<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>George&#39;s Blog</title>
  
  <subtitle>个人邮箱：george_95@126.com</subtitle>
  <link href="https://georgechan95.github.io/atom.xml" rel="self"/>
  
  <link href="https://georgechan95.github.io/"/>
  <updated>2024-09-05T11:46:04.926Z</updated>
  <id>https://georgechan95.github.io/</id>
  
  <author>
    <name>George</name>
    
  </author>
  
  <generator uri="https://hexo.io/">Hexo</generator>
  
  <entry>
    <title>04-集合的线程安全</title>
    <link href="https://georgechan95.github.io/blog/9a09d992.html"/>
    <id>https://georgechan95.github.io/blog/9a09d992.html</id>
    <published>2024-09-04T13:09:05.000Z</published>
    <updated>2024-09-05T11:46:04.926Z</updated>
    
    <content type="html"><![CDATA[<h1 id="一、ArrayList线程安全的操作"><a href="#一、ArrayList线程安全的操作" class="headerlink" title="一、ArrayList线程安全的操作"></a>一、ArrayList线程安全的操作</h1><h2 id="1-集合不安全的演示"><a href="#1-集合不安全的演示" class="headerlink" title="1. 集合不安全的演示"></a>1. 集合不安全的演示</h2><pre><code class="highlight java"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">NotSafeDemo</span> &#123;    <span class="comment">/**</span><span class="comment">     * 多个线程同时对集合进行修改</span><span class="comment">     * <span class="doctag">@param</span> args</span><span class="comment">     */</span>    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;        <span class="type">List</span> <span class="variable">list</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ArrayList</span>();        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; <span class="number">100</span>; i++) &#123;            <span class="keyword">new</span> <span class="title class_">Thread</span>(() -&gt;&#123;                list.add(UUID.randomUUID().toString());                System.out.println(list);            &#125;, <span class="string">&quot;线程&quot;</span> + i).start();        &#125;    &#125;&#125;</code></pre><p><strong>运行结果：</strong></p><pre><code class="highlight shell">Exception in thread &quot;线程93&quot; java.util.ConcurrentModificationExceptionat java.base/java.util.ArrayList$Itr.checkForComodification(ArrayList.java:1013)at java.base/java.util.ArrayList$Itr.next(ArrayList.java:967)at java.base/java.util.AbstractCollection.toString(AbstractCollection.java:456)at java.base/java.lang.String.valueOf(String.java:4222)at java.base/java.io.PrintStream.println(PrintStream.java:1047)</code></pre><p><strong>ArrayList add() 方法原码</strong></p><pre><code class="highlight java"><span class="comment">/**</span><span class="comment"> * Appends the specified element to the end of this list.</span><span class="comment"> *</span><span class="comment"> * <span class="doctag">@param</span> e element to be appended to this list</span><span class="comment"> * <span class="doctag">@return</span> &#123;<span class="doctag">@code</span> true&#125; (as specified by &#123;<span class="doctag">@link</span> Collection#add&#125;)</span><span class="comment"> */</span><span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">add</span><span class="params">(E e)</span> &#123;    modCount++;    add(e, elementData, size);    <span class="keyword">return</span> <span class="literal">true</span>;&#125;</code></pre><p>add() 方法没有加锁，是不安全的操作。</p><p><strong>如何去解决 List 类型的线程安全问题?</strong></p><h2 id="2-Vector"><a href="#2-Vector" class="headerlink" title="2. Vector"></a>2. Vector</h2><p>Vector 是<strong>矢量队列</strong>，它是 JDK1.0 版本添加的类。继承于 AbstractList，实现了 List, RandomAccess, Cloneable 这些接口。 Vector 继承了 AbstractList，实现了 List；所以，<strong>它是一个队列，支持相关的添加、删除、修改、遍历等功能</strong>。 Vector 实现了 RandmoAccess 接口，即<strong>提供了随机访问功能</strong>。RandmoAccess 是 java 中用来被 List 实现，为 List 提供快速访问功能的。在Vector 中，我们即可以通过元素的序号快速获取元素对象；这就是快速随机访问。 Vector 实现了 Cloneable 接口，即实现 clone()函数。它能被克隆。</p><p><strong>和 ArrayList 不同，Vector 中的操作是线程安全的。</strong></p><p>使用 <strong>Vector</strong> 对 Demo 进行修改</p><pre><code class="highlight java"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">VectorDemo</span> &#123;    <span class="comment">/**</span><span class="comment">     * 多个线程同时对集合进行修改</span><span class="comment">     * <span class="doctag">@param</span> args</span><span class="comment">     */</span>    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;        <span class="type">List</span> <span class="variable">list</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Vector</span>();        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; <span class="number">100</span>; i++) &#123;            <span class="keyword">new</span> <span class="title class_">Thread</span>(() -&gt;&#123;                list.add(UUID.randomUUID().toString());                System.out.println(list);            &#125;, <span class="string">&quot;线程&quot;</span> + i).start();        &#125;    &#125;&#125;</code></pre><p><strong>运行结果：无异常</strong></p><p>查看Vector add() 方法</p><pre><code class="highlight java"><span class="comment">/**</span><span class="comment"> * Appends the specified element to the end of this Vector.</span><span class="comment"> *</span><span class="comment"> * <span class="doctag">@param</span> e element to be appended to this Vector</span><span class="comment"> * <span class="doctag">@return</span> &#123;<span class="doctag">@code</span> true&#125; (as specified by &#123;<span class="doctag">@link</span> Collection#add&#125;)</span><span class="comment"> * <span class="doctag">@since</span> 1.2</span><span class="comment"> */</span><span class="keyword">public</span> <span class="keyword">synchronized</span> <span class="type">boolean</span> <span class="title function_">add</span><span class="params">(E e)</span> &#123;    modCount++;    add(e, elementData, elementCount);    <span class="keyword">return</span> <span class="literal">true</span>;&#125;</code></pre><p><code>add()</code> 方法添加了 <code>synchronized</code> 这是线程安全的操作。</p><h2 id="3-Collections"><a href="#3-Collections" class="headerlink" title="3. Collections"></a>3. Collections</h2><p>Collections 提供了方法 synchronizedList 保证 list 是同步线程安全的。</p><pre><code class="highlight java"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">CollectionsDemo</span> &#123;    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;        List&lt;Object&gt; list = Collections.synchronizedList(<span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;());        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; <span class="number">100</span>; i++) &#123;            <span class="keyword">new</span> <span class="title class_">Thread</span>(() -&gt;&#123;                list.add(UUID.randomUUID().toString());                System.out.println(list);            &#125;, <span class="string">&quot;线程&quot;</span> + i).start();        &#125;    &#125;&#125;</code></pre><p><strong>运行结果：没有异常</strong></p><p><strong>查看原码：</strong></p><pre><code class="highlight java"><span class="comment">/**</span><span class="comment"> * Returns a synchronized (thread-safe) list backed by the specified</span><span class="comment"> * list.  In order to guarantee serial access, it is critical that</span><span class="comment"> * &lt;strong&gt;all&lt;/strong&gt; access to the backing list is accomplished</span><span class="comment"> * through the returned list.&lt;p&gt;</span><span class="comment"> *</span><span class="comment"> * It is imperative that the user manually synchronize on the returned</span><span class="comment"> * list when traversing it via &#123;<span class="doctag">@link</span> Iterator&#125;, &#123;<span class="doctag">@link</span> Spliterator&#125;</span><span class="comment"> * or &#123;<span class="doctag">@link</span> Stream&#125;:</span><span class="comment"> * &lt;pre&gt;</span><span class="comment"> *  List list = Collections.synchronizedList(new ArrayList());</span><span class="comment"> *      ...</span><span class="comment"> *  synchronized (list) &#123;</span><span class="comment"> *      Iterator i = list.iterator(); // Must be in synchronized block</span><span class="comment"> *      while (i.hasNext())</span><span class="comment"> *          foo(i.next());</span><span class="comment"> *  &#125;</span><span class="comment"> * &lt;/pre&gt;</span><span class="comment"> * Failure to follow this advice may result in non-deterministic behavior.</span><span class="comment"> *</span><span class="comment"> * &lt;p&gt;The returned list will be serializable if the specified list is</span><span class="comment"> * serializable.</span><span class="comment"> *</span><span class="comment"> * <span class="doctag">@param</span>  &lt;T&gt; the class of the objects in the list</span><span class="comment"> * <span class="doctag">@param</span>  list the list to be &quot;wrapped&quot; in a synchronized list.</span><span class="comment"> * <span class="doctag">@return</span> a synchronized view of the specified list.</span><span class="comment"> */</span><span class="keyword">public</span> <span class="keyword">static</span> &lt;T&gt; List&lt;T&gt; <span class="title function_">synchronizedList</span><span class="params">(List&lt;T&gt; list)</span> &#123;    <span class="keyword">return</span> (list <span class="keyword">instanceof</span> RandomAccess ?            <span class="keyword">new</span> <span class="title class_">SynchronizedRandomAccessList</span>&lt;&gt;(list) :            <span class="keyword">new</span> <span class="title class_">SynchronizedList</span>&lt;&gt;(list));&#125;</code></pre><h2 id="4-CopyOnWriteArrayList-重点"><a href="#4-CopyOnWriteArrayList-重点" class="headerlink" title="4. CopyOnWriteArrayList (重点)"></a>4. CopyOnWriteArrayList (重点)</h2><p>CopyOnWriteArrayList 是线程安全的 ArrayList，具有以下特性：</p><ul><li>它最适合于具有以下特征的应用程序：List 大小通常保持很小，只读操作远多于可变操作，需要在遍历期间防止线程间的冲突。</li><li>它是线程安全的。</li><li>因为通常需要复制整个基础数组，所以可变操作（add()、set() 和 remove() 等等）的开销很大</li><li>迭代器支持 hasNext(), next()等不可变操作，但不支持可变 remove()等操作。</li><li>使用迭代器进行遍历的速度很快，并且不会与其他线程发生冲突。在构造迭代器时，迭代器依赖于不变的数组快照。</li></ul><p>当我们往一个容器添加元素的时候，不直接往当前容器添加，而是先将当前容器进行 Copy，复制出一个新的容器，然后新的容器里添加元素，添加完元素之后，再将原容器的引用指向新的容器。</p><p><strong>这时候会抛出来一个新的问题，也就是数据不一致的问题。如果写线程还没来得及写完并切换引用，其他的线程就会读到了脏数据</strong></p><p><strong>代码示例</strong></p><pre><code class="highlight java"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">CopyOnWriteArrayListDemo</span> &#123;    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;        CopyOnWriteArrayList&lt;String&gt; list = <span class="keyword">new</span> <span class="title class_">CopyOnWriteArrayList</span>&lt;&gt;();        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; <span class="number">100</span>; i++) &#123;            <span class="keyword">new</span> <span class="title class_">Thread</span>(() -&gt;&#123;                list.add(UUID.randomUUID().toString());                System.out.println(list);            &#125;, <span class="string">&quot;线程&quot;</span> + i).start();        &#125;    &#125;&#125;</code></pre><p>运行结果：没有线程安全问题</p><p>下面从“动态数组”和“线程安全”两个方面进一步对CopyOnWriteArrayList 的原理进行说明。</p><ul><li><strong>“动态数组”机制</strong><ul><li>它内部有个“volatile 数组”(array)来保持数据。在“添加&#x2F;修改&#x2F;删除”数据时，都会新建一个数组，并将更新后的数据拷贝到新建的数组中，最后再将该数组赋值给“volatile 数组”, 这就是它叫做 CopyOnWriteArrayList 的原因</li><li><strong>由于它在“添加&#x2F;修改&#x2F;删除”数据时，都会新建数组，所以涉及到修改数据的操作，CopyOnWriteArrayList 效率很低；但是单单只是进行遍历查找的话，效率比较高。</strong></li></ul></li><li><strong>“线程安全”机制</strong><ul><li>通过 volatile 和互斥锁来实现的。</li><li>通过“volatile 数组”来保存数据的。一个线程读取 volatile 数组时，总能看到其它线程对该 volatile 变量最后的写入；就这样，通过 volatile 提供了“读取到的数据总是最新的”这个机制的保证。</li><li>通过互斥锁来保护数据。在“添加&#x2F;修改&#x2F;删除”数据时，会先“获取互斥锁”，再修改完毕之后，先将数据更新到 “volatile 数组” 中，然后再 “释放互斥锁”，就达到了保护数据的目的。</li></ul></li></ul><h1 id="二、HashSet-线程安全的操作"><a href="#二、HashSet-线程安全的操作" class="headerlink" title="二、HashSet 线程安全的操作"></a>二、HashSet 线程安全的操作</h1><p>解决方案 CopyOnWriteArraySet</p><pre><code class="highlight java"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">CopyOnWriteArraySetDemo</span> &#123;    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;        <span class="comment">// 线程不安全的操作</span><span class="comment">//        HashSet&lt;String&gt; set = new HashSet&lt;&gt;();</span>        <span class="comment">// 线程安全的操作</span>        CopyOnWriteArraySet&lt;String&gt; set = <span class="keyword">new</span> <span class="title class_">CopyOnWriteArraySet</span>&lt;&gt;();        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; <span class="number">1000</span>; i++) &#123;            <span class="keyword">new</span> <span class="title class_">Thread</span>(() -&gt;&#123;                set.add(UUID.randomUUID().toString());                System.out.println(set);            &#125;, <span class="string">&quot;线程&quot;</span> + i).start();        &#125;    &#125;&#125;</code></pre><h1 id="三、HashMap-线程安全的操作"><a href="#三、HashMap-线程安全的操作" class="headerlink" title="三、HashMap 线程安全的操作"></a>三、HashMap 线程安全的操作</h1><p>解决方案 ConcurrentHashMap</p><pre><code class="highlight java"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ConcurrentHashMapDemo</span> &#123;    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;        <span class="comment">// 线程不安全的操作</span><span class="comment">//        HashMap&lt;String, String&gt; map = new HashMap&lt;&gt;();</span>        <span class="comment">// 线程安全的操作</span>        ConcurrentHashMap&lt;String, String&gt; map = <span class="keyword">new</span> <span class="title class_">ConcurrentHashMap</span>&lt;&gt;();        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; <span class="number">1000</span>; i++) &#123;            <span class="keyword">new</span> <span class="title class_">Thread</span>(() -&gt;&#123;                map.put(UUID.randomUUID().toString(), <span class="string">&quot;1&quot;</span>);                System.out.println(map.values());            &#125;, <span class="string">&quot;线程&quot;</span> + i).start();        &#125;    &#125;&#125;</code></pre>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;一、ArrayList线程安全的操作&quot;&gt;&lt;a href=&quot;#一、ArrayList线程安全的操作&quot; class=&quot;headerlink&quot; title=&quot;一、ArrayList线程安全的操作&quot;&gt;&lt;/a&gt;一、ArrayList线程安全的操作&lt;/h1&gt;&lt;h2 id=&quot;1</summary>
      
    
    
    
    <category term="JUC" scheme="https://georgechan95.github.io/categories/JUC/"/>
    
    
    <category term="juc" scheme="https://georgechan95.github.io/tags/juc/"/>
    
    <category term="java" scheme="https://georgechan95.github.io/tags/java/"/>
    
  </entry>
  
  <entry>
    <title>03-线程间通信</title>
    <link href="https://georgechan95.github.io/blog/bd2134da.html"/>
    <id>https://georgechan95.github.io/blog/bd2134da.html</id>
    <published>2024-09-04T12:06:00.000Z</published>
    <updated>2024-09-04T00:31:04.024Z</updated>
    
    <content type="html"><![CDATA[<h1 id="一、线程间通信"><a href="#一、线程间通信" class="headerlink" title="一、线程间通信"></a>一、线程间通信</h1><p>线程间通信的模型有两种：共享内存和消息传递，以下方式都是基本这两种模型来实现的。我们来基本一道面试常见的题目来分析</p><p><strong>场景—两个线程，一个线程对当前数值加 1，另一个线程对当前数值减 1,要求用线程间通信</strong></p><h2 id="1-synchronized-方案"><a href="#1-synchronized-方案" class="headerlink" title="1. synchronized 方案"></a>1. synchronized 方案</h2><pre><code class="highlight java"><span class="keyword">class</span> <span class="title class_">TestVolatile</span> &#123;    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;        <span class="type">DemoClass</span> <span class="variable">demoClass</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">DemoClass</span>();        <span class="keyword">new</span> <span class="title class_">Thread</span>(() -&gt; &#123;            <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; <span class="number">10</span>; i++) &#123;                <span class="keyword">try</span> &#123;                    demoClass.increment();                &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;                    <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">RuntimeException</span>(e);                &#125;            &#125;        &#125;, <span class="string">&quot;线程A&quot;</span>).start();        <span class="keyword">new</span> <span class="title class_">Thread</span>(() -&gt; &#123;            <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; <span class="number">10</span>; i++) &#123;                <span class="keyword">try</span> &#123;                    demoClass.decrement();                &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;                    <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">RuntimeException</span>(e);                &#125;            &#125;        &#125;, <span class="string">&quot;线程B&quot;</span>).start();    &#125;&#125;<span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">DemoClass</span> &#123;    <span class="keyword">private</span> <span class="type">int</span> <span class="variable">number</span> <span class="operator">=</span> <span class="number">0</span>;    <span class="keyword">public</span> <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title function_">increment</span><span class="params">()</span> <span class="keyword">throws</span> InterruptedException &#123;        <span class="keyword">while</span> (number != <span class="number">0</span>) &#123;            <span class="built_in">this</span>.wait();        &#125;        number++;        System.out.println(Thread.currentThread().getName() + <span class="string">&quot;执行了加1操作，当前值为：&quot;</span> + number);        notifyAll();    &#125;    <span class="keyword">public</span> <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title function_">decrement</span><span class="params">()</span> <span class="keyword">throws</span> InterruptedException &#123;        <span class="keyword">while</span> (number != <span class="number">1</span>) &#123;            <span class="built_in">this</span>.wait();        &#125;        number--;        System.out.println(Thread.currentThread().getName() + <span class="string">&quot;执行了减1操作，当前值为：&quot;</span> + number);        notifyAll();    &#125;&#125;</code></pre><h2 id="2-Lock-方案"><a href="#2-Lock-方案" class="headerlink" title="2. Lock 方案"></a>2. Lock 方案</h2><pre><code class="highlight java"><span class="keyword">class</span> <span class="title class_">ShareNum</span> &#123;    <span class="keyword">private</span> <span class="type">int</span> <span class="variable">number</span> <span class="operator">=</span> <span class="number">0</span>;    <span class="keyword">private</span> <span class="type">ReentrantLock</span> <span class="variable">lock</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ReentrantLock</span>(<span class="literal">true</span>);    <span class="keyword">private</span> <span class="type">Condition</span> <span class="variable">condition</span> <span class="operator">=</span> lock.newCondition();    <span class="comment">// ++操作</span>    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">increase</span><span class="params">()</span> &#123;        <span class="comment">// 上锁</span>        lock.lock();        <span class="keyword">try</span> &#123;            <span class="keyword">while</span> (number != <span class="number">0</span>) &#123;                condition.await();            &#125;            <span class="comment">// 执行 ++ 操作</span>            number++;            System.out.println(Thread.currentThread().getName() + <span class="string">&quot;执行了 ++ 操作，当前number值为：&quot;</span> + number);            <span class="comment">// 唤醒其它线程</span>            condition.signalAll();        &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;            <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">RuntimeException</span>(e);        &#125; <span class="keyword">finally</span> &#123;            <span class="comment">// 解锁</span>            lock.unlock();        &#125;    &#125;    <span class="comment">// -- 操作</span>    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">decrease</span><span class="params">()</span> &#123;        <span class="comment">// 上锁</span>        lock.lock();        <span class="keyword">try</span> &#123;            <span class="keyword">while</span> (number != <span class="number">1</span>) &#123;                condition.await();            &#125;            <span class="comment">// 执行 -- 操作</span>            number--;            System.out.println(Thread.currentThread().getName() + <span class="string">&quot;执行了 -- 操作，当前number值为：&quot;</span> + number);            <span class="comment">// 唤醒其它线程</span>            condition.signalAll();        &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;            <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">RuntimeException</span>(e);        &#125; <span class="keyword">finally</span> &#123;            <span class="comment">// 解锁</span>            lock.unlock();        &#125;    &#125;&#125;<span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ConditionDemo</span> &#123;    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;        <span class="type">ShareNum</span> <span class="variable">shareNum</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ShareNum</span>();        <span class="keyword">new</span> <span class="title class_">Thread</span>(() -&gt; &#123;            <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; <span class="number">10</span>; i++) &#123;                shareNum.increase();            &#125;        &#125;, <span class="string">&quot;AA&quot;</span>).start();        <span class="keyword">new</span> <span class="title class_">Thread</span>(() -&gt; &#123;            <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; <span class="number">10</span>; i++) &#123;                shareNum.decrease();            &#125;        &#125;, <span class="string">&quot;BB&quot;</span>).start();        <span class="keyword">new</span> <span class="title class_">Thread</span>(() -&gt; &#123;            <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; <span class="number">10</span>; i++) &#123;                shareNum.increase();            &#125;        &#125;, <span class="string">&quot;CC&quot;</span>).start();        <span class="keyword">new</span> <span class="title class_">Thread</span>(() -&gt; &#123;            <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; <span class="number">10</span>; i++) &#123;                shareNum.decrease();            &#125;        &#125;, <span class="string">&quot;DD&quot;</span>).start();    &#125;&#125;</code></pre><h1 id="二、线程间定制化通信"><a href="#二、线程间定制化通信" class="headerlink" title="二、线程间定制化通信"></a>二、线程间定制化通信</h1><h2 id="1-案例介绍"><a href="#1-案例介绍" class="headerlink" title="1. 案例介绍"></a>1. 案例介绍</h2><p><strong>A 线程打印 5 次 A，B 线程打印 10 次 B，C 线程打印 15 次 C,按照此顺序循环 10 轮</strong></p><h2 id="2-实现过程"><a href="#2-实现过程" class="headerlink" title="2. 实现过程"></a>2. 实现过程</h2><pre><code class="highlight java"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">PrintTest</span> &#123;    <span class="comment">// 线程通信标识：0-线程A  1-线程B  2-线程C</span>    <span class="keyword">private</span> <span class="type">int</span> <span class="variable">number</span> <span class="operator">=</span> <span class="number">0</span>;    <span class="comment">// 创建锁</span>    <span class="keyword">private</span> <span class="type">Lock</span> <span class="variable">lock</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ReentrantLock</span>();    <span class="comment">// 线程A的通信钥匙</span>    <span class="keyword">private</span> <span class="type">Condition</span> <span class="variable">conditionA</span> <span class="operator">=</span>lock.newCondition();    <span class="comment">// 线程B的通信钥匙</span>    <span class="keyword">private</span> <span class="type">Condition</span> <span class="variable">conditionB</span> <span class="operator">=</span>lock.newCondition();    <span class="comment">// 线程C的通信钥匙</span>    <span class="keyword">private</span> <span class="type">Condition</span> <span class="variable">conditionC</span> <span class="operator">=</span>lock.newCondition();    <span class="comment">/**</span><span class="comment">     * 打印五次A</span><span class="comment">     */</span>    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">printA</span><span class="params">(<span class="type">int</span> round)</span> &#123;        <span class="keyword">try</span> &#123;            lock.lock();            <span class="keyword">while</span> (number != <span class="number">0</span>) &#123;                conditionA.await(); <span class="comment">// 等待并释放锁</span>            &#125;            <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; <span class="number">5</span>; i++) &#123;                System.out.println(<span class="string">&quot;第 &quot;</span> + round + <span class="string">&quot;轮：&quot;</span> + Thread.currentThread().getName() + <span class="string">&quot;执行中，开始打印：=== A ===&quot;</span>);            &#125;            <span class="comment">// 打印B</span>            number = <span class="number">1</span>;            conditionB.signal();        &#125; <span class="keyword">catch</span> (Exception e) &#123;        &#125; <span class="keyword">finally</span> &#123;            lock.unlock();        &#125;    &#125;    <span class="comment">/**</span><span class="comment">     * 打印10次B</span><span class="comment">     */</span>    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">printB</span><span class="params">(<span class="type">int</span> round)</span> &#123;        <span class="keyword">try</span> &#123;            lock.lock();            <span class="keyword">while</span> (number != <span class="number">1</span>) &#123;                conditionB.await(); <span class="comment">// 等待并释放锁</span>            &#125;            <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; <span class="number">10</span>; i++) &#123;                System.out.println(<span class="string">&quot;第 &quot;</span> + round + <span class="string">&quot;轮：&quot;</span> + Thread.currentThread().getName() + <span class="string">&quot;执行中，开始打印：=== B ===&quot;</span>);            &#125;            <span class="comment">// 打印B</span>            number = <span class="number">2</span>;            conditionC.signal();        &#125; <span class="keyword">catch</span> (Exception e) &#123;        &#125; <span class="keyword">finally</span> &#123;            lock.unlock();        &#125;    &#125;    <span class="comment">/**</span><span class="comment">     * 打印15次C</span><span class="comment">     */</span>    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">printC</span><span class="params">(<span class="type">int</span> round)</span> &#123;        <span class="keyword">try</span> &#123;            lock.lock();            <span class="keyword">while</span> (number != <span class="number">2</span>) &#123;                conditionC.await(); <span class="comment">// 等待并释放锁</span>            &#125;            <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; <span class="number">15</span>; i++) &#123;                System.out.println(<span class="string">&quot;第 &quot;</span> + round + <span class="string">&quot;轮：&quot;</span> + Thread.currentThread().getName() + <span class="string">&quot;执行中，开始打印：=== C ===&quot;</span>);            &#125;            <span class="comment">// 打印B</span>            number = <span class="number">0</span>;            conditionA.signal();        &#125; <span class="keyword">catch</span> (Exception e) &#123;        &#125; <span class="keyword">finally</span> &#123;            lock.unlock();        &#125;    &#125;&#125;<span class="keyword">class</span> <span class="title class_">MainClass</span> &#123;    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;        <span class="type">PrintTest</span> <span class="variable">printTest</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">PrintTest</span>();        <span class="keyword">new</span> <span class="title class_">Thread</span>(() -&gt; &#123;            <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; <span class="number">10</span>; i++) &#123;                printTest.printA(i);            &#125;        &#125;, <span class="string">&quot;线程A&quot;</span>).start();        <span class="keyword">new</span> <span class="title class_">Thread</span>(() -&gt; &#123;            <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; <span class="number">10</span>; i++) &#123;                printTest.printB(i);            &#125;        &#125;, <span class="string">&quot;线程B&quot;</span>).start();        <span class="keyword">new</span> <span class="title class_">Thread</span>(() -&gt; &#123;            <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; <span class="number">10</span>; i++) &#123;                printTest.printC(i);            &#125;        &#125;, <span class="string">&quot;线程C&quot;</span>).start();    &#125;&#125;</code></pre>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;一、线程间通信&quot;&gt;&lt;a href=&quot;#一、线程间通信&quot; class=&quot;headerlink&quot; title=&quot;一、线程间通信&quot;&gt;&lt;/a&gt;一、线程间通信&lt;/h1&gt;&lt;p&gt;线程间通信的模型有两种：共享内存和消息传递，以下方式都是基本这两种模型来实现的。我们来基本一道面试常</summary>
      
    
    
    
    <category term="JUC" scheme="https://georgechan95.github.io/categories/JUC/"/>
    
    
    <category term="juc" scheme="https://georgechan95.github.io/tags/juc/"/>
    
    <category term="java" scheme="https://georgechan95.github.io/tags/java/"/>
    
  </entry>
  
  <entry>
    <title>02-Lock接口</title>
    <link href="https://georgechan95.github.io/blog/850dac3c.html"/>
    <id>https://georgechan95.github.io/blog/850dac3c.html</id>
    <published>2024-08-30T11:27:00.000Z</published>
    <updated>2024-09-03T23:45:00.212Z</updated>
    
    <content type="html"><![CDATA[<h1 id="一、Synchronized"><a href="#一、Synchronized" class="headerlink" title="一、Synchronized"></a>一、Synchronized</h1><h2 id="1-Synchronized-关键字回顾"><a href="#1-Synchronized-关键字回顾" class="headerlink" title="1. Synchronized 关键字回顾"></a>1. Synchronized 关键字回顾</h2><p>synchronized 是 Java 中的关键字，是一种同步锁。它修饰的对象有以下几种：</p><ul><li><p>修饰一个代码块，被修饰的代码块称为同步语句块，其作用的范围是 大括号{} 括起来的代码，作用的对象是调用这个代码块的对象；</p></li><li><p>修饰一个方法，被修饰的方法称为同步方法，其作用的范围是整个方法，作用的对象是调用这个方法的对象；</p><p>虽然可以使用 synchronized 来定义方法，但 synchronized 并不属于方法定义的一部分，因此，<strong>synchronized 关键字不能被继承</strong>。如果在父类中的某个方法使用了 synchronized 关键字，而在子类中覆盖了这个方法，在子类中的这个方法默认情况下并不是同步的，而必须显式地在子类的这个方法中加上synchronized 关键字才可以。当然，还可以在子类方法中调用父类中相应的方法，这样虽然子类中的方法不是同步的，但子类调用了父类的同步方法，因此，子类的方法也就相当于同步了。</p></li><li><p>修改一个静态的方法，其作用的范围是整个静态方法，作用的对象是这个类的所有对象；</p></li><li><p>修改一个类，其作用的范围是 synchronized 后面括号括起来的部分，作用主的对象是这个类的所有对象。</p></li></ul><h2 id="2-Synchronized案例"><a href="#2-Synchronized案例" class="headerlink" title="2. Synchronized案例"></a>2. Synchronized案例</h2><p>使用 synchronized 完成售票案例</p><pre><code class="highlight java"><span class="comment">//第一步  创建资源类，定义属性和和操作方法</span><span class="keyword">class</span> <span class="title class_">Ticket</span> &#123;    <span class="comment">//票数</span>    <span class="keyword">private</span> <span class="type">int</span> <span class="variable">number</span> <span class="operator">=</span> <span class="number">30</span>;    <span class="comment">//操作方法：卖票</span>    <span class="keyword">public</span> <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title function_">sale</span><span class="params">()</span> &#123;        <span class="comment">//判断：是否有票</span>        <span class="keyword">if</span>(number &gt; <span class="number">0</span>) &#123;            System.out.println(Thread.currentThread().getName()+<span class="string">&quot; : 卖出：&quot;</span>+(number--)+<span class="string">&quot; 剩下：&quot;</span>+number);        &#125;    &#125;&#125;<span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">SaleTicket</span> &#123;    <span class="comment">//第二步 创建多个线程，调用资源类的操作方法</span>    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;        <span class="comment">//创建Ticket对象</span>        <span class="type">Ticket</span> <span class="variable">ticket</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Ticket</span>();        <span class="comment">//创建三个线程</span>        <span class="keyword">new</span> <span class="title class_">Thread</span>(<span class="keyword">new</span> <span class="title class_">Runnable</span>() &#123;            <span class="meta">@Override</span>            <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span> &#123;                <span class="comment">//调用卖票方法</span>                <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; <span class="number">40</span>; i++) &#123;                    ticket.sale();                &#125;            &#125;        &#125;,<span class="string">&quot;AA&quot;</span>).start();        <span class="keyword">new</span> <span class="title class_">Thread</span>(<span class="keyword">new</span> <span class="title class_">Runnable</span>() &#123;            <span class="meta">@Override</span>            <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span> &#123;                <span class="comment">//调用卖票方法</span>                <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; <span class="number">40</span>; i++) &#123;                    ticket.sale();                &#125;            &#125;        &#125;,<span class="string">&quot;BB&quot;</span>).start();        <span class="keyword">new</span> <span class="title class_">Thread</span>(<span class="keyword">new</span> <span class="title class_">Runnable</span>() &#123;            <span class="meta">@Override</span>            <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span> &#123;                <span class="comment">//调用卖票方法</span>                <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; <span class="number">40</span>; i++) &#123;                    ticket.sale();                &#125;            &#125;        &#125;,<span class="string">&quot;CC&quot;</span>).start();    &#125;&#125;</code></pre><ul><li>注意：Synchronized 不是公平锁，所以执行这个程序有可能会出现某个线程把票卖完，而其它线程没有执行机会的情况</li></ul><p>如果一个代码块被 synchronized 修饰了，当一个线程获取了对应的锁，并执行该代码块时，其他线程便只能一直等待，等待获取锁的线程释放锁，而这里获取锁的线程释放锁只会有两种情况：</p><ul><li>获取锁的线程执行完了该代码块，然后线程释放对锁的占有；</li><li>线程执行发生异常，此时 JVM 会让线程自动释放锁</li></ul><p>那么如果这个获取锁的线程由于要等待 IO 或者其他原因（比如调用 sleep方法）被阻塞了，但是又没有释放锁，其他线程便只能干巴巴地等待，试想一下，这多么影响程序执行效率。因此就需要有一种机制可以不让等待的线程一直无期限地等待下去（比如只等待一定的时间或者能够响应中断），通过 Lock 就可以办到。</p><h1 id="二、Lock接口"><a href="#二、Lock接口" class="headerlink" title="二、Lock接口"></a>二、Lock接口</h1><p>Lock 锁实现提供了比使用同步方法和语句可以获得的更广泛的锁操作。它们允许更灵活的结构，可能具有非常不同的属性，并且可能支持多个关联的条件对象。Lock 提供了比 synchronized 更多的功能。</p><p>Lock 与的 Synchronized 区别：</p><ul><li>Lock 不是 Java 语言内置的，synchronized 是 Java 语言的关键字，因此是内置特性。Lock 是一个类，通过这个类可以实现同步访问；</li><li>Lock 和 synchronized 有一点非常大的不同，采用 synchronized 不需要用户去手动释放锁，当 synchronized 方法或者 synchronized 代码块执行完之后，系统会自动让线程释放对锁的占用；而 Lock 则必须要用户去手动释放锁，如果没有主动释放锁，就有可能导致出现死锁现象。</li></ul><h2 id="1-Lock-接口"><a href="#1-Lock-接口" class="headerlink" title="1. Lock 接口"></a>1. Lock 接口</h2><p>接口代码路径：<code>java.util.concurrent.locks.Lock</code></p><pre><code class="highlight java"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">Lock</span> &#123;    <span class="comment">/**</span><span class="comment">     * Acquires the lock.</span><span class="comment">     */</span>    <span class="keyword">void</span> <span class="title function_">lock</span><span class="params">()</span>;    <span class="comment">/**</span><span class="comment">     * Acquires the lock unless the current thread is</span><span class="comment">     * &#123;<span class="doctag">@linkplain</span> Thread#interrupt interrupted&#125;.</span><span class="comment">     */</span>    <span class="keyword">void</span> <span class="title function_">lockInterruptibly</span><span class="params">()</span> <span class="keyword">throws</span> InterruptedException;    <span class="comment">/**</span><span class="comment">     * Acquires the lock only if it is free at the time of invocation.</span><span class="comment">     */</span>    <span class="type">boolean</span> <span class="title function_">tryLock</span><span class="params">()</span>;    <span class="comment">/**</span><span class="comment">     * Acquires the lock if it is free within the given waiting time and the</span><span class="comment">     * current thread has not been &#123;<span class="doctag">@linkplain</span> Thread#interrupt interrupted&#125;.</span><span class="comment">     */</span>    <span class="type">boolean</span> <span class="title function_">tryLock</span><span class="params">(<span class="type">long</span> time, TimeUnit unit)</span> <span class="keyword">throws</span> InterruptedException;    <span class="comment">/**</span><span class="comment">     * Releases the lock.</span><span class="comment">     */</span>    <span class="keyword">void</span> <span class="title function_">unlock</span><span class="params">()</span>;    <span class="comment">/**</span><span class="comment">     * Returns a new &#123;<span class="doctag">@link</span> Condition&#125; instance that is bound to this</span><span class="comment">     */</span>    Condition <span class="title function_">newCondition</span><span class="params">()</span>;&#125;</code></pre><p>下面来逐个讲述 Lock 接口中每个方法的使用</p><h3 id="1-1-lock-方法"><a href="#1-1-lock-方法" class="headerlink" title="1.1 lock() 方法"></a>1.1 <code>lock()</code> 方法</h3><p>lock()方法是平常使用得最多的一个方法，就是用来获取锁。如果锁已被其他线程获取，则进行等待。</p><p>采用 Lock，必须主动去释放锁，并且在发生异常时，不会自动释放锁。因此一般来说，使用 Lock 必须在 <code>try&#123;&#125;catch&#123;&#125;</code> 块中进行，并且将释放锁的操作放在<code>finally</code> 块中进行，以保证锁一定被被释放，防止死锁的发生。通常使用 Lock来进行同步的话，是以下面这种形式去使用的：</p><pre><code class="highlight java">lock.lock();<span class="keyword">try</span> &#123;<span class="comment">//处理任务</span>&#125; <span class="keyword">catch</span> (Exception e) &#123;&#125; <span class="keyword">finally</span> &#123;    lock.unlock(); <span class="comment">//释放锁</span>&#125;</code></pre><p><strong>测试案例：买票</strong></p><p>三个售票员，同时卖30张票，不能超卖。</p><p>使用 <code>ReentrantLock</code></p><pre><code class="highlight java"><span class="comment">// 定义资源类、属性、方法</span><span class="keyword">class</span> <span class="title class_">LTickets</span> &#123;    <span class="comment">//票数量</span>    <span class="keyword">private</span> <span class="type">int</span> <span class="variable">num</span> <span class="operator">=</span> <span class="number">30</span>;    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">getNum</span><span class="params">()</span> &#123;        <span class="keyword">return</span> num;    &#125;    <span class="comment">// 创建可重入锁</span>    <span class="keyword">private</span> <span class="type">ReentrantLock</span> <span class="variable">lock</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ReentrantLock</span>(<span class="literal">true</span>);    <span class="comment">//卖票方法</span>    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">sale</span><span class="params">()</span> &#123;        <span class="comment">//上锁</span>        lock.lock();        <span class="keyword">try</span> &#123;            <span class="comment">// 判断是否还有票</span>            <span class="keyword">if</span> (num &gt; <span class="number">0</span>) &#123;                System.out.println(Thread.currentThread().getName() + <span class="string">&quot; 卖出1张票,还剩：&quot;</span> + --num +<span class="string">&quot; 张票&quot;</span>);            &#125;        &#125; <span class="keyword">finally</span> &#123;            <span class="comment">// 解锁</span>            lock.unlock();        &#125;    &#125;&#125;<span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ReentrantLockDemo</span> &#123;    <span class="comment">//第二步 创建多个线程，调用资源类的操作方法</span>    <span class="comment">//创建三个线程</span>    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;        <span class="type">LTickets</span> <span class="variable">lTickets</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">LTickets</span>();        <span class="keyword">new</span> <span class="title class_">Thread</span>(() -&gt; &#123;            <span class="keyword">while</span> (lTickets.getNum() &gt; <span class="number">0</span>) &#123;                lTickets.sale();            &#125;        &#125;, <span class="string">&quot;售票员1&quot;</span>).start();        <span class="keyword">new</span> <span class="title class_">Thread</span>(() -&gt; &#123;            <span class="keyword">while</span> (lTickets.getNum() &gt; <span class="number">0</span>) &#123;                lTickets.sale();            &#125;        &#125;, <span class="string">&quot;售票员2&quot;</span>).start();        <span class="keyword">new</span> <span class="title class_">Thread</span>(() -&gt; &#123;            <span class="keyword">while</span> (lTickets.getNum() &gt; <span class="number">0</span>) &#123;                lTickets.sale();            &#125;        &#125;, <span class="string">&quot;售票员3&quot;</span>).start();    &#125;&#125;</code></pre><p><strong>运行结果</strong></p><pre><code class="highlight txt">售票员1 卖出1张票,还剩：29 张票售票员2 卖出1张票,还剩：28 张票售票员3 卖出1张票,还剩：27 张票......售票员3 卖出1张票,还剩：3 张票售票员1 卖出1张票,还剩：2 张票售票员2 卖出1张票,还剩：1 张票售票员3 卖出1张票,还剩：0 张票</code></pre><h3 id="1-2-newCondition-方法"><a href="#1-2-newCondition-方法" class="headerlink" title="1.2 newCondition() 方法"></a>1.2 <code>newCondition()</code> 方法</h3><p>关键字 <code>synchronized</code> 与 <code>wait()</code> &#x2F; <code>notify()</code> 这两个方法一起使用可以实现等待&#x2F;通知模式， Lock 锁的 <code>newContition()</code> 方法返回 Condition 对象，Condition 类也可以实现等待&#x2F;通知模式。</p><p>用 <code>notify()</code> 通知时，JVM 会随机唤醒某个等待的线程， 使用 Condition 类可以进行选择性通知， Condition 比较常用的两个方法：</p><ul><li><code>await()</code> 会使当前线程等待,同时会释放锁,当其他线程调用 <code>signal()</code> 时,线程会重新获得锁并继续执行。</li><li><code>signal()</code> 用于唤醒一个等待的线程。</li></ul><p>注意：在调用 Condition 的 <code>await()/signal()</code> 方法前，也需要线程持有相关的 Lock 锁，调用 <code>await()</code> 后线程会释放这个锁，在 <code>singal()</code> 调用后会从当前Condition 对象的等待队列中，唤醒 一个线程，唤醒的线程尝试获得锁， 一旦获得锁成功就继续执行。</p><h4 id="测试案例"><a href="#测试案例" class="headerlink" title="测试案例"></a>测试案例</h4><p>当前有一个变量 number，初始值是0，创建四个线程同时修改次变量，线程AA、线程CC对变量做++操作， 线程BB、线程DD对变量做–操作。每个线程都执行10次</p><pre><code class="highlight java"><span class="keyword">class</span> <span class="title class_">ShareNum</span> &#123;    <span class="keyword">private</span> <span class="type">int</span> <span class="variable">number</span> <span class="operator">=</span> <span class="number">0</span>;    <span class="keyword">private</span> <span class="type">ReentrantLock</span> <span class="variable">lock</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ReentrantLock</span>(<span class="literal">true</span>);    <span class="keyword">private</span> <span class="type">Condition</span> <span class="variable">condition</span> <span class="operator">=</span> lock.newCondition();    <span class="comment">// ++操作</span>    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">increase</span><span class="params">()</span> &#123;        <span class="comment">// 上锁</span>        lock.lock();        <span class="keyword">try</span> &#123;            <span class="keyword">while</span> (number != <span class="number">0</span>) &#123;                condition.await();            &#125;            <span class="comment">// 执行 ++ 操作</span>            number++;            System.out.println(Thread.currentThread().getName() + <span class="string">&quot;执行了 ++ 操作，当前number值为：&quot;</span> + number);            <span class="comment">// 唤醒其它线程</span>            condition.signalAll();        &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;            <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">RuntimeException</span>(e);        &#125; <span class="keyword">finally</span> &#123;            <span class="comment">// 解锁</span>            lock.unlock();        &#125;    &#125;    <span class="comment">// -- 操作</span>    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">decrease</span><span class="params">()</span> &#123;        <span class="comment">// 上锁</span>        lock.lock();        <span class="keyword">try</span> &#123;            <span class="keyword">while</span> (number != <span class="number">1</span>) &#123;                condition.await();            &#125;            <span class="comment">// 执行 -- 操作</span>            number--;            System.out.println(Thread.currentThread().getName() + <span class="string">&quot;执行了 -- 操作，当前number值为：&quot;</span> + number);            <span class="comment">// 唤醒其它线程</span>            condition.signalAll();        &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;            <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">RuntimeException</span>(e);        &#125; <span class="keyword">finally</span> &#123;            <span class="comment">// 解锁</span>            lock.unlock();        &#125;    &#125;&#125;<span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ConditionDemo</span> &#123;    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;        <span class="type">ShareNum</span> <span class="variable">shareNum</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ShareNum</span>();        <span class="keyword">new</span> <span class="title class_">Thread</span>(() -&gt; &#123;            <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; <span class="number">10</span>; i++) &#123;                shareNum.increase();            &#125;        &#125;, <span class="string">&quot;AA&quot;</span>).start();        <span class="keyword">new</span> <span class="title class_">Thread</span>(() -&gt; &#123;            <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; <span class="number">10</span>; i++) &#123;                shareNum.decrease();            &#125;        &#125;, <span class="string">&quot;BB&quot;</span>).start();        <span class="keyword">new</span> <span class="title class_">Thread</span>(() -&gt; &#123;            <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; <span class="number">10</span>; i++) &#123;                shareNum.increase();            &#125;        &#125;, <span class="string">&quot;CC&quot;</span>).start();        <span class="keyword">new</span> <span class="title class_">Thread</span>(() -&gt; &#123;            <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; <span class="number">10</span>; i++) &#123;                shareNum.decrease();            &#125;        &#125;, <span class="string">&quot;DD&quot;</span>).start();    &#125;&#125;</code></pre><h1 id="三、ReentrantLock"><a href="#三、ReentrantLock" class="headerlink" title="三、ReentrantLock"></a>三、ReentrantLock</h1><p>重入锁简单来说一个线程可以重复获取锁资源，虽然ReentrantLock不像synchronized关键字一样支持隐式的重入锁，但是在调用lock方法时，它会判断当前尝试获取锁的线程，是否等于已经拥有锁的线程，如果成立则不会被阻塞。</p><p>还有ReentrantLock在创建的时候，可以通构造方法指定创建公平锁还是非公平锁。</p><h2 id="1-代码示例"><a href="#1-代码示例" class="headerlink" title="1.  代码示例"></a>1.  代码示例</h2><pre><code class="highlight java"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ReentrantLockTest</span> &#123;    <span class="keyword">private</span> ArrayList&lt;Integer&gt; arrayList = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> InterruptedException &#123;        <span class="keyword">final</span> <span class="type">ReentrantLockTest</span> <span class="variable">test</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ReentrantLockTest</span>();        <span class="comment">// 锁放在这里，保证两个线程使用的是同一把锁</span>        <span class="type">Lock</span> <span class="variable">lock</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ReentrantLock</span>(); <span class="comment">//注意这个地方</span>        <span class="keyword">new</span> <span class="title class_">Thread</span>(() -&gt; &#123;            test.insert(Thread.currentThread(), lock);        &#125;).start();        <span class="keyword">new</span> <span class="title class_">Thread</span>(() -&gt; &#123;            test.insert(Thread.currentThread(), lock);        &#125;).start();        Thread.sleep(<span class="number">1000</span>);    &#125;    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">insert</span><span class="params">(Thread thread, Lock lock)</span> &#123;        lock.lock();        <span class="keyword">try</span> &#123;            System.out.println(thread.getName()+<span class="string">&quot;得到了锁&quot;</span>);            <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;<span class="number">5</span>;i++) &#123;                arrayList.add(i);            &#125;        &#125; <span class="keyword">catch</span> (Exception e) &#123;            <span class="comment">// <span class="doctag">TODO:</span> handle exception</span>        &#125;<span class="keyword">finally</span> &#123;            System.out.println(thread.getName()+<span class="string">&quot;释放了锁&quot;</span>);            lock.unlock();        &#125;    &#125;    <span class="comment">/**</span><span class="comment">     * 计算总数</span><span class="comment">     */</span>    <span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">count</span><span class="params">()</span> &#123;        <span class="type">int</span> <span class="variable">size</span> <span class="operator">=</span> arrayList.size();        System.out.println(<span class="string">&quot;总数为：&quot;</span> + size);    &#125;&#125;</code></pre><p><strong>运行结果</strong></p><pre><code class="highlight shell">Thread-0得到了锁Thread-0释放了锁Thread-1得到了锁Thread-1释放了锁</code></pre><h1 id="四、ReadWriteLock-读写锁"><a href="#四、ReadWriteLock-读写锁" class="headerlink" title="四、ReadWriteLock 读写锁"></a>四、ReadWriteLock 读写锁</h1><h2 id="1-乐观锁和悲观锁"><a href="#1-乐观锁和悲观锁" class="headerlink" title="1. 乐观锁和悲观锁"></a>1. 乐观锁和悲观锁</h2><p><strong>悲观锁( synchronized 键字和 Lock 的实现类都是悲观锁)</strong></p><ul><li><p>什么是悲观锁？认为自己在使用数据的时候一定有别的线程来修改数据，因此在获取数据的时候会先加锁，确保数据不会被别的线程修改，这样别人想拿数据就被挡住，直到悲观锁被释放，悲观锁中的共享资源每次只给一个线程使用，其它线程阻塞，用完后再把资源转让给其它线程</p></li><li><p>但是在效率方面，处理加锁的机制会产生额外的开销，还有增加产生<strong>死锁</strong>的机会。另外还会降低并行性，如果已经锁定了一个线程A，其他线程就必须等待该线程A处理完才可以处理</p></li><li><p>悲观锁适合写操作多的场景，先加锁可以保证写操作时数据正确(写操作包括增删改)、显式的锁定之后再操作同步资源</p><p><code>synchronized</code>关键字和<code>Lock</code>的实现类都是悲观锁，<strong>数据库中的行锁，表锁，读锁(共享锁)，写锁(排他锁)，均为悲观锁，表锁会发生死锁，读锁和写锁都会发生死锁现象。</strong></p></li><li><p>悲观锁不支持并发</p></li></ul><p><img src="https://raw.githubusercontent.com/GeorgeChan95/blogimg/master/img/2024/09/03/20240903-195057.png" alt="悲观锁"></p><p><strong>乐观锁</strong></p><ul><li>概念：乐观锁认为自己在使用数据时不会有别的线程修改数据，所以不会添加锁，只是在更新数据的时候去判断之前有没有别的线程更新了这个数据。如果这个数据没有被更新,当前线程将自己修改的数据成功写入。如果数据已经被其他线程更新，则根据不同的实现方式执行不同的操作</li><li>乐观锁在Java中通过使用无锁编程来实现，最常采用的是CAS算法，Java原子类中的递增操作就通过CAS自旋实现的，适合读操作多的场景，不加锁的特点能够使其读操作的性能大幅度提升</li></ul><p><img src="https://raw.githubusercontent.com/GeorgeChan95/blogimg/master/img/2024/09/03/20240903-195152.png" alt="乐观锁"></p><p><strong>乐观锁一般有两种实现方式</strong></p><ul><li>采用版本号机制</li><li>CAS算法实现</li></ul><pre><code class="highlight java"><span class="comment">//悲观锁的调用方式</span><span class="keyword">public</span> <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title function_">m1</span><span class="params">()</span> &#123;    <span class="comment">//加锁后的业务逻辑</span>&#125;<span class="comment">//保证多个线程使用的是同一个lock对象的前提下</span><span class="type">ReetrantLock</span> <span class="variable">lock</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ReentrantLock</span>();<span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">m2</span><span class="params">()</span>&#123;    lock.lock();    <span class="keyword">try</span> &#123;        <span class="comment">//操作同步资源</span>    &#125; <span class="keyword">finally</span> &#123;        lock.unlock();    &#125;&#125;<span class="comment">//乐观锁的调用方式</span><span class="comment">//保证多个线程使用的是同一个AtomicInteger</span><span class="keyword">private</span>  AtomicInteger atomicIntege=<span class="keyword">new</span> <span class="title class_">AtomicInteger</span>();atomicIntege.incrementAndGet();</code></pre><h2 id="2-读写锁ReadWriteLock"><a href="#2-读写锁ReadWriteLock" class="headerlink" title="2. 读写锁ReadWriteLock"></a>2. 读写锁ReadWriteLock</h2><h3 id="2-1-读写锁概述"><a href="#2-1-读写锁概述" class="headerlink" title="2.1 读写锁概述"></a>2.1 读写锁概述</h3><p>我们开发中应该能够遇到这样的一种情况，对共享资源有读和写的操作，且写操作没有读操作那么频繁。在没有写操作的时候，多个线程同时读一个资源没有任何问题，所以应该<strong>允许多个线程同时读取共享资源</strong>；但是当一个<strong>写者线程在写这些共享资源时，就不允许其他线程进行访问</strong>。</p><p>读写锁实际是一种特殊的自旋锁，它把对共享资源的访问者划分成读者和写者，读者只对共享资源进行读访问，写者则需要对共享资源进行写操作。我们将读操作相关的锁，称为读锁，因为可以共享读，我们也称为“<strong>共享锁</strong>”，将写操作相关的锁，称为<strong>写锁、排他锁、独占锁</strong>。<strong>每次可以多个线程的读者进行读访问，但是一次只能由一个写者线程进行写操作，即写操作是独占式的。</strong></p><p>读写锁适合于对数据结构的读次数比写次数多得多的情况。因为读模式锁定时可以共享, 以写模式锁住时意味着独占, 所以读写锁又叫<strong>共享-独占锁</strong>。</p><h3 id="2-2-ReadWriteLock读写锁"><a href="#2-2-ReadWriteLock读写锁" class="headerlink" title="2.2 ReadWriteLock读写锁"></a>2.2 ReadWriteLock读写锁</h3><p>针对上面这种场景，Java的并发包下提供了读写锁 <code>ReadWriteLock</code>（接口） | <code>ReentrantReadWriteLock</code>（实现类）。</p><p><code>ReadWriteLock</code> 维护了一对相关的锁，一个用于只读操作， 另一个用于写入操作。<strong>只要没有 writer</strong>，<strong>读取锁可以由多个 reader 线程同时保持</strong>。写入锁是<strong>独占</strong>的。</p><pre><code class="highlight java"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">ReadWriteLock</span> &#123;<span class="comment">// 读锁</span>    Lock <span class="title function_">readLock</span><span class="params">()</span>;<span class="comment">// 写锁</span>    Lock <span class="title function_">writeLock</span><span class="params">()</span>;&#125;</code></pre><p>ReadWriteLock 读取操作通常不会改变共享资源，<strong>但执行写入操作时，必须独占方式来获取锁</strong>。</p><ul><li>对于读取操作占多数的数据结构。 <strong>ReadWriteLock 能提供比独占锁更高的并发性</strong>。</li><li>而对于只读的数据结构，其中包含的不变性可以完全不需要考虑加锁操作。</li><li>读&#x2F;写锁使用后都需要分别关闭，跟<code>Lock</code>最后也需要手动关闭是一样一样的。</li><li>ReadWriteLock是比<code>lock</code>锁更加细粒度的控制</li></ul><h3 id="2-3-ReentrantReadWriteLock实现类"><a href="#2-3-ReentrantReadWriteLock实现类" class="headerlink" title="2.3 ReentrantReadWriteLock实现类"></a>2.3 ReentrantReadWriteLock实现类</h3><p><code>ReentrantReadWriteLock</code>实现了<code>ReadWriteLock</code>接口，下面是它的源码</p><pre><code class="highlight java"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ReentrantReadWriteLock</span> <span class="keyword">implements</span> <span class="title class_">ReadWriteLock</span>,java.io.Serializable &#123;    <span class="comment">/** 读锁 */</span>    <span class="keyword">private</span> <span class="keyword">final</span> ReentrantReadWriteLock.ReadLock readerLock;    <span class="comment">/** 写锁 */</span>    <span class="keyword">private</span> <span class="keyword">final</span> ReentrantReadWriteLock.WriteLock writerLock;    <span class="keyword">final</span> Sync sync;    <span class="comment">/** 使用默认（非公平）的排序属性创建一个新的</span><span class="comment">ReentrantReadWriteLock */</span>    <span class="keyword">public</span> <span class="title function_">ReentrantReadWriteLock</span><span class="params">()</span> &#123;        <span class="built_in">this</span>(<span class="literal">false</span>);    &#125;    <span class="comment">/** 使用给定的公平策略创建一个新的 ReentrantReadWriteLock */</span>    <span class="keyword">public</span> <span class="title function_">ReentrantReadWriteLock</span><span class="params">(<span class="type">boolean</span> fair)</span> &#123;        sync = fair ? <span class="keyword">new</span> <span class="title class_">FairSync</span>() : <span class="keyword">new</span> <span class="title class_">NonfairSync</span>();        readerLock = <span class="keyword">new</span> <span class="title class_">ReadLock</span>(<span class="built_in">this</span>);        writerLock = <span class="keyword">new</span> <span class="title class_">WriteLock</span>(<span class="built_in">this</span>);    &#125;    <span class="comment">/** 返回用于写入操作的锁 */</span>    <span class="keyword">public</span> ReentrantReadWriteLock.WriteLock <span class="title function_">writeLock</span><span class="params">()</span> &#123; <span class="keyword">return</span>        writerLock; &#125;    <span class="comment">/** 返回用于读取操作的锁 */</span>    <span class="keyword">public</span> ReentrantReadWriteLock.ReadLock <span class="title function_">readLock</span><span class="params">()</span> &#123; <span class="keyword">return</span>        readerLock; &#125;    <span class="keyword">abstract</span> <span class="keyword">static</span> <span class="keyword">class</span> <span class="title class_">Sync</span> <span class="keyword">extends</span> <span class="title class_">AbstractQueuedSynchronizer</span> &#123;&#125;    <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">class</span> <span class="title class_">NonfairSync</span> <span class="keyword">extends</span> <span class="title class_">Sync</span> &#123;&#125;    <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">class</span> <span class="title class_">FairSync</span> <span class="keyword">extends</span> <span class="title class_">Sync</span> &#123;&#125;    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">class</span> <span class="title class_">ReadLock</span> <span class="keyword">implements</span> <span class="title class_">Lock</span>, java.io.Serializable &#123;&#125;    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">class</span> <span class="title class_">WriteLock</span> <span class="keyword">implements</span> <span class="title class_">Lock</span>, java.io.Serializable &#123;&#125;&#125;</code></pre><h3 id="2-4-读写锁注意点"><a href="#2-4-读写锁注意点" class="headerlink" title="2.4 读写锁注意点"></a>2.4 读写锁注意点</h3><p>当读写锁是<strong>写加锁状态</strong>时, 在这个锁被解锁之前, 所有试图对这个锁加锁的线程都会被阻塞</p><p>当读写锁在<strong>读加锁状态</strong>时，所有试图以读模式对它进行加锁的线程都可以得到访问权，但是如果线程希望以写模式对此锁进行加锁, 它必须直到所有的线程释放锁.</p><p><strong>线程想要进入读锁的前提条件：</strong></p><ul><li>不存在其他线程的写锁</li><li>没有写请求, 或者有写请求，但调用线程和持有锁的线程是同一个(可重入锁)</li></ul><p><strong>线程进入写锁的前提条件：</strong></p><ul><li>没有读者线程正在访问</li><li>没有其他写者线程正在访问</li></ul><p><strong>通常, 当读写锁处于读模式锁住状态时，如果有另外线程试图以写模式加锁，读写锁通常会阻塞随后的读模式锁请求，这样可以避免读模式锁长期占用，而等待的写模式锁请求长期阻塞</strong></p><h3 id="2-5-读写锁的特点"><a href="#2-5-读写锁的特点" class="headerlink" title="2.5 读写锁的特点"></a>2.5 读写锁的特点</h3><ul><li><strong>公平选择性：</strong><ul><li>非公平模式（默认）<ul><li>当以非公平初始化时，读锁和写锁的获取的顺序是不确定的。非公平锁主张竞争获取，可能会延缓一个或多个读或写线程，但是会比公平锁有更高的吞吐量。</li></ul></li><li>公平模式<ul><li>当以公平模式初始化时，线程将会以队列的顺序获取锁。当当前线程释放锁后，等待时间最长的写锁线程就会被分配写锁；或者有一组读线程组等待时间比写线程长，那么这组读线程组将会被分配读锁。</li><li>当有写线程持有写锁或者有等待的写线程时，一个尝试获取公平的读锁（非重入）的线程就会阻塞。这个线程直到等待时间最长的写锁获得锁后并释放掉锁后才能获取到读锁。</li></ul></li></ul></li><li><strong>可重入</strong><ul><li>读锁和写锁都支持线程重进入。但是写锁可以获得读锁，读锁不能获得写锁。因为读锁是共享的，写锁是独占式的。</li></ul></li><li><strong>锁降级</strong><ul><li>遵循获取写锁、获取读锁再释放写锁的次序，写锁能够降级成为读锁。</li></ul></li><li><strong>支持中断锁的获取</strong><ul><li>在读锁和写锁的获取过程中支持中断</li></ul></li><li><strong>监控</strong><ul><li>提供一些辅助方法，例如hasQueuedThreads方法查询是否有线程正在等待获取读锁或写锁、isWriteLocked方法查询写锁是否被任何线程持有等等</li></ul></li></ul><h3 id="2-6-案例演示"><a href="#2-6-案例演示" class="headerlink" title="2.6 案例演示"></a>2.6 案例演示</h3><p>场景：我们通过一个缓存的小案例来，在没有使用锁的情况下，实现存储和读取的功能，并通过在多个线程的并发下。：使用 ReentrantReadWriteLock 对一个 hashmap 集合进行读和写的并发操作</p><p><strong>volatile关键字</strong>：表示数据会不断发生变化，多个线程可见性，禁止指令重排序</p><blockquote><p>没有锁的情况</p></blockquote><pre><code class="highlight java"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ReentrantReadWriteLockDemo</span> &#123;    <span class="comment">//创建 map 集合</span>    <span class="keyword">private</span> <span class="keyword">volatile</span> Map&lt;String, Object&gt; map = <span class="keyword">new</span> <span class="title class_">HashMap</span>&lt;&gt;();    <span class="comment">//放数据</span>    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">put</span><span class="params">(String key, Object value)</span> &#123;        System.out.println(Thread.currentThread().getName() + <span class="string">&quot;正在写数据&quot;</span> + key);        <span class="comment">//放数据</span>        map.put(key, value);        System.out.println(Thread.currentThread().getName() + <span class="string">&quot;写完了&quot;</span> + key);    &#125;    <span class="comment">//取数据</span>    <span class="keyword">public</span> Object <span class="title function_">get</span><span class="params">(String key)</span> &#123;        <span class="type">Object</span> <span class="variable">result</span> <span class="operator">=</span> <span class="literal">null</span>;        System.out.println(Thread.currentThread().getName() + <span class="string">&quot;正在取数据&quot;</span> + key);        <span class="comment">//        TimeUnit.MICROSECONDS.sleep(300);</span>        result = map.get(key);        System.out.println(Thread.currentThread().getName() + <span class="string">&quot;取完数据了&quot;</span> + key);        <span class="keyword">return</span> result;    &#125;    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;        <span class="type">ReentrantReadWriteLockDemo</span> <span class="variable">demo</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ReentrantReadWriteLockDemo</span>();        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">1</span>; i &lt;= <span class="number">5</span>; i++) &#123;            <span class="keyword">final</span> <span class="type">int</span> <span class="variable">number</span> <span class="operator">=</span> i;            <span class="keyword">new</span> <span class="title class_">Thread</span>(() -&gt; &#123;<span class="comment">//5个线程放数据</span>                demo.put(String.valueOf(number), number);            &#125;, String.valueOf(i)).start();        &#125;        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">1</span>; i &lt;= <span class="number">5</span>; i++) &#123;            <span class="keyword">final</span> <span class="type">int</span> <span class="variable">number</span> <span class="operator">=</span> i;            <span class="keyword">new</span> <span class="title class_">Thread</span>(() -&gt; &#123;<span class="comment">//5个线程取数据</span>                demo.get(String.valueOf(number));            &#125;, String.valueOf(i)).start();        &#125;    &#125;&#125;</code></pre><p><strong>执行结果：</strong></p><pre><code class="highlight shell">1正在取数据12正在取数据24正在写数据43正在写数据33正在取数据32取完数据了24正在取数据41取完数据了14取完数据了42正在写数据23取完数据了34写完了41正在写数据13写完了32写完了25正在取数据51写完了15取完数据了55正在写数据55写完了5</code></pre><p>可以看出在一个写线程写数据的时候，有其他线程进入，这显然是不行的。</p><blockquote><p><strong>使用ReadWriteLock读&#x2F;写锁解决缓存并发问题</strong></p></blockquote><pre><code class="highlight java"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ReentrantReadWriteLockDemo</span> &#123;    <span class="comment">//创建 map 集合</span>    <span class="keyword">private</span> <span class="keyword">volatile</span> Map&lt;String, Object&gt; map = <span class="keyword">new</span> <span class="title class_">HashMap</span>&lt;&gt;();    <span class="comment">//创建读写锁对象</span>    <span class="keyword">private</span> <span class="type">ReadWriteLock</span> <span class="variable">rwLock</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ReentrantReadWriteLock</span>();    <span class="comment">//放数据</span>    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">put</span><span class="params">(String key, Object value)</span> &#123;        <span class="comment">//添加写锁</span>        rwLock.writeLock().lock();        <span class="keyword">try</span> &#123;            System.out.println(Thread.currentThread().getName() + <span class="string">&quot;正在写数据&quot;</span> + key);            <span class="comment">//暂停一会</span>            TimeUnit.MICROSECONDS.sleep(<span class="number">300</span>);            <span class="comment">//放数据</span>            map.put(key, value);            System.out.println(Thread.currentThread().getName() + <span class="string">&quot;写完了&quot;</span> + key);        &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;            e.printStackTrace();        &#125; <span class="keyword">finally</span> &#123;            <span class="comment">//释放写锁</span>            rwLock.writeLock().unlock();        &#125;    &#125;    <span class="comment">//取数据</span>    <span class="keyword">public</span> Object <span class="title function_">get</span><span class="params">(String key)</span> &#123;        <span class="comment">//添加读锁</span>        rwLock.readLock().lock();        <span class="type">Object</span> <span class="variable">result</span> <span class="operator">=</span> <span class="literal">null</span>;        <span class="keyword">try</span> &#123;            System.out.println(Thread.currentThread().getName() + <span class="string">&quot;正在取数据&quot;</span> + key);            <span class="comment">//暂停一会</span>            TimeUnit.MICROSECONDS.sleep(<span class="number">300</span>);            result = map.get(key);            System.out.println(Thread.currentThread().getName() + <span class="string">&quot;取完数据了&quot;</span> + key);        &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;            e.printStackTrace();        &#125; <span class="keyword">finally</span> &#123;            <span class="comment">//释放读锁</span>            rwLock.readLock().unlock();        &#125;        <span class="keyword">return</span> result;    &#125;    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;        <span class="type">ReentrantReadWriteLockDemo</span> <span class="variable">demo</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ReentrantReadWriteLockDemo</span>();        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">1</span>; i &lt;= <span class="number">5</span>; i++) &#123;            <span class="keyword">final</span> <span class="type">int</span> <span class="variable">number</span> <span class="operator">=</span> i;            <span class="keyword">new</span> <span class="title class_">Thread</span>(() -&gt; &#123;<span class="comment">//5个线程放数据</span>                demo.put(String.valueOf(number), number);            &#125;, String.valueOf(i)).start();        &#125;        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">1</span>; i &lt;= <span class="number">5</span>; i++) &#123;            <span class="keyword">final</span> <span class="type">int</span> <span class="variable">number</span> <span class="operator">=</span> i;            <span class="keyword">new</span> <span class="title class_">Thread</span>(() -&gt; &#123;<span class="comment">//5个线程取数据</span>                demo.get(String.valueOf(number));            &#125;, String.valueOf(i)).start();        &#125;    &#125;&#125;</code></pre><p><strong>执行结果：</strong></p><pre><code class="highlight shell">1正在写数据11写完了12正在写数据22写完了23正在写数据33写完了34正在写数据44写完了45正在写数据55写完了51正在取数据12正在取数据24正在取数据43正在取数据35正在取数据52取完数据了21取完数据了15取完数据了53取完数据了34取完数据了4</code></pre><p>从结果可以看出，写操作是唯一独占的，多个线程不能同时写，必须等一个线程写完了另外一个线程才能进去，而读的时候是共享的，多个线程可以一起读数据。</p><h3 id="2-7-总结-重点"><a href="#2-7-总结-重点" class="headerlink" title="2.7 总结(重点)"></a>2.7 总结(重点)</h3><p>与传统锁不同的是读写锁的规则是可以共享读，但只能一个写，即不能同时存在读写线程，总结起来为：读读不互斥，读写互斥，写写互斥。而一般的传统独占锁是：读读互斥，读写互斥，写写互斥，而场景中往往读远远大于写，读写锁就是为了这种优化而创建出来的一种机制。注意是读远远大于写，一般情况下独占锁的效率低来源于高并发下对临界区的激烈竞争导致线程上下文切换。因此当并发不是很高的情况下，读写锁由于需要额外维护读锁的状态，可能还不如独占锁的效率高。因此需要根据实际情况选择使用。</p><ul><li><strong>ReentrantReadWriteLock和Synchonized、ReentrantLock比较起来有哪些区别呢？或者有哪些优势呢？</strong></li><li>Synchonized、ReentrantLock是属于传统独占锁，读、写操作每次都只能是一个人访问，效率比较低。</li><li>而ReentrantReadWriteLock读操作可以共享，提升性能，允许多人一起读操作，而写操作还是每次一个人访问。</li><li>当然ReentrantReadWriteLock优势是有，但是也存在一些缺陷，容易造成<strong>锁饥饿</strong>，因为如果是读线程先拿到锁的话，并且后续有很多读线程，但只有一个写线程，很有可能这个写线程拿不到锁，它可能要等到所有读线程读完才能进入，就可能会造成一种一直读，没有写的现象。</li></ul><h2 id="3-锁降级"><a href="#3-锁降级" class="headerlink" title="3. 锁降级"></a>3. 锁降级</h2><h3 id="3-1-概述"><a href="#3-1-概述" class="headerlink" title="3.1 概述"></a>3.1 概述</h3><p><strong>概念：</strong></p><p>锁降级的意思就是<strong>写锁降级为读锁</strong>。而读锁是不可以升级为写锁的。如果当前线程拥有写锁，然后将其释放，最后再获取读锁，这种分段完成的过程不能称之为锁降级。锁降级是指把持住（当前拥有的）写锁，再获取到读锁，随后释放（先前拥有的）写锁的过程，最后释放读锁的过程。</p><p><strong>编程模型：</strong></p><p>获取写锁—&gt;获取读锁—&gt;释放写锁—&gt;释放读锁</p><p><strong>代码演示</strong></p><pre><code class="highlight java"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ReadWriteLockDemo2</span> &#123;    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;        <span class="type">ReentrantReadWriteLock</span> <span class="variable">reentrantReadWriteLock</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ReentrantReadWriteLock</span>();        <span class="comment">// 获取读锁</span>        ReentrantReadWriteLock.<span class="type">WriteLock</span> <span class="variable">writeLock</span> <span class="operator">=</span> reentrantReadWriteLock.writeLock();        <span class="comment">// 获取写锁</span>        ReentrantReadWriteLock.<span class="type">ReadLock</span> <span class="variable">readLock</span> <span class="operator">=</span> reentrantReadWriteLock.readLock();                <span class="comment">//1、获取到写锁</span>        writeLock.lock();        System.out.println(<span class="string">&quot;获取到了写锁&quot;</span>);                <span class="comment">//2、获取到读锁</span>        readLock.lock();        System.out.println(<span class="string">&quot;继续获取到读锁&quot;</span>);        <span class="comment">//3、释放写锁</span>        writeLock.unlock();   <span class="comment">//4、 释放读锁</span>        readLock.unlock();    &#125;&#125;</code></pre><p>结果：</p><pre><code class="highlight shell">获取到了写锁继续获取到读锁</code></pre><p>也许大家觉得看不出什么，但是如果将获取读锁那一行代码调到获取写锁上方去，可能结果就完全不一样拉。</p><pre><code class="highlight java"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ReadWriteLockDemo2</span> &#123;    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;        <span class="type">ReentrantReadWriteLock</span> <span class="variable">reentrantReadWriteLock</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ReentrantReadWriteLock</span>();        <span class="comment">// 获取读锁</span>        ReentrantReadWriteLock.<span class="type">WriteLock</span> <span class="variable">writeLock</span> <span class="operator">=</span> reentrantReadWriteLock.writeLock();        <span class="comment">// 获取写锁</span>        ReentrantReadWriteLock.<span class="type">ReadLock</span> <span class="variable">readLock</span> <span class="operator">=</span> reentrantReadWriteLock.readLock();        <span class="comment">//1、 获取到读锁</span>        readLock.lock();        System.out.println(<span class="string">&quot;获取到了读锁&quot;</span>);        writeLock.lock();        System.out.println(<span class="string">&quot;继续获取到写锁&quot;</span>);        writeLock.unlock();        readLock.unlock();    &#125;&#125;</code></pre><p>结果：执行到读锁就停止了，即读锁不能升级为写锁。</p><pre><code class="highlight shell">获取到了读锁</code></pre><p><strong>原因：</strong></p><p>因为在线程持有读锁的情况下，该线程不能取得写锁（因为获取写锁的前提条件是，当前没有读者线程，也没有其他写者线程，如果发现当前的读锁被占用，就马上获取失败，不管读锁是不是被当前线程持有)。</p><p>但是在线程持有写锁的情况下，该线程可以继续获取读锁（获取读锁时如果发现写锁被占用，只有写锁没有被当前线程占用的情况才会获取失败）。</p><p>当线程获取读锁的时候，可能有其他线程同时也在持有读锁，因此不能把获取读锁的线程“升级”为写锁；而对于获得写锁的线程，它一定独占了读写锁，因此可以继续让它获取读锁，当它同时获取了写锁和读锁后，还可以先释放写锁继续持有读锁，这样一个写锁就“降级”为了读锁。</p><h3 id="3-2-使用场景"><a href="#3-2-使用场景" class="headerlink" title="3.2 使用场景"></a>3.2 使用场景</h3><p>对于数据比较敏感, 需要在对数据修改以后, 获取到修改后的值, 并进行接下来的其它操作.</p><p>我们来看个比较实在的案例：</p><pre><code class="highlight java"><span class="keyword">import</span> java.util.HashMap;<span class="keyword">import</span> java.util.Map;<span class="keyword">import</span> java.util.concurrent.locks.Lock;<span class="keyword">import</span> java.util.concurrent.locks.ReadWriteLock;<span class="keyword">import</span> java.util.concurrent.locks.ReentrantReadWriteLock;<span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">CacheDemo</span> &#123;    <span class="comment">/**</span><span class="comment">     * 缓存器,这里假设需要存储1000左右个缓存对象，按照默认的负载因子0.75，则容量=750，大概估计每一个节点链表长度为5个</span><span class="comment">     * 那么数组长度大概为：150,又有雨设置map大小一般为2的指数，则最近的数字为：128</span><span class="comment">     */</span>    <span class="keyword">private</span> Map&lt;String, Object&gt; map = <span class="keyword">new</span> <span class="title class_">HashMap</span>&lt;&gt;(<span class="number">128</span>);    <span class="keyword">private</span> <span class="type">ReadWriteLock</span> <span class="variable">rwl</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ReentrantReadWriteLock</span>();    <span class="keyword">private</span> Lock writeLock=rwl.writeLock();    <span class="keyword">private</span> Lock readLock=rwl.readLock();    <span class="keyword">public</span> Object <span class="title function_">get</span><span class="params">(String id)</span> &#123;        <span class="type">Object</span> <span class="variable">value</span> <span class="operator">=</span> <span class="literal">null</span>;        readLock.lock();<span class="comment">//首先开启读锁，从缓存中去取</span>        <span class="keyword">try</span> &#123;            <span class="comment">//如果缓存中没有  释放读锁，上写锁</span>            <span class="keyword">if</span> (map.get(id) == <span class="literal">null</span>) &#123;                 readLock.unlock();                writeLock.lock();                <span class="keyword">try</span> &#123;                    <span class="comment">//防止多写线程重复查询赋值</span>                    <span class="keyword">if</span> (value == <span class="literal">null</span>) &#123;                        <span class="comment">//此时可以去数据库中查找，这里简单的模拟一下</span>                        value = <span class="string">&quot;redis-value&quot;</span>;                      &#125;                    <span class="comment">//加读锁降级写锁,不明白的可以查看上面锁降级的原理与保持读取数据原子性的讲解</span>                    readLock.lock();                 &#125; <span class="keyword">finally</span> &#123;                    <span class="comment">//释放写锁</span>                    writeLock.unlock();                 &#125;            &#125;        &#125; <span class="keyword">finally</span> &#123;            <span class="comment">//最后释放读锁</span>            readLock.unlock();         &#125;        <span class="keyword">return</span> value;    &#125;&#125;</code></pre><p>如果不使用锁降级功能，如先释放写锁，然后获得读锁，在这个获取读锁的过程中，可能会有其他线程竞争到写锁 或者是更新数据 则获得的数据是其他线程更新的数据，可能会造成数据的污染，即产生脏读的问题。</p><h3 id="3-4-锁降级的必要性"><a href="#3-4-锁降级的必要性" class="headerlink" title="3.4 锁降级的必要性"></a>3.4 锁降级的必要性</h3><p>锁降级中读锁的获取是否必要呢？</p><p>答案是必要的。主要是为了保证数据的可见性，如果当前线程不获取读锁而是直接释放写锁， 假设此刻另一个线程（记作线程T）获取了写锁并修改了数据，那么当前线程无法感知线程T的数据更新。如果当前线程获取读锁，即遵循锁降级的步骤，则线程T将会被阻塞，直到当前线程使用数据并释放读锁之后，线程T才能获取写锁进行数据更新。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;一、Synchronized&quot;&gt;&lt;a href=&quot;#一、Synchronized&quot; class=&quot;headerlink&quot; title=&quot;一、Synchronized&quot;&gt;&lt;/a&gt;一、Synchronized&lt;/h1&gt;&lt;h2 id=&quot;1-Synchronized-关键</summary>
      
    
    
    
    <category term="JUC" scheme="https://georgechan95.github.io/categories/JUC/"/>
    
    
    <category term="juc" scheme="https://georgechan95.github.io/tags/juc/"/>
    
    <category term="java" scheme="https://georgechan95.github.io/tags/java/"/>
    
  </entry>
  
  <entry>
    <title>01-多线程的基本概念</title>
    <link href="https://georgechan95.github.io/blog/4e6bd685.html"/>
    <id>https://georgechan95.github.io/blog/4e6bd685.html</id>
    <published>2024-08-30T11:03:01.000Z</published>
    <updated>2024-08-31T03:39:29.138Z</updated>
    
    <content type="html"><![CDATA[<h1 id="一、进程和线程"><a href="#一、进程和线程" class="headerlink" title="一、进程和线程"></a>一、进程和线程</h1><ul><li>进程（Process）是计算机中的程序关于某数据集合上的一次运行活动，是系统进行资源分配和调度的基本单位，是操作系统结构的基础。在早期面向进程设计的计算机结构中，进程是程序的基本执行实体；在当代面向线程设计的计算机结构中，进程是线程的容器。程序是指令、数据及其组织形式的描述，进程是程序的实体。</li><li>线程（thread）是操作系统能够进行运算调度的最小单位。它被包含在进程之中，是进程中的实际运作单位。一条线程指的是进程中一个单一顺序的控制流，一个进程中可以并发多个线程，每条线程并行执行不同的任务。</li></ul><p>总结来说：</p><ul><li>进程：指在系统中正在运行的一个应用程序；程序一旦运行就是进程；进程是资源分配的最小单位</li><li>线程：系统分配处理器时间资源的基本单元，或者说进程之内独立执行的一个单元执行流。线程时程序执行的最小单位</li></ul><h1 id="二、线程的状态"><a href="#二、线程的状态" class="headerlink" title="二、线程的状态"></a>二、线程的状态</h1><p>进入 java.lang.Thread 类，找到内部类 State ，代码如下</p><pre><code class="highlight java"><span class="keyword">public</span> <span class="keyword">enum</span> <span class="title class_">State</span> &#123;        <span class="comment">/**</span><span class="comment">         * Thread state for a thread which has not yet started.</span><span class="comment">         */</span>        NEW,(新建)        <span class="comment">/**</span><span class="comment">         * Thread state for a runnable thread.  A thread in the runnable</span><span class="comment">         * state is executing in the Java virtual machine but it may</span><span class="comment">         * be waiting for other resources from the operating system</span><span class="comment">         * such as processor.</span><span class="comment">         */</span>        RUNNABLE,（准备就绪）        <span class="comment">/**</span><span class="comment">         * Thread state for a thread blocked waiting for a monitor lock.</span><span class="comment">         * A thread in the blocked state is waiting for a monitor lock</span><span class="comment">         * to enter a synchronized block/method or</span><span class="comment">         * reenter a synchronized block/method after calling</span><span class="comment">         * &#123;<span class="doctag">@link</span> Object#wait() Object.wait&#125;.</span><span class="comment">         */</span>        BLOCKED,（阻塞）        <span class="comment">/**</span><span class="comment">         * Thread state for a waiting thread.</span><span class="comment">         * A thread is in the waiting state due to calling one of the</span><span class="comment">         * following methods:</span><span class="comment">         * &lt;ul&gt;</span><span class="comment">         *   &lt;li&gt;&#123;<span class="doctag">@link</span> Object#wait() Object.wait&#125; with no timeout&lt;/li&gt;</span><span class="comment">         *   &lt;li&gt;&#123;<span class="doctag">@link</span> #join() Thread.join&#125; with no timeout&lt;/li&gt;</span><span class="comment">         *   &lt;li&gt;&#123;<span class="doctag">@link</span> LockSupport#park() LockSupport.park&#125;&lt;/li&gt;</span><span class="comment">         * &lt;/ul&gt;</span><span class="comment">         *</span><span class="comment">         * &lt;p&gt;A thread in the waiting state is waiting for another thread to</span><span class="comment">         * perform a particular action.</span><span class="comment">         *</span><span class="comment">         * For example, a thread that has called &lt;tt&gt;Object.wait()&lt;/tt&gt;</span><span class="comment">         * on an object is waiting for another thread to call</span><span class="comment">         * &lt;tt&gt;Object.notify()&lt;/tt&gt; or &lt;tt&gt;Object.notifyAll()&lt;/tt&gt; on</span><span class="comment">         * that object. A thread that has called &lt;tt&gt;Thread.join()&lt;/tt&gt;</span><span class="comment">         * is waiting for a specified thread to terminate.</span><span class="comment">         */</span>        WAITING,（不限时间等待）        <span class="comment">/**</span><span class="comment">         * Thread state for a waiting thread with a specified waiting time.</span><span class="comment">         * A thread is in the timed waiting state due to calling one of</span><span class="comment">         * the following methods with a specified positive waiting time:</span><span class="comment">         * &lt;ul&gt;</span><span class="comment">         *   &lt;li&gt;&#123;<span class="doctag">@link</span> #sleep Thread.sleep&#125;&lt;/li&gt;</span><span class="comment">         *   &lt;li&gt;&#123;<span class="doctag">@link</span> Object#wait(long) Object.wait&#125; with timeout&lt;/li&gt;</span><span class="comment">         *   &lt;li&gt;&#123;<span class="doctag">@link</span> #join(long) Thread.join&#125; with timeout&lt;/li&gt;</span><span class="comment">         *   &lt;li&gt;&#123;<span class="doctag">@link</span> LockSupport#parkNanos LockSupport.parkNanos&#125;&lt;/li&gt;</span><span class="comment">         *   &lt;li&gt;&#123;<span class="doctag">@link</span> LockSupport#parkUntil LockSupport.parkUntil&#125;&lt;/li&gt;</span><span class="comment">         * &lt;/ul&gt;</span><span class="comment">         */</span>        TIMED_WAITING,（限时等待）        <span class="comment">/**</span><span class="comment">         * Thread state for a terminated thread.</span><span class="comment">         * The thread has completed execution.</span><span class="comment">         */</span>        TERMINATED;(终结)&#125;</code></pre><ul><li>NEW,(新建)</li><li>RUNNABLE,（准备就绪）</li><li>BLOCKED,（阻塞）</li><li>WAITING,（不限时等待）</li><li>TIMED_WAITING,（限时等待）</li><li>TERMINATED;(终结)</li></ul><h1 id="三、wait和sleep"><a href="#三、wait和sleep" class="headerlink" title="三、wait和sleep"></a>三、wait和sleep</h1><ul><li>sleep 是 Thread 的静态方法，wait 是 Object 的方法，任何对象实例都能调用。</li><li>sleep 不会释放锁，它也不需要占用锁；wait会释放锁，但调用它的前提是当前线程占有锁（即代码要在synchronized中）</li><li>它们都可以被 <code>interrupt</code> 方法中断</li></ul><p><img src="https://raw.githubusercontent.com/GeorgeChan95/blogimg/master/img/2024/08/30/20240830-191847.png" alt="线程状态"></p><h1 id="四、并发与并行"><a href="#四、并发与并行" class="headerlink" title="四、并发与并行"></a>四、并发与并行</h1><ul><li>并发：同一时间间隔内多个线程正在执行，实际上是宏观上并行，微观上串行</li><li>并行：同一时刻多个线程正在执行</li></ul><h1 id="五、管程（monitor）"><a href="#五、管程（monitor）" class="headerlink" title="五、管程（monitor）"></a>五、管程（monitor）</h1><p>管程(monitor)是保证了同一时刻只有一个进程在管程内活动,即管程内定义的操作在同一时刻只被一个进程调用(由编译器实现).但是这样并不能保证进程以设计的顺序执行。</p><p>JVM 中同步是基于进入和退出管程(monitor)对象实现的，每个对象都会有一个管程(monitor)对象，管程(monitor)会随着 java 对象一同创建和销毁。</p><p>执行线程首先要持有管程对象，然后才能执行方法，当方法完成之后会释放管程，方法在执行时候会持有管程，其他线程无法再获取同一个管程</p><h1 id="六、用户线程和守护线程"><a href="#六、用户线程和守护线程" class="headerlink" title="六、用户线程和守护线程"></a>六、用户线程和守护线程</h1><ul><li><strong>用户线程</strong>：自定义线程</li><li><strong>守护线程</strong>:运行在后台,是一种特殊的线程,比如垃圾回收</li><li>当主线程结束后,用户线程还在运行,JVM 存活</li><li>如果没有用户线程,都是守护线程,JVM 结束</li></ul>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;一、进程和线程&quot;&gt;&lt;a href=&quot;#一、进程和线程&quot; class=&quot;headerlink&quot; title=&quot;一、进程和线程&quot;&gt;&lt;/a&gt;一、进程和线程&lt;/h1&gt;&lt;ul&gt;
&lt;li&gt;进程（Process）是计算机中的程序关于某数据集合上的一次运行活动，是系统进行资源分配</summary>
      
    
    
    
    <category term="JUC" scheme="https://georgechan95.github.io/categories/JUC/"/>
    
    
    <category term="juc" scheme="https://georgechan95.github.io/tags/juc/"/>
    
    <category term="java" scheme="https://georgechan95.github.io/tags/java/"/>
    
  </entry>
  
  <entry>
    <title>第二十五章-分析GC日志</title>
    <link href="https://georgechan95.github.io/blog/1b0522f4.html"/>
    <id>https://georgechan95.github.io/blog/1b0522f4.html</id>
    <published>2024-08-28T13:36:08.000Z</published>
    <updated>2024-08-28T08:47:45.286Z</updated>
    
    <content type="html"><![CDATA[<h1 id="一、GC日志参数"><a href="#一、GC日志参数" class="headerlink" title="一、GC日志参数"></a>一、GC日志参数</h1><ul><li><p><code>-verbose:gc</code></p><p>输出gc日志信息，默认输出到标准输出</p></li><li><p><code>-XX:+PrintGC</code></p><p>输出GC日志。类似：-verbose:gc</p></li><li><p><code>-XX:+PrintGCDetails</code></p><p>在发生垃圾回收时打印内存回收详细的日志，并在进程退出时输出当前内存各区域分配情况</p></li><li><p><code>-XX:+PrintGCTimeStamps</code></p><p>输出GC发生时的时间截</p></li><li><p><code>-XX:+PrintGCDateStamps</code></p><p>输出GC发生时的时间戳（以日期的形式，如 2013-05-04T21:53:59.234+0800)</p></li><li><p><code>-XX:+PrintHeapAtGC</code></p><p>每一次GC前和GC后，都打印堆信息</p></li><li><p><code>-Xloggc:&lt;file&gt;</code></p><p>表示把GC日志写入到一个文件中去，而不是打印到标准输出中</p></li></ul><h1 id="二、GC日志格式"><a href="#二、GC日志格式" class="headerlink" title="二、GC日志格式"></a>二、GC日志格式</h1><h2 id="1-GC分类"><a href="#1-GC分类" class="headerlink" title="1. GC分类"></a>1. GC分类</h2><p>针对 HotSpot VM 的实现，它里面的GC按照回收区域又分为两大种类型：一种是部分收集（Partial GC), 一种是整堆收集（Full GC)</p><h3 id="1-1-部分收集"><a href="#1-1-部分收集" class="headerlink" title="1.1 部分收集"></a>1.1 部分收集</h3><p>不是完整收集整个Java堆的垃圾收集。</p><p>其中又分为：</p><ul><li>新生代收集（Minor GC&#x2F;Young GC):只是新生代（Eden\S0,S1)的垃圾收集</li><li>老年代收集（Major GC&#x2F;old GC):只是老年代的垃圾收集。<ul><li>目前，只有CMSGC会有单独收集老年代的行为。</li><li>注意，很多时候Major GC会和Full GC混淆使用，需要具体分辨是老年代回收还是整堆回收。</li></ul></li><li>混合收集（Mixed GC):收集整个新生代以及部分老年代的垃圾收集。<ul><li>目前，只有G1GC会有这种行为</li></ul></li></ul><h3 id="1-2-整堆收集（Full-GC"><a href="#1-2-整堆收集（Full-GC" class="headerlink" title="1.2 整堆收集（Full GC)"></a>1.2 整堆收集（Full GC)</h3><p>收集整个java堆和方法区的垃圾收集。</p><p><strong>哪些情况会触发Full GC?</strong></p><ul><li>老年代空间不足</li><li>方法区空间不足</li><li>显式调用System.gc()</li><li>Minor GC进入老年代的数据的平均大小大于老年代的可用内存</li><li>大对象直接进入老年代，而老年代的可用空间不足</li></ul><h2 id="2-GC日志分类"><a href="#2-GC日志分类" class="headerlink" title="2. GC日志分类"></a>2. GC日志分类</h2><h3 id="2-1-MinorGC"><a href="#2-1-MinorGC" class="headerlink" title="2.1 MinorGC"></a>2.1 MinorGC</h3><p>MinorGC(或young GC或YGC)日志：</p><p>[GC (Allocation Failure) [PSYoungGen: 131584K-&gt;7195K(153088K)] 131584K-&gt;7203K(502784K), 0.0334432 secs] [Times: user&#x3D;0.02 sys&#x3D;0.00, real&#x3D;0.04 secs]</p><p><img src="https://raw.githubusercontent.com/GeorgeChan95/blogimg/master/img/2024/08/28/20240828-140528.png" alt="minorGC日志解析"></p><h3 id="2-2-FullGC"><a href="#2-2-FullGC" class="headerlink" title="2.2 FullGC"></a>2.2 FullGC</h3><p>[Full GC (Metadata GC Threshold) [PSYoungGen: 2848K-&gt;0K(158720K)] [ParOldGen: 32816K-&gt;19441K(349696K)] 35664K-&gt;19441K(508416K), [Metaspace: 34044K-&gt;34044K(1079296K)], 0.1156700 secs] [Times: user&#x3D;0.09 sys&#x3D;0.00, real&#x3D;0.12 secs]</p><p><img src="https://raw.githubusercontent.com/GeorgeChan95/blogimg/master/img/2024/08/28/20240828-140956.png" alt="fullGC日志解析"></p><h2 id="3-GC日志结构剖析"><a href="#3-GC日志结构剖析" class="headerlink" title="3. GC日志结构剖析"></a>3. GC日志结构剖析</h2><h3 id="3-1-垃圾收集器"><a href="#3-1-垃圾收集器" class="headerlink" title="3.1  垃圾收集器"></a>3.1  垃圾收集器</h3><ul><li>使用 <code>Serial</code> 收集器在新生代的名字是 <code>Default New Generation</code> , 因此显示的是”[DefNew”</li><li>使用 <code>ParNew</code> 收集器在新生代的名字会变成”[ParNew” , 意思是”Parallel New Generation”</li><li>使用 <code>Parallel Scavenge</code> 收集器在新生代的名字是”[PSYoungGen”,这里的JDK1.7使用的就是<code>PSYoungGen</code></li><li>使用 <code>Parallel Old Generation</code> 收集器在老年代的名字是”[ParOldGen”</li><li>使用G1收集器的话，会显示为”garbage-first heap”</li></ul><p><strong>Allocation Failure</strong></p><p>表明本次引起GC的原因是因为在年轻代中没有足够的空间能够存储新的数据了。</p><h3 id="3-2-GC前后情况"><a href="#3-2-GC前后情况" class="headerlink" title="3.2 GC前后情况"></a>3.2 GC前后情况</h3><p>通过图示，我们可以发现GC日志格式的规律一般都是：GC前内存占用 一&gt; GC后内存占用（该区域内存总大小）</p><p>[PSYoungGen: 5986K -&gt; 696K(8704K)] 5986K -&gt; 704K(9216K)</p><p>中括号内：GC回收前年轻代堆大小，回收后大小，(<strong>年轻代堆总大小</strong>）</p><p>括号外：GC回收前年轻代和老年代大小，回收后大小，(<strong>年轻代和老年代总大小</strong>）</p><h3 id="3-3-GC时间"><a href="#3-3-GC时间" class="headerlink" title="3.3 GC时间"></a>3.3 GC时间</h3><p>GC日志中有三个时间：user , sys 和 real</p><ul><li><strong>user</strong> - 进程执行用户态代码（核心之外）所使用的时间。这是执行此进程所使用的实际CPU时间，其他进程和此进程阻塞的时间并不包括在内。在垃圾收集的情况下，表示GC线程执行所使用的CPU总时间。</li><li><strong>sys</strong> - 进程在内核态消耗的CPU时间，即在内核执行系统调用或等待系统事件所使用的CPU时间</li><li><strong>real</strong> - 程序从开始到结束所用的时钟时间。这个时间包括其他进程使用的时间片和进程阻塞的时间（比如等待I&#x2F;0完成）。对于并行gc,这个数字应该接近（用户时间+系统时间）除以垃圾收集器使用的线程数。</li></ul><p>由于多核的原因，一般的GC事件中，real time是小于 <code>sys + user time</code> 的，因为一般是多个线程并发的去做 GC,所以real time是要小于 sys+user time 的。<br> 如果 <code>real &gt; sys+user</code> 的话，则你的应用可能存在下列问题：IO负载非常重 或者是CPU不够用。</p><h2 id="4-Minor-GC-日志解析"><a href="#4-Minor-GC-日志解析" class="headerlink" title="4. Minor GC 日志解析"></a>4. Minor GC 日志解析</h2><p>2024-08-28T15:09:58.253+0800: 2.004: [GC (Allocation Failure) [PSYoungGen: 138937K-&gt;7465K(153088K)] 138945K-&gt;7473K(502784K), 0.0261046 secs] [Times: user&#x3D;0.01 sys&#x3D;0.00, real&#x3D;0.03 secs]</p><ul><li><p>2024-08-28T15:09:58.253+0800</p><p><strong>日志打印时间日期格式</strong></p></li><li><p>2.004</p><p><strong>gc发生时，Java虚拟机启动以来经过的秒数</strong></p></li><li><p>[GC (Allocation Failure) </p><p><strong>发生了一次垃圾回收，这是一次MinorGC</strong></p><p>它不区分新生代还是老年代GC，括号里的内容是gc发生的原因，这里的Allocation Failure的原因是新生代中没有足够区域能够存放需要分配的数据而失败</p></li><li><p>[PSYoungGen: 138937K-&gt;7465K(153088K)] </p><ul><li>PSYoungGen：表示GC发生的区域，区域名称与使用的GC收集器是密切相关的<ul><li>Serial收集器：Default New Generation 显示Defnew</li><li>ParNew收集器：ParNew</li><li>Parallel Scanvenge收集器：PSYoung</li><li>老年代和新生代同理，也是和收集器名称相关</li></ul></li><li>138937K-&gt;7465K(153088K)：GC前该内存区域已使用容量-&gt;GC后该区域容量(该区域总容量)<ul><li>如果是新生代，总容量则会显示整个新生代内存的9&#x2F;10，即eden+from&#x2F;to区</li><li>如果是老年代，总容量则是全身内存大小，无变化</li></ul></li></ul></li><li><p>138945K-&gt;7473K(502784K)</p><p>虽然本次是Minor GC，只会进行新生代的垃圾收集，但是也肯定会打印堆中总容量相关信息</p><p>在显示完区域容量GC的情况之后，会接着显示整个堆内存区域的GC情况：GC前堆内存已使用容量-&gt;GC后堆内存容量（堆内存总容量），并且堆内存总容量 &#x3D; 9&#x2F;10 新生代 + 老年代，然后堆内存总容量肯定小于初始化的内存大小</p></li><li><p>0.0261046 secs</p><p>整个GC所花费的时间，单位是秒</p></li><li><p>[Times: user&#x3D;0.01 sys&#x3D;0.00, real&#x3D;0.03 secs]</p><ul><li>user：指CPU工作在用户态所花费的时间</li><li>sys：指CPU工作在内核态所花费的时间</li><li>real：指在此次事件中所花费的总时间</li></ul></li></ul><h2 id="5-Full-GC-日志解析"><a href="#5-Full-GC-日志解析" class="headerlink" title="5. Full GC 日志解析"></a>5. Full GC 日志解析</h2><p>2024-08-28T15:10:01.578+0800: 5.329: [Full GC (Metadata GC Threshold) [PSYoungGen: 3264K-&gt;0K(163840K)] [ParOldGen: 6227K-&gt;7621K(349696K)] 9491K-&gt;7621K(513536K), [Metaspace: 20472K-&gt;20472K(1067008K)], 0.0627380 secs] [Times: user&#x3D;0.04 sys&#x3D;0.00, real&#x3D;0.06 secs]</p><h3 id="5-1-日志分解与解释"><a href="#5-1-日志分解与解释" class="headerlink" title="5.1 日志分解与解释"></a>5.1 日志分解与解释</h3><pre><code class="highlight plaintext">2024-08-28T15:10:01.578+0800: 5.329: [Full GC (Metadata GC Threshold) [PSYoungGen: 3264K-&gt;0K(163840K)] [ParOldGen: 6227K-&gt;7621K(349696K)] 9491K-&gt;7621K(513536K), [Metaspace: 20472K-&gt;20472K(1067008K)], 0.0627380 secs] [Times: user=0.04 sys=0.00, real=0.06 secs]</code></pre><ol><li><strong>时间戳</strong>: <code>2024-08-28T15:10:01.578+0800</code><ul><li>这表示日志条目的日期和时间。<code>+0800</code> 表示时区偏移量（例如，北京时间为 UTC+8）。</li></ul></li><li><strong>GC 事件触发时间</strong>: <code>5.329</code><ul><li>表示从 JVM 启动到 GC 事件发生的时间，单位是秒。这表明在 JVM 启动后的 5.329 秒，发生了一个 Full GC。</li></ul></li><li><strong>GC 类型</strong>: <code>[Full GC (Metadata GC Threshold)]</code><ul><li><code>Full GC</code> 表示一次 Full Garbage Collection，即对整个堆（包括年轻代和老年代）进行的垃圾回收。</li><li><code>Metadata GC Threshold</code> 是此次 GC 的触发原因。它表明是因为元数据（如类的元信息）达到了特定的阈值，导致了 Full GC。<ul><li>Full GC (Ergonomics) : JVM , 自适应调整导致的GC</li><li>Full GC(System) : 调用了System.gc()方法</li></ul></li></ul></li><li><strong>年轻代回收</strong>: <code>[PSYoungGen: 3264K-&gt;0K(163840K)]</code><ul><li><strong>PSYoungGen</strong>: 使用 Parallel Scavenge（并行清除）垃圾回收器的年轻代（Young Generation）。</li><li><code>3264K-&gt;0K</code>: 表示在回收前年轻代占用 3264 KB 内存，回收后占用 0 KB。</li><li><code>(163840K)</code>: 年轻代的总容量是 163840 KB（160 MB）。</li></ul></li><li><strong>老年代回收</strong>: <code>[ParOldGen: 6227K-&gt;7621K(349696K)]</code><ul><li><strong>ParOldGen</strong>: 使用并行老年代垃圾回收器（Parallel Old Generation）。</li><li><code>6227K-&gt;7621K</code>: 表示在回收前老年代占用 6227 KB 内存，回收后增加到 7621 KB。这通常表示有一些对象从年轻代晋升到老年代。</li><li><code>(349696K)</code>: 老年代的总容量是 349696 KB（341.5 MB）。</li></ul></li><li><strong>堆总内存使用情况</strong>: <code>9491K-&gt;7621K(513536K)</code><ul><li><code>9491K-&gt;7621K</code>: 表示在 GC 前整个堆（年轻代 + 老年代）使用的总内存为 9491 KB，GC 后减少到 7621 KB。</li><li><code>(513536K)</code>: 堆的总容量是 513536 KB（501.25 MB）。</li></ul></li><li><strong>元空间（Metaspace）</strong>: <code>[Metaspace: 20472K-&gt;20472K(1067008K)]</code><ul><li><code>20472K-&gt;20472K</code>: 表示元空间（用于存储类的元数据）的使用量在 GC 前后保持不变，为 20472 KB。</li><li><code>(1067008K)</code>: 元空间的总容量是 1067008 KB（1042 MB）。</li></ul></li><li><strong>GC 事件耗时</strong>: <code>0.0627380 secs</code><ul><li>表示 GC 事件的总持续时间为 0.0627380 秒（约 62 毫秒）。</li></ul></li><li><strong>GC 时间分解</strong>: <code>[Times: user=0.04 sys=0.00, real=0.06 secs]</code><ul><li><code>user=0.04</code>: 用户态 CPU 时间（多个 CPU 线程的总和）是 0.04 秒。</li><li><code>sys=0.00</code>: 内核态 CPU 时间是 0.00 秒。</li><li><code>real=0.06</code>: 真实时间，即 GC 事件的墙钟时间是 0.06 秒。这个值通常比 <code>user</code> 和 <code>sys</code> 时间之和略大，反映了多线程并行执行的情况。</li></ul></li></ol><h1 id="三、GC日志分析工具"><a href="#三、GC日志分析工具" class="headerlink" title="三、GC日志分析工具"></a>三、GC日志分析工具</h1><p>上节介绍了GC日志的打印及含义，但是GC日志看起来比较麻烦，本节将会介绍一下GC日志可视化分析工具GCeasy和GCviewer等。通过GC日志可视化分析工具，我们可以很方便的看到JVM各个分代的内存使用情况、垃圾回收次数、垃圾回收的原因、垃圾回收占用的时间、吞吐量等，这些指标在我们进行JVM调优的时候是很有用的。</p><p>如果想把GC日志存到文件的话，是下面这个参数：</p><pre><code class="highlight shell">-Xloggc:/path/to/gc.log<span class="meta prompt_"># </span><span class="language-bash">示例</span>java -Xms512m -Xmx512m -XX:+PrintGCDetails -XX:+PrintGCDateStamps -Xloggc:/opt/module/ioms/ioms-ums/gc-%t.log -jar ioms-ums.jar --spring.profiles.active=dev</code></pre><p>然后就可以用一些工具去分析这些gc日志。</p><p><strong>示例代码1</strong></p><pre><code class="highlight java"><span class="comment">/**</span><span class="comment"> * 测试生成详细的日志文件</span><span class="comment"> *</span><span class="comment"> * -Xms60m -Xmx60m -XX:SurvivorRatio=8 -XX:+PrintGCDetails -XX:+PrintGCDateStamps -XX:+PrintHeapAtGC -Xloggc:d:/gc-log-%t.log</span><span class="comment"> *</span><span class="comment"> */</span><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">GCLogTest</span> &#123;    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;        ArrayList&lt;<span class="type">byte</span>[]&gt; list = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; <span class="number">5000</span>; i++) &#123;            <span class="type">byte</span>[] arr = <span class="keyword">new</span> <span class="title class_">byte</span>[<span class="number">1024</span> * <span class="number">50</span>];<span class="comment">//50KB</span>            list.add(arr);            <span class="keyword">try</span> &#123;                Thread.sleep(<span class="number">30</span>);            &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;                e.printStackTrace();            &#125;        &#125;    &#125;&#125;</code></pre><p><strong>示例代码2</strong></p><pre><code class="highlight java"><span class="comment">/**</span><span class="comment"> * java.lang.OutOfMemoryError: Metaspace异常演示：</span><span class="comment"> *</span><span class="comment"> * -Xms60m -Xmx60m -XX:MetaspaceSize=10m -XX:MaxMetaspaceSize=10m -XX:SurvivorRatio=8 -XX:+PrintGCDetails -XX:+PrintGCTimeStamps -XX:+PrintGCDateStamps -XX:+PrintHeapAtGC -Xloggc:d:/meta-log-%t.log</span><span class="comment"> *</span><span class="comment"> */</span><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">MetaspaceOOM</span> <span class="keyword">extends</span> <span class="title class_">ClassLoader</span> &#123;    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;        <span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> <span class="number">0</span>;        <span class="keyword">try</span> &#123;            <span class="type">MetaspaceOOM</span> <span class="variable">test</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">MetaspaceOOM</span>();            <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; <span class="number">10000</span>; i++) &#123;                <span class="comment">//创建ClassWriter对象，用于生成类的二进制字节码</span>                <span class="type">ClassWriter</span> <span class="variable">classWriter</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ClassWriter</span>(<span class="number">0</span>);                <span class="comment">//指明版本号，修饰符，类名，包名，父类，接口</span>                classWriter.visit(Opcodes.V1_8, Opcodes.ACC_PUBLIC, <span class="string">&quot;Class&quot;</span> + i, <span class="literal">null</span>, <span class="string">&quot;java/lang/Object&quot;</span>, <span class="literal">null</span>);                <span class="comment">//返回byte[]</span>                <span class="type">byte</span>[] code = classWriter.toByteArray();                <span class="comment">//类的加载</span>                test.defineClass(<span class="string">&quot;Class&quot;</span> + i, code, <span class="number">0</span>, code.length);<span class="comment">//Class对象</span>                j++;            &#125;        &#125; <span class="keyword">finally</span> &#123;            System.out.println(j);        &#125;    &#125;&#125;</code></pre><h2 id="1-GCeasy"><a href="#1-GCeasy" class="headerlink" title="1. GCeasy"></a>1. GCeasy</h2><p><strong>基本概述</strong></p><p>GCeasy——一款超好用的在线分析GC日志的网站官网地址：<a href="https://gceasy.io/gc-dashboard.jsp">https://gceasy.io/gc-dashboard.jsp</a></p><p>GCeasy是一款在线的GC日志分析器，可以通过GC日志分析进行内存泄漏检测、GC暂停原因分析、JVM配置建议优化等功能，而且是可以免费使用的（有一些服务是收费的）。</p><p><img src="https://raw.githubusercontent.com/GeorgeChan95/blogimg/master/img/2024/08/28/20240828-160343.png" alt="GCeasy官网"></p><p><strong>分析结果</strong></p><p><img src="https://raw.githubusercontent.com/GeorgeChan95/blogimg/master/img/2024/08/28/20240828-160459.png" alt="内存分析"></p><p><img src="https://raw.githubusercontent.com/GeorgeChan95/blogimg/master/img/2024/08/28/20240828-160520.png" alt="gc时间分析"></p><p><img src="https://raw.githubusercontent.com/GeorgeChan95/blogimg/master/img/2024/08/28/20240828-160833.png" alt="堆的使用"></p><p><img src="https://raw.githubusercontent.com/GeorgeChan95/blogimg/master/img/2024/08/28/20240828-160741.png" alt="GC统计"></p><p>等等……</p><h2 id="2-GCViewer"><a href="#2-GCViewer" class="headerlink" title="2. GCViewer"></a>2. GCViewer</h2><h3 id="2-1-基本概述"><a href="#2-1-基本概述" class="headerlink" title="2.1 基本概述"></a>2.1 基本概述</h3><p><code>GCViewer</code> 是一个免费的、开源的分析小工具，用于可视化查看由SUN&#x2F;Oracle,IBM,HP和BEA Java虚拟机产生的垃圾收集器的日志。</p><p>GCViewer用于可视化Java VM选项 <code>-verbose:gc</code> 和.NET生成的数据 <code>-Xloggc:&lt;file&gt;</code> 。它还计算与垃圾回收相关的性能指标（吞吐量，累积的暂停，最长的暂停等）。当通过更改世代大小或设置初始堆大小来调整特定应用程序的垃圾回收时，此功能非常有用。</p><h3 id="2-2-安装"><a href="#2-2-安装" class="headerlink" title="2.2 安装"></a>2.2 安装</h3><p><strong>下载GCViewer工具</strong></p><ul><li>源码下载: <a href="https://github.com/chewiebug/GCViewer">https://github.com/chewiebug/GCViewer</a></li><li>运行版本下载: <a href="https://github.com/chewiebug/GCViewer/wiki/Changelog">https://github.com/chewiebug/GCViewer/wiki/Changelog</a></li></ul><h3 id="2-3-启动GCViewer-gui"><a href="#2-3-启动GCViewer-gui" class="headerlink" title="2.3 启动GCViewer(gui)"></a>2.3 启动GCViewer(gui)</h3><p>需双击 <code>gcviewer-1.3x.jar</code></p><p>或</p><p>需要运行java1.8 vm</p><pre><code class="highlight shell">java -jar gcviewer-1.3x.jar</code></pre><p><img src="https://raw.githubusercontent.com/GeorgeChan95/blogimg/master/img/2024/08/28/20240828-162437.png" alt="GCViewer"></p><p>很难用！！！</p><h2 id="3-其他工具"><a href="#3-其他工具" class="headerlink" title="3. 其他工具"></a>3. 其他工具</h2><h3 id="3-1-GChisto"><a href="#3-1-GChisto" class="headerlink" title="3.1 GChisto"></a>3.1 GChisto</h3><p><code>GChisto</code> 是一款专业分析gc日志的工具，可以通过gc日志来分析 : MinorGC、Full GC的次数、频率、持续时间等，通过列表、报表、图表等不同形式来反应gc的情况。</p><p>虽然界面略显粗糙，但是功能还是不错的。</p><p>官网上没有下载的地方，需要自己从SVN上拉下来编译，不过这个工具似乎没怎么维护了，存在不少bug</p><h3 id="3-2-HPjmeter"><a href="#3-2-HPjmeter" class="headerlink" title="3.2 HPjmeter"></a>3.2 HPjmeter</h3><p>工具很强大，但只能打开由以下参数生成的 <code>GC log</code> , <code>-verbose:gc</code> <code>-Xloggc:gc.log</code> 。添加其他参数生成的 gc.log无法打开</p><p>HPjmeter集成了以前的 <code>HPjtune</code> 功能，可以分析在HP机器上产生的垃圾回收日志文件</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;一、GC日志参数&quot;&gt;&lt;a href=&quot;#一、GC日志参数&quot; class=&quot;headerlink&quot; title=&quot;一、GC日志参数&quot;&gt;&lt;/a&gt;一、GC日志参数&lt;/h1&gt;&lt;ul&gt;
&lt;li&gt;&lt;p&gt;&lt;code&gt;-verbose:gc&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;输出gc日</summary>
      
    
    
    
    <category term="JVM" scheme="https://georgechan95.github.io/categories/JVM/"/>
    
    
    <category term="java" scheme="https://georgechan95.github.io/tags/java/"/>
    
    <category term="jvm" scheme="https://georgechan95.github.io/tags/jvm/"/>
    
  </entry>
  
  <entry>
    <title>第二十四章-JVM运行时参数</title>
    <link href="https://georgechan95.github.io/blog/944806143.html"/>
    <id>https://georgechan95.github.io/blog/944806143.html</id>
    <published>2024-08-27T10:30:10.000Z</published>
    <updated>2024-08-28T04:17:33.350Z</updated>
    
    <content type="html"><![CDATA[<h1 id="一、JVM参数选项"><a href="#一、JVM参数选项" class="headerlink" title="一、JVM参数选项"></a>一、JVM参数选项</h1><p>官网地址：<a href="https://docs.oracle.com/javase/8/docs/technotes/tools/unix/java.html">https://docs.oracle.com/javase/8/docs/technotes/tools/unix/java.html</a></p><h2 id="1-类型一：标准参数选项"><a href="#1-类型一：标准参数选项" class="headerlink" title="1. 类型一：标准参数选项"></a>1. 类型一：标准参数选项</h2><h3 id="1-1-特点"><a href="#1-1-特点" class="headerlink" title="1.1 特点"></a>1.1 特点</h3><ul><li>比较稳定，后续版本基本不会变化</li><li>以 <code>-</code> 开头</li></ul><h3 id="1-2-各种选项"><a href="#1-2-各种选项" class="headerlink" title="1.2 各种选项"></a>1.2 各种选项</h3><p>运行 <code>java</code> 或者 <code>java-help</code> 可以看到所有的标准选项</p><pre><code class="highlight shell">C:\Users\kd&gt;java -help用法: java [-options] class [args...]           (执行类)   或  java [-options] -jar jarfile [args...]           (执行 jar 文件)其中选项包括:    -d32          使用 32 位数据模型 (如果可用)    -d64          使用 64 位数据模型 (如果可用)    -server       选择 &quot;server&quot; VM                  默认 VM 是 server.    -cp &lt;目录和 zip/jar 文件的类搜索路径&gt;    -classpath &lt;目录和 zip/jar 文件的类搜索路径&gt;                  用 ; 分隔的目录, JAR 档案                  和 ZIP 档案列表, 用于搜索类文件。    -D&lt;名称&gt;=&lt;值&gt;                  设置系统属性    -verbose:[class|gc|jni]                  启用详细输出    -version      输出产品版本并退出    -version:&lt;值&gt;                  警告: 此功能已过时, 将在                  未来发行版中删除。                  需要指定的版本才能运行    -showversion  输出产品版本并继续    -jre-restrict-search | -no-jre-restrict-search                  警告: 此功能已过时, 将在                  未来发行版中删除。                  在版本搜索中包括/排除用户专用 JRE    -? -help      输出此帮助消息    -X            输出非标准选项的帮助    -ea[:&lt;packagename&gt;...|:&lt;classname&gt;]    -enableassertions[:&lt;packagename&gt;...|:&lt;classname&gt;]                  按指定的粒度启用断言    -da[:&lt;packagename&gt;...|:&lt;classname&gt;]    -disableassertions[:&lt;packagename&gt;...|:&lt;classname&gt;]                  禁用具有指定粒度的断言    -esa | -enablesystemassertions                  启用系统断言    -dsa | -disablesystemassertions                  禁用系统断言    -agentlib:&lt;libname&gt;[=&lt;选项&gt;]                  加载本机代理库 &lt;libname&gt;, 例如 -agentlib:hprof                  另请参阅 -agentlib:jdwp=help 和 -agentlib:hprof=help    -agentpath:&lt;pathname&gt;[=&lt;选项&gt;]                  按完整路径名加载本机代理库    -javaagent:&lt;jarpath&gt;[=&lt;选项&gt;]                  加载 Java 编程语言代理, 请参阅 java.lang.instrument    -splash:&lt;imagepath&gt;                  使用指定的图像显示启动屏幕有关详细信息, 请参阅 http://www.oracle.com/technetwork/java/javase/documentation/index.html。</code></pre><h3 id="1-3-补充内容-server-与-client"><a href="#1-3-补充内容-server-与-client" class="headerlink" title="1.3 补充内容 -server 与 -client"></a>1.3 补充内容 -server 与 -client</h3><p><code>Hotspot JVM</code> 有两种模式，分别是 <code>server</code> 和 <code>client</code> , 分别通过 <code>-server</code> 和 <code>-client</code> 模式设置</p><ul><li><p>在32位Windows系统上，默认使用Client类型的JVM。要想使用 <code>Server</code> 模式，则机器配置至少有2个以上的CPU和2G以上的物理内存。<code>client</code> 模式适用于对内存要求较小的桌面应用程序，默认使用Serial串行垃圾收集器</p></li><li><p>64位机器上只支持server模式的JVM,适用于需要大内存的应用程序，默认使用并行垃圾收集器关于server和client的官网介绍为：<a href="https://docs.oracle.com/javase/8/docs/technotes/guides/vm/index.html">https://docs.oracle.com/javase/8/docs/technotes/guides/vm/index.html</a></p><p><img src="https://raw.githubusercontent.com/GeorgeChan95/blogimg/master/img/2024/08/27/20240827-184239.png" alt="server模式"></p></li></ul><h2 id="2-类型二：-X参数选项"><a href="#2-类型二：-X参数选项" class="headerlink" title="2. 类型二：-X参数选项"></a>2. 类型二：-X参数选项</h2><h3 id="2-1-特点"><a href="#2-1-特点" class="headerlink" title="2.1 特点"></a>2.1 特点</h3><ul><li>非标准化参数</li><li>功能还是比较稳定的，但官方说后续高版本可能变更</li><li>以 <code>-X</code> 开头</li></ul><h3 id="2-2-各种选项"><a href="#2-2-各种选项" class="headerlink" title="2.2 各种选项"></a>2.2 各种选项</h3><p>直接在DOS窗口中运行 <code>java -X</code> 命令可以看到所有的X选项</p><pre><code class="highlight shell">C:\Users\kd&gt;java -X    -Xmixed           混合模式执行 (默认)    -Xint             仅解释模式执行    -Xbootclasspath:&lt;用 ; 分隔的目录和 zip/jar 文件&gt;                      设置搜索路径以引导类和资源    -Xbootclasspath/a:&lt;用 ; 分隔的目录和 zip/jar 文件&gt;                      附加在引导类路径末尾    -Xbootclasspath/p:&lt;用 ; 分隔的目录和 zip/jar 文件&gt;                      置于引导类路径之前    -Xdiag            显示附加诊断消息    -Xnoclassgc       禁用类垃圾收集    -Xincgc           启用增量垃圾收集    -Xloggc:&lt;file&gt;    将 GC 状态记录在文件中 (带时间戳)    -Xbatch           禁用后台编译    -Xms&lt;size&gt;        设置初始 Java 堆大小    -Xmx&lt;size&gt;        设置最大 Java 堆大小    -Xss&lt;size&gt;        设置 Java 线程堆栈大小    -Xprof            输出 cpu 配置文件数据    -Xfuture          启用最严格的检查, 预期将来的默认值    -Xrs              减少 Java/VM 对操作系统信号的使用 (请参阅文档)    -Xcheck:jni       对 JNI 函数执行其他检查    -Xshare:off       不尝试使用共享类数据    -Xshare:auto      在可能的情况下使用共享类数据 (默认)    -Xshare:on        要求使用共享类数据, 否则将失败。    -XshowSettings    显示所有设置并继续    -XshowSettings:all                      显示所有设置并继续    -XshowSettings:vm 显示所有与 vm 相关的设置并继续    -XshowSettings:properties                      显示所有属性设置并继续    -XshowSettings:locale                      显示所有与区域设置相关的设置并继续-X 选项是非标准选项, 如有更改, 恕不另行通知。</code></pre><h3 id="2-3-JVM的JIT编译模式相关的选项"><a href="#2-3-JVM的JIT编译模式相关的选项" class="headerlink" title="2.3 JVM的JIT编译模式相关的选项"></a>2.3 JVM的JIT编译模式相关的选项</h3><ul><li><p><code>-Xint</code> : 只使用解释器：所有字节码都被解释执行，这个模式的速度是很慢的</p></li><li><p><code>-Xcomp</code> : 只使用编译器：所有字节码第一次使用就被编译成本地代码，然后在执行</p></li><li><p>-Xmixed : 混合模式：这是默认模式，刚开始的时候使用解释器慢慢解释执行，后来让JIT即时编译器根据程序运行的情况，有选择地将某些热点代码提前编译并缓存在本地，在执行的时候效率就非常高了</p><p><img src="https://raw.githubusercontent.com/GeorgeChan95/blogimg/master/img/2024/08/27/20240827-185220.png" alt="默认使用混合模式"></p></li></ul><h3 id="2-4-参数特别说明"><a href="#2-4-参数特别说明" class="headerlink" title="2.4 参数特别说明"></a>2.4 参数特别说明</h3><ul><li><code>-Xms&lt;size&gt;</code> ：设置初始Java堆大小，等价于 <code>-XX:InitialHeapSize</code></li><li><code>-Xmx&lt;size&gt;</code> ：设置最大Java堆大小，等价于 <code>-XX:MaxHeapSize</code></li><li><code>-Xss&lt;size&gt;</code> ：设置Java线程堆栈大小，等价于 <code>-XX:ThreadStackSize</code></li></ul><p>单位：k&#x2F;K、m&#x2F;M、g&#x2F;G<br>设置：-Xmx、-Xms 最好设置成一样的值，避免扩容带来的损耗</p><h2 id="3-类型三：-XX参数选项"><a href="#3-类型三：-XX参数选项" class="headerlink" title="3. 类型三：-XX参数选项"></a>3. 类型三：-XX参数选项</h2><h3 id="3-1-特点"><a href="#3-1-特点" class="headerlink" title="3.1 特点"></a>3.1 特点</h3><ul><li>非标准化参数</li><li>使用的最多的参数类型</li><li>这类选项属于实验性，不稳定</li><li>以 <code>-XX</code> 开头</li></ul><h3 id="3-2-作用"><a href="#3-2-作用" class="headerlink" title="3.2 作用"></a>3.2 作用</h3><p>用于开发和调试JVM</p><h3 id="3-3-分类"><a href="#3-3-分类" class="headerlink" title="3.3 分类"></a>3.3 分类</h3><h4 id="3-3-1-Boolean类型格式"><a href="#3-3-1-Boolean类型格式" class="headerlink" title="3.3.1 Boolean类型格式"></a>3.3.1 Boolean类型格式</h4><ul><li><p><code>-XX:+&lt;option&gt;</code>  表示启用option属性</p></li><li><p><code>-XX:-&lt;option&gt;</code>  表示禁用option属性</p></li></ul><p><strong>举例</strong></p><ul><li><p><code>-XX:+UseParallelGC</code> 选择垃圾收集器为并行收集器</p></li><li><p><code>-XX:+UseG1GC</code> 表示启用G1收集器</p></li><li><p><code>-XX:+UseAdaptiveSizePolicy</code> 自动选择年轻代区大小和相应的Survivor区比例</p></li></ul><p><strong>说明</strong></p><p>说明：因为有的指令默认是开启的，所以可以使用 <code>-</code> 关闭</p><h4 id="3-3-2-非Boolean类型格式（key-value类型）"><a href="#3-3-2-非Boolean类型格式（key-value类型）" class="headerlink" title="3.3.2 非Boolean类型格式（key-value类型）"></a>3.3.2 非Boolean类型格式（key-value类型）</h4><ul><li><p>数值型格式 <code>-XX:&lt;option&gt;=&lt;number&gt;</code></p><p><code>number</code> 表示数值，<code>number</code> 可以带上单位</p><p>比如：<br><code>m</code> 、<code>M</code> 表示 兆<br><code>k</code> 、<code>K</code> 表示 <code>Kb</code><br><code>g</code> 、<code>G</code> 表示 <code>g</code> ( 例如 : <code>32k</code> 跟 <code>32768</code> 是一样的效果 ）</p><p><strong>举例</strong></p><ul><li><p>设置新生代初始大小为1024兆</p><pre><code class="highlight shell">-XX:NewSize=1024m</code></pre></li><li><p>设置GC停顿时间：500毫秒</p><pre><code class="highlight shell">-XX:MaxGCPauseMillis=500</code></pre></li><li><p>设置吞吐量</p><pre><code class="highlight shell">-XX:GCTimeRatio=19</code></pre></li><li><p>新生代与老年代的比例</p><pre><code class="highlight shell">-XX:NewRatio=2</code></pre></li></ul></li><li><p>非数值型格式 <code>-XX:&lt;name&gt;=&lt;string&gt;</code></p><p><strong>举例</strong></p><ul><li><p>指定heap转存文件的存储路径</p><pre><code class="highlight shell">-XX:HeapDumpPath=/usr/local/heapdump.hprof</code></pre></li></ul></li></ul><h3 id="3-4-特别参数说明"><a href="#3-4-特别参数说明" class="headerlink" title="3.4 特别参数说明"></a>3.4 特别参数说明</h3><p><code>-XX:+PrintFlagsFinal</code> : 输出所有参数的名称和默认值</p><p>默认不包括 <code>Diagnostic</code>(诊断) 和 <code>Experimental</code>(实验) 的参数</p><p>可以配合 <code>-XX:+UnlockDiagnosticVMOptions</code> 和 <code>-XX:UnlockExperimentalVMOptions</code> 使用</p><h1 id="二、添加JVM参数选项"><a href="#二、添加JVM参数选项" class="headerlink" title="二、添加JVM参数选项"></a>二、添加JVM参数选项</h1><h2 id="1-Eclipse"><a href="#1-Eclipse" class="headerlink" title="1. Eclipse"></a>1. Eclipse</h2><ol><li><p>在空白处单击右键，选择Run As，在选择Run Configurations……</p><p><img src="https://raw.githubusercontent.com/GeorgeChan95/blogimg/master/img/2024/08/27/20240827-192230.png" alt="eclipse添加JVM选项1"></p></li><li><p>设置虚拟机参数</p><p><img src="https://raw.githubusercontent.com/GeorgeChan95/blogimg/master/img/2024/08/27/20240827-192311.png" alt="eclipse添加JVM选项2"></p></li></ol><h2 id="2-IDEA"><a href="#2-IDEA" class="headerlink" title="2. IDEA"></a>2. IDEA</h2><ol><li><p>Edit Configurations…</p><p><img src="https://raw.githubusercontent.com/GeorgeChan95/blogimg/master/img/2024/08/27/20240827-192358.png" alt="IDEA添加JVM选项1"></p></li><li><p>设置虚拟机参数</p><p><img src="https://raw.githubusercontent.com/GeorgeChan95/blogimg/master/img/2024/08/27/20240827-192428.png" alt="IDEA添加JVM选项2"></p></li></ol><h2 id="3-运行jar包"><a href="#3-运行jar包" class="headerlink" title="3. 运行jar包"></a>3. 运行jar包</h2><p>java -Xms500m -Xmx500m -XX:+PrintGCDetails -XX:+PrintGCTimeStamps -jar demo.jar</p><p>这是在java -jar demo.jar中的java -jar之间添加了虚拟机配置信息</p><h2 id="4-通过Tomcat运行war包"><a href="#4-通过Tomcat运行war包" class="headerlink" title="4. 通过Tomcat运行war包"></a>4. 通过Tomcat运行war包</h2><ul><li>Linux系统下可以在 tomcat&#x2F;bin&#x2F;catalina.sh 中添加类似如下配置：JAVA_OPTS&#x3D;”-Xms512M -Xmx1024M”</li><li>Windows系统下载 catalina.bat 中添加类似如下配置：set “JAVA_OPTS&#x3D;-Xms512M -Xmx1024M”</li></ul><h2 id="5-程序运行过程中"><a href="#5-程序运行过程中" class="headerlink" title="5. 程序运行过程中"></a>5. 程序运行过程中</h2><p><code>jinfo</code> 不仅可以查看运行时某一个 Java 虚拟机参数的实际取值，甚至可以在运行时修改部分参数，并使之立即生效。</p><p>但是，并非所有参数都支持动态修改。参数只有被标记为 manageable 的 flag 可以被实时修改。其实，这个修改能力是极其有限的。</p><p><strong>查看被标记为 manageable 的参数</strong></p><p><code>java -XX:+PrintFlagsFinal -version | grep &quot;manageable&quot;</code> 可以查看标记为 <code>manageable</code> 的参数</p><pre><code class="highlight shell">root@ubuntu:~# java -XX:+PrintFlagsFinal -version | grep &quot;manageable&quot;     intx CMSAbortablePrecleanWaitMillis            = 100                                 &#123;manageable&#125;     intx CMSTriggerInterval                        = -1                                  &#123;manageable&#125;     intx CMSWaitDuration                           = 2000                                &#123;manageable&#125;     bool HeapDumpAfterFullGC                       = false                               &#123;manageable&#125;     bool HeapDumpBeforeFullGC                      = false                               &#123;manageable&#125;     bool HeapDumpOnOutOfMemoryError                = false                               &#123;manageable&#125;    ccstr HeapDumpPath                              =                                     &#123;manageable&#125;    uintx MaxHeapFreeRatio                          = 100                                 &#123;manageable&#125;    uintx MinHeapFreeRatio                          = 0                                   &#123;manageable&#125;     bool PrintClassHistogram                       = false                               &#123;manageable&#125;     bool PrintClassHistogramAfterFullGC            = false                               &#123;manageable&#125;     bool PrintClassHistogramBeforeFullGC           = false                               &#123;manageable&#125;     bool PrintConcurrentLocks                      = false                               &#123;manageable&#125;     bool PrintGC                                   = false                               &#123;manageable&#125;     bool PrintGCDateStamps                         = false                               &#123;manageable&#125;     bool PrintGCDetails                            = false                               &#123;manageable&#125;     bool PrintGCID                                 = false                               &#123;manageable&#125;     bool PrintGCTimeStamps                         = false                               &#123;manageable&#125;java version &quot;1.8.0_261&quot;Java(TM) SE Runtime Environment (build 1.8.0_261-b12)Java HotSpot(TM) 64-Bit Server VM (build 25.261-b12, mixed mode)</code></pre><ul><li><p>设置非Boolean类型参数</p><p><code>jinfo -flag &lt;name&gt;=&lt;value&gt; &lt;pid&gt;</code></p></li><li><p>设置Boolean类型参数</p><p><code>jinfo -flag [+|-] &lt;name&gt; &lt;pid&gt;</code></p><p>示例： jinfo -flag +PrintGCDetails 29536</p></li></ul><h1 id="三、常用的JVM参数选项"><a href="#三、常用的JVM参数选项" class="headerlink" title="三、常用的JVM参数选项"></a>三、常用的JVM参数选项</h1><h2 id="1-打印设置的XX选项及值"><a href="#1-打印设置的XX选项及值" class="headerlink" title="1. 打印设置的XX选项及值"></a>1. 打印设置的XX选项及值</h2><ul><li><p>-XX:+PrintCommandLineFlags 可以让程序运行前打印出用户手动设置或者JVM自动设置的XX选项</p></li><li><p>-XX:+PrintFlagsInitial 表示打印出所有XX选项的默认值</p></li><li><p>-XX:+PrintFlagsFinal 表示打印出XX选项在运行程序时生效的值</p><p>如果值的前面加上了 <code>:=</code> ，说明该值不是初始值，该值可能被 jvm 自动改变了，也可能被我们设置的参数改变了，如下所示：</p><p><img src="https://raw.githubusercontent.com/GeorgeChan95/blogimg/master/img/2024/08/27/20240827-200720.png" alt="PrintFlagsFinal"></p></li><li><p>-XX:+PrintVMOptions 打印JVM的参数</p></li></ul><h2 id="2-堆、栈、方法区等内存大小设置"><a href="#2-堆、栈、方法区等内存大小设置" class="headerlink" title="2. 堆、栈、方法区等内存大小设置"></a>2. 堆、栈、方法区等内存大小设置</h2><h3 id="2-1-栈"><a href="#2-1-栈" class="headerlink" title="2.1 栈"></a>2.1 栈</h3><ul><li>-Xss128k 或 -XX:ThreadStackSize&#x3D;128k ：设置每个线程的栈大小为128k</li></ul><h3 id="2-2-堆内存"><a href="#2-2-堆内存" class="headerlink" title="2.2 堆内存"></a>2.2 堆内存</h3><ul><li>-Xms3550m 或 -XX:InitialHeapSize&#x3D;3550m ：设置JVM初始堆内存为3550M</li><li>-Xmx3550m 或 -XX:MaxHeapSize&#x3D;3550m ：设置JVM最大堆内存为3550M</li><li>-Xmn2g ：设置年轻代大小为2G, 官方推荐配置为整个堆大小的3&#x2F;8</li><li>-XX:NewSize&#x3D;1024m：设置年轻代初始值为1024M</li><li>-XX:MaxNewSize&#x3D;1024m ：设置年轻代最大值为1024M</li><li>-XX:SurvivorRatio&#x3D;8 ：设置年轻代中Eden区与一个Survivor区的比值，默认为8</li><li>-XX:+UseAdaptiveSizePolicy ：自动选择各区大小比例</li><li>-XX:NewRatio&#x3D;4 ：设置<strong>老年代</strong>与<strong>年轻代</strong>（包括1个Eden和2个Survivor区）的比值</li><li>-XX:PretenureSizeThreadshold&#x3D;1024 ：设置让大于此阀值的对象直接分配在老年代，单位为字节<br>只对Serial、ParNew收集器有效</li><li>-XX:MaxTenuringThreshold&#x3D;15 ：新生代每次 <code>MinorGC</code> 后，还存活的对象年龄 + 1 , 当对象的年龄大于设置的这个值时就进入老年代,默认值为15</li><li>-XX:+PrintTenuringDistribution ：每次 <code>MinorGC</code> 后打印出当前使用的 <code>Survivor</code> 中对象的年龄分布</li><li>-XX:TargetSurvivorRatio ：<code>MinorGC</code> 结束后 <code>Survivor</code> 区域中占用空间的期望比例</li></ul><h3 id="2-3-方法区"><a href="#2-3-方法区" class="headerlink" title="2.3 方法区"></a>2.3 方法区</h3><h4 id="2-3-1-永久代"><a href="#2-3-1-永久代" class="headerlink" title="2.3.1 永久代"></a>2.3.1 永久代</h4><ul><li>-XX:PermSize&#x3D;256m  ：设置<strong>永久代初始值</strong>为256M</li><li>-XX:MaxPermSize&#x3D;256m ：设置永久代最大值为256M</li></ul><h4 id="2-3-2-元空间"><a href="#2-3-2-元空间" class="headerlink" title="2.3.2 元空间"></a>2.3.2 元空间</h4><ul><li>-XX:MetaspaceSize ：初始空间大小</li><li>-XX:MaxMetaspaceSize ：最大空间，默认没有限制</li><li>-XX:+UseCompressedOops ：压缩对象指针</li><li>-XX:+UseCompressedClassPointers ：压缩类指针</li><li>-XX:CompressedClassSpaceSize ：设置Klass Metaspace的大小，默认1G</li></ul><h3 id="2-4-直接内存"><a href="#2-4-直接内存" class="headerlink" title="2.4 直接内存"></a>2.4 直接内存</h3><ul><li>-XX:MaxDirectMemorySize ：指定 DirectMemory 容量，若未指定，则默认与Java堆最大值一样</li></ul><h2 id="3-OutOfMemory相关的选项"><a href="#3-OutOfMemory相关的选项" class="headerlink" title="3. OutOfMemory相关的选项"></a>3. OutOfMemory相关的选项</h2><ul><li><p>-XX:+HeapDumpOnOutOfMemoryError ：内存出现OOM的时候，把Heap转存（Dump)到文件以便后续分析</p></li><li><p>-XX:+HeapDumpBeforeFullGC ：在出现FullGC之前，生成Heap转储文件</p></li><li><p><code>-XX:HeapDumpPath=&lt;path&gt;</code> ：指定heap转存文件的存储路径</p></li><li><p>-XX:OnOutOfMemoryError ：指定一个程序或者脚本的路径，当发生OOM的时候，去执行这个脚本</p><p><strong>举例：</strong></p><p>以部署在linux系统 <code>/opt/Server</code> 目录下的 <code>ioms-ums.jar</code> 为例</p><ul><li><p>在 <code>run.sh</code> 启动脚本中添加jvm参数：</p><pre><code class="highlight shell">-XX:OnOutOfMemoryError=/opt/Server/restart.sh</code></pre></li><li><p>restart.sh 脚本</p><ul><li><p>linux环境：</p><pre><code class="highlight shell"><span class="meta prompt_">#</span><span class="language-bash">!/bin/bash</span>pid=$(ps -ef|grep ioms-ums.jar|awk &#x27;&#123;if($8==&quot;java&quot;) &#123;print $2&#125;&#125;&#x27;)kill -9 $pidcd /opt/Server/;sh run.sh</code></pre></li><li><p>Windows环境：</p><pre><code class="highlight shell">echo offwmic process where Name=&#x27;java.exe&#x27; deletecd D:\Serverstart run.bat</code></pre></li></ul></li></ul></li></ul><h2 id="4-垃圾收集器相关选项"><a href="#4-垃圾收集器相关选项" class="headerlink" title="4. 垃圾收集器相关选项"></a>4. 垃圾收集器相关选项</h2><p>7款经典收集器与垃圾分代之间的关系 :</p><p><img src="https://raw.githubusercontent.com/GeorgeChan95/blogimg/master/img/2024/08/27/20240827-203512.png" alt="垃圾收集器分代关系"></p><p>垃圾收集器的组合关系 :</p><p><img src="https://raw.githubusercontent.com/GeorgeChan95/blogimg/master/img/2024/08/27/20240827-203533.png" alt="垃圾收集器的组合关系"></p><h3 id="4-1-查看默认垃圾收集器"><a href="#4-1-查看默认垃圾收集器" class="headerlink" title="4.1 查看默认垃圾收集器"></a>4.1 查看默认垃圾收集器</h3><ul><li><p><code>-XX:+PrintCommandLineFlags</code> 查看命令行相关参数（包含使用的垃圾收集器）</p></li><li><p><code>jinfo -flag 相关垃圾回收器参数 进程ID</code>，作用：使用命令行指令</p><ul><li><p>注意：只能修改被标记为 manageable 的参数</p><p>java -XX:+PrintFlagsFinal -version | grep “manageable”</p></li></ul><p>示例：jinfo -flag +PrintGCDetails 29536</p></li></ul><h3 id="4-2-Serial回收器"><a href="#4-2-Serial回收器" class="headerlink" title="4.2 Serial回收器"></a>4.2 Serial回收器</h3><p><code>Serial</code> 收集器作为HotSpot中client模式下的 <strong>默认新生代垃圾收集器</strong>。<code>Serial Old</code> 是运行在 <code>Client</code> 模式下默认的老年代的垃圾回收器。</p><ul><li><p><code>-XX:+UseSerialGC</code></p><p>指定年轻代和老年代都使用串行收集器</p><p>等价于新生代用 <code>Serial GC</code> , 且老年代用 <code>Serial Old GC</code> 。可以获得最高的单线程收集效率</p></li></ul><h3 id="4-3-ParNew回收器"><a href="#4-3-ParNew回收器" class="headerlink" title="4.3 ParNew回收器"></a>4.3 ParNew回收器</h3><ul><li><p><code>-XX:+UseParNewGC</code></p><p>手动指定使用 <code>ParNew</code> 收集器执行内存回收任务。</p><p>它表示年轻代使用并行收集器，不影响老年代。</p></li><li><p><code>-XX:ParallelGCThreads=N</code></p><p>限制线程数量，默认开启和CPU数据相同的线程数</p></li></ul><h3 id="4-4-Parallel回收器"><a href="#4-4-Parallel回收器" class="headerlink" title="4.4 Parallel回收器"></a>4.4 Parallel回收器</h3><ul><li><p><code>-XX:+UseParallelGC</code> </p><p>手动指定<strong>年轻代</strong>使用 <code>Parallel</code> <strong>并行收集器</strong>执行内存回收任务</p></li><li><p><code>-XX:+UseParallelOldGC</code></p><p>手动指定老年代都是使用并行回收收集器。</p></li></ul><p>分别适用于新生代和老年代。默认jdk8是开启的。</p><p>上面两个参数，默认开启一个，另一个也会被开启。（互相激活）</p><ul><li><p><code>-XX:ParallelGCThreads</code> </p><p>设置年轻代并行收集器的线程数。<br>一般地，最好与CPU数量相等，以避免过多的线程数影响垃圾收集性能。</p><p>在默认情况下，当CPU数量小于8个，ParallelGCThreads的值等于CPU数量。<br>当CPU数量大于8个，ParallelGCThreads 的值 &#x3D; 3 + [ 5 * CPU_Count] &#x2F; 8 ]</p></li><li><p><code>-XX:MaxGCPauseMillis</code></p><p>设置垃圾收集器<strong>最大停顿时间</strong>（即STW的时间）。单位是毫秒。</p><ul><li>为了尽可能地把停顿时间控制在 <code>MaxGCPauseMills</code> 以内，收集器在工作时会调整Java堆大小 或 其他一些参数。</li><li>对于用户来讲，停顿时间越短体验越好。但是在服务器端，我们注重高并发，整体的吞吐量。所以服务器端适合Parallel , 进行控制。</li><li>该参数使用需谨慎。</li></ul></li><li><p><code>-XX:GCTimeRatio</code></p><p>垃圾收集时间占总时间的比例（ &#x3D;1 &#x2F; ( N + 1 ) )。用于衡量<strong>吞吐量</strong>的大小。</p><ul><li>取值范围（ 0 , 100 )。默认值99 , 也就是垃圾回收时间不超过1%</li><li>与前一个 <code>-XX:MaxGCPauseMillis</code> 参数有一定矛盾性。暂停时间越长，Radio参数就容易超过设定的比例</li></ul></li><li><p><code>-XX:+UseAdaptiveSizePolicy</code></p><p>设置 <code>Parallel Scavenge</code> 收集器具有自适应调节策略</p><ul><li><p>在这种模式下，<strong>年轻代</strong>的大小、<code>Eden</code> 和 <code>Survivor</code> 的比例、晋升<strong>老年代</strong>的对象年龄等参数会被自动调整，已达到在<strong>堆大小</strong>、<strong>吞吐量</strong>和<strong>停顿时间</strong>之间的平衡点。</p></li><li><p>在手动调优比较困难的场合，可以直接使用这种自适应的方式，仅指定虚拟机的<strong>最大堆</strong>、目标的<strong>吞吐量</strong>（ <code>GCTimeRatio</code> )和<strong>停顿时间</strong>（ <code>MaxGCPauseMills</code> ) , 让虚拟机自己完成调优工作。</p></li></ul></li></ul><h3 id="4-5-CMS回收器"><a href="#4-5-CMS回收器" class="headerlink" title="4.5 CMS回收器"></a>4.5 CMS回收器</h3><ul><li><p><code>-XX:+UseConcMarkSweepGC</code></p><p>手动指定使用CMS 收集器执行内存回收任务</p><ul><li>开启该参数后会自动将 <code>-XX:+UseParNewGC</code> 打开。即：ParNew ( Young区用）+ CMS(Old区用）+ <code>Serial Old</code> 的组合。</li></ul></li><li><p><code>-XX:CMSlnitiatingoccupanyFraction</code></p><p>设置堆内存使用率的阀值，一旦达到该阀值，便开始进行回收。</p><ul><li>JDK5及以前版本的默认值为68 , 即当老年代的空间使用率达到68%时，会执行一次CMS回收。JDK6及以上版本默认值为92%</li><li>如果内存增长缓慢，则可以设置一个稍大的值，大的阙值可以有效降低CMS的触发频率，减少老年代回收的次数可以较为明显地改善应用程序性能。反之，如果应用程序内存使用率增长很快，则应该降低这个阙值，以避免频繁触发老年代串行收集器。因此通过该选项便可以有效降低Full GC 的执行次数。</li></ul></li><li><p><code>-XX:+UseCMSComlpactAtFullCollection</code></p><p>用于指定在执行完Full GC后对内存空间进行压缩整理，以此避免内存碎片的产生。</p><ul><li>不过由于内存压缩整理过程无法并发执行，所带来的问题就是停顿时间变得更长了。</li></ul></li><li><p><code>-XX:CMSFullGCsBeforeCompaction</code></p><p>设置在执行多少次 <code>Full GC</code> 后对内存空间进行压缩整理。</p></li><li><p>-XX:ParallelCMSThreads</p><p>设置CMS的线程数量</p><ul><li>CMS默认启动的线程数是（ParallelGCThreads + 3 ) &#x2F; 4 , <code>ParallelGCThreads</code> 是<strong>年轻代并行收集器</strong>的线程数。当CPU资源比较紧张时，受到CMS收集器线程的影响，应用程序的性能在垃圾回收阶段可能会非常糟糕。</li></ul></li></ul><p><strong>补充参数</strong></p><ul><li><p><code>-XX:ConcGCThreads</code></p><p>设置并发垃圾收集的线程数，默认该值是基于 <code>ParallelGCThreads</code> 计算出来的；</p></li><li><p><code>-XX:+UseCMSInitiatingOccupancyonly</code></p><p>是否动态可调，用这个参数可以使CMS一直按 <code>CMSInitiatingOccupancyFraction</code> 设定的值启动</p></li><li><p><code>-XX:+CMSScavengeBeforeRemark</code></p><p>强制hotspot虚拟机在 <code>cms remark</code> 阶段之前做一次 <code>minor gc</code> ,用于提高 <code>remark</code> 阶段的速度；</p></li><li><p><code>-XX:+CMSClassUnloadingEnable</code></p><p>如果有的话，启用回收Perm区（JDK8之前）</p></li><li><p><code>-XX:+CMSParallelInitialEnabled</code></p><p>用于开启 <code>CMS initial-mark</code> 阶段采用多线程的方式进行标记，用于提高标记速度，在Java8开始已经默认开启；</p></li><li><p><code>-XX:+CMSParallelRemarkEnabled</code></p><p>用户开启<code>CMS remark</code> 阶段采用多线程的方式进行重新标记 , 默认开启；</p></li><li><p><code>-XX:+ExplicitGCInvokesConcurrent</code> <code>-XX:+ExplicitGCInvokesConcurrentAndUnloadsClasses</code></p><p>这两个参数用户指定hotspot虚拟在执行 <code>System.gc()</code> 时使用CMS周期；</p></li><li><p><code>-XX:+CMSPrecleaningEnabled</code></p><p>指定CMS是否需要进行 <code>Pre cleaning</code> 这个阶段</p></li></ul><p><strong>特别说明</strong></p><p>JDK9新特性：<code>CMS</code> 被标记为 <code>Deprecate</code> 了（JEP291)</p><ul><li>如果对JDK9及以上版本的 <code>HotSpot</code> 虚拟机使用参数 <code>-XX:+UseConcMarkSweepGC</code> 来开启CMS收集器的话，用户会收到一个警告信息，提示CMS未来将会被废弃。</li></ul><p>JDK14新特性：删除CMS垃圾回收器（JEP363)</p><ul><li><p>移除了CMS垃圾收集器，如果在JDK14中使用 <code>-XX:+UseConcMarkSweepGC</code> 的话 , JVM不会报错，只是给出一个warning信息，但是不会exit。JVM会自动回退以默认GC方式启动JVM</p><p><img src="https://raw.githubusercontent.com/GeorgeChan95/blogimg/master/img/2024/08/28/20240828-081410.png" alt="JDK14 CMS"></p></li></ul><h3 id="4-6-G1回收器"><a href="#4-6-G1回收器" class="headerlink" title="4.6 G1回收器"></a>4.6 G1回收器</h3><p>如果使用G1垃圾收集器，不建议设置-Xmn和-XX:NewRatio，毕竟可能影响G1的自动调节</p><ul><li><p><code>-XX:+UseG1GC</code></p><p>手动指定使用G1收集器执行内存回收任务。</p></li><li><p><code>-XX:G1HeapRegionSize</code></p><p>设置每个Region的大小。值是2的幂，范围是1MB到32MB之间，目标是根据最小的Java堆大小划分出约2048个区域。默认是堆内存的1&#x2F;2000。</p></li><li><p><code>-XX:MaxGCPauseMillis</code></p><p>设置期望达到的最大GC停顿时间指标（JVM会尽力实现，但不保证达到）。默认值是200ms</p></li><li><p><code>-XX:ParallelGCThread</code>  设置STW时GC线程数的值。最多设置为8</p></li><li><p><code>-XX:ConcGCThreads</code></p><p>设置并发标记的线程数。将n设置为并行垃圾回收线程数（ParallelGCThreads)的1&#x2F;4左右。</p></li><li><p><code>-XX:InitiatingHeapOccupancyPercent</code></p><p>设置触发并发GC周期的Java堆占用率阈值。超过此值，就触发GC。默认值是45。</p></li><li><p><code>-XX:G1NewSizePercent</code> <code>-XX:G1MaxNewSizePercent</code></p><p>新生代占用整个堆内存的最小百分比（默认5%)、最大百分比（默认60%)</p></li><li><p><code>-XX:G1ReservePercent=10</code></p><p>保留内存区域，防止 <code>to space</code> (Survivor中的to区）溢出</p></li></ul><p><strong>Mixed GC调优参数</strong></p><p>注意：G1收集器主要涉及到Mixed GC,Mixed GC会回收young区和部分old区。</p><p>G1关于Mixed GC调优常用参数：</p><ul><li><p><code>-XX:InitiatingHeapOccupancyPercent</code></p><p>设置堆占用率的百分比（0到100)达到这个数值的时候触发global concurrent marking(全局并发标记）,默认为 45%。值为0表示间断进行全局并发标记。</p></li><li><p><code>-XX:G1MixedGCLiveThresholdPercent</code></p><p>设置old区的region被回收时候的对象占比，默认占用率为85%。只有old区的region中存活的对象占用达到了这个百分比 , 才会在Mixed GC中被回收。</p></li><li><p><code>-XX:G1HeapWastePercent</code></p><p>在global concurrent marking(全局并发标记）结束之后，可以知道所有的区有多少空间要被回收，在每次young GC之后和再次发生Mixed GC之前，会检查垃圾占比是否达到此参数，只有达到了，下次才会发生 Mixed GC。</p></li><li><p><code>-XX:G1MixedGCCountTarget</code></p><p>一次global concurrent marking(全局并发标记）之后，最多执行Mixed GC的次数，默认是8。</p></li><li><p><code>-XX:G1OldCSetRegionThresholdPercent</code></p><p>设置Mixed GC收集周期中要收集的Old region数的上限。默认值是Java堆的10%</p></li></ul><h3 id="4-7-怎么选择垃圾回收器"><a href="#4-7-怎么选择垃圾回收器" class="headerlink" title="4.7 怎么选择垃圾回收器"></a>4.7 怎么选择垃圾回收器</h3><ul><li>优先调整堆的大小让JVM自适应完成。</li><li>如果内存小于100M,使用串行收集器</li><li>如果是单核、单机程序，并且没有停顿时间的要求，串行收集器</li><li>如果是多CPU、需要高吞吐量、允许停顿时间超过1秒，选择并行或者JVM自己选择</li><li>如果是多CPU、追求低停顿时间，需快速响应（比如延迟不能超过1秒，如互联网应用),使用并发收集器。官方推荐G1,性能高。现在互联网的项目，基本都是使用G1。</li></ul><p>特别说明：</p><ol><li>没有最好的收集器，更没有万能的收集；</li><li>调优永远是针对特定场景、特定需求，不存在一劳永逸的收集器</li></ol><h2 id="5-GC日志相关选项"><a href="#5-GC日志相关选项" class="headerlink" title="5. GC日志相关选项"></a>5. GC日志相关选项</h2><p>强烈建议看下这篇博客：<a href="https://cloud.tencent.com/developer/article/1916565">https://cloud.tencent.com/developer/article/1916565</a></p><h3 id="5-1-常用参数"><a href="#5-1-常用参数" class="headerlink" title="5.1 常用参数"></a>5.1 常用参数</h3><ul><li><p><code>-verbose:gc</code></p><p>输出gc日志信息，默认输出到标准输出<br>可以独立使用</p></li><li><p><code>-XX:+PrintGC</code></p><p>等同于 <code>-verbose:gc</code> 表示打开简化的GC日志<br>可以独立使用</p></li><li><p><code>-XX:+PrintGCDetails</code></p><p>在发生垃圾回收时打印内存回收详细的日志，并在进程退出时输出当前内存各区域分配情况<br>可以独立使用</p></li><li><p><code>-XX:+PrintGCTimeStamps</code></p><p>输出GC发生时的时间截<br>不可以独立使用，需要配合-XX:+PrintGCDetails使用</p></li><li><p><code>-XX:+PrintGCDateStamps</code></p><p>输出GC发生时的时间戳（以日期的形式，如 2013-05-04T21:53:59.234+0800)<br>不可以独立使用，需要配合-XX:+PrintGCDetails使用</p></li><li><p><code>-XX:+PrintHeapAtGC</code></p><p>每一次GC前和GC后，都打印堆信息<br>可以独立使用</p></li><li><p><code>-Xloggc:&lt;file&gt;</code></p><p>把GC日志写入到一个文件中去，而不是打印到标准输出中</p><pre><code class="highlight shell">java -Xms4096m -Xmx4096m -Xloggc:/tm/gc-%t.log -jar ioms-ums.jar<span class="meta prompt_"># </span><span class="language-bash">或</span>java  -Xms4096m -Xmx4096m -Xloggc:/tm/gc-%t.log -XX:+UseGCLogFileRotation -XX:NumberOfGCLogFiles=3 -XX:GCLogFileSize=512k -jar ioms-ums.jar</code></pre></li></ul><h3 id="5-2-其他参数"><a href="#5-2-其他参数" class="headerlink" title="5.2 其他参数"></a>5.2 其他参数</h3><ul><li><p><code>-XX:+TraceClassLoading</code></p><p>监控类的加载</p></li><li><p><code>-XX:+PrintGCApplicationStoppedTime</code></p><p>打印GC时线程的停顿时间</p></li><li><p><code>-XX:+PrintGCApplicationConcurrentTime</code></p><p>垃圾收集之前打印出应用未中断的执行时间</p></li><li><p><code>-XX:+PrintReferenceGC</code></p><p>记录回收了多少种不同引用类型的引用</p></li><li><p><code>-XX:+PrintTenuringDistribution</code></p><p>让JVM在每次MinorGC后打印出当前使用的Survivor中对象的年龄分布</p></li><li><p><code>-XX:+UseGCLogFileRotation</code></p><p>启用GC日志文件的自动转储</p></li><li><p><code>-XX:NumberOfGClogFiles=1</code></p><p>GC日志文件的循环数目</p></li><li><p><code>-XX:GCLogFileSize=1M</code></p><p>控制GC日志文件的大小</p></li></ul><pre><code class="highlight shell">java  -Xms4096m -Xmx4096m -Xloggc:/tm/gc-%t.log -XX:+UseGCLogFileRotation -XX:NumberOfGCLogFiles=3 -XX:GCLogFileSize=512k -jar ioms-ums.jar</code></pre><h2 id="6-其他参数"><a href="#6-其他参数" class="headerlink" title="6. 其他参数"></a>6. 其他参数</h2><ul><li><p><code>-XX:+DisableExplicitGC</code></p><p>禁止hotspot执行System.gc(),默认禁用</p></li><li><p><code>-XX:ReservedCodeCacheSize=&lt;n&gt;[g|m|k]</code>  <code>-XX:InitialCodeCacheSize=&lt;n&gt;[g|m|k]</code></p><p>指定代码缓存的大小</p></li><li><p><code>-XX:+UseCodeCacheFlushing</code></p><p>使用该参数让jvm放弃一些被编译的代码，避免代码缓存被占满时JVM切换到interpreted-only的情况</p></li><li><p><code>XX:+DoEscapeAnalysis</code>  开启逃逸分析（jdk1.8默认开启）</p></li><li><p><code>-XX:+UseBiasedLocking</code>  开启偏向锁</p></li><li><p><code>-XX:+UseLargePages</code>  开启使用大页面</p></li><li><p><code>-XX:+UseTLAB</code>  使用TLAB,默认打开</p></li><li><p><code>-XX:+PrintTLAB</code>  打印TLAB的使用情况</p></li><li><p><code>-XX:TLABSize</code>  设置TLAB大小</p></li></ul><h1 id="四、通过Java代码获取JVM参数"><a href="#四、通过Java代码获取JVM参数" class="headerlink" title="四、通过Java代码获取JVM参数"></a>四、通过Java代码获取JVM参数</h1><p>Java提供了 <code>java.lang.management</code> 包用于监视和管理Java虚拟机和Java运行时中的其他组件，它允许本地和远程监控和管理运行的Java虚拟机。<br> 其中 <code>ManagementFactory</code> 这个类还是挺常用的。另外还有Runtime类也可以获取一些内存、CPU核数等相关的数据。</p><p>通过这些api可以监控我们的应用服务器的堆内存使用情况，设置一些阀值进行报警等处理。</p><pre><code class="highlight java"><span class="keyword">package</span> com.cpucode.java.operating.parameters;<span class="keyword">import</span> java.lang.management.ManagementFactory;<span class="keyword">import</span> java.lang.management.MemoryMXBean;<span class="keyword">import</span> java.lang.management.MemoryUsage;<span class="comment">/**</span><span class="comment"> * 监控我们的应用服务器的堆内存使用情况，设置一些阈值进行报警等处理</span><span class="comment"> */</span><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">MemoryMonitor</span> &#123;    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;        <span class="type">MemoryMXBean</span> <span class="variable">memoryMXBean</span> <span class="operator">=</span> ManagementFactory.getMemoryMXBean();        <span class="type">MemoryUsage</span> <span class="variable">usage</span> <span class="operator">=</span> memoryMXBean.getHeapMemoryUsage();        System.out.println(<span class="string">&quot;INIT HEAP: &quot;</span> + usage.getInit() / <span class="number">1024</span> / <span class="number">1024</span> + <span class="string">&quot;m&quot;</span>);        System.out.println(<span class="string">&quot;MAX HEAP: &quot;</span> + usage.getMax() / <span class="number">1024</span> / <span class="number">1024</span> + <span class="string">&quot;m&quot;</span>);        System.out.println(<span class="string">&quot;USE HEAP: &quot;</span> + usage.getUsed() / <span class="number">1024</span> / <span class="number">1024</span> + <span class="string">&quot;m&quot;</span>);        System.out.println(<span class="string">&quot;\nFull Information:&quot;</span>);        System.out.println(<span class="string">&quot;Heap Memory Usage: &quot;</span> + memoryMXBean.getHeapMemoryUsage());        System.out.println(<span class="string">&quot;Non-Heap Memory Usage: &quot;</span> + memoryMXBean.getNonHeapMemoryUsage());        System.out.println(<span class="string">&quot;=======================通过java来获取相关系统状态============================ &quot;</span>);        <span class="comment">// 当前堆内存大小</span>        System.out.println(<span class="string">&quot;当前堆内存大小totalMemory &quot;</span> + (<span class="type">int</span>) Runtime.getRuntime().totalMemory() / <span class="number">1024</span> / <span class="number">1024</span> + <span class="string">&quot;m&quot;</span>);        <span class="comment">// 空闲堆内存大小</span>        System.out.println(<span class="string">&quot;空闲堆内存大小freeMemory &quot;</span> + (<span class="type">int</span>) Runtime.getRuntime().freeMemory() / <span class="number">1024</span> / <span class="number">1024</span> + <span class="string">&quot;m&quot;</span>);        <span class="comment">// 最大可用总堆内存大小</span>        System.out.println(<span class="string">&quot;最大可用总堆内存maxMemory &quot;</span> + Runtime.getRuntime().maxMemory() / <span class="number">1024</span> / <span class="number">1024</span> + <span class="string">&quot;m&quot;</span>);    &#125;&#125;</code></pre><p><strong>通过Runtime获取</strong></p><pre><code class="highlight java"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">HeapSpaceInitial</span> &#123;<span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span>&#123;<span class="comment">//返回Java虚拟机中的堆内存总量</span><span class="type">long</span> <span class="variable">initialMemory</span> <span class="operator">=</span> Runtime.getRuntime().totalMemory() / <span class="number">1024</span> / <span class="number">1024</span>;<span class="comment">//返回Java虚拟机试图使用的最大堆内存量</span><span class="type">long</span> <span class="variable">maxMemory</span> <span class="operator">=</span> Runtime.getRuntime().maxMemory() / <span class="number">1024</span> / <span class="number">1024</span>;System.out.println(<span class="string">&quot;-Xms:&quot;</span> + initialMemory + <span class="string">&quot;M&quot;</span>);System.out.println(<span class="string">&quot;-Xmx:&quot;</span> + maxMemory + <span class="string">&quot;M&quot;</span>);System.out.println(<span class="string">&quot;系统内存大小为：&quot;</span> + maxMemory * <span class="number">4.0</span> / <span class="number">1024</span> + <span class="string">&quot;G&quot;</span>);System.out.println(<span class="string">&quot;系统内存大小为：&quot;</span> + initialMemory * <span class="number">64.0</span> / <span class="number">1024</span> + <span class="string">&quot;G&quot;</span>);&#125;&#125;</code></pre>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;一、JVM参数选项&quot;&gt;&lt;a href=&quot;#一、JVM参数选项&quot; class=&quot;headerlink&quot; title=&quot;一、JVM参数选项&quot;&gt;&lt;/a&gt;一、JVM参数选项&lt;/h1&gt;&lt;p&gt;官网地址：&lt;a href=&quot;https://docs.oracle.com/java</summary>
      
    
    
    
    <category term="JVM" scheme="https://georgechan95.github.io/categories/JVM/"/>
    
    
    <category term="java" scheme="https://georgechan95.github.io/tags/java/"/>
    
    <category term="jvm" scheme="https://georgechan95.github.io/tags/jvm/"/>
    
  </entry>
  
  <entry>
    <title>第二十三章-使用OQL语言查询对象信息</title>
    <link href="https://georgechan95.github.io/blog/490498600.html"/>
    <id>https://georgechan95.github.io/blog/490498600.html</id>
    <published>2024-08-24T07:02:10.000Z</published>
    <updated>2024-08-28T04:17:33.348Z</updated>
    
    <content type="html"><![CDATA[<p>MAT支持一种类似于SQL的查询语言OQL（Object Query Language）。OQL使用类SQL语法，可以在堆中进行对象的查找和筛选。</p><p><img src="https://raw.githubusercontent.com/GeorgeChan95/blogimg/master/img/2024/08/24/20240824-150903.png" alt="在MAT中使用OQL语句"></p><h2 id="1-SELECT子句"><a href="#1-SELECT子句" class="headerlink" title="1. SELECT子句"></a>1. SELECT子句</h2><p>在MAT中，Select子句的格式与SQL基本一致，用于指定要显示的列。Select子句中可以使用“＊”，查看结果对象的引用实例（相当于outgoing references）。</p><pre><code class="highlight sql"><span class="keyword">SELECT</span> <span class="operator">*</span> <span class="keyword">FROM</span> java.util.Vector v</code></pre><p>使用“OBJECTS”关键字，可以将返回结果集中的项以对象的形式显示。</p><pre><code class="highlight sql"><span class="keyword">SELECT</span> objects v.elementData <span class="keyword">FROM</span> java.util.Vector v<span class="keyword">SELECT</span> OBJECTS s.value <span class="keyword">FROM</span> java.lang.String s</code></pre><p>在Select子句中，使用“AS RETAINED SET”关键字可以得到所得对象的保留集。</p><pre><code class="highlight sql"><span class="keyword">SELECT</span> <span class="keyword">AS</span> RETAINED <span class="keyword">SET</span> <span class="operator">*</span><span class="keyword">FROM</span> com.atguigu.mat.Student</code></pre><p>“DISTINCT”关键字用于在结果集中去除重复对象。</p><pre><code class="highlight sql"><span class="keyword">SELECT</span> <span class="keyword">DISTINCT</span> OBJECTS classof(s) <span class="keyword">FROM</span> java.lang.String s</code></pre><h2 id="2-FROM子句"><a href="#2-FROM子句" class="headerlink" title="2. FROM子句"></a>2. FROM子句</h2><p>From子句用于指定查询范围，它可以指定类名、正则表达式或者对象地址。</p><pre><code class="highlight sql"><span class="keyword">SELECT</span> <span class="operator">*</span> <span class="keyword">FROM</span> java.lang.String s</code></pre><p>使用正则表达式，限定搜索范围，输出所有com.atguigu包下所有类的实例</p><pre><code class="highlight sql"><span class="keyword">SELECT</span> <span class="operator">*</span> <span class="keyword">FROM</span> &quot;com\.atguigu\..*&quot;</code></pre><p>使用类的地址进行搜索。使用类的地址的好处是可以区分被不同ClassLoader加载的同一种类型。</p><pre><code class="highlight sql"><span class="keyword">select</span> <span class="operator">*</span> <span class="keyword">from</span> <span class="number">0x37a0b4d</span></code></pre><h2 id="3-WHERE子句"><a href="#3-WHERE子句" class="headerlink" title="3. WHERE子句"></a>3. WHERE子句</h2><p>Where子句用于指定OQL的查询条件。OQL查询将只返回满足Where子句指定条件的对象。Where子句的格式与传统SQL极为相似。</p><p>返回长度大于1000的byte[]数组。</p><pre><code class="highlight sql"><span class="keyword">SELECT</span> <span class="operator">*</span> <span class="keyword">FROM</span> byte[] s <span class="keyword">WHERE</span> s.<span class="variable">@length</span><span class="operator">&gt;</span><span class="number">1000</span></code></pre><p><img src="https://raw.githubusercontent.com/GeorgeChan95/blogimg/master/img/2024/08/24/20240824-151855.png" alt="长度大于1000的byte[]数组"></p><p><img src="https://raw.githubusercontent.com/GeorgeChan95/blogimg/master/img/2024/08/24/20240824-151942.png" alt="查看对象被谁引用"></p><p>返回包含“java”子字符串的所有字符串，使用“LIKE”操作符，“LIKE”操作符的操作参数为正则表达式。</p><pre><code class="highlight sql"><span class="keyword">SELECT</span> <span class="operator">*</span> <span class="keyword">FROM</span> java.lang.String s <span class="keyword">WHERE</span> toString(s) <span class="keyword">LIKE</span> &quot;.*java.*&quot;</code></pre><p>返回所有value域不为null的字符串，使用“＝”操作符。</p><pre><code class="highlight sql"><span class="keyword">SELECT</span> <span class="operator">*</span> <span class="keyword">FROM</span> java.lang.String s <span class="keyword">where</span> s.value<span class="operator">!=</span><span class="keyword">null</span></code></pre><p>返回数组长度大于15，并且深堆大于1000字节的所有Vector对象。</p><pre><code class="highlight sql"><span class="keyword">SELECT</span> <span class="operator">*</span> <span class="keyword">FROM</span> java.util.Vector v <span class="keyword">WHERE</span> v.elementData.<span class="variable">@length</span><span class="operator">&gt;</span><span class="number">15</span> <span class="keyword">AND</span> v.<span class="variable">@retainedHeapSize</span><span class="operator">&gt;</span><span class="number">1000</span></code></pre><h2 id="4-内置对象与方法"><a href="#4-内置对象与方法" class="headerlink" title="4. 内置对象与方法"></a>4. 内置对象与方法</h2><p>OQL中可以访问堆内对象的属性，也可以访问堆内代理对象的属性。访问堆内对象的属性时，格式如下，其中alias为对象名称：</p><p><code>[ &lt;alias&gt;. ] &lt;field&gt; . &lt;field&gt;. &lt;field&gt;</code></p><p>访问java.io.File对象的path属性，并进一步访问path的value属性：</p><pre><code class="highlight sql"><span class="keyword">SELECT</span> toString(f.path.value) <span class="keyword">FROM</span> java.io.File f</code></pre><p>显示String对象的内容、objectid和objectAddress。</p><pre><code class="highlight sql"><span class="keyword">SELECT</span> s.toString(),s.<span class="variable">@objectId</span>, s.<span class="variable">@objectAddress</span> <span class="keyword">FROM</span> java.lang.String s</code></pre><p>显示java.util.Vector内部数组的长度。</p><pre><code class="highlight sql"><span class="keyword">SELECT</span> v.elementData.<span class="variable">@length</span> <span class="keyword">FROM</span> java.util.Vector v</code></pre><p>显示所有的java.util.Vector对象及其子类型</p><pre><code class="highlight sql"><span class="keyword">select</span> <span class="operator">*</span> <span class="keyword">from</span> INSTANCEOF java.util.Vector</code></pre>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;MAT支持一种类似于SQL的查询语言OQL（Object Query Language）。OQL使用类SQL语法，可以在堆中进行对象的查找和筛选。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://raw.githubusercontent.com/GeorgeChan95</summary>
      
    
    
    
    <category term="JVM" scheme="https://georgechan95.github.io/categories/JVM/"/>
    
    
    <category term="java" scheme="https://georgechan95.github.io/tags/java/"/>
    
    <category term="jvm" scheme="https://georgechan95.github.io/tags/jvm/"/>
    
  </entry>
  
  <entry>
    <title>第二十三章-浅堆-深堆-内存泄漏</title>
    <link href="https://georgechan95.github.io/blog/1471620196.html"/>
    <id>https://georgechan95.github.io/blog/1471620196.html</id>
    <published>2024-08-24T05:04:37.000Z</published>
    <updated>2024-08-28T04:17:33.349Z</updated>
    
    <content type="html"><![CDATA[<h1 id="一、浅堆与深堆"><a href="#一、浅堆与深堆" class="headerlink" title="一、浅堆与深堆"></a>一、浅堆与深堆</h1><h2 id="1-shallow-heap-浅堆"><a href="#1-shallow-heap-浅堆" class="headerlink" title="1. shallow heap(浅堆)"></a>1. shallow heap(浅堆)</h2><p>shallow heap是对象本身的大小，不包括其引用的对象。<br>对于非数组类型：shallow heap就是对象与其成员变量加在一起的大小。<br>对于数组类型：shallow heap就是数组各个元素大小之和。</p><h2 id="2-retained-heap-保留集"><a href="#2-retained-heap-保留集" class="headerlink" title="2. retained heap(保留集)"></a>2. retained heap(保留集)</h2><p>对象remainder heap 大小 &#x3D; 对象shallow heap大小 + 对象直接或者间接引用的对象大小（排除被GC ROOT直接引用的对象）。<br>如下图所示：</p><p><img src="https://raw.githubusercontent.com/GeorgeChan95/blogimg/master/img/2024/08/20/20240820-194720.png" alt="对象引用关系"></p><p><strong>对象引用关系</strong><br>OBJECT A 的 remainder heap &#x3D; OBJECT A 的 shallow heap<br>OBJECT B的 remainder heap &#x3D; OBJECT B 的 shallow heap + OBJECT C 的对象大小 + OBJECT E 的对象大小</p><p>所以对象的remainder heap其实接近进行垃圾回收时，清除该对象时所能获取的堆内存大小（有的对象可能还被其他对象引用，垃圾回收时，不能清除）。</p><p>下面是用mat对从服务器上面dump出来Java虚拟机内存进行解析之后的结果：</p><p><img src="https://raw.githubusercontent.com/GeorgeChan95/blogimg/master/img/2024/08/20/20240820-194952.png" alt="内存分析"></p><p><strong>Java内存解析结果</strong></p><p>其中，Objects为类的对象的个数。Shallow Heap是这些对象自身大小之和，Remainder Heap是这些对象自身以及这些对象直接或者间接引用的对象大小总和。</p><h2 id="3-补充：对象实际大小"><a href="#3-补充：对象实际大小" class="headerlink" title="3. 补充：对象实际大小"></a>3. 补充：对象实际大小</h2><p>另外一个常用的概念是对象的实际大小。这里，对象的实际大小定义为一个对象所能触及的所有对象的浅堆大小之和，也就是通常意义上我们说的对象大小。与深堆相比，似乎这个在日常开发中更为直观和被人接受，但实际上，<strong>这个概念和垃圾回收无关</strong>。</p><p>下图显示了一个简单的对象引用关系图，对象A引用了C和D，对象B引用了C和E。那么对象A的浅堆大小只是A本身，不含C和D，而A的实际大小为A、C、D三者之和。而A的深堆大小为A与D之和，由于对象C还可以通过对象B访问到，因此不在对象A的深堆范围内。</p><p><img src="https://raw.githubusercontent.com/GeorgeChan95/blogimg/master/img/2024/08/20/20240820-195149.png" alt="对象引用关系"></p><h2 id="4-案例分析：StudentTrace"><a href="#4-案例分析：StudentTrace" class="headerlink" title="4. 案例分析：StudentTrace"></a>4. 案例分析：StudentTrace</h2><p><strong>案例代码</strong></p><pre><code class="highlight java"><span class="comment">/**</span><span class="comment"> * 有一个学生浏览网页的记录程序，它将记录 每个学生访问过的网站地址。</span><span class="comment"> * 它由三个部分组成：Student、WebPage和StudentTrace三个类</span><span class="comment"> *</span><span class="comment"> *  -XX:+HeapDumpBeforeFullGC -XX:HeapDumpPath=d:\student.hprof</span><span class="comment"> */</span><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">StudentTrace</span> &#123;    <span class="keyword">static</span> List&lt;WebPage&gt; webpages = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;WebPage&gt;();    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">createWebPages</span><span class="params">()</span> &#123;        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; <span class="number">100</span>; i++) &#123;            <span class="type">WebPage</span> <span class="variable">wp</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">WebPage</span>();            wp.setUrl(<span class="string">&quot;http://www.&quot;</span> + Integer.toString(i) + <span class="string">&quot;.com&quot;</span>);            wp.setContent(Integer.toString(i));            webpages.add(wp);        &#125;    &#125;    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;        createWebPages();<span class="comment">//创建了100个网页</span>        <span class="comment">//创建3个学生对象</span>        <span class="type">Student</span> <span class="variable">st3</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Student</span>(<span class="number">3</span>, <span class="string">&quot;Tom&quot;</span>);        <span class="type">Student</span> <span class="variable">st5</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Student</span>(<span class="number">5</span>, <span class="string">&quot;Jerry&quot;</span>);        <span class="type">Student</span> <span class="variable">st7</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Student</span>(<span class="number">7</span>, <span class="string">&quot;Lily&quot;</span>);        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; webpages.size(); i++) &#123;            <span class="keyword">if</span> (i % st3.getId() == <span class="number">0</span>)                st3.visit(webpages.get(i));            <span class="keyword">if</span> (i % st5.getId() == <span class="number">0</span>)                st5.visit(webpages.get(i));            <span class="keyword">if</span> (i % st7.getId() == <span class="number">0</span>)                st7.visit(webpages.get(i));        &#125;        webpages.clear();        System.gc();    &#125;&#125;<span class="keyword">class</span> <span class="title class_">Student</span> &#123;    <span class="keyword">private</span> <span class="type">int</span> id;    <span class="keyword">private</span> String name;    <span class="keyword">private</span> List&lt;WebPage&gt; history = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();    <span class="keyword">public</span> <span class="title function_">Student</span><span class="params">(<span class="type">int</span> id, String name)</span> &#123;        <span class="built_in">super</span>();        <span class="built_in">this</span>.id = id;        <span class="built_in">this</span>.name = name;    &#125;    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">getId</span><span class="params">()</span> &#123;        <span class="keyword">return</span> id;    &#125;    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setId</span><span class="params">(<span class="type">int</span> id)</span> &#123;        <span class="built_in">this</span>.id = id;    &#125;    <span class="keyword">public</span> String <span class="title function_">getName</span><span class="params">()</span> &#123;        <span class="keyword">return</span> name;    &#125;    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setName</span><span class="params">(String name)</span> &#123;        <span class="built_in">this</span>.name = name;    &#125;    <span class="keyword">public</span> List&lt;WebPage&gt; <span class="title function_">getHistory</span><span class="params">()</span> &#123;        <span class="keyword">return</span> history;    &#125;    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setHistory</span><span class="params">(List&lt;WebPage&gt; history)</span> &#123;        <span class="built_in">this</span>.history = history;    &#125;    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">visit</span><span class="params">(WebPage wp)</span> &#123;        <span class="keyword">if</span> (wp != <span class="literal">null</span>) &#123;            history.add(wp);        &#125;    &#125;&#125;<span class="keyword">class</span> <span class="title class_">WebPage</span> &#123;    <span class="keyword">private</span> String url;    <span class="keyword">private</span> String content;    <span class="keyword">public</span> String <span class="title function_">getUrl</span><span class="params">()</span> &#123;        <span class="keyword">return</span> url;    &#125;    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setUrl</span><span class="params">(String url)</span> &#123;        <span class="built_in">this</span>.url = url;    &#125;    <span class="keyword">public</span> String <span class="title function_">getContent</span><span class="params">()</span> &#123;        <span class="keyword">return</span> content;    &#125;    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setContent</span><span class="params">(String content)</span> &#123;        <span class="built_in">this</span>.content = content;    &#125;&#125;</code></pre><p><img src="https://raw.githubusercontent.com/GeorgeChan95/blogimg/master/img/2024/08/20/20240820-200332.png" alt="线程对象追踪"></p><p><strong>结论：</strong><br>elementData 数组的浅堆是80个字节，而 elementData 数组中的所有 WebPage 对象的深堆之和是1208个字节，所以加在一起就是 elementData 数组的深堆之和，也就是1288个字节</p><p><strong>解析：</strong></p><p>默认采用了指针压缩则为12字节，没有采用则为16字节（数组还需要加上数组长度）。</p><p>1.为什么有152字节和144字节：因为我们的URL和content存在两种情况<br>        URL:”<a href="http://www.7.com"、content:"7"-----URL:"http://www.14.com"、content:"14">http://www.7.com&quot;、content:&quot;7&quot;-----URL:&quot;http://www.14.com&quot;、content:&quot;14</a>“<br>        第一种URL长度为16，底层的char数组的占用空间为(【】方括号里面整个都属于对象头，分开写方便大家理解)<br>            【普通对象头(12) + 数组长度(4)】 + 16个字符(32) &#x3D; 48字节，符合8字节对齐<br>            同理content 占用 【普通对象头(12) +数组长度(4)】+ 一个字符(2) &#x3D; 18字节,八字节对齐&#x3D;24字节<br>        第二种URL长度为17，底层的插入数组的占用空间为<br>            【普通对象头(12) + 数组长度(4)】 + 17个字符(34) &#x3D; 50字节，不符合8字节对齐，对齐为56<br>            同理content 占用 【普通对象头(12) +数组长度(4)】+ 两个字符(4) &#x3D; 20字节,八字节对齐&#x3D;24字节<br>        所以第一种总字节为48 + 24 &#x3D; 72,第二种总字节为56 + 24 &#x3D; 80<br>        因此第二种比第一种多了8字节，所以是152和144。<br>        (为什么总大小是152而不是72是因为我们只计算了String底层的char数组的区别没有计算各变量本身的浅堆,<br>        因为结构都相同，所以差别就差在内容的占用上)</p><p>2.为什么最终结果是1288<br>        首先ElementData数组本身的浅堆大小为<br>        【普通对象头(12) + 数组长度(4)】 + 数组内容【15个Obejct引用&#x3D;16*4】 &#x3D; 76,八字节对齐&#x3D;80字节<br>        15个Object分为13个152字节+2个144字节，总大小为&#x3D;2264字节<br>        7号和其他student重复的有0、21、42、63、84、35、70总计6个152和1一个144<br>        所以2264 - 6 * 152 - 144 &#x3D; 1208字节<br>    所以ElementData本身的浅堆80 + 仅能通过它到达的浅堆1208 &#x3D; 1288</p><h1 id="二、支配树（Dominator-Tree）"><a href="#二、支配树（Dominator-Tree）" class="headerlink" title="二、支配树（Dominator Tree）"></a>二、支配树（Dominator Tree）</h1><p>支配树的概念源自<strong>图论</strong>。</p><p>MAT提供了一个称为<strong>支配树</strong>（Dominator Tree)的对象图。支配树体现了<strong>对象实例</strong>间的支配关系。在对象引用图中，所有指向对象B的路径都经过对象A , 则认为对象A支配对象B。如果对象A是离对象B最近的一个支配对象 ，则认为对象A为对象B的<strong>直接支配者</strong>。支配树是基于<strong>对象间的引用图</strong>所建立的，它有以下基本性质：</p><ul><li>对象A的子树（所有被对象A支配的对象集合）表示对象A的保留集（retained set) , 即深堆</li><li>如果对象A支配对象B , 那么对象A的直接支配者也支配对象B</li><li>支配树的边与对象引用图的边不直接对应</li></ul><p>如下图所示：</p><p>左图表示<strong>对象引用图</strong>，右图表示左图所对应的<strong>支配树</strong>。</p><p>对象A和B由根对象直接支配，由于在到对象C的路径中，可以经过A , 也可以经过B , 因此对象C的直接支配者也是根对象。<br>对象F与对象D相互引用 ，因为到对象F的所有路径必然经过对象D , 因此，对象D是对象F的直接支配者 。<br>而到对象D的所有路径中，必然经过对象C , 即使是从对象F到对象D的引用 ，从根节点出发，也是经过对象C的，所以 ，对象D的直接支配者为对象C。</p><p><img src="https://raw.githubusercontent.com/GeorgeChan95/blogimg/master/img/2024/08/22/20240822-184127.png" alt="支配树"></p><p>同理，对象E支配对象G。到达对象H的可以通过对象D , 也可以通过对象E , 因此对象D和E都不能支配对象H , 而经过对象C既可以到达D也可以到达E , 因此<strong>对象C为对象H的直接支配者</strong>。</p><p>在MAT中，单击工具栏上的对象支配树按钮，可以打开<strong>对象支配树</strong>视图。</p><p><img src="https://raw.githubusercontent.com/GeorgeChan95/blogimg/master/img/2024/08/22/20240822-184933.png" alt="MAT通过dump文件查看对象支配树"></p><p>下图显示了对象支配树视图的一部分。该截图显示部分Lily学生的history队列的直接支配对象。即当Lily对象被回收，也会一并回收的所有对象。显然能被3或者5整除的网页不会出现在该列表中，因为它们同时被另外两名学生对象引用。</p><h1 id="三、内存泄漏"><a href="#三、内存泄漏" class="headerlink" title="三、内存泄漏"></a>三、内存泄漏</h1><h2 id="1-内存泄漏（memory-leak）"><a href="#1-内存泄漏（memory-leak）" class="headerlink" title="1. 内存泄漏（memory leak）"></a>1. 内存泄漏（memory leak）</h2><p>可达性分析算法来判断对象是否是不再使用的对象，本质都是判断一个对象是否还被引用。那么对于这种情况下，由于代码的实现不同就会出现很多种内存泄漏问题（让JVM误以为此对象还在引用中，无法回收，造成内存泄漏）。</p><ul><li>是否还被使用？是</li><li>是否还被需要？否</li></ul><p><img src="https://raw.githubusercontent.com/GeorgeChan95/blogimg/master/img/2024/08/24/20240824-135555.png" alt="内存泄漏"></p><p>严格来说，只有对象不会再被程序用到了，但是GC又不能回收他们的情况，才叫内存泄漏。但实际情况很多时候一些不太好的实践（或疏忽）会导致对象的生命周期变得很长甚至导致OOM，也可以叫做宽泛意义上的“内存泄漏”。</p><p>如下图，当Y生命周期结束的时候，X依然引用着Y，这时候，垃圾回收期是不会回收对象Y的；如果对象X还引用着生命周期比较短的A、B、C，对象A又引用着对象 a、b、c，这样就可能造成大量无用的对象不能被回收，进而占据了内存资源，造成内存泄漏，直到内存溢出。</p><p><img src="https://raw.githubusercontent.com/GeorgeChan95/blogimg/master/img/2024/08/24/20240824-135602.png" alt="内存泄漏示意"></p><p>申请了内存用完了不释放，比如一共有1024M的内存，分配了512M的内存一直不回收，那么可以用的内存只有512M了，仿佛泄露掉了一部分；通俗一点讲的话，内存泄漏就是【占着茅坑不拉shi】。</p><h2 id="2-内存溢出（out-of-memory）"><a href="#2-内存溢出（out-of-memory）" class="headerlink" title="2. 内存溢出（out of memory）"></a>2. 内存溢出（out of memory）</h2><p>申请内存时，没有足够的内存可以使用；通俗一点儿讲，一个厕所就三个坑，有两个站着茅坑不走的（内存泄漏），剩下最后一个坑，厕所表示接待压力很大，这时候一下子来了两个人，坑位（内存）就不够了，内存泄漏变成内存溢出了。可见，内存泄漏和内存溢出的关系：内存泄漏的增多，最终会导致内存溢出。</p><p><strong>泄漏的分类</strong></p><ul><li><p>经常发生：发生内存泄露的代码会被多次执行，每次执行，泄露一块内存；</p></li><li><p>偶然发生：在某些特定情况下才会发生</p></li><li><p>一次性：发生内存泄露的方法只会执行一次；</p></li><li><p>隐式泄漏：一直占着内存不释放，直到执行结束；严格的说这个不算内存泄漏，因为最终释放掉了，但是如果执行时间特别长，也可能会导致内存耗尽。</p></li></ul><h2 id="3-Java中内存泄露的8种情况"><a href="#3-Java中内存泄露的8种情况" class="headerlink" title="3. Java中内存泄露的8种情况"></a>3. Java中内存泄露的8种情况</h2><h3 id="3-1-静态集合类"><a href="#3-1-静态集合类" class="headerlink" title="3.1 静态集合类"></a>3.1 静态集合类</h3><p>静态集合类，如 HashMap、LinkedList 等等。如果这些容器为静态的，那么它们的生命周期与JVM程序一致，则容器中的对象在程序结束之前将不能被释放，从而造成内存泄漏。简单而言，长生命周期的对象持有短生命周期对象的引用，尽管短生命周期的对象不再使用，但是因为长生命周期对象持有它的引用而导致不能被回收。</p><pre><code class="highlight java"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">MemoryLeak</span> &#123;    <span class="keyword">static</span> <span class="type">List</span> <span class="variable">list</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ArrayList</span>();    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">oomTests</span><span class="params">()</span>&#123;        Object obj＝<span class="keyword">new</span> <span class="title class_">Object</span>();<span class="comment">//局部变量</span>        list.add(obj);    &#125;&#125;</code></pre><h3 id="3-2-单例模式"><a href="#3-2-单例模式" class="headerlink" title="3.2 单例模式"></a>3.2 单例模式</h3><p>单例模式，和静态集合导致内存泄露的原因类似，因为单例的静态特性，它的生命周期和 JVM 的生命周期一样长，所以如果单例对象如果持有外部对象的引用，那么这个外部对象也不会被回收，那么就会造成内存泄漏。</p><h3 id="3-3-内部类持有外部类"><a href="#3-3-内部类持有外部类" class="headerlink" title="3.3 内部类持有外部类"></a>3.3 内部类持有外部类</h3><p>内部类持有外部类，如果一个外部类的实例对象的方法返回了一个内部类的实例对象。这个内部类对象被长期引用了，即使那个外部类实例对象不再被使用，但由于内部类持有外部类的实例对象，这个外部类对象将不会被垃圾回收，这也会造成内存泄漏。</p><h3 id="3-4-各种连接，如数据库连接、网络连接和IO连接等"><a href="#3-4-各种连接，如数据库连接、网络连接和IO连接等" class="headerlink" title="3.4 各种连接，如数据库连接、网络连接和IO连接等"></a>3.4 各种连接，如数据库连接、网络连接和IO连接等</h3><p>在对数据库进行操作的过程中，首先需要建立与数据库的连接，当不再使用时，需要调用close方法来释放与数据库的连接。只有连接被关闭后，垃圾回收器才会回收对应的对象。否则，如果在访问数据库的过程中，对Connection、Statement或ResultSet不显性地关闭，将会造成大量的对象无法被回收，从而引起内存泄漏。</p><pre><code class="highlight java"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;    <span class="keyword">try</span>&#123;        <span class="type">Connection</span> <span class="variable">conn</span> <span class="operator">=</span><span class="literal">null</span>;        Class.forName(<span class="string">&quot;com.mysql.jdbc.Driver&quot;</span>);        conn =DriverManager.getConnection(<span class="string">&quot;url&quot;</span>,<span class="string">&quot;&quot;</span>,<span class="string">&quot;&quot;</span>);        <span class="type">Statement</span> <span class="variable">stmt</span> <span class="operator">=</span>conn.createStatement();        <span class="type">ResultSet</span> <span class="variable">rs</span> <span class="operator">=</span>stmt.executeQuery(<span class="string">&quot;....&quot;</span>);    &#125; <span class="keyword">catch</span>（Exception e）&#123;<span class="comment">//异常日志</span>    &#125; <span class="keyword">finally</span> &#123;        <span class="comment">// 1．关闭结果集 Statement</span>        <span class="comment">// 2．关闭声明的对象 ResultSet</span>        <span class="comment">// 3．关闭连接 Connection</span>    &#125;&#125;</code></pre><h3 id="3-5-变量不合理的作用域"><a href="#3-5-变量不合理的作用域" class="headerlink" title="3.5 变量不合理的作用域"></a>3.5 变量不合理的作用域</h3><p>变量不合理的作用域。一般而言，一个变量的定义的作用范围大于其使用范围，很有可能会造成内存泄漏。另一方面，如果没有及时地把对象设置为null，很有可能导致内存泄漏的发生。</p><pre><code class="highlight java"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">UsingRandom</span> &#123;    <span class="keyword">private</span> String msg;    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">receiveMsg</span><span class="params">()</span>&#123;        readFromNet();<span class="comment">//从网络中接受数据保存到msg中</span>        saveDB();<span class="comment">//把msg保存到数据库中</span>    &#125;&#125;</code></pre><p>如上面这个伪代码，通过 readFromNet 方法把接受的消息保存在变量msg中，然后调用saveDB方法把msg的内容保存到数据库中，此时msg已经就没用了，由于msg的生命周期与对象的生命周期相同，此时msg还不能回收，因此造成了内存泄漏。实际上这个msg变量可以放在receiveMsg方法内部，当方法使用完，那么msg的生命周期也就结束，此时就可以回收了。还有一种方法，在使用完msg后，把msg设置为null，这样垃圾回收器也会回收msg的内存空间。</p><h3 id="3-6-改变哈希值"><a href="#3-6-改变哈希值" class="headerlink" title="3.6 改变哈希值"></a>3.6 改变哈希值</h3><p>改变哈希值，当一个对象被存储进 HashSet 集合中以后，就不能修改这个对象中的那些参与计算哈希值的字段了。</p><p>否则，对象修改后的哈希值与最初存储进HashSet集合中时的哈希值就不同了，在这种情况下，即使在 contains 方法使用该对象的当前引用作为的参数去HashSet集合中检索对象，也将返回找不到对象的结果，这也会导致无法从HashSet集合中单独删除当前对象，造成内存泄漏。</p><p>这也是 String 为什么被设置成了不可变类型，我们可以放心地把 String 存入 HashSet，或者把String 当做 HashMap 的 key 值；</p><p>当我们想把自己定义的类保存到散列表的时候，需要保证对象的 hashCode 不可变。</p><pre><code class="highlight java"><span class="comment">/**</span><span class="comment"> * 例1</span><span class="comment"> */</span><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ChangeHashCode</span> &#123;    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;        <span class="type">HashSet</span> <span class="variable">set</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">HashSet</span>();        <span class="type">Person</span> <span class="variable">p1</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Person</span>(<span class="number">1001</span>, <span class="string">&quot;AA&quot;</span>);        <span class="type">Person</span> <span class="variable">p2</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Person</span>(<span class="number">1002</span>, <span class="string">&quot;BB&quot;</span>);        set.add(p1);        set.add(p2);        p1.name = <span class="string">&quot;CC&quot;</span>;<span class="comment">//导致了内存的泄漏</span>        set.remove(p1); <span class="comment">//删除失败</span>        System.out.println(set);        set.add(<span class="keyword">new</span> <span class="title class_">Person</span>(<span class="number">1001</span>, <span class="string">&quot;CC&quot;</span>));        System.out.println(set);        set.add(<span class="keyword">new</span> <span class="title class_">Person</span>(<span class="number">1001</span>, <span class="string">&quot;AA&quot;</span>));        System.out.println(set);    &#125;&#125;<span class="keyword">class</span> <span class="title class_">Person</span> &#123;    <span class="type">int</span> id;    String name;    <span class="keyword">public</span> <span class="title function_">Person</span><span class="params">(<span class="type">int</span> id, String name)</span> &#123;        <span class="built_in">this</span>.id = id;        <span class="built_in">this</span>.name = name;    &#125;    <span class="meta">@Override</span>    <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">equals</span><span class="params">(Object o)</span> &#123;        <span class="keyword">if</span> (<span class="built_in">this</span> == o) <span class="keyword">return</span> <span class="literal">true</span>;        <span class="keyword">if</span> (!(o <span class="keyword">instanceof</span> Person)) <span class="keyword">return</span> <span class="literal">false</span>;        <span class="type">Person</span> <span class="variable">person</span> <span class="operator">=</span> (Person) o;        <span class="keyword">if</span> (id != person.id) <span class="keyword">return</span> <span class="literal">false</span>;        <span class="keyword">return</span> name != <span class="literal">null</span> ? name.equals(person.name) : person.name == <span class="literal">null</span>;    &#125;    <span class="meta">@Override</span>    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">hashCode</span><span class="params">()</span> &#123;        <span class="type">int</span> <span class="variable">result</span> <span class="operator">=</span> id;        result = <span class="number">31</span> * result + (name != <span class="literal">null</span> ? name.hashCode() : <span class="number">0</span>);        <span class="keyword">return</span> result;    &#125;    <span class="meta">@Override</span>    <span class="keyword">public</span> String <span class="title function_">toString</span><span class="params">()</span> &#123;        <span class="keyword">return</span> <span class="string">&quot;Person&#123;&quot;</span> +                <span class="string">&quot;id=&quot;</span> + id +                <span class="string">&quot;, name=&#x27;&quot;</span> + name + <span class="string">&#x27;\&#x27;&#x27;</span> +                <span class="string">&#x27;&#125;&#x27;</span>;    &#125;&#125;</code></pre><pre><code class="highlight java"><span class="comment">/**</span><span class="comment"> * 例2</span><span class="comment"> */</span><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ChangeHashCode1</span> &#123;    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;        HashSet&lt;Point&gt; hs = <span class="keyword">new</span> <span class="title class_">HashSet</span>&lt;Point&gt;();        <span class="type">Point</span> <span class="variable">cc</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Point</span>();        cc.setX(<span class="number">10</span>);<span class="comment">//hashCode = 41</span>        hs.add(cc);        cc.setX(<span class="number">20</span>);<span class="comment">//hashCode = 51  此行为导致了内存的泄漏</span>        System.out.println(<span class="string">&quot;hs.remove = &quot;</span> + hs.remove(cc));<span class="comment">//false</span>        hs.add(cc);        System.out.println(<span class="string">&quot;hs.size = &quot;</span> + hs.size());<span class="comment">//size = 2</span>        System.out.println(hs);    &#125;&#125;<span class="keyword">class</span> <span class="title class_">Point</span> &#123;    <span class="type">int</span> x;    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">getX</span><span class="params">()</span> &#123;        <span class="keyword">return</span> x;    &#125;    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setX</span><span class="params">(<span class="type">int</span> x)</span> &#123;        <span class="built_in">this</span>.x = x;    &#125;    <span class="meta">@Override</span>    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">hashCode</span><span class="params">()</span> &#123;        <span class="keyword">final</span> <span class="type">int</span> <span class="variable">prime</span> <span class="operator">=</span> <span class="number">31</span>;        <span class="type">int</span> <span class="variable">result</span> <span class="operator">=</span> <span class="number">1</span>;        result = prime * result + x;        <span class="keyword">return</span> result;    &#125;    <span class="meta">@Override</span>    <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">equals</span><span class="params">(Object obj)</span> &#123;        <span class="keyword">if</span> (<span class="built_in">this</span> == obj) <span class="keyword">return</span> <span class="literal">true</span>;        <span class="keyword">if</span> (obj == <span class="literal">null</span>) <span class="keyword">return</span> <span class="literal">false</span>;        <span class="keyword">if</span> (getClass() != obj.getClass()) <span class="keyword">return</span> <span class="literal">false</span>;        <span class="type">Point</span> <span class="variable">other</span> <span class="operator">=</span> (Point) obj;        <span class="keyword">if</span> (x != other.x) <span class="keyword">return</span> <span class="literal">false</span>;        <span class="keyword">return</span> <span class="literal">true</span>;    &#125;    <span class="meta">@Override</span>    <span class="keyword">public</span> String <span class="title function_">toString</span><span class="params">()</span> &#123;        <span class="keyword">return</span> <span class="string">&quot;Point&#123;&quot;</span> +                <span class="string">&quot;x=&quot;</span> + x +                <span class="string">&#x27;&#125;&#x27;</span>;    &#125;&#125;</code></pre><h3 id="3-7-缓存泄露"><a href="#3-7-缓存泄露" class="headerlink" title="3.7 缓存泄露"></a>3.7 缓存泄露</h3><p>内存泄漏的另一个常见来源是缓存，一旦你把对象引用放入到缓存中，他就很容易遗忘。比如：之前项目在一次上线的时候，应用启动奇慢直到夯死，就是因为代码中会加载一个表中的数据到缓存（内存）中，测试环境只有几百条数据，但是生产环境有几百万的数据。</p><p>对于这个问题，可以使用WeakHashMap代表缓存，此种Map的特点是，当除了自身有对key的引用外，此key没有其他引用那么此map会自动丢弃此值。</p><p>public class MapTest {<br>    static Map wMap &#x3D; new WeakHashMap();<br>    static Map map &#x3D; new HashMap();</p><pre><code class="highlight java"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">MapTest</span> &#123;    <span class="keyword">static</span> <span class="type">Map</span> <span class="variable">wMap</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">WeakHashMap</span>();    <span class="keyword">static</span> <span class="type">Map</span> <span class="variable">map</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">HashMap</span>();    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;        init();        testWeakHashMap();        testHashMap();    &#125;    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">init</span><span class="params">()</span> &#123;        <span class="type">String</span> <span class="variable">ref1</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">String</span>(<span class="string">&quot;obejct1&quot;</span>);        <span class="type">String</span> <span class="variable">ref2</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">String</span>(<span class="string">&quot;obejct2&quot;</span>);        <span class="type">String</span> <span class="variable">ref3</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">String</span>(<span class="string">&quot;obejct3&quot;</span>);        <span class="type">String</span> <span class="variable">ref4</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">String</span>(<span class="string">&quot;obejct4&quot;</span>);        wMap.put(ref1, <span class="string">&quot;cacheObject1&quot;</span>);        wMap.put(ref2, <span class="string">&quot;cacheObject2&quot;</span>);        map.put(ref3, <span class="string">&quot;cacheObject3&quot;</span>);        map.put(ref4, <span class="string">&quot;cacheObject4&quot;</span>);        System.out.println(<span class="string">&quot;String引用ref1，ref2，ref3，ref4 消失&quot;</span>);    &#125;    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">testWeakHashMap</span><span class="params">()</span> &#123;        System.out.println(<span class="string">&quot;WeakHashMap GC之前&quot;</span>);        <span class="keyword">for</span> (Object o : wMap.entrySet()) &#123;            System.out.println(o);        &#125;        <span class="keyword">try</span> &#123;            System.gc();            TimeUnit.SECONDS.sleep(<span class="number">5</span>);        &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;            e.printStackTrace();        &#125;        System.out.println(<span class="string">&quot;WeakHashMap GC之后&quot;</span>);        <span class="keyword">for</span> (Object o : wMap.entrySet()) &#123;            System.out.println(o);        &#125;    &#125;    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">testHashMap</span><span class="params">()</span> &#123;        System.out.println(<span class="string">&quot;HashMap GC之前&quot;</span>);        <span class="keyword">for</span> (Object o : map.entrySet()) &#123;            System.out.println(o);        &#125;        <span class="keyword">try</span> &#123;            System.gc();            TimeUnit.SECONDS.sleep(<span class="number">5</span>);        &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;            e.printStackTrace();        &#125;        System.out.println(<span class="string">&quot;HashMap GC之后&quot;</span>);        <span class="keyword">for</span> (Object o : map.entrySet()) &#123;            System.out.println(o);        &#125;    &#125;&#125;</code></pre><p>上面代码和图示主演演示WeakHashMap如何自动释放缓存对象，当init函数执行完成后，局部变量字符串引用weakd1，weakd2，d1，d2都会消失，此时只有静态map中保存中对字符串对象的引用，可以看到，调用gc之后，HashMap的没有被回收，而WeakHashMap里面的缓存被回收了。</p><h3 id="3-8-监听器和其他回调"><a href="#3-8-监听器和其他回调" class="headerlink" title="3.8 监听器和其他回调"></a>3.8 监听器和其他回调</h3><p>内存泄漏第三个常见来源是监听器和其他回调，如果客户端在你实现的API中注册回调，却没有显示的取消，那么就会积聚。</p><p>需要确保回调立即被当作垃圾回收的最佳方法是只保存它的弱引用，例如将他们保存成为WeakHashMap中的键。</p><h1 id="四、内存泄露案例分析"><a href="#四、内存泄露案例分析" class="headerlink" title="四、内存泄露案例分析"></a>四、内存泄露案例分析</h1><pre><code class="highlight java"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Stack</span> &#123;    <span class="keyword">private</span> Object[] elements;    <span class="keyword">private</span> <span class="type">int</span> <span class="variable">size</span> <span class="operator">=</span> <span class="number">0</span>;    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">int</span> <span class="variable">DEFAULT_INITIAL_CAPACITY</span> <span class="operator">=</span> <span class="number">16</span>;    <span class="keyword">public</span> <span class="title function_">Stack</span><span class="params">()</span> &#123;        elements = <span class="keyword">new</span> <span class="title class_">Object</span>[DEFAULT_INITIAL_CAPACITY];    &#125;    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">push</span><span class="params">(Object e)</span> &#123; <span class="comment">//入栈</span>        ensureCapacity();        elements[size++] = e;    &#125;    <span class="keyword">public</span> Object <span class="title function_">pop</span><span class="params">()</span> &#123; <span class="comment">//出栈</span>        <span class="keyword">if</span> (size == <span class="number">0</span>)            <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">EmptyStackException</span>();        <span class="keyword">return</span> elements[--size];    &#125;    <span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">ensureCapacity</span><span class="params">()</span> &#123;        <span class="keyword">if</span> (elements.length == size)            elements = Arrays.copyOf(elements, <span class="number">2</span> * size + <span class="number">1</span>);    &#125;&#125;</code></pre><p>上述程序并没有明显的错误，但是这段程序有一个内存泄漏，随着GC活动的增加，或者内存占用的不断增加，程序性能的降低就会表现出来，严重时可导致内存泄漏，但是这种失败情况相对较少。</p><p>代码的主要问题在pop函数，下面通过这张图示展现。假设这个栈一直增长，增长后如下图所示</p><p><img src="https://raw.githubusercontent.com/GeorgeChan95/blogimg/master/img/2024/08/24/20240824-145444.png" alt="pop方法内存泄漏"></p><p>当进行大量的pop操作时，由于引用未进行置空，gc是不会释放的，如下图所示</p><p><img src="https://raw.githubusercontent.com/GeorgeChan95/blogimg/master/img/2024/08/24/20240824-145558.png" alt="pop方法内存泄漏2"></p><p>从上图中看以看出，如果栈先增长，再收缩，那么从栈中弹出的对象将不会被当作垃圾回收，即使程序不再使用栈中的这些队象，他们也不会回收，因为栈中仍然保存这对象的引用，俗称过期引用，这个内存泄露很隐蔽。</p><p>将代码中的pop()方法变成如下方法：</p><pre><code class="highlight java"><span class="keyword">public</span> Object <span class="title function_">pop</span><span class="params">()</span> &#123;    <span class="keyword">if</span> (size == <span class="number">0</span>)        <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">EmptyStackException</span>();    <span class="type">Object</span> <span class="variable">result</span> <span class="operator">=</span> elements[--size];    elements[size] = <span class="literal">null</span>;    <span class="keyword">return</span> result;&#125;</code></pre><p>一旦引用过期，清空这些引用，将引用置空。</p><p><img src="https://raw.githubusercontent.com/GeorgeChan95/blogimg/master/img/2024/08/24/20240824-145718.png" alt="pop方法解决内存泄漏"></p>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;一、浅堆与深堆&quot;&gt;&lt;a href=&quot;#一、浅堆与深堆&quot; class=&quot;headerlink&quot; title=&quot;一、浅堆与深堆&quot;&gt;&lt;/a&gt;一、浅堆与深堆&lt;/h1&gt;&lt;h2 id=&quot;1-shallow-heap-浅堆&quot;&gt;&lt;a href=&quot;#1-shallow-heap-浅</summary>
      
    
    
    
    <category term="JVM" scheme="https://georgechan95.github.io/categories/JVM/"/>
    
    
    <category term="java" scheme="https://georgechan95.github.io/tags/java/"/>
    
    <category term="jvm" scheme="https://georgechan95.github.io/tags/jvm/"/>
    
  </entry>
  
  <entry>
    <title>第二十三章-JVM监控及诊断工具-GUI篇</title>
    <link href="https://georgechan95.github.io/blog/971417975.html"/>
    <id>https://georgechan95.github.io/blog/971417975.html</id>
    <published>2024-08-16T13:00:00.000Z</published>
    <updated>2024-08-28T04:17:33.353Z</updated>
    
    <content type="html"><![CDATA[<h1 id="一、工具概述"><a href="#一、工具概述" class="headerlink" title="一、工具概述"></a>一、工具概述</h1><p>使用命令行工具或组合能帮您获取目标Java应用性能相关的基础信息，但它们存在下列局限：</p><ul><li><p>无法获取方法级别的分析数据，如方法间的调用关系、各方法的调用次数和调用时间等（这对定位应用性能瓶颈至关重要）。</p></li><li><p>要求用户登录到目标 Java 应用所在的宿主机上，使用起来不是很方便。</p></li><li><p>分析数据通过终端输出，结果展示不够直观。</p></li></ul><p>为此，JDK提供了一些内存泄漏的分析工具，如 jconsole，jvisualvm 等，用于辅助开发人员定位问题，但是这些工具很多时候并不足以满足快速定位的需求。所以这里我们介绍的工具相对多一些、丰富一些。</p><h2 id="1-JDK自带的工具"><a href="#1-JDK自带的工具" class="headerlink" title="1. JDK自带的工具"></a>1. JDK自带的工具</h2><ul><li><p>jconsole：JDK自带的可视化监控工具。查看Java应用程序的运行概况、监控堆信息、永久区（或元空间）使用情况、类加载情况等 </p></li><li><p>Visual VM：Visual VM是一个工具，它提供了一个可视界面，用于查看Java虚拟机上运行的基于Java技术的应用程序的详细信息。 </p></li><li><p>JMC：Java Mission Control，内置Java Flight Recorder。能够以极低的性能开销收集Java虚拟机的性能数据。</p></li></ul><h2 id="2-第三方工具"><a href="#2-第三方工具" class="headerlink" title="2. 第三方工具"></a>2. 第三方工具</h2><ul><li><p>MAT：MAT（Memory Analyzer Tool）是基于 Eclipse 的内存分析工具，是一个快速、功能丰富的 Java heap 分析工具，它可以帮助我们查找内存泄漏和减少内存消耗 </p></li><li><p>JProfiler：商业软件，需要付费。功能强大。 </p></li><li><p>Arthas：Alibaba 开源的 java 诊断工具。</p></li><li><p>Btrace：java 运行时追踪工具。</p></li></ul><h2 id="3-服务端开启远程监控"><a href="#3-服务端开启远程监控" class="headerlink" title="3. 服务端开启远程监控"></a>3. 服务端开启远程监控</h2><p>Jconsole、JVisual、JMC 可视化工具，调用本地监控直接使用对应的命令行即可，但 Linux 无法使用可视化工具，Java 程序基本都部署到 Linux 服务器。需要开启 <strong>远程调用服务器</strong>，可以使用JMX代理实现.</p><h3 id="3-1-JMX"><a href="#3-1-JMX" class="headerlink" title="3.1 JMX"></a>3.1 JMX</h3><p>JMX (Java Management Extensions) 是 Java 提供的一套标准 API,用于管理和监控 Java 应用程序的各种性能指标和使用情况。这里主要使用远程访问的功能。</p><p><strong>JMX 启动参数：</strong></p><ul><li>-Dcom.sun.management.jmxremote 远程开启开关</li><li>-Dcom.sun.management.jmxremote.port&#x3D;1808 jmx远程调用端口</li><li>-Dcom.sun.management.jmxremote.rmi.port&#x3D;1808 添加 rmi 端口<ul><li>JMX 和 RMI，是两种相关联的技术，JMX 使用 RMI 作为远程管理工具来管理和监控 Java 程序，RMI 为 JMX 提供了远程连接所需的远程调用和通信机制。</li></ul></li><li>-Dcom.sun.management.jmxremote.authenticate&#x3D;false 不开启验证</li><li>-Dcom.sun.management.jmxremote.ssl&#x3D;false 不为ssl连接</li><li>-Djava.rmi.server.hostname&#x3D;192.168.6.203 服务器所在ip或者域名</li><li>-Dcom.sun.management.jmxremote.pwd.file&#x3D;&#x2F;opt&#x2F;module&#x2F;jdk1.8.0_261&#x2F;jre&#x2F;lib&#x2F;management&#x2F;jmxremote.password 配置JMX远程连接用户名和密码</li></ul><h4 id="3-1-1-无密码方式开启JMX远程连接"><a href="#3-1-1-无密码方式开启JMX远程连接" class="headerlink" title="3.1.1  无密码方式开启JMX远程连接"></a>3.1.1  无密码方式开启JMX远程连接</h4><p>jar 包程序启动一般为：</p><pre><code class="highlight shell">java -jar xxx.jar</code></pre><p>添加参数后：</p><pre><code class="highlight shell">java -Xmx512m -Xms512m -Xmn512m \-Dcom.sun.management.jmxremote \-Dcom.sun.management.jmxremote.port=1808 \-Dcom.sun.management.jmxremote.rmi.port=1808 \-Dcom.sun.management.jmxremote.authenticate=false \-Dcom.sun.management.jmxremote.ssl=false \-Djava.rmi.server.hostname=192.168.6.203 \-jar xxx.jar \--spring.profiles.active=prod</code></pre><p>启动服务后,使用 Jconsole、Visual VM、JProfiler 等连接服务端, 这里以 Jconsole 连接监控远程服务举例:</p><p><img src="https://raw.githubusercontent.com/GeorgeChan95/blogimg/master/img/2024/08/17/20240817-143557.png" alt="Jconsole无密码远程连接"></p><p><img src="https://raw.githubusercontent.com/GeorgeChan95/blogimg/master/img/2024/08/17/20240817-143715.png" alt="Jconsole无密码远程连接2"></p><p><img src="https://raw.githubusercontent.com/GeorgeChan95/blogimg/master/img/2024/08/17/20240817-143747.png" alt="Jconsole无密码远程连接3"></p><h4 id="3-1-2-有密码方式开启JMX远程连接"><a href="#3-1-2-有密码方式开启JMX远程连接" class="headerlink" title="3.1.2  有密码方式开启JMX远程连接"></a>3.1.2  有密码方式开启JMX远程连接</h4><p><strong>配置JMX密码文件</strong></p><pre><code class="highlight shell"><span class="meta prompt_"># </span><span class="language-bash">进入JMX配置文件目录</span>cd /opt/module/jdk1.8.0_261/jre/lib/management<span class="meta prompt_"></span><span class="meta prompt_"># </span><span class="language-bash">复制JMX密码文件</span>cp jmxremote.password.template jmxremote.password<span class="meta prompt_"></span><span class="meta prompt_"># </span><span class="language-bash">编辑密码文件, 修改 连接用户名/密码(这里设置为 controlRole / 123456)</span>vim jmxremote.password<span class="meta prompt_"></span><span class="meta prompt_"># </span><span class="language-bash">保存密码配置文件</span>wq!<span class="meta prompt_"></span><span class="meta prompt_"># </span><span class="language-bash">配置权限文件为600</span>chmod 600 jmxremote.password jmxremote.access</code></pre><p><img src="https://raw.githubusercontent.com/GeorgeChan95/blogimg/master/img/2024/08/17/20240817-144220.png" alt="jmxremote.password"></p><p>到这里密码配置就结束了</p><p><strong>启动Java服务</strong></p><pre><code class="highlight shell">java -Xmx512m -Xms512m -Xmn512m \-Dcom.sun.management.jmxremote \-Dcom.sun.management.jmxremote.port=1808 \-Dcom.sun.management.jmxremote.rmi.port=1808 \-Dcom.sun.management.jmxremote.authenticate=true \-Dcom.sun.management.jmxremote.ssl=false \-Djava.rmi.server.hostname=192.168.6.203 \-Dcom.sun.management.jmxremote.pwd.file=/opt/module/jdk1.8.0_261/jre/lib/management/jmxremote.password \-jar ioms-ums.jar \--spring.profiles.active=dev</code></pre><p><strong>使用Jconsole、Visual VM、JProfiler 等连接服务端,</strong> 这里以 Jconsole 连接监控远程服务举例:</p><p><img src="https://raw.githubusercontent.com/GeorgeChan95/blogimg/master/img/2024/08/17/20240817-144556.png" alt="Jconsole有密码远程连接"></p><p><strong>注意: 服务器防火墙要开放JMX监控端口</strong></p><h1 id="二、JConsole"><a href="#二、JConsole" class="headerlink" title="二、JConsole"></a>二、JConsole</h1><h2 id="1-基本概述"><a href="#1-基本概述" class="headerlink" title="1. 基本概述"></a>1. 基本概述</h2><ul><li><p>jconsole：从Java5开始，在JDK中自带的 java 监控和管理控制台。</p></li><li><p>用于对JVM中内存、线程和类等的监控，是一个基于JMX（java management extensions）的GUI性能监控工具。</p></li><li><p>官方地址：<a href="https://docs.oracle.com/javase/7/docs/technotes/guides/management/jconsole.html">https://docs.oracle.com/javase/7/docs/technotes/guides/management/jconsole.html</a></p></li></ul><h2 id="2-启动"><a href="#2-启动" class="headerlink" title="2. 启动"></a>2. 启动</h2><ul><li>方式一: 在jdk安装目录中找到jconsole.exe，双击该可执行文件就可以</li><li>方式二: 打开DOS窗口，直接输入jconsole就可以了</li></ul><h2 id="3-连接"><a href="#3-连接" class="headerlink" title="3. 连接"></a>3. 连接</h2><h3 id="3-1-本地连接"><a href="#3-1-本地连接" class="headerlink" title="3.1 本地连接"></a>3.1 本地连接</h3><p><strong>注意：本地连接要求 启动jconsole的用户 和 运行当前程序的用户 是同一个用户</strong></p><p>具体操作如下：</p><ol><li>在jdk的 bin 目录下,双击 jconsole.exe , 即可启动 jconsole</li></ol><p><img src="https://raw.githubusercontent.com/GeorgeChan95/blogimg/master/img/2024/08/17/20240817-150254.png" alt="启动jconsole"></p><ol start="2"><li>选择 <code>本地进程</code> , 选择要监控的程序 <code>PID</code> , 点击 <code>连接</code></li></ol><p><img src="https://raw.githubusercontent.com/GeorgeChan95/blogimg/master/img/2024/08/17/20240817-150504.png" alt="选择本地进程"></p><ol start="3"><li>点击 <code>不安全的连接</code></li></ol><p><img src="https://raw.githubusercontent.com/GeorgeChan95/blogimg/master/img/2024/08/17/20240817-150632.png" alt="不安全的连接"></p><ol start="4"><li>进入控制台页面</li></ol><p><img src="https://raw.githubusercontent.com/GeorgeChan95/blogimg/master/img/2024/08/17/20240817-150830.png" alt="控制台页面"></p><h3 id="3-2-远程连接"><a href="#3-2-远程连接" class="headerlink" title="3.2 远程连接"></a>3.2 远程连接</h3><p>见上一章节,第三部分 : <strong>服务端开启远程监控</strong></p><h3 id="3-3-Advanced"><a href="#3-3-Advanced" class="headerlink" title="3.3  Advanced"></a>3.3  Advanced</h3><p>使用一个特殊的URL连接JMX代理。一般情况使用自己定制的连接器而不是RMI提供的连接器来连接JMX代理，或者是一个使用JDK1.4的实现了JMX和JMX Rmote的应用</p><h2 id="4-主要作用"><a href="#4-主要作用" class="headerlink" title="4. 主要作用"></a>4. 主要作用</h2><h3 id="4-1-概览"><a href="#4-1-概览" class="headerlink" title="4.1 概览"></a>4.1 概览</h3><p><img src="https://raw.githubusercontent.com/GeorgeChan95/blogimg/master/img/2024/08/17/20240817-152123.png" alt="概览"></p><h3 id="4-2-内存"><a href="#4-2-内存" class="headerlink" title="4.2 内存"></a>4.2 内存</h3><p><img src="https://raw.githubusercontent.com/GeorgeChan95/blogimg/master/img/2024/08/17/20240817-152302.png" alt="内存"></p><p>可以在这里点 <code>执行GC</code> 手动进行一次 GC操作.</p><h3 id="4-3-线程"><a href="#4-3-线程" class="headerlink" title="4.3 线程"></a>4.3 线程</h3><p><img src="https://raw.githubusercontent.com/GeorgeChan95/blogimg/master/img/2024/08/17/20240817-152336.png" alt="监控程序线程"></p><h4 id="4-3-1-根据线程检测死锁"><a href="#4-3-1-根据线程检测死锁" class="headerlink" title="4.3.1 根据线程检测死锁"></a>4.3.1 根据线程检测死锁</h4><p>在线程监控中点击 <code>检测死锁</code> 检查程序中是否线程发生了 <code>死锁</code></p><p><img src="https://raw.githubusercontent.com/GeorgeChan95/blogimg/master/img/2024/08/17/20240817-152513.png" alt="检测死锁"></p><h3 id="4-4-加载的类"><a href="#4-4-加载的类" class="headerlink" title="4.4 加载的类"></a>4.4 加载的类</h3><p><img src="https://raw.githubusercontent.com/GeorgeChan95/blogimg/master/img/2024/08/17/20240817-152534.png" alt="加载的类"></p><h3 id="4-5-VM概要"><a href="#4-5-VM概要" class="headerlink" title="4.5 VM概要"></a>4.5 VM概要</h3><p><img src="https://raw.githubusercontent.com/GeorgeChan95/blogimg/master/img/2024/08/17/20240817-152015.png" alt="VM概要"></p><h1 id="三、Visual-VM"><a href="#三、Visual-VM" class="headerlink" title="三、Visual VM"></a>三、Visual VM</h1><ul><li><p>jvisualvm和visual vm的区别：</p><p>visual vm 是单独下载的工具，然后将 visual vm 结合到 jdk 中就变成了 jvisualvm，仅仅是添加了一个j而已，这个j应该是 java 的用处，所以说 jvisualvm 其实就是 visual vm</p></li></ul><h2 id="1-基本概述-1"><a href="#1-基本概述-1" class="headerlink" title="1. 基本概述"></a>1. 基本概述</h2><ul><li>Visual VM是一个功能强大的多合一故障诊断和性能监控的可视化工具。</li><li>它集成了多个JDK命令行工具，使用 Visual VM 可用于显示虚拟机进程及进程的配置和环境信息( jps,jinfo )，监视应用程序的CPU、GC、堆、方法区及线程的信息( jstat、jstack )等，甚至代替 JConsole。</li><li>在JDK6 Update 7以后，Visua1 VM 便作为JDK的一部分发布( Visual VM 在 JDK&#x2F;bin 目录下)，即:它完全免费。</li><li>此外，Visual VM 也可以作为独立的软件安装:</li></ul><p>首页: <a href="https://visualvm.github.io/index.html">https://visualvm.github.io/index.html</a></p><p><img src="https://raw.githubusercontent.com/GeorgeChan95/blogimg/master/img/2024/08/17/20240817-155000.png" alt="Visual VM 官网"></p><h2 id="2-使用方式："><a href="#2-使用方式：" class="headerlink" title="2. 使用方式："></a>2. 使用方式：</h2><ul><li><p>方式一: 在jdk安装目录中找到 <code>jvisualvm.exe</code> ，然后双击执行即可</p><p><img src="https://raw.githubusercontent.com/GeorgeChan95/blogimg/master/img/2024/08/17/20240817-155239.png" alt="jvisualvm.exe"></p></li><li><p>方式二: 打开DOS窗口，输入 <code>jvisualvm</code> 就可以打开该软件</p></li></ul><h2 id="3-主要功能"><a href="#3-主要功能" class="headerlink" title="3. 主要功能"></a>3. 主要功能</h2><ul><li><p>生成&#x2F;读取堆内存&#x2F;线程快照</p></li><li><p>查看JVM参数和系统属性</p></li><li><p>查看运行中的虚拟机进程</p></li><li><p>程序资源的实时监控</p></li><li><p>JMX代理连接、远程环境监控、CPU分析和内存分析</p></li></ul><h2 id="2-插件的安装"><a href="#2-插件的安装" class="headerlink" title="2. 插件的安装"></a>2. 插件的安装</h2><p>Visual VM 的一大特点是支持插件扩展，并且插件安装非常方便。我们既可以通过离线下载插件文件 *.nbm，然后在Plugin对话框的已下载页面下，添加已下载的插件。也可以在可用插件页面下,在线安装插件。(这里建议安装上: VisualGc )</p><ul><li><strong>离线安装</strong></li></ul><p>插件地址 : <a href="https://visualvm.github.io/pluginscenters.html">https://visualvm.github.io/pluginscenters.html</a></p><p><img src="https://raw.githubusercontent.com/GeorgeChan95/blogimg/master/img/2024/08/17/20240817-160134.png" alt="选择Visual VM 版本"></p><p><img src="https://raw.githubusercontent.com/GeorgeChan95/blogimg/master/img/2024/08/17/20240817-160236.png" alt="插件下载中心"></p><p>点击需要的插件, 即可下载.</p><p><img src="https://raw.githubusercontent.com/GeorgeChan95/blogimg/master/img/2024/08/17/20240817-160649.png" alt="点击添加插件"></p><p><img src="https://raw.githubusercontent.com/GeorgeChan95/blogimg/master/img/2024/08/17/20240817-161349.png" alt="选择插件"></p><p><img src="https://raw.githubusercontent.com/GeorgeChan95/blogimg/master/img/2024/08/17/20240817-161450.png" alt="点击安装"></p><p><img src="https://raw.githubusercontent.com/GeorgeChan95/blogimg/master/img/2024/08/17/20240817-161516.png" alt="安装成功"></p><ul><li><strong>在线安装</strong></li></ul><p><img src="https://raw.githubusercontent.com/GeorgeChan95/blogimg/master/img/2024/08/17/20240817-160540.png" alt="在线安装"></p><ul><li><strong>IDEA 安装 VisualVM Launcher 插件</strong></li></ul><p>“File” →→ “Settings” →→ “Plugins” 打开插件安装界面。</p><p><img src="https://raw.githubusercontent.com/GeorgeChan95/blogimg/master/img/2024/08/18/20240818-090501.png" alt="安装VisualVM插件"></p><p>插件安装好之后，重启IDEA，然后再打开 “Settings” 配置界面，找到 “VisualVM Launcher”，配置 Visual VM 的路径和JDK，如下：</p><p><img src="https://raw.githubusercontent.com/GeorgeChan95/blogimg/master/img/2024/08/18/20240818-091155.png" alt="配置Visual VM 插件"></p><p><strong>IDEA 启动并连接 Visual VM</strong></p><p><img src="https://raw.githubusercontent.com/GeorgeChan95/blogimg/master/img/2024/08/18/20240818-091648.png" alt="IDEA 启动并连接 Visual VM"></p><h2 id="3-连接方式"><a href="#3-连接方式" class="headerlink" title="3. 连接方式"></a>3. 连接方式</h2><h3 id="3-1-本地连接-1"><a href="#3-1-本地连接-1" class="headerlink" title="3.1 本地连接"></a>3.1 本地连接</h3><p>打开 Visual VM , 选择一个运行中的本地进程即可.</p><p><img src="https://raw.githubusercontent.com/GeorgeChan95/blogimg/master/img/2024/08/17/20240817-165644.png" alt="Visual VM 本地连接"></p><h3 id="3-2-远程连接-1"><a href="#3-2-远程连接-1" class="headerlink" title="3.2 远程连接"></a>3.2 远程连接</h3><ul><li>1-确定远程服务器的ip地址</li><li>2-添加JMX（通过JMX技术具体监控远程服务器哪个Java进程）</li><li>3-修改bin&#x2F;catalina.sh文件，连接远程的tomcat</li><li>4-在 ..&#x2F;conf 中添加 jmxremote.access 和 jmxremote.password 文件</li><li>5-将服务器地址改成公网ip地址</li><li>6-设置阿里云安全策略和防火墙策略</li><li>7-启动tomcat，查看tomcat启动日志和端口监听</li><li>8-JMX中输入端口号、用户名、密码登录</li></ul><p><strong>实操远程连接</strong></p><ul><li><p>服务器设置开启 JMX 远程监控端口</p><ul><li>具体参考 第一章节: <strong>服务端开启远程监控</strong></li></ul></li><li><p>Visual VM 添加远程连接</p><p><img src="https://raw.githubusercontent.com/GeorgeChan95/blogimg/master/img/2024/08/17/20240817-170109.png" alt="添加JMX连接"></p></li></ul><p><img src="https://raw.githubusercontent.com/GeorgeChan95/blogimg/master/img/2024/08/17/20240817-170302.png" alt="设置JMX连接参数"></p><p><img src="https://raw.githubusercontent.com/GeorgeChan95/blogimg/master/img/2024/08/17/20240817-170434.png" alt="JMX连接成功"></p><h2 id="4-主要功能"><a href="#4-主要功能" class="headerlink" title="4. 主要功能"></a>4. 主要功能</h2><h3 id="4-1-生成-读取堆内存快照"><a href="#4-1-生成-读取堆内存快照" class="headerlink" title="4.1 生成&#x2F;读取堆内存快照"></a>4.1 生成&#x2F;读取堆内存快照</h3><h4 id="4-1-1-生成dump文件"><a href="#4-1-1-生成dump文件" class="headerlink" title="4.1.1 生成dump文件"></a>4.1.1 生成dump文件</h4><ul><li><p>方式一: 在左侧列表, 右击运行的进程, 直接生成 堆Dump</p><p><img src="https://raw.githubusercontent.com/GeorgeChan95/blogimg/master/img/2024/08/18/20240818-103735.png" alt="直接生成 堆Dump"></p></li><li><p>方式二: 在 监视器TAB 标签页中, 点击 <code>堆Dump</code> 生成dump文件</p><p><img src="https://raw.githubusercontent.com/GeorgeChan95/blogimg/master/img/2024/08/18/20240818-103929.png" alt="监视器生成dump"></p></li></ul><p>注意：<br>生成堆内存快照如下图：</p><p><img src="https://raw.githubusercontent.com/GeorgeChan95/blogimg/master/img/2024/08/18/20240818-104053.png" alt="生成的dump文件"></p><p>这些快照存储在内存中，当线程停止的时候快照就会丢失，如果还想利用，可以将快照进行另存为操作，如下图：</p><p><img src="https://raw.githubusercontent.com/GeorgeChan95/blogimg/master/img/2024/08/18/20240818-104222.png" alt="导出dump文件"></p><h4 id="4-1-2-导入dump文件"><a href="#4-1-2-导入dump文件" class="headerlink" title="4.1.2 导入dump文件"></a>4.1.2 导入dump文件</h4><p><img src="https://raw.githubusercontent.com/GeorgeChan95/blogimg/master/img/2024/08/18/20240818-104415.png" alt="导入dump文件"></p><p>选择要导入的dump文件</p><p><img src="https://raw.githubusercontent.com/GeorgeChan95/blogimg/master/img/2024/08/18/20240818-104701.png" alt="选择dump文件"></p><h3 id="4-2-查看JVM参数和系统属性"><a href="#4-2-查看JVM参数和系统属性" class="headerlink" title="4.2 查看JVM参数和系统属性"></a>4.2 查看JVM参数和系统属性</h3><p><img src="https://raw.githubusercontent.com/GeorgeChan95/blogimg/master/img/2024/08/18/20240818-105215.png" alt="JVM参数和系统属性"></p><h3 id="4-3-查看运行中的虚拟机进程"><a href="#4-3-查看运行中的虚拟机进程" class="headerlink" title="4.3 查看运行中的虚拟机进程"></a>4.3 查看运行中的虚拟机进程</h3><p><img src="https://raw.githubusercontent.com/GeorgeChan95/blogimg/master/img/2024/08/18/20240818-105620.png" alt="查看进程"></p><p>其中每个进程号都代表一个进程</p><h3 id="4-4-生成-读取线程快照"><a href="#4-4-生成-读取线程快照" class="headerlink" title="4.4 生成&#x2F;读取线程快照"></a>4.4 生成&#x2F;读取线程快照</h3><h4 id="4-4-1-生成线程快照"><a href="#4-4-1-生成线程快照" class="headerlink" title="4.4.1 生成线程快照"></a>4.4.1 生成线程快照</h4><p><img src="https://raw.githubusercontent.com/GeorgeChan95/blogimg/master/img/2024/08/18/20240818-105802.png" alt="生成线程快照"></p><p><img src="https://raw.githubusercontent.com/GeorgeChan95/blogimg/master/img/2024/08/18/20240818-105902.png" alt="生成线程快照结果"></p><h4 id="4-4-2-装入线程快照"><a href="#4-4-2-装入线程快照" class="headerlink" title="4.4.2 装入线程快照"></a>4.4.2 装入线程快照</h4><p><img src="https://raw.githubusercontent.com/GeorgeChan95/blogimg/master/img/2024/08/18/20240818-110025.png" alt="装入线程快照"></p><p><img src="https://raw.githubusercontent.com/GeorgeChan95/blogimg/master/img/2024/08/18/20240818-110101.png" alt="选择快照文件"></p><h3 id="4-5-程序资源的实时监控"><a href="#4-5-程序资源的实时监控" class="headerlink" title="4.5 程序资源的实时监控"></a>4.5 程序资源的实时监控</h3><p><img src="https://raw.githubusercontent.com/GeorgeChan95/blogimg/master/img/2024/08/18/20240818-110304.png" alt="程序资源的实时监控"></p><ul><li>可以同时查看 CPU、线程、堆 的使用情况</li><li>可以查看类的加载数量</li><li>可以手动点击进行一次 GC</li></ul><h3 id="4-6-其他功能"><a href="#4-6-其他功能" class="headerlink" title="4.6 其他功能"></a>4.6 其他功能</h3><ul><li>JMX代理连接</li><li>远程环境监控</li><li>CPU分析和内存分析</li></ul><h1 id="四、Eclipse-MAT"><a href="#四、Eclipse-MAT" class="headerlink" title="四、Eclipse MAT"></a>四、Eclipse MAT</h1><h2 id="1-基本概述-2"><a href="#1-基本概述-2" class="headerlink" title="1. 基本概述"></a>1. 基本概述</h2><p>MAT（Memory Analyzer Tool）工具是一款功能强大的Java堆内存分析器。可以用于查找内存泄漏以及查看内存消耗情况。</p><p>MAT是基于Eclipse开发的，不仅可以单独使用，还可以作为插件的形式嵌入在Eclipse中使用。是一款免费的性能分析工具，使用起来非常方便。大家可以在 <a href="https://www.eclipse.org/mat/downloads.php">https://www.eclipse.org/mat/downloads.php</a> 下载并使用MAT</p><h3 id="1-1-安装MAT"><a href="#1-1-安装MAT" class="headerlink" title="1.1 安装MAT"></a>1.1 安装MAT</h3><ul><li>打开官网, 下载 MAT, 注意: 我的JDK是 1.8版本的, 需要下载 MAT 1.11.0 版本</li></ul><p><img src="https://raw.githubusercontent.com/GeorgeChan95/blogimg/master/img/2024/08/18/20240818-124733.png" alt="image-20240818124732612"></p><ul><li><p>解压安装包, 双击 <code>MemoryAnalyzer.exe</code> 即可启动</p><p><img src="https://raw.githubusercontent.com/GeorgeChan95/blogimg/master/img/2024/08/18/20240818-125715.png" alt="启动MAT"></p></li><li><p>解决JDK版本不兼容问题</p><p><img src="https://raw.githubusercontent.com/GeorgeChan95/blogimg/master/img/2024/08/18/20240818-125807.png" alt="JDK版本不兼容"></p><p>打开MAT的安装目录，找到配置文件 <code>MemoryAnalyzer.ini</code>：</p><p><img src="https://raw.githubusercontent.com/GeorgeChan95/blogimg/master/img/2024/08/18/20240818-142434.png" alt="MemoryAnalyzer.ini"></p><p>打开这个文件，在文件中如下两行,指定jdk版本。</p><p><img src="https://raw.githubusercontent.com/GeorgeChan95/blogimg/master/img/2024/08/18/20240818-142411.png" alt="指定jdk版本"></p><p><strong>注意事项</strong></p><ul><li>写在开头</li><li>必须小写-vm</li><li>必须 换行 写成2行</li></ul><p>保存之后，再次尝试，顺利启动。</p></li></ul><p><strong>还可以在 Eclipse 中以插件的方式安装</strong></p><p><img src="https://raw.githubusercontent.com/GeorgeChan95/blogimg/master/img/2024/08/18/20240818-123902.png" alt="eclipse安装MAT插件"></p><h2 id="2-获取堆dump文件"><a href="#2-获取堆dump文件" class="headerlink" title="2. 获取堆dump文件"></a>2. 获取堆dump文件</h2><p>MAT可以分析heap dump文件。在进行内存分析时，只要获得了反映当前设备内存映像的 hprof 文件,通过 MAT 打开就可以直观地看到当前的内存信息。</p><p>一般说来，这些内存信息包含：</p><ul><li>所有的对象信息，包括对象实例、成员变量、存储于栈中的基本类型值和存储于堆中的其他对象的引用值。</li><li>所有的类信息，包括 classloader、类名称、父类、静态变量等</li><li>GCRoot 到所有的这些对象的引用路径</li><li>线程信息，包括线程的调用栈及此线程的线程局部变量(TLS)</li></ul><p><strong>两点说明：</strong></p><ul><li><p>说明1：</p><p>缺点: MAT 不是一个万能工具，它并不能处理所有类型的堆存储文件。但是比较主流的厂家和格式，例如 Sun，HP，SAP 所采用的 HPROF 二进制堆存储文件，以及 IBM 的 PHD 堆存储文件等都能被很好的解析。</p></li><li><p>说明2:</p><p>最吸引人的还是能够快速为开发人员生成<strong>内存泄漏报表</strong>，方便定位问题和分析问题。虽然MAT有如此强大的功能，但是内存分析也没有简单到一键完成的程度，很多内存问题还是需要我们从MAT展现给我们的信息当中通过经验和直觉来判断才能发现。</p><p><img src="https://raw.githubusercontent.com/GeorgeChan95/blogimg/master/img/2024/08/20/20240820-183317.png" alt="生成内存泄漏报表"></p></li></ul><h3 id="2-1-生成dump文件"><a href="#2-1-生成dump文件" class="headerlink" title="2.1 生成dump文件"></a>2.1 生成dump文件</h3><ul><li><p>方法一: 通过 jmap 工具生成，可以生成任意一个java进程的 dump 文件;</p></li><li><p>方法二: 通过配置JVM参数生成。</p><ul><li>选项 “ -XX:+HeapDumpOn0utOfMemoryError “或” -XX:+HeapDumpBeforeFullGc “</li><li>选项 “ -XX:HeapDumpPath “ 所代表的含义就是当程序出现 OutofMemory 时，将会在相应的目录下生成一份 dump 文件。如果不指定选项 “ -XX:HeapDumpPath ”则在当前目录下生成dump文件。</li></ul><p>对比:考虑到生产环境中几乎不可能在线对其进行分析，大都是采用离线分析，因此使用 jmap + MAT 工具是最常见的组合。</p></li><li><p>方法三: 使用 VisualVM 可以导出堆dump文件</p></li><li><p>方法四: 使用MAT既可以打开一个已有的堆快照，也可以通过MAT直接从活动Java程序中导出堆快照该功能将借助jps列出当前正在运行的 Java 进程，以供选择并获取快照。</p><p><img src="https://raw.githubusercontent.com/GeorgeChan95/blogimg/master/img/2024/08/20/20240820-184556.png" alt="MAT导出dump文件"></p></li></ul><h2 id="3-分析堆dump文件"><a href="#3-分析堆dump文件" class="headerlink" title="3. 分析堆dump文件"></a>3. 分析堆dump文件</h2><h3 id="3-1-histogram-直方图"><a href="#3-1-histogram-直方图" class="headerlink" title="3.1 histogram(直方图)"></a>3.1 histogram(直方图)</h3><p>展示了各个类的实例数目以及这些实例的 Shallow heap 或者 Retained heap 的总和</p><p><img src="https://raw.githubusercontent.com/GeorgeChan95/blogimg/master/img/2024/08/20/20240820-190530.png" alt="生成直方图"></p><p>点击上面两个红框其中任意一个，都可以生成直方图，生成具体内容：</p><p><img src="https://raw.githubusercontent.com/GeorgeChan95/blogimg/master/img/2024/08/20/20240820-190927.png" alt="直方图内容"></p><h3 id="3-2-thread-overview"><a href="#3-2-thread-overview" class="headerlink" title="3.2 thread overview"></a>3.2 thread overview</h3><ul><li>查看系统中的Java线程</li><li>查看局部变量的信息</li></ul><p><img src="https://raw.githubusercontent.com/GeorgeChan95/blogimg/master/img/2024/08/20/20240820-191717.png" alt="线程概览"></p><p><img src="https://raw.githubusercontent.com/GeorgeChan95/blogimg/master/img/2024/08/20/20240820-192456.png" alt="线程明细"></p><h3 id="3-3-获得对象互相引用的关系"><a href="#3-3-获得对象互相引用的关系" class="headerlink" title="3.3 获得对象互相引用的关系"></a>3.3 获得对象互相引用的关系</h3><ul><li><p>with outgoing references 变量引用了谁</p><p>​<img src="https://raw.githubusercontent.com/GeorgeChan95/blogimg/master/img/2024/08/20/20240820-193043.png" alt="outgoing"></p><p><img src="https://raw.githubusercontent.com/GeorgeChan95/blogimg/master/img/2024/08/20/20240820-193139.png" alt="引用结果"></p></li><li><p>with incoming references 谁引用了该变量</p><p><img src="https://raw.githubusercontent.com/GeorgeChan95/blogimg/master/img/2024/08/20/20240820-193245.png" alt="incoming"></p><p><img src="https://raw.githubusercontent.com/GeorgeChan95/blogimg/master/img/2024/08/20/20240820-193409.png" alt="引用结果"></p></li></ul><h3 id="3-4-浅堆与深堆"><a href="#3-4-浅堆与深堆" class="headerlink" title="3.4 浅堆与深堆"></a>3.4 浅堆与深堆</h3><h4 id="3-4-1-shallow-heap-浅堆"><a href="#3-4-1-shallow-heap-浅堆" class="headerlink" title="3.4.1 shallow heap(浅堆)"></a>3.4.1 shallow heap(浅堆)</h4><p>shallow heap是对象本身的大小，不包括其引用的对象。<br>对于非数组类型：shallow heap就是对象与其成员变量加在一起的大小。<br>对于数组类型：shallow heap就是数组各个元素大小之和。</p><h4 id="3-4-2-retained-heap-保留集"><a href="#3-4-2-retained-heap-保留集" class="headerlink" title="3.4.2 retained heap(保留集)"></a>3.4.2 retained heap(保留集)</h4><p>对象remainder heap 大小 &#x3D; 对象shallow heap大小 + 对象直接或者间接引用的对象大小（排除被GC ROOT直接引用的对象）。<br>如下图所示：</p><p><img src="https://raw.githubusercontent.com/GeorgeChan95/blogimg/master/img/2024/08/20/20240820-194720.png" alt="对象引用关系"></p><p><strong>对象引用关系</strong><br>OBJECT A 的 remainder heap &#x3D; OBJECT A 的 shallow heap<br>OBJECT B的 remainder heap &#x3D; OBJECT B 的 shallow heap + OBJECT C 的对象大小 + OBJECT E 的对象大小</p><p>所以对象的remainder heap其实接近进行垃圾回收时，清除该对象时所能获取的堆内存大小（有的对象可能还被其他对象引用，垃圾回收时，不能清除）。</p><p>下面是用mat对从服务器上面dump出来Java虚拟机内存进行解析之后的结果：</p><p><img src="https://raw.githubusercontent.com/GeorgeChan95/blogimg/master/img/2024/08/20/20240820-194952.png" alt="内存分析"></p><p><strong>Java内存解析结果</strong></p><p>其中，Objects为类的对象的个数。Shallow Heap是这些对象自身大小之和，Remainder Heap是这些对象自身以及这些对象直接或者间接引用的对象大小总和。</p><h4 id="3-4-3-补充：对象实际大小"><a href="#3-4-3-补充：对象实际大小" class="headerlink" title="3.4.3 补充：对象实际大小"></a>3.4.3 补充：对象实际大小</h4><p>另外一个常用的概念是对象的实际大小。这里，对象的实际大小定义为一个对象所能触及的所有对象的浅堆大小之和，也就是通常意义上我们说的对象大小。与深堆相比，似乎这个在日常开发中更为直观和被人接受，但实际上，<strong>这个概念和垃圾回收无关</strong>。</p><p>下图显示了一个简单的对象引用关系图，对象A引用了C和D，对象B引用了C和E。那么对象A的浅堆大小只是A本身，不含C和D，而A的实际大小为A、C、D三者之和。而A的深堆大小为A与D之和，由于对象C还可以通过对象B访问到，因此不在对象A的深堆范围内。</p><p><img src="https://raw.githubusercontent.com/GeorgeChan95/blogimg/master/img/2024/08/20/20240820-195149.png" alt="对象引用关系"></p><h4 id="3-4-4-案例分析：StudentTrace"><a href="#3-4-4-案例分析：StudentTrace" class="headerlink" title="3.4.4 案例分析：StudentTrace"></a>3.4.4 案例分析：StudentTrace</h4><p><strong>案例代码</strong></p><pre><code class="highlight java"><span class="comment">/**</span><span class="comment"> * 有一个学生浏览网页的记录程序，它将记录 每个学生访问过的网站地址。</span><span class="comment"> * 它由三个部分组成：Student、WebPage和StudentTrace三个类</span><span class="comment"> *</span><span class="comment"> *  -XX:+HeapDumpBeforeFullGC -XX:HeapDumpPath=d:\student.hprof</span><span class="comment"> */</span><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">StudentTrace</span> &#123;    <span class="keyword">static</span> List&lt;WebPage&gt; webpages = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;WebPage&gt;();    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">createWebPages</span><span class="params">()</span> &#123;        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; <span class="number">100</span>; i++) &#123;            <span class="type">WebPage</span> <span class="variable">wp</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">WebPage</span>();            wp.setUrl(<span class="string">&quot;http://www.&quot;</span> + Integer.toString(i) + <span class="string">&quot;.com&quot;</span>);            wp.setContent(Integer.toString(i));            webpages.add(wp);        &#125;    &#125;    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;        createWebPages();<span class="comment">//创建了100个网页</span>        <span class="comment">//创建3个学生对象</span>        <span class="type">Student</span> <span class="variable">st3</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Student</span>(<span class="number">3</span>, <span class="string">&quot;Tom&quot;</span>);        <span class="type">Student</span> <span class="variable">st5</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Student</span>(<span class="number">5</span>, <span class="string">&quot;Jerry&quot;</span>);        <span class="type">Student</span> <span class="variable">st7</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Student</span>(<span class="number">7</span>, <span class="string">&quot;Lily&quot;</span>);        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; webpages.size(); i++) &#123;            <span class="keyword">if</span> (i % st3.getId() == <span class="number">0</span>)                st3.visit(webpages.get(i));            <span class="keyword">if</span> (i % st5.getId() == <span class="number">0</span>)                st5.visit(webpages.get(i));            <span class="keyword">if</span> (i % st7.getId() == <span class="number">0</span>)                st7.visit(webpages.get(i));        &#125;        webpages.clear();        System.gc();    &#125;&#125;<span class="keyword">class</span> <span class="title class_">Student</span> &#123;    <span class="keyword">private</span> <span class="type">int</span> id;    <span class="keyword">private</span> String name;    <span class="keyword">private</span> List&lt;WebPage&gt; history = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();    <span class="keyword">public</span> <span class="title function_">Student</span><span class="params">(<span class="type">int</span> id, String name)</span> &#123;        <span class="built_in">super</span>();        <span class="built_in">this</span>.id = id;        <span class="built_in">this</span>.name = name;    &#125;    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">getId</span><span class="params">()</span> &#123;        <span class="keyword">return</span> id;    &#125;    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setId</span><span class="params">(<span class="type">int</span> id)</span> &#123;        <span class="built_in">this</span>.id = id;    &#125;    <span class="keyword">public</span> String <span class="title function_">getName</span><span class="params">()</span> &#123;        <span class="keyword">return</span> name;    &#125;    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setName</span><span class="params">(String name)</span> &#123;        <span class="built_in">this</span>.name = name;    &#125;    <span class="keyword">public</span> List&lt;WebPage&gt; <span class="title function_">getHistory</span><span class="params">()</span> &#123;        <span class="keyword">return</span> history;    &#125;    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setHistory</span><span class="params">(List&lt;WebPage&gt; history)</span> &#123;        <span class="built_in">this</span>.history = history;    &#125;    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">visit</span><span class="params">(WebPage wp)</span> &#123;        <span class="keyword">if</span> (wp != <span class="literal">null</span>) &#123;            history.add(wp);        &#125;    &#125;&#125;<span class="keyword">class</span> <span class="title class_">WebPage</span> &#123;    <span class="keyword">private</span> String url;    <span class="keyword">private</span> String content;    <span class="keyword">public</span> String <span class="title function_">getUrl</span><span class="params">()</span> &#123;        <span class="keyword">return</span> url;    &#125;    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setUrl</span><span class="params">(String url)</span> &#123;        <span class="built_in">this</span>.url = url;    &#125;    <span class="keyword">public</span> String <span class="title function_">getContent</span><span class="params">()</span> &#123;        <span class="keyword">return</span> content;    &#125;    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setContent</span><span class="params">(String content)</span> &#123;        <span class="built_in">this</span>.content = content;    &#125;&#125;</code></pre><p><img src="https://raw.githubusercontent.com/GeorgeChan95/blogimg/master/img/2024/08/20/20240820-200332.png" alt="线程对象追踪"></p><p><strong>结论：</strong><br>elementData 数组的浅堆是80个字节，而 elementData 数组中的所有 WebPage 对象的深堆之和是1208个字节，所以加在一起就是 elementData 数组的深堆之和，也就是1288个字节</p><p><strong>解析：</strong></p><p>默认采用了指针压缩则为12字节，没有采用则为16字节（数组还需要加上数组长度）。</p><p>1.为什么有152字节和144字节：因为我们的URL和content存在两种情况<br>        URL:”<a href="http://www.7.com"、content:"7"-----URL:"http://www.14.com"、content:"14">http://www.7.com&quot;、content:&quot;7&quot;-----URL:&quot;http://www.14.com&quot;、content:&quot;14</a>“<br>        第一种URL长度为16，底层的char数组的占用空间为(【】方括号里面整个都属于对象头，分开写方便大家理解)<br>            【普通对象头(12) + 数组长度(4)】 + 16个字符(32) &#x3D; 48字节，符合8字节对齐<br>            同理content 占用 【普通对象头(12) +数组长度(4)】+ 一个字符(2) &#x3D; 18字节,八字节对齐&#x3D;24字节<br>        第二种URL长度为17，底层的插入数组的占用空间为<br>            【普通对象头(12) + 数组长度(4)】 + 17个字符(34) &#x3D; 50字节，不符合8字节对齐，对齐为56<br>            同理content 占用 【普通对象头(12) +数组长度(4)】+ 两个字符(4) &#x3D; 20字节,八字节对齐&#x3D;24字节<br>        所以第一种总字节为48 + 24 &#x3D; 72,第二种总字节为56 + 24 &#x3D; 80<br>        因此第二种比第一种多了8字节，所以是152和144。<br>        (为什么总大小是152而不是72是因为我们只计算了String底层的char数组的区别没有计算各变量本身的浅堆,<br>        因为结构都相同，所以差别就差在内容的占用上)</p><p>2.为什么最终结果是1288<br>        首先ElementData数组本身的浅堆大小为<br>        【普通对象头(12) + 数组长度(4)】 + 数组内容【15个Obejct引用&#x3D;16*4】 &#x3D; 76,八字节对齐&#x3D;80字节<br>        15个Object分为13个152字节+2个144字节，总大小为&#x3D;2264字节<br>        7号和其他student重复的有0、21、42、63、84、35、70总计6个152和1一个144<br>        所以2264 - 6 * 152 - 144 &#x3D; 1208字节<br>    所以ElementData本身的浅堆80 + 仅能通过它到达的浅堆1208 &#x3D; 1288</p><h3 id="3-5-支配树"><a href="#3-5-支配树" class="headerlink" title="3.5 支配树"></a>3.5 支配树</h3><p>支配树的概念源自<strong>图论</strong>。</p><p>MAT提供了一个称为<strong>支配树</strong>（Dominator Tree)的对象图。支配树体现了<strong>对象实例</strong>间的支配关系。在对象引用图中，所有指向对象B的路径都经过对象A , 则认为对象A支配对象B。如果对象A是离对象B最近的一个支配对象 ，则认为对象A为对象B的<strong>直接支配者</strong>。支配树是基于<strong>对象间的引用图</strong>所建立的，它有以下基本性质：</p><ul><li>对象A的子树（所有被对象A支配的对象集合）表示对象A的保留集（retained set) , 即深堆</li><li>如果对象A支配对象B , 那么对象A的直接支配者也支配对象B</li><li>支配树的边与对象引用图的边不直接对应</li></ul><p>如下图所示：</p><p>左图表示<strong>对象引用图</strong>，右图表示左图所对应的<strong>支配树</strong>。</p><p>对象A和B由根对象直接支配，由于在到对象C的路径中，可以经过A , 也可以经过B , 因此对象C的直接支配者也是根对象。<br>对象F与对象D相互引用 ，因为到对象F的所有路径必然经过对象D , 因此，对象D是对象F的直接支配者 。<br>而到对象D的所有路径中，必然经过对象C , 即使是从对象F到对象D的引用 ，从根节点出发，也是经过对象C的，所以 ，对象D的直接支配者为对象C。</p><p><img src="https://raw.githubusercontent.com/GeorgeChan95/blogimg/master/img/2024/08/22/20240822-184127.png" alt="支配树"></p><p>同理，对象E支配对象G。到达对象H的可以通过对象D , 也可以通过对象E , 因此对象D和E都不能支配对象H , 而经过对象C既可以到达D也可以到达E , 因此<strong>对象C为对象H的直接支配者</strong>。</p><p>在MAT中，单击工具栏上的对象支配树按钮，可以打开<strong>对象支配树</strong>视图。</p><p><img src="https://raw.githubusercontent.com/GeorgeChan95/blogimg/master/img/2024/08/22/20240822-184933.png" alt="MAT通过dump文件查看对象支配树"></p><p>下图显示了对象支配树视图的一部分。该截图显示部分Lily学生的history队列的直接支配对象。即当Lily对象被回收，也会一并回收的所有对象。显然能被3或者5整除的网页不会出现在该列表中，因为它们同时被另外两名学生对象引用。</p><h2 id="4-案例：Tomcat堆溢出分析"><a href="#4-案例：Tomcat堆溢出分析" class="headerlink" title="4. 案例：Tomcat堆溢出分析"></a>4. 案例：Tomcat堆溢出分析</h2><h3 id="4-1-说明"><a href="#4-1-说明" class="headerlink" title="4.1 说明"></a>4.1 说明</h3><p>Tomcat是最常用的Java Servlet容器之一，同时也可以当做单独的Web服务器使用。<br> Tomcat本身使用Java实现，并运行于Java虚拟机之上。在大规模请求时，Tomcat有可能会因为无法承受压力而发生内存溢出错误。这里根据一个被压垮的Tomcat的堆快照文件，来分析Tomcat在崩溃时的内部情况。</p><h3 id="4-2-分析过程"><a href="#4-2-分析过程" class="headerlink" title="4.2 分析过程"></a>4.2 分析过程</h3><p><img src="https://raw.githubusercontent.com/GeorgeChan95/blogimg/master/img/2024/08/22/20240822-191115.png" alt="Tomcat溢出分析图1"></p><p><img src="https://raw.githubusercontent.com/GeorgeChan95/blogimg/master/img/2024/08/22/20240822-191318.png" alt="Tomcat溢出分析图2"></p><p><img src="https://raw.githubusercontent.com/GeorgeChan95/blogimg/master/img/2024/08/22/20240822-191325.png" alt="Tomcat溢出分析图3"></p><p><img src="https://raw.githubusercontent.com/GeorgeChan95/blogimg/master/img/2024/08/22/20240822-191331.png" alt="Tomcat溢出分析图4"></p><p><img src="https://raw.githubusercontent.com/GeorgeChan95/blogimg/master/img/2024/08/22/20240822-191337.png" alt="Tomcat溢出分析图5"></p><p><img src="https://raw.githubusercontent.com/GeorgeChan95/blogimg/master/img/2024/08/22/20240822-191343.png" alt="Tomcat溢出分析图6"></p><p><img src="https://raw.githubusercontent.com/GeorgeChan95/blogimg/master/img/2024/08/22/20240822-191350.png" alt="Tomcat溢出分析图6-2"></p><p><img src="https://raw.githubusercontent.com/GeorgeChan95/blogimg/master/img/2024/08/22/20240822-191356.png" alt="Tomcat溢出分析图7"></p><p><img src="https://raw.githubusercontent.com/GeorgeChan95/blogimg/master/img/2024/08/22/20240822-191405.png" alt="Tomcat溢出分析图8"></p><h1 id="五、JProfiler"><a href="#五、JProfiler" class="headerlink" title="五、JProfiler"></a>五、JProfiler</h1><h2 id="1-基本概述-3"><a href="#1-基本概述-3" class="headerlink" title="1. 基本概述"></a>1. 基本概述</h2><h3 id="1-1-介绍"><a href="#1-1-介绍" class="headerlink" title="1.1 介绍"></a>1.1 介绍</h3><p>在运行Java的时候有时候想测试运行时占用内存情况，这时候就需要使用测试工具查看了。在eclipse里面有 Eclipse Memory Analyzer tool (MAT) 插件可以测试，而在IDEA中也有这么一个插件，就是JProfiler。</p><p>JProfiler 是由 ej-technologies 公司开发的一款 Java 应用性能诊断工具。功能强大，但是收费。</p><p>官网下载地址：<a href="https://www.ej-technologies.com/jprofiler">https://www.ej-technologies.com/jprofiler</a></p><p><img src="https://raw.githubusercontent.com/GeorgeChan95/blogimg/master/img/2024/08/22/20240822-194145.png" alt="JProfiler 官网"></p><h3 id="1-2-特点"><a href="#1-2-特点" class="headerlink" title="1.2 特点"></a>1.2 特点</h3><ul><li><p>使用方便、界面操作友好（简单且强大）</p></li><li><p>对被分析的应用影响小（提供模板）</p></li><li><p>CPU，Thread，Memory分析功能尤其强大</p></li><li><p>支持对jdbc，noSql，jsp，servlet，socket等进行分析</p></li><li><p>支持多种模式（离线，在线）的分析</p></li><li><p>支持监控本地、远程的JVM</p></li><li><p>跨平台，拥有多种操作系统的安装版本</p></li></ul><h3 id="1-3-主要功能"><a href="#1-3-主要功能" class="headerlink" title="1.3 主要功能"></a>1.3 主要功能</h3><ul><li>1-方法调用：对方法调用的分析可以帮助您了解应用程序正在做什么，并找到提高其性能的方法</li><li>2-内存分配：通过分析堆上对象、引用链和垃圾收集能帮您修复内存泄露问题，优化内存使用</li><li>3-线程和锁：JProfiler 提供多种针对线程和锁的分析视图助您发现多线程问题</li><li>4-高级子系统：许多性能问题都发生在更高的语义级别上。例如，对于JDBC调用，您可能希望找出执行最慢的SQL语句。JProfiler支持对这些子系统进行集成分析</li></ul><h2 id="2-安装与配置"><a href="#2-安装与配置" class="headerlink" title="2. 安装与配置"></a>2. 安装与配置</h2><h3 id="2-1-下载与安装"><a href="#2-1-下载与安装" class="headerlink" title="2.1 下载与安装"></a>2.1 下载与安装</h3><p>下载地址：<a href="https://www.ej-technologies.com/jprofiler/download">https://www.ej-technologies.com/jprofiler/download</a></p><p><img src="https://raw.githubusercontent.com/GeorgeChan95/blogimg/master/img/2024/08/22/20240822-195531.png" alt="下载 JProfiler"></p><p>选择一个版版本，点击下载后，安装。（收费软件，下载安装后有试用期）</p><p>或者下载使用破解版本：<a href="https://downloadlynet.ir/2020/12/1885/03/jprofiler/00/#/1885-ej-techn-152438080522.html">https://downloadlynet.ir/2020/12/1885/03/jprofiler/00/?#/1885-ej-techn-152438080522.html</a></p><h3 id="2-2-JProfiler-中配置-IDEA"><a href="#2-2-JProfiler-中配置-IDEA" class="headerlink" title="2.2 JProfiler 中配置 IDEA"></a>2.2 JProfiler 中配置 IDEA</h3><p><img src="https://raw.githubusercontent.com/GeorgeChan95/blogimg/master/img/2024/08/22/20240822-201609.png" alt="IDEA集成"></p><p>点击选择 <code>IDEA Integrations</code></p><p><img src="https://raw.githubusercontent.com/GeorgeChan95/blogimg/master/img/2024/08/22/20240822-202323.png" alt="选择IDEA，点击 Integrate"></p><p>选择 <code>IntelliJ IDEA</code> ， 点击 <code>Integrate</code>,  再点击 OK</p><h3 id="2-3-IDEA集成JProfiler"><a href="#2-3-IDEA集成JProfiler" class="headerlink" title="2.3 IDEA集成JProfiler"></a>2.3 IDEA集成JProfiler</h3><p><img src="https://raw.githubusercontent.com/GeorgeChan95/blogimg/master/img/2024/08/22/20240822-202123.png" alt="安装 JProfiler 插件"></p><p>IDEA 安装 JProfiler 插件</p><p><img src="https://raw.githubusercontent.com/GeorgeChan95/blogimg/master/img/2024/08/22/20240822-202816.png" alt="image-20240822202816158"></p><p>Tool 中配置 JProfiler 的执行exe文件路径。</p><p>安装并配置完成后，IDEA工具栏会出现这两个图标，点击可以直接启动一个进程，或者追踪一个运行中的进程。</p><p><img src="https://raw.githubusercontent.com/GeorgeChan95/blogimg/master/img/2024/08/22/20240822-203121.png" alt="image-20240822203120430"></p><h2 id="3-具体使用"><a href="#3-具体使用" class="headerlink" title="3. 具体使用"></a>3. 具体使用</h2><h3 id="3-1-数据采集方式"><a href="#3-1-数据采集方式" class="headerlink" title="3.1 数据采集方式"></a>3.1 数据采集方式</h3><ul><li>Instrumentation：这是 JProfiler 全功能模式。在 class 加载之前，JProfier 把相关功能代码写入到需要分析的 class 的 bytecode 中，对正在运行的 jvm 有一定影响。<ul><li>优点：功能强大。在此设置中，调用堆栈信息是准确的。</li><li>缺点：若要分析的 class 较多，则对应用的性能影响较大，CPU 开销可能很高（取决于 Filter 的控制）。因此使用此模式一般配合 Filter 使用，只对特定的类或包进行分析</li></ul></li><li>Sampling：类似于样本统计，每隔一定时间（5ms）将每个线程栈中方法栈中的信息统计出来。<ul><li>优点：对 CPU 的开销非常低，对应用影响小（即使你不配置任何 Filter）</li><li>缺点：一些数据／特性不能提供（例如：方法的调用次数、执行时间）</li></ul></li></ul><p>注：JProfiler 本身没有指出数据的采集类型，这里的采集类型是针对方法调用的采集类型。因为 JProfiler 的绝大多数核心功能都依赖方法调用采集的数据，所以可以直接认为是 JProfiler 的数据采集类型。</p><h3 id="3-2-遥感监测-Telemetries"><a href="#3-2-遥感监测-Telemetries" class="headerlink" title="3.2 遥感监测 Telemetries"></a>3.2 遥感监测 Telemetries</h3><h4 id="3-2-1-概览"><a href="#3-2-1-概览" class="headerlink" title="3.2.1 概览"></a>3.2.1 概览</h4><p><img src="https://raw.githubusercontent.com/GeorgeChan95/blogimg/master/img/2024/08/23/20240823-082049.png" alt="概览"></p><h4 id="3-2-2-内存"><a href="#3-2-2-内存" class="headerlink" title="3.2.2 内存"></a>3.2.2 内存</h4><p><img src="https://raw.githubusercontent.com/GeorgeChan95/blogimg/master/img/2024/08/23/20240823-083632.png" alt="内存"></p><p>内存占用持续飙升，存在OOM风险</p><h4 id="3-2-3-记录的对象"><a href="#3-2-3-记录的对象" class="headerlink" title="3.2.3 记录的对象"></a>3.2.3 记录的对象</h4><p><img src="https://raw.githubusercontent.com/GeorgeChan95/blogimg/master/img/2024/08/23/20240823-083819.png" alt="记录的对象"></p><h4 id="3-2-4-记录的吞吐量"><a href="#3-2-4-记录的吞吐量" class="headerlink" title="3.2.4 记录的吞吐量"></a>3.2.4 记录的吞吐量</h4><p><img src="https://raw.githubusercontent.com/GeorgeChan95/blogimg/master/img/2024/08/23/20240823-083914.png" alt="记录的吞吐量"></p><h4 id="3-2-5-GC活动"><a href="#3-2-5-GC活动" class="headerlink" title="3.2.5 GC活动"></a>3.2.5 GC活动</h4><p><img src="https://raw.githubusercontent.com/GeorgeChan95/blogimg/master/img/2024/08/23/20240823-084559.png" alt="GC活动"></p><h4 id="3-2-6-类"><a href="#3-2-6-类" class="headerlink" title="3.2.6 类"></a>3.2.6 类</h4><p><img src="https://raw.githubusercontent.com/GeorgeChan95/blogimg/master/img/2024/08/23/20240823-084628.png" alt="类"></p><h4 id="3-2-7-线程"><a href="#3-2-7-线程" class="headerlink" title="3.2.7 线程"></a>3.2.7 线程</h4><p><img src="https://raw.githubusercontent.com/GeorgeChan95/blogimg/master/img/2024/08/23/20240823-084653.png" alt="线程"></p><h4 id="3-2-8-CPU负载"><a href="#3-2-8-CPU负载" class="headerlink" title="3.2.8 CPU负载"></a>3.2.8 CPU负载</h4><p><img src="https://raw.githubusercontent.com/GeorgeChan95/blogimg/master/img/2024/08/23/20240823-084722.png" alt="CPU负载"></p><h3 id="3-3-内存视图-Live-Memory"><a href="#3-3-内存视图-Live-Memory" class="headerlink" title="3.3 内存视图 Live Memory"></a>3.3 内存视图 Live Memory</h3><p><code>Live memory</code> 内存剖析：<code>class/class instance</code> 的相关信息。例如对象的个数，大小，对象创建的方法执行栈，对象创建的热点。</p><h4 id="3-3-1-所有对象-All-Objects"><a href="#3-3-1-所有对象-All-Objects" class="headerlink" title="3.3.1 所有对象 All Objects"></a>3.3.1 所有对象 All Objects</h4><p>显示所有加载的类的列表和在堆上分配的实例数。只有Java 1.5(JVMTI)才会显示此视图。</p><p><img src="https://raw.githubusercontent.com/GeorgeChan95/blogimg/master/img/2024/08/23/20240823-085930.png" alt="Live Memory"></p><p>通过内存标记，可以查看到 Picture 持续增加，程序存在内存泄漏。</p><h4 id="3-3-2-记录对象Recorded-Objects"><a href="#3-3-2-记录对象Recorded-Objects" class="headerlink" title="3.3.2 记录对象Recorded Objects"></a>3.3.2 记录对象Recorded Objects</h4><p>查看特定时间段对象的分配，并记录分配的调用堆栈。</p><p><img src="https://raw.githubusercontent.com/GeorgeChan95/blogimg/master/img/2024/08/23/20240823-091046.png" alt="Recorded Objects"></p><p>可以看到Picture类占用了过多的内存，需要重点查看</p><h4 id="3-3-3-分配访问树-Allocation-Call-Tree"><a href="#3-3-3-分配访问树-Allocation-Call-Tree" class="headerlink" title="3.3.3 分配访问树 Allocation Call Tree"></a>3.3.3 分配访问树 Allocation Call Tree</h4><p>显示一棵请求树或者方法、类、包或对已选择类有带注释的分配信息的J2EE组件。</p><p><img src="https://raw.githubusercontent.com/GeorgeChan95/blogimg/master/img/2024/08/23/20240823-091415.png" alt="分配访问树"></p><h4 id="3-3-4-分配热点-Allocation-Hot-Spots"><a href="#3-3-4-分配热点-Allocation-Hot-Spots" class="headerlink" title="3.3.4 分配热点 Allocation Hot Spots"></a>3.3.4 分配热点 Allocation Hot Spots</h4><p>显示一个列表，包括方法、类、包或分配已选类的J2EE组件。你可以标注当前值并且显示差异值。对于每个热点都可以显示它的跟踪记录树。</p><p><img src="https://raw.githubusercontent.com/GeorgeChan95/blogimg/master/img/2024/08/23/20240823-092146.png" alt="Allocation Hot Spots"></p><h4 id="3-3-5-类追踪器-Class-Tracker"><a href="#3-3-5-类追踪器-Class-Tracker" class="headerlink" title="3.3.5 类追踪器 Class Tracker"></a>3.3.5 类追踪器 Class Tracker</h4><p>类跟踪视图可以包含任意数量的图表，显示选定的类和包的实例与时间。</p><p><img src="https://raw.githubusercontent.com/GeorgeChan95/blogimg/master/img/2024/08/23/20240823-093043.png" alt="Class Tracker"></p><p>分析：内存中的对象的情况</p><ul><li>频繁创建的Java对象：死循环、循环次数过多</li><li>存在大的对象：读取文件时，byte[]应该边读边写。如果长时间不写出的话，导致byte[]过大</li><li>存在内存泄漏</li></ul><p>注意：</p><ul><li>All Objects后面的Size大小是浅堆大小</li><li>Record Objects 在判断内存泄露的时候使用，可以通过观察Telemetries中的Memory，如果里面出现垃圾回收之后的内存占用逐步提高，这就有可能出现内存泄露问题，所以可以使用Record Objects查看，但是该分析默认不开启，毕竟占用CPU性能太多</li></ul><h3 id="3-4-堆遍历-heap-walker"><a href="#3-4-堆遍历-heap-walker" class="headerlink" title="3.4 堆遍历 heap walker"></a>3.4 堆遍历 heap walker</h3><p>如果通过内存视图 Live Memory已经分析出哪个类的对象不能进行垃圾回收，并且有可能导致内存溢出，如果想进一步分析，我们可以在该对象上点击右键，选择Show Selection In Heap Walker，如下图：</p><p><img src="https://raw.githubusercontent.com/GeorgeChan95/blogimg/master/img/2024/08/23/20240823-122458.png" alt="Show Selection In Heap Walker"></p><p>进入堆遍历视图，如下图所示：</p><p><img src="https://raw.githubusercontent.com/GeorgeChan95/blogimg/master/img/2024/08/23/20240823-123008.png" alt="image-20240823123007846"></p><p>查看对象的引用关系，如下图：</p><p><img src="https://raw.githubusercontent.com/GeorgeChan95/blogimg/master/img/2024/08/23/20240823-123505.png" alt="对象引用关系"></p><ul><li><p>Outgoing references 对象引用了谁</p><p><img src="https://raw.githubusercontent.com/GeorgeChan95/blogimg/master/img/2024/08/23/20240823-123700.png" alt="Outgoing references"></p></li><li><p>Incoming references 谁引用了自己</p><p><img src="https://raw.githubusercontent.com/GeorgeChan95/blogimg/master/img/2024/08/23/20240823-123821.png" alt="Incoming references"></p></li><li><p>Show In Graph 通过图表形式查看对象引用关系</p><p><img src="https://raw.githubusercontent.com/GeorgeChan95/blogimg/master/img/2024/08/23/20240823-124144.png" alt="image-20240823124143505"></p></li></ul><p><img src="https://raw.githubusercontent.com/GeorgeChan95/blogimg/master/img/2024/08/23/20240823-124442.png" alt="引用关系图"></p><h3 id="3-5-cpu视图-cpu-views"><a href="#3-5-cpu视图-cpu-views" class="headerlink" title="3.5  cpu视图 cpu views"></a>3.5  cpu视图 cpu views</h3><p><code>JProfiler</code> 提供不同的方法来记录访问树以优化性能和细节。线程或者线程组以及线程状况可以被所有的视图选择。所有的视图都可以聚集到方法、类、包或J2EE组件等不同层上。</p><ul><li><p><strong>访问树 Call Tree</strong></p><p>显示一个积累的自顶向下的树，树中包含所有在JVM中已记录的访问队列。JDBC,JMS和JNDI服务请求都被注释在请求树中。请求树可以根据Servlet和JSP对URL的不同需要进行拆分。</p><p><img src="https://raw.githubusercontent.com/GeorgeChan95/blogimg/master/img/2024/08/23/20240823-195001.png" alt="访问树"></p></li></ul><p>上面的 100% 表示该方法会100%调用下面的方法, 276s 表示方法调用一共花费了276秒, 再往下就是方法的全名称.</p><p>左上角可以筛选展示: Package, Class, Method</p><ul><li><p><strong>热点 Hot Spots</strong></p><p>显示消耗时间最多的方法的列表。对每个热点都能够显示回溯树。该热点可以按照方法请求，JDBC,JMS和JNDI服务请求以及按照URL请求来进行计算。</p><p><img src="https://raw.githubusercontent.com/GeorgeChan95/blogimg/master/img/2024/08/23/20240823-195125.png" alt="热点"></p></li><li><p><strong>访问图 Call Graph</strong></p><p>显示一个从已选方法、类、包或]2EE组件开始的访问队列的图。</p><p><img src="https://raw.githubusercontent.com/GeorgeChan95/blogimg/master/img/2024/08/23/20240823-195416.png" alt="访问图"></p></li><li><p><strong>方法检测 Outlier Detection</strong></p><p>显示一段时间内记录的方法的调用时间细节。</p><p><img src="https://raw.githubusercontent.com/GeorgeChan95/blogimg/master/img/2024/08/23/20240823-200246.png" alt="image-20240823200244805"></p></li><li><p><strong>调用栈追踪 Call Tracer</strong></p><p><img src="https://raw.githubusercontent.com/GeorgeChan95/blogimg/master/img/2024/08/23/20240823-200527.png" alt="image-20240823200526033"></p></li></ul><h3 id="3-6-线程视图-threads"><a href="#3-6-线程视图-threads" class="headerlink" title="3.6  线程视图 threads"></a>3.6  线程视图 threads</h3><p>JProfiler通过对线程历史的监控判断其运行状态，并监控是否有线程阻塞产生，还能将一个线程所管理的方法以树状形式呈现。对线程剖析。</p><ul><li><p><strong>线程历史 Thread History</strong></p><p>显示一个与线程活动和线程状态在一起的活动时间表。</p><p><img src="https://raw.githubusercontent.com/GeorgeChan95/blogimg/master/img/2024/08/23/20240823-202059.png" alt="线程历史"></p></li><li><p><strong>线程监控 Thread Monitor</strong></p><p>显示一个列表，包括所有的活动线程以及它们目前的活动状况。</p><p><img src="https://raw.githubusercontent.com/GeorgeChan95/blogimg/master/img/2024/08/23/20240823-202149.png" alt="线程监控"></p></li><li><p><strong>线程转储 Thread Dumps</strong></p><p>显示所有线程的堆栈跟踪。</p><p><img src="https://raw.githubusercontent.com/GeorgeChan95/blogimg/master/img/2024/08/23/20240823-202330.png" alt="线程转储"></p></li></ul><p>线程分析主要关心三个方面：</p><ul><li>web容器的线程最大数。比如：Tomcat的线程容量应该略大于最大并发数。</li><li>线程阻塞</li><li>线程死锁</li></ul><h3 id="3-7-监视器-锁-Monitors-locks"><a href="#3-7-监视器-锁-Monitors-locks" class="headerlink" title="3.7 监视器&amp;锁 Monitors&amp;locks"></a>3.7 监视器&amp;锁 Monitors&amp;locks</h3><p>监控和锁 <code>Monitors &amp; Locks</code> 所有线程持有<strong>锁</strong>的情况以及锁的信息. 观察JVM的内部线程并查看状态：</p><ul><li><p><strong>死锁探测图表 Current Locking Graph</strong></p><p>显示JVM中的当前<strong>死锁</strong>图表</p><p><img src="https://raw.githubusercontent.com/GeorgeChan95/blogimg/master/img/2024/08/23/20240823-202629.png" alt="死锁探测图表"></p></li><li><p><strong>监测器 Current Monitors</strong></p><p>显示目前使用的监测器并且包括它们的<strong>关联线程</strong></p><p><img src="https://raw.githubusercontent.com/GeorgeChan95/blogimg/master/img/2024/08/23/20240823-203056.png" alt="Current Monitors"></p></li><li><p><strong>锁定历史图表 Locking History Graph</strong></p><p>显示记录在JVM中的<strong>锁定历史</strong></p></li><li><p><strong>历史检测记录Monitor History</strong></p><p>显示重大的<strong>等待事件</strong>和<strong>阻塞事件</strong>的历史记录</p></li><li><p><strong>监控器使用统计 Monitor Usage Statistics</strong></p><p>显示分组监测，线程和监测类的<strong>统计监测数据</strong></p></li></ul><h2 id="4-案例分析"><a href="#4-案例分析" class="headerlink" title="4. 案例分析"></a>4. 案例分析</h2><ul><li><p>代码</p><pre><code class="highlight java"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">MemoryLeak</span> &#123;    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;        <span class="keyword">while</span> (<span class="literal">true</span>) &#123;            <span class="type">ArrayList</span> <span class="variable">beanList</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ArrayList</span>();            <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; <span class="number">500</span>; i++) &#123;                <span class="type">Bean</span> <span class="variable">data</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Bean</span>();                data.list.add(<span class="keyword">new</span> <span class="title class_">byte</span>[<span class="number">1024</span> * <span class="number">10</span>]);<span class="comment">//10kb</span>                beanList.add(data);            &#125;            <span class="keyword">try</span> &#123;                TimeUnit.MILLISECONDS.sleep(<span class="number">500</span>);            &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;                e.printStackTrace();            &#125;        &#125;    &#125;&#125;<span class="keyword">class</span> <span class="title class_">Bean</span> &#123;    <span class="type">int</span> <span class="variable">size</span> <span class="operator">=</span> <span class="number">10</span>;    <span class="type">String</span> <span class="variable">info</span> <span class="operator">=</span> <span class="string">&quot;hello,atguigu&quot;</span>;<span class="comment">//     ArrayList list = new ArrayList();</span>    <span class="keyword">static</span> <span class="type">ArrayList</span> <span class="variable">list</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ArrayList</span>();&#125;</code></pre></li><li><p>使用JProfiler进行分析</p><ul><li><p>我们通过JProfiler来看一下，如下：</p><p><img src="https://raw.githubusercontent.com/GeorgeChan95/blogimg/master/img/2024/08/23/20240823-204502.png" alt="查看内存"></p><p>你可以看到内存一个劲的往上涨，但是就是没有下降的趋势，说明这肯定有问题，过不了多久就会出现OOM，我们来到Live memory中，先标记看一下到底是哪些对象在进行内存增长，等一小下看看会不会触发垃圾回收，如果不触发的话，我们自己来触发垃圾回收，之后观察哪些对象没有被回收掉，如下：</p></li><li><p>查看Live Memory, 标记内存, 手动进行GC</p><p><img src="https://raw.githubusercontent.com/GeorgeChan95/blogimg/master/img/2024/08/23/20240823-204649.png" alt="查看活动的内存"></p><p>我上面点击了Mark Current，发现有些对象在持续增长，然后点击了一下Run GC，发现 byte[] 并没有被回收</p></li><li><p>点击Show Selection In Heap Walker，如下：</p><p><img src="https://raw.githubusercontent.com/GeorgeChan95/blogimg/master/img/2024/08/23/20240823-204856.png" alt="右键,点击 Heap Walker"></p></li><li><p>然后看一下该对象被谁引用，如下：</p><p><img src="https://raw.githubusercontent.com/GeorgeChan95/blogimg/master/img/2024/08/23/20240823-205031.png" alt="Incoming reference"></p><p>结果如下：</p><p><img src="https://raw.githubusercontent.com/GeorgeChan95/blogimg/master/img/2024/08/23/20240823-205343.png" alt="image-20240823205342532"></p></li></ul></li><li><p>结论</p><p>可以看出byte[]来自于Bean类是的list中，并且这个list是ArrayList类型的静态集合，所以找到了：static ArrayList list &#x3D; new ArrayList();<br>发现list是静态的，这不妥，因为我们的目的是while结束之后Bean对象被回收，并且Bena对象中的所有字段都被回收，但是list是静态的，那就是类的，众所周知，类变量随类而生，随类而灭，因此每次我们往list中添加值，都是往同一个list中添加值，这会造成list不断增大，并且不能回收，所以最终会导致OOM</p></li></ul><h1 id="六、Arthas"><a href="#六、Arthas" class="headerlink" title="六、Arthas"></a>六、Arthas</h1><h2 id="1-基本概述-4"><a href="#1-基本概述-4" class="headerlink" title="1. 基本概述"></a>1. 基本概述</h2><h3 id="1-1-背景"><a href="#1-1-背景" class="headerlink" title="1.1 背景"></a>1.1 背景</h3><p>前面，我们介绍了jdk自带的 <code>jvisualvm</code> 等免费工具，以及商业化工具<code>Jprofiler</code>。</p><p>这两款工具在业界知名度也比较高，他们的优点是可以<strong>图形界面</strong>上看到各维度的性能数据，使用者根据这些数据进行综合分析，然后判断哪里出现了性能问题。</p><p>但是这两款工具也有个缺点，都必须在<strong>服务端</strong>项目进程中配置相关的监控参数。然后工具通过远程连接到项目进程，获取相关的数据。这样就会带来一些不便，比如线上环境的网络是<strong>隔离</strong>的，本地的监控工具根本连不上线上环境。并且类似于<code>Jprofiler</code>这样的商业工具，是需要付费的。</p><p>阿里巴巴开源的<strong>性能分析神器</strong>Arthas(阿尔萨斯）不需要远程连接，也不需要配置监控参数，并且提供了丰富的性能监控数据.</p><h3 id="1-2-概述"><a href="#1-2-概述" class="headerlink" title="1.2 概述"></a>1.2 概述</h3><p>Arthas支持JDK6+,支持 <code>Linux</code> &#x2F; <code>Mac</code> &#x2F; <code>Windows</code>,采用命令行交互模式，同时提供丰富的<code>Tab</code>自动补全功能，进一步方便进行问题的定位和诊断。</p><p>当你遇到以下类似问题而束手无策时，Arthas可以帮助你解决：</p><ul><li><p>这个类从哪个jar包加载的？为什么会报各种类相关的Exception?</p></li><li><p>我改的代码为什么没有执行到？难道是我没commit?分支搞错了？</p></li><li><p>遇到问题无法在线上 debug , 难道只能通过加日志再重新发布吗？</p></li><li><p>线上遇到某个用户的数据处理有问题，但线上同样无法 debug,线下无法重现！</p></li><li><p>是否有一个全局视角来查看系统的运行状况？</p></li><li><p>有什么办法可以监控到JVM的实时运行状态？</p></li><li><p>怎么快速定位应用的热点，生成火焰图？</p></li></ul><h3 id="1-3-基于哪些工具开发而来"><a href="#1-3-基于哪些工具开发而来" class="headerlink" title="1.3 基于哪些工具开发而来"></a>1.3 基于哪些工具开发而来</h3><ul><li>greys-anatomy:Arthas代码基于Greys二次开发而来，非常感谢Greys之前所有的工作，以及Greys原作者对Arthas提出的意见和建议！</li><li>termd:Arthas的命令行实现基于termd开发，是一款优秀的命令行程序开发框架，感谢termd提供了优秀的框架。</li><li>crash:Arthas的文本渲染功能基于crash中的文本渲染功能开发，可以从这里看到源码，感谢crash在这方面所做的优秀工作。</li><li>cli:Arthas的命令行界面基于vert.x提供的cli库进行开发，感谢vert.x在这方面做的优秀工作。</li><li>compiler Arthas里的内存编绎器代码来源</li><li>Apache Commons Net Arthas里的Telnet Client代码来源</li><li>JavaAgent:运行在main方法之前的拦截器，它内定的方法名叫premain,也就是说先执行premain方法然后再执行main方法</li><li>ASM:一个通用的Java字节码操作和分析框架。它可以用于修改现有的类或直接以二进制形式动态生成类。ASM提供了一些常见的字节码转换和分析算法，可以从它们构建定制的复杂转换和代码分析工具。ASM提供了与其他Java字节码框架类似的功能，但是主要关注性能。因为它被设计和实现得尽可能小和快，所以非常适合在动态系统中使用（当然也可以以静态方式使用，例如在编译器中）</li></ul><h3 id="1-4-官方使用文档"><a href="#1-4-官方使用文档" class="headerlink" title="1.4 官方使用文档"></a>1.4 官方使用文档</h3><p><a href="https://arthas.aliyun.com/">https://arthas.aliyun.com/</a></p><p><img src="https://raw.githubusercontent.com/GeorgeChan95/blogimg/master/img/2024/08/23/20240823-210407.png" alt="官网"></p><h2 id="2-安装与使用"><a href="#2-安装与使用" class="headerlink" title="2. 安装与使用"></a>2. 安装与使用</h2><h3 id="2-1-安装"><a href="#2-1-安装" class="headerlink" title="2.1 安装"></a>2.1 安装</h3><p><strong>安装方式一:</strong> 可以直接在Linux上通过命令下载</p><p>可以在官方 Github 上进行下载，如果速度较慢，可以尝试国内的码云 Gitee 下载。</p><ul><li><p>Github下载</p><pre><code class="highlight shell">wget https://alibaba.github.io/arthas/arthas-boot.jar</code></pre><p><img src="https://raw.githubusercontent.com/GeorgeChan95/blogimg/master/img/2024/08/24/20240824-082939.png" alt="从Github下载"></p></li><li><p>Gitee 下载</p><pre><code class="highlight shell">wget https://arthas.gitee.io/arthas-boot.jar</code></pre></li></ul><p><strong>安装方式二:</strong></p><p>也可以在浏览器直接访问 <a href="https://alibaba.github.io/arthas/arthas-boot.jar">https://alibaba.github.io/arthas/arthas-boot.jar</a> ，等待下载完后，上传到Linux服务器上。</p><p><strong>卸载</strong></p><p>在 Linux&#x2F;Unix&#x2F;Mac 平台，删除下面的文件：</p><pre><code class="highlight shell">rm -rf ~/.arthasrm -rf ~/logs/arthas</code></pre><p><img src="https://raw.githubusercontent.com/GeorgeChan95/blogimg/master/img/2024/08/24/20240824-083154.png" alt="image-20240824083153843"></p><p>Windows 平台直接删除 <code>&lt;User_Home&gt;</code> 下的 .arthas 和 logs&#x2F;arthas 目录</p><h3 id="2-2-工程目录"><a href="#2-2-工程目录" class="headerlink" title="2.2 工程目录"></a>2.2 工程目录</h3><ul><li><strong>arthas-agent</strong>: 基于 JavaAgent 技术的代理</li><li><strong>bin</strong>: 一些启动脚本</li><li><strong>arthas-boot</strong>: Java 版本的一键安装启动脚本</li><li><strong>arthas-client</strong>: telnet client 代码</li><li><strong>arthas-common</strong>: 一些共用的工具类和枚举类</li><li><strong>arthas-core</strong>: 核心库，各种 arthas 命令的交互和实现</li><li><strong>arthas-demo</strong>: 示例代码</li><li><strong>arthas-memorycompiler</strong>: 内存编绎器代码，Fork from <a href="https://github.com/skalogs/SkaETL/tree/master/compiler">https://github.com/skalogs/SkaETL/tree/master/compiler</a></li><li><strong>arthas-packaging</strong>: maven 打包相关的</li><li><strong>arthas-site</strong>: arthas 站点</li><li><strong>arthas-spy</strong>: 编织到目标类中的各个功面</li><li><strong>static</strong>: 静态资源</li><li><strong>arthas-testcase</strong>: 测试</li></ul><h3 id="2-3-启动"><a href="#2-3-启动" class="headerlink" title="2.3 启动"></a>2.3 启动</h3><p>Arthas 只是一个 Java 程序，所以可以直接用 <code>java -jar</code> 运行。</p><ul><li><p>执行成功后，arthas 提供了一种命令行方式的交互方式，arthas 会检测当前服务器上的 Java 进程并将进程列表展示出来，用户输入对应的编号 (1、2、3、4…) 进行选择，然后回车。</p><p>选择进程（输入[]内编号（不是PID)回车）</p></li></ul><p><img src="https://raw.githubusercontent.com/GeorgeChan95/blogimg/master/img/2024/08/24/20240824-083713.png" alt="启动方式一"></p><ul><li>方式2: 运行时选择 Java 进程 PID</li></ul><p><img src="https://raw.githubusercontent.com/GeorgeChan95/blogimg/master/img/2024/08/24/20240824-083826.png" alt="启动方式二"></p><h3 id="2-4-查看进程"><a href="#2-4-查看进程" class="headerlink" title="2.4 查看进程"></a>2.4 查看进程</h3><p>查看运行中的程序进程号，使用命令：<code>jps</code> 或者 <code>jps -l</code></p><h3 id="2-5-查看日志"><a href="#2-5-查看日志" class="headerlink" title="2.5 查看日志"></a>2.5 查看日志</h3><pre><code class="highlight shell">cat ~/logs/arthas/arthas.log</code></pre><h3 id="2-6-参看帮助"><a href="#2-6-参看帮助" class="headerlink" title="2.6 参看帮助"></a>2.6 参看帮助</h3><pre><code class="highlight shell">java -jar arthas-boot.jar -h</code></pre><h3 id="2-7-web-console"><a href="#2-7-web-console" class="headerlink" title="2.7 web console"></a>2.7 web console</h3><p>除了在命令行查看外，<code>Arthas</code>目前还支持 <code>Web Console</code> 。在成功启动连接进程之后就已经自动启动，可以直接访问 <code>http://127.0.0.1:8563/</code> 访问，页面上的操作模式和控制台完全一样。</p><h3 id="2-8-退出"><a href="#2-8-退出" class="headerlink" title="2.8 退出"></a>2.8 退出</h3><ul><li>使用 <code>quit/exit</code>：退出当前客户端</li><li>使用 <code>stop/shutdown</code>：关闭 arthas 服务端，并退出所有客户端。</li></ul><h2 id="3-相关诊断指令"><a href="#3-相关诊断指令" class="headerlink" title="3. 相关诊断指令"></a>3. 相关诊断指令</h2><p>官方文档: <a href="https://arthas.aliyun.com/doc/commands.html">https://arthas.aliyun.com/doc/commands.html</a></p><h3 id="3-1-基础指令"><a href="#3-1-基础指令" class="headerlink" title="3.1 基础指令"></a>3.1 基础指令</h3><ul><li><code>help</code>：查看命令帮助信息</li><li><code>cat</code>：打印文件内容，和 linux 里的 cat 命令类似</li><li><code>echo</code>：打印参数，和 linux 里的 echo 命令类似</li><li><code>grep</code>：匹配查找，和 linux 里的 grep 命令类似</li><li><code>tee</code>：复制标准输入到标准输出和指定的文件，和 linux 里的 tee 命令类似</li><li><code>pwd</code>：返回当前的工作目录，和 linux 命令类似</li><li><code>cls</code>：清空当前屏幕区域</li><li><code>session</code>：查看当前会话的信息</li><li><code>reset</code>：重置增强类，将被 Arthas 增强过的类全部还原，Arthas 服务端关闭时会重置所有增强过的类</li><li><code>version</code>：输出当前目标 Java 进程所加戟的 Arthas 版本号</li><li><code>history</code>：打印命令历史</li><li><code>quit</code>：退出当前 Arthas 客户端，其他 Arthas 客户端不受影响</li><li><code>stop</code>：关闭 Arthas 服务端，所有 Arthas 客户端全部退出</li><li><code>keymap</code>：Arthas 快捷键列表及自定义快捷键</li></ul><h3 id="3-2-jvm相关"><a href="#3-2-jvm相关" class="headerlink" title="3.2 jvm相关"></a>3.2 jvm相关</h3><p><a href="https://arthas.aliyun.com/doc/commands.html">https://arthas.aliyun.com/doc/commands.html</a></p><ul><li><code>dashboard</code>: 当前系统的实时数据面板</li><li><code>thread</code>: 查看当前 JVM 的线程堆栈信息</li><li><code>jvm</code>: 查看当前 JVM 的信息</li><li><code>sysenv</code>: 查看 JVM 的环境变量</li><li><code>sysprop</code>: 查看和修改 JVM 的系统属性</li><li><code>sysem</code>: 查看 JVM 的环境变量</li><li><code>vmoption</code>: 查看和修改 JVM 里诊断相关的 option</li><li><code>perfcounter</code>: 查看当前 JVM 的 Perf Counter 信息</li><li><code>logger</code>: 查看和修改 logger</li><li><code>getstatic</code>: 查看类的静态属性</li><li><code>ognl</code>: 执行 ognl 表达式</li><li><code>mbean</code>: 查看 Mbean 的信息</li><li><code>heapdump</code>: dump java heap，类似 jmap 命令的 heap dump 功能</li></ul><h3 id="3-3-class-classloader相关"><a href="#3-3-class-classloader相关" class="headerlink" title="3.3 class&#x2F;classloader相关"></a>3.3 class&#x2F;classloader相关</h3><ul><li><code>sc</code>: 查看 JVM 已加载的类信息</li><li><code>sm</code>: 查看已加载类的方法信息</li><li><code>jad</code>: 反编译指定已加载类的源码</li><li><code>mc</code>: 内存编译器，内存编译.java 文件为.class 文件</li><li><code>retransform</code>: 加载外部的.class 文件，retransform 到 JVM 里</li><li><code>redefine</code>: 加载外部的.class 文件，redefine 到 JVM 里</li><li><code>dump</code>: dump 已加载类的 byte code 到特定目录</li><li><code>classloader</code>: 查看 classloader 的继承树，urls，类加载信息，使用 classloader 去 getResource</li></ul><h3 id="3-4-monitor-watch-trace相关"><a href="#3-4-monitor-watch-trace相关" class="headerlink" title="3.4 monitor&#x2F;watch&#x2F;trace相关"></a>3.4 monitor&#x2F;watch&#x2F;trace相关</h3><p>请注意，这些命令，都通过字节码增强技术来实现的，会在指定类的方法中插入一些切面来实现数据统计和观测，因此在线上、预发使用时，请尽量明确需要观测的类、方法以及条件，诊断结束要执行 stop 或将增强过的类执行 reset 命令。</p><ul><li>monitor 对匹配 <code>class-pattern／method-pattern／condition-express</code> 的类、方法的调用进行监控。</li><li>watch: 让你能方便的观察到指定函数的调用情况。能观察到的范围为：返回值、抛出异常、入参，通过编写 OGNL 表达式进行对应变量的查看。</li><li>trace: <code>trace</code> 命令能主动搜索 <code>class-pattern</code>／<code>method-pattern</code> 对应的方法调用路径，渲染和统计整个调用链路上的所有性能开销和追踪调用链路。</li><li>stack: 很多时候我们都知道一个方法被执行，但这个方法被执行的路径非常多，或者你根本就不知道这个方法是从那里被执行了，此时你需要的是 <code>stack</code> 命令。</li><li>tt: 方法执行数据的时空隧道，记录下指定方法每次调用的入参和返回信息，并能对这些不同的时间下调用进行观测</li></ul><h3 id="3-5-其他"><a href="#3-5-其他" class="headerlink" title="3.5 其他"></a>3.5 其他</h3><ul><li><p>profiler&#x2F;火焰图: <a href="https://arthas.aliyun.com/doc/profiler.html">https://arthas.aliyun.com/doc/profiler.html</a></p><p><img src="https://raw.githubusercontent.com/GeorgeChan95/blogimg/master/img/2024/08/24/20240824-093316.jpg" alt="火焰图"></p></li><li><p>options: <a href="https://arthas.aliyun.com/doc/options.html">https://arthas.aliyun.com/doc/options.html</a></p></li></ul><h1 id="七、Java-Misssion-Control"><a href="#七、Java-Misssion-Control" class="headerlink" title="七、Java Misssion Control"></a>七、Java Misssion Control</h1><h2 id="1-历史"><a href="#1-历史" class="headerlink" title="1. 历史"></a>1. 历史</h2><p>在 Oracle 收购 Sun 之前，Oracle 的 JRockit 虚拟机提供了一款叫做 JRockit Mission Control 的虚拟机诊断工具。</p><p>在 Oracle 收购 sun 之后，Oracle 公司同时拥有了 Hotspot 和 JRockit 两款虚拟机。根据 Oracle 对于 Java 的战略，在今后的发展中，会将 JRokit 的优秀特性移植到 Hotspot 上。其中一个重要的改进就是在 Sun 的 JDK 中加入了 JRockit 的支持。</p><p>在 Oracle JDK 7u40 之后，Mission Control 这款工具己经绑定在 Oracle JDK 中发布。</p><p>自 Java11 开始，本节介绍的 JFR 己经开源。但在之前的 Java 版本，JFR 属于 Commercial Feature 通过 Java 虚拟机参数 <code>-XX:+UnlockCommercialFeatures</code> 开启。</p><ul><li>官方地址：<a href="https://openjdk.org/projects/jmc">https://openjdk.org/projects/jmc</a></li><li>Github项目地址：<a href="https://github.com/openjdk/jmc">https://github.com/openjdk/jmc</a></li></ul><h2 id="2-概述"><a href="#2-概述" class="headerlink" title="2. 概述"></a>2. 概述</h2><p>Java Mission Control（简称 JMC) ， Java 官方提供的性能强劲的工具，是一个用于对 Java 应用程序进行管理、监视、概要分析和故障排除的工具套件。</p><p>它包含一个 GUI 客户端以及众多用来收集 Java 虚拟机性能数据的插件如 JMX Console（能够访问用来存放虚拟机各个子系统运行数据的 MXBeans）以及虚拟机内置的高效 profiling 工具 Java Flight Recorder（JFR）。</p><p>JMC 的另一个优点就是：采用取样，而不是传统的代码植入技术，对应用性能的影响非常非常小，完全可以开着 JMC 来做压测（唯一影响可能是 full gc 多了）。</p><h2 id="3-启动"><a href="#3-启动" class="headerlink" title="3. 启动"></a>3. 启动</h2><p>Mission Control 位于 <code>%JAVA_HOME%/bin/jmc.exe</code></p><p><img src="https://raw.githubusercontent.com/GeorgeChan95/blogimg/master/img/2024/08/24/20240824-094004.png" alt="jmc.exe"></p><h2 id="4-功能：实时监控JVM运行时的状态"><a href="#4-功能：实时监控JVM运行时的状态" class="headerlink" title="4. 功能：实时监控JVM运行时的状态"></a>4. 功能：实时监控JVM运行时的状态</h2><p>如果是远程服务器，使用前要开 JMX。</p><p><strong>JMX 启动参数：</strong></p><ul><li>-Dcom.sun.management.jmxremote 远程开启开关</li><li>-Dcom.sun.management.jmxremote.port&#x3D;1808 jmx远程调用端口</li><li>-Dcom.sun.management.jmxremote.rmi.port&#x3D;1808 添加 rmi 端口<ul><li>JMX 和 RMI，是两种相关联的技术，JMX 使用 RMI 作为远程管理工具来管理和监控 Java 程序，RMI 为 JMX 提供了远程连接所需的远程调用和通信机制。</li></ul></li><li>-Dcom.sun.management.jmxremote.authenticate&#x3D;false 不开启验证</li><li>-Dcom.sun.management.jmxremote.ssl&#x3D;false 不为ssl连接</li><li>-Djava.rmi.server.hostname&#x3D;192.168.6.203 服务器所在ip或者域名</li><li>-Dcom.sun.management.jmxremote.pwd.file&#x3D;&#x2F;opt&#x2F;module&#x2F;jdk1.8.0_261&#x2F;jre&#x2F;lib&#x2F;management&#x2F;jmxremote.password 配置JMX远程连接用户名和密码</li></ul><p><strong>服务端启动示例</strong></p><pre><code class="highlight shell">java -Xmx512m -Xms512m -Xmn512m \-XX:+UnlockCommercialFeatures -XX:+FlightRecorder \-Dcom.sun.management.jmxremote \-Dcom.sun.management.jmxremote.port=1808 \-Dcom.sun.management.jmxremote.rmi.port=1808 \-Dcom.sun.management.jmxremote.authenticate=false \-Dcom.sun.management.jmxremote.ssl=false \-Djava.rmi.server.hostname=192.168.6.203 \-jar ioms-ums.jar \--spring.profiles.active=dev</code></pre><p><em>注意：启动时，要在关闭用户校验的情况下启动JMX：<code>-Dcom.sun.management.jmxremote.authenticate=false</code>，并且添加参数 <code>-XX:+UnlockCommercialFeatures -XX:+FlightRecorder</code> 开启飞行记录仪；</em></p><p><strong>另外说明一点：</strong></p><p>这里需要注意的一点是，JMC可以用于java7以上的所有版本，而飞行记录器，只能用于oracle jre，且是java7及以上的版本，因为要使用飞行记录器，需要开启jvm的商业特性，也就是在启动的时候加上参数：”-XX:+UnlockCommercialFeatures”,”-XX:+FlightRecorder”。如果是open jdk，尝试加这两个参数的时候，会直接导致虚拟机终止，无法正常启动。所以，飞行记录器只能局限在oracle jdk里面使用。</p><p><strong>JMC连接监控进程</strong></p><p>文件 -&gt;连接 -&gt;创建新连接， 填入上面 JMX 参数的 host 和 port, 具体参考：第一章第3节：服务端开启远程监控</p><p><img src="https://raw.githubusercontent.com/GeorgeChan95/blogimg/master/img/2024/08/24/20240824-094752.png" alt="远程连接JMC"></p><p><img src="https://raw.githubusercontent.com/GeorgeChan95/blogimg/master/img/2024/08/24/20240824-095059.png" alt="连接JMC成功"></p><h2 id="5-Java-Flight-Recorder"><a href="#5-Java-Flight-Recorder" class="headerlink" title="5. Java Flight Recorder"></a>5. Java Flight Recorder</h2><p>Java Flight Recorder 是 JMC 的其中一个组件。</p><p>Java Flight Recorder 能够以极低的性能开销收集 Java 虚拟机的性能数据。</p><p>JFR 的性能开销很小，在默认配置下平均低于 1%。与其他工具相比，JFR 能够直接访问虚拟机内的数据，并且不会影响虚拟机的优化。因此，它非常适用于生产环境下满负荷运行的 Java 程序。</p><p>Java Flight Recorder 和 JDK Mission Control 共同创建了一个完整的工具链。JDKMission Control 可对 Java Flight Recorder 连续收集低水平和详细的运行时信息进行高效详细的分析。</p><h3 id="5-1-事件类型"><a href="#5-1-事件类型" class="headerlink" title="5.1 事件类型"></a>5.1 事件类型</h3><p>当启用时 JFR将记录运行过程中发生的一系列事件。其中包括Java层面的事件如线程事件、锁事件，以及Java虚拟机内部的事件，如新建对象，垃圾回收和即时编译事件。</p><p>按照发生时机以及持续时间来划分，JFR的事件共有四种类型，它们分别为以下四种：</p><ul><li>瞬时事件（Instant Event) ，用户关心的是它们发生与否，例如异常、线程启动事件。</li><li>持续事件(Duration Event) ，用户关心的是它们的持续时间，例如垃圾回收事件。</li><li>计时事件(Timed Event) ，是时长超出指定阈值的持续事件。</li><li>取样事件（Sample Event)，是周期性取样的事件。</li></ul><p>取样事件的其中一个常见例子便是方法抽样（Method Sampling），即每隔一段时问统计各个线程的栈轨迹。如果在这些抽样取得的栈轨迹中存在一个反复出现的方法，那么我们可以推测该方法是热点方法</p><h3 id="5-2-启动方式"><a href="#5-2-启动方式" class="headerlink" title="5.2 启动方式"></a>5.2 启动方式</h3><p><strong>方式1：使用 <code>-XX:StartFlightRecording=参数</code></strong></p><p>第一种是在运行目标 Java 程序时添加 <code>-XX:startFlightRecording=参数</code>。</p><p>比如: 下面命令中，JFR 将会在 Java 虚拟机启动 5s 后 (对应 <code>delay=5s</code>) 收集数据，持续 20s(对应 <code>duration=28s</code>)。当收集完毕后，JFR 会将收集得到的数据保存至指定的文件中(对应 <code>filename=myrecording.jfr</code>)</p><pre><code class="highlight shell">java -Xmx512m -Xms512m -Xmn512m \-XX:+UnlockCommercialFeatures -XX:+FlightRecorder \-XX:StartFlightRecording=delay=5s,duration=20s,filename=myrecording.jfr,settings=profile \-Dcom.sun.management.jmxremote \-Dcom.sun.management.jmxremote.port=1808 \-Dcom.sun.management.jmxremote.rmi.port=1808 \-Dcom.sun.management.jmxremote.authenticate=false \-Dcom.sun.management.jmxremote.ssl=false \-Djava.rmi.server.hostname=192.168.6.203 \-jar ioms-ums.jar \--spring.profiles.active=dev</code></pre><p>由于 JFR 将持续收集数据，如果不加以限制，那么 JFR 可能会填满硬盘的所有空间。因此，我们有必要对这种模式下所收集的数据进行限制。</p><p>比如:</p><pre><code class="highlight shell">java -Xmx512m -Xms512m -Xmn512m \-XX:+UnlockCommercialFeatures -XX:+FlightRecorder \-XX:StartFlightRecording=delay=5s,,duration=20s,maxage=10m,maxsize=100m,name=SomeLabel,filename=myrecording.jfr,settings=profile \-Dcom.sun.management.jmxremote \-Dcom.sun.management.jmxremote.port=1808 \-Dcom.sun.management.jmxremote.rmi.port=1808 \-Dcom.sun.management.jmxremote.authenticate=false \-Dcom.sun.management.jmxremote.ssl=false \-Djava.rmi.server.hostname=192.168.6.203 \-jar ioms-ums.jar \--spring.profiles.active=dev</code></pre><p><strong>方式2：使用 jcmd 的JFR.*子命令</strong></p><p>通过 jcmd 来让 JFR 开始收集数据、停止收集数据，或者保存所收集的数据，对应的子命令分别为JFR.start, JFR.stop，以及JFR.dump。</p><ul><li><p>启动java程序</p><pre><code class="highlight shell">java -Xmx512m -Xms512m -Xmn512m \-XX:+UnlockCommercialFeatures -XX:+FlightRecorder \-jar ioms-ums.jar \--spring.profiles.active=dev</code></pre></li><li><p>查看程序进程</p><pre><code class="highlight shell">root@ubuntu:/opt/module/ioms/ioms-ums# jps -l29318 ioms-gateway.jar29272 ioms-eureka.jar27116 ioms-ums.jar27228 sun.tools.jps.Jps29422 ioms-auth.ja</code></pre></li><li><p>通过jcmd来让 JFR 开始收集数据</p><pre><code class="highlight shell"><span class="meta prompt_">$ </span><span class="language-bash">jcmd &lt;PID&gt; JFR.start settings=profile maxage=10m maxsize=150m name=SomeLabel</span></code></pre><p>示例：</p><pre><code class="highlight shell">jcmd 27116 JFR.start settings=profile maxage=10m maxsize=100m name=test-jfr</code></pre><p><img src="https://raw.githubusercontent.com/GeorgeChan95/blogimg/master/img/2024/08/24/20240824-111447.png" alt="JFR 开始收集数据"></p></li><li><p>保存所收集的数据</p><pre><code class="highlight shell">jcmd &lt;PID&gt; JFR.dump name=SomeLabel filename=myrecording.jfr</code></pre><p>示例：</p><pre><code class="highlight shell">jcmd 27116 JFR.dump name=test-jfr filename=myrecording.jfr</code></pre><p><img src="https://raw.githubusercontent.com/GeorgeChan95/blogimg/master/img/2024/08/24/20240824-111612.png" alt="保存所收集的数据"></p></li><li><p>关闭目标进程中的 JFR</p><pre><code class="highlight shell"><span class="meta prompt_">$ </span><span class="language-bash">jcmd &lt;PID&gt; JFR.stop name=SomeLabel</span></code></pre><p>示例:</p><pre><code class="highlight shell">jcmd 27116 JFR.stop name=test-jfr</code></pre><p><img src="https://raw.githubusercontent.com/GeorgeChan95/blogimg/master/img/2024/08/24/20240824-111828.png" alt="关闭目标进程中的 JFR"></p></li></ul><p><strong>配置飞行记录仪监测</strong></p><ol><li>启动飞行记录仪</li></ol><p><img src="https://raw.githubusercontent.com/GeorgeChan95/blogimg/master/img/2024/08/24/20240824-112403.png" alt="启动飞行记录仪"></p><p><img src="https://raw.githubusercontent.com/GeorgeChan95/blogimg/master/img/2024/08/24/20240824-113110.png" alt="启动飞行记录仪"></p><p>2.正式启动</p><p><img src="https://raw.githubusercontent.com/GeorgeChan95/blogimg/master/img/2024/08/24/20240824-113329.png" alt="正式启动"></p><p>启动 Object Count 和 Object Count after GC </p><p><img src="https://raw.githubusercontent.com/GeorgeChan95/blogimg/master/img/2024/08/24/20240824-113508.png" alt="正式启动"></p><p><img src="https://raw.githubusercontent.com/GeorgeChan95/blogimg/master/img/2024/08/24/20240824-115346.png" alt="正式启动"></p><h3 id="5-3-Java-Flight-Recorder-取样分析"><a href="#5-3-Java-Flight-Recorder-取样分析" class="headerlink" title="5.3 Java Flight Recorder 取样分析"></a>5.3 Java Flight Recorder 取样分析</h3><p>要采用取样，必须先添加参数:</p><ul><li><code>-XX:+UnlockCommercialFeatures</code></li><li><code>-XX:+FlightRecorder</code></li></ul><p>JDK9及更高版本</p><ul><li><code>-XX:+UnlockCommercialFeatures</code></li><li><code>-XX:+StartFlightRecording</code></li></ul><p>如：<code>-XX:+UnlockCommercialFeatures -XX:+FlightRecorder -XX:StartFlightRecording=duration=200s</code></p><p>否则:</p><p><img src="https://raw.githubusercontent.com/GeorgeChan95/blogimg/master/img/2024/08/24/20240824-114008.png" alt="img"></p><p><img src="https://raw.githubusercontent.com/GeorgeChan95/blogimg/master/img/2024/08/24/20240824-114015.png" alt="img"></p><p>取样时间默认 1 分钟，可自行按需调整，事件设置选为profiling，然后可以设置取样 profile哪些信息，比如:</p><ul><li>加上对象数量的统计: Java Virtual Machine →→ Gc →→ Detailed →→ ObjectCount&#x2F;Object Count after GC</li><li>方法调用采样的间隔从 10ms 改为 1ms(但不能低于 1ms，否则会影响性能了): JavaVirtual Machine →→ Profiling →→ Method Profiling Sample&#x2F;Method SamplingInformation</li><li>Socket 与 File 采样，10ms 太久，但即使改为 1ms 也未必能抓住什么，可以干脆取消掉:Java Application →→ File Read&#x2F;FileWrite&#x2F;Socket Read&#x2F;Socket Write</li></ul><p><img src="https://raw.githubusercontent.com/GeorgeChan95/blogimg/master/img/2024/08/24/20240824-115458.png" alt="img"></p><p>然后就开始 Profile，到时间后 Profile 结束，会自动把记录下载回来，在 JMC 中展示。</p><p><img src="https://raw.githubusercontent.com/GeorgeChan95/blogimg/master/img/2024/08/24/20240824-120314.png" alt="JMC分析文件"></p><h1 id="八、其他工具"><a href="#八、其他工具" class="headerlink" title="八、其他工具"></a>八、其他工具</h1><h2 id="1-Flame-Graphs（火焰图）"><a href="#1-Flame-Graphs（火焰图）" class="headerlink" title="1. Flame Graphs（火焰图）"></a>1. Flame Graphs（火焰图）</h2><p>在追求极致性能的场景下，了解你的程序运行过程中cpu在干什么很重要，火焰图就是一种非常直观的展示CPU在程序整个生命周期过程中时间分配的工具。火焰图对于现代的程序员不应该陌生，这个工具可以非常直观的显示出调用找中的CPU消耗瓶颈。</p><p>网上的关于Java火焰图的讲解大部分来自于Brenden Gregg的博客 <a href="http://new.brendangregg.com/flamegraphs.html">http://new.brendangregg.com/flamegraphs.html</a></p><p><strong>CPU Flame Graphs</strong></p><p><img src="https://raw.githubusercontent.com/GeorgeChan95/blogimg/master/img/2024/08/24/20240824-120453.svg" alt="CPU Flame Graphs"></p><p>Memory Flame Graph</p><p><img src="https://raw.githubusercontent.com/GeorgeChan95/blogimg/master/img/2024/08/24/20240824-120514.svg" alt="Memory Flame Graph"></p><p>火焰图，简单通过x轴横条宽度来度量时间指标，y轴代表线程栈的层次。</p><h2 id="2-Tprofiler"><a href="#2-Tprofiler" class="headerlink" title="2. Tprofiler"></a>2. Tprofiler</h2><ul><li><p><strong>案例：</strong></p><p>使用 JDK 自身提供的工具进行 JVM 调优可以将下 TPS 由 2.5 提升到 20（提升了 7 倍），并准确 定位系统瓶颈。</p><p>系统瓶颈有：应用里释态对象不是太多、有大量的业务线程在频繁创建一些生命周期很长的临时对象，代码里有问题。</p><p>那么，如何在海量业务代码里边准确定位这些性能代码？这里使用阿里开源工具 Tprofiler 来定位 这些性能代码，成功解决掉了 GC 过于频繁的性能瓶预，并最终在上次优化的基础上将 TPS 再提升了 4 倍，即提升到 100。</p></li><li><p>Tprofiler 配置部署、远程操作、 日志阅谈都不太复杂，操作还是很简单的。但是其却是能够 起到一针见血、立竿见影的效果，帮我们解决了 GC 过于频繁的性能瓶预。</p></li><li><p>Tprofiler 最重要的特性就是能够统汁出你指定时间段内 JVM 的 top method 这些 top method 极有可能就是造成你 JVM 性能瓶颈的元凶。这是其他大多数 JVM 调优工具所不具备的，包括 JRockit Mission Control。JRokit 首席开发者 Marcus Hirt 在其私人博客《 Lom Overhead Method Profiling cith Java Mission Control》下的评论中曾明确指出 JRMC 井不支持 TOP 方法的统计。</p></li></ul><p>Github地址：<a href="http://github.com/alibaba/Tprofiler">http://github.com/alibaba/Tprofiler</a></p><h2 id="3-Btrace"><a href="#3-Btrace" class="headerlink" title="3. Btrace"></a>3. Btrace</h2><p>常见的动态追踪工具有BTrace、HouseHD（该项目己经停止开发）、Greys-Anatomy（国人开发 个人开发者）、Byteman（JBoss出品），注意Java运行时追踪工具井不限干这几种，但是这几个是相对比较常用的。</p><p>BTrace是SUN Kenai 云计算开发平台下的一个开源项目，旨在为java提供安全可靠的动态跟踪分析工具。先看一卜日Trace的官方定义：</p><blockquote><p>BTrace is a safe, dynamic tracing tool for the Java platform. BTrace can be used to dynamically trace a running Java program(similar to DTrace for OpenSolaris applications and 0s). BTrace dynamically instruments the classes of the target application to inject tracing code (“bytecode tracing” ).</p></blockquote><p>大概意思是一个 Java 平台的安全的动态追踪工具，可以用来动态地追踪一个运行的 Java 程序。BTrace动态调整目标应用程序的类以注入跟踪代码（“字节码跟踪“）。</p><h2 id="3-YourKit"><a href="#3-YourKit" class="headerlink" title="3. YourKit"></a>3. YourKit</h2><h2 id="4-JProbe"><a href="#4-JProbe" class="headerlink" title="4. JProbe"></a>4. JProbe</h2><h2 id="5-Spring-Insight"><a href="#5-Spring-Insight" class="headerlink" title="5. Spring Insight"></a>5. Spring Insight</h2>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;一、工具概述&quot;&gt;&lt;a href=&quot;#一、工具概述&quot; class=&quot;headerlink&quot; title=&quot;一、工具概述&quot;&gt;&lt;/a&gt;一、工具概述&lt;/h1&gt;&lt;p&gt;使用命令行工具或组合能帮您获取目标Java应用性能相关的基础信息，但它们存在下列局限：&lt;/p&gt;
&lt;ul&gt;
&lt;</summary>
      
    
    
    
    <category term="JVM" scheme="https://georgechan95.github.io/categories/JVM/"/>
    
    
    <category term="java" scheme="https://georgechan95.github.io/tags/java/"/>
    
    <category term="jvm" scheme="https://georgechan95.github.io/tags/jvm/"/>
    
  </entry>
  
  <entry>
    <title>第二十二章-JVM监控及诊断工具-命令行篇</title>
    <link href="https://georgechan95.github.io/blog/2165702380.html"/>
    <id>https://georgechan95.github.io/blog/2165702380.html</id>
    <published>2024-08-12T11:36:32.000Z</published>
    <updated>2024-08-28T04:17:33.351Z</updated>
    
    <content type="html"><![CDATA[<h1 id="一、概述"><a href="#一、概述" class="headerlink" title="一、概述"></a>一、概述</h1><p>性能诊断是软件工程师在日常工作中需要经常面对和解决的问题，在用户体验至上的今天，解决好应用的性能问题能带来非常大的收益。</p><p>Java 作为最流行的编程语言之一，其应用性能诊断一直受到业界广泛关注。可能造成 Java 应用出现性能问题的因素非常多，例如线程控制、磁盘读写、数据库访问、网络I&#x2F;O、垃圾收集等。想要定位这些问题，一款优秀的性能诊断工具必不可少。</p><h2 id="1-简单命令行工具"><a href="#1-简单命令行工具" class="headerlink" title="1. 简单命令行工具"></a>1. 简单命令行工具</h2><p>除了我们最了解的两个命令: javac，java 之外, 进入到安装jdk的bin目录，发现还有一系列辅助工具。这些辅助工具用来获取目标 JVM 不同方面、不同层次的信息，帮助开发人员很好地解决Java应用程序的一些疑难杂症。</p><p><img src="https://raw.githubusercontent.com/GeorgeChan95/blogimg/master/img/2024/08/12/20240812-194528.png" alt="mac系统jdk安装目录"></p><p><img src="https://raw.githubusercontent.com/GeorgeChan95/blogimg/master/img/2024/08/12/20240812-194744.png" alt="win下JDK安装目录"></p><p>官方源码地址：<a href="https://hg.openjdk.org/jdk/jdk11/file/1ddf9a99e4ad/src/jdk.jcmd/share/classes/sun/tools">https://hg.openjdk.org/jdk/jdk11/file/1ddf9a99e4ad/src/jdk.jcmd/share/classes/sun/tools</a></p><h1 id="二、jps：查看正在运行的Java进程"><a href="#二、jps：查看正在运行的Java进程" class="headerlink" title="二、jps：查看正在运行的Java进程"></a>二、jps：查看正在运行的Java进程</h1><p>jps (Java Process Status)：显示指定系统内所有的HotSpot虚拟机进程（查看虚拟机进程信息），可用于查询正在运行的虚拟机进程。</p><p>说明：对于本地虚拟机进程来说，进程的本地虚拟机ID与操作系统的进程ID是一致的，是唯一的。</p><p><strong>基本使用语法为：</strong><code>jps [options] [hostid]</code></p><p>我们还可以通过追加参数，来打印额外的信息。</p><h2 id="1-options参数"><a href="#1-options参数" class="headerlink" title="1. options参数"></a>1. options参数</h2><ul><li><p>-q：仅仅显示LVMID（local virtual machine id），即本地虚拟机唯一id。不显示主类的名称等</p></li><li><p>-l：输出应用程序主类的全类名 或 如果进程执行的是jar包，则输出jar完整路径</p></li><li><p>-m：输出虚拟机进程启动时传递给主类main()的参数</p></li><li><p>-v：列出虚拟机进程启动时的JVM参数。比如：-Xms20m -Xmx50m是启动程序指定的jvm参数。</p></li></ul><p>说明：以上参数可以综合使用。</p><p>补充：如果某 Java 进程关闭了默认开启的UsePerfData参数（即使用参数 <code>-XX：-UsePerfData</code>），那么jps命令（以及下面介绍的jstat）将无法探知该Java 进程。</p><p>解决Windows11下,  jps 命令无效的问题: <a href="https://blog.csdn.net/lingyiwin/article/details/123238600">https://blog.csdn.net/lingyiwin/article/details/123238600</a></p><h2 id="2-hostid参数"><a href="#2-hostid参数" class="headerlink" title="2. hostid参数"></a>2. hostid参数</h2><p>RMI注册表中注册的主机名。如果想要远程监控主机上的 java 程序，需要安装 <code>jstatd</code> 。</p><p>对于具有更严格的安全实践的网络场所而言，可能使用一个自定义的策略文件来显示对特定的可信主机或网络的访问，尽管这种技术容易受到IP地址欺诈攻击。</p><p>如果安全问题无法使用一个定制的策略文件来处理，那么最安全的操作是不运行jstatd服务器，而是在本地使用jstat和jps工具。</p><p>关于 jps [hostid] 的使用, 参考: <a href="https://www.cnblogs.com/keystone/p/10789382.html">https://www.cnblogs.com/keystone/p/10789382.html</a></p><h2 id="3-综合使用"><a href="#3-综合使用" class="headerlink" title="3. 综合使用"></a>3. 综合使用</h2><p><code>jps -l -m</code> 等价于 <code>jps -lm</code></p><p><strong>如何将信息输出到同级文件中：</strong><br><strong>语法：</strong>命令 &gt; 文件名称<br><strong>例如：</strong>jps -l &gt; a.txt</p><h1 id="三、jstat：查看JVM统计信息"><a href="#三、jstat：查看JVM统计信息" class="headerlink" title="三、jstat：查看JVM统计信息"></a>三、jstat：查看JVM统计信息</h1><p><code>jstat</code>（JVM Statistics Monitoring Tool）：用于监视虚拟机各种运行状态信息的命令行工具。它可以显示本地或者远程虚拟机进程中的类装载、内存、垃圾收集、JIT编译等运行数据。在没有GUI图形界面，只提供了纯文本控制台环境的服务器上，它将是运行期定位虚拟机性能问题的首选工具。常用于检测垃圾回收问题以及内存泄漏问题。</p><p><strong>官方文档：</strong><a href="https://docs.oracle.com/javase/8/docs/technotes/tools/unix/jstat.html">https://docs.oracle.com/javase/8/docs/technotes/tools/unix/jstat.html</a></p><p><strong>基本使用语法为：</strong> <code>jstat -&lt;option&gt; [-t] [-h&lt;lines&gt;] &lt;vmid&gt; [&lt;interval&gt; [&lt;count&gt;]]</code> </p><p><strong>查看命令相关参数：</strong>jstat -h  或  jstat -help</p><p><strong>查看options选项:</strong>   <code>jstat -options</code> </p><p>其中<strong>vmid是进程id号</strong>，也就是jps之后看到的前面的号码，如下：</p><p><img src="https://raw.githubusercontent.com/GeorgeChan95/blogimg/master/img/2024/08/14/20240814-121106.png" alt="image-20240814121104746"></p><h2 id="1-option参数"><a href="#1-option参数" class="headerlink" title="1. option参数"></a>1. option参数</h2><p>选项option可以由以下值构成。</p><p><strong>类装载相关的：</strong></p><ul><li>-class：显示ClassLoader的相关信息：类的装载、卸载数量、总空间、类装载所消耗的时间等</li></ul><p><strong>垃圾回收相关的：</strong></p><ul><li><p>-gc：显示与GC相关的堆信息。包括Eden区、两个Survivor区、老年代、永久代等的容量、已用空间、GC时间合计等信息。</p></li><li><p>-gccapacity：显示内容与-gc基本相同，但输出主要关注Java堆各个区域使用到的最大、最小空间。</p></li><li><p>-gcutil：显示内容与-gc基本相同，但输出主要关注已使用空间占总空间的百分比。</p></li><li><p>-gccause：与-gcutil功能一样，但是会额外输出导致最后一次或当前正在发生的GC产生的原因。</p></li><li><p>-gcnew：显示新生代GC状况</p></li><li><p>-gcnewcapacity：显示内容与-gcnew基本相同，输出主要关注使用到的最大、最小空间</p></li><li><p>-geold：显示老年代GC状况</p></li><li><p>-gcoldcapacity：显示内容与-gcold基本相同，输出主要关注使用到的最大、最小空间</p></li><li><p>-gcpermcapacity：显示永久代使用到的最大、最小空间。</p></li></ul><p><strong>JIT相关的：</strong></p><ul><li><p>-compiler：显示JIT编译器编译过的方法、耗时等信息</p></li><li><p>-printcompilation：输出已经被JIT编译的方法</p></li></ul><h3 id="2-使用示例"><a href="#2-使用示例" class="headerlink" title="2. 使用示例"></a>2. 使用示例</h3><h4 id="class"><a href="#class" class="headerlink" title="-class"></a>-class</h4><p><strong>jstat -class -t -h5 29544 1000 10</strong> </p><p>其中h5中的5代表每隔5个分隔一次，29544 代表类的进程id，1000代表每隔1000毫秒打印一次，10代表一共打印10次，如下所示：</p><p><img src="https://raw.githubusercontent.com/GeorgeChan95/blogimg/master/img/2024/08/15/20240815-173507.png" alt="-class"></p><p>以下是输出结果中每个参数的含义：</p><ol><li><strong>Timestamp</strong>: 运行时的时间戳，单位为秒，表示自 JVM 启动以来的时间。通过这个时间戳可以了解当前统计数据是在 JVM 运行多长时间之后获取的。在你的输出中，时间戳分别为 <code>13.1</code>, <code>14.1</code>, <code>15.1</code> 等。</li><li><strong>Loaded</strong>: 已加载的类的数量。这里显示的是自 JVM 启动以来，JVM 加载到内存中的类的总数。在输出中，<code>Loaded</code> 的值始终为 <code>610</code>，表示在每个采样点 JVM 中已加载了 610 个类。</li><li><strong>Bytes</strong>: 已加载的类所占用的内存空间大小，单位为 KB。在输出中，<code>Bytes</code> 的值始终为 <code>1234.0</code> KB，表示 JVM 中已加载的类占用了 1234 KB 的内存空间。</li><li><strong>Unloaded</strong>: 自 JVM 启动以来，已卸载的类的数量。在你的输出中，<code>Unloaded</code> 的值始终为 <code>0</code>，表示没有卸载过任何类。</li><li><strong>Bytes</strong>: 已卸载的类释放的内存空间大小，单位为 KB。因为没有类被卸载，所以这个值始终为 <code>0.0</code> KB。</li><li><strong>Time</strong>: JVM 在类加载和卸载上所花费的总时间，单位为秒。这里的 <code>Time</code> 值为 <code>0.05</code> 秒，表示 JVM 在处理类加载和卸载操作上总共花费了 0.05 秒。</li></ol><h4 id="gc"><a href="#gc" class="headerlink" title="-gc"></a>-gc</h4><p><strong>jstat -gc -t -h5 28100 1000 10</strong></p><p>其中h5中的5代表每隔5个分隔一次，28100 代表类的进程id，1000代表每隔1000毫秒打印一次，10代表一共打印10次，如下所示：</p><p><img src="https://raw.githubusercontent.com/GeorgeChan95/blogimg/master/img/2024/08/15/20240815-173658.png" alt="-gc"></p><p>以下是每个参数的含义和解释：</p><ol><li><strong>Timestamp</strong>: 运行时的时间戳，单位为秒，表示自 JVM 启动以来的时间。在你的输出中，时间戳分别为 <code>12.7</code>, <code>13.7</code>, <code>14.7</code> 等。</li><li><strong>S0C</strong> (Survivor Space 0 Capacity): 新生代中第一个存活区（Survivor 0 区）的容量，单位为 KB。在你的输出中，<code>S0C</code> 的值始终为 <code>2048.0</code> KB，表示 Survivor 0 区的容量为 2048 KB。</li><li><strong>S1C</strong> (Survivor Space 1 Capacity): 新生代中第二个存活区（Survivor 1 区）的容量，单位为 KB。<code>S1C</code> 的值也为 <code>2048.0</code> KB，表示 Survivor 1 区的容量为 2048 KB。</li><li><strong>S0U</strong> (Survivor Space 0 Utilization): 新生代中第一个存活区（Survivor 0 区）的使用量，单位为 KB。在输出中，<code>S0U</code> 的值大部分时间为 <code>0.0</code>，表示 Survivor 0 区未被使用。</li><li><strong>S1U</strong> (Survivor Space 1 Utilization): 新生代中第二个存活区（Survivor 1 区）的使用量，单位为 KB。在第一个时间戳中，<code>S1U</code> 的值为 <code>0.0</code>，表示未使用。在后续时间戳中，<code>S1U</code> 的值为 <code>2024.3</code> KB，表示 Survivor 1 区几乎已满。</li><li><strong>EC</strong> (Eden Space Capacity): Eden 区的容量，单位为 KB。<code>EC</code> 的值为 <code>16384.0</code> KB，表示 Eden 区的容量为 16384 KB。</li><li><strong>EU</strong> (Eden Space Utilization): Eden 区的使用量，单位为 KB。随着时间的推移，<code>EU</code> 的值从 <code>13888.0</code> KB 增加到 <code>5002.0</code> KB，表示 Eden 区的使用情况逐渐变化。</li><li><strong>OC</strong> (Old Generation Capacity): 老年代的容量，单位为 KB。<code>OC</code> 的值为 <code>40960.0</code> KB，表示老年代的容量为 40960 KB。</li><li><strong>OU</strong> (Old Generation Utilization): 老年代的使用量，单位为 KB。最初 <code>OU</code> 的值为 <code>0.0</code> KB，但在时间戳 <code>15.7</code> 之后变为 <code>11817.8</code> KB，表示部分对象被移入了老年代。</li><li><strong>MC</strong> (Metaspace Capacity): 元空间的容量，单位为 KB。<code>MC</code> 的值为 <code>4480.0</code> KB，后续增加到 <code>4864.0</code> KB，表示元空间的容量略有增加。</li><li><strong>MU</strong> (Metaspace Utilization): 元空间的使用量，单位为 KB。<code>MU</code> 的值从 <code>776.8</code> KB 增加到 <code>3743.2</code> KB，表示元空间的使用情况变化较大。</li><li><strong>CCSC</strong> (Compressed Class Space Capacity): 压缩类空间的容量，单位为 KB。<code>CCSC</code> 的值最初为 <code>384.0</code> KB，随后增加到 <code>512.0</code> KB，表示压缩类空间的容量有所增加。</li><li><strong>CCSU</strong> (Compressed Class Space Utilization): 压缩类空间的使用量，单位为 KB。<code>CCSU</code> 的值从 <code>76.6</code> KB 增加到 <code>409.7</code> KB，表示压缩类空间的使用情况变化较大。</li><li><strong>YGC</strong> (Young Generation GC Events): 新生代 GC（Minor GC）的次数。<code>YGC</code> 的值最初为 <code>0</code>，随后增加到 <code>1</code>，表示发生了一次 Minor GC。</li><li><strong>YGCT</strong> (Young Generation GC Time): 新生代 GC 总时间，单位为秒。<code>YGCT</code> 的值从 <code>0.000</code> 秒增加到 <code>0.007</code> 秒，表示 Minor GC 总共花费了 0.007 秒。</li><li><strong>FGC</strong> (Full GC Events): Full GC（涉及整个堆的 GC） 的次数。在输出中，<code>FGC</code> 的值为 <code>0</code>，表示未发生过 Full GC。</li><li><strong>FGCT</strong> (Full GC Time): Full GC 总时间，单位为秒。<code>FGCT</code> 的值为 <code>0.000</code> 秒，表示 Full GC 总共花费了 0 秒。</li><li><strong>GCT</strong> (Total GC Time): GC 总时间，单位为秒，包含 Minor GC 和 Full GC 的时间。<code>GCT</code> 的值从 <code>0.000</code> 秒增加到 <code>0.007</code> 秒，表示 GC 总时间为 0.007 秒。</li></ol><h4 id="gccapacity"><a href="#gccapacity" class="headerlink" title="-gccapacity"></a>-gccapacity</h4><p><code>jstat -gccapacity 3060</code>，其中 3060 代表类的进程id，执行结果如下：</p><p><img src="https://raw.githubusercontent.com/GeorgeChan95/blogimg/master/img/2024/08/15/20240815-170535.png" alt="-gccapacity"></p><p>以下是每个参数的含义：</p><ol><li><strong>NGCMN</strong> (Minimum New Generation Capacity): 新生代内存区域的最小容量。</li><li><strong>NGCMX</strong> (Maximum New Generation Capacity): 新生代内存区域的最大容量。</li><li><strong>NGC</strong> (Current New Generation Capacity): 新生代内存区域的当前容量。</li><li><strong>S0C</strong> (Current Survivor Space 0 Capacity): 新生代中第一个存活区的当前容量。</li><li><strong>S1C</strong> (Current Survivor Space 1 Capacity): 新生代中第二个存活区的当前容量。</li><li><strong>EC</strong> (Current Eden Space Capacity): Eden 区的当前容量。Eden 区是新对象首先分配内存的地方。</li><li><strong>OGCMN</strong> (Minimum Old Generation Capacity): 老年代内存区域的最小容量。</li><li><strong>OGCMX</strong> (Maximum Old Generation Capacity): 老年代内存区域的最大容量。</li><li><strong>OGC</strong> (Current Old Generation Capacity): 老年代内存区域的当前容量。</li><li><strong>OC</strong> (Current Old Space Capacity): 老年代的当前容量，通常等同于 OGC。</li><li><strong>MCMN</strong> (Minimum Metaspace Capacity): 元空间的最小容量（元空间用于存储类元数据）。</li><li><strong>MCMX</strong> (Maximum Metaspace Capacity): 元空间的最大容量。</li><li><strong>MC</strong> (Current Metaspace Capacity): 元空间的当前容量。</li><li><strong>CCSMN</strong> (Minimum Compressed Class Space Capacity): 压缩类空间的最小容量。压缩类空间用于存储类的相关元数据（如果开启了类元数据的压缩）。</li><li><strong>CCSMX</strong> (Maximum Compressed Class Space Capacity): 压缩类空间的最大容量。</li><li><strong>CCSC</strong> (Current Compressed Class Space Capacity): 压缩类空间的当前容量。</li><li><strong>YGC</strong> (Number of Young Generation GC Events): 新生代 GC（通常称为 Minor GC）的次数。</li><li><strong>FGC</strong> (Number of Full GC Events): Full GC（涉及整个堆的 GC） 的次数。</li></ol><h4 id="gcutil"><a href="#gcutil" class="headerlink" title="-gcutil"></a>-gcutil</h4><p><code>jstat -gcutil 33520</code>，其中13152代表类的进程id，执行结果如下所示：</p><p><img src="https://raw.githubusercontent.com/GeorgeChan95/blogimg/master/img/2024/08/15/20240815-172341.png" alt="-gcutil"></p><p>以下是每个参数的含义：</p><ol><li><strong>S0</strong> (Survivor Space 0 Utilization): 新生代中第一个存活区（Survivor 0 区）的使用率（百分比）。在这个例子中，<code>S0</code> 的值为 <code>0.00</code>，表示 Survivor 0 区未被使用。</li><li><strong>S1</strong> (Survivor Space 1 Utilization): 新生代中第二个存活区（Survivor 1 区）的使用率（百分比）。<code>S1</code> 的值为 <code>0.00</code>，表示 Survivor 1 区未被使用。</li><li><strong>E</strong> (Eden Space Utilization): Eden 区的使用率（百分比）。<code>E</code> 的值为 <code>81.10</code>，表示 Eden 区的 81.10% 被使用。</li><li><strong>O</strong> (Old Generation Utilization): 老年代的使用率（百分比）。<code>O</code> 的值为 <code>0.00</code>，表示老年代未被使用。</li><li><strong>M</strong> (Metaspace Utilization): 元空间的使用率（百分比）。<code>M</code> 的值为 <code>17.34</code>，表示元空间的 17.34% 被使用。</li><li><strong>CCS</strong> (Compressed Class Space Utilization): 压缩类空间的使用率（百分比）。<code>CCS</code> 的值为 <code>19.94</code>，表示压缩类空间的 19.94% 被使用。</li><li><strong>YGC</strong> (Number of Young Generation GC Events): 新生代 GC（Minor GC）的次数。<code>YGC</code> 的值为 <code>0</code>，表示未发生过 Minor GC。</li><li><strong>YGCT</strong> (Young Generation GC Time): 新生代 GC 总时间（以秒为单位）。<code>YGCT</code> 的值为 <code>0.000</code>，表示 Minor GC 消耗的总时间为 0 秒。</li><li><strong>FGC</strong> (Number of Full GC Events): Full GC（涉及整个堆的 GC） 的次数。<code>FGC</code> 的值为 <code>0</code>，表示未发生过 Full GC。</li><li><strong>FGCT</strong> (Full GC Time): Full GC 总时间（以秒为单位）。<code>FGCT</code> 的值为 <code>0.000</code>，表示 Full GC 消耗的总时间为 0 秒。</li><li><strong>GCT</strong> (Total GC Time): GC 总时间（以秒为单位），包括所有 Minor GC 和 Full GC 的时间。<code>GCT</code> 的值为 <code>0.000</code>，表示 GC 总时间为 0 秒。</li></ol><h4 id="gccause"><a href="#gccause" class="headerlink" title="-gccause"></a>-gccause</h4><p><code>jstat -gccause 9180</code>，其中 9180 代表类的进程id，执行结果如下：</p><p><img src="https://raw.githubusercontent.com/GeorgeChan95/blogimg/master/img/2024/08/15/20240815-172707.png" alt="-gccause"></p><p>以下是每个参数的含义：</p><ol><li><strong>S0</strong> (Survivor Space 0 Utilization): 新生代中第一个存活区（Survivor 0 区）的使用率（百分比）。在这个例子中，<code>S0</code> 的值为 <code>0.00</code>，表示 Survivor 0 区未被使用。</li><li><strong>S1</strong> (Survivor Space 1 Utilization): 新生代中第二个存活区（Survivor 1 区）的使用率（百分比）。<code>S1</code> 的值为 <code>0.00</code>，表示 Survivor 1 区未被使用。</li><li><strong>E</strong> (Eden Space Utilization): Eden 区的使用率（百分比）。<code>E</code> 的值为 <code>66.45</code>，表示 Eden 区的 66.45% 被使用。</li><li><strong>O</strong> (Old Generation Utilization): 老年代的使用率（百分比）。<code>O</code> 的值为 <code>0.00</code>，表示老年代未被使用。</li><li><strong>M</strong> (Metaspace Utilization): 元空间的使用率（百分比）。<code>M</code> 的值为 <code>17.34</code>，表示元空间的 17.34% 被使用。</li><li><strong>CCS</strong> (Compressed Class Space Utilization): 压缩类空间的使用率（百分比）。<code>CCS</code> 的值为 <code>19.94</code>，表示压缩类空间的 19.94% 被使用。</li><li><strong>YGC</strong> (Number of Young Generation GC Events): 新生代 GC（Minor GC）的次数。<code>YGC</code> 的值为 <code>0</code>，表示未发生过 Minor GC。</li><li><strong>YGCT</strong> (Young Generation GC Time): 新生代 GC 总时间（以秒为单位）。<code>YGCT</code> 的值为 <code>0.000</code>，表示 Minor GC 消耗的总时间为 0 秒。</li><li><strong>FGC</strong> (Number of Full GC Events): Full GC（涉及整个堆的 GC） 的次数。<code>FGC</code> 的值为 <code>0</code>，表示未发生过 Full GC。</li><li><strong>FGCT</strong> (Full GC Time): Full GC 总时间（以秒为单位）。<code>FGCT</code> 的值为 <code>0.000</code>，表示 Full GC 消耗的总时间为 0 秒。</li><li><strong>GCT</strong> (Total GC Time): GC 总时间（以秒为单位），包括所有 Minor GC 和 Full GC 的时间。<code>GCT</code> 的值为 <code>0.000</code>，表示 GC 总时间为 0 秒。</li><li><strong>LGCC</strong> (Last GC Cause): 最近一次 GC 发生的原因。<code>LGCC</code> 的值为 <code>Allocation Failure</code>，表示最近一次 GC 是由于内存分配失败（即 Eden 空间不足以容纳新对象）而触发的。</li><li><strong>GCC</strong> (Current GC Cause): 当前 GC 发生的原因。如果当前正在进行 GC，该值会显示触发 GC 的原因。<code>GCC</code> 的值为 <code>No GC</code>，表示当前没有 GC 正在进行。</li></ol><h2 id="2-interval参数"><a href="#2-interval参数" class="headerlink" title="2. interval参数"></a>2. interval参数</h2><p>用于指定输出统计数据的周期，单位为毫秒。即：查询间隔</p><h2 id="3-count参数"><a href="#3-count参数" class="headerlink" title="3. count参数"></a>3. count参数</h2><p> 用于指定查询的总次数</p><h2 id="4-t参数"><a href="#4-t参数" class="headerlink" title="4. -t参数"></a>4. -t参数</h2><p>可以在输出信息前加上一个Timestamp列，显示程序的运行时间。单位：秒</p><h2 id="5-h参数"><a href="#5-h参数" class="headerlink" title="5. -h参数"></a>5. -h参数</h2><p>可以在周期性数据输出时，输出多少行数据后输出一个表头信息</p><h2 id="补充"><a href="#补充" class="headerlink" title="补充"></a>补充</h2><p>jstat还可以用来判断是否出现内存泄漏。</p><p>第1步：在长时间运行的 Java 程序中，我们可以运行jstat命令连续获取多行性能数据，并取这几行数据中 OU 列（即已占用的老年代内存）的最小值。</p><p>第2步：然后，我们每隔一段较长的时间重复一次上述操作，来获得多组 OU 最小值。如果这些值呈上涨趋势，则说明该 Java 程序的老年代内存已使用量在不断上涨，这意味着无法回收的对象在不断增加，因此很有可能存在内存泄漏。</p><h1 id="四、jinfo：实时查看和修改JVM配置参数"><a href="#四、jinfo：实时查看和修改JVM配置参数" class="headerlink" title="四、jinfo：实时查看和修改JVM配置参数"></a>四、jinfo：实时查看和修改JVM配置参数</h1><p>jinfo(Configuration Info for Java)：查看虚拟机配置参数信息，也可用于调整虚拟机的配置参数。在很多情况下，Java应用程序不会指定所有的Java虚拟机参数。而此时，开发人员可能不知道某一个具体的Java虚拟机参数的默认值。在这种情况下，可能需要通过查找文档获取某个参数的默认值。这个查找过程可能是非常艰难的。但有了jinfo工具，开发人员可以很方便地找到Java虚拟机参数的当前值。</p><p><strong>基本使用语法为：jinfo [options] pid</strong></p><p>说明：java 进程ID必须要加上</p><table><thead><tr><th>选项</th><th>选项说明</th></tr></thead><tbody><tr><td>no option</td><td>输出全部的参数和系统属性</td></tr><tr><td>-flag name</td><td>输出对应名称的参数</td></tr><tr><td>-flag [+-]name</td><td>开启或者关闭对应名称的参数 只有被标记为manageable的参数才可以被动态修改</td></tr><tr><td>-flag name&#x3D;value</td><td>设定对应名称的参数</td></tr><tr><td>-flags</td><td>输出全部的参数</td></tr><tr><td>-sysprops</td><td>输出系统属性</td></tr></tbody></table><p><strong>官方帮助文档:</strong> <a href="https://docs.oracle.com/en/java/javase/11/tools/jinfo.html">https://docs.oracle.com/en/java/javase/11/tools/jinfo.html</a></p><h2 id="1-jinfo-sysprops-pid-输出系统属性"><a href="#1-jinfo-sysprops-pid-输出系统属性" class="headerlink" title="1. jinfo -sysprops pid 输出系统属性"></a>1. jinfo -sysprops pid 输出系统属性</h2><p><strong>jinfo -sysprops 2176</strong></p><p>2176 是通过 jps 指令查询的 java 进程ID, jinfo -sysprops pid 可以查看由 <code>System.getProperties()</code> 取得的参数</p><p><img src="https://raw.githubusercontent.com/GeorgeChan95/blogimg/master/img/2024/08/15/20240815-184047.png" alt="-sysprops"></p><h2 id="2-jinfo-flags-pid-输出全部的参数"><a href="#2-jinfo-flags-pid-输出全部的参数" class="headerlink" title="2. jinfo -flags pid 输出全部的参数"></a>2. jinfo -flags pid 输出全部的参数</h2><p><strong>jinfo -flags 25244</strong></p><p>25244 是通过 jps 指令查询的 java 进程ID, <code>jinfo -flags pid</code> 可以查看当前进程JVM赋了值的参数信息.</p><p><img src="https://raw.githubusercontent.com/GeorgeChan95/blogimg/master/img/2024/08/15/20240815-184848.png" alt="-flags"></p><h2 id="3-jinfo-flag-参数-pid-查看某个java进程的具体参数信息"><a href="#3-jinfo-flag-参数-pid-查看某个java进程的具体参数信息" class="headerlink" title="3. jinfo -flag 参数 pid 查看某个java进程的具体参数信息"></a>3. jinfo -flag 参数 pid 查看某个java进程的具体参数信息</h2><p><strong>jinfo -flag UseG1GC 24340</strong></p><p>其中: <code>UseG1GC</code> 是要查看的具体的参数, 24340 是通过 jps 指令查询的 java 进程ID</p><p><img src="https://raw.githubusercontent.com/GeorgeChan95/blogimg/master/img/2024/08/15/20240815-185233.png" alt="-flag param"></p><h2 id="4-jinfo-flag-name-pid-修改参数信息"><a href="#4-jinfo-flag-name-pid-修改参数信息" class="headerlink" title="4. jinfo -flag [+-]name pid 修改参数信息"></a>4. jinfo -flag [+-]name pid 修改参数信息</h2><p>jinfo不仅可以查看运行时某一个]ava虚拟机参数的实际取值，甚至可以在运行时修改部分参数，并使之立即生效。</p><p>但是，并非所有参数都支持动态修改。参数只有被标记为 <code>manageable</code> 的 flag 可以被实时修改。其实，这个修改能力是极其有限的。</p><h3 id="4-1-查看被标记为manageable的参数"><a href="#4-1-查看被标记为manageable的参数" class="headerlink" title="4.1 查看被标记为manageable的参数"></a>4.1 查看被标记为manageable的参数</h3><pre><code class="highlight shell">root@ubuntu:~# java -XX:+PrintFlagsFinal -version | grep manageable     intx CMSAbortablePrecleanWaitMillis            = 100                                 &#123;manageable&#125;     intx CMSTriggerInterval                        = -1                                  &#123;manageable&#125;     intx CMSWaitDuration                           = 2000                                &#123;manageable&#125;     bool HeapDumpAfterFullGC                       = false                               &#123;manageable&#125;     bool HeapDumpBeforeFullGC                      = false                               &#123;manageable&#125;     bool HeapDumpOnOutOfMemoryError                = false                               &#123;manageable&#125;    ccstr HeapDumpPath                              =                                     &#123;manageable&#125;    uintx MaxHeapFreeRatio                          = 100                                 &#123;manageable&#125;    uintx MinHeapFreeRatio                          = 0                                   &#123;manageable&#125;     bool PrintClassHistogram                       = false                               &#123;manageable&#125;     bool PrintClassHistogramAfterFullGC            = false                               &#123;manageable&#125;     bool PrintClassHistogramBeforeFullGC           = false                               &#123;manageable&#125;     bool PrintConcurrentLocks                      = false                               &#123;manageable&#125;     bool PrintGC                                   = false                               &#123;manageable&#125;     bool PrintGCDateStamps                         = false                               &#123;manageable&#125;     bool PrintGCDetails                            = false                               &#123;manageable&#125;     bool PrintGCID                                 = false                               &#123;manageable&#125;     bool PrintGCTimeStamps                         = false                               &#123;manageable&#125;java version &quot;1.8.0_261&quot;Java(TM) SE Runtime Environment (build 1.8.0_261-b12)Java HotSpot(TM) 64-Bit Server VM (build 25.261-b12, mixed mode)</code></pre><h3 id="4-2-针对boolean类型的修改"><a href="#4-2-针对boolean类型的修改" class="headerlink" title="4.2 针对boolean类型的修改"></a>4.2 针对boolean类型的修改</h3><p>jinfo -flag [+|-]参数名称 进程id</p><p>PID可以通过jps命令查看，如果使用+号，那就可以让该参数起作用，否则使用-号就让该参数不起作用，具体例子如下：</p><p><img src="https://raw.githubusercontent.com/GeorgeChan95/blogimg/master/img/2024/08/15/20240815-192843.png" alt="-flag boolean类型"></p><p><em>PrintGCDetails 参数用于控制垃圾回收 (GC) 详情的输出</em></p><h3 id="4-3-针对非boolean类型的修改"><a href="#4-3-针对非boolean类型的修改" class="headerlink" title="4.3 针对非boolean类型的修改"></a>4.3 针对非boolean类型的修改</h3><p>jinfo -flag 参数名称&#x3D;参数值 进程id</p><p>PID可以通过jps命令查看，如果使用+号，那就可以让该参数起作用，否则使用-号就让该参数不起作用，具体例子如下：</p><p><img src="https://raw.githubusercontent.com/GeorgeChan95/blogimg/master/img/2024/08/15/20240815-193525.png" alt="-flag 非boolean类型"></p><p><em>MaxHeapFreeRatio 定义了堆内存中空闲内存的最大百分比。当堆内存的空闲比例超过此值时，JVM可能会考虑缩小堆的大小。默认值通常为70%，意味着当超过70%的堆空闲时，JVM会尝试减小堆大小。（当-Xmx与-Xms相等时，该配置无效）</em></p><h2 id="5-拓展"><a href="#5-拓展" class="headerlink" title="5. 拓展"></a>5. 拓展</h2><ul><li><p><code>java -XX:+PrintFlagsInitial</code> 查看所有JVM参数启动的初始值</p><p><img src="https://raw.githubusercontent.com/GeorgeChan95/blogimg/master/img/2024/08/15/20240815-195517.png" alt="-XX:+PrintFlagsInitial"></p><p><strong>在编译后的class文件夹下执行</strong></p></li><li><p><code>java -XX:+PrintFlagsFinal</code> 查看所有JVM参数的最终值</p><ul><li>java -XX:+UseSerialGC -XX:+PrintFlagsFinal com.atguigu.jstat.GCTest <ul><li>这个命令会启动 JVM，并使用 Serial GC 进行垃圾回收，同时打印出所有 JVM 参数的最终配置。然后 JVM 会执行 <code>com.atguigu.jstat.GCTest</code> 类中的 <code>main</code> 方法。</li></ul></li></ul><p><img src="https://raw.githubusercontent.com/GeorgeChan95/blogimg/master/img/2024/08/15/20240815-195355.png" alt="-XX:+PrintFlagsFinal"></p><p><strong>在编译后的class文件夹下执行</strong></p></li><li><p>java -XX:+PrintCommandLineFlags 查看那些已经被用户或者JVM设置过的详细的XX参数的名称和值</p><ul><li><p>java -XX:+UseSerialGC -XX:+PrintCommandLineFlags com.atguigu.jstat.GCTest</p><ul><li>这个命令启动 JVM，并使用 Serial 垃圾回收器，同时在启动时打印出所有命令行标志。随后，JVM 会执行 <code>com.atguigu.jstat.GCTest</code> 类中的 <code>main</code> 方法。</li></ul><p><img src="https://raw.githubusercontent.com/GeorgeChan95/blogimg/master/img/2024/08/15/20240815-195141.png" alt="+PrintCommandLineFlags"></p><p><strong>在编译后的class文件夹下执行</strong></p></li></ul></li></ul><h1 id="五、jmap：导出内存映像文件-内存使用情况"><a href="#五、jmap：导出内存映像文件-内存使用情况" class="headerlink" title="五、jmap：导出内存映像文件&amp;内存使用情况"></a>五、jmap：导出内存映像文件&amp;内存使用情况</h1><h2 id="1-简述"><a href="#1-简述" class="headerlink" title="1. 简述"></a>1. 简述</h2><p>jmap（JVM Memory Map）：作用一方面是获取dump文件（堆转储快照文件，二进制文件），它还可以获取目标Java进程的内存相关信息，包括Java堆各区域的使用情况、堆中对象的统计信息、类加载信息等。开发人员可以在控制台中输入命令“ jmap -help ”查阅 jmap 工具的具体使用方式和一些标准选项配置。</p><ul><li><p><strong>官方帮助文档：</strong><a href="https://docs.oracle.com/en/java/javase/11/tools/jmap.html">https://docs.oracle.com/en/java/javase/11/tools/jmap.html</a></p></li><li><p><strong>基本使用语法</strong>：</p><ul><li><p><code>jmap [option] &lt;pid&gt;</code></p></li><li><p><code>jmap [option] &lt;executable &lt;core&gt;</code></p></li><li><p><code>jmap [option] [server_id@] &lt;remote server IP or hostname&gt;</code></p></li></ul></li></ul><h2 id="2-基本语法"><a href="#2-基本语法" class="headerlink" title="2. 基本语法"></a>2. 基本语法</h2><ul><li>-dump<ul><li>生成Java堆转储快照：dump文件</li></ul></li><li>-dump:live<ul><li>生成Java堆转储快照：dump文件, 但只保存堆中的存活对象</li><li>相较于 <code>-dump</code> , 文件体积会小一些</li></ul></li><li>-heap<ul><li>输出整个堆空间的详细信息，包括GC的使用、堆配置信息，以及内存的使用信息等</li></ul></li><li>-histo<ul><li>输出堆中对象的同级信息，包括类、实例数量和合计容量</li><li>特别的：-histo:live 只统计堆中的存活对象</li></ul></li><li>-histo:live<ul><li>输出堆中对象的同级信息，包括类、实例数量和合计容量, 但是只统计堆中的存活对象</li></ul></li><li>-permstat<ul><li>以ClassLoader 为统计口径输出永久代的内存状态信息</li><li>仅 linux&#x2F;solaris 平台有效</li></ul></li><li>-finalizerinfo<ul><li>显示在 F-Queue 中等待 Finalizer 线程执行 finalize 方法的对象</li><li>仅linux&#x2F;solaris平台有效</li></ul></li><li>-F<ul><li>当虚拟机进程对-dump选项没有任何响应时，可使用此选项强制执行生成dump文件</li><li>仅linux&#x2F;solaris平台有效</li></ul></li><li>-h | -help<ul><li>jamp工具使用的帮助命令</li></ul></li><li>-J <flag><ul><li>传递参数给 jmap 启动的 jvm</li></ul></li></ul><h2 id="3-导出内存映像文件"><a href="#3-导出内存映像文件" class="headerlink" title="3. 导出内存映像文件"></a>3. 导出内存映像文件</h2><h3 id="3-1-手动导出"><a href="#3-1-手动导出" class="headerlink" title="3.1 手动导出"></a>3.1 手动导出</h3><p><code>jmap -dump:format=b,file=&lt;filename.hprof&gt; &lt;pid&gt;</code></p><p><strong>说明:</strong></p><ul><li><code>&lt;filename.hprof&gt;</code> 中的filename是文件名称，而 <code>.hprof</code> 是后缀名，&lt;***&gt;代表该值可以省略&lt;&gt;，当然后面的 <pid> 是进程id，需要通过jps查询出来</li><li><code>format=b</code> 表示生成的是标准的dump文件，用来进行格式限定</li></ul><p><strong>具体例子如下：</strong></p><ul><li><p>生成堆中所有对象的快照：</p><p><strong>jmap -dump:format&#x3D;b,file&#x3D;d:\1.hprof 22096</strong></p></li></ul><p><img src="https://raw.githubusercontent.com/GeorgeChan95/blogimg/master/img/2024/08/16/20240816-082026.png" alt="-dump"></p><ul><li><p>生成堆中存活对象的快照：</p><p>jmap -dump:live,format&#x3D;b,file&#x3D;d:\2.hprof 22012</p><p><img src="https://raw.githubusercontent.com/GeorgeChan95/blogimg/master/img/2024/08/16/20240816-082159.png" alt="-dump:live"></p></li></ul><p><strong>其中 <code>file=</code> 后面的是生成的dump文件地址，最后的11696 是进程id，可以通过jps查看</strong></p><p><img src="https://raw.githubusercontent.com/GeorgeChan95/blogimg/master/img/2024/08/16/20240816-083214.png" alt="导出的dump文件"></p><p>一般使用的是第二种方式，也就是生成堆中存活对象的快照，毕竟这种方式生成的dump文件更小，我们传输处理都更方便</p><p>由于jmap将访问堆中的所有对象，为了保证在此过程中不被应用线程干扰，jmap需要借助安全点机制，让所有线程停留在不改变堆中数据的状态。也就是说，由jmap导出的堆快照必定是安全点位置的。这可能导致基于该堆快照的分析结果存在偏差。<br>举个例子，假设在编译生成的机器码中，某些对象的生命周期在两个安全点之间，那么:1ive选项将无法探知到这些对象。<br>另外，如果某个线程长时间无法跑到安全点，jmap将一直等下去。与前面讲的jstat则不同垃圾回收器会主动将jstat所需要的摘要数据保存至固定位置之中，而jstat只需直接读取即可。</p><h3 id="3-2-自动导出"><a href="#3-2-自动导出" class="headerlink" title="3.2 自动导出"></a>3.2 自动导出</h3><p>当程序发生OOM退出系统时，一些瞬时信息都随着程序的终止而消失，而重现OOM问题往往比较困难或者耗时。此时若能在OOM时，自动导出dump文件就显得非常迫切。</p><p>这里介绍一种比较常用的取得堆快照文件的方法，即使用:</p><ul><li><code>-XX:+HeapDumpOn0utOfMemoryError</code> : 在程序发生OOM时，导出应用程序的当前堆快照。</li><li><code>-XX:HeapDumpPath</code> : 可以指定堆快照的保存位置。</li></ul><p><strong>例如:</strong></p><pre><code class="highlight plaintext">-Xms100m -Xmx100m -XX:+HeapDumpOnOutOfMemoryError -XX:HeapDumpPath=D:\m.hprof</code></pre><p><img src="https://raw.githubusercontent.com/GeorgeChan95/blogimg/master/img/2024/08/16/20240816-083406.png" alt="VM Options 配置"></p><p><strong>示例代码:</strong></p><pre><code class="highlight java"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">GCTest</span> &#123;    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;        ArrayList&lt;<span class="type">byte</span>[]&gt; list = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; <span class="number">1000</span>; i++) &#123;            <span class="type">byte</span>[] arr = <span class="keyword">new</span> <span class="title class_">byte</span>[<span class="number">1024</span> * <span class="number">100</span>];<span class="comment">//100KB</span>            list.add(arr);            <span class="keyword">try</span> &#123;                Thread.sleep(<span class="number">60</span>);            &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;                e.printStackTrace();            &#125;        &#125;    &#125;&#125;</code></pre><p>运行代码,当程序出现OOM时, 会自动在D盘根目录下生成 m.hprof 文件</p><p><img src="https://raw.githubusercontent.com/GeorgeChan95/blogimg/master/img/2024/08/16/20240816-083748.png" alt="image-20240816083747704"></p><h2 id="4-显示堆内存相关信息"><a href="#4-显示堆内存相关信息" class="headerlink" title="4. 显示堆内存相关信息"></a>4. 显示堆内存相关信息</h2><h3 id="4-1-jmap-heap-进程id"><a href="#4-1-jmap-heap-进程id" class="headerlink" title="4.1 jmap -heap 进程id"></a>4.1 <strong>jmap -heap 进程id</strong></h3><ul><li><p><code>jmap -heap &lt;pid&gt;</code> 只是时间点上的堆信息，而 <code>jstat</code> 后面可以添加参数，可以指定时间动态观察数据改变情况，而图形化界面工具，例如 jvisualvm 等，它们可以用图表的方式动态展示出相关信息，更加直观明了</p><p><img src="https://raw.githubusercontent.com/GeorgeChan95/blogimg/master/img/2024/08/16/20240816-085807.png" alt="jmap -heap"></p></li></ul><p>**参数解析: **</p><ul><li><p>一般信息</p><pre><code class="highlight shell">Attaching to process ID 28420, please wait...Debugger attached successfully.Server compiler detected.JVM version is 25.241-b07</code></pre><ul><li><p><strong>Attaching to process ID 28420</strong>: 表示 <code>jmap</code> 工具正在连接到进程 ID 为 28420 的 JVM 实例。</p></li><li><p><strong>Debugger attached successfully</strong>: 调试器成功附加到 JVM 实例。</p></li><li><p><strong>Server compiler detected</strong>: JVM 使用的是服务器模式的编译器，这通常用于高性能环境。</p></li><li><p><strong>JVM version is 25.241-b07</strong>: 表示 JVM 的版本号是 25.241-b07，这通常是 Java 8 的一个版本。</p></li></ul></li><li><p>GC 信息</p><pre><code class="highlight shell">using thread-local object allocation.Parallel GC with 15 thread(s)</code></pre><ul><li><p><strong>using thread-local object allocation</strong>: JVM 使用线程本地对象分配（TLOA），这是为了提高对象分配的效率。</p></li><li><p><strong>Parallel GC with 15 thread(s)</strong>: JVM 使用的是并行垃圾回收器（Parallel GC），并且使用了 15 个线程来进行垃圾回收。</p></li></ul></li><li><p>堆内存配置 (Heap Configuration)</p><pre><code class="highlight shell">Heap Configuration:   MinHeapFreeRatio         = 0   MaxHeapFreeRatio         = 100   MaxHeapSize              = 104857600 (100.0MB)   NewSize                  = 34603008 (33.0MB)   MaxNewSize               = 34603008 (33.0MB)   OldSize                  = 70254592 (67.0MB)   NewRatio                 = 2   SurvivorRatio            = 8   MetaspaceSize            = 21807104 (20.796875MB)   CompressedClassSpaceSize = 1073741824 (1024.0MB)   MaxMetaspaceSize         = 17592186044415 MB   G1HeapRegionSize         = 0 (0.0MB)</code></pre><ul><li><p><strong>MinHeapFreeRatio &#x3D; 0</strong>: 最小堆内存空闲比例为 0%，表示没有保留的最小空闲空间。</p></li><li><p><strong>MaxHeapFreeRatio &#x3D; 100</strong>: 最大堆内存空闲比例为 100%，表示堆可以完全空闲。</p></li><li><p><strong>MaxHeapSize &#x3D; 104857600 (100.0MB)</strong>: 最大堆大小设置为 100MB。</p></li><li><p><strong>NewSize &#x3D; 34603008 (33.0MB)</strong>: 新生代的初始大小为 33MB。</p></li><li><p><strong>MaxNewSize &#x3D; 34603008 (33.0MB)</strong>: 新生代的最大大小为 33MB。</p></li><li><p><strong>OldSize &#x3D; 70254592 (67.0MB)</strong>: 老年代的初始大小为 67MB。</p></li><li><p><strong>NewRatio &#x3D; 2</strong>: 新生代与老年代的比例为 1:2。</p></li><li><p><strong>SurvivorRatio &#x3D; 8</strong>: Eden 区与 Survivor 区的比例为 8:1。</p></li><li><p><strong>MetaspaceSize &#x3D; 21807104 (20.796875MB)</strong>: 元空间的初始大小为约 20.8MB。</p></li><li><p><strong>CompressedClassSpaceSize &#x3D; 1073741824 (1024.0MB)</strong>: 压缩类空间大小为 1024MB。</p></li><li><p><strong>MaxMetaspaceSize &#x3D; 17592186044415 MB</strong>: 最大元空间大小非常大，几乎没有限制。</p></li><li><p><strong>G1HeapRegionSize &#x3D; 0 (0.0MB)</strong>: G1 GC 堆区域大小为 0，表示未使用 G1 垃圾回收器。</p></li></ul></li><li><p>堆内存使用情况 (Heap Usage)</p><pre><code class="highlight shell">Heap Usage:PS Young GenerationEden Space:   capacity = 26214400 (25.0MB)   used     = 23077464 (22.008384704589844MB)   free     = 3136936 (2.9916152954101562MB)   88.03353881835938% usedFrom Space:   capacity = 4194304 (4.0MB)   used     = 0 (0.0MB)   free     = 4194304 (4.0MB)   0.0% usedTo Space:   capacity = 4194304 (4.0MB)   used     = 0 (0.0MB)   free     = 4194304 (4.0MB)   0.0% usedPS Old Generation   capacity = 70254592 (67.0MB)   used     = 0 (0.0MB)   free     = 70254592 (67.0MB)   0.0% used</code></pre><p><strong>PS Young Generation</strong>: 年轻代（Parallel Scavenge GC）信息。</p><ul><li>Eden Space<ul><li><strong>capacity &#x3D; 26214400 (25.0MB)</strong>: Eden 区的总容量为 25MB。</li><li><strong>used &#x3D; 23077464 (22.008384704589844MB)</strong>: 已使用 22MB。</li><li><strong>free &#x3D; 3136936 (2.9916152954101562MB)</strong>: 空闲 3MB。</li><li><strong>88.03353881835938% used</strong>: 使用率为 88%。</li></ul></li><li>From Space<ul><li><strong>capacity &#x3D; 4194304 (4.0MB)</strong>: From Survivor 区的总容量为 4MB。</li><li><strong>used &#x3D; 0 (0.0MB)</strong>: 未使用。</li><li><strong>free &#x3D; 4194304 (4.0MB)</strong>: 完全空闲。</li><li><strong>0.0% used</strong>: 使用率为 0%。</li></ul></li><li>To Space<ul><li><strong>capacity &#x3D; 4194304 (4.0MB)</strong>: To Survivor 区的总容量为 4MB。</li><li><strong>used &#x3D; 0 (0.0MB)</strong>: 未使用。</li><li><strong>free &#x3D; 4194304 (4.0MB)</strong>: 完全空闲。</li><li><strong>0.0% used</strong>: 使用率为 0%。</li></ul></li></ul><p><strong>PS Old Generation</strong>: 老年代信息。</p><ul><li><p><strong>capacity &#x3D; 70254592 (67.0MB)</strong>: 老年代的总容量为 67MB。</p></li><li><p><strong>used &#x3D; 0 (0.0MB)</strong>: 未使用。</p></li><li><p><strong>free &#x3D; 70254592 (67.0MB)</strong>: 完全空闲。</p></li><li><p><strong>0.0% used</strong>: 使用率为 0%。</p></li></ul></li><li><p>字符串池的使用情况</p><pre><code class="highlight shell">2164 interned Strings occupying 200768 bytes.</code></pre><ul><li><p><strong>2164 interned Strings</strong>: 字符串池中有 2164 个字符串。</p></li><li><p><strong>occupying 200768 bytes</strong>: 这些字符串占用了约 200768 字节（约 196 KB）的内存。</p></li></ul></li></ul><h3 id="4-2-jmap-histo-进程id"><a href="#4-2-jmap-histo-进程id" class="headerlink" title="4.2 jmap -histo 进程id"></a>4.2 jmap -histo 进程id</h3><p>输出堆中对象的同级信息，包括类、实例数量和合计容量，也是这一时刻的内存中的对象信息</p><p><img src="https://raw.githubusercontent.com/GeorgeChan95/blogimg/master/img/2024/08/16/20240816-091150.png" alt="jmap -histo"></p><h2 id="5-其它作用"><a href="#5-其它作用" class="headerlink" title="5. 其它作用"></a>5. 其它作用</h2><ul><li><code>jmap -permstat 进程id</code> : 查看系统的ClassLoader信息</li><li><code>jmap -finalizerinfo</code> : 查看堆积在finalizer队列中的对象</li></ul><p>这两个指令仅linux&#x2F;solaris平台有效，所以无法在windows操作平台上使用</p><h2 id="6-总结"><a href="#6-总结" class="headerlink" title="6. 总结"></a>6. 总结</h2><ul><li>由于jmap将访问堆中的所有对象，为了保证在此过程中不被应用线程干扰，jmap需要借助安全点机制，让所有线程停留在不改变堆中数据的状态。也就是说，由jmap导出的堆快照必定是安全点位置的。这可能导致基于该堆快照的分析结果存在偏差。</li><li>举个例子，假设在编译生成的机器码中，某些对象的生命周期在两个安全点之间，那么 <code>:live</code> 选项将无法探知到这些对象。</li><li>另外，如果某个线程长时间无法跑到安全点，jmap将一直等下去。与前面讲的jstat则不同, 垃圾回收器会主动将jstat所需要的摘要数据保存至固定位置之中，而jstat只需直接读取即可。</li></ul><h1 id="六、jhat：JDK自带堆分析工具"><a href="#六、jhat：JDK自带堆分析工具" class="headerlink" title="六、jhat：JDK自带堆分析工具"></a>六、jhat：JDK自带堆分析工具</h1><p>jhat 命令在 jdk9 及其之后就被移除了，官方建议使用 Jvisualvm 代替jhat，所以该指令只需简单了解一下即可</p><p><code>jhat</code> (JVM Heap Analysis Tool):</p><ul><li>Sun ]DK 提供的 jhat 命令与 jmap 命令搭配使用，用于分析 jmap 生成的 heap dump文件(堆转储快照) 。jhat 内置了一个微型的 HTTP&#x2F;HTML 服务器， 生成 dump 文件的分析结果后， 用户可以在浏览器中查看分析结果(分析虚拟机转储快照信息)。</li><li>使用了 jhat 命令，就启动了一个http服务，端口是 7008，即 <a href="http://1ocalhost:7800/%EF%BC%8C%E5%B0%B1%E5%8F%AF%E4%BB%A5%E5%9C%A8%E6%B5%8F%E8%A7%88%E5%99%A8%E9%87%8C%E5%88%86%E6%9E%90%E3%80%82">http://1ocalhost:7800/，就可以在浏览器里分析。</a></li><li>说明: jhat 命令在JDK9、JDK18中已经被删除，官方建议用 <code>VisualVM</code> 代替</li></ul><h2 id="1-基本语法"><a href="#1-基本语法" class="headerlink" title="1. 基本语法"></a>1. 基本语法</h2><p><code>jhat [option] [dumpfile]</code></p><p>其中dumpfile代表dump文件的地址以及名称，例如：</p><p><img src="https://raw.githubusercontent.com/GeorgeChan95/blogimg/master/img/2024/08/16/20240816-140048.png" alt="jhat"></p><p><img src="https://raw.githubusercontent.com/GeorgeChan95/blogimg/master/img/2024/08/16/20240816-140120.png" alt="jhat web"></p><h2 id="2-options参数"><a href="#2-options参数" class="headerlink" title="2. options参数"></a>2. options参数</h2><ul><li>-stack false l true<ul><li>关闭|打开对象分配调用栈跟踪</li></ul></li><li>-refs false l true<ul><li>关闭|打开对象引用跟踪</li></ul></li><li>-port port-number <ul><li>设置 jhat HTTP Server的端口号，默认7000</li></ul></li><li>-exclude exclude-file<ul><li>执行对象查询时需要排除的数据成员</li></ul></li><li>-baseline exclude-file<ul><li>指定一个基准堆转储</li></ul></li><li>-debug int<ul><li>设置debug级别</li></ul></li><li>-version<ul><li>启动后显示版本信息就退出</li></ul></li><li>-J <flag><ul><li>传入启动参数，比如小 -J -Xmx512m</li></ul></li></ul><p><strong>示例:</strong></p><pre><code class="highlight sh">jhat -stack <span class="literal">false</span> d:\1.hprofjhat -port 6565 d:\1.hprofjhat -version</code></pre><h1 id="七、jstack：打印JVM中线程快照"><a href="#七、jstack：打印JVM中线程快照" class="headerlink" title="七、jstack：打印JVM中线程快照"></a>七、jstack：打印JVM中线程快照</h1><h2 id="1-基本情况"><a href="#1-基本情况" class="headerlink" title="1. 基本情况"></a>1. 基本情况</h2><p><strong>jstack (JVM stack Trace)</strong> : 用于生成虚拟机指定进程当前时刻的线程快照(虚拟机堆栈跟踪)。 线程快照就是当前虚拟机内指定进程的每一条线程正在执行的方法堆栈的集合。</p><p><strong>生成线程快照的作用</strong> : 可用于定位线程出现长时间停顿的原因，如线程间死锁、死循环、请求外部资源导致的长时间等待等问题。这些都是导致线程长时间停顿的常见原因。当线程出现停顿时，就可以用 jstack 显示各个线程调用的堆情况。</p><p><strong>官方帮助文档:</strong><br><a href="https://docs.oracle.com/en/java/javase/11/tools/jstack.html">https://docs.oracle.com/en/java/javase/11/tools/jstack.html</a></p><p>在 <strong>thread dump</strong> 中，要留意下面几种状态</p><ul><li>死锁，Deadlock(重点关注)</li><li>等待资源，Waiting on condition(重点关注)</li><li>等待获取监视器，Waiting on monitor entry(重点关注)</li><li>阻塞，Blocked(重点关注)</li><li>执行中，Runnable</li><li>暂停，Suspended</li><li>对象等待中，Object.wait() 或 TIMED WAITING</li><li>停止，Parked</li></ul><h2 id="2-基本语法-1"><a href="#2-基本语法-1" class="headerlink" title="2. 基本语法"></a>2. 基本语法</h2><p><img src="https://raw.githubusercontent.com/GeorgeChan95/blogimg/master/img/2024/08/16/20240816-142006.png" alt="jstack"></p><p><strong>它的基本使用语法为:</strong> <code>jstack option pid</code></p><p><strong>option 参数</strong></p><ul><li><p>-F</p><p>当正常输出的请求不被响应时，强制输出线程堆栈</p></li><li><p>-l</p><p>除堆栈外，显示关于锁的附加信息</p></li><li><p>-m</p><p>如果调用本地方法的话，可以显示C&#x2F;C++的堆栈</p></li><li><p>-h</p><p>帮助操作</p></li></ul><p><strong>使用示例: 测试jstack排查死锁</strong></p><ul><li><p>测试代码</p><pre><code class="highlight java"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ThreadDeadLock</span> &#123;    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;        <span class="type">StringBuilder</span> <span class="variable">s1</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">StringBuilder</span>();        <span class="type">StringBuilder</span> <span class="variable">s2</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">StringBuilder</span>();        <span class="keyword">new</span> <span class="title class_">Thread</span>()&#123;            <span class="meta">@Override</span>            <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span> &#123;                <span class="keyword">synchronized</span> (s1)&#123;                    s1.append(<span class="string">&quot;a&quot;</span>);                    s2.append(<span class="string">&quot;1&quot;</span>);                    <span class="keyword">try</span> &#123;                        Thread.sleep(<span class="number">100</span>);                    &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;                        e.printStackTrace();                    &#125;                    <span class="keyword">synchronized</span> (s2)&#123;                        s1.append(<span class="string">&quot;b&quot;</span>);                        s2.append(<span class="string">&quot;2&quot;</span>);                        System.out.println(s1);                        System.out.println(s2);                    &#125;                &#125;            &#125;        &#125;.start();        <span class="keyword">new</span> <span class="title class_">Thread</span>(<span class="keyword">new</span> <span class="title class_">Runnable</span>() &#123;            <span class="meta">@Override</span>            <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span> &#123;                <span class="keyword">synchronized</span> (s2)&#123;                    s1.append(<span class="string">&quot;c&quot;</span>);                    s2.append(<span class="string">&quot;3&quot;</span>);                    <span class="keyword">try</span> &#123;                        Thread.sleep(<span class="number">100</span>);                    &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;                        e.printStackTrace();                    &#125;                    <span class="keyword">synchronized</span> (s1)&#123;                        s1.append(<span class="string">&quot;d&quot;</span>);                        s2.append(<span class="string">&quot;4&quot;</span>);                        System.out.println(s1);                        System.out.println(s2);                    &#125;                &#125;            &#125;        &#125;).start();        <span class="keyword">try</span> &#123;            Thread.sleep(<span class="number">1000</span>);        &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;            e.printStackTrace();        &#125;        <span class="keyword">new</span> <span class="title class_">Thread</span>(<span class="keyword">new</span> <span class="title class_">Runnable</span>() &#123;            <span class="meta">@Override</span>            <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span> &#123;                Map&lt;Thread, StackTraceElement[]&gt; all = Thread.getAllStackTraces();<span class="comment">//追踪当前进程中的所有的线程</span>                Set&lt;Map.Entry&lt;Thread, StackTraceElement[]&gt;&gt; entries = all.entrySet();                <span class="keyword">for</span>(Map.Entry&lt;Thread, StackTraceElement[]&gt; en : entries)&#123;                    <span class="type">Thread</span> <span class="variable">t</span> <span class="operator">=</span> en.getKey();                    StackTraceElement[] v = en.getValue();                    System.out.println(<span class="string">&quot;【Thread name is :&quot;</span> + t.getName() + <span class="string">&quot;】&quot;</span>);                    <span class="keyword">for</span>(StackTraceElement s : v)&#123;                        System.out.println(<span class="string">&quot;\t&quot;</span> + s.toString());                    &#125;                &#125;            &#125;        &#125;).start();    &#125;&#125;</code></pre></li><li><p>启动程序</p></li><li><p>使用 jstack 打印线程信息</p><p><code>jstack -l 19076</code> : 其中 19076 是程序的进程ID</p><p><img src="https://raw.githubusercontent.com/GeorgeChan95/blogimg/master/img/2024/08/16/20240816-144116.png" alt="jstack 排查死锁问题"></p></li></ul><h1 id="八、jcmd：多功能命令行"><a href="#八、jcmd：多功能命令行" class="headerlink" title="八、jcmd：多功能命令行"></a>八、jcmd：多功能命令行</h1><p>在 JDK 1.7 以后，新增了一个命令行工具jcmd。</p><p>它是一个多功能的工具，可以用来实现前面除了 jstat 之外所有命令的功能。比如:用它来导出堆、内存使用、查看Java进程、导出线程信息、执行GC、JVM运行时间等</p><p><strong>官方帮助文档:</strong> <a href="https://docs.oracle.com/en/java/javase/11/tools/jcmd.html">https://docs.oracle.com/en/java/javase/11/tools/jcmd.html</a></p><p>jcmd 拥有 jmap 的大部分功能，并且在Oracle的官方网站上也推荐使用 jcmd 命令代 jmap 命令</p><h2 id="1-基本语法-1"><a href="#1-基本语法-1" class="headerlink" title="1. 基本语法"></a>1. 基本语法</h2><ul><li><p>jcmd -l </p><p>列出所有的JVM进程</p></li><li><p>jcmd 进程号 help</p><p>针对指定的进程，列出支持的所有具体命令</p><p><img src="https://raw.githubusercontent.com/GeorgeChan95/blogimg/master/img/2024/08/16/20240816-150959.png" alt="jcmd help"></p><p>根据以上命令来替换之前的那些操作：</p><ul><li>Thread.print 可以替换 jstack 指令</li><li>GC.class_histogram 可以替换 jmap中的 -histo 操作</li><li>GC.heap_dump 可以替换 jmap中的 -dump 操作</li><li>GC.run 可以查看GC的执行情况</li><li>VM.uptime 可以查看程序的总执行时间，可以替换jstat指令中的 -t 操作</li><li>VM.system_properties 可以替换 jinfo -sysprops 进程id</li><li>VM.flags 可以获取JVM的配置参数信息</li></ul></li><li><p>jcmd 进程号 具体命令</p><p>显示指定进程的指令命令的数据</p><p><img src="https://raw.githubusercontent.com/GeorgeChan95/blogimg/master/img/2024/08/16/20240816-151415.png" alt="jcmd 打印线程信息"></p></li></ul><h1 id="九、jstatd：远程主机信息收集"><a href="#九、jstatd：远程主机信息收集" class="headerlink" title="九、jstatd：远程主机信息收集"></a>九、jstatd：远程主机信息收集</h1><p>之前的指令只涉及到监控本机的Java应用程序，而在这些工具中，一些监控工具也支持对远程计算机的监控(如 <code>jps</code>、<code>jstat</code> )。为了启用远程监控，则需要配合使用 <code>jstatd</code> 工具。<br>命令 jstatd 是一个RMI服务端程序，它的作用相当于代理服务器，建立本地计算机与远程监控工具的通信。jstatd 服务器将本机的Java应用程序信息传递到远程计算机。</p><p><img src="https://raw.githubusercontent.com/GeorgeChan95/blogimg/master/img/2024/08/16/20240816-164755.png" alt="jstatd的理解"></p>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;一、概述&quot;&gt;&lt;a href=&quot;#一、概述&quot; class=&quot;headerlink&quot; title=&quot;一、概述&quot;&gt;&lt;/a&gt;一、概述&lt;/h1&gt;&lt;p&gt;性能诊断是软件工程师在日常工作中需要经常面对和解决的问题，在用户体验至上的今天，解决好应用的性能问题能带来非常大的收益。&lt;/</summary>
      
    
    
    
    <category term="JVM" scheme="https://georgechan95.github.io/categories/JVM/"/>
    
    
    <category term="java" scheme="https://georgechan95.github.io/tags/java/"/>
    
    <category term="jvm" scheme="https://georgechan95.github.io/tags/jvm/"/>
    
  </entry>
  
  <entry>
    <title>第二十一章-性能监控与调优概述</title>
    <link href="https://georgechan95.github.io/blog/2681163762.html"/>
    <id>https://georgechan95.github.io/blog/2681163762.html</id>
    <published>2024-08-12T11:13:06.000Z</published>
    <updated>2024-08-28T04:17:33.347Z</updated>
    
    <content type="html"><![CDATA[<h1 id="一、背景说明"><a href="#一、背景说明" class="headerlink" title="一、背景说明"></a>一、背景说明</h1><h2 id="1-生产环境中的问题"><a href="#1-生产环境中的问题" class="headerlink" title="1. 生产环境中的问题"></a>1. 生产环境中的问题</h2><ul><li><p>生产环境发生了内存溢出该如何处理？</p></li><li><p>生产环境应该给服务器分配多少内存合适？</p></li><li><p>如何对垃圾回收器的性能进行调优？</p></li><li><p>生产环境CPU负载飙高该如何处理？</p></li><li><p>生产环境应该给应用分配多少线程合适？</p></li><li><p>不加log，如何确定请求是否执行了某一行代码？</p></li><li><p>不加log，如何实时查看某个方法的入参与返回值？</p></li></ul><h2 id="2-为什么要调优"><a href="#2-为什么要调优" class="headerlink" title="2. 为什么要调优"></a>2. 为什么要调优</h2><ul><li><p>防止出现OOM</p></li><li><p>解决OOM</p></li><li><p>减少Full GC出现的频率</p></li></ul><h2 id="3-不同阶段的考虑"><a href="#3-不同阶段的考虑" class="headerlink" title="3. 不同阶段的考虑"></a>3. 不同阶段的考虑</h2><ul><li><p>上线前</p></li><li><p>项目运行阶段</p></li><li><p>线上出现OOM</p></li></ul><h1 id="二、调优概述"><a href="#二、调优概述" class="headerlink" title="二、调优概述"></a>二、调优概述</h1><h2 id="1-监控的依据"><a href="#1-监控的依据" class="headerlink" title="1. 监控的依据"></a>1. 监控的依据</h2><ul><li><p>运行日志</p></li><li><p>异常堆栈</p></li><li><p>GC日志</p></li><li><p>线程快照</p></li><li><p>堆转储快照</p></li></ul><h2 id="2-调优的大方向"><a href="#2-调优的大方向" class="headerlink" title="2. 调优的大方向"></a>2. 调优的大方向</h2><ul><li><p>合理地编写代码</p></li><li><p>充分并合理的使用硬件资源</p></li><li><p>合理地进行JVM调优</p></li></ul><h1 id="三、性能优化的步骤"><a href="#三、性能优化的步骤" class="headerlink" title="三、性能优化的步骤"></a>三、性能优化的步骤</h1><h2 id="第1步：性能监控"><a href="#第1步：性能监控" class="headerlink" title="第1步：性能监控"></a>第1步：性能监控</h2><ul><li><p>GC频繁</p></li><li><p>cpu load过高</p></li><li><p>OOM</p></li><li><p>内存泄露</p></li><li><p>死锁</p></li><li><p>程序响应时间较长</p></li></ul><h2 id="第2步：性能分析"><a href="#第2步：性能分析" class="headerlink" title="第2步：性能分析"></a>第2步：性能分析</h2><ul><li><p>打印GC日志，通过 GCviewer 或者 <a href="http://gceasy.io/">http://gceasy.io</a> 来分析异常信息</p></li><li><p>灵活运用命令行工具、jstack、jmap、jinfo等</p></li><li><p>dump出堆文件，使用内存分析工具分析文件</p></li><li><p>使用阿里Arthas、jconsole、JVisualVM来实时查看JVM状态</p></li><li><p>jstack查看堆栈信息</p></li></ul><h2 id="第3步：性能调优"><a href="#第3步：性能调优" class="headerlink" title="第3步：性能调优"></a>第3步：性能调优</h2><ul><li><p>适当增加内存，根据业务背景选择垃圾回收器</p></li><li><p>优化代码，控制内存使用</p></li><li><p>增加机器，分散节点压力</p></li><li><p>合理设置线程池线程数量</p></li><li><p>使用中间件提高程序效率，比如缓存、消息队列等</p></li><li><p>其他……</p></li></ul><h1 id="四、性能评价-测试指标"><a href="#四、性能评价-测试指标" class="headerlink" title="四、性能评价&#x2F;测试指标"></a>四、性能评价&#x2F;测试指标</h1><h2 id="1-停顿时间（或响应时间）"><a href="#1-停顿时间（或响应时间）" class="headerlink" title="1. 停顿时间（或响应时间）"></a>1. 停顿时间（或响应时间）</h2><p>提交请求和返回该请求的响应之间使用的时间，一般比较关注平均响应时间。常用操作的响应时间列表：</p><table><thead><tr><th>操作</th><th>响应时间</th></tr></thead><tbody><tr><td>打开一个站点</td><td>几秒</td></tr><tr><td>数据库查询一条记录（有索引）</td><td>十几毫秒</td></tr><tr><td>机械磁盘一次寻址定位</td><td>4毫秒</td></tr><tr><td>从机械磁盘顺序读取1M数据</td><td>2毫秒</td></tr><tr><td>从SSD磁盘顺序读取1M数据</td><td>0.3毫秒</td></tr><tr><td>从远程分布式换成Redis 读取一个数据</td><td>0.5毫秒</td></tr><tr><td>从内存读取 1M数据</td><td>十几微妙</td></tr><tr><td>Java程序本地方法调用</td><td>几微妙</td></tr><tr><td>网络传输2Kb数据</td><td>1 微妙</td></tr></tbody></table><p>在垃圾回收环节中：</p><ul><li><p>暂停时间：执行垃圾收集时，程序的工作线程被暂停的时间。</p></li><li><p>-XX:MaxGCPauseMillis (设置最大暂停时间)</p></li></ul><h2 id="2-吞吐量"><a href="#2-吞吐量" class="headerlink" title="2. 吞吐量"></a>2. 吞吐量</h2><ul><li><p>对单位时间内完成的工作量（请求）的量度</p></li><li><p>在GC中：运行用户代码的事件占总运行时间的比例（总运行时间：程序的运行时间+内存回收的时间）</p></li><li><p>吞吐量为1-1&#x2F;(1+n)，其中-XX::GCTimeRatio&#x3D;n</p><ul><li>parallel scavenge 收集器参数, 即: 垃圾收集时间占总时间的比率, 默认值: 99</li></ul></li></ul><h2 id="3-并发数"><a href="#3-并发数" class="headerlink" title="3. 并发数"></a>3. 并发数</h2><ul><li>同一时刻，对服务器有实际交互的请求数<ul><li>1000个人同时在线，估计并发数在5%-15%之间，也就是同时并发量：50-150之间。</li></ul></li></ul><h2 id="4-内存占用"><a href="#4-内存占用" class="headerlink" title="4. 内存占用"></a>4. 内存占用</h2><ul><li>Java堆区所占的内存大小</li></ul>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;一、背景说明&quot;&gt;&lt;a href=&quot;#一、背景说明&quot; class=&quot;headerlink&quot; title=&quot;一、背景说明&quot;&gt;&lt;/a&gt;一、背景说明&lt;/h1&gt;&lt;h2 id=&quot;1-生产环境中的问题&quot;&gt;&lt;a href=&quot;#1-生产环境中的问题&quot; class=&quot;headerli</summary>
      
    
    
    
    <category term="JVM" scheme="https://georgechan95.github.io/categories/JVM/"/>
    
    
    <category term="java" scheme="https://georgechan95.github.io/tags/java/"/>
    
    <category term="jvm" scheme="https://georgechan95.github.io/tags/jvm/"/>
    
  </entry>
  
  <entry>
    <title>第二十章-再谈类的加载器</title>
    <link href="https://georgechan95.github.io/blog/3537043756.html"/>
    <id>https://georgechan95.github.io/blog/3537043756.html</id>
    <published>2024-08-10T05:43:10.000Z</published>
    <updated>2024-08-28T04:17:33.358Z</updated>
    
    <content type="html"><![CDATA[<p><strong>以下内容关于类加载器都是基于 JDK8 讲解的, JDK9的类加载器与之不同</strong></p><h1 id="一、概述"><a href="#一、概述" class="headerlink" title="一、概述"></a>一、概述</h1><p>类加载器是JVM执行类加载机制的前提。</p><p><strong>ClassLoader的作用：</strong></p><p>ClassLoader是Java的核心组件，所有的Class都是由ClassLoader进行加载的，ClassLoader负责通过各种方式将Class信息的二进制数据流读入JVM内部，转换为一个与目标类对应的java.lang.Class对象实例。然后交给Java虚拟机进行链接、初始化等操作。因此，ClassLoader在整个装载阶段，只能影响到类的加载，而无法通过ClassLoader去改变类的链接和初始化行为。至于它是否可以运行，则由Execution Engine决定。</p><p><img src="https://raw.githubusercontent.com/GeorgeChan95/blogimg/master/img/2024/08/10/20240810-135915.png" alt="类的加载"></p><p>类加载器最早出现在Java1.8版本中，那个时候只是单纯地为了满足Java Applet应用而被研发出来。但如今类加载器却在OSGi、字节码加解密领域大放异彩。这主要归功于]ava虚拟机的设计者们当初在设计类加载器的时候，并没有考虑将它绑定在JVM内部，这样做的好处就是能够更加灵活和动态地执行类加载操作。</p><h2 id="1-类加载器的分类"><a href="#1-类加载器的分类" class="headerlink" title="1. 类加载器的分类"></a>1. 类加载器的分类</h2><p><strong>类的加载分类：显式加载 vs 隐式加载</strong></p><p>class文件的显式加载与隐式加载的方式是指JVM加载class文件到内存的方式。</p><ul><li>显式加载指的是在代码中通过调用ClassLoader加载class对象，如直接使用 <code>Class.forName(name)</code> 或 <code>this.getClass().getClassLoader().loadClass()</code> 加载class对象。</li><li>隐式加载则是不直接在代码中调用ClassLoader的方法加载class对象，而是通过虚拟机自动加载到内存中，如在加载某个类的class文件时，该类的class文件中引用了另外一个类的对象，此时额外引用的类将通过JVM自动加载到内存中。</li></ul><p>在日常开发以上两种方式一般会混合使用。</p><pre><code class="highlight java"><span class="comment">//隐式加载</span>User user=<span class="keyword">new</span> <span class="title class_">User</span>();<span class="comment">//显式加载，并初始化</span>Class clazz=Class.forName(<span class="string">&quot;com.test.java.User&quot;</span>);<span class="comment">//显式加载，但不初始化</span>ClassLoader.getSystemClassLoader().loadClass(<span class="string">&quot;com.test.java.Parent&quot;</span>);</code></pre><h2 id="2-类加载器的必要性"><a href="#2-类加载器的必要性" class="headerlink" title="2. 类加载器的必要性"></a>2. 类加载器的必要性</h2><p>一般情况下，Java开发人员并不需要在程序中显式地使用类加载器，但是了解类加载器的加载机制却显得至关重要。从以下几个方面说：</p><ul><li><p>避免在开发中遇到 <code>java.lang.ClassNotFoundException</code> 异常或 <code>java.lang.NoClassDefFoundError</code> 异常时，手足无措。只有了解类加载器的 加载机制才能够在出现异常的时候快速地根据错误异常日志定位问题和解决问题</p></li><li><p>需要支持类的动态加载或需要对编译后的字节码文件进行加解密操作时，就需要与类加载器打交道了。</p></li><li><p>开发人员可以在程序中编写自定义类加载器来重新定义类的加载规则，以便实现一些自定义的处理逻辑。</p></li></ul><h2 id="3-命名空间"><a href="#3-命名空间" class="headerlink" title="3. 命名空间"></a>3. 命名空间</h2><p><strong>何为类的唯一性？</strong></p><p>对于任意一个类，都需要由加载它的类加载器和这个类本身一同确认其在Java虚拟机中的唯一性。每一个类加载器，都拥有一个独立的类名称空间：比较两个类是否相等，只有在这两个类是由同一个类加载器加载的前提下才有意义。否则，即使这两个类源自同一个Class文件，被同一个虚拟机加载，只要加载他们的类加载器不同，那这两个类就必定不相等。</p><p><strong>命名空间</strong></p><ul><li><p>每个类加载器都有自己的命名空间，命名空间由该加载器及所有的父加载器所加载的类组成 </p></li><li><p>在同一命名空间中，不会出现类的完整名字（包括类的包名）相同的两个类 </p></li><li><p>在不同的命名空间中，有可能会出现类的完整名字（包括类的包名）相同的两个类</p></li></ul><p>在大型应用中，我们往往借助这一特性，来运行同一个类的不同版本。</p><h2 id="4-类加载机制的基本特征"><a href="#4-类加载机制的基本特征" class="headerlink" title="4. 类加载机制的基本特征"></a>4. 类加载机制的基本特征</h2><p>通常类的加载机制有三个基本特征</p><ul><li>双亲委派模型。但不是所有类加载都遵守这个模型，有的时候，启动类加载器所加载的类型，是可能要加载用户代码的，比如JDK内部的<code>ServiceProvider/ServiceLoader</code> 机制，用户可以在标准API框架上，提供自己的实现，JDK也需要提供些默认的参考实现。例如，Java中JNDI、JDBC、文件系统、Cipher等很多方面，都是利用的这种机制，这种情况就不会用双亲委派模型去加载，而是利用所谓的上下文加载器。</li><li>可见性。子类加载器可以访问父加载器加载的类型，但是反过来是不允许的。不然，因为缺少必要的隔离，我们就没有办法利用类加载器去实现容器的逻辑。</li><li>单一性。由于父加载器的类型对于子加载器是可见的，所以父加载器中加载过的类型，就不会在子加载器中重复加载。但是注意，类加载器“邻居”间，同一类型仍然可以被加载多次，因为互相并不可见。</li></ul><h2 id="5-类加载器之间的关系"><a href="#5-类加载器之间的关系" class="headerlink" title="5. 类加载器之间的关系"></a>5. 类加载器之间的关系</h2><h3 id="5-1-Launcher类核心代码"><a href="#5-1-Launcher类核心代码" class="headerlink" title="5.1 Launcher类核心代码"></a>5.1 Launcher类核心代码</h3><p>JDK8中, 全路径: <code>sun.misc.Launcher</code></p><pre><code class="highlight java"><span class="keyword">public</span> <span class="title function_">Launcher</span><span class="params">()</span> &#123;    <span class="comment">// .......</span>        ExtClassLoader var1;    <span class="keyword">try</span> &#123;        var1 = Launcher.ExtClassLoader.getExtClassLoader();    &#125; <span class="keyword">catch</span> (IOException var10) &#123;        <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">InternalError</span>(<span class="string">&quot;Could not create extension class loader&quot;</span>, var10);    &#125;    <span class="keyword">try</span> &#123;        <span class="built_in">this</span>.loader = Launcher.AppClassLoader.getAppClassLoader(var1);    &#125; <span class="keyword">catch</span> (IOException var9) &#123;        <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">InternalError</span>(<span class="string">&quot;Could not create application class loader&quot;</span>, var9);    &#125;    Thread.currentThread().setContextClassLoader(<span class="built_in">this</span>.loader);        <span class="comment">// ......</span>&#125;</code></pre><h3 id="5-2-关键代码分析"><a href="#5-2-关键代码分析" class="headerlink" title="5.2 关键代码分析"></a>5.2 关键代码分析</h3><h4 id="5-2-1-ExtClassLoader的Parent类是null"><a href="#5-2-1-ExtClassLoader的Parent类是null" class="headerlink" title="5.2.1 ExtClassLoader的Parent类是null"></a>5.2.1 <strong>ExtClassLoader的Parent类是null</strong></h4><p>先看：</p><pre><code class="highlight java">var1 = Launcher.ExtClassLoader.getExtClassLoader();</code></pre><p>获取到扩展类加载器，点击该方法往里面追溯，在找到：</p><pre><code class="highlight java">instance = createExtClassLoader();</code></pre><p>我们在点击该方法往里面追溯，在找到：</p><pre><code class="highlight java"><span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">ExtClassLoader</span>(var1);</code></pre><p>我们在点击该方法往里面追溯，在找到：</p><pre><code class="highlight java"><span class="built_in">super</span>(getExtURLs(var1), (ClassLoader)<span class="literal">null</span>, Launcher.factory);</code></pre><p>然后点击super，往里面追溯，在找到：</p><pre><code class="highlight java"><span class="keyword">public</span> <span class="title function_">URLClassLoader</span><span class="params">(URL[] urls, ClassLoader parent,</span><span class="params">                          URLStreamHandlerFactory factory)</span> &#123;    <span class="built_in">super</span>(parent);    <span class="comment">// this is to make the stack depth consistent with 1.1</span>    <span class="type">SecurityManager</span> <span class="variable">security</span> <span class="operator">=</span> System.getSecurityManager();    <span class="keyword">if</span> (security != <span class="literal">null</span>) &#123;        security.checkCreateClassLoader();    &#125;</code></pre><p>点击其中的parent就是null，我们点击super，往里面追溯，在找到：</p><pre><code class="highlight java"><span class="keyword">protected</span> <span class="title function_">SecureClassLoader</span><span class="params">(ClassLoader parent)</span> &#123;    <span class="built_in">super</span>(parent);</code></pre><p>点击其中的parent就是null，我们点击super，往里面追溯，在找到：</p><pre><code class="highlight java"><span class="keyword">protected</span> <span class="title function_">ClassLoader</span><span class="params">(ClassLoader parent)</span> &#123;    <span class="built_in">this</span>(checkCreateClassLoader(), parent);&#125;</code></pre><p>点击其中的parent就是null，我们点击this，往里面追溯，在找到：</p><pre><code class="highlight java"><span class="keyword">private</span> <span class="title function_">ClassLoader</span><span class="params">(Void unused, ClassLoader parent)</span> &#123;    <span class="built_in">this</span>.parent = parent;</code></pre><p>由于parent就是null，所以ExtClassLoader(扩展类加载器)的父类是null，也就是Bootstrap ClassLoader(引导类加载器)，因此我们调用获取扩展类加载器父类的方法获得的结果是null</p><h4 id="5-2-2-AppClassLoader的Parent类是ExtClassLoader"><a href="#5-2-2-AppClassLoader的Parent类是ExtClassLoader" class="headerlink" title="5.2.2 AppClassLoader的Parent类是ExtClassLoader"></a>5.2.2 AppClassLoader的Parent类是ExtClassLoader</h4><p>先看：</p><pre><code class="highlight plaintext">this.loader = Launcher.AppClassLoader.getAppClassLoader(var1);</code></pre><p>获取到系统类加载器，点击该方法往里面追溯，在找到：</p><pre><code class="highlight plaintext">return new AppClassLoader(var1x, var0);</code></pre><p>其中 <code>var0</code> 就是扩展类加载器，点击AppClassLoader，往里面追溯，在找到：</p><pre><code class="highlight plaintext">AppClassLoader(URL[] var1, ClassLoader var2) &#123;    super(var1, var2, Launcher.factory);    this.ucp.initLookupCache(this);&#125;</code></pre><p>其中var2就是扩展类加载器，我们点击super，往里面追溯，在找到：</p><pre><code class="highlight plaintext">public URLClassLoader(URL[] urls, ClassLoader parent,                      URLStreamHandlerFactory factory) &#123;    super(parent);</code></pre><p>里面的parent就是扩展类加载器，我们点击super，往里面追溯，在找到：</p><pre><code class="highlight plaintext">protected SecureClassLoader(ClassLoader parent) &#123;    super(parent);</code></pre><p>里面的parent就是扩展类加载器，我们点击super，往里面追溯，在找到：</p><pre><code class="highlight plaintext">protected ClassLoader(ClassLoader parent) &#123;    this(checkCreateClassLoader(), parent);&#125;</code></pre><p>里面的parent就是扩展类加载器，我们点击this，往里面追溯，在找到：</p><pre><code class="highlight plaintext">private ClassLoader(Void unused, ClassLoader parent) &#123;    this.parent = parent;</code></pre><p>由于parent就是扩展类加载器，所以系统类加载器的父类是扩展类加载器，因此我们调用获取系统类加载器父类的方法获得的结果是扩展类加载器</p><h4 id="5-2-3-当前线程的ClassLoader是AppClassLoader"><a href="#5-2-3-当前线程的ClassLoader是AppClassLoader" class="headerlink" title="5.2.3  当前线程的ClassLoader是AppClassLoader"></a>5.2.3  当前线程的ClassLoader是AppClassLoader</h4><p><code>Thread.currentThread().setContextClassLoader(this.loader)</code> 就是将系统类加载器设置为当前线程的上下文加载器，所以<code>Thread.currentThread().getContextClassLoader()</code> 获取到的就是系统类加载器</p><p><strong>注意，这里的Parent类并不是Java语言意义上的继承关系，而是一种包含关系</strong></p><h1 id="二、类的加载器分类"><a href="#二、类的加载器分类" class="headerlink" title="二、类的加载器分类"></a>二、类的加载器分类</h1><p>JVM支持两种类型的类加载器，分别为引导类加载器（Bootstrap ClassLoader）和自定义类加载器（User-Defined ClassLoader）。</p><p>从概念上来讲，自定义类加载器一般指的是程序中由开发人员自定义的一类类加载器，但是Java虚拟机规范却没有这么定义，而是将所有派生于抽象类ClassLoader的类加载器都划分为自定义类加载器。无论类加载器的类型如何划分，在程序中我们最常见的类加载器结构主要是如下情况：</p><p><img src="https://raw.githubusercontent.com/GeorgeChan95/blogimg/master/img/2024/08/10/20240810-150849.png" alt="类加载器的分类"></p><ul><li><p>除了顶层的启动类加载器外，其余的类加载器都应当有自己的“父类”加载器。</p></li><li><p>不同类加载器看似是继承（Inheritance）关系，实际上是包含关系。在下层加载器中，包含着上层加载器的引用。</p></li></ul><p>父类加载器和子类加载器的关系：</p><pre><code class="highlight java"><span class="keyword">class</span> <span class="title class_">ClassLoader</span>&#123;    ClassLoader parent;<span class="comment">//父类加载器</span>    <span class="keyword">public</span> <span class="title function_">ClassLoader</span><span class="params">(ClassLoader parent)</span>&#123;    <span class="built_in">this</span>.parent = parent;    &#125;&#125;<span class="keyword">class</span> <span class="title class_">ParentClassLoader</span> <span class="keyword">extends</span> <span class="title class_">ClassLoader</span>&#123;    <span class="keyword">public</span> <span class="title function_">ParentClassLoader</span><span class="params">(ClassLoader parent)</span>&#123;        <span class="built_in">super</span>(parent);    &#125;&#125;<span class="keyword">class</span> <span class="title class_">ChildClassLoader</span> <span class="keyword">extends</span> <span class="title class_">ClassLoader</span>&#123;    <span class="keyword">public</span> <span class="title function_">ChildClassLoader</span><span class="params">(ClassLoader parent)</span>&#123; <span class="comment">//parent = new ParentClassLoader();</span>        <span class="built_in">super</span>(parent);    &#125;&#125;</code></pre><p>正是由于子类加载器中包含着父类加载器的引用，所以可以通过子类加载器的方法获取对应的父类加载器</p><p><strong>注意：</strong></p><p>启动类加载器通过C&#x2F;C++语言编写，而自定义类加载器都是由Java语言编写的，虽然扩展类加载器和应用程序类加载器是被jdk开发人员使用java语言来编写的，但是也是由java语言编写的，所以也被称为自定义类加载器.</p><h2 id="1-引导类加载器"><a href="#1-引导类加载器" class="headerlink" title="1. 引导类加载器"></a>1. 引导类加载器</h2><p>启动类加载器（引导类加载器，Bootstrap ClassLoader）</p><ul><li><p>这个类加载使用C&#x2F;C++语言实现的，嵌套在JVM内部。 </p></li><li><p>它用来加载Java的核心库（<code>JAVAHOME/jre/lib/</code>rt.jar或<code>sun.boot.class.path</code>路径下的内容）。用于提供JVM自身需要的类。 </p></li><li><p>并不继承自java.lang.ClassLoader，没有父加载器。 </p></li><li><p>出于安全考虑，Bootstrap启动类加载器只加载包名为java、javax、sun等开头的类 </p></li><li><p>加载扩展类和应用程序类加载器，并指定为他们的父类加载器。</p></li></ul><p><img src="https://raw.githubusercontent.com/GeorgeChan95/blogimg/master/img/2024/08/10/20240810-153117.png" alt="引导类加载器"></p><p>使用 <code>-XX:+TraceClassLoading</code> 参数得到。</p><p><strong>代码示例:</strong></p><pre><code class="highlight java">System.out.println(<span class="string">&quot;**********启动类加载器**************&quot;</span>);<span class="comment">//获取BootstrapClassLoader能够加载的api的路径</span>URL[] urLs = sun.misc.Launcher.getBootstrapClassPath().getURLs();<span class="keyword">for</span> (URL element : urLs) &#123;    System.out.println(element.toExternalForm());&#125;<span class="comment">//从上面的路径中随意选择一个类,来看看他的类加载器是什么:引导类加载器</span><span class="type">ClassLoader</span> <span class="variable">classLoader</span> <span class="operator">=</span> java.security.Provider.class.getClassLoader();System.out.println(classLoader);</code></pre><p><strong>执行结果：</strong></p><pre><code class="highlight txt">**********启动类加载器**************file:/E:/software/Java/jdk1.8.0_241/jre/lib/resources.jarfile:/E:/software/Java/jdk1.8.0_241/jre/lib/rt.jarfile:/E:/software/Java/jdk1.8.0_241/jre/lib/sunrsasign.jarfile:/E:/software/Java/jdk1.8.0_241/jre/lib/jsse.jarfile:/E:/software/Java/jdk1.8.0_241/jre/lib/jce.jarfile:/E:/software/Java/jdk1.8.0_241/jre/lib/charsets.jarfile:/E:/software/Java/jdk1.8.0_241/jre/lib/jfr.jarfile:/E:/software/Java/jdk1.8.0_241/jre/classesnull</code></pre><h2 id="2-扩展类加载器"><a href="#2-扩展类加载器" class="headerlink" title="2. 扩展类加载器"></a>2. 扩展类加载器</h2><p>扩展类加载器（Extension ClassLoader）</p><p>● Java语言编写，由sun.misc.Launcher$ExtClassLoader实现。<br>●  继承于ClassLoader类<br>●  父类加载器为启动类加载器<br>●  从java.ext.dirs系统属性所指定的目录中加载类库，或从JDK的安装目录的jre&#x2F;lib&#x2F;ext子目录下加载类库。如果用户创建的JAR放在此目录下，也会自动由扩展类加载器加载。</p><p><img src="https://raw.githubusercontent.com/GeorgeChan95/blogimg/master/img/2024/08/10/20240810-155020.png" alt="image-20240810155019744"></p><p><strong>代码示例:</strong></p><pre><code class="highlight java">System.out.println(<span class="string">&quot;***********扩展类加载器*************&quot;</span>);<span class="type">String</span> <span class="variable">extDirs</span> <span class="operator">=</span> System.getProperty(<span class="string">&quot;java.ext.dirs&quot;</span>);<span class="keyword">for</span> (String path : extDirs.split(<span class="string">&quot;;&quot;</span>)) &#123;    System.out.println(path);&#125;<span class="comment">//从上面的路径中随意选择一个类,来看看他的类加载器是什么:扩展类加载器</span><span class="type">ClassLoader</span> <span class="variable">classLoader1</span> <span class="operator">=</span> sun.security.ec.CurveDB.class.getClassLoader();System.out.println(classLoader1); <span class="comment">// sun.misc.Launcher$ExtClassLoader@12a3a380</span></code></pre><p><strong>执行结果:</strong></p><pre><code class="highlight txt">***********扩展类加载器*************E:\software\Java\jdk1.8.0_241\jre\lib\extC:\Windows\Sun\Java\lib\extsun.misc.Launcher$ExtClassLoader@12a3a380</code></pre><h2 id="3-系统类加载器"><a href="#3-系统类加载器" class="headerlink" title="3. 系统类加载器"></a>3. 系统类加载器</h2><p>应用程序类加载器（系统类加载器，AppClassLoader）</p><ul><li><p>java语言编写，由sun.misc.Launcher$AppClassLoader实现</p></li><li><p>继承于ClassLoader类</p></li><li><p>父类加载器为扩展类加载器</p></li><li><p>它负责加载环境变量classpath或系统属性java.class.path 指定路径下的类库</p></li><li><p>应用程序中的类加载器默认是系统类加载器。</p></li><li><p>它是用户自定义类加载器的默认父加载器</p></li><li><p>通过ClassLoader的getSystemClassLoader()方法可以获取到该类加载器</p><pre><code class="highlight java"><span class="comment">//获取系统该类加载器</span><span class="type">ClassLoader</span> <span class="variable">systemClassLoader</span> <span class="operator">=</span> ClassLoader.getSystemClassLoader();System.out.println(systemClassLoader);<span class="comment">//sun.misc.Launcher$AppClassLoader@18b4aac2</span></code></pre></li></ul><p><img src="https://raw.githubusercontent.com/GeorgeChan95/blogimg/master/img/2024/08/10/20240810-155619.png" alt="image-20240810155619231"></p><h2 id="4-用户自定义类加载器"><a href="#4-用户自定义类加载器" class="headerlink" title="4. 用户自定义类加载器"></a>4. 用户自定义类加载器</h2><ul><li><p>在Java的日常应用程序开发中，类的加载几乎是由上述3种类加载器相互配合执行的。在必要时，我们还可以自定义类加载器，来定制类的加载方式。</p></li><li><p>体现Java语言强大生命力和巨大魅力的关键因素之一便是，Java开发者可以自定义类加载器来实现类库的动态加载，加载源可以是本地的JAR包，也可以是网络上的远程资源。</p></li><li><p>通过类加载器可以实现非常绝妙的插件机制，这方面的实际应用案例举不胜举。例如，著名的OSGI组件框架，再如Eclipse的插件机制。类加载器为应用程序提供了一种动态增加新功能的机制，这种机制无须重新打包发布应用程序就能实现。</p></li><li><p>同时，自定义加载器能够实现应用隔离，例如Tomcat，Spring等中间件和组件框架都在内部实现了自定义的加载器，并通过自定义加载器隔离不同的组件模块。这种机制比C&#x2F;C程序要好太多，想不修改C&#x2F;C程序就能为其新增功能，几乎是不可能的，仅仅一个兼容性便能阻挡住所有美好的设想。</p></li><li><p>自定义类加载器通常需要继承于ClassLoader。</p></li></ul><h1 id="三、测试不同的类的加载器"><a href="#三、测试不同的类的加载器" class="headerlink" title="三、测试不同的类的加载器"></a>三、测试不同的类的加载器</h1><p>每个Class对象都会包含一个定义它的ClassLoader的一个引用。</p><pre><code class="highlight java"><span class="comment">//获取系统该类加载器</span><span class="type">ClassLoader</span> <span class="variable">systemClassLoader</span> <span class="operator">=</span> ClassLoader.getSystemClassLoader();System.out.println(systemClassLoader);<span class="comment">//sun.misc.Launcher$AppClassLoader@18b4aac2</span><span class="comment">//获取扩展类加载器</span><span class="type">ClassLoader</span> <span class="variable">extClassLoader</span> <span class="operator">=</span> systemClassLoader.getParent();System.out.println(extClassLoader);<span class="comment">//sun.misc.Launcher$ExtClassLoader@1540e19d</span><span class="comment">//试图获取引导类加载器：失败</span><span class="type">ClassLoader</span> <span class="variable">bootstrapClassLoader</span> <span class="operator">=</span> extClassLoader.getParent();System.out.println(bootstrapClassLoader);<span class="comment">//null</span><span class="type">ClassLoader</span> <span class="variable">classLoader</span> <span class="operator">=</span> Class.forName(<span class="string">&quot;java.lang.String&quot;</span>).getClassLoader();System.out.println(classLoader); <span class="comment">// null, String是核心类库,使用Bootstrap ClassLoader加载</span><span class="comment">//自定义的类默认使用系统类加载器</span><span class="type">ClassLoader</span> <span class="variable">classLoader1</span> <span class="operator">=</span> Class.forName(<span class="string">&quot;com.atguigu.java.ClassLoaderTest1&quot;</span>).getClassLoader();System.out.println(classLoader1); <span class="comment">// sun.misc.Launcher$AppClassLoader@18b4aac2</span><span class="comment">//关于数组类型的加载:使用的类的加载器与数组元素的类的加载器相同</span>String[] arrStr = <span class="keyword">new</span> <span class="title class_">String</span>[<span class="number">10</span>];System.out.println(arrStr.getClass().getClassLoader()); <span class="comment">//null:表示使用的是引导类加载器</span>ClassLoaderTest1[] arr1 = <span class="keyword">new</span> <span class="title class_">ClassLoaderTest1</span>[<span class="number">10</span>];System.out.println(arr1.getClass().getClassLoader()); <span class="comment">//sun.misc.Launcher$AppClassLoader@18b4aac2</span><span class="type">int</span>[] arr2 = <span class="keyword">new</span> <span class="title class_">int</span>[<span class="number">10</span>];System.out.println(arr2.getClass().getClassLoader()); <span class="comment">//null: 基本数据类型不需要类的加载器</span><span class="comment">// 当前线程上下文的ClassLoader就是系统类加载器，</span>System.out.println(Thread.currentThread().getContextClassLoader()); <span class="comment">// sun.misc.Launcher$AppClassLoader@18b4aac2</span></code></pre><p><strong>解释:</strong></p><ul><li><p>站在程序的角度看，引导类加载器与另外两种类加载器（系统类加载器和扩展类加载器）并不是同一个层次意义上的加<br>载器，引导类加载器是使用C++语言编写而成的，而另外两种类加载器则是使用Java语言编写而成的。由于引导类加载<br>器压根儿就不是一个Java类，因此在Java程序中只能打印出空值。</p></li><li><p>数组类的Class对象，不是由类加载器去创建的，而是在Java运行期JVM根据需要自动创建的。对于数组类的类加载器<br>来说，是通过Class.getClassLoader()返回的，与数组当中元素类型的类加载器是一样的；如果数组当中的元素类型<br>是基本数据类型，数组类是没有类加载器的。</p></li></ul><h1 id="四、ClassLoader源码解析"><a href="#四、ClassLoader源码解析" class="headerlink" title="四、ClassLoader源码解析"></a>四、ClassLoader源码解析</h1><p><strong>ClassLoader与现有类的关系：</strong></p><p><img src="https://raw.githubusercontent.com/GeorgeChan95/blogimg/master/img/2024/08/10/20240810-163038.png" alt="ClassLoader继承关系"></p><p>除了以上虚拟机自带的加载器外，用户还可以定制自己的类加载器。Java提供了抽象类java.lang.ClassLoader，所有用户自定义的类加载器都应该继承ClassLoader类。</p><h2 id="1-ClassLoader的主要方法"><a href="#1-ClassLoader的主要方法" class="headerlink" title="1. ClassLoader的主要方法"></a>1. ClassLoader的主要方法</h2><p>抽象类ClassLoader的主要方法：（内部没有抽象方法）</p><ol><li><p>返回该类加载器的超类加载器</p><pre><code class="highlight java"><span class="keyword">public</span> <span class="keyword">final</span> ClassLoader <span class="title function_">getParent</span><span class="params">()</span></code></pre></li><li><p>加载名称为name的类，返回结果为java.lang.Class类的实例。如果找不到类，则返回 <code>ClassNotFoundException</code> 异常。该方法中的逻辑就是双亲委派模式的实现。</p><pre><code class="highlight java"><span class="keyword">public</span> Class&lt;?&gt; loadClass(String name) <span class="keyword">throws</span> ClassNotFoundException</code></pre></li><li><p>查找二进制名称为name的类，返回结果为java.lang.Class类的实例。这是一个受保护的方法，JVM鼓励我们重写此方法，需要自定义加载器遵循双亲委托机制，该方法会在检查完父类加载器之后被loadClass()方法调用。</p><pre><code class="highlight plaintext">protected Class&lt;?&gt; findClass(String name) throws ClassNotFoundException</code></pre><ul><li>在JDK1.2之前，在自定义类加载时，总会去继承ClassLoader类并重写loadClass方法，从而实现自定义的类加载类。但是在JDK1.2之后已不再建议用户去覆盖loadClass()方法，而是建议把自定义的类加载逻辑写在findClass()方法中，从前面的分析可知，findClass()方法是在loadClass()方法中被调用的，当loadClass()方法中父加载器加载失败后，则会调用自己的findClass()方法来完成类加载，这样就可以保证自定义的类加载器也符合双亲委托模式。 </li><li>需要注意的是 ClassLoader 类中并没有实现 findClass() 方法的具体代码逻辑，取而代之的是抛出 ClassNotFoundException 异常，同时应该知道的是 findClass 方法通常是和 defineClass 方法一起使用的。</li></ul><p><strong>一般情况下，在自定义类加载器时，会直接覆盖 ClassLoader 的 findClass() 方法并编写加载规则，取得要加载类的字节码后转换成流，然后调用 defineClass() 方法生成类的Class对象。</strong></p></li><li><p>根据给定的 字节数组b 转换为Class的实例，off 和 len 参数表示实际Class信息在byte数组中的位置和长度，其中byte数组b是ClassLoader从外部获取的。这是受保护的方法，只有在自定义ClassLoader子类中可以使用。</p><pre><code class="highlight java"><span class="keyword">protected</span> <span class="keyword">final</span> Class&lt;?&gt; defineClass(String name, <span class="type">byte</span>[] b,<span class="type">int</span> off,<span class="type">int</span> len)</code></pre><ul><li><p>defineClass() 方法是用来将byte字节流解析成JVM能够识别的Class对象（ClassLoader中已实现该方法逻辑），通过这个方法不仅能够通过class文件实例化class对象，也可以通过其他方式实例化class对象，如通过网络接收一个类的字节码，然后转换为byte字节流创建对应的Class对象。 </p></li><li><p><strong>defineClass() 方法通常与 findClass() 方法一起使用，一般情况下，在自定义类加载器时，会直接覆盖 ClassLoader 的 findClass() 方法并编写加载规则，取得要加载类的字节码后转换成流，然后调用 defineClass() 方法生成类的Class对象</strong></p></li></ul><p><strong>举例说明</strong></p><pre><code class="highlight java"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">UserClassLoader</span> <span class="keyword">extends</span> <span class="title class_">ClassLoader</span> &#123;    <span class="keyword">private</span> String rootDir;    <span class="keyword">public</span> <span class="title function_">UserClassLoader</span><span class="params">(String rootDir)</span> &#123;        <span class="built_in">this</span>.rootDir = rootDir;    &#125;    <span class="comment">/**</span><span class="comment">     * 编写findClass方法的逻辑</span><span class="comment">     */</span>    <span class="meta">@Override</span>    <span class="keyword">protected</span> Class&lt;?&gt; findClass(String name) <span class="keyword">throws</span> ClassNotFoundException &#123;        <span class="comment">// 获取类的class文件字节数组</span>        <span class="type">byte</span>[] classData = getClassData(name);        <span class="keyword">if</span> (classData == <span class="literal">null</span>) &#123;            <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">ClassNotFoundException</span>();        &#125; <span class="keyword">else</span> &#123;            <span class="comment">//直接生成class对象</span>            <span class="keyword">return</span> defineClass(name, classData, <span class="number">0</span>, classData.length);        &#125;    &#125;    <span class="comment">/**</span><span class="comment">     * 编写获取class文件并转换为字节码流的逻辑 * <span class="doctag">@param</span> className * <span class="doctag">@return</span></span><span class="comment">     */</span>    <span class="keyword">private</span> <span class="type">byte</span>[] getClassData(String className) &#123;        <span class="comment">// 读取类文件的字节</span>        <span class="type">String</span> <span class="variable">path</span> <span class="operator">=</span> classNameToPath(className);        <span class="keyword">try</span> &#123;            <span class="type">InputStream</span> <span class="variable">ins</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">FileInputStream</span>(path);            <span class="type">ByteArrayOutputStream</span> <span class="variable">baos</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ByteArrayOutputStream</span>();            <span class="type">byte</span>[] buffer = <span class="keyword">new</span> <span class="title class_">byte</span>[<span class="number">1024</span>];            <span class="type">int</span> <span class="variable">len</span> <span class="operator">=</span> <span class="number">0</span>;            <span class="comment">// 读取类文件的字节码</span>            <span class="keyword">while</span> ((len = ins.read(buffer)) != -<span class="number">1</span>) &#123;                baos.write(buffer, <span class="number">0</span>, len);            &#125;            <span class="keyword">return</span> baos.toByteArray();        &#125; <span class="keyword">catch</span> (IOException e) &#123;            e.printStackTrace();        &#125;        <span class="keyword">return</span> <span class="literal">null</span>;    &#125;    <span class="comment">/**</span><span class="comment">     * 类文件的完全路径</span><span class="comment">     */</span>    <span class="keyword">private</span> String <span class="title function_">classNameToPath</span><span class="params">(String className)</span> &#123;        <span class="keyword">return</span> rootDir + <span class="string">&quot;\\&quot;</span> + className.replace(<span class="string">&#x27;.&#x27;</span>, <span class="string">&#x27;\\&#x27;</span>) + <span class="string">&quot;.class&quot;</span>;    &#125;    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;        <span class="type">String</span> <span class="variable">rootDir</span> <span class="operator">=</span> <span class="string">&quot;E:\\testWorkspace\\jvm-demo-mid\\chapter04\\src\\&quot;</span>;        <span class="keyword">try</span> &#123;            <span class="comment">//创建自定义的类的加载器1</span>            <span class="type">UserClassLoader</span> <span class="variable">loader1</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">UserClassLoader</span>(rootDir);            <span class="type">Class</span> <span class="variable">clazz1</span> <span class="operator">=</span> loader1.findClass(<span class="string">&quot;com.atguigu.java.User&quot;</span>);            <span class="comment">//创建自定义的类的加载器2</span>            <span class="type">UserClassLoader</span> <span class="variable">loader2</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">UserClassLoader</span>(rootDir);            <span class="type">Class</span> <span class="variable">clazz2</span> <span class="operator">=</span> loader2.findClass(<span class="string">&quot;com.atguigu.java.User&quot;</span>);            System.out.println(clazz1 == clazz2); <span class="comment">//结果:false, clazz1与clazz2对应了不同的类模板结构。</span>            System.out.println(clazz1.getClassLoader()); <span class="comment">// com.atguigu.java.UserClassLoader@16f65612</span>            System.out.println(clazz2.getClassLoader()); <span class="comment">// com.atguigu.java.UserClassLoader@7c53a9eb</span>            <span class="comment">//######################</span>            <span class="type">Class</span> <span class="variable">clazz3</span> <span class="operator">=</span> ClassLoader.getSystemClassLoader().loadClass(<span class="string">&quot;com.atguigu.java.User&quot;</span>);            System.out.println(clazz3.getClassLoader()); <span class="comment">// sun.misc.Launcher$AppClassLoader@18b4aac2</span>            <span class="comment">// 自定义类加载器的父类加载器是 AppClassLoader</span>            System.out.println(clazz1.getClassLoader().getParent()); <span class="comment">// sun.misc.Launcher$AppClassLoader@18b4aac2</span>        &#125; <span class="keyword">catch</span> (ClassNotFoundException e) &#123;            e.printStackTrace();        &#125;    &#125;&#125;</code></pre></li><li><p>链接指定的一个Java类。使用该方法可以使用类的Class对象创建完成的同时也被解析。前面我们说链接阶段主要是对字节码进行验证，为类变量分配内存并设置初始值同时将字节码文件中的符号引用转换为直接引用。</p><pre><code class="highlight java"><span class="keyword">protected</span> <span class="keyword">final</span> Class&lt;?&gt; findLoadedClass(String name)</code></pre></li><li><p>查找名称为name的已经被加载过的类，返回结果为java.lang.Class类的实例。这个方法是final方法，无法被修改。</p><pre><code class="highlight java"><span class="keyword">protected</span> <span class="keyword">final</span> Class&lt;?&gt; findLoadedClass(String name)</code></pre></li><li><p>它也是一个ClassLoader的实例，这个字段所表示的ClassLoader也称为这个ClassLoader的双亲。在类加载的过程中，ClassLoader可能会将某些请求交予自己的双亲处理。</p><pre><code class="highlight java"><span class="keyword">private</span> <span class="keyword">final</span> ClassLoader parent;</code></pre></li></ol><h2 id="2-SecureClassLoader与URLClassLoader"><a href="#2-SecureClassLoader与URLClassLoader" class="headerlink" title="2. SecureClassLoader与URLClassLoader"></a>2. SecureClassLoader与URLClassLoader</h2><p>接着<strong>SecureClassLoader</strong>扩展了ClassLoader，新增了几个与使用相关的代码源（对代码源的位置及其证书的验证）和权限定义类验证（主要指对class源码的访问权限）的方法，一般我们不会直接跟这个类打交道，更多是与它的子类<strong>URLClassLoader</strong>有所关联。</p><p>前面说过，ClassLoader是一个抽象类，很多方法是空的没有实现，比如findClass()、findResource()等。而URLClassLoader这个实现类为这些方法提供了具体的实现。并新增了URLClassPath类协助取得Class字节码流等功能。<strong>在编写自定义类加载器时，如果没有太过于复杂的需求，可以直接继承URLClassLoader类</strong>，这样就可以避免自己去编写findClass()方法及其获取字节码流的方式，使自定义类加载器编写更加简洁。</p><p><img src="https://raw.githubusercontent.com/GeorgeChan95/blogimg/master/img/2024/08/10/20240810-165250.png" alt="URLClassLoader"></p><h2 id="3-ExtClassLoader与AppClassLoader"><a href="#3-ExtClassLoader与AppClassLoader" class="headerlink" title="3. ExtClassLoader与AppClassLoader"></a>3. ExtClassLoader与AppClassLoader</h2><p>了解完URLClassLoader后接着看看剩余的两个类加载器，即<strong>拓展类加载器ExtClassLoader</strong>和<strong>系统类加载器AppClassLoader</strong>，这两个类都继承自URLClassLoader，是 <code>sun.misc.Launcher</code> 的静态内部类。</p><p><code>sun.misc.Launcher</code> 主要被系统用于启动主应用程序，ExtClassLoader和AppClassLoader都是由sun.misc.Launcher创建的，其类主要类结构如下：</p><p><img src="https://raw.githubusercontent.com/GeorgeChan95/blogimg/master/img/2024/08/10/20240810-165757.png" alt="Launcher"></p><p>我们发现ExtClassLoader并没有重写loadClass()方法，这足矣说明其遵循双亲委派模式，而AppClassLoader重载了loadClass()方法，但最终调用的还是父类loadClass()方法，因此依然遵守双亲委派模式。</p><h2 id="4-Class-forName-与ClassLoader-loadClass"><a href="#4-Class-forName-与ClassLoader-loadClass" class="headerlink" title="4. Class.forName()与ClassLoader.loadClass()"></a>4. Class.forName()与ClassLoader.loadClass()</h2><p><strong>Class.forName()</strong></p><ul><li>Class.forName()：是一个<strong>静态方法</strong>，最常用的是Class.forName(String className); </li><li>根据传入的类的全限定名返回一个Class对象。该方法在将Class文件加载到内存的同时，<strong>会执行类的初始化</strong>。</li></ul><pre><code class="highlight java">Class.forName(<span class="string">&quot;com.atguigu.java.Helloworld&quot;</span>);</code></pre><p><strong>ClassLoader.loadClass()</strong></p><ul><li><p>ClassLoader.loadClass()：这是一个<strong>实例方法</strong>，需要一个ClassLoader对象来调用该方法。 </p></li><li><p>该方法将Class文件加载到内存时，并<strong>不会执行类的初始化，直到这个类第一次使用时才进行初始化</strong>。该方法因为需要得到一个ClassLoader对象，所以可以根据需要指定使用哪个类加载器。</p></li></ul><pre><code class="highlight java"><span class="type">Class</span> <span class="variable">clazz</span> <span class="operator">=</span> ClassLoader.getSystemClassLoader().loadClass(<span class="string">&quot;com.atguigu.java1.Person&quot;</span>);</code></pre><h1 id="五、双亲委派模型"><a href="#五、双亲委派模型" class="headerlink" title="五、双亲委派模型"></a>五、双亲委派模型</h1><h2 id="1-定义与本质"><a href="#1-定义与本质" class="headerlink" title="1. 定义与本质"></a>1. 定义与本质</h2><p>类加载器用来把类加载到Java虚拟机中。从JDK1.2版本开始，类的加载过程采用双亲委派机制，这种机制能更好地保证Java平台的安全。</p><p><strong>定义</strong></p><p>如果一个类加载器在接到加载类的请求时，它首先不会自己尝试去加载这个类，而是把这个请求任务委托给父类加载器去完成，依次递归，如果父类加载器可以完成类加载任务，就成功返回。只有父类加载器无法完成此加载任务时，才自己去加载。</p><p><strong>本质</strong></p><p>规定了类加载的顺序是：引导类加载器先加载，若加载不到，由扩展类加载器加载，若还加载不到，才会由系统类加载器或自定义的类加载器进行加载。</p><p><img src="https://raw.githubusercontent.com/GeorgeChan95/blogimg/master/img/2024/08/10/20240810-170952.png" alt="双亲委派模型"></p><p><img src="https://raw.githubusercontent.com/GeorgeChan95/blogimg/master/img/2024/08/10/20240810-171002.png" alt="双亲委派模型2"></p><h2 id="2-优势与劣势"><a href="#2-优势与劣势" class="headerlink" title="2. 优势与劣势"></a>2. 优势与劣势</h2><h3 id="2-1-双亲委派机制优势"><a href="#2-1-双亲委派机制优势" class="headerlink" title="2.1 双亲委派机制优势"></a>2.1 双亲委派机制优势</h3><ul><li><p>避免类的重复加载，确保一个类的全局唯一性</p><p>Java类随着它的类加载器一起具备了一种带有优先级的层次关系，通过这种层级关可以避免类的重复加载，当父亲已经加载了该类时，就没有必要子ClassLoader再加载一次。</p></li><li><p>保护程序安全，防止核心API被随意篡改</p></li></ul><h3 id="2-2-代码支持"><a href="#2-2-代码支持" class="headerlink" title="2.2 代码支持"></a>2.2 代码支持</h3><p>双亲委派机制在 <code>java.lang.ClassLoader.loadClass(String，boolean)</code> 接口中体现。该接口的逻辑如下：</p><ol><li>先在当前加载器的缓存中查找有无目标类，如果有，直接返回。</li><li>判断当前加载器的父加载器是否为空，如果不为空，则调用 <code>parent.loadClass(name，false)</code> 接口进行加载。</li><li>反之，如果当前加载器的父类加载器为空，则调用 <code>findBootstrapClassorNull(name)</code> 接口，让引导类加载器进行加载。</li><li>如果通过以上3条路径都没能成功加载，则调用 <code>findClass(name)</code> 接口进行加载。该接口最终会调用java.lang.ClassLoader接口的defineClass系列的native接口加载目标Java类。</li></ol><p>双亲委派的模型就隐藏在这第2和第3步中。</p><h3 id="2-3-举例"><a href="#2-3-举例" class="headerlink" title="2.3 举例"></a>2.3 举例</h3><p>假设当前加载的是java.lang.Object这个类，很显然，该类属于JDK中核心得不能再核心的一个类，因此一定只能由引导类加载器进行加载。当]VM准备加载javaJang.Object时，JVM默认会使用系统类加载器去加载，按照上面4步加载的逻辑，在第1步从系统类的缓存中肯定查找不到该类，于是进入第2步。由于从系统类加载器的父加载器是扩展类加载器，于是扩展类加载器继续从第1步开始重复。由于扩展类加载器的缓存中也一定查找不到该类，因此进入第2步。扩展类的父加载器是null，因此系统调用findClass（String），最终通过引导类加载器进行加载。</p><h3 id="2-4-思考"><a href="#2-4-思考" class="headerlink" title="2.4 思考"></a>2.4 思考</h3><p>如果在自定义的类加载器中重写 <code>java.lang.ClassLoader.loadClass(String)</code> 或 <code>java.lang.ClassLoader.loadclass(String，boolean)</code> 方法，抹去其中的双亲委派机制，仅保留上面这4步中的第l步与第4步，那么是不是就能够加载核心类库了呢？</p><p>这也不行！因为JDK还为核心类库提供了一层保护机制。不管是自定义的类加载器，还是系统类加载器抑或扩展类加载器，最终都必须调用 <code>java.lang.ClassLoader.defineclass(String，byte[]，int，int，ProtectionDomain)</code> 方法，而该方法会执行 <code>preDefineClass()</code> 接口，该接口中提供了对JDK核心类库的保护。</p><h3 id="2-5-弊端"><a href="#2-5-弊端" class="headerlink" title="2.5 弊端"></a>2.5 弊端</h3><p>检查类是否加载的委托过程是单向的，这个方式虽然从结构上说比较清晰，使各个ClassLoader的职责非常明确，但是同时会带来一个问题，即顶层的ClassLoader无法访问底层的ClassLoader所加载的类。</p><p>通常情况下，启动类加载器中的类为系统核心类，包括一些重要的系统接口，而在应用类加载器中的类为应用类。按照这种模式，应用类访问系统类自然是没有问题，但是系统类访问应用类就会出现问题。比如在系统类中提供了一个接口，该接口需要在应用类中得以实现，该接口还绑定一个工厂方法，用于创建该接口的实例，而接口和工厂方法都在启动类加载器中。这时，就会出现该工厂方法无法创建由应用类加载器加载的应用实例的问题。</p><h3 id="2-6-结论"><a href="#2-6-结论" class="headerlink" title="2.6 结论"></a>2.6 结论</h3><p><strong>由于Java虚拟机规范并没有明确要求类加载器的加载机制一定要使用双亲委派模型，只是建议采用这种方式而已。</strong>比如在Tomcat中，类加载器所采用的加载机制就和传统的双亲委派模型有一定区别，当缺省的类加载器接收到一个类的加载任务时，首先会由它自行加载，当它加载失败时，才会将类的加载任务委派给它的超类加载器去执行，这同时也是Servlet规范推荐的一种做法。</p><h2 id="3-破坏双亲委派机制"><a href="#3-破坏双亲委派机制" class="headerlink" title="3. 破坏双亲委派机制"></a>3. 破坏双亲委派机制</h2><p>双亲委派模型并不是一个具有强制性约束的模型，而是Java设计者推荐给开发者们的类加载器实现方式。</p><p>在Java的世界中大部分的类加载器都遵循这个模型，但也有例外的情况，直到Java模块化出现为止，双亲委派模型主要出现过3次较大规模“被破坏”的情况。</p><h3 id="3-1-破坏双亲委派机制1"><a href="#3-1-破坏双亲委派机制1" class="headerlink" title="3.1 破坏双亲委派机制1"></a>3.1 破坏双亲委派机制1</h3><p>双亲委派模型的第一次“被破坏”其实发生在双亲委派模型出现之前–即JDK1.2面世以前的“远古”时代。</p><p>由于双亲委派模型在JDK 1.2之后才被引入，但是类加载器的概念和抽象类java.lang.ClassLoader则在Java的第一个版本中就已经存在，面对经存在的用户自定义类加载器的代码，Java设计者们引入双亲委派模型时不得不做出一些妥协，为了兼容这些已有代码，无法再以技术手段避免loadClass()被子类覆盖的可能性，只能在JDK1.2之后的java.lang.ClassLoader中添加一个新的protected方法findClass()，并引导用户编写的类加载逻辑时尽可能去重写这个方法，而不是在loadClass()中编写代码。上节我们已经分析过loadClass()方法，双亲委派的具体逻辑就实现在这里面，按照loadClass()方法的逻辑，如果父类加载失败，会自动调用自己的findClass()方法来完成加载，这样既不影响用户按照自己的意愿去加载类，又可以保证新写出来的类加载器是符合双亲委派规则的。</p><h3 id="3-2-破坏双亲委派机制1"><a href="#3-2-破坏双亲委派机制1" class="headerlink" title="3.2 破坏双亲委派机制1"></a>3.2 破坏双亲委派机制1</h3><p>双亲委派模型的第二次“被破坏”是由这个模型自身的缺陷导致的，双亲委派很好地解决了各个类加载器协作时基础类型的一致性问题（越基础的类由越上层的加载器进行加载），基础类型之所以被称为“基础”，是因为它们总是作为被用户代码继承、调用的API存在，但程序设计往往没有绝对不变的完美规则，如果有基础类型又要调用回用户的代码，那该怎么办呢？</p><p>这并非是不可能出现的事情，一个典型的例子便是JNDI服务，JNDI现在已经是Java的标准服务，它的代码由启动类加载器来完成加载（在JDK 1.3时加入到rt.jar的），肯定属于Java中很基础的类型了。但JNDI存在的目的就是对资源进行查找和集中管理，它需要调用由其他厂商实现并部署在应用程序的ClassPath下的JNDI服务提供者接口（Service Provider Interface，SPI）的代码，现在问题来了，启动类加载器是绝不可能认识、加载这些代码的，那该怎么办？（SPI：在Java平台中，通常把核心类rt.jar中提供外部服务、可由应用层自行实现的接口称为SPI）</p><p>为了解决这个困境，Java的设计团队只好引入了一个不太优雅的设计：<strong>线程上下文类加载器（Thread Context ClassLoader）</strong>。这个类加载器可以通过java.lang.Thread类的setContextClassLoader()方法进行设置，如果创建线程时还未设置，它将会从父线程中继承一个，如果在应用程序的全局范围内都没有设置过的话，那这个类加载器默认就是应用程序类加载器。</p><p>有了线程上下文类加载器，程序就可以做一些“舞弊”的事情了。JNDI服务使用这个线程上下文类加载器去加载所需的SPI服务代码，</p><p>**这是一种父类加载器去请求子类加载器完成类加载的行为，这种行为实际上是打通了双亲委派模型的层次结构来逆向使用类加载器，已经违背了双亲委派模型的一般性原则, **但也是无可奈何的事情。 例如JNDI、JDBC、JCE、JAXB和JBI等。不过，当SPI的服务提供者多于一个的时候，代码就只能根据具体提供者的类型来硬编码判断，为了消除这种极不优雅的实现方式，在JDK6时，JDK提供了java.util.ServiceLoader类，以META-INF&#x2F;services中的配置信息，辅以责任链模式，这才算是给SPI的加载提供了一种相对合理的解决方案。</p><p><img src="https://raw.githubusercontent.com/GeorgeChan95/blogimg/master/img/2024/08/10/20240810-173847.png" alt="线程上下文类加载器"></p><p>默认线程上下文加载器就是应用类加载器，这样以上下文加载器为中介，使得启动类加载器中的代码也可以访问应用类加载器中的类。</p><h3 id="3-3-破坏双亲委派机制1"><a href="#3-3-破坏双亲委派机制1" class="headerlink" title="3.3 破坏双亲委派机制1"></a>3.3 破坏双亲委派机制1</h3><p>双亲委派模型的第三次“被破坏”是由于用户对程序动态性的追求而导致的。如：**代码热替换(Hot Swap)、模块热部署(Hot Deployment)**等</p><p>IBM公司主导的 <strong>JSR-291</strong> (即OSGiR4.2)实现模块化热部署的关键是它自定义的类加载器机制的实现，每一个程序模块(osGi中称为Bundle)都有一个自己的类加载器，当需要更换一个Bundle时，就把Bund1e连同类加载器一起换掉以实现代码的热替换。在OSGi环境下，类加载器不再双亲委派模型推荐的树状结构，而是进一步发展为更加复杂的网状结构。</p><p>当收到类加载请求时，OSGi将按照下面的顺序进行类搜索：</p><ol><li>将以java.*开头的类，委派给父类加载器加载。</li><li>否则，将委派列表名单内的类，委派给父类加载器加载。</li><li>否则，将Import列表中的类，委派给Export这个类的Bundle的类加载器加载。</li><li>否则，查找当前Bundle的ClassPath，使用自己的类加载器加载。</li><li>否则，查找类是否在自己的Fragment Bundle中，如果在，则委派给Fragment Bundle的类加载器加载。</li><li>否则，查找Dynamic Import列表的Bundle，委派给对应Bund1e的类加载器加载。</li><li>否则，类查找失败。</li></ol><p>说明：只有开头两点仍然符合双亲委派模型的原则，其余的类查找都是在平级的类加载器中进行的</p><p>小结：这里，我们使用了“被破坏”这个词来形容上述不符合双亲委派模型原则的行为，但这里“被破坏”并不一定是带有贬义的。只要有明确的目的和充分的理由，突破旧有原则无疑是一种创新。</p><p>正如：OSGi中的类加载器的设计不符合传统的双亲委派的类加载器架构，且业界对其为了实现热部署而带来的额外的高复杂度还存在不少争议，但对这方面有了解的技术人员基本还是能达成一个共识，认为<strong>OSGi中对类加载器的运用是值得学习的，完全弄懂了OSGi的实现，就算是掌握了类加载器的精粹。</strong></p><h2 id="4-热替换的实现"><a href="#4-热替换的实现" class="headerlink" title="4. 热替换的实现"></a>4. 热替换的实现</h2><h3 id="4-1-理论概述"><a href="#4-1-理论概述" class="headerlink" title="4.1 理论概述"></a>4.1 理论概述</h3><p><strong>热替换是指在程序的运行过程中，不停止服务，只通过替换程序文件来修改程序的行为。</strong></p><p>热替换的关键需求在于服务不能中断，修改必须立即表现正在运行的系统之中。基本上大部分脚本语言都是天生支持热替换的，比如：PHP，只要替换了PHP源文件，这种改动就会立即生效，而无需重启Web服务器。</p><p>但对Java来说，热替换并非天生就支持，如果一个类已经加载到系统中，通过修改类文件，并无法让系统再来加载并重定义这个类。因此，在Java中实现这一功能的一个可行的方法就是灵活运用ClassLoader。</p><p><strong>注意：由不同ClassLoader加载的同名类属于不同的类型，不能相互转换和兼容。即两个不同的ClassLoader加载同一个类，在虚拟机内部，会认为这2个类是完全不同的。</strong></p><p>根据这个特点，可以用来模拟热替换的实现，基本思路如下图所示：</p><p><img src="https://raw.githubusercontent.com/GeorgeChan95/blogimg/master/img/2024/08/10/20240810-174651.png" alt="热替换的实现"></p><p>每次调用方法之前都要加载字节码文件，然后创建对象，我们可以把字节码文件变成最新的，那么创建的对象肯定是最新的，所以这就完成了热替换</p><h3 id="4-2-代码实现"><a href="#4-2-代码实现" class="headerlink" title="4.2 代码实现"></a><strong>4.2 代码实现</strong></h3><ul><li><p>基础类</p><pre><code class="highlight java"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Demo1</span> &#123;    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">hot</span><span class="params">()</span> &#123;        System.out.println(<span class="string">&quot;OldDemo1&quot;</span>);    &#125;&#125;</code></pre></li><li><p>自定义ClassLoader</p><pre><code class="highlight java"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">MyClassLoader</span> <span class="keyword">extends</span> <span class="title class_">ClassLoader</span> &#123;    <span class="keyword">private</span> String rootDir;    <span class="keyword">public</span> <span class="title function_">MyClassLoader</span><span class="params">(String rootDir)</span> &#123;        <span class="built_in">this</span>.rootDir = rootDir;    &#125;    <span class="keyword">protected</span> Class&lt;?&gt; findClass(String className) <span class="keyword">throws</span> ClassNotFoundException &#123;        <span class="type">Class</span> <span class="variable">clazz</span> <span class="operator">=</span> <span class="built_in">this</span>.findLoadedClass(className);        <span class="type">FileChannel</span> <span class="variable">fileChannel</span> <span class="operator">=</span> <span class="literal">null</span>;        <span class="type">WritableByteChannel</span> <span class="variable">outChannel</span> <span class="operator">=</span> <span class="literal">null</span>;        <span class="keyword">if</span> (<span class="literal">null</span> == clazz) &#123;            <span class="keyword">try</span> &#123;                <span class="type">String</span> <span class="variable">classFile</span> <span class="operator">=</span> getClassFile(className);                <span class="type">FileInputStream</span> <span class="variable">fis</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">FileInputStream</span>(classFile);                fileChannel = fis.getChannel();                <span class="type">ByteArrayOutputStream</span> <span class="variable">baos</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ByteArrayOutputStream</span>();                outChannel = Channels.newChannel(baos);                <span class="type">ByteBuffer</span> <span class="variable">buffer</span> <span class="operator">=</span> ByteBuffer.allocateDirect(<span class="number">1024</span>);                <span class="keyword">while</span> (<span class="literal">true</span>) &#123;                    <span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> fileChannel.read(buffer);                    <span class="keyword">if</span> (i == <span class="number">0</span> || i == -<span class="number">1</span>) &#123;                        <span class="keyword">break</span>;                    &#125;                    buffer.flip();                    outChannel.write(buffer);                    buffer.clear();                &#125;                <span class="type">byte</span>[] bytes = baos.toByteArray();                clazz = defineClass(className, bytes, <span class="number">0</span>, bytes.length);            &#125; <span class="keyword">catch</span> (FileNotFoundException e) &#123;                e.printStackTrace();            &#125; <span class="keyword">catch</span> (IOException e) &#123;                e.printStackTrace();            &#125; <span class="keyword">finally</span> &#123;                <span class="keyword">try</span> &#123;                    <span class="keyword">if</span> (fileChannel != <span class="literal">null</span>)                        fileChannel.close();                &#125; <span class="keyword">catch</span> (IOException e) &#123;                    e.printStackTrace();                &#125;                <span class="keyword">try</span> &#123;                    <span class="keyword">if</span> (outChannel != <span class="literal">null</span>)                        outChannel.close();                &#125; <span class="keyword">catch</span> (IOException e) &#123;                    e.printStackTrace();                &#125;            &#125;        &#125;        <span class="keyword">return</span> clazz;    &#125;    <span class="comment">/**</span><span class="comment">     * 类文件的完全路径</span><span class="comment">     */</span>    <span class="keyword">private</span> String <span class="title function_">getClassFile</span><span class="params">(String className)</span> &#123;        <span class="keyword">return</span> rootDir + <span class="string">&quot;\\&quot;</span> + className.replace(<span class="string">&#x27;.&#x27;</span>, <span class="string">&#x27;\\&#x27;</span>) + <span class="string">&quot;.class&quot;</span>;    &#125;&#125;</code></pre></li><li><p>测试类</p><pre><code class="highlight java"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">LoopRun</span> &#123;    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String args[])</span> &#123;        <span class="keyword">while</span> (<span class="literal">true</span>) &#123;            <span class="keyword">try</span> &#123;                <span class="comment">//1. 创建自定义类加载器的实例</span>                <span class="type">MyClassLoader</span> <span class="variable">loader</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">MyClassLoader</span>(<span class="string">&quot;E:\\testWorkspace\\jvm-demo-mid\\chapter04\\src\\&quot;</span>);                <span class="comment">//2. 加载指定的类</span>                <span class="type">Class</span> <span class="variable">clazz</span> <span class="operator">=</span> loader.findClass(<span class="string">&quot;com.atguigu.java1.Demo1&quot;</span>);                <span class="comment">//3. 创建运行时类的实例</span>                <span class="type">Object</span> <span class="variable">demo</span> <span class="operator">=</span> clazz.newInstance();                <span class="comment">//4. 获取运行时类中指定的方法</span>                <span class="type">Method</span> <span class="variable">m</span> <span class="operator">=</span> clazz.getMethod(<span class="string">&quot;hot&quot;</span>);                <span class="comment">//5. 调用指定的方法</span>                m.invoke(demo);                Thread.sleep(<span class="number">5000</span>);            &#125; <span class="keyword">catch</span> (Exception e) &#123;                System.out.println(<span class="string">&quot;not find&quot;</span>);                <span class="keyword">try</span> &#123;                    Thread.sleep(<span class="number">5000</span>);                &#125; <span class="keyword">catch</span> (InterruptedException ex) &#123;                    ex.printStackTrace();                &#125;            &#125;        &#125;    &#125;&#125;</code></pre></li></ul><h3 id="4-3-代码测试"><a href="#4-3-代码测试" class="headerlink" title="4.3 代码测试"></a>4.3 代码测试</h3><ul><li><p>启动测试类, 控制台打印:</p><p><img src="https://raw.githubusercontent.com/GeorgeChan95/blogimg/master/img/2024/08/10/20240810-175542.png" alt="热替换前"></p></li><li><p>修改Demo1.java, 重新编译生成新的Demo1.class文件</p><p><img src="https://raw.githubusercontent.com/GeorgeChan95/blogimg/master/img/2024/08/10/20240810-175647.png" alt="修改并重新编译"></p></li><li><p>无需重启服务, 再次查看控制台</p><p><img src="https://raw.githubusercontent.com/GeorgeChan95/blogimg/master/img/2024/08/10/20240810-175845.png" alt="热替换后"></p></li></ul><h1 id="六、沙箱安全机制"><a href="#六、沙箱安全机制" class="headerlink" title="六、沙箱安全机制"></a>六、沙箱安全机制</h1><ul><li><p>保证程序安全</p></li><li><p>保护Java原生的JDK代码</p></li></ul><p>安全模型的核心就是Java沙箱（sandbox）。什么是沙箱？沙箱是一个限制程序运行的环境。</p><p><strong>沙箱机制就是将Java代码限定在虚拟机（JVM）特定的运行范围中，并且严格限制代码对本地系统资源访问。通过这样的措施来保证对代码的有限隔离，防止对本地系统造成破坏。</strong></p><p>沙箱主要限制系统资源访问，那系统资源包括什么？CPU、内存、文件系统、网络。不同级别的沙箱对这些资源访问的限制也可以不一样。</p><p>所有的Java程序运行都可以指定沙箱，可以定制安全策略。</p><h2 id="1-JDK1-0时期"><a href="#1-JDK1-0时期" class="headerlink" title="1. JDK1.0时期"></a>1. JDK1.0时期</h2><p>在Java中将执行程序分成本地代码和远程代码两种，本地代码默认视为可信任的，而远程代码则被看作是不受信的。对于授信的本地代码，可以访问一切本地资源。而对于非授信的远程代码在早期的Java实现中，安全依赖于沙箱（Sandbox）机制。如下图所示JDK1.0安全模型</p><p><img src="https://raw.githubusercontent.com/GeorgeChan95/blogimg/master/img/2024/08/11/20240811-092543.png" alt="JDK1.0时期"></p><h2 id="2-JDK1-1时期"><a href="#2-JDK1-1时期" class="headerlink" title="2. JDK1.1时期"></a>2. JDK1.1时期</h2><p>JDK1.0中如此严格的安全机制也给程序的功能扩展带来障碍，比如当用户希望远程代码访问本地系统的文件时候，就无法实现。</p><p>因此在后续的Java1.1版本中，针对安全机制做了改进，增加了<strong>安全策略</strong>。允许用户指定代码对本地资源的访问权限。</p><p>如下图所示JDK1.1安全模型</p><p><img src="https://raw.githubusercontent.com/GeorgeChan95/blogimg/master/img/2024/08/11/20240811-092849.png" alt="JDK1.1安全模型"></p><h2 id="3-JDK1-2时期"><a href="#3-JDK1-2时期" class="headerlink" title="3. JDK1.2时期"></a>3. JDK1.2时期</h2><p>在Java1.2版本中，再次改进了安全机制，增加了<strong>代码签名</strong>。不论本地代码或是远程代码，都会按照用户的安全策略设定，由类加载器加载到虚拟机中权限不同的运行空间，来实现差异化的代码执行权限控制。如下图所示JDK1.2安全模型：</p><p><img src="https://raw.githubusercontent.com/GeorgeChan95/blogimg/master/img/2024/08/11/20240811-093040.png" alt="JDK1.2安全模型"></p><h2 id="4-JDK1-6时期"><a href="#4-JDK1-6时期" class="headerlink" title="4. JDK1.6时期"></a>4. JDK1.6时期</h2><p>当前最新的安全机制实现，则引入了<strong>域（Domain）</strong>的概念。</p><p>虚拟机会把所有代码加载到不同的系统域和应用域。系统域部分专门负责与关键资源进行交互，而各个应用域部分则通过系统域的部分代理来对各种需要的资源进行访问。虚拟机中不同的受保护域（Protected Domain），对应不一样的权限（Permission）。存在于不同域中的类文件就具有了当前域的全部权限，如下图所示，最新的安全模型（jdk1.6）</p><p><img src="C:/Users/George/Desktop/jdk1.6%E5%AE%89%E5%85%A8%E6%A8%A1%E5%9E%8B.png" alt="jdk1.6安全模型"></p><h1 id="七、自定义类的加载器"><a href="#七、自定义类的加载器" class="headerlink" title="七、自定义类的加载器"></a>七、自定义类的加载器</h1><h2 id="1-为什么要自定义类加载器？"><a href="#1-为什么要自定义类加载器？" class="headerlink" title="1. 为什么要自定义类加载器？"></a>1. 为什么要自定义类加载器？</h2><ul><li><p>隔离加载类</p><p>在某些框架内进行中间件与应用的模块隔离，把类加载到不同的环境。比如:阿里内某容器框架通过自定义类加载器确保应用中依赖的jar包不会影响到中间件运行时使用的jar包。再比如:Tomcat这类Web应用服务器，内部自定义了好几种类加载器，用于隔离同一个Web应用服务器上的不同应用程序。 </p></li><li><p>修改类加载的方式</p><p>类的加载模型并非强制，除Bootstrap外，其他的加载并非一定要引入，或者根据实际情况在某个时间点进行按需进行动态加载 </p></li><li><p>扩展加载源</p><p>比如从数据库、网络、甚至是电视机机顶盒进行加载 </p></li><li><p>防止源码泄漏</p><p>Java代码容易被编译和篡改，可以进行编译加密。那么类加载也需要自定义，还原加密的字节码。</p></li></ul><p><strong>常见的场景</strong></p><ul><li><p>实现类似进程内隔离，类加载器实际上用作不同的命名空间，以提供类似容器、模块化的效果。例如，两个模块依赖于某个类库的不同版本，如果分别被不同的容器加载，就可以互不干扰。这个方面的集大成者是JavaEE和OSGI、JPMS等框架。</p></li><li><p>应用需要从不同的数据源获取类定义信息，例如网络数据源，而不是本地文件系统。或者是需要自己操纵字节码，动态修改或者生成类型。</p></li></ul><p><strong>注意</strong></p><p>在一般情况下，使用不同的类加载器去加载不同的功能模块，会提高应用程序的安全性。但是，如果涉及Java类型转换，则加载器反而容易产生不美好的事情。在做Java类型转换时，只有两个类型都是由同一个加载器所加载，才能进行类型转换，否则转换时会发生异常。</p><h2 id="2-实现方式"><a href="#2-实现方式" class="headerlink" title="2. 实现方式"></a>2. 实现方式</h2><h3 id="2-1-方法概述"><a href="#2-1-方法概述" class="headerlink" title="2.1 方法概述"></a>2.1 方法概述</h3><p>Java提供了抽象类java.lang.ClassLoader，<strong>所有用户自定义的类加载器都应该继承ClassLoader类</strong>。</p><p>在自定义ClassLoader的子类时候，我们常见的会有两种做法:</p><ul><li><p>方式一:重写loadClass()方法</p></li><li><p>方式二:重写findclass()方法</p></li></ul><p><strong>对比</strong></p><ul><li>这两种方法本质上差不多，毕竟loadClass()也会调用findClass()，但是从逻辑上讲我们最好不要直接修改loadClass()的内部逻辑。建议的做法是只在findClass()里重写自定义类的加载方法，根据参数指定类的名字，返回对应的Class对象的引用。</li><li>loadclass()这个方法是实现双亲委派模型逻辑的地方，擅自修改这个方法会导致模型被破坏，容易造成问题。因此我们最好是在双亲委派模型框架内进行小范围的改动，不破坏原有的稳定结构。同时，也避免了自己重写loadClass()方法的过程中必须写双亲委托的重复代码，从代码的复用性来看，不直接修改这个方法始终是比较好的选择。</li><li>当编写好自定义类加载器后，便可以在程序中调用loadClass()方法来实现类加载操作。</li></ul><p><strong>说明</strong></p><ul><li><p>其父类加载器是系统类加载器</p></li><li><p>JVM中的所有类加载都会使用java.lang.ClassLoader.loadClass(String)接口(自定义类加载器并重写java.lang.ClassLoader.loadClass(String)接口的除外)，连JDK的核心类库也不能例外。</p></li></ul><h3 id="2-2-代码示例"><a href="#2-2-代码示例" class="headerlink" title="2.2 代码示例"></a>2.2 代码示例</h3><p><strong>定义要加载的类和方法</strong></p><pre><code class="highlight java"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Demo1</span> &#123;    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">hot</span><span class="params">()</span> &#123;        System.out.println(<span class="string">&quot;OldDemo1----&gt;NEW CLASS&quot;</span>);    &#125;&#125;</code></pre><p>使用 <code>javac Demo1.java</code> 编译该类,并将编译后的生成的 .class 文件放到任意目录下.</p><p><strong>自定义类加载器</strong></p><pre><code class="highlight java"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">MyClassLoader</span> <span class="keyword">extends</span> <span class="title class_">ClassLoader</span> &#123;    <span class="keyword">private</span> String byteCodePath;    <span class="keyword">public</span> <span class="title function_">MyClassLoader</span><span class="params">(String byteCodePath)</span> &#123;        <span class="built_in">this</span>.byteCodePath = byteCodePath;    &#125;    <span class="keyword">public</span> <span class="title function_">MyClassLoader</span><span class="params">(ClassLoader parent, String byteCodePath)</span> &#123;        <span class="built_in">super</span>(parent);        <span class="built_in">this</span>.byteCodePath = byteCodePath;    &#125;    <span class="meta">@Override</span>    <span class="keyword">protected</span> Class&lt;?&gt; findClass(String className) <span class="keyword">throws</span> ClassNotFoundException &#123;        <span class="type">BufferedInputStream</span> <span class="variable">bis</span> <span class="operator">=</span> <span class="literal">null</span>;        <span class="type">ByteArrayOutputStream</span> <span class="variable">baos</span> <span class="operator">=</span> <span class="literal">null</span>;        <span class="keyword">try</span> &#123;            <span class="comment">//获取字节码文件的完整路径</span>            <span class="type">String</span> <span class="variable">fileName</span> <span class="operator">=</span> byteCodePath + className + <span class="string">&quot;.class&quot;</span>;            <span class="comment">//获取一个输入流</span>            bis = <span class="keyword">new</span> <span class="title class_">BufferedInputStream</span>(<span class="keyword">new</span> <span class="title class_">FileInputStream</span>(fileName));            <span class="comment">//获取一个输出流</span>            baos = <span class="keyword">new</span> <span class="title class_">ByteArrayOutputStream</span>();            <span class="comment">//具体读入数据并写出的过程</span>            <span class="type">int</span> len;            <span class="type">byte</span>[] data = <span class="keyword">new</span> <span class="title class_">byte</span>[<span class="number">1024</span>];            <span class="keyword">while</span> ((len = bis.read(data)) != -<span class="number">1</span>) &#123;                baos.write(data, <span class="number">0</span>, len);            &#125;            <span class="comment">//获取内存中的完整的字节数组的数据</span>            <span class="type">byte</span>[] byteCodes = baos.toByteArray();            <span class="comment">//调用defineClass()，将字节数组的数据转换为Class的实例。</span>            <span class="type">Class</span> <span class="variable">clazz</span> <span class="operator">=</span> defineClass(<span class="literal">null</span>, byteCodes, <span class="number">0</span>, byteCodes.length);            <span class="keyword">return</span> clazz;        &#125; <span class="keyword">catch</span> (IOException e) &#123;            e.printStackTrace();        &#125; <span class="keyword">finally</span> &#123;            <span class="keyword">try</span> &#123;                <span class="keyword">if</span> (baos != <span class="literal">null</span>)                    baos.close();            &#125; <span class="keyword">catch</span> (IOException e) &#123;                e.printStackTrace();            &#125;            <span class="keyword">try</span> &#123;                <span class="keyword">if</span> (bis != <span class="literal">null</span>)                    bis.close();            &#125; <span class="keyword">catch</span> (IOException e) &#123;                e.printStackTrace();            &#125;        &#125;        <span class="keyword">return</span> <span class="literal">null</span>;    &#125;&#125;</code></pre><p><strong>测试自定义类加载器</strong></p><pre><code class="highlight java"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">MyClassLoaderTest</span> &#123;    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;        <span class="type">MyClassLoader</span> <span class="variable">loader</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">MyClassLoader</span>(<span class="string">&quot;F:/&quot;</span>);        <span class="keyword">try</span> &#123;            <span class="type">Class</span> <span class="variable">clazz</span> <span class="operator">=</span> loader.loadClass(<span class="string">&quot;Demo1&quot;</span>);            System.out.println(<span class="string">&quot;加载此类的类的加载器为：&quot;</span> + clazz.getClassLoader().getClass().getName());            System.out.println(<span class="string">&quot;加载当前Demo1类的类的加载器的父类加载器为：&quot;</span> + clazz.getClassLoader().getParent().getClass().getName());            <span class="comment">// 创建运行时类的实例</span>            <span class="type">Object</span> <span class="variable">instance</span> <span class="operator">=</span> clazz.newInstance();            <span class="comment">//4. 获取运行时类中指定的方法</span>            <span class="type">Method</span> <span class="variable">m</span> <span class="operator">=</span> clazz.getMethod(<span class="string">&quot;hot&quot;</span>);            <span class="comment">//5. 调用指定的方法</span>            m.invoke(instance);        &#125; <span class="keyword">catch</span> (ClassNotFoundException e) &#123;            e.printStackTrace();        &#125; <span class="keyword">catch</span> (IllegalAccessException e) &#123;            e.printStackTrace();        &#125; <span class="keyword">catch</span> (InstantiationException e) &#123;            e.printStackTrace();        &#125; <span class="keyword">catch</span> (NoSuchMethodException e) &#123;            e.printStackTrace();        &#125; <span class="keyword">catch</span> (InvocationTargetException e) &#123;            e.printStackTrace();        &#125;    &#125;&#125;</code></pre><p><strong>启动测试类</strong></p><p>打印结果如下:</p><pre><code class="highlight shell">加载此类的类的加载器为：com.atguigu.java2.MyClassLoader加载当前Demo1类的类的加载器的父类加载器为：sun.misc.Launcher$AppClassLoader<span class="meta prompt_">OldDemo1----&gt;</span><span class="language-bash">NEW CLASS</span></code></pre><h1 id="八、Java9新特性"><a href="#八、Java9新特性" class="headerlink" title="八、Java9新特性"></a>八、Java9新特性</h1><p>为了保证兼容性，JDK9没有从根本上改变三层类加载器架构和双亲委派模型，但为了模块化系统的顺利运行，仍然发生了一些值得被注意的变动。</p><ol><li>扩展机制被移除，扩展类加载器由于向后兼容性的原因被保留，不过被重命名为平台类加载器(platform class loader)。可以通过classLoader的新方法getPlatformClassLoader()来获取。<br>  JDK9时基于模块化进行构建(原来的rt.jar和tools.jar被拆分成数十个JMOD文件)，其中的Java类库就已天然地满足了可扩展的需求，那自然无须再保留<JAVA_HOME>\lib\ext目录，此前使用这个目录或者java.ext.dirs系统变量来扩展JDK功能的机制已经没有继续存在的价值了。 </li><li>平台类加载器和应用程序类加载器都不再继承自java.net.URLClassLoader。<br>现在启动类加载器、平台类加载器、应用程序类加载器全都继承于jdk.internal.loader.BuiltinClassLoader。</li></ol><p><img src="https://raw.githubusercontent.com/GeorgeChan95/blogimg/master/img/2024/08/11/20240811-100028.png" alt="JDK9类加载器继承关系图"></p><p>​如果有程序直接依赖了这种继承关系，或者依赖了URLClassLoader类的特定方法，那代码很可能会在JDK9及更高版本的JDK中崩溃。</p><ol start="3"><li>在Java9中，类加载器有了名称。该名称在构造方法中指定，可以通过getName()方法来获取。平台类加载器的名称是platform，应用类加载器的名称是app。类加载器的名称在调试与类加载器相关的问题时会非常有用。</li><li>启动类加载器现在是在jvm内部和java类库共同协作实现的类加载器（以前是C++实现），但为了与之前代码兼容，在获取启动类加载器的场景中仍然会返回null，而不会得到BootClassLoader实例。</li><li>类加载的委派关系也发生了变动。当平台及应用程序类加载器收到类加载请求，在委派给父加载器加载前，要先判断该类是否能够归属到某一个系统模块中，如果可以找到这样的归属关系，就要优先委派给负责那个模块的加载器完成加载。</li></ol><p><img src="https://raw.githubusercontent.com/GeorgeChan95/blogimg/master/img/2024/08/11/20240811-100139.png" alt="JDK9双亲委派模式"></p><p><img src="https://raw.githubusercontent.com/GeorgeChan95/blogimg/master/img/2024/08/11/20240811-100236.png" alt="jdk9模块化1"></p><p><img src="https://raw.githubusercontent.com/GeorgeChan95/blogimg/master/img/2024/08/11/20240811-100301.png" alt="jdk9模块化2"></p><p><img src="https://raw.githubusercontent.com/GeorgeChan95/blogimg/master/img/2024/08/11/20240811-100347.png" alt="jdk9模块化3"></p><p><strong>示例代码：</strong></p><p>需要在JDK9环境下执行</p><pre><code class="highlight java"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ClassLoaderTest</span> &#123;    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;        System.out.println(ClassLoaderTest.class.getClassLoader());        System.out.println(ClassLoaderTest.class.getClassLoader().getParent());        System.out.println(ClassLoaderTest.class.getClassLoader().getParent().getParent());        <span class="comment">//获取系统类加载器</span>        System.out.println(ClassLoader.getSystemClassLoader());        <span class="comment">//获取平台类加载器</span>        System.out.println(ClassLoader.getPlatformClassLoader());        <span class="comment">//获取类的加载器的名称</span>        System.out.println(ClassLoaderTest.class.getClassLoader().getName());    &#125;&#125;</code></pre>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;&lt;strong&gt;以下内容关于类加载器都是基于 JDK8 讲解的, JDK9的类加载器与之不同&lt;/strong&gt;&lt;/p&gt;
&lt;h1 id=&quot;一、概述&quot;&gt;&lt;a href=&quot;#一、概述&quot; class=&quot;headerlink&quot; title=&quot;一、概述&quot;&gt;&lt;/a&gt;一、概述&lt;/h1&gt;&lt;p</summary>
      
    
    
    
    <category term="JVM" scheme="https://georgechan95.github.io/categories/JVM/"/>
    
    
    <category term="java" scheme="https://georgechan95.github.io/tags/java/"/>
    
    <category term="jvm" scheme="https://georgechan95.github.io/tags/jvm/"/>
    
  </entry>
  
  <entry>
    <title>第十九章-类的加载过程详解</title>
    <link href="https://georgechan95.github.io/blog/3387211378.html"/>
    <id>https://georgechan95.github.io/blog/3387211378.html</id>
    <published>2024-08-02T11:33:27.000Z</published>
    <updated>2024-08-28T04:17:33.365Z</updated>
    
    <content type="html"><![CDATA[<h1 id="一、概述"><a href="#一、概述" class="headerlink" title="一、概述"></a>一、概述</h1><p>在Java中数据类型分为基本数据类型和引用数据类型。<strong>基本数据类型由虚拟机预先定义，引用数据类型则需要进行类的加载。</strong></p><p>按照Java虚拟机规范，从class文件到加载到内存中的类，到类卸载出内存为止，它的整个生命周期包括如下7个阶段：</p><p><img src="https://raw.githubusercontent.com/GeorgeChan95/blogimg/master/img/2024/08/02/20240802-195737.png" alt="类的生命周期"></p><p>其中，验证、准备、解析3个部分统称为链接（Linking）</p><p>从程序中类的使用过程看</p><p><img src="https://raw.githubusercontent.com/GeorgeChan95/blogimg/master/img/2024/08/02/20240802-195857.png" alt="类的使用过程"></p><p><strong>注意: 我们所说的加载完毕包括：加载、链接、初始化三个阶段都完成之后类进入方法区中</strong></p><h1 id="二、过程一-Loading-加载-阶段"><a href="#二、过程一-Loading-加载-阶段" class="headerlink" title="二、过程一: Loading (加载)阶段"></a>二、过程一: Loading (加载)阶段</h1><h2 id="1-加载完成的操作"><a href="#1-加载完成的操作" class="headerlink" title="1. 加载完成的操作"></a>1. 加载完成的操作</h2><h3 id="1-1-加载的理解"><a href="#1-1-加载的理解" class="headerlink" title="1.1 加载的理解"></a>1.1 加载的理解</h3><p><strong>所谓加载，简而言之就是 JAVA类的字节码文件加载到机器内存中，并在内存中构建出JAVA类的原型——类模板对象。</strong></p><p>所谓类模板对象，其实就是Java类在]VM内存中的一个快照，JVM将从字节码文件中解析出的常量池、类字段、类方法等信息存储到类模板中，这样]VM在运行期便能通过类模板而获取Java类中的任意信息，能够对Java类的成员变量进行遍历，也能进行Java方法的调用。</p><p>反射的机制即基于这一基础。如果JVM没有将Java类的声明信息存储起来，则JVM在运行期也无法反射。</p><h3 id="1-2-加载完成的操作"><a href="#1-2-加载完成的操作" class="headerlink" title="1.2 加载完成的操作"></a>1.2 加载完成的操作</h3><p><strong>加载阶段，简言之，查找并加载类的二进制数据，生成Class的实例</strong></p><p>在加载类时，Java虚拟机必须完成以下3件事情：</p><ul><li>通过<em>类的全名</em>，获取类的二进制数据流。 </li><li>解析类的二进制数据流为方法区内的数据结构（Java类模型） </li><li>创建java.lang.Class类的实例，表示该类型。作为方法区这个类的各种数据的访问入口</li></ul><h2 id="2-二进制流的获取方式"><a href="#2-二进制流的获取方式" class="headerlink" title="2. 二进制流的获取方式"></a>2. 二进制流的获取方式</h2><p>对于类的二进制数据流，虚拟机可以通过多种途径产生或获得。（只要所读取的字节码符合JVM规范即可）</p><ul><li><p>虚拟机可能通过文件系统读入一个class后缀的文件（最常见)</p></li><li><p>读入jar、zip等归档数据包，提取类文件。</p></li><li><p>事先存放在数据库中的类的二进制数据</p></li><li><p>使用类似于HTTP之类的协议通过网络进行加载</p></li><li><p>在运行时生成一段class的二进制信息等</p></li><li><p>在获取到类的二进制信息后，Java虚拟机就会处理这些数据，并最终转为一个java.lang.Class的实例。</p></li></ul><p><strong>如果输入数据不是ClassFile的结构，则会抛出ClassFormatError。</strong></p><h2 id="3-类模型与Class实例的位置"><a href="#3-类模型与Class实例的位置" class="headerlink" title="3. 类模型与Class实例的位置"></a>3. 类模型与Class实例的位置</h2><h3 id="3-1-类模型的位置"><a href="#3-1-类模型的位置" class="headerlink" title="3.1 类模型的位置"></a>3.1 类模型的位置</h3><p><strong>加载的类在JVM中创建相应的类结构，类结构会存储在方法区</strong>（JDK1.8之前：永久代；JDK1.8及之后：元空间）。</p><h3 id="3-2-Class实例的位置"><a href="#3-2-Class实例的位置" class="headerlink" title="3.2 Class实例的位置"></a>3.2 Class实例的位置</h3><p>类将.class文件加载至元空间后，会<strong>在堆中创建一个Java.lang.Class 对象</strong>，用来封装类位于方法区内的数据结构，该Class对象是在加载类的过程中创建的，每个类都对应有一个Class类型的对象。</p><p><img src="https://raw.githubusercontent.com/GeorgeChan95/blogimg/master/img/2024/08/02/20240802-202716.png" alt="Class实例的位置"></p><p><strong>示例:</strong></p><p>通过Class类，获得了 java.lang.String 类的所有方法信息，并打印方法访问标识符、描述符</p><pre><code class="highlight java"><span class="comment">/**</span><span class="comment"> * 过程一：加载阶段</span><span class="comment"> *</span><span class="comment"> * 通过Class类，获得了java.lang.String类的所有方法信息，并打印方法访问标识符、描述符</span><span class="comment"> */</span><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">LoadingTest</span> &#123;    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;        <span class="keyword">try</span> &#123;            <span class="type">Class</span> <span class="variable">clazz</span> <span class="operator">=</span> Class.forName(<span class="string">&quot;java.lang.String&quot;</span>);            <span class="comment">//获取当前运行时类声明的所有方法</span>            Method[] ms = clazz.getDeclaredMethods();            <span class="keyword">for</span> (Method m : ms) &#123;                <span class="comment">//获取方法的修饰符</span>                <span class="type">String</span> <span class="variable">mod</span> <span class="operator">=</span> Modifier.toString(m.getModifiers());                System.out.print(mod + <span class="string">&quot; &quot;</span>);                <span class="comment">//获取方法的返回值类型</span>                <span class="type">String</span> <span class="variable">returnType</span> <span class="operator">=</span> m.getReturnType().getSimpleName();                System.out.print(returnType + <span class="string">&quot; &quot;</span>);                <span class="comment">//获取方法名</span>                System.out.print(m.getName() + <span class="string">&quot;(&quot;</span>);                <span class="comment">//获取方法的参数列表</span>                Class&lt;?&gt;[] ps = m.getParameterTypes();                <span class="keyword">if</span> (ps.length == <span class="number">0</span>) System.out.print(<span class="string">&#x27;)&#x27;</span>);                <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; ps.length; i++) &#123;                    <span class="type">char</span> <span class="variable">end</span> <span class="operator">=</span> (i == ps.length - <span class="number">1</span>) ? <span class="string">&#x27;)&#x27;</span> : <span class="string">&#x27;,&#x27;</span>;                    <span class="comment">//获取参数的类型</span>                    System.out.print(ps[i].getSimpleName() + end);                &#125;                System.out.println();            &#125;        &#125; <span class="keyword">catch</span> (ClassNotFoundException e) &#123;            e.printStackTrace();        &#125;    &#125;&#125;</code></pre><h2 id="4-数组类的加载"><a href="#4-数组类的加载" class="headerlink" title="4. 数组类的加载"></a>4. 数组类的加载</h2><p>创建数组类的情况稍微有些特殊，因为数组类本身并不是由类加载器负责创建，而是由JVM在运行时根据需要而直接创建的，但数组的元素类型仍然需要依靠类加载器去创建。创建数组类（下述简称A）的过程：</p><ul><li><p>如果数组的元素类型是引用类型，那么就遵循定义的加载过程递归加载和创建数组A的元素类型；</p></li><li><p>JVM使用指定的元素类型和数组维度来创建新的数组类。</p></li></ul><p>如果数组的元素类型是引用类型，数组类的可访问性就由元素类型的可访问性决定。否则数组类的可访问性将被缺省定义为public。</p><p><strong>详细解析:</strong></p><ol><li><strong>数组类的创建方式</strong>：<ul><li>与普通类不同，数组类不是由类加载器（ClassLoader）创建的。</li><li>数组类是由JVM（Java虚拟机）在运行时根据需要直接创建的。</li></ul></li><li><strong>数组元素类型的依赖</strong>：<ul><li>尽管数组类本身由JVM直接创建，数组的元素类型仍然需要类加载器来加载和创建。</li></ul></li><li><strong>创建数组类的具体过程</strong>：<ul><li>引用类型元素：<ul><li>如果数组的元素是引用类型（例如对象），则按照Java类加载的常规流程递归地加载和创建这些元素类型。</li><li>比如，创建一个<code>String</code>类型数组，JVM会首先确保<code>String</code>类已经加载。</li></ul></li><li>JVM创建数组类：<ul><li>JVM根据指定的元素类型和数组的维度来创建新的数组类。</li><li>例如，对于一个二维整型数组<code>int[][]</code>，JVM会创建一个包含整型的二维数组类。</li></ul></li></ul></li><li><strong>数组类的可访问性</strong>：<ul><li>引用类型元素：<ul><li>如果数组的元素类型是引用类型，则数组类的可访问性由元素类型的可访问性决定。</li><li>比如，如果一个数组包含的元素类是<code>private</code>的，那么这个数组类也会是<code>private</code>的。</li></ul></li><li>基本类型元素：<ul><li>如果数组的元素类型是基本类型（如<code>int</code>、<code>char</code>），数组类的可访问性默认为<code>public</code>。</li></ul></li></ul></li></ol><h1 id="三、过程二-Linking-链接-阶段"><a href="#三、过程二-Linking-链接-阶段" class="headerlink" title="三、过程二: Linking (链接)阶段"></a>三、过程二: Linking (链接)阶段</h1><h2 id="1-环节1：链接阶段之Verification（验证）"><a href="#1-环节1：链接阶段之Verification（验证）" class="headerlink" title="1. 环节1：链接阶段之Verification（验证）"></a>1. 环节1：链接阶段之Verification（验证）</h2><p>当类加载到系统后，就开始链接操作，验证是链接操作的第一步。</p><p><strong>它的目的是保证加载的字节码是合法、合理并符合规范的.</strong></p><p>验证的步骤比较复杂，实际要验证的项目也很繁多，大体上Java虚拟机需要做以下检查，如图所示。</p><p><img src="https://raw.githubusercontent.com/GeorgeChan95/blogimg/master/img/2024/08/07/20240807-082017.png" alt="验证"></p><h3 id="1-1-整体说明"><a href="#1-1-整体说明" class="headerlink" title="1.1 整体说明"></a>1.1 整体说明</h3><p>验证的内容则涵盖了类数据信息的格式验证、语义检查、字节码验证，以及符号引用验证等。</p><ul><li><strong>其中格式验证会和加载阶段一起执行。</strong>验证通过之后，类加载器才会成功将类的二进制数据信息加载到方法区中。</li><li><strong>格式验证之外的验证操作将会在方法区中进行。</strong>(这是因为类数据模板已经被加载到方法区了)</li></ul><p>链接阶段的验证虽然拖慢了加载速度，但是它避免了在字节码运行时还需要进行各种检查。（磨刀不误砍柴工）</p><h3 id="1-2-具体说明"><a href="#1-2-具体说明" class="headerlink" title="1.2 具体说明"></a>1.2 具体说明</h3><ul><li><p>格式验证：是否以魔数<code>0XCAFEBABE</code>开头，主版本和副版本号是否在当前Java虚拟机的支持范围内，数据中每一个项是否都拥有正确的长度等。 </p></li><li><p>语义检查：Java虚拟机会进行字节码的语义检查，但凡在语义上不符合规范的，虚拟机也不会给予验证通过。比如： </p></li><li><ul><li>是否所有的类都有父类的存在（在Java里，除了object外，其他类都应该有父类）</li></ul></li><li><ul><li>是否一些被定义为final的方法或者类被重写或继承了</li></ul></li><li><ul><li>非抽象类是否实现了所有抽象方法或者接口方法</li></ul></li><li><p>字节码验证：Java虚拟机还会进行字节码验证，<strong>字节码验证也是验证过程中最为复杂的一个过程。</strong>它试图通过对字节码流的分析，判断字节码是否可以被正确地执行。比如： </p><ul><li>在字节码的执行过程中，是否会跳转到一条不存在的指令</li><li>函数的调用是否传递了正确类型的参数</li><li>变量的赋值是不是给了正确的数据类型等</li></ul><p>栈映射帧（StackMapTable）就是在这个阶段，用于检测在特定的字节码处，其局部变量表和操作数栈是否有着正确的数据类型。但遗憾的是，100%准确地判断一段字节码是否可以被安全执行是无法实现的，因此，该过程只是尽可能地检查出可以预知的明显的问题。如果在这个阶段无法通过检查，虚拟机也不会正确装载这个类。但是，如果通过了这个阶段的检查，也不能说明这个类是完全没有问题的。</p><p><strong>在前面3次检查中，已经排除了文件格式错误、语义错误以及字节码的不正确性。但是依然不能确保类是没有问题的。</strong></p></li><li><p>符号引用的验证：校验器还将进符号引用的验证。Class文件在其常量池会通过字符串记录自己将要使用的其他类或者方法。因此，在验证阶段，虚拟机就会检查这些类或者方法确实是存在的，并且当前类有权限访问这些数据，如果一个需要使用类无法在系统中找到，则会抛出NoClassDefFoundError，如果一个方法无法被找到，则会抛出NoSuchMethodError。此阶段在解析环节才会执行。</p></li></ul><h2 id="2-环节2：链接阶段之Preparation（准备）"><a href="#2-环节2：链接阶段之Preparation（准备）" class="headerlink" title="2. 环节2：链接阶段之Preparation（准备）"></a>2. 环节2：链接阶段之Preparation（准备）</h2><p>准备阶段（Preparation），简言之，为类的静态变量分配内存，并将其初始化为默认值。</p><p>当一个类验证通过时，虚拟机就会进入准备阶段。在这个阶段，虚拟机就会为这个类分配相应的内存空间，并设置默认初始值。Java虚拟机为各类型变量默认的初始值如表所示。</p><table><thead><tr><th>类型</th><th>默认初始值</th></tr></thead><tbody><tr><td>byte</td><td>(byte)0</td></tr><tr><td>short</td><td>(short)0</td></tr><tr><td>int</td><td>0</td></tr><tr><td>long</td><td>0L</td></tr><tr><td>float</td><td>0.0f</td></tr><tr><td>double</td><td>0.0</td></tr><tr><td>char</td><td>\u0000</td></tr><tr><td>boolean</td><td>false</td></tr><tr><td>reference</td><td>null</td></tr></tbody></table><p>Java并不支持boolean类型，对于boolean类型，内部实现是int，由于int的默认值是0，故对应的，boolean的默认值就是false。</p><p><strong>注意</strong></p><ul><li><p><strong>这里不包含基本数据类型的字段用staticfinal修饰的情况，因为final在编译的时候就会分配了，准备阶段会显式赋值。</strong></p><pre><code class="highlight java"><span class="comment">// 一般情况：static final修饰的基本数据类型、字符串类型字面量会在准备阶段赋值</span><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">String</span> <span class="variable">str</span> <span class="operator">=</span> <span class="string">&quot;Hello world&quot;</span>;<span class="comment">// 特殊情况：static final修饰的引用类型不会在准备阶段赋值，而是在初始化阶段赋值</span><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">String</span> <span class="variable">str</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">String</span>(<span class="string">&quot;Hello world&quot;</span>);</code></pre></li><li><p>注意这里不会为实例变量分配初始化，类变量会分配在方法区中，而实例变量是会随着对象一起分配到Java堆中。 </p></li><li><p>在这个阶段并不会像初始化阶段中那样会有初始化或者代码被执行。</p></li><li><p>准备环节不会有代码执行，只是进行非final的数据类型的初始值赋值</p></li></ul><p><strong>注意：以下前3点的前提都是字段已经完成显示赋值（定义的后面已经赋了值）的前提下进行的</strong><br>1、非final修饰的静态变量会在准备阶段赋初始值，然后在初始化中的<clinit>方法中显示赋值<br>2、静态常量（基本数据类型、String类型字面量（”XXX”这种情况））在编译阶段会初始化赋值，然后在准备阶段就会显示赋值<br>3、引用数据类型的静态常量，尤其是new String(“XXX”)这种形式，都是在初始化中的<clinit>中进行显示赋值的<br>4、如果在static静态代码块中具有显示赋值操作（定义的后面没有赋值），那肯定就是在初始化中的<clinit>方法中显示赋值</p><h2 id="3-环节3：链接阶段之Resolution（解析）"><a href="#3-环节3：链接阶段之Resolution（解析）" class="headerlink" title="3. 环节3：链接阶段之Resolution（解析）"></a>3. 环节3：链接阶段之Resolution（解析）</h2><p>在准备阶段完成后，就进入了解析阶段。解析阶段（Resolution），简言之，将类、接口、字段和方法的符号引用转为直接引用。</p><p><strong>具体描述</strong>：</p><p>符号引用就是一些字面量的引用，和虚拟机的内部数据结构和和内存布局无关。比较容易理解的就是在Class类文件中，通过常量池进行了大量的符号引用。但是在程序实际运行时，只有符号引用是不够的，比如当如下println()方法被调用时，系统需要明确知道该方法的位置。</p><p><strong>举例</strong>：</p><p>输出操作System.out.println()对应的字节码：</p><pre><code class="highlight txt">invokevirtual #24 &lt;java/io/PrintStream.println&gt;</code></pre><p><img src="https://raw.githubusercontent.com/GeorgeChan95/blogimg/master/img/2024/08/07/20240807-092933.png" alt="符号引用"></p><p>以方法为例，Java虚拟机为每个类都准备了一张方法表，将其所有的方法都列在表中，当需要调用一个类的方法的时候，只要知道这个方法在方法表中的偏移量就可以直接调用该方法。<br>通过解析操作，符号引用就可以转变为目标方法在类中方法表中的位置，从而使得方法被成功调用。</p><h1 id="四、过程三-Initialization-初始化-阶段"><a href="#四、过程三-Initialization-初始化-阶段" class="headerlink" title="四、过程三: Initialization (初始化)阶段"></a>四、过程三: Initialization (初始化)阶段</h1><h2 id="1-static与final的搭配问题"><a href="#1-static与final的搭配问题" class="headerlink" title="1. static与final的搭配问题"></a>1. static与final的搭配问题</h2><p><strong>说明</strong>：使用static+ final修饰的字段的显式赋值的操作，到底是在哪个阶段进行的赋值？</p><ul><li><p>情况1：在链接阶段的准备环节赋值 </p></li><li><p>情况2：在初始化阶段<clinit>()中赋值</p></li></ul><p><strong>结论</strong>： 在<strong>链接阶段</strong>的准备环节赋值的情况：</p><ul><li><p>对于基本数据类型的字段来说，如果使用static final修饰，则显式赋值(直接赋值常量，而非调用方法)通常是在链接阶段的准备环节进行 </p></li><li><p>对于String来说，如果使用字面量的方式赋值，使用static final修饰的话，则显式赋值通常是在链接阶段的准备环节进行 </p></li><li><p>在初始化阶段<clinit>()中赋值的情况： 排除上述的在准备环节赋值的情况之外的情况。</p></li></ul><pre><code class="highlight java"><span class="keyword">public</span> <span class="keyword">static</span> <span class="type">int</span> <span class="variable">a</span> <span class="operator">=</span> <span class="number">1</span>;<span class="comment">//在初始化阶段&lt;clinit&gt;()中赋值</span><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">int</span> <span class="variable">INT_CONSTANT</span> <span class="operator">=</span> <span class="number">10</span>;<span class="comment">//在链接阶段的准备环节赋值</span><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">Integer</span> <span class="variable">INTEGER_CONSTANT1</span> <span class="operator">=</span> Integer.valueOf(<span class="number">100</span>);<span class="comment">//在初始化阶段&lt;clinit&gt;()中赋值</span><span class="keyword">public</span> <span class="keyword">static</span> <span class="type">Integer</span> <span class="variable">INTEGER_CONSTANT2</span> <span class="operator">=</span> Integer.valueOf(<span class="number">1000</span>);<span class="comment">//在初始化阶段&lt;clinit&gt;()中赋值</span><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">String</span> <span class="variable">s0</span> <span class="operator">=</span> <span class="string">&quot;helloworld0&quot;</span>;<span class="comment">//在链接阶段的准备环节赋值</span><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">String</span> <span class="variable">s1</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">String</span>(<span class="string">&quot;helloworld1&quot;</span>);<span class="comment">//在初始化阶段&lt;clinit&gt;()中赋值</span><span class="keyword">public</span> <span class="keyword">static</span> <span class="type">String</span> <span class="variable">s2</span> <span class="operator">=</span> <span class="string">&quot;helloworld2&quot;</span>; <span class="comment">// 在初始化阶段&lt;clinit&gt;()中赋值</span><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">int</span> <span class="variable">NUM1</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Random</span>().nextInt(<span class="number">10</span>);<span class="comment">//在初始化阶段&lt;clinit&gt;()中赋值</span></code></pre><p><strong>最终结论：使用static+final修饰，且显式赋值中不涉及到方法或构造器调用的基本数据类到或String类型的显式赋值，是在链接阶段的准备环节进行。</strong></p><p>对于准备阶段就完成赋值的，其字段下面的有属性ConstantValue，否则是没有属性ConstantValue的，如下：</p><p><img src="https://raw.githubusercontent.com/GeorgeChan95/blogimg/master/img/2024/08/08/20240808-125400.png" alt="准备阶段完成赋值"></p><p>在初始化中的<clinit>方法中完成赋值的，引用类型静态常量的例子我就不举了，我举一个静态变量的例子吧，如下：</p><p><img src="https://raw.githubusercontent.com/GeorgeChan95/blogimg/master/img/2024/08/08/20240808-125608.png" alt="clinit"></p><h2 id="2-clinit-的线程安全性"><a href="#2-clinit-的线程安全性" class="headerlink" title="2. clinit 的线程安全性"></a>2. clinit 的线程安全性</h2><p>对于 <code>&lt;clinit&gt;()</code> 方法的调用，也就是类的初始化，虚拟机会在内部确保其多线程环境中的安全性。</p><p>虚拟机会保证一个类的 <code>&lt;clinit&gt;()</code> 方法在多线程环境中被正确地加锁、同步，如果多个线程同时去初始化一个类，那么只会有一个线程去执行这个类的 <code>&lt;clinit&gt;()</code> 方法，其他线程都需要阻塞等待，直到活动线程执行 <code>&lt;clinit&gt;()</code> 方法完毕。</p><p>正是因为函数 <code>&lt;clinit&gt;()</code> 带锁线程安全的，因此，如果在一个类的 <code>&lt;clinit&gt;()</code> 方法中有耗时很长的操作，就可能造成多个线程阻塞，引发死锁。并且这种死锁是很难发现的，因为看起来它们并没有可用的锁信息。</p><p>如果之前的线程成功加载了类，则等在队列中的线程就没有机会再执行 <code>&lt;clinit&gt;()</code> 方法了。那么，当需要使用这个类时，虚拟机会直接返回给它已经准备好的信息。(这也说明了类的初始化只会执行一次)</p><h2 id="3-类的初始化情况：主动使用vs被动使用"><a href="#3-类的初始化情况：主动使用vs被动使用" class="headerlink" title="3. 类的初始化情况：主动使用vs被动使用"></a>3. 类的初始化情况：主动使用vs被动使用</h2><p>Java程序对类的使用分为两种：主动使用和被动使用。</p><h3 id="3-1-主动使用"><a href="#3-1-主动使用" class="headerlink" title="3.1 主动使用"></a>3.1 主动使用</h3><p>Class只有在必须要首次使用的时候才会被装载，Java虚拟机不会无条件地装载Class类型。Java虚拟机规定，一个类或接口在初次使用前，必须要进行初始化。这里指的“使用”，是指主动使用，主动使用只有下列几种情况：（即：如果出现如下的情况，则会对类进行初始化操作。而初始化操作之前的加载、验证、准备已经完成。</p><ul><li><p><strong>实例化</strong>：当创建一个类的实例时，比如使用new关键字，或者通过反射、克隆、反序列化。 </p><pre><code class="highlight java"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ActiveUse1</span> &#123;    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;        <span class="comment">// 1. 使用new关键字</span>        <span class="type">Order</span> <span class="variable">order</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Order</span>();    &#125;    <span class="comment">/**</span><span class="comment">     * 2. 使用new关键字</span><span class="comment">     * 序列化的过程</span><span class="comment">     */</span>    <span class="meta">@Test</span>    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">test1</span><span class="params">()</span> &#123;        <span class="type">ObjectOutputStream</span> <span class="variable">oos</span> <span class="operator">=</span> <span class="literal">null</span>;        <span class="keyword">try</span> &#123;            oos = <span class="keyword">new</span> <span class="title class_">ObjectOutputStream</span>(<span class="keyword">new</span> <span class="title class_">FileOutputStream</span>(<span class="string">&quot;order.dat&quot;</span>));            oos.writeObject(<span class="keyword">new</span> <span class="title class_">Order</span>());        &#125; <span class="keyword">catch</span> (IOException e) &#123;            e.printStackTrace();        &#125; <span class="keyword">finally</span> &#123;            <span class="keyword">try</span> &#123;                <span class="keyword">if</span> (oos != <span class="literal">null</span>)                    oos.close();            &#125; <span class="keyword">catch</span> (IOException e) &#123;                e.printStackTrace();            &#125;        &#125;    &#125;    <span class="comment">/**</span><span class="comment">     * 3.反序列化的过程：（验证）</span><span class="comment">     */</span>    <span class="meta">@Test</span>    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">test2</span><span class="params">()</span> &#123;        <span class="type">ObjectInputStream</span> <span class="variable">ois</span> <span class="operator">=</span> <span class="literal">null</span>;        <span class="keyword">try</span> &#123;            ois = <span class="keyword">new</span> <span class="title class_">ObjectInputStream</span>(<span class="keyword">new</span> <span class="title class_">FileInputStream</span>(<span class="string">&quot;order.dat&quot;</span>));            <span class="type">Order</span> <span class="variable">order</span> <span class="operator">=</span> (Order) ois.readObject();        &#125; <span class="keyword">catch</span> (IOException e) &#123;            e.printStackTrace();        &#125; <span class="keyword">catch</span> (ClassNotFoundException e) &#123;            e.printStackTrace();        &#125; <span class="keyword">finally</span> &#123;            <span class="keyword">try</span> &#123;                <span class="keyword">if</span> (ois != <span class="literal">null</span>)                    ois.close();            &#125; <span class="keyword">catch</span> (IOException e) &#123;                e.printStackTrace();            &#125;        &#125;    &#125;&#125;<span class="keyword">class</span> <span class="title class_">Order</span> <span class="keyword">implements</span> <span class="title class_">Serializable</span>&#123;    <span class="keyword">static</span> &#123;        System.out.println(<span class="string">&quot;Order类的初始化过程&quot;</span>);    &#125;    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">method</span><span class="params">()</span>&#123;        System.out.println(<span class="string">&quot;Order method()....&quot;</span>);    &#125;&#125;</code></pre></li><li><p><strong>静态方法</strong>：当调用类的静态方法时，即当使用了字节码invokestatic指令。 </p><pre><code class="highlight java"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ActiveUse1</span> &#123;    <span class="comment">/**</span><span class="comment">     * 4. 静态方法调用</span><span class="comment">     */</span>    <span class="meta">@Test</span>    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">test3</span><span class="params">()</span>&#123;        Order.method();    &#125;&#125;<span class="keyword">class</span> <span class="title class_">Order</span> <span class="keyword">implements</span> <span class="title class_">Serializable</span>&#123;    <span class="keyword">static</span> &#123;        System.out.println(<span class="string">&quot;Order类的初始化过程&quot;</span>);    &#125;    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">method</span><span class="params">()</span>&#123;        System.out.println(<span class="string">&quot;Order method()....&quot;</span>);    &#125;&#125;</code></pre></li><li><p><strong>静态字段</strong>：当使用类、接口的静态字段时（final修饰特殊考虑），比如，使用getstatic或者putstatic指令。（对应访问变量、赋值变量操作）</p><ul><li><p>类使用静态字段触发初始化</p><pre><code class="highlight java"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ActiveUse2</span> &#123;    <span class="meta">@Test</span>    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">test1</span><span class="params">()</span>&#123;        System.out.println(User.num); <span class="comment">// 执行了 User 的初始化</span>        System.out.println(User.num1); <span class="comment">// 不执行 User 的初始化, 因为num1为static final修饰的常量</span>        System.out.println(User.num2); <span class="comment">// 执行了 User 的初始化</span>    &#125;&#125;<span class="keyword">class</span> <span class="title class_">User</span>&#123;    <span class="keyword">static</span>&#123;        System.out.println(<span class="string">&quot;User类的初始化过程&quot;</span>);    &#125;    <span class="keyword">public</span> <span class="keyword">static</span> <span class="type">int</span> <span class="variable">num</span> <span class="operator">=</span> <span class="number">1</span>;    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">int</span> <span class="variable">num1</span> <span class="operator">=</span> <span class="number">2</span>;    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">int</span> <span class="variable">num2</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Random</span>().nextInt(<span class="number">10</span>);&#125;</code></pre></li><li><p>接口的初始化</p><pre><code class="highlight java"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ActiveUse2</span> &#123;    <span class="meta">@Test</span>    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">test2</span><span class="params">()</span>&#123;<span class="comment">//        System.out.println(CompareA.NUM1);</span>        System.out.println(CompareA.NUM2);    &#125;&#125;<span class="keyword">interface</span> <span class="title class_">CompareA</span>&#123;    <span class="comment">// 测试接口的初始化</span>    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">Thread</span> <span class="variable">t</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Thread</span>()&#123;        &#123;            System.out.println(<span class="string">&quot;CompareA的初始化&quot;</span>);        &#125;    &#125;;    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">int</span> <span class="variable">NUM1</span> <span class="operator">=</span> <span class="number">1</span>; <span class="comment">// 不经过clinit防范</span>    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">int</span> <span class="variable">NUM2</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Random</span>().nextInt(<span class="number">10</span>); <span class="comment">// 经过clinit方法,触发接口初始化</span>&#125;</code></pre></li></ul></li><li><p><strong>反射</strong>：当使用java.lang.reflect包中的方法反射类的方法时。比如：Class.forName(“com.atguigu.java.Test”) </p></li><li><p><strong>继承</strong>：当初始化子类时，如果发现其父类还没有进行过初始化，则需要先触发其父类的初始化。</p></li></ul><p>  当Java虚拟机初始化一个类时，要求它的所有父类都已经被初始化，但是这条规则并不适用于接口。可以使用 <code>-XX:+TraceClassLoading</code> 参数配置查看类加载路径</p><ul><li><p>在初始化一个类时，并不会先初始化它所实现的接口</p></li><li><p>在初始化一个接口时，并不会先初始化它的父接口</p></li><li><p>因此，一个父接口并不会因为它的子接口或者实现类的初始化而初始化。只有当程序首次使用特定接口的静态字段时，才会导致该接口的初始化。</p></li><li><p>default方法：如果一个接口定义了default方法，那么直接实现或者间接实现该接口的类的初始化，该接口要在其之前被初始化。 </p><pre><code class="highlight java"><span class="keyword">interface</span> <span class="title class_">CompareB</span> &#123;    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">Thread</span> <span class="variable">t</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Thread</span>() &#123;        &#123;            System.out.println(<span class="string">&quot;CompareB的初始化&quot;</span>);        &#125;    &#125;;    <span class="keyword">public</span> <span class="keyword">default</span> <span class="keyword">void</span> <span class="title function_">method1</span><span class="params">()</span>&#123;        System.out.println(<span class="string">&quot;你好！&quot;</span>);    &#125;&#125;<span class="keyword">class</span> <span class="title class_">Father</span> &#123;    <span class="keyword">static</span> &#123;        System.out.println(<span class="string">&quot;Father类的初始化过程&quot;</span>);    &#125;&#125;<span class="keyword">class</span> <span class="title class_">Son</span> <span class="keyword">extends</span> <span class="title class_">Father</span> <span class="keyword">implements</span> <span class="title class_">CompareB</span>&#123;    <span class="keyword">static</span> &#123;        System.out.println(<span class="string">&quot;Son类的初始化过程&quot;</span>);    &#125;    <span class="keyword">public</span> <span class="keyword">static</span> <span class="type">int</span> <span class="variable">num</span> <span class="operator">=</span> <span class="number">1</span>;&#125;<span class="meta">@Test</span><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">test2</span><span class="params">()</span> &#123;    System.out.println(Son.num);&#125;<span class="comment">// 打印结果:</span>Father类的初始化过程CompareB的初始化Son类的初始化过程<span class="number">1</span></code></pre></li><li><p>main方法：当虚拟机启动时，用户需要指定一个要执行的主类（包含main()方法的那个类），虚拟机会先初始化这个主类。</p></li></ul><p>  JVM启动的时候通过引导类加载器加载一个初始类。这个类在调用public static void main(String[])方法之前被链接和初始化。这个方法的执行将依次导致所需的类的加载，链接和初始化。</p><ul><li>MethodHandle：当初次调用MethodHandle实例时，初始化该MethodHandle指向的方法所在的类。（涉及解析REF getStatic、REF_putStatic、REF invokeStatic方法句柄对应的类）</li></ul><h3 id="3-2-被动使用"><a href="#3-2-被动使用" class="headerlink" title="3.2 被动使用"></a>3.2 被动使用</h3><p>除了以上的情况属于主动使用，其他的情况均属于被动使用。<strong>被动使用不会引起类的初始化</strong>。</p><p>也就是说：<strong>并不是在代码中出现的类，就一定会被加载或者初始化。</strong>如果不符合主动使用的条件，类就不会初始化。</p><ul><li><p><strong>静态字段</strong>：当通过子类引用父类的静态变量，不会导致子类初始化，只有真正声明这个字段的类才会被初始化。 </p><pre><code class="highlight java"><span class="keyword">class</span> <span class="title class_">Parent</span>&#123;    <span class="keyword">static</span>&#123;        System.out.println(<span class="string">&quot;Parent的初始化过程&quot;</span>);    &#125;    <span class="keyword">public</span> <span class="keyword">static</span> <span class="type">int</span> <span class="variable">num</span> <span class="operator">=</span> <span class="number">1</span>;&#125;<span class="keyword">class</span> <span class="title class_">Child</span> <span class="keyword">extends</span> <span class="title class_">Parent</span>&#123;    <span class="keyword">static</span>&#123;        System.out.println(<span class="string">&quot;Child的初始化过程&quot;</span>);    &#125;&#125;<span class="meta">@Test</span><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">test1</span><span class="params">()</span>&#123;    System.out.println(Child.num);&#125;<span class="comment">// 打印结果: </span>Parent的初始化过程<span class="number">1</span></code></pre></li><li><p><strong>数组定义</strong>：通过数组定义类引用，不会触发此类的初始化 </p><pre><code class="highlight java"><span class="meta">@Test</span><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">test2</span><span class="params">()</span>&#123;    Parent[] parents = <span class="keyword">new</span> <span class="title class_">Parent</span>[<span class="number">10</span>];    System.out.println(parents.getClass()); <span class="comment">// class [Lcom.atguigu.java1.Parent;</span>    System.out.println(parents.getClass().getSuperclass()); <span class="comment">// class java.lang.Object</span>    parents[<span class="number">0</span>] = <span class="keyword">new</span> <span class="title class_">Parent</span>(); <span class="comment">// Parent的初始化过程</span>    parents[<span class="number">1</span>] = <span class="keyword">new</span> <span class="title class_">Parent</span>(); <span class="comment">// 没有打印任何东西,类仅初始化一次</span>&#125;</code></pre></li><li><p><strong>引用常量</strong>：引用常量不会触发此类或接口的初始化。因为常量在链接阶段就已经被显式赋值了。 </p><pre><code class="highlight java"><span class="keyword">interface</span> <span class="title class_">SerialA</span>&#123;    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">Thread</span> <span class="variable">t</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Thread</span>() &#123;        &#123;            System.out.println(<span class="string">&quot;SerialA的初始化&quot;</span>);        &#125;    &#125;;    <span class="type">int</span> <span class="variable">ID</span> <span class="operator">=</span> <span class="number">1</span>; <span class="comment">// 接口中默认就是常量, 不需要初始化</span>    <span class="type">int</span> <span class="variable">ID1</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Random</span>().nextInt(<span class="number">10</span>); <span class="comment">//此时的赋值操作需要在&lt;clinit&gt;()中执行</span>&#125;<span class="meta">@Test</span><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">test2</span><span class="params">()</span>&#123;    System.out.println(SerialA.ID); <span class="comment">// 打印: 1, 没有触发接口初始化</span>    System.out.println(SerialA.ID1); <span class="comment">// 打印: SerialA的初始化, 触发接口初始化</span>&#125;</code></pre></li><li><p><strong>loadClass方法</strong>：调用ClassLoader类的loadClass()方法加载一个类，并不是对类的主动使用，不会导致类的初始化。 </p><pre><code class="highlight java"><span class="keyword">class</span> <span class="title class_">Person</span>&#123;    <span class="keyword">static</span>&#123;        System.out.println(<span class="string">&quot;Person类的初始化&quot;</span>);    &#125;    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">int</span> <span class="variable">NUM</span> <span class="operator">=</span> <span class="number">1</span>;<span class="comment">//在链接过程的准备环节就被赋值为1了。</span>    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">int</span> <span class="variable">NUM1</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Random</span>().nextInt(<span class="number">10</span>);<span class="comment">//此时的赋值操作需要在&lt;clinit&gt;()中执行</span>&#125;<span class="meta">@Test</span><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">test3</span><span class="params">()</span>&#123;    <span class="keyword">try</span> &#123;        <span class="type">Class</span> <span class="variable">clazz</span> <span class="operator">=</span> ClassLoader.getSystemClassLoader().loadClass(<span class="string">&quot;com.atguigu.java1.Person&quot;</span>);    &#125; <span class="keyword">catch</span> (ClassNotFoundException e) &#123;        e.printStackTrace();    &#125;&#125;</code></pre></li></ul><blockquote><p>**扩展: **  -XX:+TraceClassLoading：追踪打印类的加载信息</p></blockquote><h1 id="五、过程四-类的Using-使用"><a href="#五、过程四-类的Using-使用" class="headerlink" title="五、过程四: 类的Using (使用)"></a>五、过程四: 类的Using (使用)</h1><p>任何一个类型在使用之前都必须经历过完整的加载、链接和初始化3个类加载步骤。一旦一个类型成功经历过这3个步骤之后，便“厉事俱备只欠东风”，就等着开发者使用了。</p><p>开发人员可以在程序中访问和调用它的静态类成员信息（比如：静态字段、静态方法），或者使用new关键字为其创建对象实例。</p><h1 id="六、过程五-类的Unloading-卸载"><a href="#六、过程五-类的Unloading-卸载" class="headerlink" title="六、过程五: 类的Unloading (卸载)"></a>六、过程五: 类的Unloading (卸载)</h1><h2 id="1-类、类的加载器、类的实例之间的引用关系"><a href="#1-类、类的加载器、类的实例之间的引用关系" class="headerlink" title="1. 类、类的加载器、类的实例之间的引用关系"></a>1. 类、类的加载器、类的实例之间的引用关系</h2><p>在类加载器的内部实现中，用一个Java集合来存放所加载类的引用。另一方面，一个Class对象总是会引用它的类加载器，调用Class对象的getClassLoader()方法，就能获得它的类加载器。由此可见，代表某个类的Class实例与其类的加载器之间为双向关联关系。</p><p>一个类的实例总是引用代表这个类的Class对象。在Object类中定义了getClass()方法，这个方法返回代表对象所属类的Class对象的引用。此外，所有的java类都有一个静态属性class，它引用代表这个类的Class对象。</p><h2 id="2-类的生命周期"><a href="#2-类的生命周期" class="headerlink" title="2. 类的生命周期"></a>2. 类的生命周期</h2><p>当Sample类被加载、链接和初始化后，它的生命周期就开始了。当代表Sample类的Class对象不再被引用，即不可触及时，Class对象就会结束生命周期，Sample类在方法区内的数据也会被卸载，从而结束Sample类的生命周期。</p><p><strong>一个类何时结束生命周期，取决于代表它的Class对象何时结束生命周期。</strong></p><h2 id="3-具体例子"><a href="#3-具体例子" class="headerlink" title="3. 具体例子"></a>3. 具体例子</h2><p><img src="https://raw.githubusercontent.com/GeorgeChan95/blogimg/master/img/2024/08/08/20240808-193450.png" alt="类的卸载"></p><p>loader1变量和obj变量间接引用代表Sample类的Class对象，而objClass变量则直接引用它。</p><p>如果程序运行过程中，将上图左侧三个引用变量都置为null，此时Sample对象结束生命周期，MyClassLoader对象结束生命周期，代表Sample类的Class对象也结束生命周期，Sample类在方法区内的二进制数据被卸载。</p><p>当再次有需要时，会检查Sample类的Class对象是否存在，如果存在会直接使用，不再重新加载；如果不存在Sample类会被重新加载，在Java虚拟机的堆区会生成一个新的代表Sample类的Class实例（可以通过哈希码查看是否是同一个实例）</p><h2 id="4-类的卸载"><a href="#4-类的卸载" class="headerlink" title="4. 类的卸载"></a>4. 类的卸载</h2><ol><li>启动类加载器加载的类型在整个运行期间是不可能被卸载的（jvm和jls规范）</li><li>被系统类加载器和扩展类加载器加载的类型在运行期间不太可能被卸载，因为系统类加载器实例或者扩展类的实例基本上在整个运行期间总能直接或者间接的访问的到，其达到unreachable的可能性极小。</li><li>被开发者自定义的类加载器实例加载的类型只有在很简单的上下文环境中才能被卸载，而且一般还要借助于强制调用虚拟机的垃圾收集功能才可以做到。可以预想，稍微复杂点的应用场景中（比如：很多时候用户在开发自定义类加载器实例的时候采用缓存的策略以提高系统性能），被加载的类型在运行期间也是几乎不太可能被卸载的（至少卸载的时间是不确定的）。</li></ol><p>综合以上三点，一个已经加载的类型被卸载的几率很小至少被卸载的时间是不确定的。同时我们可以看的出来，开发者在开发代码时候，不应该对虚拟机的类型卸载做任何假设的前提下，来实现系统中的特定功能。</p><h2 id="回顾：方法区的垃圾回收"><a href="#回顾：方法区的垃圾回收" class="headerlink" title="回顾：方法区的垃圾回收"></a>回顾：方法区的垃圾回收</h2><p>方法区的垃圾收集主要回收两部分内容：<strong>常量池中废弃的常量和不再使用的类型</strong>。</p><p>HotSpot虚拟机对常量池的回收策略是很明确的，只要常量池中的常量没有被任何地方引用，就可以被回收。</p><p>判定一个常量是否“废弃”还是相对简单，而要判定一个类型是否属于“不再使用的类”的条件就比较苛刻了。需要同时满足下面三个条件：</p><ul><li><p>该类所有的实例都已经被回收。也就是Java堆中不存在该类及其任何派生子类的实例。</p></li><li><p>加载该类的类加载器已经被回收。这个条件除非是经过精心设计的可替换类加载器的场景，如OSGi、JSP的重加载等，否则通常是很难达成的。</p></li><li><p>该类对应的java.lang.Class对象没有在任何地方被引用，无法在任何地方通过反射访问该类的方法.</p></li></ul><p>Java虚拟机被允许对满足上述三个条件的无用类进行回收，这里说的仅仅是“被允许”，而并不是和对象一样，没有引用了就必然会回收。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;一、概述&quot;&gt;&lt;a href=&quot;#一、概述&quot; class=&quot;headerlink&quot; title=&quot;一、概述&quot;&gt;&lt;/a&gt;一、概述&lt;/h1&gt;&lt;p&gt;在Java中数据类型分为基本数据类型和引用数据类型。&lt;strong&gt;基本数据类型由虚拟机预先定义，引用数据类型则需要进行类的</summary>
      
    
    
    
    <category term="JVM" scheme="https://georgechan95.github.io/categories/JVM/"/>
    
    
    <category term="java" scheme="https://georgechan95.github.io/tags/java/"/>
    
    <category term="jvm" scheme="https://georgechan95.github.io/tags/jvm/"/>
    
  </entry>
  
  <entry>
    <title>第十八章-字节码指令集与解析指令</title>
    <link href="https://georgechan95.github.io/blog/1107503247.html"/>
    <id>https://georgechan95.github.io/blog/1107503247.html</id>
    <published>2024-07-31T17:40:02.000Z</published>
    <updated>2024-08-28T04:17:33.369Z</updated>
    
    <content type="html"><![CDATA[<h1 id="一、概述"><a href="#一、概述" class="headerlink" title="一、概述"></a>一、概述</h1><ul><li>java字节码对于虚拟机，就好像汇编语言对于计算机，属于基本执行指令。</li><li>Java 虚拟机的指令由一个字节长度的、代表着某种特定操作含义的数字(称为操作码，Opcode)以及跟随其后的零至多个代表此操作所需参数(称为操作数, Operands而构成。由于 Java 虚拟机采用面向操作数栈而不是寄存器的结构，所以大多数的指令都不包含操作数，只有一个操作码。</li><li>由于限制了 Java 虚拟机操作码的长度为一个字节(即 0~255)，这意味着指令集的操作码总数不可能超过256 条。</li><li>官方文档:<a href="https://docs.oracle.com/javase/specs/jvms/se8/html/jvms-6.html">https://docs.oracle.com/javase/specs/jvms/se8/html/jvms-6.html</a></li><li>熟悉虚拟机的指令对于动态字节码生成、反编译class文件、Class文件修补都有着非常重要的价值。因此，阅读字节码作为了解 Java 虚拟机的基础技能，需要熟练掌握常见指令。</li></ul><h2 id="1-执行模型"><a href="#1-执行模型" class="headerlink" title="1. 执行模型"></a>1. 执行模型</h2><p>如果不考虑异常处理的话，那么Java虚拟机的解释器可以使用下面这个伪代码当做最基本的执行模型来理解</p><pre><code class="highlight java"><span class="keyword">do</span>&#123;    自动计算PC寄存器的值加<span class="number">1</span>;    根据PC寄存器的指示位置，从字节码流中取出操作码;    <span class="keyword">if</span>(字节码存在操作数) 从字节码流中取出操作数;    执行操作码所定义的操作;&#125;<span class="keyword">while</span>(字节码长度&gt;<span class="number">0</span>);</code></pre><h2 id="2-字节码与数据类型"><a href="#2-字节码与数据类型" class="headerlink" title="2. 字节码与数据类型"></a>2. 字节码与数据类型</h2><p>在Java虚拟机的指令集中，大多数的指令都包含了其操作所对应的数据类型信息。例如，iload指令用于从局部变量表中加载int型的数据到操作数栈中，而fload指令加载的则是float类型的数据。</p><p>对于大部分与数据类型相关的字节码指令，它们的操作码助记符中都有特殊的字符来表明专门为哪种数据类型服务：</p><ul><li><p>i代表对int类型的数据操作，</p></li><li><p>l代表long</p></li><li><p>s代表short</p></li><li><p>b代表byte</p></li><li><p>c代表char</p></li><li><p>f代表float</p></li><li><p>d代表double</p></li></ul><p>也有一些指令的助记符中没有明确地指明操作类型的字母，如arraylength指令，它没有代表数据类型的特殊字符，但操作数永远只能是一个数组类型的对象。</p><p>还有另外一些指令，如无条件跳转指令goto则是与数据类型无关的。</p><p>大部分的指令都没有支持整数类型byte、char和short，甚至没有任何指令支持boolean类型。编译器会在编译期或运行期将byte和short类型的数据带符号扩展（Sign-Extend）为相应的int类型数据，将boolean和char类型数据零位扩展（Zero-Extend）为相应的int类型数据。与之类似，在处理boolean、byte、short和char类型的数组时，也会转换为使用对应的int类型的字节码指令来处理。因此，大多数对于boolean、byte、short和char类型数据的操作，实际上都是使用相应的int类型作为运算类型。</p><h2 id="3-指令分析"><a href="#3-指令分析" class="headerlink" title="3. 指令分析"></a>3. 指令分析</h2><p>由于完全介绍和学习这些指令需要花费大量时间。为了让大家能够更快地熟悉和了解这些基本指令，这里将JVM中的字节码指令集按用途大致分成9类。</p><ul><li><p>加载与存储指令</p></li><li><p>算术指令</p></li><li><p>类型转换指令</p></li><li><p>对象的创建与访问指令</p></li><li><p>方法调用与返回指令</p></li><li><p>操作数栈管理指令</p></li><li><p>比较控制指令</p></li><li><p>异常处理指令</p></li><li><p>同步控制指令</p></li></ul><p>（说在前面）在做值相关操作时：</p><ul><li><p>一个指令，可以从局部变量表、常量池、堆中对象、方法调用、系统调用中等取得数据，这些数据（可能是值，可能是对象的引用）被压入操作数栈。</p></li><li><p>一个指令，也可以从操作数栈中取出一到多个值（pop多次），完成赋值、加减乘除、方法传参、系统调用等等操作。</p></li></ul><h1 id="二、加载与存储指令"><a href="#二、加载与存储指令" class="headerlink" title="二、加载与存储指令"></a>二、加载与存储指令</h1><h2 id="1-作用"><a href="#1-作用" class="headerlink" title="1. 作用"></a>1. 作用</h2><p>加载和存储指令用于将数据从栈帧的局部变量表和操作数栈之间来回传递。</p><h2 id="2-常用指令"><a href="#2-常用指令" class="headerlink" title="2. 常用指令"></a>2. 常用指令</h2><ol><li>【局部变量压栈指令】将一个局部变量加载到操作数栈：xload、xload_<n>（其中x为i、l、f、d、a，n为0到3）</li><li>【常量入栈指令】将一个常量加载到操作数栈：bipush、sipush、ldc、ldc_w、ldc2_w、aconst_null、iconst_m1、iconst_<i>、lconst_<l>、fconst_<f>、dconst_<d></li><li>【出栈装入局部变量表指令】将一个数值从操作数栈存储到局部变量表：xstore、xstore_<n>（其中x为i、l、f、d、a，n为0到3）；xastore（其中x为i、l、f、d、a、b、c、s）</li><li>扩充局部变量表的访问索引的指令：wide。</li></ol><p>上面所列举的指令助记符中，有一部分是以尖括号结尾的（例如iload_<n>）。这些指令助记符实际上代表了一组指令（例如iload_<n>代表了<code>iload_0、iload_1、iload_2</code>和<code>iload_3</code>这几个指令）。这几组指令都是某个带有一个操作数的通用指令（例如iload）的特殊形式，对于这若干组特殊指令来说，它们表面上没有操作数，不需要进行取操作数的动作，但操作数都隐含在指令中。</p><p>除此之外，它们的语义与原生的通用指令完全一致（例如<code>iload_0</code>的语义与操作数为0时的iload指令语义完全一致）。在尖括号之间的字母指定了指令隐含操作数的数据类型，<n>代表非负的整数，<i>代表是int类型数据，<l>代表long类型，<f>代表float类型，<d>代表double类型。</p><p>操作byte、char、short和boolean类型数据时，经常用int类型的指令来表示。</p><h2 id="3-再谈操作数栈与局部变量表"><a href="#3-再谈操作数栈与局部变量表" class="headerlink" title="3. 再谈操作数栈与局部变量表"></a>3. 再谈操作数栈与局部变量表</h2><h3 id="3-1-操作数栈（Operand-Stacks）"><a href="#3-1-操作数栈（Operand-Stacks）" class="headerlink" title="3.1 操作数栈（Operand Stacks）"></a>3.1 操作数栈（Operand Stacks）</h3><p>我们知道，Java字节码是Java虚拟机所使用的指令集。因此，它与Java虚拟机基于栈的计算模型是密不可分的。在解释执行过程中，每当为Java方法分配栈桢时，Java虚拟机往往需要开辟一块额外的空间作为操作数栈，来存放计算的操作数以及返回结果。</p><p>具体来说便是：执行每一条指令之前，Java虚拟机要求该指令的操作数已被压入操作数栈中。在执行指令时，Java虚拟机会将该指令所需的操作数弹出，并且将指令的结果重新压入栈中。</p><p><img src="https://raw.githubusercontent.com/GeorgeChan95/blogimg/master/img/2024/07/25/20240725-134709.png" alt="操作数栈1"></p><p>以加法指令iadd为例。假设在执行该指令前，栈顶的两个元素分别为int值1和int值2，那么iadd指令将弹出这两个int，并将求得的和int值3压入栈中。</p><p><img src="https://raw.githubusercontent.com/GeorgeChan95/blogimg/master/img/2024/07/25/20240725-134734.png" alt="操作数栈2"></p><p>由于iadd指令只消耗栈顶的两个元素，因此，对于离栈顶距离为2的元素，即图中的问号，iadd 指令并不关心它是否存在，更加不会对其进行修改。</p><h3 id="3-2-局部变量表（Local-Variables）"><a href="#3-2-局部变量表（Local-Variables）" class="headerlink" title="3.2 局部变量表（Local Variables）"></a>3.2 局部变量表（Local Variables）</h3><p>Java方法栈桢的另外一个重要组成部分则是局部变量区，字节码程序可以将计算的结果缓存在局部变量区之中。</p><p>实际上，Java虚拟机将局部变量区当成一个数组，依次存放this指针（<strong>仅非静态方法</strong>），所传入的参数，以及字节码中的局部变量。</p><p>和操作数栈一样，long类型以及double类型的值将占据两个单元，其余类型仅占据一个单元。</p><p><img src="https://raw.githubusercontent.com/GeorgeChan95/blogimg/master/img/2024/07/25/20240725-210722.png" alt="不同类型占局部变量表长度"></p><p>举例：</p><pre><code class="highlight java"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">foo</span><span class="params">(<span class="type">long</span> l, <span class="type">float</span> f)</span> &#123;    &#123;        <span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> e;    &#125;    &#123;        <span class="type">String</span> <span class="variable">s</span> <span class="operator">=</span> <span class="string">&quot;Hello, World&quot;</span>;    &#125;&#125;</code></pre><p>对应的图示：</p><p><img src="https://raw.githubusercontent.com/GeorgeChan95/blogimg/master/img/2024/07/25/20240725-210848.png" alt="局部变量表"></p><p>this表示当前类的引用，l 和 f 的类型的值占两个槽位，i 和 s 变量由于分别在各自代码块中，没有共同的生命周期，所以占同一个槽位（即槽位复用）</p><p>在栈帧中，与性能调优关系最为密切的部分就是局部变量表。局部变量表中的变量也是重要的垃圾回收根节点，只要被局部变量表中直接或间接引用的对象都不会被回收。</p><h3 id="3-3-局部变量压栈指令"><a href="#3-3-局部变量压栈指令" class="headerlink" title="3.3 局部变量压栈指令"></a>3.3 局部变量压栈指令</h3><ul><li><code>iload</code> 从局部变量中装载int类型值</li><li><code>lload</code> 从局部变量中装载long类型值</li><li><code>fload</code> 从局部变量中装载float类型值</li><li><code>dload</code> 从局部变量中装载double类型值</li><li><code>aload</code> 从局部变量中装载引用类型值（refernce）</li><li><code>iload_0</code> ,<code>iload_1</code>,<code>iload_2</code>,<code>iload_3</code> 将局部变量表下标为0, 1, 2, 3的 <code>int类型</code> 的值,加载到操作数栈中</li><li><code>lload_0</code> ,<code>lload_1</code> ,<code>lload_2</code> ,<code>lload_3</code> 将局部变量表下标为0, 1, 2, 3 的 <code>long类型</code> 的值,加载到操作数栈中</li><li><code>fload_0</code>, <code>fload_1</code>, <code>fload_2</code>, <code>fload_3</code> 将局部变量表下标为0, 1, 2, 3 的 <code>float类型</code> 的值,加载到操作数栈中</li><li><code>dload_0</code>, <code>dload_1</code>, <code>dload_2</code>, <code>dload_3</code> 将局部变量表下标为0, 1, 2, 3 的 <code>double类型</code> 的值,加载到操作数栈中</li><li><code>aload_0</code>, <code>aload_1</code>, <code>aload_2</code>, <code>aload_3</code> 将局部变量表下标为0, 1, 2, 3 的 <code>引用类型</code> 的值,加载到操作数栈中</li><li><code>iaload</code> 将 int 型数组指定索引的值推送至栈顶, 执行该指令后，将从操作数栈出栈2个参数arrayref和index</li><li><code>laload</code> 将 long 型数组指定索引的值推送至栈顶</li><li><code>faload</code> 将 float 型数组指定索引的值推送至栈顶</li><li><code>daload</code> 将 double 型数组指定索引的值推送至栈顶</li><li><code>aaload</code> 将引用型数组指定索引的值推送至栈顶</li><li><code>baload</code> 将byte类型或boolean类型值数组指定索引的值推送至栈顶</li><li><code>caload</code> 将char型数组指定索引的值推送至栈顶</li><li><code>saload</code> 将 short 型数组指定索引的值推送至栈顶</li></ul><h4 id="3-3-1-局部变量压栈指令剖析"><a href="#3-3-1-局部变量压栈指令剖析" class="headerlink" title="3.3.1 局部变量压栈指令剖析"></a>3.3.1 局部变量压栈指令剖析</h4><p>局部变量压栈指令将给定的局部变量表中的数据压入操作数栈, 这类指令大体可以分为：</p><ul><li><p><code>xload_&lt;n&gt;</code>（x为i、l、f、d、a，n为0到3）</p></li><li><p><code>xload</code>（x为i、l、f、d、a）</p></li></ul><p><strong>说明：</strong>在这里，x的取值表示数据类型。</p><p>指令xload_n表示将第n个局部变量压入操作数栈，比如iload_1、fload_0、aload_0等指令。其中aload_n表示将一个对象引用压栈。</p><p>指令xload通过指定参数的形式，把局部变量压入操作数栈，当使用这个命令时，表示局部变量的数量可能超过了4个，比如指令iload、fload等。</p><p><strong>举例：</strong></p><pre><code class="highlight java"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">load</span><span class="params">(<span class="type">int</span> num, Object obj, <span class="type">long</span> count, <span class="type">boolean</span> flag, <span class="type">short</span>[] arr)</span> &#123;    System.out.println(num);    System.out.println(obj);    System.out.println(count);    System.out.println(flag);    System.out.println(arr);&#125;</code></pre><p><strong>字节码执行过程：</strong></p><p><img src="https://raw.githubusercontent.com/GeorgeChan95/blogimg/master/img/2024/07/26/20240726-093706.png" alt="字节码执行过程"></p><h3 id="3-4-常量入栈指令"><a href="#3-4-常量入栈指令" class="headerlink" title="3.4 常量入栈指令"></a>3.4 常量入栈指令</h3><ul><li><code>aconst_null</code> 将null对象引用压入栈</li><li><code>iconst_m1</code> 将int类型常量-1压入栈</li><li><code>iconst_0</code>, <code>iconst_1</code>, <code>iconst_2</code>,<code>iconst_3</code>,<code>iconst_4</code>,<code>iconst_5</code> 将int类型常量 0, 1, 2, 3, 4, 5 压入栈</li><li><code>lconst_0</code>, <code>lconst_1</code>, 将long类型常量0, 1压入栈</li><li><code>fconst_0</code>, <code>fconst_1</code> 将float类型常量0, 1压入栈</li><li><code>dconst_0</code>, <code>dconst_1</code> 将double类型常量0, 1压入栈</li><li><code>bipush</code> 将一个8位带符号整数压入栈(-128~127)</li><li><code>sipush</code> 将16位带符号整数压入栈(-32768~32767)</li><li><code>ldc index</code> 加载常量池中的无符号byte类型的常量到操作数栈，‌index 最大值是 255, 索引指向的数据类型可以是： <code>int</code>、 <code>float</code> 或 <code>String</code></li><li><code>ldc_w index</code>  如果常量池的大小超过255，‌或者需要加载的常量值超过一个byte可以表示的范围，‌这时就需要使用 <code>ldc_w</code> 指令。‌<code>ldc_w</code> 指令可以加载常量池中的宽索引项到操作数栈，‌从而支持更大的常量值。‌索引指向的数据类型可以是： <code>int</code>、 <code>float</code> 或 <code>String</code></li><li><code>ldc2_w index</code> 将long或double型常量值从常量池中推送至栈顶（宽索引）（分两次压入，因为 long, double 是 8 个字节）索引指向的数据类型可以是： <code>int</code>、 <code>float</code> 或 <code>String</code></li></ul><h4 id="3-4-1-常量入栈常用指令集"><a href="#3-4-1-常量入栈常用指令集" class="headerlink" title="3.4.1 常量入栈常用指令集"></a>3.4.1 常量入栈常用指令集</h4><table><thead><tr><th>xconst_n</th><th>范围</th><th>xconst_null</th><th>xconst_m1</th><th>xconst_0</th><th>xconst_1</th><th>xconst_2</th><th>xconst_3</th><th>xconst_4</th><th>xconst_5</th></tr></thead><tbody><tr><td><strong>iconst_n</strong></td><td>[-1, 5]</td><td></td><td>iconst_m1</td><td>iconst_0</td><td>iconst_1</td><td>iconst_2</td><td>iconst_3</td><td>iconst_4</td><td>iconst_5</td></tr><tr><td><strong>lconst_n</strong></td><td>0, 1</td><td></td><td></td><td>lconst_0</td><td>lconst_1</td><td></td><td></td><td></td><td></td></tr><tr><td><strong>fconst_n</strong></td><td>0, 1, 2</td><td></td><td></td><td>fconst_0</td><td>fconst_1</td><td>fconst_2</td><td></td><td></td><td></td></tr><tr><td><strong>dconst_n</strong></td><td>0, 1</td><td></td><td></td><td>dconst_0</td><td>dconst_1</td><td></td><td></td><td></td><td></td></tr><tr><td><strong>aconst_n</strong></td><td>null, String literal, Class literal</td><td>aconst_null</td><td></td><td></td><td></td><td></td><td></td><td></td><td></td></tr><tr><td><strong>bipush</strong></td><td>一个字节有符号整数，[-2<sup>7</sup>, 2<sup>7</sup> - 1]，即[-128, 127]</td><td></td><td></td><td></td><td></td><td></td><td></td><td></td><td></td></tr><tr><td><strong>sipush</strong></td><td>两个字节有符号整数，[-2<sup>15</sup>, 2<sup>15</sup> - 1]，即[-32768, 32767]</td><td></td><td></td><td></td><td></td><td></td><td></td><td></td><td></td></tr><tr><td><strong>ldc</strong></td><td>1个字节(8位)无符号数，-2<sup>8</sup> - 1, 即不超过255</td><td></td><td></td><td></td><td></td><td></td><td></td><td></td><td></td></tr><tr><td><strong>ldc_w</strong></td><td>宽索引, 接收两个8位参数，能支持的索引范围大于ldc, 索引范围比ldc更大</td><td></td><td></td><td></td><td></td><td></td><td></td><td></td><td></td></tr><tr><td><strong>ldc2_w</strong></td><td>宽索引，long或double</td><td></td><td></td><td></td><td></td><td></td><td></td><td></td><td></td></tr></tbody></table><h4 id="3-4-2-常量入栈指令剖析"><a href="#3-4-2-常量入栈指令剖析" class="headerlink" title="3.4.2 常量入栈指令剖析"></a>3.4.2 常量入栈指令剖析</h4><p>常量入栈指令的功能是将常数压入操作数栈，根据数据类型和入栈内容的不同，又可以分为 const 系列、push 系列和 ldc 指令。</p><p>指令const系列：用于对特定的常量入栈，入栈的常量隐含在指令本身里。指令有：<code>iconst_&lt;i&gt;（i从-1到5）、lconst_&lt;l&gt;（l从0到1）、fconst_&lt;f&gt;（f从0到2）、dconst_&lt;d&gt;（d从0到1）、aconst_null</code>。比如，</p><ul><li><p><code>iconst_m1</code> 将-1压入操作数栈；</p></li><li><p><code>iconst_x</code>（x为0到5）将x压入栈；</p></li><li><p><code>lconst_0</code>、<code>lconst_1</code>分别将长整数0和1压入栈；</p></li><li><p><code>fconst_0</code>、<code>fconst_1</code>、<code>fconst_2</code> 分别将浮点数0、1、2压入栈；</p></li><li><p><code>dconst_0</code> 和 <code>dconst_1</code> 分别将double型0和1压入栈；</p></li><li><p><code>aconst_null</code> 将null压入操作数栈；</p></li></ul><p>从指令的命名上不难找出规律，指令助记符的第一个字符总是喜欢表示数据类型，i表示整数，l表示长整数，f表示浮点数，d表示双精度浮点，习惯上用a表示对象引用。如果指令隐含操作的参数，会以下划线形式给出。</p><p>指令push系列：主要包括bipush和sipush。它们的区别在于接收数据类型的不同，bipush接收8位整数作为参数，sipush接收16位整数，它们都将参数压入栈。</p><p>指令ldc系列：如果以上指令都不能满足需求，那么可以使用万能的</p><ul><li><p>ldc 指令，它可以接收一个8位的参数，该参数指向常量池中的int、float或者String的索引，将指定的内容压入堆栈。</p></li><li><p>类似的还有ldc_w，它接收两个8位参数，能支持的索引范围大于ldc。</p></li><li><p>如果要压入的元素是long或者double类型的，则使用ldc2_w指令，使用方式都是类似的</p></li></ul><p>总结如下：</p><table><thead><tr><th>类型</th><th>常数指令</th><th>范围</th></tr></thead><tbody><tr><td>int(boolean,byte,char,short)</td><td>iconst</td><td>[-1, 5]</td></tr><tr><td></td><td>bipush</td><td>[-128, 127]</td></tr><tr><td></td><td>sipush</td><td>[-32768, 32767]</td></tr><tr><td></td><td>ldc</td><td>any int value</td></tr><tr><td>long</td><td>lconst</td><td>0, 1</td></tr><tr><td></td><td>ldc</td><td>any long value</td></tr><tr><td>float</td><td>fconst</td><td>0, 1, 2</td></tr><tr><td></td><td>ldc</td><td>any float value</td></tr><tr><td>double</td><td>dconst</td><td>0, 1</td></tr><tr><td></td><td>ldc</td><td>any double value</td></tr><tr><td>reference</td><td>aconst</td><td>null</td></tr><tr><td></td><td>ldc</td><td>String literal, Class literal</td></tr></tbody></table><p><img src="https://raw.githubusercontent.com/GeorgeChan95/blogimg/master/img/2024/07/26/20240726-105330.png" alt="字节码指令示例1"></p><p><img src="https://raw.githubusercontent.com/GeorgeChan95/blogimg/master/img/2024/07/26/20240726-105342.png" alt="字节码指令示例2"></p><h3 id="3-5-出栈装入局部变量表指令"><a href="#3-5-出栈装入局部变量表指令" class="headerlink" title="3.5 出栈装入局部变量表指令"></a>3.5 出栈装入局部变量表指令</h3><ul><li><p><code>istore</code> 将int类型值存入局部变量</p></li><li><p><code>lstore</code> 将long类型值存入局部变量</p></li><li><p><code>fstore</code> 将float类型值存入局部变量</p></li><li><p><code>dstore</code> 将double类型值存入局部变量</p></li><li><p><code>astore</code> 将将引用类型或returnAddress类型值存入局部变量</p></li><li><p><code>istore_0</code>, <code>istore_1</code>, <code>istore_2</code>, <code>istore_3</code> 分别将int类型值存入局部变量0, 1, 2, 3索引位置</p></li><li><p><code>lstore_0</code>, <code>lstore_1</code>, <code>lstore_2</code>, <code>lstore_3</code> 将long类型值存入局部变量0, 1, 2, 3 索引位置</p></li><li><p><code>fstore_0</code>, <code>fstore_1</code>, <code>fstore_2</code>, <code>fstore_3</code>, 将float类型值存入局部变量0, 1, 2, 3 索引位置</p></li><li><p><code>dstore_0</code>, <code>dstore_1</code>, <code>dstore_2</code>, <code>dstore_3</code>, 将double类型值存入局部变量0</p></li><li><p><code>astore_0</code>, <code>astore_1</code>, <code>astore_2</code>, <code>astore_3</code> 将引用类型或returnAddress类型值存入局部变量0, 1, 2, 3 索引位置</p></li><li><p><code>iastore</code> 将int类型值存入数组中</p></li><li><p><code>lastore</code> 将long类型值存入数组中</p></li><li><p><code>fastore</code> 将float类型值存入数组中</p></li><li><p><code>dastore</code> 将double类型值存入数组中</p></li><li><p><code>aastore</code> 将引用类型值存入数组中</p></li><li><p><code>bastore</code> 将byte类型或者boolean类型值存入数组中</p></li><li><p><code>castore</code> 将char类型值存入数组中</p></li><li><p><code>sastore</code> 将short类型值存入数组中</p></li><li><p>wide指令</p></li><li><p>wide 使用附加字节扩展局部变量索引</p></li></ul><h4 id="3-5-1-出栈装入局部变量表指令剖析"><a href="#3-5-1-出栈装入局部变量表指令剖析" class="headerlink" title="3.5.1 出栈装入局部变量表指令剖析"></a>3.5.1 出栈装入局部变量表指令剖析</h4><p>出栈装入局部变量表指令用于将操作数栈中栈顶元素弹出后，装入局部变量表的指定位置，用于给局部变量赋值。这类指令主要以store的形式存在，比如<code>xstore（x为i、l、f、d、a）、xstore_n（x为i、l、f、d、a，n为0至3）</code>。</p><ul><li><p>其中，指令istore_n将从操作数栈中弹出一个整数，并把它值给局部变量索引n位置。</p></li><li><p>指令xstore由于没有隐含参数信息，故需要提供一个byte类型的参数类指定目标局部变量表的位置。</p></li></ul><p>说明：一般说来，类似像store这样的命令需要带一个参数，用来指明将弹出的元素放在局部变量表的第几个位置。但是，为了尽可能压缩指令大小，使用专门的istore_1指令表示将弹出的元素放置在局部变量表第1个位置。类似的还有istore_0、istore_2、istore_3，它们分别表示从操作数栈顶弹出一个元素，存放在局部变量表第0、2、3个位置。由于局部变量表前几个位置总是非常常用，因此这种做法虽然增加了指令数量，但是可以大大压缩生成的字节码的体积。如果局部变量表很大，需要存储的槽位大于3，那么可以使用istore指令，外加一个参数，用来表示需要存放的槽位位置。</p><p><img src="https://raw.githubusercontent.com/GeorgeChan95/blogimg/master/img/2024/07/26/20240726-110910.png" alt="字节码指令执行过程"></p><h1 id="三、算数指令"><a href="#三、算数指令" class="headerlink" title="三、算数指令"></a>三、算数指令</h1><h2 id="1-作用-1"><a href="#1-作用-1" class="headerlink" title="1. 作用"></a>1. 作用</h2><p>算术指令用于对两个操作数栈上的值进行某种特定运算，并把结果重新压入操作数栈。</p><h2 id="2-分类"><a href="#2-分类" class="headerlink" title="2. 分类"></a>2. 分类</h2><p>大体上算术指令可以分为两种：对<strong>整型数据进行运算</strong>的指令与对<strong>浮点类型数据进行运算</strong>的指令。</p><h2 id="3-byte、short、char和boolean类型说明"><a href="#3-byte、short、char和boolean类型说明" class="headerlink" title="3. byte、short、char和boolean类型说明"></a>3. byte、short、char和boolean类型说明</h2><p>在每一大类中，都有针对Java虚拟机具体数据类型的专用算术指令。但没有直接支持byte、short、char和boolean类型的算术指令，对于这些数据的运算，都使用int类型的指令来处理。此外，在处理boolean、byte、short和char类型的数组时，也会转换为使用对应的int类型的字节码指令来处理。</p><p><img src="https://raw.githubusercontent.com/GeorgeChan95/blogimg/master/img/2024/07/26/20240726-111216.png" alt="java虚拟机中实际类型与运算类型"></p><h2 id="4-运算时的溢出"><a href="#4-运算时的溢出" class="headerlink" title="4. 运算时的溢出"></a>4. 运算时的溢出</h2><p>数据运算可能会导致溢出，例如两个很大的正整数相加，结果可能是一个负数。其实Java虚拟机规范并无明确规定过整型数据溢出的具体结果，仅规定了在处理整型数据时，只有除法指令以及求余指令中当出现除数为0时会导致虚拟机抛出异常ArithmeticException。</p><h2 id="5-运算模式"><a href="#5-运算模式" class="headerlink" title="5. 运算模式"></a>5. 运算模式</h2><p><strong>向最接近数舍入模式</strong>：JVM要求在进行浮点数计算时，所有的运算结果都必须舍入到适当的精度，非精确结果必须舍入为可被表示的最接近的精确值，如果有两种可表示的形式与该值一样接近，将优先选择最低有效位为零的；</p><p><strong>向零舍入模式</strong>：将浮点数转换为整数时，采用该模式，该模式将在目标数值类型中选择一个最接近但是不大于原值的数字作为最精确的舍入结果；</p><h2 id="6-NaN值使用"><a href="#6-NaN值使用" class="headerlink" title="6. NaN值使用"></a>6. NaN值使用</h2><p>当一个操作产生溢出时，将会使用有符号的无穷大表示，如果某个操作结果没有明确的数学定义的话，将会使用NaN值来表示。而且所有使用NaN值作为操作数的算术操作，结果都会返回NaN；</p><p><img src="https://raw.githubusercontent.com/GeorgeChan95/blogimg/master/img/2024/07/26/20240726-111920.png" alt="无穷大与NaN"></p><h2 id="7-所有算术指令"><a href="#7-所有算术指令" class="headerlink" title="7. 所有算术指令"></a>7. 所有算术指令</h2><p><strong>整数运算</strong></p><ul><li><code>iadd</code> 执行int类型的加法</li><li><code>ladd</code> 执行long类型的加法</li><li><code>isub</code> 执行int类型的减法</li><li><code>lsub</code> 执行long类型的减法</li><li><code>imul</code> 执行int类型的乘法</li><li><code>lmul</code> 执行long类型的乘法</li><li><code>idiv</code> 执行int类型的除法</li><li><code>ldiv</code> 执行long类型的除法</li><li><code>irem</code> 计算int类型除法的余数</li><li><code>lrem</code> 计算long类型除法的余数</li><li><code>ineg</code> 对一个int类型值进行取反操作</li><li><code>lneg</code> 对一个long类型值进行取反操作</li><li><code>iinc</code> 把一个常量值加到一个int类型的局部变量上</li></ul><p><strong>移位操作</strong></p><ul><li><code>ishl</code> 执行int类型的向左移位操作</li><li><code>lshl</code> 执行long类型的向左移位操作</li><li><code>ishr</code> 执行int类型的向右移位操作</li><li><code>lshr</code> 执行long类型的向右移位操作</li><li><code>iushr</code> 执行int类型的向右逻辑移位操作</li><li><code>lushr</code> 执行long类型的向右逻辑移位操作</li></ul><p><strong>按位布尔运算</strong></p><ul><li><code>iand</code> 对int类型值进行“逻辑与”操作</li><li><code>land</code> 对long类型值进行“逻辑与”操作</li><li><code>ior</code> 对int类型值进行“逻辑或”操作</li><li><code>lor</code> 对long类型值进行“逻辑或”操作</li><li><code>ixor</code> 对int类型值进行“逻辑异或”操作</li><li><code>lxor</code> 对long类型值进行“逻辑异或”操作</li></ul><p><strong>浮点运算</strong></p><ul><li><code>fadd</code> 执行float类型的加法</li><li><code>dadd</code> 执行double类型的加法</li><li><code>fsub</code> 执行float类型的减法</li><li><code>dsub</code> 执行double类型的减法</li><li><code>fmul</code> 执行float类型的乘法</li><li><code>dmul</code> 执行double类型的乘法</li><li><code>fdiv</code> 执行float类型的除法</li><li><code>ddiv</code> 执行double类型的除法</li><li><code>frem</code> 计算float类型除法的余数</li><li><code>drem</code> 计算double类型除法的余数</li><li><code>fneg</code> 将一个float类型的数值取反</li><li><code>dneg</code> 将一个double类型的数值取反</li></ul><p><strong>算术指令集</strong></p><table><thead><tr><th>算数指令</th><th>int(boolean,byte,char,short)</th><th>long</th><th>float</th><th>double</th></tr></thead><tbody><tr><td>加法指令</td><td>iadd</td><td>ladd</td><td>fadd</td><td>dadd</td></tr><tr><td>减法指令</td><td>isub</td><td>lsub</td><td>fsub</td><td>dsub</td></tr><tr><td>乘法指令</td><td>imul</td><td>lmul</td><td>fmul</td><td>dmul</td></tr><tr><td>除法指令</td><td>idiv</td><td>ldiv</td><td>fdiv</td><td>ddiv</td></tr><tr><td>求余指令</td><td>irem</td><td>lrem</td><td>frem</td><td>drem</td></tr><tr><td>取反指令</td><td>ineg</td><td>lneg</td><td>fneg</td><td>dneg</td></tr><tr><td>自增指令</td><td>iinc</td><td></td><td></td><td></td></tr><tr><td>位运算指令</td><td>按位或指令</td><td>ior</td><td>lor</td><td></td></tr><tr><td></td><td>按位或指令</td><td>ior</td><td>lor</td><td></td></tr><tr><td></td><td>按位与指令</td><td>iand</td><td>land</td><td></td></tr><tr><td></td><td>按位异或指令</td><td>ixor</td><td>lxor</td><td></td></tr><tr><td>比较指令</td><td></td><td>lcmp</td><td>fcmpg &#x2F; fcmpl</td><td>dcmpg &#x2F; dcmpl</td></tr></tbody></table><p><strong>示例1</strong></p><pre><code class="highlight java"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">add</span><span class="params">()</span> &#123;<span class="type">byte</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">15</span>;<span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> <span class="number">8</span>;<span class="type">int</span> <span class="variable">k</span> <span class="operator">=</span> i + j;&#125;</code></pre><p><img src="https://raw.githubusercontent.com/GeorgeChan95/blogimg/master/img/2024/07/27/20240727-145225.png" alt="1"></p><p><img src="https://raw.githubusercontent.com/GeorgeChan95/blogimg/master/img/2024/07/27/20240727-145233.png" alt="2"></p><p><img src="https://raw.githubusercontent.com/GeorgeChan95/blogimg/master/img/2024/07/27/20240727-145245.png" alt="3"></p><p><img src="https://raw.githubusercontent.com/GeorgeChan95/blogimg/master/img/2024/07/27/20240727-145254.gif" alt="4"></p><p><strong>示例2</strong></p><pre><code class="highlight java"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;<span class="type">int</span> <span class="variable">x</span> <span class="operator">=</span> <span class="number">500</span>;<span class="type">int</span> <span class="variable">y</span> <span class="operator">=</span> <span class="number">100</span>;<span class="type">int</span> <span class="variable">a</span> <span class="operator">=</span> x / y;<span class="type">int</span> <span class="variable">b</span> <span class="operator">=</span> <span class="number">50</span>;System.out.println(a + b);&#125;</code></pre><p><img src="https://raw.githubusercontent.com/GeorgeChan95/blogimg/master/img/2024/07/27/20240727-145932.png" alt="1"></p><p><img src="https://raw.githubusercontent.com/GeorgeChan95/blogimg/master/img/2024/07/27/20240727-145944.png" alt="2"></p><h1 id="四、类型转换指令"><a href="#四、类型转换指令" class="headerlink" title="四、类型转换指令"></a>四、类型转换指令</h1><h2 id="1-类型转换指令说明"><a href="#1-类型转换指令说明" class="headerlink" title="1. 类型转换指令说明"></a>1. 类型转换指令说明</h2><ul><li>类型转换指令可以将两种不同的数值类型进行相互转换。</li><li>这些转换操作一般用于实现用户代码中的显式类型转换操作，或者用来处理字节码指令集中数据类型相关指令无法与数据类型一一对应的问题。</li></ul><p><strong>宽化类型转换指令</strong></p><ul><li><code>i2l</code> 把int类型的数据转化为long类型</li><li><code>i2f</code> 把int类型的数据转化为float类型</li><li><code>i2d</code> 把int类型的数据转化为double类型</li><li><code>l2f</code> 把long类型的数据转化为float类型</li><li><code>l2d</code> 把long类型的数据转化为double类型</li><li><code>f2d</code> 把float类型的数据转化为double类型</li></ul><p><strong>窄化类型转换</strong></p><ul><li><code>i2b</code> 把int类型的数据转化为byte类型</li><li><code>i2c</code> 把int类型的数据转化为char类型</li><li><code>i2s</code> 把int类型的数据转化为short类型</li><li><code>l2i</code> 把long类型的数据转化为int类型</li><li><code>f2i</code> 把float类型的数据转化为int类型</li><li><code>f2l</code> 把float类型的数据转化为long类型</li><li><code>d2i</code> 把double类型的数据转化为int类型</li><li><code>d2l</code> 把double类型的数据转化为long类型</li><li><code>d2f</code> 把double类型的数据转化为float类型</li></ul><p><strong>类型转换指令集</strong></p><table><thead><tr><th></th><th><strong>byte</strong></th><th><strong>char</strong></th><th><strong>short</strong></th><th><strong>int</strong></th><th><strong>long</strong></th><th><strong>float</strong></th><th><strong>double</strong></th></tr></thead><tbody><tr><td><strong>int</strong></td><td>i2b</td><td>i2c</td><td>i2s</td><td>-</td><td>i2l</td><td>i2f</td><td>i2d</td></tr><tr><td><strong>long</strong></td><td>l2i   i2b</td><td>l2i   i2c</td><td>l2i   i2s</td><td>l2i</td><td>-</td><td>l2f</td><td>l2d</td></tr><tr><td><strong>float</strong></td><td>f2i   i2b</td><td>f2i   i2c</td><td>f2i   i2s</td><td>f2i</td><td>f2l</td><td>-</td><td>f2d</td></tr><tr><td><strong>double</strong></td><td>d2i   i2b</td><td>d2i   i2c</td><td>d2i   i2s</td><td>d2i</td><td>d2l</td><td>d2f</td><td>-</td></tr></tbody></table><h2 id="2-宽化类型转换指令"><a href="#2-宽化类型转换指令" class="headerlink" title="2. 宽化类型转换指令"></a>2. 宽化类型转换指令</h2><p><strong>宽化类型转换( Widening Numeric Conversions)</strong></p><h3 id="2-1-转换规则"><a href="#2-1-转换规则" class="headerlink" title="2.1 转换规则"></a>2.1 转换规则</h3><p>Java虚拟机直接支持以下数值的宽化类型转换（ widening numeric conversion,小范围类型向大范围类型的安全转换）。也就是说，并不需要指令执行，包括</p><ul><li><p>从int类型到long、float或者 double类型。对应的指令为：i21、i2f、i2d </p></li><li><p>从long类型到float、 double类型。对应的指令为：l2f、l2d </p></li><li><p>从float类型到double类型。对应的指令为：f2d</p></li></ul><p>简化为：int–&gt;long–&gt;float-&gt; double</p><p><a href="https://juejin.cn/post/7206123045855969337">float的表示范围为什么比long大?</a></p><h3 id="2-2-精度损失问题"><a href="#2-2-精度损失问题" class="headerlink" title="2.2 精度损失问题"></a>2.2 精度损失问题</h3><ul><li><p>宽化类型转换是不会因为超过目标类型最大值而丢失信息的，例如，从int转换到long,或者从int转换到double,都不会丢失任何信息，转换前后的值是精确相等的。 </p></li><li><p>从int、long类型数值转换到float，或者long类型数值转换到double时，将可能发生精度丢失一一可能丢失掉几个最低有效位上的值，转换后的浮点数值是根据IEEE754最接近含入模式所得到的正确整数值。</p></li></ul><p><strong>尽管宽化类型转换实际上是可能发生精度丢失的，但是这种转换永远不会导致Java虚拟机抛出运行时异常</strong></p><h3 id="2-3-补充说明"><a href="#2-3-补充说明" class="headerlink" title="2.3 补充说明"></a>2.3 补充说明</h3><p>从byte、char和 short类型到int类型的宽化类型转换实际上是不存在的。对于byte类型转为int,虚拟机并没有做实质性的转化处理，只是简单地通过操作数栈交換了两个数据。而将byte转为long时，使用的是i2l,可以看到在内部，byte在这里已经等同于int类型处理，类似的还有 short类型，这种处理方式有两个特点：</p><ul><li>一方面可以减少实际的数据类型，如果为 short和byte都准备一套指令，那么指令的数量就会大増，而虚拟机目前的设计上，只愿意使用一个字节表示指令，因此指令总数不能超过256个，为了节省指令资源，将 short和byte当做int处理也在情理之中。</li><li>另一方面，由于局部变量表中的槽位固定为32位，无论是byte或者 short存入局部变量表，都会占用32位空间。从这个角度说，也没有必要特意区分这几种数据类型。</li></ul><h2 id="3-窄化类型转换指令"><a href="#3-窄化类型转换指令" class="headerlink" title="3. 窄化类型转换指令"></a>3. 窄化类型转换指令</h2><p><strong>窄化类型转换( Narrowing Numeric Conversion)</strong></p><h3 id="3-1-转换规则"><a href="#3-1-转换规则" class="headerlink" title="3.1 转换规则"></a>3.1 转换规则</h3><p>Java虚拟机也直接支持以下窄化类型转换：</p><ul><li><p>从主int类型至byte、 short或者char类型。对应的指令有：i2b、i2c、i2s </p></li><li><p>从long类型到int类型。对应的指令有：l2i </p></li><li><p>从float类型到int或者long类型。对应的指令有：f2i、f2l </p></li><li><p>从double类型到int、long或者float类型。对应的指令有：d2i、d2l、d2f</p></li></ul><h3 id="3-2-精度损失问题"><a href="#3-2-精度损失问题" class="headerlink" title="3.2 精度损失问题"></a>3.2 精度损失问题</h3><p>窄化类型转换可能会导致转换结果具备不同的正负号、不同的数量级，因此，转换过程很可能会导致数值丢失精度。</p><p>尽管数据类型窄化转换可能会发生上限溢出、下限溢出和精度丢失等情况，但是Java虚拟机规范中明确规定数值类型的窄化转换指令永远不可能导致虚拟机抛出运行时异常</p><h3 id="3-3-补充说明"><a href="#3-3-补充说明" class="headerlink" title="3.3 补充说明"></a>3.3 补充说明</h3><p>当将一个浮点值窄化转换为整数类型T(T限于int或long类型之一)的时候，将遵循以下转换规则：</p><ul><li><p>如果浮点值是NaN,那转换结果就是int或long类型的0. </p></li><li><p>如果浮点值不是无穷大的话，浮点值使用IEEE754的向零含入模式取整，获得整数值v。如果v在目标类型T(int或long)的表示范围之内，那转换结果就是v。否则，将根据v的符号，转换为T所能表示的最大或者最小正数</p></li></ul><p>当将一个double类型窄化转换为float类型时，将遵循以下转换规则，通过向最接近数舍入模式舍入一个可以使用float类型表示的数字。最后结果根据下面这3条规则判断：</p><ul><li><p>如果转换结果的绝对值太小而无法使用float来表示，将返回float类型的正负零 </p></li><li><p>如果转换结果的绝对值太大而无法使用float来表示，将返回float类型的正负无穷大。 </p></li><li><p>对于double类型的NaN值将按规定转换为float类型的NaN值。</p></li></ul><h1 id="五、对象的创建与访问指令"><a href="#五、对象的创建与访问指令" class="headerlink" title="五、对象的创建与访问指令"></a>五、对象的创建与访问指令</h1><p>Java是面向对象的程序设计语言，虚拟机平台从字节码层面就对面向对象做了深层次的支持。有一系列指令专门用于对象操作，可进一步细分为创建指令、字段访问指令、数组操作指令、类型检查指令。</p><ul><li><strong>对象操作指令</strong><ul><li><code>new</code> 创建一个新对象</li><li><code>getfield</code> 从对象中获取字段</li><li><code>putfield</code> 设置对象中字段的值</li><li><code>getstatic</code> 从类中获取静态字段</li><li><code>putstatic</code> 设置类中静态字段的值</li><li><code>checkcast</code> 确定对象为所给定的类型。后跟目标类，判断栈顶元素是否为目标类 &#x2F; 接口的实例。如果不是便抛出异常</li><li><code>instanceof</code> 判断对象是否为给定的类型。后跟目标类，判断栈顶元素是否为目标类 &#x2F; 接口的实例。是则压入 1，否则压入 0</li></ul></li><li><strong>数组操作指令</strong><ul><li><code>newarray</code> 分配数据成员类型为基本数据类型的新数组</li><li><code>anewarray</code> 分配数据成员类型为引用类型的新数组</li><li><code>arraylength</code> 获取数组长度</li><li><code>multianewarray</code> 分配新的多维数组</li></ul></li></ul><h2 id="1-创建指令"><a href="#1-创建指令" class="headerlink" title="1. 创建指令"></a>1. 创建指令</h2><table><thead><tr><th>创建指令</th><th>含义</th></tr></thead><tbody><tr><td>new</td><td>创建类实例</td></tr><tr><td>newarray</td><td>创建基本类型数组</td></tr><tr><td>anewarray</td><td>创建引用类型数组</td></tr><tr><td>multilanewarra</td><td>创建多维数组</td></tr></tbody></table><p>虽然类实例和数组都是对象，但Java虚拟机对类实例和数组的创建与操作使用了不同的字节码指令：</p><ul><li>创建类实例的指令： <ul><li>创建类实例的指令：new</li><li>它接收一个操作数，为指向常量池的索引，表示要创建的类型，执行完成后，将对象的引用压入栈。</li></ul></li><li>创建数组的指令： <ul><li>创建数组的指令：newarray、anewarray、multianewarray</li><li>上述创建指令可以用于创建对象或者数组，由于对象和数组在Java中的广泛使用，这些指令的使用频率也非常高。</li></ul></li></ul><h2 id="2-字段访问指令"><a href="#2-字段访问指令" class="headerlink" title="2. 字段访问指令"></a>2. 字段访问指令</h2><table><thead><tr><th>字段访问指令</th><th>含义</th></tr></thead><tbody><tr><td>getstatic、putstatic</td><td>访问类字段（static字段，或者称为类变量）的指令</td></tr><tr><td>getfield、 putfield</td><td>访问类实例字段（非static字段，或者称为实例变量）的指令</td></tr></tbody></table><p>对象创建后，就可以通过对象访问指令获取对象实例或数组实例中的字段或者数组元素。</p><ul><li><p>访问类字段（static字段，或者称为类变量）的指令：getstatic、putstatic</p></li><li><p>访问类实例字段（非static字段，或者称为实例变量）的指令：getfield、putfield</p></li></ul><p>举例：以getstatic指令为例，它含有一个操作数，为指向常量池的Fieldref索引，它的作用就是获取Fieldref指定的对象或者值，并将其压入操作数栈。</p><pre><code class="highlight java"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setOrderId</span><span class="params">()</span>&#123;    <span class="type">Order</span> <span class="variable">order</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Order</span>();    order.id = <span class="number">1001</span>;    System.out.println(order.id);    Order.name = <span class="string">&quot;ORDER&quot;</span>;    System.out.println(Order.name);&#125;<span class="comment">// Order类代码如下:</span><span class="keyword">class</span> <span class="title class_">Order</span>&#123;    <span class="type">int</span> id;    <span class="keyword">static</span> String name;&#125;</code></pre><p>setOrderId() 方法对应的字节码指令：</p><pre><code class="highlight shell"> 0 new #11 &lt;com/atguigu/java/Order&gt; 3 dup 4 invokespecial #12 &lt;com/atguigu/java/Order.&lt;init&gt; : ()V&gt; 7 astore_1 8 aload_1 9 sipush 100112 putfield #13 &lt;com/atguigu/java/Order.id : I&gt;15 getstatic #8 &lt;java/lang/System.out : Ljava/io/PrintStream;&gt;18 aload_119 getfield #13 &lt;com/atguigu/java/Order.id : I&gt;22 invokevirtual #14 &lt;java/io/PrintStream.println : (I)V&gt;25 ldc #15 &lt;ORDER&gt;27 putstatic #16 &lt;com/atguigu/java/Order.name : Ljava/lang/String;&gt;30 getstatic #8 &lt;java/lang/System.out : Ljava/io/PrintStream;&gt;33 getstatic #16 &lt;com/atguigu/java/Order.name : Ljava/lang/String;&gt;36 invokevirtual #10 &lt;java/io/PrintStream.println : (Ljava/lang/String;)V&gt;39 return</code></pre><p><img src="https://raw.githubusercontent.com/GeorgeChan95/blogimg/master/img/2024/07/28/20240728-104906.png" alt="字节码指令执行过程"></p><h2 id="3-数组操作指令"><a href="#3-数组操作指令" class="headerlink" title="3. 数组操作指令"></a>3. 数组操作指令</h2><p>数组操作指令主要有：xastore和xaload指令。具体为：</p><ul><li><p>把一个数组元素加载到操作数栈的指令：baload、caload、saload、iaload、laload、faload、daload、aaload</p></li><li><p>将一个操作数栈的值存储到数组元素中的指令：bastore、castore、sastore、iastore、lastore、fastore、dastore、aastore</p></li></ul><table><thead><tr><th>数组指令</th><th>byte(boolean)</th><th>char</th><th>short</th><th>long</th><th>long</th><th>float</th><th>double</th><th>reference</th></tr></thead><tbody><tr><td><strong>xaload</strong></td><td>baload</td><td>caload</td><td>saload</td><td>iaload</td><td>laload</td><td>faload</td><td>daload</td><td>aaload</td></tr><tr><td><strong>xastore</strong></td><td>bastore</td><td>castore</td><td>sastore</td><td>iastore</td><td>lastore</td><td>fastore</td><td>dastore</td><td>aastore</td></tr></tbody></table><p>取数组长度的指令：<code>arraylength</code>。该指令弹出栈顶的数组元素，获取数组的长度，将长度压入栈。</p><p>指令 <code>xaload</code> 表示将数组的元素压栈，比如saload、caload分别表示压入short数组和char数组。指令xaload在执行时，要求操作数中栈顶元素为数组索引 i，栈顶顺位第2个元素为数组引用 a，该指令会弹出栈顶这两个元素，并将 a[i] 重新压入栈。</p><p><code>xastore</code> 则专门针对数组操作，以 iastore 为例，它用于给一个int数组的给定索引赋值。在iastore执行前，操作数栈顶需要以此准备3个元素：值、索引、数组引用，iastore会弹出这3个值，并将值赋给数组中指定索引的位置。</p><h2 id="4-类型检查指令"><a href="#4-类型检查指令" class="headerlink" title="4. 类型检查指令"></a>4. 类型检查指令</h2><p>检查类实例或数组类型的指令：instanceof、checkcast。</p><ul><li>指令 <code>instanceof</code> 用来判断给定对象是否是某一个类的实例，它会将判断结果压入操作数栈</li><li>指令 <code>checkcast</code> 用于检查类型强制转换是否可以进行。如果可以进行，那么checkcast指令不会改变操作数栈，否则它会抛出ClassCastException异常</li></ul><table><thead><tr><th>类型检查指令</th><th>含义</th></tr></thead><tbody><tr><td>instanceof</td><td>判断对象是否为给定的类型。后跟目标类，判断栈顶元素是否为目标类 &#x2F; 接口的实例。是则压入 1，否则压入 0</td></tr><tr><td>checkcast</td><td>确定对象为所给定的类型。后跟目标类，判断栈顶元素是否为目标类 &#x2F; 接口的实例。如果不是便抛出异常</td></tr></tbody></table><h1 id="六、方法的调用与返回指令"><a href="#六、方法的调用与返回指令" class="headerlink" title="六、方法的调用与返回指令"></a>六、方法的调用与返回指令</h1><ul><li><strong>方法调用指令</strong><ul><li>invokevirtual 运行时按照对象的类来调用实例方法</li><li>invokespecial 根据编译时类型来调用实例方法</li><li>invokestatic 调用类（静态）方法</li><li>invokcinterface 调用接口方法</li></ul></li><li><strong>方法返回指令</strong><ul><li>ireturn 从方法中返回int类型的数据</li><li>lreturn 从方法中返回long类型的数据</li><li>freturn 从方法中返回float类型的数据</li><li>dreturn 从方法中返回double类型的数据</li><li>areturn 从方法中返回引用类型的数据</li><li>return 从方法中返回，返回值为void</li></ul></li></ul><h2 id="1-方法调用指令"><a href="#1-方法调用指令" class="headerlink" title="1. 方法调用指令"></a>1. 方法调用指令</h2><p>方法调用指令：invokevirtual、invokeinterface、invokespecial、invokestatic、invokedynamic，以下5条指令用于方法调用：</p><ul><li><p><code>invokevirtual</code> 指令用于调用对象的实例方法，根据对象的实际类型进行分派（虚方法分派），支持多态。这也是Java语言中最常见的方法分派方式。</p><ul><li><p>首先，对象的实例方法是指定义在类中并用关键字“this”引用对象自身的方法，它们以对象作为调用者进行调用，而且同一个类的不同实例对象所调用的同名函数可能会表现出不同的行为。而调用对象的实例方法需要使用特定的指令来完成，Java语言中最常见的方法分派方式就是使用“invokevirtual”指令。</p><p>其次，“invokevirtual”指令支持多态，这也是Java语言中的一大特点。多态是指同一个函数名可以被多个子类继承并实现不同的方法，当程序调用该函数时，编译器不能确定调用的是哪个子类的方法，而是在运行时根据对象的实际类型进行分派，即虚方法分派。</p><p>具体来说，在执行“invokevirtual”指令时，虚拟机会根据对象的实际类型找到对应的方法，并进行调用。这个过程称为虚拟方法分派，它可以保证程序的灵活性和可扩展性，也是Java语言中面向对象特性的重要体现。</p><p>总之，“invokevirtual”指令用于调用对象的实例方法，根据对象的实际类型进行虚方法分派，支持多态，是Java语言中最常用的方法分派方式之一。</p></li></ul></li><li><p><code>invokeinterface</code> 指令用于调用接口方法，它会在运行时搜索由特定对象所实现的这个接口方法，并找出适合的方法进行调用。</p></li><li><p><code>invokespecial</code> 指令用于调用一些需要特殊处理的实例方法，包括实例初始化方法（构造器）、私有方法和父类方法。这些方法都是静态类型绑定的，不会在调用时进行动态派发。</p></li><li><p><code>invokestatic</code> 指令用于调用命名类中的类方法（static方法）。这是静态绑定的。</p></li><li><p><code>invokedynamic</code> 指令用于调用动态绑定的方法，这个是JDK1.7后新加入的指令。用于在运行时动态解析出调用点限定符所引用的方法，并执行该方法。<code>invokedynamic</code> 指令的分派逻辑是由用户所设定的引导方法决定的，而前面4条调用指令的分派逻辑都固化在java虚拟机内部。</p></li></ul><h2 id="2-方法返回指令"><a href="#2-方法返回指令" class="headerlink" title="2. 方法返回指令"></a>2. 方法返回指令</h2><p>方法调用结束前，需要进行返回。方法返回指令是根据返回值的类型区分的。</p><ul><li><p>包括ireturn（当返回值是boolean、byte、char、short和int 类型时使用）、lreturn、freturn、dreturn 和 areturn</p></li><li><p>另外还有一条return 指令供声明为void的方法、实例初始化方法以及类和接口的类初始化方法使用。</p></li></ul><table><thead><tr><th>方法返回指令</th><th>void</th><th>int、boolean、byte、char、short</th><th>long</th><th>float</th><th>double</th><th>reference</th></tr></thead><tbody><tr><td><strong>xreturn</strong></td><td>return</td><td>ireturn</td><td>lreturn</td><td>freutrn</td><td>dreturn</td><td>areturn</td></tr></tbody></table><p>通过ireturn指令，将当前函数操作数栈的顶层元素弹出，并将这个元素压入调用者函数的操作数栈中（因为调用者非常关心函数的返回值），所有在当前函数操作数栈中的其他元素都会被丢弃。</p><p>如果当前返回的是synchronized方法，那么还会执行一个隐含的monitorexit指令，退出临界区。</p><p>最后，会丢弃当前方法的整个帧，恢复调用者的帧，并将控制权转交给调用者。</p><p><strong>举例：</strong></p><pre><code class="highlight java"><span class="keyword">public</span> <span class="type">int</span> <span class="title function_">methodReturn</span><span class="params">()</span> &#123;    <span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">500</span>;    <span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> <span class="number">200</span>;    <span class="type">int</span> <span class="variable">k</span> <span class="operator">=</span> <span class="number">50</span>;        <span class="keyword">return</span> (i + j) / k;&#125;</code></pre><p><strong>图示：</strong></p><p><img src="https://raw.githubusercontent.com/GeorgeChan95/blogimg/master/img/2024/07/28/20240728-113404.png" alt="方法返回指令"></p><h1 id="七、操作数栈管理指令"><a href="#七、操作数栈管理指令" class="headerlink" title="七、操作数栈管理指令"></a>七、操作数栈管理指令</h1><h2 id="1-指令概述"><a href="#1-指令概述" class="headerlink" title="1. 指令概述"></a>1. 指令概述</h2><p>如同操作一个普通数据结构中的堆栈那样，JVM提供的操作数栈管理指令，可以用于直接操作操作数栈的指令。</p><p>这类指令包括如下内容：</p><ul><li><p>将一个或两个元素从栈顶弹出，并且直接废弃：<code>pop，pop2</code></p></li><li><p>复制栈顶占一个solt长度的值,并重新压入栈的指令: <code>dup，dup_x1，dup_×2</code></p></li><li><p>复制栈顶占两个solt长度的值(1个八子节或2个四字节的值),并重新压入栈的指令: <code>dup2，dup2_×1，dup2_×2</code></p></li><li><p>将栈最顶端的两个Slot数值位置交换：<code>swap</code>。Java虚拟机没有提供交换两个64位数据类型（long、double）数值的指令。</p></li><li><p>指令<code>nop</code>，是一个非常特殊的指令，它的字节码为0x00。和汇编语言中的nop一样，它表示什么都不做。这条指令一般可用于调试、占位等。</p></li></ul><p>这些指令属于通用型，对栈的压入或者弹出无需指明数据类型。</p><ul><li><p>不带_x的指令是复制栈顶数据并压入栈顶。包括两个指令，<code>dup，dup2</code>。dup的系数代表要复制的Slot个数。dup开头的指令用于复制1个Slot的数据。例如1个int或1个reference类型数据dup2开头的指令用于复制2个Slot的数据。例如1个long，或2个int，或1个int+1个float类型数据</p></li><li><p>带_x的指令是复制栈顶数据并插入栈顶以下的某个位置。共有4个指令，<code>dup_×1，dup2_×1，dup_×2，dup2×2</code>。对于带<em>x的复制插入指令，只要将指令的dup和x的系数相加，结果即为需要插入的位置。因此dup</em>×1插入位置：1+1&#x3D;2，即栈顶2个slot下面dup_×2插入位置：1+2&#x3D;3，即栈顶3个slot下面；dup2×1插入位置：2+1&#x3D;3，即栈顶3个Slot下面</p></li><li><p><code>pop</code>：将栈顶的1个Slot数值出栈。例如1个short类型数值</p></li><li><p><code>pop2</code>：将栈顶的2个slot数值出栈。例如1个double类型数值，或者2个int类型数值</p></li></ul><h2 id="2-实例解析"><a href="#2-实例解析" class="headerlink" title="2. 实例解析"></a>2. 实例解析</h2><p><strong>代码示例</strong></p><pre><code class="highlight java"><span class="keyword">private</span> <span class="type">long</span> <span class="variable">index</span> <span class="operator">=</span> <span class="number">0</span>;<span class="keyword">public</span> <span class="type">long</span> <span class="title function_">nextIndex</span><span class="params">()</span> &#123; <span class="comment">// 返回结果: 0</span>    <span class="keyword">return</span> ++index;&#125;</code></pre><p><strong>nextIndex()方法字节码</strong></p><pre><code class="highlight shell"> 0 aload_0 1 dup 2 getfield #2 &lt;com/atguigu/java/StackOperateTest.index : J&gt; 5 dup2_x1 6 lconst_1 7 ladd 8 putfield #2 &lt;com/atguigu/java/StackOperateTest.index : J&gt;11 lreturn</code></pre><p><strong>字节码解析</strong></p><p><img src="https://raw.githubusercontent.com/GeorgeChan95/blogimg/master/img/2024/07/28/20240728-182711.png" alt="操作数栈指令解析"></p><h1 id="八、控制转义指令"><a href="#八、控制转义指令" class="headerlink" title="八、控制转义指令"></a>八、控制转义指令</h1><p>程序流程离不开条件控制，为了支持条件跳转，虚拟机提供了大量字节码指令，大体上可以分为</p><ul><li><p>比较指令</p><ul><li><code>lcmp</code> 比较long类型值</li><li><code>fcmpl</code> 比较float类型值（当遇到NaN时，返回-1）</li><li><code>fcmpg</code> 比较float类型值（当遇到NaN时，返回1）</li><li><code>dcmpl</code> 比较double类型值（当遇到NaN时，返回-1）</li><li><code>dcmpg</code> 比较double类型值（当遇到NaN时，返回1）</li></ul></li><li><p>条件跳转指令</p><ul><li><code>ifeq</code> 如果等于0，则跳转</li><li><code>ifne</code> 如果不等于0，则跳转</li><li><code>iflt</code> 如果小于0，则跳转</li><li><code>ifge</code> 如果大于等于0，则跳转</li><li><code>ifgt</code> 如果大于0，则跳转</li><li><code>ifle</code> 如果小于等于0，则跳转</li></ul></li><li><p>比较条件跳转指令</p><ul><li><code>if_icmpeq</code> 如果两个int值相等，则跳转</li><li><code>if_icmpne</code> 如果两个int类型值不相等，则跳转</li><li><code>if_icmplt</code> 如果一个int类型值小于另外一个int类型值，则跳转</li><li><code>if_icmpge</code> 如果一个int类型值大于或者等于另外一个int类型值，则跳转</li><li><code>if_icmpgt</code> 如果一个int类型值大于另外一个int类型值，则跳转</li><li><code>if_icmple</code> 如果一个int类型值小于或者等于另外一个int类型值，则跳转</li><li><code>ifnull</code> 如果等于null，则跳转</li><li><code>ifnonnull</code> 如果不等于null，则跳转</li><li><code>if_acmpeq</code> 如果两个对象引用相等，则跳转</li><li><code>if_acmpne</code> 如果两个对象引用不相等，则跳转</li></ul></li><li><p>多条件分支跳转指令</p><ul><li><code>tableswitch</code> 通过索引访问跳转表，并跳转</li><li><code>lookupswitch</code> 通过键值匹配访问跳转表，并执行跳转操作</li></ul></li><li><p>无条件跳转指令等</p><ul><li><code>goto</code> 无条件跳转</li><li><code>goto_w</code> 无条件跳转（宽索引）</li></ul></li></ul><h2 id="1-比较指令"><a href="#1-比较指令" class="headerlink" title="1. 比较指令"></a>1. 比较指令</h2><p>比较指令的作用是比较占栈顶两个元素的大小，并将比较结果入栈。比较指令有： <code>dcmpg</code>、<code>dcmpl</code>、<code>fcmpg</code>、<code>fcmpl</code>、<code>lcmp</code>。与前面讲解的指令类似，首字符d表示double类型，f表示float, l表示long。</p><p>对于double和float类型的数字，由于NaN的存在，各有两个版本的比较指令。以float为例，有 fcmpg 和 fcmpl 两个指令，它们的区别在于在数字比较时，若遇到NaN值，处理结果不同。</p><p>指令 dcmpl 和 dcmpg 也是类似的，根据其命名可以推测其含义，在此不再赘述。</p><p>数值类型的数据，才可以谈大小！boolean、引用数据类型不能比较大小。</p><p><strong>举例</strong></p><pre><code class="highlight java"><span class="comment">//结合比较指令</span><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">compare2</span><span class="params">()</span> &#123;    <span class="type">float</span> <span class="variable">f1</span> <span class="operator">=</span> <span class="number">9</span>;    <span class="type">float</span> <span class="variable">f2</span> <span class="operator">=</span> <span class="number">10</span>;    System.out.println(f1 &lt; f2);<span class="comment">//true</span>&#125;</code></pre><p><strong>字节码:</strong></p><pre><code class="highlight txt"> 0 ldc #2 &lt;9.0&gt; 2 fstore_1 3 ldc #3 &lt;10.0&gt; 5 fstore_2 6 getstatic #4 &lt;java/lang/System.out : Ljava/io/PrintStream;&gt; 9 fload_110 fload_211 fcmpg12 ifge 19 (+7)15 iconst_116 goto 20 (+4)19 iconst_020 invokevirtual #5 &lt;java/io/PrintStream.println : (Z)V&gt;23 return</code></pre><p><img src="https://raw.githubusercontent.com/GeorgeChan95/blogimg/master/img/2024/07/31/20240731-192344.png" alt="字节码指令执行过程"></p><p><strong>解析:</strong></p><p>指令 fcmp和fcmpl都从中弹出两个操作数，并将它们做比较，设栈顶的元素为v2，顶顺位第2位的元素为v1：若v1&#x3D;v2，则压入0；若v1&gt;v2，则压入1；若v1&lt;v2，则压入-1。</p><p>两个指令的不同之处在于，如果遇到NaN值， fcmpg会压入1,而fcmpl会压入-1</p><h2 id="2-条件跳转指令"><a href="#2-条件跳转指令" class="headerlink" title="2. 条件跳转指令"></a>2. 条件跳转指令</h2><p>条件跳转指令通常和比较指令结合使用。在条件跳转指令执行前，一般可以先用比较指令进行栈顶元素的准备，然后进行条件跳转。</p><p>条件跳转指令有：ifeq，iflt，ifle，ifne，ifgt，ifge，ifnull，ifnonnull。这些指令都接收两个字节的操作数，用于计算跳转的位置（16位符号整数作为当前位置的offset）。</p><p>它们的统一含义为：弹出栈顶元素，测试它是否满足某一条件，如果满足条件，则跳转到给定位置。</p><table><thead><tr><th>&lt;</th><th>&lt;&#x3D;</th><th>&#x3D;&#x3D;</th><th>!&#x3D;</th><th>&gt;&#x3D;</th><th>&gt;</th><th>null</th><th>not null</th></tr></thead><tbody><tr><td>iflt</td><td>ifle</td><td>ifeq</td><td>ifng</td><td>ifge</td><td>ifgt</td><td>ifnull</td><td>ifnonnull</td></tr></tbody></table><p>与前面运算规则一致：</p><ul><li><p>对于boolean、byte、char、short类型的条件分支比较操作，都是使用int类型的比较指令完成</p></li><li><p>对于long、float、double类型的条件分支比较操作，则会先执行相应类型的比较运算指令，运算指令会返回一个整型值到操作数栈中，随后再执行int类型的条件分支比较操作来完成整个分支跳转</p></li></ul><p>由于各类型的比较最终都会转为int类型的比较操作，所以Java虚拟机提供的int类型的条件分支指令是最为丰富和强大的。</p><h2 id="3-比较条件跳转指令"><a href="#3-比较条件跳转指令" class="headerlink" title="3. 比较条件跳转指令"></a>3. 比较条件跳转指令</h2><p>比较条件跳转指令类似于比较指令和条件跳转指令的结合体，它将比较和跳转两个步骤合二为一。</p><p>这类指令有：<code>if_icmpeq</code>、<code>if_icmpne</code>、<code>if_icmplt</code>、<code>if_icmpgt</code>、<code>if_icmple</code>、<code>if_icmpge</code>、<code>if_acmpeq</code> 和 <code>if_acmpne</code>。其中指令助记符加上“if_”后，以字符“i”开头的指令针对 int 型整数操作（也包括short和byte类型），以字符“a”开头的指令表示对象引用的比较。</p><table><thead><tr><th>&lt;</th><th>&lt;&#x3D;</th><th>&#x3D;&#x3D;</th><th>!&#x3D;</th><th>&gt;&#x3D;</th><th>&gt;</th></tr></thead><tbody><tr><td>if_icmplt</td><td>if_icmple</td><td>if_icmpeq、if_acmpeq</td><td>if_icmpne、if_acmpne</td><td>if_icmpge</td><td>if_icmpgt</td></tr></tbody></table><p>这些指令都接收两个字节的操作数作为参数，用于计算跳转的位置。同时在执行指令时，栈顶需要准备两个元素进行比较。指令执行完成后，栈顶的这两个元素被清空，且没有任何数据入栈。如果预设条件成立，则执行跳转，否则，继续执行下一条语句。</p><p><strong>示例</strong></p><pre><code class="highlight java"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">ifCompare3</span><span class="params">()</span> &#123;        <span class="type">Object</span> <span class="variable">obj1</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Object</span>();        <span class="type">Object</span> <span class="variable">obj2</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Object</span>();        System.out.println(obj1 == obj2);<span class="comment">//false</span>        System.out.println(obj1 != obj2);<span class="comment">//true</span>    &#125;</code></pre><p><strong>字节码</strong></p><pre><code class="highlight txt"> 0 new #10 &lt;java/lang/Object&gt; 3 dup 4 invokespecial #1 &lt;java/lang/Object.&lt;init&gt; : ()V&gt; 7 astore_1 8 new #10 &lt;java/lang/Object&gt;11 dup12 invokespecial #1 &lt;java/lang/Object.&lt;init&gt; : ()V&gt;15 astore_216 getstatic #4 &lt;java/lang/System.out : Ljava/io/PrintStream;&gt;19 aload_120 aload_221 if_acmpne 28 (+7)24 iconst_125 goto 29 (+4)28 iconst_029 invokevirtual #5 &lt;java/io/PrintStream.println : (Z)V&gt;32 getstatic #4 &lt;java/lang/System.out : Ljava/io/PrintStream;&gt;35 aload_136 aload_237 if_acmpeq 44 (+7)40 iconst_141 goto 45 (+4)44 iconst_045 invokevirtual #5 &lt;java/io/PrintStream.println : (Z)V&gt;48 return</code></pre><h2 id="4-多条件分支跳转指令"><a href="#4-多条件分支跳转指令" class="headerlink" title="4. 多条件分支跳转指令"></a>4. 多条件分支跳转指令</h2><p>多条件分支跳转指令是专为switch-case语句设计的，主要有 <code>tableswitch</code> 和 <code>lookupswitch</code> 。</p><table><thead><tr><th>指令名称</th><th>描述</th></tr></thead><tbody><tr><td>tableswitch</td><td>用于switch条件跳转，case值连续</td></tr><tr><td>lookupswitch</td><td>用于switch条件跳转，case值不连续</td></tr></tbody></table><p>从助记符上看，两者都是switch语句的实现，它们的区别：</p><ul><li><p><code>tableswitch</code> 要求多个条件分支值是连续的，它内部只存放起始值和终止值，以及若干个跳转偏移量，通过给定的操作数index，可以立即定位到跳转偏移量位置，因此效率比较高。</p></li><li><p><code>lookupswitch</code> 内部存放着各个离散的case-offset对，每次执行都要搜索全部的case-offset对，找到匹配的case值，并根据对应的offset计算跳转地址，因此效率较低。</p></li></ul><p>指令tableswitch的示意图如下图所示。由于tableswitch的case值是连续的，因此只需要记录最低值和最高值，以及每一项对应的offset偏移量，根据给定的index值通过简单的计算即可直接定位到offset。</p><p><img src="https://raw.githubusercontent.com/GeorgeChan95/blogimg/master/img/2024/07/31/20240731-200001.png" alt="table-switch"></p><p><strong>示例:</strong></p><pre><code class="highlight java"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">swtich2</span><span class="params">(<span class="type">int</span> select)</span>&#123;    <span class="type">int</span> num;    <span class="keyword">switch</span>(select)&#123;        <span class="keyword">case</span> <span class="number">100</span>:            num = <span class="number">10</span>;            <span class="keyword">break</span>;        <span class="keyword">case</span> <span class="number">500</span>:            num = <span class="number">20</span>;            <span class="keyword">break</span>;        <span class="keyword">case</span> <span class="number">200</span>:            num = <span class="number">30</span>;            <span class="keyword">break</span>;        <span class="keyword">default</span>:            num = <span class="number">40</span>;    &#125;&#125;</code></pre><p><strong>字节码</strong></p><pre><code class="highlight txt"> 0 iload_1 1 tableswitch 1 to 31:  28 (+27)2:  34 (+33)3:  37 (+36)default:  43 (+42)28 bipush 1030 istore_231 goto 46 (+15)34 bipush 2036 istore_237 bipush 3039 istore_240 goto 46 (+6)43 bipush 4045 istore_246 return</code></pre><p>指令 lookupswitch 处理的是离散的case值，但是出于效率考虑，将case-offset对按照case值大小排序，给定index时，需要查找与index相等的case，获得其offset，如果找不到则跳转到default。指令lookupswitch如下图所示。</p><p><img src="https://raw.githubusercontent.com/GeorgeChan95/blogimg/master/img/2024/07/31/20240731-200220.png" alt="lookupswitch"></p><p><strong>示例</strong></p><pre><code class="highlight java"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">swtich2</span><span class="params">(<span class="type">int</span> select)</span>&#123;    <span class="type">int</span> num;    <span class="keyword">switch</span>(select)&#123;        <span class="keyword">case</span> <span class="number">100</span>:            num = <span class="number">10</span>;            <span class="keyword">break</span>;        <span class="keyword">case</span> <span class="number">500</span>:            num = <span class="number">20</span>;            <span class="keyword">break</span>;        <span class="keyword">case</span> <span class="number">200</span>:            num = <span class="number">30</span>;            <span class="keyword">break</span>;        <span class="keyword">default</span>:            num = <span class="number">40</span>;    &#125;&#125;</code></pre><p><strong>字节码</strong></p><pre><code class="highlight txt"> 0 iload_1 1 lookupswitch 3100:  36 (+35)200:  48 (+47)500:  42 (+41)default:  54 (+53)36 bipush 1038 istore_239 goto 57 (+18)42 bipush 2044 istore_245 goto 57 (+12)48 bipush 3050 istore_251 goto 57 (+6)54 bipush 4056 istore_257 return</code></pre><h2 id="5-无条件跳转指令"><a href="#5-无条件跳转指令" class="headerlink" title="5. 无条件跳转指令"></a>5. 无条件跳转指令</h2><p>目前主要的无条件跳转指令为goto。指令goto接收两个字节的操作数，共同组成一个带符号的整数，用于指定指令的偏移量，指令执行的目的就是跳转到偏移量给定的位置处。</p><p>如果指令偏移量太大，超过双字节的带符号整数的范围，则可以使用指令goto_w，它和goto有相同的作用，但是它接收4个字节的操作数，可以表示更大的地址范围。</p><p><em>指令jsr、jsr_w、ret虽然也是无条件跳转的，但主要用于try-finally语句，且已经被虚拟机逐渐废弃，故不在这里介绍这两个指令。</em></p><table><thead><tr><th>指令名称</th><th>描述</th></tr></thead><tbody><tr><td>goto</td><td>无条件跳转</td></tr><tr><td>goto_w</td><td>无条件跳转（宽索引）</td></tr><tr><td>jsr</td><td>跳转至指定16位offset位置，并将jsr下一条指令地址压入栈顶</td></tr><tr><td>jsr_w</td><td>跳转至指定32位offer位置，并将jsr_w下一条指令地址压入栈顶</td></tr><tr><td>ret</td><td>返回至由指定的局部变量所给出的指令位置（一般与jsr、jsr_w联合使用）</td></tr></tbody></table><h1 id="九、异常处理指令"><a href="#九、异常处理指令" class="headerlink" title="九、异常处理指令"></a>九、异常处理指令</h1><p><strong>异常处理指令</strong></p><ul><li><code>athrow</code> 抛出异常或错误。将栈顶异常抛出</li><li><code>jsr</code> 跳转到子例程</li><li><code>jsr_w</code> 跳转到子例程（宽索引）</li><li><code>ret</code> 从子例程返回</li></ul><h2 id="1-athrow指令"><a href="#1-athrow指令" class="headerlink" title="1. athrow指令"></a>1. athrow指令</h2><p>在Java程序中显示抛出异常的操作（throw语句）都是由athrow指令来实现。</p><p>除了使用throw语句显示抛出异常情况之外，JVM规范还规定了许多运行时异常会在其他Java虚拟机指令检测到异常状况时自动抛出。例如，在之前介绍的整数运算时，当除数为零时，虚拟机会在 <code>idiv</code> 或 <code>ldiv</code> 指令中抛出ArithmeticException异常。</p><p><strong>正常情况下，操作数栈的压入弹出都是一条条指令完成的。唯一的例外情况是在抛异常时，Java虚拟机会清除操作数栈上的所有内容，而后将异常实例压入调用者操作数栈上。</strong></p><p><strong>注意：</strong></p><p>如果使用throw new 异常名称()这种形式来抛出异常，那就会在代码中出现athrow指令，而在方法上面添加throw 异常名称这种形式来抛出异常，然后使用jclasslib的时候就会出现在方法下面多出现一个属性Exceptions，如下图所示：</p><p><img src="https://raw.githubusercontent.com/GeorgeChan95/blogimg/master/img/2024/07/31/20240731-201555.png" alt="image-20240731201553896"></p><p><strong>示例:</strong></p><pre><code class="highlight java"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">throwOne</span><span class="params">(<span class="type">int</span> i)</span> <span class="keyword">throws</span> RuntimeException,IOException&#123;    <span class="keyword">if</span>(i == <span class="number">1</span>)&#123;        <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">RuntimeException</span>(<span class="string">&quot;参数值为1&quot;</span>);    &#125;&#125;</code></pre><p><img src="https://raw.githubusercontent.com/GeorgeChan95/blogimg/master/img/2024/07/31/20240731-201731.png" alt="image-20240731201731105"></p><p><img src="https://raw.githubusercontent.com/GeorgeChan95/blogimg/master/img/2024/07/31/20240731-201747.png" alt="image-20240731201746649"></p><h2 id="2-处理异常"><a href="#2-处理异常" class="headerlink" title="2. 处理异常"></a>2. 处理异常</h2><p>在Java虚拟机中，处理异常（catch语句）不是由字节码指令来实现的（早期使用jsr、ret指令），而是采用异常表来完成的。</p><h2 id="3-异常表"><a href="#3-异常表" class="headerlink" title="3. 异常表"></a>3. 异常表</h2><p>如果一个方法定义了一个try-catch 或者try-finally的异常处理，就会创建一个异常表。它包含了每个异常处理或者finally块的信息。异常表保存了每个异常处理信息。比如：</p><ul><li><p>起始位置</p></li><li><p>结束位置</p></li><li><p>程序计数器记录的代码处理的偏移地址</p></li><li><p>被捕获的异常类在常量池中的索引</p></li></ul><p>当一个异常被抛出时，JVM会在当前的方法里寻找一个匹配的处理，如果没有找到，这个方法会强制结束并弹出当前栈帧，并且异常会重新抛给上层调用的方法（在调用方法栈帧）。如果在所有栈帧弹出前仍然没有找到合适的异常处理，这个线程将终止。如果这个异常在最后一个非守护线程里抛出，将会导致JVM自己终止，比如这个线程是个main线程。</p><p>不管什么时候抛出异常，如果异常处理最终匹配了所有异常类型，代码就会继续执行。在这种情况下，如果方法结束后没有抛出异常，仍然执行finally块，在return前，它直接跳到finally块来完成目标</p><p><strong>示例:</strong></p><pre><code class="highlight java"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">tryCatch</span><span class="params">()</span>&#123;    <span class="keyword">try</span>&#123;        <span class="type">File</span> <span class="variable">file</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">File</span>(<span class="string">&quot;d:/hello.txt&quot;</span>);        <span class="type">FileInputStream</span> <span class="variable">fis</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">FileInputStream</span>(file);        <span class="type">String</span> <span class="variable">info</span> <span class="operator">=</span> <span class="string">&quot;hello!&quot;</span>;    &#125;<span class="keyword">catch</span> (FileNotFoundException e) &#123;        e.printStackTrace();    &#125;    <span class="keyword">catch</span>(RuntimeException e)&#123;        e.printStackTrace();    &#125;&#125;</code></pre><p><strong>字节码</strong></p><pre><code class="highlight txt"> 0 new #8 &lt;java/io/File&gt; 3 dup 4 ldc #9 &lt;d:/hello.txt&gt; 6 invokespecial #10 &lt;java/io/File.&lt;init&gt; : (Ljava/lang/String;)V&gt; 9 astore_110 new #11 &lt;java/io/FileInputStream&gt;13 dup14 aload_115 invokespecial #12 &lt;java/io/FileInputStream.&lt;init&gt; : (Ljava/io/File;)V&gt;18 astore_219 ldc #13 &lt;hello!&gt;21 astore_322 goto 38 (+16)25 astore_126 aload_127 invokevirtual #15 &lt;java/io/FileNotFoundException.printStackTrace : ()V&gt;30 goto 38 (+8)33 astore_134 aload_135 invokevirtual #16 &lt;java/lang/RuntimeException.printStackTrace : ()V&gt;38 return</code></pre><p><img src="https://raw.githubusercontent.com/GeorgeChan95/blogimg/master/img/2024/07/31/20240731-202434.png" alt="异常表"></p><h1 id="十、同步控制指令"><a href="#十、同步控制指令" class="headerlink" title="十、同步控制指令"></a>十、同步控制指令</h1><p>Java虚拟机支持两种同步结构：方法级的同步和方法内部一段指令序列的同步，这两种同步都是使用monitor来支持的. </p><h2 id="1-方法级的同步"><a href="#1-方法级的同步" class="headerlink" title="1. 方法级的同步"></a>1. 方法级的同步</h2><p><strong>方法级的同步：是隐式的</strong>，即无须通过字节码指令来控制，它实现在方法调用和返回操作之中。虚拟机可以从方法常量池的方法表结构中的 <code>ACC_SYNCHRONIZED</code>访问标志 得知一个方法是否声明为同步方法；</p><p>当调用方法时，调用指令将会检查方法的 <strong>ACC_SYNCHRONIZED访问标志</strong> 是否设置。</p><ul><li><p>如果设置了，执行线程将先持有同步锁，然后执行方法。最后在方法完成（无论是正常完成还是非正常完成）时释放同步锁。</p></li><li><p>在方法执行期间，执行线程持有了同步锁，其他任何线程都无法再获得同一个锁。</p></li><li><p>如果一个同步方法执行期间抛出了异常，并且在方法内部无法处理此异常，<strong>那这个同步方法所持有的锁将在异常抛到同步方法之外时自动释放</strong>。</p></li></ul><p><strong>示例</strong></p><pre><code class="highlight java"><span class="keyword">private</span> <span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>;<span class="keyword">public</span> <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title function_">add</span><span class="params">()</span> &#123;i++;&#125;</code></pre><p>对应的字节码：</p><pre><code class="highlight txt"> 0 aload_0 1 dup 2 getfield #2 &lt;com/atguigu/java1/SynchronizedTest.i : I&gt; 5 iconst_1 6 iadd 7 putfield #2 &lt;com/atguigu/java1/SynchronizedTest.i : I&gt;10 return</code></pre><p>这段代码和普通的无同步操作的代码没有什么不同，没有使用 <code>monitorenter</code> 和 <code>monitorexit</code> 进行同步区控制。</p><p>这是因为，对于同步方法而言，当虚拟机通过方法的访问标示符判断是一个同步方法时，会自动在方法调用前进行加锁，当同步方法执行完毕后，不管方法是正常结束还是有异常抛出，均会由虚拟机释放这个锁。</p><p><img src="https://raw.githubusercontent.com/GeorgeChan95/blogimg/master/img/2024/07/31/20240731-203639.png" alt="方法级同步"></p><p>因此，对于同步方法而言，monitorenter 和 monitorexit 指令是隐式存在的，并未直接出现在字节码中。</p><h2 id="2-方法内指令指令序列的同步"><a href="#2-方法内指令指令序列的同步" class="headerlink" title="2. 方法内指令指令序列的同步"></a>2. 方法内指令指令序列的同步</h2><p>同步一段指令集序列：通常是由java中的 synchronized语句块 来表示的。jvm的指令集有 <code>monitorenter</code> 和 <code>monitorexit</code> 两条指令来支持synchronized关键字的语义。</p><p>当一个线程进入同步代码块时，它使用 monitorenter 指令请求进入。如果当前对象的监视器计数器为0，则它会被准许进入，若为1，则判断持有当前监视器的线程是否为自己，如果是，则进入，否则进行等待，直到对象的监视器计数器为0，才会被允许进入同步块。</p><p>当线程退出同步块时，需要使用monitorexit声明退出。在Java虚拟机中，任何对象都有一个监视器与之相关联，用来判断对象是否被锁定，当监视器被持有后，对象处于锁定状态。</p><p>指令monitorenter和monitorexit在执行时，都需要在操作数栈顶压入对象，之后 monitorenter 和 monitorexit 的锁定和释放都是针对这个对象的监视器进行的。</p><p><strong>示例:</strong></p><pre><code class="highlight java"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">subtract</span><span class="params">()</span>&#123;    <span class="keyword">synchronized</span> (obj)&#123;        i--;    &#125;&#125;</code></pre><p><strong>字节码</strong></p><pre><code class="highlight txt">0: aloade 1: dup 2: astore_1 3: monitorenter 4: aload_0 5: dup 6: getfield #2 //Field i:I 9: iconst_110: isub11: putfield #2 //Field i:I14: aload_115: monitorexit16: goto 2419: astore_226: aload_121: monitorexit22: aload_223: athrow24: returnException table:from to target type4 16   19  any19 22    19  any</code></pre><p>编译器必须确保无论方法通过何种方式完成，方法中调用过的每条monitorenter指令都必须执行其对应的monitorexit指令，而无论这个方法是正常结束还是异常结束。</p><p>为了保证在方法异常完成时monitorenter和monitorexit指令依然可以正确配对执行，编译器会自动产生一个异常处理器，这个异常处理器声明可处理所有的异常，它的目的就是用来执行monitorexit</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;一、概述&quot;&gt;&lt;a href=&quot;#一、概述&quot; class=&quot;headerlink&quot; title=&quot;一、概述&quot;&gt;&lt;/a&gt;一、概述&lt;/h1&gt;&lt;ul&gt;
&lt;li&gt;java字节码对于虚拟机，就好像汇编语言对于计算机，属于基本执行指令。&lt;/li&gt;
&lt;li&gt;Java 虚拟机的指令</summary>
      
    
    
    
    <category term="JVM" scheme="https://georgechan95.github.io/categories/JVM/"/>
    
    
    <category term="java" scheme="https://georgechan95.github.io/tags/java/"/>
    
    <category term="jvm" scheme="https://georgechan95.github.io/tags/jvm/"/>
    
  </entry>
  
  <entry>
    <title>第十七章-使用javap指令解析class文件</title>
    <link href="https://georgechan95.github.io/blog/2772873157.html"/>
    <id>https://georgechan95.github.io/blog/2772873157.html</id>
    <published>2024-07-22T15:54:00.000Z</published>
    <updated>2024-08-28T04:17:33.361Z</updated>
    
    <content type="html"><![CDATA[<h1 id="一、解析字节码的作用"><a href="#一、解析字节码的作用" class="headerlink" title="一、解析字节码的作用"></a>一、解析字节码的作用</h1><p>通过反编译生成的字节码文件，我们可以深入的了解java代码的工作机制。但是，自己分析类文件结构太麻烦了! 除了使用第三方的jclasslib工具之外，oracle官方也提供了工具: <code>javap</code> 。<br>javap 是jdk自带的反解析工具。它的作用就是根据class字节码文件，反解析出当前类对应的code区(字节码指令)局部变量表、异常表和代码行偏移量映射表、常量池等信息。<br>通过局部变量表，我们可以查看局部变量的作用域范围、所在槽位等信息，甚至可以看到槽位复用等信息。</p><h1 id="二、javac-g-操作"><a href="#二、javac-g-操作" class="headerlink" title="二、javac -g 操作"></a>二、javac -g 操作</h1><p>解析字节码文件得到的信息中，有些信息(如局部变量表、指令和代码行偏移量映射表、常量池中方法的参数名称等等)需要在使用javac编译成class文件时，指定参数才能输出。<br>比如，你直接javac xx.java，就不会在生成对应的局部变量表等信息，如果你使用javac -g xx.java就可以生成所有相关信息了。如果你使用的eclipse或 IDEA，则默认情况下，eclipse、IDEA在编译时会帮你生成局部变量表、指令和代码行偏移量映射表等信息的。</p><h1 id="三、javap-的用法"><a href="#三、javap-的用法" class="headerlink" title="三、javap 的用法"></a>三、javap 的用法</h1><p>javap的用法格式:</p><ul><li><p>javap <options> <classes></p><ul><li><p>其中，classes就是你要反编译的class文件。</p></li><li><p>在命令行中直接输入javap或javap -help可以看到javap的options有如下选项:</p><p><img src="https://raw.githubusercontent.com/GeorgeChan95/blogimg/master/img/2024/07/22/20240722-094028.png" alt="javap"></p></li></ul></li></ul><p>一般常用的是 -v -l -c三个选项。</p><ul><li>javap -l 会输出行号和本地变量表信息。</li><li>javap -c 会对当前class字节码进行反编译生成汇编代码。</li><li>javap -v classxx 除了包含-c内容外，还会输出行号、局部变量表信息、常量池等信息。</li></ul><p><strong>注意：</strong></p><p>① -v 相当于 -c -l </p><p>② -v 也不会输出私有的字段、方法等信息，所以如果想输出私有的信息，那需要在 -v 后面加上 -p 才行</p><h1 id="四、使用举例"><a href="#四、使用举例" class="headerlink" title="四、使用举例"></a>四、使用举例</h1><h2 id="1-代码"><a href="#1-代码" class="headerlink" title="1. 代码"></a>1. 代码</h2><pre><code class="highlight java"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">JavapTest</span> &#123;    <span class="keyword">private</span> <span class="type">int</span> num;    <span class="type">boolean</span> flag;    <span class="keyword">protected</span> <span class="type">char</span> gender;    <span class="keyword">public</span> String info;    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">int</span> <span class="variable">COUNTS</span> <span class="operator">=</span> <span class="number">1</span>;    <span class="keyword">static</span>&#123;        <span class="type">String</span> <span class="variable">url</span> <span class="operator">=</span> <span class="string">&quot;www.atguigu.com&quot;</span>;    &#125;    &#123;        info = <span class="string">&quot;java&quot;</span>;    &#125;    <span class="keyword">public</span> <span class="title function_">JavapTest</span><span class="params">()</span>&#123;    &#125;    <span class="keyword">private</span> <span class="title function_">JavapTest</span><span class="params">(<span class="type">boolean</span> flag)</span>&#123;        <span class="built_in">this</span>.flag = flag;    &#125;    <span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">methodPrivate</span><span class="params">()</span>&#123;    &#125;    <span class="type">int</span> <span class="title function_">getNum</span><span class="params">(<span class="type">int</span> i)</span>&#123;        <span class="keyword">return</span> num + i;    &#125;    <span class="keyword">protected</span> <span class="type">char</span> <span class="title function_">showGender</span><span class="params">()</span>&#123;        <span class="keyword">return</span> gender;    &#125;    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">showInfo</span><span class="params">()</span>&#123;        <span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">10</span>;        System.out.println(info + i);    &#125;&#125;</code></pre><h2 id="2-字节码分析"><a href="#2-字节码分析" class="headerlink" title="2. 字节码分析"></a>2. 字节码分析</h2><h3 id="2-1-使用-javap-命令解析class文件"><a href="#2-1-使用-javap-命令解析class文件" class="headerlink" title="2.1 使用 javap 命令解析class文件"></a>2.1 使用 <code>javap</code> 命令解析class文件</h3><pre><code class="highlight shell">javap -v -p JavapTest</code></pre><h3 id="2-2-版本信息"><a href="#2-2-版本信息" class="headerlink" title="2.2 版本信息"></a>2.2 版本信息</h3><pre><code class="highlight shell">警告: 二进制文件JavapTest包含com.atguigu.java1.JavapTestClassfile /E:/testWorkspace/jvm-demo-mid/out/production/chapter01/com/atguigu/java1/JavapTest.class   // 字节码文件所属的路径  Last modified 2024-7-22; size 1358 bytes  // 最后修改时间，字节码文件的大小  MD5 checksum 526b4a845e4d98180438e4c5781b7e88 // MD5散列值  Compiled from &quot;JavapTest.java&quot;   // 源文件的名称public class com.atguigu.java1.JavapTest  minor version: 0 // 副版本  major version: 52 // 主版本  flags: ACC_PUBLIC, ACC_SUPER // 访问标识</code></pre><h3 id="2-3-常量池"><a href="#2-3-常量池" class="headerlink" title="2.3 常量池"></a>2.3 常量池</h3><pre><code class="highlight shell">Constant pool:<span class="meta prompt_">   #</span><span class="language-bash">1 = Methodref          <span class="comment">#16.#46        // java/lang/Object.&quot;&lt;init&gt;&quot;:()V</span></span><span class="meta prompt_">   #</span><span class="language-bash">2 = String             <span class="comment">#47            // java</span></span><span class="meta prompt_">   #</span><span class="language-bash">3 = Fieldref           <span class="comment">#15.#48        // com/atguigu/java1/JavapTest.info:Ljava/lang/String;</span></span><span class="meta prompt_">   #</span><span class="language-bash">4 = Fieldref           <span class="comment">#15.#49        // com/atguigu/java1/JavapTest.flag:Z</span></span><span class="meta prompt_">   #</span><span class="language-bash">5 = Fieldref           <span class="comment">#15.#50        // com/atguigu/java1/JavapTest.num:I</span></span><span class="meta prompt_">   #</span><span class="language-bash">6 = Fieldref           <span class="comment">#15.#51        // com/atguigu/java1/JavapTest.gender:C</span></span><span class="meta prompt_">   #</span><span class="language-bash">7 = Fieldref           <span class="comment">#52.#53        // java/lang/System.out:Ljava/io/PrintStream;</span></span><span class="meta prompt_">   #</span><span class="language-bash">8 = Class              <span class="comment">#54            // java/lang/StringBuilder</span></span><span class="meta prompt_">   #</span><span class="language-bash">9 = Methodref          <span class="comment">#8.#46         // java/lang/StringBuilder.&quot;&lt;init&gt;&quot;:()V</span></span><span class="meta prompt_">  #</span><span class="language-bash">10 = Methodref          <span class="comment">#8.#55         // java/lang/StringBuilder.append:(Ljava/lang/String;)Ljava/lang/StringBuilder;</span></span><span class="meta prompt_">  #</span><span class="language-bash">11 = Methodref          <span class="comment">#8.#56         // java/lang/StringBuilder.append:(I)Ljava/lang/StringBuilder;</span></span><span class="meta prompt_">  #</span><span class="language-bash">12 = Methodref          <span class="comment">#8.#57         // java/lang/StringBuilder.toString:()Ljava/lang/String;</span></span><span class="meta prompt_">  #</span><span class="language-bash">13 = Methodref          <span class="comment">#58.#59        // java/io/PrintStream.println:(Ljava/lang/String;)V</span></span><span class="meta prompt_">  #</span><span class="language-bash">14 = String             <span class="comment">#60            // www.atguigu.com</span></span><span class="meta prompt_">  #</span><span class="language-bash">15 = Class              <span class="comment">#61            // com/atguigu/java1/JavapTest</span></span><span class="meta prompt_">  #</span><span class="language-bash">16 = Class              <span class="comment">#62            // java/lang/Object</span></span><span class="meta prompt_">  #</span><span class="language-bash">17 = Utf8               num</span><span class="meta prompt_">  #</span><span class="language-bash">18 = Utf8               I</span><span class="meta prompt_">  #</span><span class="language-bash">19 = Utf8               flag</span><span class="meta prompt_">  #</span><span class="language-bash">20 = Utf8               Z</span><span class="meta prompt_">  #</span><span class="language-bash">21 = Utf8               gender</span><span class="meta prompt_">  #</span><span class="language-bash">22 = Utf8               C</span><span class="meta prompt_">  #</span><span class="language-bash">23 = Utf8               info</span><span class="meta prompt_">  #</span><span class="language-bash">24 = Utf8               Ljava/lang/String;</span><span class="meta prompt_">  #</span><span class="language-bash">25 = Utf8               COUNTS</span><span class="meta prompt_">  #</span><span class="language-bash">26 = Utf8               ConstantValue</span><span class="meta prompt_">  #</span><span class="language-bash">27 = Integer            1</span><span class="meta prompt_">  #</span><span class="language-bash">28 = Utf8               &lt;init&gt;</span><span class="meta prompt_">  #</span><span class="language-bash">29 = Utf8               ()V</span><span class="meta prompt_">  #</span><span class="language-bash">30 = Utf8               Code</span><span class="meta prompt_">  #</span><span class="language-bash">31 = Utf8               LineNumberTable</span><span class="meta prompt_">  #</span><span class="language-bash">32 = Utf8               LocalVariableTable</span><span class="meta prompt_">  #</span><span class="language-bash">33 = Utf8               this</span><span class="meta prompt_">  #</span><span class="language-bash">34 = Utf8               Lcom/atguigu/java1/JavapTest;</span><span class="meta prompt_">  #</span><span class="language-bash">35 = Utf8               (Z)V</span><span class="meta prompt_">  #</span><span class="language-bash">36 = Utf8               methodPrivate</span><span class="meta prompt_">  #</span><span class="language-bash">37 = Utf8               getNum</span><span class="meta prompt_">  #</span><span class="language-bash">38 = Utf8               (I)I</span><span class="meta prompt_">  #</span><span class="language-bash">39 = Utf8               i</span><span class="meta prompt_">  #</span><span class="language-bash">40 = Utf8               showGender</span><span class="meta prompt_">  #</span><span class="language-bash">41 = Utf8               ()C</span><span class="meta prompt_">  #</span><span class="language-bash">42 = Utf8               showInfo</span><span class="meta prompt_">  #</span><span class="language-bash">43 = Utf8               &lt;clinit&gt;</span><span class="meta prompt_">  #</span><span class="language-bash">44 = Utf8               SourceFile</span><span class="meta prompt_">  #</span><span class="language-bash">45 = Utf8               JavapTest.java</span><span class="meta prompt_">  #</span><span class="language-bash">46 = NameAndType        <span class="comment">#28:#29        // &quot;&lt;init&gt;&quot;:()V</span></span><span class="meta prompt_">  #</span><span class="language-bash">47 = Utf8               java</span><span class="meta prompt_">  #</span><span class="language-bash">48 = NameAndType        <span class="comment">#23:#24        // info:Ljava/lang/String;</span></span><span class="meta prompt_">  #</span><span class="language-bash">49 = NameAndType        <span class="comment">#19:#20        // flag:Z</span></span><span class="meta prompt_">  #</span><span class="language-bash">50 = NameAndType        <span class="comment">#17:#18        // num:I</span></span><span class="meta prompt_">  #</span><span class="language-bash">51 = NameAndType        <span class="comment">#21:#22        // gender:C</span></span><span class="meta prompt_">  #</span><span class="language-bash">52 = Class              <span class="comment">#63            // java/lang/System</span></span><span class="meta prompt_">  #</span><span class="language-bash">53 = NameAndType        <span class="comment">#64:#65        // out:Ljava/io/PrintStream;</span></span><span class="meta prompt_">  #</span><span class="language-bash">54 = Utf8               java/lang/StringBuilder</span><span class="meta prompt_">  #</span><span class="language-bash">55 = NameAndType        <span class="comment">#66:#67        // append:(Ljava/lang/String;)Ljava/lang/StringBuilder;</span></span><span class="meta prompt_">  #</span><span class="language-bash">56 = NameAndType        <span class="comment">#66:#68        // append:(I)Ljava/lang/StringBuilder;</span></span><span class="meta prompt_">  #</span><span class="language-bash">57 = NameAndType        <span class="comment">#69:#70        // toString:()Ljava/lang/String;</span></span><span class="meta prompt_">  #</span><span class="language-bash">58 = Class              <span class="comment">#71            // java/io/PrintStream</span></span><span class="meta prompt_">  #</span><span class="language-bash">59 = NameAndType        <span class="comment">#72:#73        // println:(Ljava/lang/String;)V</span></span><span class="meta prompt_">  #</span><span class="language-bash">60 = Utf8               www.atguigu.com</span><span class="meta prompt_">  #</span><span class="language-bash">61 = Utf8               com/atguigu/java1/JavapTest</span><span class="meta prompt_">  #</span><span class="language-bash">62 = Utf8               java/lang/Object</span><span class="meta prompt_">  #</span><span class="language-bash">63 = Utf8               java/lang/System</span><span class="meta prompt_">  #</span><span class="language-bash">64 = Utf8               out</span><span class="meta prompt_">  #</span><span class="language-bash">65 = Utf8               Ljava/io/PrintStream;</span><span class="meta prompt_">  #</span><span class="language-bash">66 = Utf8               append</span><span class="meta prompt_">  #</span><span class="language-bash">67 = Utf8               (Ljava/lang/String;)Ljava/lang/StringBuilder;</span><span class="meta prompt_">  #</span><span class="language-bash">68 = Utf8               (I)Ljava/lang/StringBuilder;</span><span class="meta prompt_">  #</span><span class="language-bash">69 = Utf8               toString</span><span class="meta prompt_">  #</span><span class="language-bash">70 = Utf8               ()Ljava/lang/String;</span><span class="meta prompt_">  #</span><span class="language-bash">71 = Utf8               java/io/PrintStream</span><span class="meta prompt_">  #</span><span class="language-bash">72 = Utf8               println</span><span class="meta prompt_">  #</span><span class="language-bash">73 = Utf8               (Ljava/lang/String;)V</span></code></pre><h3 id="2-4-字段表集合的信息"><a href="#2-4-字段表集合的信息" class="headerlink" title="2.4 字段表集合的信息"></a>2.4 字段表集合的信息</h3><pre><code class="highlight shell">&#123;  private int num; // 字段名    descriptor: I // 字段表集合的信息    flags: ACC_PRIVATE // 字段的访问标识  boolean flag;    descriptor: Z    flags:  protected char gender;    descriptor: C    flags: ACC_PROTECTED  public java.lang.String info;    descriptor: Ljava/lang/String;    flags: ACC_PUBLIC  public static final int COUNTS;    descriptor: I    flags: ACC_PUBLIC, ACC_STATIC, ACC_FINAL    ConstantValue: int 1 // 常量字段的属性：ConstantValue</code></pre><h3 id="2-5-方法表集合的信息"><a href="#2-5-方法表集合的信息" class="headerlink" title="2.5 方法表集合的信息"></a>2.5 方法表集合的信息</h3><pre><code class="highlight shell">  public com.atguigu.java1.JavapTest(); // 无参构造器方法信息    descriptor: ()V    flags: ACC_PUBLIC    Code:      stack=2, locals=1, args_size=1         0: aload_0         1: invokespecial #1                  // Method java/lang/Object.&quot;&lt;init&gt;&quot;:()V         4: aload_0         5: ldc           #2                  // String java         7: putfield      #3                  // Field info:Ljava/lang/String;        10: return      LineNumberTable:        line 20: 0        line 18: 4        line 22: 10      LocalVariableTable:        Start  Length  Slot  Name   Signature            0      11     0  this   Lcom/atguigu/java1/JavapTest;private com.atguigu.java1.JavapTest(boolean); // 单个参数构造器方法信息    descriptor: (Z)V    flags: ACC_PRIVATE    Code:      stack=2, locals=2, args_size=2         0: aload_0         1: invokespecial #1                  // Method java/lang/Object.&quot;&lt;init&gt;&quot;:()V         4: aload_0         5: ldc           #2                  // String java         7: putfield      #3                  // Field info:Ljava/lang/String;        10: aload_0        11: iload_1        12: putfield      #4                  // Field flag:Z        15: return      LineNumberTable:        line 23: 0        line 18: 4        line 24: 10        line 25: 15      LocalVariableTable:        Start  Length  Slot  Name   Signature            0      16     0  this   Lcom/atguigu/java1/JavapTest;            0      16     1  flag   Z  private void methodPrivate();    descriptor: ()V    flags: ACC_PRIVATE    Code:      stack=0, locals=1, args_size=1         0: return      LineNumberTable:        line 28: 0      LocalVariableTable:        Start  Length  Slot  Name   Signature            0       1     0  this   Lcom/atguigu/java1/JavapTest;  int getNum(int);    descriptor: (I)I    flags:    Code:      stack=2, locals=2, args_size=2         0: aload_0         1: getfield      #5                  // Field num:I         4: iload_1         5: iadd         6: ireturn      LineNumberTable:        line 30: 0      LocalVariableTable:        Start  Length  Slot  Name   Signature            0       7     0  this   Lcom/atguigu/java1/JavapTest;            0       7     1     i   I  protected char showGender();    descriptor: ()C    flags: ACC_PROTECTED    Code:      stack=1, locals=1, args_size=1         0: aload_0         1: getfield      #6                  // Field gender:C         4: ireturn      LineNumberTable:        line 33: 0      LocalVariableTable:        Start  Length  Slot  Name   Signature            0       5     0  this   Lcom/atguigu/java1/JavapTest;  public void showInfo();    descriptor: ()V  // 方法的描述符：方法的形参列表、返回值类型    flags: ACC_PUBLIC // 方法的访问标识    Code: // 方法的Code属性      stack=3, locals=2, args_size=1  // stack：操作数栈的最大深度   locals：局部变量表的长度   args_size：方法接受参数的个数      // 偏移量  操作码   操作数         0: bipush        10         2: istore_1         3: getstatic     #7                  // Field java/lang/System.out:Ljava/io/PrintStream;         6: new           #8                  // class java/lang/StringBuilder         9: dup        10: invokespecial #9                  // Method java/lang/StringBuilder.&quot;&lt;init&gt;&quot;:()V        13: aload_0        14: getfield      #3                  // Field info:Ljava/lang/String;        17: invokevirtual #10                 // Method java/lang/StringBuilder.append:(Ljava/lang/String;)Ljava/lang/StringBuilder;        20: iload_1        21: invokevirtual #11                 // Method java/lang/StringBuilder.append:(I)Ljava/lang/StringBuilder;        24: invokevirtual #12                 // Method java/lang/StringBuilder.toString:()Ljava/lang/String;        27: invokevirtual #13                 // Method java/io/PrintStream.println:(Ljava/lang/String;)V        30: return              // 行号表：指明字节码指令的偏移量与java源代码中代码的行号的一一对应关系      LineNumberTable:        line 36: 0        line 37: 3        line 38: 30              // 局部变量表：描述内部局部变量的相关信息      LocalVariableTable:        Start  Length  Slot  Name   Signature            0      31     0  this   Lcom/atguigu/java1/JavapTest;            3      28     1     i   I  static &#123;&#125;;    descriptor: ()V    flags: ACC_STATIC    Code:      stack=1, locals=1, args_size=0         0: ldc           #14                 // String www.atguigu.com         2: astore_0         3: return      LineNumberTable:        line 15: 0        line 16: 3      LocalVariableTable:        Start  Length  Slot  Name   Signature&#125; // 附加属性：指明当前字节码文件对应的源程序文件名SourceFile: &quot;JavapTest.java&quot;</code></pre><h3 id="2-6-jclasslib展示的内容："><a href="#2-6-jclasslib展示的内容：" class="headerlink" title="2.6 jclasslib展示的内容："></a>2.6 jclasslib展示的内容：</h3><p><img src="https://raw.githubusercontent.com/GeorgeChan95/blogimg/master/img/2024/07/22/20240722-100533.png" alt="jclasslib"></p><h1 id="五、总结"><a href="#五、总结" class="headerlink" title="五、总结"></a>五、总结</h1><ul><li><p>通过 javap 命令可以査看一个java类反汇编得到的class文件版本号、常量池、访问标识、变量表、指令代码行号表等等信息。不显示类索引、父类索引、接口索引集合、<clinit>()、<init>()等结构</p></li><li><p>通过对前面例子代码反汇编文件的简单分析，可以发现，一个方法的执行通常会涉及下面几块内存的操作:</p><ul><li>java栈中:局部变量表、操作数栈。</li><li>java堆。通过对象的地址引用去操作。</li><li>常量池。</li><li>其他如帧数据区、方法区的剩余部分等情况，测试中没有显示出来，这里说明一下。</li></ul></li><li><p>平常，我们比较关注的是java类中每个方法的反汇编中的指令操作过程，这些指令都是顺序执行的，可以参考官方文档查看每个指令的含义，很简单: <a href="https://docs.oracle.com/javase/specs/jvms/se7/html/jvms-6.html">https://docs.oracle.com/javase/specs/jvms/se7/html/jvms-6.html</a></p></li></ul>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;一、解析字节码的作用&quot;&gt;&lt;a href=&quot;#一、解析字节码的作用&quot; class=&quot;headerlink&quot; title=&quot;一、解析字节码的作用&quot;&gt;&lt;/a&gt;一、解析字节码的作用&lt;/h1&gt;&lt;p&gt;通过反编译生成的字节码文件，我们可以深入的了解java代码的工作机制。但是，</summary>
      
    
    
    
    <category term="JVM" scheme="https://georgechan95.github.io/categories/JVM/"/>
    
    
    <category term="java" scheme="https://georgechan95.github.io/tags/java/"/>
    
    <category term="jvm" scheme="https://georgechan95.github.io/tags/jvm/"/>
    
  </entry>
  
  <entry>
    <title>第十六章-Class文件结构</title>
    <link href="https://georgechan95.github.io/blog/143162370.html"/>
    <id>https://georgechan95.github.io/blog/143162370.html</id>
    <published>2024-07-15T11:54:50.000Z</published>
    <updated>2024-08-28T04:17:33.371Z</updated>
    
    <content type="html"><![CDATA[<h1 id="一、概述"><a href="#一、概述" class="headerlink" title="一、概述"></a>一、概述</h1><h2 id="1-字节码文件的跨平台型"><a href="#1-字节码文件的跨平台型" class="headerlink" title="1. 字节码文件的跨平台型"></a>1. 字节码文件的跨平台型</h2><p><strong>1. Java语言: 跨平台的语言</strong></p><p>当Java源代码成功编译成字节码后，如果想在不同的平台上面运行，则无须再次编译,这个优势不再那么吸引人了。Python、PHP、Per1、Ruby、Lisp等有强大的解释器。跨平台似乎已经快成为一门语言必选的特性。</p><p><strong>2. Java 虚拟机:跨语言的平台</strong></p><p><strong>Java虚拟机不和包括 Java 在内的任何语言绑定，它只与“c1ass 文件”这种特定的二进制文件格式所关联。</strong>无论使用何种语言进行软件开发，只要能将源文件编译为正确的Class文件，那么这种语言就可以在Java虚拟机上执行。可以说，统一而强大的Class文件结构，就是Java虚拟机的基石、桥梁。</p><p><img src="https://raw.githubusercontent.com/GeorgeChan95/blogimg/master/img/2024/07/19/20240719-103403.jpg" alt="JVM的平台无关性"></p><p>JAVA虚拟机规范官方文档: <a href="https://docs.oracle.com/javase/specs/jvms/se8/html/index.html">https://docs.oracle.com/javase/specs/jvms/se8/html/index.html</a></p><p>所有的JVM全部遵守Java虚拟机规范，也就是说所有的JVM环境都是一样的，这样一来字节码文件可以在各种JVM上运行。</p><p><strong>3. 想要让一个]ava程序正确地运行在JVM中，Java源码就必须要被编译为符合JVM规范的字节码。</strong></p><ul><li>前端编译器的主要任务就是负责将符合]ava语法规范的]ava代码转换为符合JVM规范的字节码文件。</li><li>javac是一种能够将Java源码编译为字节码的前端编译器。</li><li>Javac编译器在将]ava源码编译为一个有效的字节码文件过程中经历了4个步骤，分别是 <strong>词法解析、语法解析、语义解析以及生成字节码</strong>。</li></ul><p><img src="https://raw.githubusercontent.com/GeorgeChan95/blogimg/master/img/2024/07/19/20240719-103432.jpg" alt="JVM结构"></p><p><strong>Oracle的JDK软件包括两部分内容:</strong></p><ul><li><p>一部分是将Java源代码编译成Java虚拟机的指令集的编译器</p></li><li><p>另一部分是用于实现Java虚拟机的运行时环境。</p></li></ul><h2 id="2-Java的前端编译器"><a href="#2-Java的前端编译器" class="headerlink" title="2. Java的前端编译器"></a>2. Java的前端编译器</h2><p><img src="https://raw.githubusercontent.com/GeorgeChan95/blogimg/master/img/2024/07/19/20240719-103807.jpg" alt="理解执行引擎"></p><p><strong>前端编译器 vs 后端编译器</strong></p><p>Java源代码的编译结果是字节码，那么肯定需要有一种编译器能够将]ava源码编译为字节码，承担这个重要责任的就是配置在path环境变量中的javac编译器。iavac是一种能够将]ava源码编译为字节码的前端编译器。</p><p>Hotspot VM并没有强制要求前端编译器只能使用javac来编译字节码，其实只要编译结果符合JVM规范都可以被JVM所识别即可。在]ava的前端编译器领域，除了javac之外，还有一种被大家经常用到的前端编译器，那就是内置在Eclipse中的ECJ(Eclipse Compiler for Java)编译器。和Javac的全量式编译不同，ECj是一种增量式编译器。</p><ul><li>在Eclipse中，当开发人员编写完代码后，使用“ctrl+S”快捷键时，ECj编译器所采取的编译方案是把未编译部分的源码逐行进行编译，而非每次都全量编译。因此ECJ的编译效率会比Javac更加迅速和高效，当然编译质量和javac相比大致还是一样的。</li><li>ECJ不仅是Eclipse的默认内置前端编译器，在Tomcat中同样也是使用ECJ编译器来编译jsp文件。由于ECJ编译器是采用GPLv2的开源协议进行源代码公开，所以，大家可以登录eclipse官网下载ECJ编译器的源码进行二次开发。默认情况下，IntelliJ IDEA 使用 javac 编译器。(还可以自己设置为AspectJ编译器 ajc)</li></ul><p>前端编译器并不会直接涉及编译优化等方面的技术，而是将这些具体优化细节移交给HotSpot的JIT编译器负责。</p><p>顺便提一句: <strong>AOT(静态提前编译器，Ahead Of Time Compiler)</strong></p><h1 id="二、虚拟机的基石-Class文件"><a href="#二、虚拟机的基石-Class文件" class="headerlink" title="二、虚拟机的基石: Class文件"></a>二、虚拟机的基石: Class文件</h1><ul><li><p>字节码文件里是什么?</p><p>源代码经过编译器编译之后便会生成一个字节码文件，字节码是一种二进制的类文件，它的内容是JVM的指令，而不像C、C++经由编译器直接生成机器码。</p></li><li><p>什么是字节码指令(byte code)?</p><p>Java虚拟机的指令由一个字节长度的、代表着某种特定操作含义的操作码(opcode)以及跟随其后的零至多个代表此操作所需参数的操作数(operand)所构成。虚拟机中许多指令并不包含操作数，只有一个操作码。</p><p><img src="https://raw.githubusercontent.com/GeorgeChan95/blogimg/master/img/2024/07/19/20240719-111004.png" alt="字节码指令"></p></li></ul><p><strong>如何解读供虚拟机解释执行的二进制字节码?</strong></p><ul><li><p>方式一: 一个一个二进制的看。这里用到的是Notepad++,需要安装一个HEX-Editor插件，或者使用Binary Viewer</p><img src="https://raw.githubusercontent.com/GeorgeChan95/blogimg/master/img/2024/07/19/20240719-112211.png" alt="使用HEX-Editor插件插件.class文件" style="zoom: 67%;" /><p>插件离线下载地址: <a href="https://github.com/chcg/NPP_HexEdit/releases">https://github.com/chcg/NPP_HexEdit/releases</a></p></li><li><p>方式二:使用javap指令:jdk自带的反解析工具</p><pre><code class="highlight shell">javap -v xxx.class</code></pre><p><img src="https://raw.githubusercontent.com/GeorgeChan95/blogimg/master/img/2024/07/19/20240719-112549.png" alt="javap指令"></p></li><li><p>方式三:【使用IDEA插件:jclasslib 或jclasslib bytecode viewer客户端工具。(可视化更好)</p><p><img src="https://raw.githubusercontent.com/GeorgeChan95/blogimg/master/img/2024/07/19/20240719-112658.png" alt="IDEA插件:jclasslib"></p></li></ul><h1 id="三、Class字节码文件结构"><a href="#三、Class字节码文件结构" class="headerlink" title="三、Class字节码文件结构"></a>三、Class字节码文件结构</h1><h2 id="0-字节码文件概览"><a href="#0-字节码文件概览" class="headerlink" title="0. 字节码文件概览"></a>0. 字节码文件概览</h2><p><strong>1. 文件结构</strong></p><table><thead><tr><th></th><th>类型</th><th>名称</th><th>说明</th><th>长度</th><th>数量</th></tr></thead><tbody><tr><td>魔数</td><td>u4</td><td>magic</td><td>魔数,识别Class文件格式</td><td>4个字节</td><td>1</td></tr><tr><td>版本号</td><td>u2</td><td>minor_version</td><td>副版本号(小版本)</td><td>2个字节</td><td>1</td></tr><tr><td></td><td>u2</td><td>major_version</td><td>主版本号(大版本)</td><td>2个字节</td><td>1</td></tr><tr><td>常量池集合</td><td>u2</td><td>constant_pool_count</td><td>常量池计数器</td><td>2个字节</td><td>1</td></tr><tr><td></td><td>cp_info</td><td>constant_pool</td><td>常量池表</td><td>n个字节</td><td>constant_pool_count - 1</td></tr><tr><td>访问标识</td><td>u2</td><td>access_flags</td><td>访问标识</td><td>2个字节</td><td>1</td></tr><tr><td>索引集合</td><td>u2</td><td>this_class</td><td>类索引</td><td>2个字节</td><td>1</td></tr><tr><td></td><td>u2</td><td>super_class</td><td>父类索引</td><td>2个字节</td><td>1</td></tr><tr><td></td><td>u2</td><td>interfaces_count</td><td>接口计数器</td><td>2个字节</td><td>1</td></tr><tr><td></td><td>u2</td><td>interfaces</td><td>接口索引集合</td><td>2个字节</td><td>interfaces_count</td></tr><tr><td>字段表集合</td><td>u2</td><td>fields_count</td><td>字段计数器</td><td>2个字节</td><td>1</td></tr><tr><td></td><td>field_info</td><td>fields</td><td>字段表</td><td>n个字节</td><td>fields_count</td></tr><tr><td>方法表集合</td><td>u2</td><td>methods_count</td><td>方法计数器</td><td>2个字节</td><td>1</td></tr><tr><td></td><td>method_info</td><td>methods</td><td>方法表</td><td>n个字节</td><td>methods_count</td></tr><tr><td>属性表集合</td><td>u2</td><td>attributes_count</td><td>属性计数器</td><td>2个字节</td><td>1</td></tr><tr><td></td><td>attribute_info</td><td>attributes</td><td>属性表</td><td>n个字节</td><td>attributes_count</td></tr></tbody></table><p><strong>2. 示例代码</strong></p><pre><code class="highlight plaintext">public class Demo &#123;    private int num = 1;    public int add()&#123;        num = num + 2;        return num;    &#125;&#125;</code></pre><p><strong>3. 字节码</strong></p><pre><code class="highlight txt">cafebabe0000003400160a0004001209000300130700140700150100036e756d 010001490100063c696e69743e010003282956010004436f646501000f4c696e 654e756d6265725461626c650100124c 6f63616c5661726961626c655461626c 65010004746869730100184c636f6d2f 617467756967752f6a617661312f44656d6f3b01000361646401000328294901000a536f7572636546696c6501000944656d6f2e6a6176610c000700080c00050006010016636f6d2f617467756967752f6a617661312f44656d6f0100106a6176612f6c616e672f4f626a65637400210003000400000001000200050006000000020001000700080001000900000038000200010000000a2ab700012a04b50002b100000002000a0000000a00020000000700040008000b0000000c00010000000a000c000d00000001000e000f000100090000003d000300010000000f2a2a b400020560b500022ab40002ac00000002000a0000000a00020000000b000a000c000b0000000c00010000000f000c000d000000010010000000020011</code></pre><p><strong>4. 字节码解析</strong></p><p><img src="https://raw.githubusercontent.com/GeorgeChan95/blogimg/master/img/2024/07/20/20240720-175022.png" alt="demo.java字节码解析"></p><p>二、Class文件数据类型</p><table><thead><tr><th>数据类型</th><th>定义</th><th>说明</th></tr></thead><tbody><tr><td>无符号数</td><td>无符号数可以用来描述数字、索引引用、数量值或按照utf-8编码构成的字符串值。</td><td>其中无符号数属于基本的数据类型。 以u1、u2、u4、u8来分别代表1个字节、2个字节、4个字节和8个字节</td></tr><tr><td>表</td><td>表是由多个无符号数或其他表构成的复合数据结构。</td><td>所有的表都以“_info”结尾。 由于表没有固定长度，所以通常会在其前面加上个数说明。</td></tr></tbody></table><h2 id="1-魔数"><a href="#1-魔数" class="headerlink" title="1. 魔数"></a>1. 魔数</h2><p><strong>Magic Number（魔数）</strong></p><ul><li><p>每个Class文件开头的4个字节的无符号整数称为魔数（Magic Number）</p></li><li><p>它的唯一作用是确定这个文件是否为一个能被虚拟机接受的有效合法的Class文件。即：魔数是Class文件的标识符。</p></li><li><p>魔数值固定为0xCAFEBABE。不会改变。</p></li><li><p>如果一个Class文件不以0xCAFEBABE开头，虚拟机在进行文件校验的时候就会直接抛出以下错误：</p><pre><code class="highlight java">Error: A JNI error has occurred, please check your installation and <span class="keyword">try</span> againException in thread <span class="string">&quot;main&quot;</span> java.lang.ClassFormatError: Incompatible magic value <span class="number">1885430635</span> in <span class="keyword">class</span> <span class="title class_">file</span> StringTest</code></pre></li></ul><h2 id="2-文件版本号"><a href="#2-文件版本号" class="headerlink" title="2. 文件版本号"></a>2. 文件版本号</h2><p>紧接着魔数的4个字节存储的是Class文件的版本号。同样也是4个字节。第5个和第6个字节所代表的含义就是编译的副版本号minor_version，而第7个和第8个字节就是编译的主版本号major_version。</p><p>它们共同构成了class文件的格式版本号。譬如某个Class文件的主版本号为M，副版本号为m，那么这个Class文件的格式版本号就确定为M.m。</p><h3 id="2-1-Class文件版本号对应关系"><a href="#2-1-Class文件版本号对应关系" class="headerlink" title="2.1 Class文件版本号对应关系"></a>2.1 Class文件版本号对应关系</h3><table><thead><tr><th>主版本（十进制）</th><th>副版本（十进制）</th><th>编译器版本</th></tr></thead><tbody><tr><td>45</td><td>3</td><td>1.1</td></tr><tr><td>46</td><td>0</td><td>1.2</td></tr><tr><td>47</td><td>0</td><td>1.3</td></tr><tr><td>48</td><td>0</td><td>1.4</td></tr><tr><td>49</td><td>0</td><td>1.5</td></tr><tr><td>50</td><td>0</td><td>1.6</td></tr><tr><td>51</td><td>0</td><td>1.7</td></tr><tr><td>52</td><td>0</td><td>1.8</td></tr><tr><td>53</td><td>0</td><td>1.9</td></tr><tr><td>54</td><td>0</td><td>1.10</td></tr><tr><td>55</td><td>0</td><td>1.11</td></tr></tbody></table><p>Java的版本号是从45开始的，JDK1.1之后的每个JDK大版本发布主版本号向上加1。</p><p>不同版本的Java编译器编译的Class文件对应的版本是不一样的。目前，高版本的Java虚拟机可以执行由低版本编译器生成的Class文件，但是低版本的Java虚拟机不能执行由高版本编译器生成的Class文件。否则JVM会抛出java.lang.UnsupportedClassVersionError异常。（向下兼容）</p><p>在实际应用中，由于开发环境和生产环境的不同，可能会导致该问题的发生。因此，需要我们在开发时，特别注意开发编译的JDK版本和生产环境中的JDK版本是否一致。</p><ul><li>虚拟机JDK版本为1.k（k&gt;&#x3D;2）时，对应的class文件格式版本号的范围为45.0 - 44+k.0（含两端）。</li></ul><h2 id="3-常量池集合"><a href="#3-常量池集合" class="headerlink" title="3. 常量池集合"></a>3. 常量池集合</h2><p>常量池是Class文件中内容最为丰富的区域之一。常量池对于Class文件中的字段和方法解析也有着至关重要的作用。</p><p>随着Java虚拟机的不断发展，常量池的内容也日渐丰富。可以说，常量池是整个Class文件的基石。</p><p><img src="https://raw.githubusercontent.com/GeorgeChan95/blogimg/master/img/2024/07/18/20240718-192319.png" alt="常量池"></p><p>在版本号之后，紧跟着的是常量池的数量，以及若干个常量池表项。</p><p>常量池中常量的数量是不固定的，所以在常量池的入口需要放置一项u2类型的无符号数，代表常量池容量计数值（constant_pool_count）。与Java中语言习惯不一样的是，这个容量计数是从1而不是0开始的。</p><table><thead><tr><th>类型</th><th>名称</th><th>数量</th></tr></thead><tbody><tr><td>u2（无符号数）</td><td>constant_pool_count</td><td>1</td></tr><tr><td>cp_info（表）</td><td>constant_pool</td><td>constant_pool_count - 1</td></tr></tbody></table><p>由上表可见，Class文件使用了一个前置的容量计数器（constant_pool_count）加若干个连续的数据项（constant_pool）的形式来描述常量池内容。我们把这一系列连续常量池数据称为常量池集合。</p><ul><li>常量池表项中，用于存放编译时期生成的各种字面量和符号引用，这部分内容将在类加载后进入方法区的运行时常量池中存放</li></ul><p><img src="https://raw.githubusercontent.com/GeorgeChan95/blogimg/master/img/2024/07/18/20240718-194527.png" alt="jclasslib"></p><h3 id="3-1-常量池计数器"><a href="#3-1-常量池计数器" class="headerlink" title="3.1 常量池计数器"></a>3.1 常量池计数器</h3><p><strong>constant_pool_count（常量池计数器）</strong></p><ul><li><p>由于常量池的数量不固定，时长时短，所以需要放置两个字节来表示常量池容量计数值。</p></li><li><p>常量池容量计数值（u2类型）：从1开始，表示常量池中有多少项常量。即constant_pool_count&#x3D;1表示常量池中有0个常量项。</p></li><li><p>Demo的值为：</p><p><img src="https://raw.githubusercontent.com/GeorgeChan95/blogimg/master/img/2024/07/18/20240718-200507.png" alt="常量池计数器"></p></li></ul><p>其值为0x0016，转换成10进制就是22。需要注意的是，这实际上只有21项常量。索引为范围是1-21。为什么呢？</p><p>通常我们写代码时都是从0开始的，但是这里的常量池却是从1开始，因为它把第0项常量空出来了。这是为了满足后面某些指向常量池的索引值的数据在特定情况下需要表达“不引用任何一个常量池项目”的含义，这种情况可用索引值0来表示。</p><h3 id="3-2-常量池表"><a href="#3-2-常量池表" class="headerlink" title="3.2 常量池表"></a>3.2 常量池表</h3><p>constant_pool是一种表结构，以1 ~ constant_pool_count - 1为索引。表明了后面有多少个常量项。</p><p><strong>常量池主要存放两大类常量：字面量（Literal）和符号引用（Symbolic References）</strong></p><p>它包含了class文件结构及其子结构中引用的所有字符串常量、类或接口名、字段名和其他常量。常量池中的每一项都具备相同的特征。第1个字节作为类型标记，用于确定该项的格式，这个字节称为tag byte（标记字节、标签字节）。</p><p><strong>常量类型与结构表</strong></p><table><thead><tr><th>类型</th><th>标志(或标识)</th><th>描述</th></tr></thead><tbody><tr><td>CONSTANT_Utf8_info</td><td>1</td><td>UTF-8编码的字符串</td></tr><tr><td>CONSTANT_Integer_info</td><td>3</td><td>整型字面量</td></tr><tr><td>CONSTANT_Float_info</td><td>4</td><td>浮点型字面量</td></tr><tr><td>CONSTANT_Long_info</td><td>5</td><td>长整型字面量</td></tr><tr><td>CONSTANT_Double_info</td><td>6</td><td>双精度浮点型字面量</td></tr><tr><td>CONSTANT_Class_info</td><td>7</td><td>类或接口的符号引用</td></tr><tr><td>CONSTANT_String_info</td><td>8</td><td>字符串类型字面量</td></tr><tr><td>CONSTANT_Fieldref_info</td><td>9</td><td>字段的符号引用</td></tr><tr><td>CONSTANT_Methodref_info</td><td>10</td><td>类中方法的符号引用</td></tr><tr><td>CONSTANT_InterfaceMethodref_info</td><td>11</td><td>接口中方法的符号引用</td></tr><tr><td>CONSTANT_NameAndType_info</td><td>12</td><td>字段或方法的符号引用</td></tr><tr><td>CONSTANT_MethodHandle_info</td><td>15</td><td>表示方法句柄</td></tr><tr><td>CONSTANT_MethodType_info</td><td>16</td><td>标志方法类型</td></tr><tr><td>CONSTANT_InvokeDynamic_info</td><td>18</td><td>表示一个动态方法调用点</td></tr></tbody></table><p><strong>常量类型与结构细节</strong></p><table><thead><tr><th>标志</th><th>常量</th><th>描述</th><th>细节</th><th>长度</th><th>细节描述</th></tr></thead><tbody><tr><td>1</td><td>CONSTANT_utf8_info</td><td>UTF-8编码的字符串</td><td>tag</td><td>u1</td><td>值为1</td></tr><tr><td></td><td></td><td></td><td>length</td><td>u2</td><td>UTF-8编码的字符串占用的字符数</td></tr><tr><td></td><td></td><td></td><td>bytes</td><td>u1</td><td>长度为length的UTF-8编码的字符串</td></tr><tr><td>3</td><td>CONSTANT_Integer_info</td><td>整型字面量</td><td>tag</td><td>u1</td><td>值为3</td></tr><tr><td></td><td></td><td></td><td>bytes</td><td>u4</td><td>按照高位在前存储的int值</td></tr><tr><td>4</td><td>CONSTANT_Float_info</td><td>浮点型字面量</td><td>tag</td><td>u1</td><td>值为4</td></tr><tr><td></td><td></td><td></td><td>bytes</td><td>u4</td><td>按照高位在前存储的float值</td></tr><tr><td>5</td><td>CONSTANT_Long_info</td><td>长整型字面量</td><td>tag</td><td>u1</td><td>值为5</td></tr><tr><td></td><td></td><td></td><td>bytes</td><td>u8</td><td>按照高位在前存储的long值</td></tr><tr><td>6</td><td>CONSTANT_Double_info</td><td>双精度浮点型字面量</td><td>tag</td><td>u1</td><td>值为6</td></tr><tr><td></td><td></td><td></td><td>bytes</td><td>u8</td><td>按照高位在前存储的double值</td></tr><tr><td>7</td><td>CONSTANT_Class_info</td><td>类或接口的符号引用</td><td>tag</td><td>u1</td><td>值为7</td></tr><tr><td></td><td></td><td></td><td>index</td><td>u2</td><td>指向全限定名常量项的索引</td></tr><tr><td>8</td><td>CONSTANT_String_info</td><td>字符串类型字面量</td><td>tag</td><td>u1</td><td>值为8</td></tr><tr><td></td><td></td><td></td><td>index</td><td>u2</td><td>指向字符串字面量的索引</td></tr><tr><td>9</td><td>CONSTANT_Fieldref_info</td><td>字段的符号引用</td><td>tag</td><td>u1</td><td>值为9</td></tr><tr><td></td><td></td><td></td><td>index</td><td>u2</td><td>指向声明字段的类或接口描述符CONSTANT_Class_info的索引项</td></tr><tr><td></td><td></td><td></td><td>index</td><td>u2</td><td>指向字段描述符CONSTANT_NameAndType的索引项</td></tr><tr><td>10</td><td>CONSTANT_Methodref_info</td><td>类中方法的符号引用</td><td>tag</td><td>u1</td><td>值为10</td></tr><tr><td></td><td></td><td></td><td>index</td><td>u2</td><td>指向声明方法的类描述符CONSTANT_Class_Info的索引项</td></tr><tr><td></td><td></td><td></td><td>index</td><td>u2</td><td>指向名称及类型描述符CONSTANT_NameAndType的索引项</td></tr><tr><td>11</td><td>CONSTANT_InterfaceMethodref_info</td><td>接口中方法的符号引用</td><td>tag</td><td>u1</td><td>值为11</td></tr><tr><td></td><td></td><td></td><td>index</td><td>u2</td><td>指向声明方法的接口描述符CONSTANT_Class_Info的索引项</td></tr><tr><td></td><td></td><td></td><td>index</td><td>u2</td><td>指向名称及类型描述符CONSTANT_NameAndType的索引项</td></tr><tr><td>12</td><td>CONSTANT_NameAndType_info</td><td>字段或方法的符号引用</td><td>tag</td><td>u1</td><td>值为12</td></tr><tr><td></td><td></td><td></td><td>index</td><td>u2</td><td>指向该字段或方法名称常量项的索引</td></tr><tr><td></td><td></td><td></td><td>index</td><td>u2</td><td>指向该字段或方法描述符常量项的索引</td></tr><tr><td>15</td><td>CONSTANT_MethodHandle_info</td><td>表示方法句柄</td><td>tag</td><td>u1</td><td>值为15</td></tr><tr><td></td><td></td><td></td><td>reference_kind</td><td>u1</td><td>值必须在1-9之间，它决定了方法句柄的类型方法句柄类型的值表示方法句柄的字节码行为</td></tr><tr><td></td><td></td><td></td><td>reference_index</td><td>u2</td><td>值必须是对常量池的有效索引</td></tr><tr><td>16</td><td>CONSTANT_MethodType_info</td><td>标志方法类型</td><td>tag</td><td>u1</td><td>值为16</td></tr><tr><td></td><td></td><td></td><td>descriptor_index</td><td>u2</td><td>值必须是对常量池的有效索引，常量池在该索引处的项必须是CONSTANT_Utf8_info结构，表示方法的描述符</td></tr><tr><td>18</td><td>CONSTANT_InvokeDynamic_info</td><td>表示一个动态方法调用点</td><td>tag</td><td>u1</td><td>值为18</td></tr><tr><td></td><td></td><td></td><td>bootstrap_method_attr</td><td>u2</td><td>值必须是对当前Class文件中引导方法表的bootstrap_methods[]数组的有效索引</td></tr><tr><td></td><td></td><td></td><td>name_and_type_index</td><td>u2</td><td>值必须是对当前常量池的有效索引，常量池在该索引处的项必须是CONSTANT_NameAndType_Info结构，表示方法名和方法描述符</td></tr></tbody></table><h4 id="3-2-1-字面量和符号引用"><a href="#3-2-1-字面量和符号引用" class="headerlink" title="3.2.1 字面量和符号引用"></a>3.2.1 字面量和符号引用</h4><p>在对这些常量解读前，我们需要搞清楚几个概念。</p><p>常量池主要存放两大类常量：<strong>字面量（Literal）和符号引用（Symbolic References）</strong>。如下表：</p><table><thead><tr><th>常量</th><th>具体的常量</th></tr></thead><tbody><tr><td>字面量</td><td>文本字符串</td></tr><tr><td></td><td>声明为final的常量值</td></tr><tr><td>符号引用</td><td>类和接口的全限定名</td></tr><tr><td></td><td>字段的名称和描述符</td></tr><tr><td></td><td>方法的名称和描述符</td></tr></tbody></table><p><strong>全限定名</strong></p><p>com&#x2F;atguigu&#x2F;test&#x2F;Demo这个就是类的全限定名，仅仅是把包名的“.“替换成”&#x2F;”，为了使连续的多个全限定名之间不产生混淆，在使用时最后一般会加入一个“;”表示全限定名结束。</p><p><strong>简单名称</strong></p><p>简单名称是指<strong>没有类型和参数修饰的方法或者字段名称</strong>，上面例子中的类的add()方法和num字段的简单名称分别是add和num。</p><p><strong>描述符</strong></p><p>描述符的作用是用来描述字段的数据类型、方法的参数列表（包括数量、类型以及顺序）和返回值。根据描述符规则，基本数据类型（byte、char、double、float、int、long、short、boolean）以及代表无返回值的void类型都用一个大写字符来表示，而对象类型则用字符L加对象的全限定名来表示，详见下表：</p><table><thead><tr><th>标志符</th><th>含义</th></tr></thead><tbody><tr><td>B</td><td>基本数据类型byte</td></tr><tr><td>C</td><td>基本数据类型char</td></tr><tr><td>D</td><td>基本数据类型double</td></tr><tr><td>F</td><td>基本数据类型float</td></tr><tr><td>I</td><td>基本数据类型int</td></tr><tr><td>J</td><td>基本数据类型long</td></tr><tr><td>S</td><td>基本数据类型short</td></tr><tr><td>Z</td><td>基本数据类型boolean</td></tr><tr><td>V</td><td>代表void类型</td></tr><tr><td>L</td><td>对象类型，比如：<code>Ljava/lang/Object;</code></td></tr><tr><td>[</td><td>数组类型，代表一维数组。比如：&#96;double[] is [D</td></tr></tbody></table><p>用描述符来描述方法时，按照先参数列表，后返回值的顺序描述，参数列表按照参数的严格顺序放在一组小括号“()”之内。如方法 java.lang.String tostring() 的描述符为 <code>()Ljava/lang/String</code> ，方法 <code>int abc(int[]x, int y)</code> 的描述符为 <code>([II)I</code></p><p><strong>补充说明：</strong></p><p>虚拟机在加载Class文件时才会进行动态链接，也就是说，Class文件中不会保存各个方法和字段的最终内存布局信息。因此，这些字段和方法的符号引用不经过转换是无法直接被虚拟机使用的。当虚拟机运行时，需要从常量池中获得对应的符号引用，再在类加载过程中的解析阶段将其替换为直接引用，并翻译到具体的内存地址中。</p><p>这里说明下符号引用和直接引用的区别与关联：</p><ul><li><p>符号引用：符号引用以一组符号来描述所引用的目标，符号可以是任何形式的字面量，只要使用时能无歧义地定位到目标即可。符号引用与虚拟机实现的内存布局无关，引用的目标并不一定已经加载到了内存中。</p></li><li><p>直接引用：直接引用可以是直接指向目标的指针、相对偏移量或是一个能间接定位到目标的句柄。直接引用是与虚拟机实现的内存布局相关的，同一个符号引用在不同虚拟机实例上翻译出来的直接引用一般不会相同。如果有了直接引用，那说明引用的目标必定已经存在于内存之中了。</p></li></ul><h4 id="3-2-2-常量类型和结构"><a href="#3-2-2-常量类型和结构" class="headerlink" title="3.2.2 常量类型和结构"></a>3.2.2 常量类型和结构</h4><p>常量池中每一项常量都是一个表，J0K1.7之后共有14种不同的表结构数据。如下表格所示：</p><p><img src="https://raw.githubusercontent.com/GeorgeChan95/blogimg/master/img/2024/07/18/20240718-205459.png" alt="常量类型和结构"></p><p>根据上图每个类型的描述我们也可以知道每个类型是用来描述常量池中哪些内容（主要是字面量、符号引用）的。比如 :</p><p>CONSTANT_Integer_info是用来描述常量池中字面量信息的，而且只是整型字面量信息。</p><p>标志为15、16、18的常量项类型是用来支持动态语言调用的（jdk1.7时才加入的）。</p><p><strong>细节说明</strong></p><ul><li><p>CONSTANT_Class_info 结构用于表示类或接口</p></li><li><p>CONSTAT_Fieldref_info、CONSTAHT_Methodref_info 和 CONSTANIT_InterfaceMethodref_info 结构表示字段、方法和接口方法</p></li><li><p>CONSTANT_String_info 结构用于表示String类型的常量对象</p></li><li><p>CONSTANT_Integer_info 和 CONSTANT_Float_info 表示4字节（int和float）的数值常量</p></li><li><p>CONSTANT_Long_info 和 CONSTANT_Double_info 结构表示8字节（long和double）的数值常量 </p></li><li><ul><li>在class文件的常量池表中，所有的8字节常量均占两个表成员（项）的空间。如果一个CONSTANT_Long_info 和 CONSTANT_Double_info 结构在常量池中的索引位n，则常量池中一个可用的索引位n+2，此时常量池长中索引为n+1的项仍然有效但必须视为不可用的。</li></ul></li><li><p>CONSTANT_NameAndType_info 结构用于表示字段或方法，但是和之前的3个结构不同，CONSTANT_NameAndType_info 结构没有指明该字段或方法所属的类或接口。</p></li><li><p>CONSTANT_Utf8_info 用于表示字符常量的值</p></li><li><p>CONSTANT_MethodHandle_info 结构用于表示方法句柄</p></li><li><p>CONSTANT_MethodType_info 结构表示方法类型</p></li><li><p>CONSTANT_InvokeDynamic_info结构表示invokedynamic指令所用到的引导方法(bootstrap method)、引导方法所用到的动态调用名称(dynamic invocation name)、参数和返回类型，并可以给引导方法传入一系列称为静态参数（static argument）的常量。</p></li></ul><h2 id="4-访问标志"><a href="#4-访问标志" class="headerlink" title="4. 访问标志"></a>4. 访问标志</h2><p><strong>访问标识（access_flag、访问标志、访问标记）</strong></p><p>在常量池后，紧跟着访问标记。该标记使用两个字节表示，用于识别一些类或者接口层次的访问信息，包括：这个Class是类还是接口；是否定义为public类型；是否定义为abstract类型；如果是类的话，是否被声明为final等。各种访问标记如下所示：</p><table><thead><tr><th>标志名称</th><th>标志值</th><th>含义</th></tr></thead><tbody><tr><td>ACC_PUBLIC</td><td>0x0001</td><td>标志为public类型</td></tr><tr><td>ACC_FINAL</td><td>0x0010</td><td>标志被声明为final，只有类可以设置</td></tr><tr><td>ACC_SUPER</td><td>0x0020</td><td>标志允许使用invokespecial字节码指令的新语义，JDK1.0.2之后编译出来的类的这个标志默认为真。（使用增强的方法调用父类方法）</td></tr><tr><td>ACC_INTERFACE</td><td>0x0200</td><td>标志这是一个接口</td></tr><tr><td>ACC_ABSTRACT</td><td>0x0400</td><td>是否为abstract类型，对于接口或者抽象类来说，此标志值为真，其他类型为假</td></tr><tr><td>ACC_SYNTHETIC</td><td>0x1000</td><td>标志此类并非由用户代码产生（即：由编译器产生的类，没有源码对应）</td></tr><tr><td>ACC_ANNOTATION</td><td>0x2000</td><td>标志这是一个注解</td></tr><tr><td>ACC_ENUM</td><td>0x4000</td><td>标志这是一个枚举</td></tr></tbody></table><ul><li>类的访问权限通常为ACC_开头的常量。</li><li>每一种类型的表示都是通过设置访问标记的32位中的特定位来实现的。比如，若是public final的类，则该标记为ACC_PUBLIC | ACC_FINAL</li><li>使用ACC_SUPER可以让类更准确地定位到父类的方法super.method()，现代编译器都会设置并且使用这个标记。</li></ul><p><strong>补充说明：</strong></p><ul><li><p>带有ACC_INTERFACE标志的class文件表示的是接口而不是类，反之则表示的是类而不是接口。 </p></li><li><ul><li>如果一个class文件被设置了ACC_INTERFACE标志，那么同时也得设置ACC_ABSTRACT标志。同时它不能再设置ACC_FINAL、ACC_SUPER 或ACC_ENUM标志。</li></ul></li><li><ul><li>如果没有设置ACC_INTERFACE标志，那么这个class文件可以具有上表中除ACC_ANNOTATION外的其他所有标志。当然，ACC_FINAL和ACC_ABSTRACT这类互斥的标志除外。这两个标志不得同时设置。</li></ul></li><li><p>ACC_SUPER标志用于确定类或接口里面的invokespecial指令使用的是哪一种执行语义。针对Java虚拟机指令集的编译器都应当设置这个标志。对于Java SE 8及后续版本来说，无论class文件中这个标志的实际值是什么，也不管class文件的版本号是多少，Java虚拟机都认为每个class文件均设置了ACC_SUPER标志。 </p></li><li><ul><li>ACC_SUPER标志是为了向后兼容由旧Java编译器所编译的代码而设计的。目前的ACC_SUPER标志在由JDK1.0.2之前的编译器所生成的access_flags中是没有确定含义的，如果设置了该标志，那么oracle的Java虚拟机实现会将其忽略。</li></ul></li><li><p>ACC_SYNTHETIC标志意味着该类或接口是由编译器生成的，而不是由源代码生成的。 </p></li><li><p>注解类型必须设置ACC_ANNOTATION标志。如果设置了ACC_ANNOTATION标志，那么也必须设置ACC_INTERFACE标志。 </p></li><li><p>ACC_ENUM标志表明该类或其父类为枚举类型。</p></li></ul><h2 id="5-类索引、父类索引、接口索引"><a href="#5-类索引、父类索引、接口索引" class="headerlink" title="5. 类索引、父类索引、接口索引"></a>5. 类索引、父类索引、接口索引</h2><p>在访问标记后，会指定该类的类别、父类类别以及实现的接口，格式如下：</p><table><thead><tr><th>长度</th><th>含义</th></tr></thead><tbody><tr><td>u2</td><td>this_class</td></tr><tr><td>u2</td><td>super_class</td></tr><tr><td>u2</td><td>interfaces_count</td></tr><tr><td>u2</td><td>interfaces[interfaces_count]</td></tr></tbody></table><p>这三项数据来确定这个类的继承关系：</p><ul><li><p>类索引用于确定这个类的全限定名</p></li><li><p>父类索引用于确定这个类的父类的全限定名。由于Java语言不允许多重继承，所以父类索引只有一个，除了java.lang.Object之外，所有的Java类都有父类，因此除了java.lang.Object外，所有Java类的父类索引都不为0。</p></li><li><p>接口索引集合就用来描述这个类实现了哪些接口，这些被实现的接口将按implements语句（如果这个类本身是一个接口，则应当是extends语句）后的接口顺序从左到右排列在接口索引集合中。</p></li></ul><h3 id="5-1-this-class（类索引）"><a href="#5-1-this-class（类索引）" class="headerlink" title="5.1. this_class（类索引）"></a>5.1. this_class（类索引）</h3><p>2字节无符号整数，指向常量池的索引。它提供了类的全限定名，如com&#x2F;atguigu&#x2F;java1&#x2F;Demo。this_class的值必须是对常量池表中某项的一个有效索引值。常量池在这个索引处的成员必须为CONSTANT_Class_info类型结构体，该结构体表示这个class文件所定义的类或接口。</p><h3 id="5-2-super-class（父类索引）"><a href="#5-2-super-class（父类索引）" class="headerlink" title="5.2. super_class（父类索引）"></a>5.2. super_class（父类索引）</h3><p>2字节无符号整数，指向常量池的索引。它提供了当前类的父类的全限定名。如果我们没有继承任何类，其默认继承的是java&#x2F;lang&#x2F;object类。同时，由于Java不支持多继承，所以其父类只有一个。</p><p><strong>super_class指向的父类不能是final。</strong></p><h3 id="5-3-interfaces"><a href="#5-3-interfaces" class="headerlink" title="5.3. interfaces"></a>5.3. interfaces</h3><p>指向常量池索引集合，它提供了一个符号引用到所有已实现的接口</p><p>由于一个类可以实现多个接口，因此需要以数组形式保存多个接口的索引，表示接口的每个索引也是一个指向常量池的CONSTANT_Class（当然这里就必须是接口，而不是类）。</p><h4 id="5-3-1-interfaces-count（接口计数器）"><a href="#5-3-1-interfaces-count（接口计数器）" class="headerlink" title="5.3.1 interfaces_count（接口计数器）"></a>5.3.1 interfaces_count（接口计数器）</h4><p>interfaces_count 项的值表示当前类或接口的直接超接口数量。</p><h4 id="5-3-2-interfaces-（接口索引集合）"><a href="#5-3-2-interfaces-（接口索引集合）" class="headerlink" title="5.3.2 interfaces[]（接口索引集合）"></a>5.3.2 interfaces[]（接口索引集合）</h4><p>interfaces[]中每个成员的值必须是对常量池表中某项的有效索引值，它的长度为interfaces_count。每个成员interfaces[i]必须为CONSTANT_Class_info结构，其中0 &lt;&#x3D; i &lt; interfaces_count。在interfaces[]中，各成员所表示的接口顺序和对应的源代码中给定的接口顺序（从左至右）一样，即interfaces[0]对应的是源代码中最左边的接口。</p><h2 id="6-字段表集合"><a href="#6-字段表集合" class="headerlink" title="6. 字段表集合"></a>6. 字段表集合</h2><p><strong>fields</strong></p><ul><li><p>用于描述接口或类中声明的变量。字段（field）包括类级变量以及实例级变量，但是不包括方法内部、代码块内部声明的局部变量。</p></li><li><p>字段叫什么名字、字段被定义为什么数据类型，这些都是无法固定的，只能引用常量池中的常量来描述。</p></li><li><p>它指向常量池索引集合，它描述了每个字段的完整信息。比如字段的标识符、访问修饰符（public、private或protected）、是类变量还是实例变量（static修饰符）、是否是常量（final修饰符）等。</p></li></ul><p><strong>注意事项：</strong></p><ul><li><p>字段表集合中不会列出从父类或者实现的接口中继承而来的字段，但有可能列出原本Java代码之中不存在的字段。譬如在内部类中为了保持对外部类的访问性，会自动添加指向外部类实例的字段。</p></li><li><p>在Java语言中字段是无法重载的，两个字段的数据类型、修饰符不管是否相同，都必须使用不一样的名称，但是对于字节码来讲，如果两个字段的描述符不一致，那字段重名就是合法的。</p></li></ul><h3 id="6-1-字段计数器"><a href="#6-1-字段计数器" class="headerlink" title="6.1 字段计数器"></a>6.1 字段计数器</h3><p><strong>fields_count（字段计数器）</strong></p><p>fields_count 的值表示当前class文件fields表的成员个数。使用两个字节来表示。</p><p>fields表中每个成员都是一个field_info结构，用于表示该类或接口所声明的所有类字段或者实例字段，不包括方法内部声明的变量，也不包括从父类或父接口继承的那些字段。</p><table><thead><tr><th>标志名称</th><th>标志值</th><th>含义</th><th>数量</th></tr></thead><tbody><tr><td>u2</td><td>access_flags</td><td>访问标志</td><td>1</td></tr><tr><td>u2</td><td>name_index</td><td>字段名索引</td><td>1</td></tr><tr><td>u2</td><td>descriptor_index</td><td>描述符索引</td><td>1</td></tr><tr><td>u2</td><td>attributes_count</td><td>属性计数器</td><td>1</td></tr><tr><td>attribute_info</td><td>attributes</td><td>属性集合</td><td>attributes_count</td></tr></tbody></table><h3 id="6-2-字段表"><a href="#6-2-字段表" class="headerlink" title="6.2 字段表"></a>6.2 字段表</h3><h4 id="6-2-1-字段表访问标识"><a href="#6-2-1-字段表访问标识" class="headerlink" title="6.2.1 字段表访问标识"></a>6.2.1 字段表访问标识</h4><p>我们知道，一个字段可以被各种关键字去修饰，比如：作用域修饰符（public、private、protected）、static修饰符、final修饰符、volatile修饰符等等。因此，其可像类的访问标志那样，使用一些标志来标记字段。字段的访问标志有如下这些：</p><table><thead><tr><th>标志名称</th><th>标志值</th><th>含义</th></tr></thead><tbody><tr><td>ACC_PUBLIC</td><td>0x0001</td><td>字段是否为public</td></tr><tr><td>ACC_PRIVATE</td><td>0x0002</td><td>字段是否为private</td></tr><tr><td>ACC_PROTECTED</td><td>0x0004</td><td>字段是否为protected</td></tr><tr><td>ACC_STATIC</td><td>0x0008</td><td>字段是否为static</td></tr><tr><td>ACC_FINAL</td><td>0x0010</td><td>字段是否为final</td></tr><tr><td>ACC_VOLATILE</td><td>0x0040</td><td>字段是否为volatile</td></tr><tr><td>ACC_TRANSTENT</td><td>0x0080</td><td>字段是否为transient</td></tr><tr><td>ACC_SYNCHETIC</td><td>0x1000</td><td>字段是否为由编译器自动产生</td></tr><tr><td>ACC_ENUM</td><td>0x4000</td><td>字段是否为enum</td></tr></tbody></table><h4 id="6-2-2-描述符索引"><a href="#6-2-2-描述符索引" class="headerlink" title="6.2.2 描述符索引"></a>6.2.2 描述符索引</h4><p>描述符的作用是用来描述字段的数据类型、方法的参数列表（包括数量、类型以及顺序）和返回值。根据描述符规则，基本数据类型（byte，char，double，float，int，long，short，boolean）及代表无返回值的void类型都用一个大写字符来表示，而对象则用字符L加对象的全限定名来表示，如下所示：</p><table><thead><tr><th>标志符</th><th>含义</th></tr></thead><tbody><tr><td>B</td><td>基本数据类型byte</td></tr><tr><td>C</td><td>基本数据类型char</td></tr><tr><td>D</td><td>基本数据类型double</td></tr><tr><td>F</td><td>基本数据类型float</td></tr><tr><td>I</td><td>基本数据类型int</td></tr><tr><td>J</td><td>基本数据类型long</td></tr><tr><td>S</td><td>基本数据类型short</td></tr><tr><td>Z</td><td>基本数据类型boolean</td></tr><tr><td>V</td><td>代表void类型</td></tr><tr><td>L</td><td>对象类型，比如：<code>Ljava/lang/Object;</code></td></tr><tr><td>[</td><td>数组类型，代表一维数组.  示例：<code>double[][][]</code> is <code>[[[D</code></td></tr></tbody></table><h4 id="6-3-属性表集合"><a href="#6-3-属性表集合" class="headerlink" title="6.3 属性表集合"></a>6.3 属性表集合</h4><p>一个字段还可能拥有一些属性，用于存储更多的额外信息。比如初始化值、一些注释信息等。属性个数存放在attribute_count中，属性具体内容存放在attributes数组中。</p><pre><code class="highlight java"><span class="comment">// 以常量属性为例，结构为：</span>ConstantValue_attribute&#123;u2 attribute_name_index;u4 attribute_length;    u2 constantvalue_index;&#125;</code></pre><p>说明：对于常量属性而言，attribute_length值恒为2。</p><p><img src="https://raw.githubusercontent.com/GeorgeChan95/blogimg/master/img/2024/07/19/20240719-154111.png" alt="字段常量属性示例"></p><h2 id="7-方法表集合"><a href="#7-方法表集合" class="headerlink" title="7. 方法表集合"></a>7. 方法表集合</h2><p>Methods：指向常量池索引集合，它完整描述了每个方法的签名。</p><ul><li><p>在字节码文件中，每一个method_info项都对应着一个类或者接口中的方法信息。比如方法的访问修饰符（public、private或protected），方法的返回值类型以及方法的参数信息等。</p></li><li><p>如果这个方法不是抽象的或者不是native的，那么字节码中会体现出来。</p></li><li><p>一方面，methods表只描述当前类或接口中声明的方法，不包括从父类或父接口继承的方法。另一方面，methods表有可能会出现由编译器自动添加的方法，最典型的便是编译器产生的方法信息（比如：类（接口）初始化方法<clinit>()和实例初始化方法<init>()）。</p></li></ul><p><strong>使用注意事项：</strong></p><p>在Java语言中，要重载（Overload）一个方法，除了要与原方法具有相同的简单名称之外，还要求必须拥有一个与原方法不同的特征签名，特征签名就是一个方法中各个参数在常量池中的字段符号引用的集合，也就是因为返回值不会包含在特征签名之中，因此Java语言里无法仅仅依靠返回值的不同来对一个已有方法进行重载。但在Class文件格式中，特征签名的范围更大一些，只要描述符不是完全一致的两个方法就可以共存。也就是说，如果两个方法有相同的名称和特征签名，但返回值不同，那么也是可以合法共存于同一个class文件中。</p><p>也就是说，尽管Java语法规范并不允许在一个类或者接口中声明多个方法签名相同的方法，但是和Java语法规范相反，字节码文件中却恰恰允许存放多个方法签名相同的方法，唯一的条件就是这些方法之间的返回值不能相同。</p><h3 id="7-1-方法计数器"><a href="#7-1-方法计数器" class="headerlink" title="7.1 方法计数器"></a>7.1 方法计数器</h3><p><strong>methods_count（方法计数器）</strong></p><ul><li><p>methods_count 的值表示当前class文件methods表的成员个数。使用<strong>两个字节</strong>来表示。</p></li><li><p>methods表中每个成员都是一个method_info结构。</p></li></ul><h4 id="7-2-方法表"><a href="#7-2-方法表" class="headerlink" title="7.2 方法表"></a>7.2 方法表</h4><p><strong>methods[]（方法表）</strong></p><ul><li><p>methods表中的每个成员都必须是一个method_info结构，用于表示当前类或接口中某个方法的完整描述。如果某个method_info结构的access_flags项既没有设置ACC_NATIVE标志也没有设置ACC_ABSTRACT标志，那么该结构中也应包含实现这个方法所用的Java虚拟机指令。</p></li><li><p>method_info结构可以表示类和接口中定义的所有方法，包括实例方法、类方法、实例初始化方法和类或接口初始化方法.</p></li></ul><p>方法表的结构实际跟字段表是一样的，方法表结构如下：</p><table><thead><tr><th>标志名称</th><th>标志值</th><th>含义</th><th>数量</th></tr></thead><tbody><tr><td>u2</td><td>access_flags</td><td>访问标志</td><td>1</td></tr><tr><td>u2</td><td>name_index</td><td>方法名索引</td><td>1</td></tr><tr><td>u2</td><td>descriptor_index</td><td>描述符索引</td><td>1</td></tr><tr><td>u2</td><td>attributes_count</td><td>属性计数器</td><td>1</td></tr><tr><td>attribute_info</td><td>attributes</td><td>属性集合</td><td>attributes_count</td></tr></tbody></table><p><strong>方法表访问标志</strong></p><p>跟字段表一样，方法表也有访问标志，而且他们的标志有部分相同，部分则不同，方法表的具体访问标志如下：</p><table><thead><tr><th>标志名称</th><th>标志值</th><th>含义</th></tr></thead><tbody><tr><td>ACC_PUBLIC</td><td>0x0001</td><td>public，方法可以从包外访问</td></tr><tr><td>ACC_PRIVATE</td><td>0x0002</td><td>private，方法只能本类访问</td></tr><tr><td>ACC_PROTECTED</td><td>0x0004</td><td>protected，方法在自身和子类可以访问</td></tr><tr><td>ACC_STATIC</td><td>0x0008</td><td>static，静态方法</td></tr></tbody></table><h2 id="8-属性表集合"><a href="#8-属性表集合" class="headerlink" title="8. 属性表集合"></a>8. 属性表集合</h2><p>方法表集合之后的属性表集合，指的是class文件所携带的辅助信息，比如该class文件的源文件的名称。以及任何带有RetentionPolicy.CLASS 或者RetentionPolicy.RUNTIME的注解。这类信息通常被用于Java虚拟机的验证和运行，以及Java程序的调试，一般无须深入了解。</p><p>此外，字段表、方法表都可以有自己的属性表。用于描述某些场景专有的信息。</p><p>属性表集合的限制没有那么严格，不再要求各个属性表具有严格的顺序，并且只要不与已有的属性名重复，任何人实现的编译器都可以向属性表中写入自己定义的属性信息，但Java虚拟机运行时会忽略掉它不认识的属性。</p><h3 id="8-1-属性计数器"><a href="#8-1-属性计数器" class="headerlink" title="8.1 属性计数器"></a>8.1 属性计数器</h3><p><strong>attributes_count（属性计数器）</strong></p><p>attributes_count的值表示当前class文件属性表的成员个数。属性表中每一项都是一个attribute_info结构。</p><h3 id="8-2-属性表"><a href="#8-2-属性表" class="headerlink" title="8.2 属性表"></a>8.2 属性表</h3><p><strong>attributes[]（属性表）</strong></p><p>属性表的每个项的值必须是attribute_info结构。属性表的结构比较灵活，各种不同的属性只要满足以下结构即可。</p><h4 id="8-2-1-属性的通用格式"><a href="#8-2-1-属性的通用格式" class="headerlink" title="8.2.1 属性的通用格式"></a><strong>8.2.1 属性的通用格式</strong></h4><table><thead><tr><th>类型</th><th>名称</th><th>数量</th><th>含义</th></tr></thead><tbody><tr><td>u2</td><td>attribute_name_index</td><td>1</td><td>属性名索引</td></tr><tr><td>u4</td><td>attribute_length</td><td>1</td><td>属性长度</td></tr><tr><td>u1</td><td>info</td><td>attribute_length</td><td>属性表</td></tr></tbody></table><h4 id="8-2-2-属性类型"><a href="#8-2-2-属性类型" class="headerlink" title="8.2.2 属性类型"></a><strong>8.2.2 属性类型</strong></h4><p>属性表实际上可以有很多类型，上面看到的Code属性只是其中一种，Java8里面定义了23种属性。下面这些是虚拟机中预定义的属性：</p><table><thead><tr><th>属性名称</th><th>使用位置</th><th>含义</th></tr></thead><tbody><tr><td>Code</td><td>方法表</td><td>Java代码编译成的字节码指令</td></tr><tr><td>ConstantValue</td><td>字段表</td><td>final关键字定义的常量池</td></tr><tr><td>Deprecated</td><td>类，方法，字段表</td><td>被声明为deprecated的方法和字段</td></tr><tr><td>Exceptions</td><td>方法表</td><td>方法抛出的异常</td></tr><tr><td>EnclosingMethod</td><td>类文件</td><td>仅当一个类为局部类或者匿名类时才能拥有这个属性，这个属性用于标识这个类所在的外围方法</td></tr><tr><td>InnerClass</td><td>类文件</td><td>内部类列表</td></tr><tr><td>LineNumberTable</td><td>Code属性</td><td>Java源码的行号与字节码指令的对应关系</td></tr><tr><td>LocalVariableTable</td><td>Code属性</td><td>方法的局部变量描述</td></tr><tr><td>StackMapTable</td><td>Code属性</td><td>JDK1.6中新增的属性，供新的类型检查检验器和处理目标方法的局部变量和操作数有所需要的类是否匹配</td></tr><tr><td>Signature</td><td>类，方法表，字段表</td><td>用于支持泛型情况下的方法签名</td></tr><tr><td>SourceFile</td><td>类文件</td><td>记录源文件名称</td></tr><tr><td>SourceDebugExtension</td><td>类文件</td><td>用于存储额外的调试信息</td></tr><tr><td>Synthetic</td><td>类，方法表，字段表</td><td>标志方法或字段为编译器自动生成的</td></tr><tr><td>LocalVariableTypeTable</td><td>类</td><td>使用特征签名代替描述符，是为了引入泛型语法之后能描述泛型参数化类型而添加</td></tr><tr><td>RuntimeVisibleAnnotations</td><td>类，方法表，字段表</td><td>为动态注解提供支持</td></tr><tr><td>RuntimeInvisibleAnnotations</td><td>类，方法表，字段表</td><td>用于指明哪些注解是运行时不可见的</td></tr><tr><td>RuntimeVisibleParameterAnnotation</td><td>方法表</td><td>作用与RuntimeVisibleAnnotations属性类似，只不过作用对象或方法</td></tr><tr><td>RuntimeInvisibleParameterAnnotation</td><td>方法表</td><td>作用与RuntimeInvisibleAnnotations属性类似，只不过作用对象或方法</td></tr><tr><td>AnnotationDefault</td><td>方法表</td><td>用于记录注解类元素的默认值</td></tr><tr><td>BootstrapMethods</td><td>类文件</td><td>用于保存invokeddynamic指令引用的引导方法限定符</td></tr></tbody></table><p>官方网址查看: <a href="https://docs.oracle.com/javase/specs/jvms/se8/html/jvms-4.html#jvms-4.7">https://docs.oracle.com/javase/specs/jvms/se8/html/jvms-4.html#jvms-4.7</a></p><h4 id="8-2-3-部分属性详解"><a href="#8-2-3-部分属性详解" class="headerlink" title="8.2.3 部分属性详解"></a>8.2.3 部分属性详解</h4><p><strong>① ConstantValue属性</strong></p><p>ConstantValue属性表示一个常量字段的值。位于field_info结构的属性表中。</p><pre><code class="highlight java">ConstantValue_attribute&#123;u2 attribute_name_index;u4 attribute_length;u2 constantvalue_index;<span class="comment">//字段值在常量池中的索引，常量池在该索引处的项给出该属性表示的常量值。（例如，值是1ong型的，在常量池中便是CONSTANT_Long）</span>&#125;</code></pre><p><img src="https://raw.githubusercontent.com/GeorgeChan95/blogimg/master/img/2024/07/20/20240720-171159.png" alt="ConstantValue"></p><p><strong>② Deprecated 属性</strong></p><p>Deprecated 属性是在JDK1.1为了支持注释中的关键词@deprecated而引入的。</p><pre><code class="highlight java">Deprecated_attribute&#123;u2 attribute_name_index;u4 attribute_length;&#125;</code></pre><p><strong>③ Code属性</strong></p><p>Code属性就是存放方法体里面的代码。但是，并非所有方法表都有Code属性。像接口或者抽象方法，他们没有具体的方法体，因此也就不会有Code属性了。Code属性表的结构，如下表：</p><table><thead><tr><th>类型</th><th>名称</th><th>数量</th><th>含义</th></tr></thead><tbody><tr><td>u2</td><td>attribute_name_index</td><td>1</td><td>属性名索引</td></tr><tr><td>u4</td><td>attribute_length</td><td>1</td><td>属性长度</td></tr><tr><td>u2</td><td>max_stack</td><td>1</td><td>操作数栈深度的最大值</td></tr><tr><td>u2</td><td>max_locals</td><td>1</td><td>局部变量表所需的存续空间</td></tr><tr><td>u4</td><td>code_length</td><td>1</td><td>字节码指令的长度</td></tr><tr><td>u1</td><td>code</td><td>code_lenth</td><td>存储字节码指令</td></tr><tr><td>u2</td><td>exception_table_length</td><td>1</td><td>异常表长度</td></tr><tr><td>exception_info</td><td>exception_table</td><td>exception_length</td><td>异常表</td></tr><tr><td>u2</td><td>attributes_count</td><td>1</td><td>属性集合计数器</td></tr><tr><td>attribute_info</td><td>attributes</td><td>attributes_count</td><td>属性集合</td></tr></tbody></table><p><img src="https://raw.githubusercontent.com/GeorgeChan95/blogimg/master/img/2024/07/20/20240720-171543.png" alt="Code属性"></p><p>可以看到：Code属性表的前两项跟属性表是一致的，即Code属性表遵循属性表的结构，后面那些则是他自定义的结构。</p><p><strong>④ InnerClasses 属性</strong></p><p>为了方便说明特别定义一个表示类或接口的Class格式为C。如果C的常量池中包含某个CONSTANT_Class_info成员，且这个成员所表示的类或接口不属于任何一个包，那么C的ClassFile结构的属性表中就必须含有对应的InnerClasses属性。InnerClasses属性是在JDK1.1中为了支持内部类和内部接口而引入的，位于ClassFile结构的属性表。</p><p><strong>⑤ LineNumberTable属性</strong></p><p>LineNumberTable属性是可选变长属性，位于Code结构的属性表。</p><p><strong>LineNumberTable属性是用来描述 <code>Java源码行号</code> 与 <code>字节码行号</code> 之间的对应关系</strong>。这个属性可以用来在调试的时候定位代码执行的行数。</p><ul><li>start_pc，即字节码行号；line_number，即Java源代码行号。</li></ul><p>在Code属性的属性表中，LineNumberTable属性可以按照任意顺序出现，此外，多个LineNumberTable属性可以共同表示一个行号在源文件中表示的内容，即LineNumberTable属性不需要与源文件的行一一对应。</p><pre><code class="highlight java"><span class="comment">// LineNumberTable属性表结构：</span>LineNumberTable_attribute&#123;    u2 attribute_name_index;    u4 attribute_length;    u2 line_number_table_length;    &#123;        u2 start_pc;        u2 line_number;    &#125; line_number_table[line_number_table_length];&#125;</code></pre><p><img src="https://raw.githubusercontent.com/GeorgeChan95/blogimg/master/img/2024/07/20/20240720-172941.png" alt="字节码"></p><p><img src="https://raw.githubusercontent.com/GeorgeChan95/blogimg/master/img/2024/07/20/20240720-173134.png" alt="LineNumberTable"></p><p><strong>⑥ LocalVariableTable属性</strong></p><p>LocalVariableTable是可选变长属性，位于Code属性的属性表中。它被调试器用于确定方法在执行过程中局部变量的信息。在Code属性的属性表中，LocalVariableTable属性可以按照任意顺序出现。Code属性中的每个局部变量最多只能有一个LocalVariableTable属性。</p><ul><li><p>start pc + length表示这个变量在字节码中的生命周期起始和结束的偏移位置（this生命周期从头0到结尾15）</p></li><li><p>index就是这个变量在局部变量表中的槽位（槽位可复用）</p></li><li><p>name就是变量名</p></li><li><p>Descriptor表示局部变量类型描述</p></li></ul><pre><code class="highlight java"><span class="comment">// LocalVariableTable属性表结构：</span>LocalVariableTable_attribute&#123;    u2 attribute_name_index;    u4 attribute_length;    u2 local_variable_table_length;    &#123;        u2 start_pc;        u2 length;        u2 name_index;        u2 descriptor_index;        u2 index;    &#125; local_variable_table[local_variable_table_length];&#125;</code></pre><p><img src="https://raw.githubusercontent.com/GeorgeChan95/blogimg/master/img/2024/07/20/20240720-173346.png" alt="LocalVariableTable"></p><p><strong>⑦ Signature属性</strong></p><p>Signature属性是可选的定长属性，位于ClassFile，field_info或method_info结构的属性表中。在Java语言中，任何类、接口、初始化方法或成员的泛型签名如果包含了类型变量（Type Variables）或参数化类型（Parameterized Types），则Signature属性会为它记录泛型签名信息。</p><p><strong>⑧ SourceFile属性</strong></p><p>SourceFile属性结构</p><table><thead><tr><th>类型</th><th>名称</th><th>数量</th><th>含义</th></tr></thead><tbody><tr><td>u2</td><td>attribute_name_index</td><td>1</td><td>属性名索引</td></tr><tr><td>u4</td><td>attribute_length</td><td>1</td><td>属性长度</td></tr><tr><td>u2</td><td>source file name index</td><td>1</td><td>源码文件素引</td></tr></tbody></table><p>可以看到，其长度总是固定的8个字节。</p><p><strong>⑨ 其他属性</strong></p><p>Java虚拟机中预定义的属性有20多个，这里就不一一介绍了，通过上面几个属性的介绍，只要领会其精髓，其他属性的解读也是易如反掌。</p><h1 id="参考文档"><a href="#参考文档" class="headerlink" title="参考文档"></a>参考文档</h1><blockquote><p>参考1: <a href="https://blog.csdn.net/weelyy/article/details/78969412">https://blog.csdn.net/weelyy/article/details/78969412</a></p><p>JAVA虚拟机规范官方文档:<a href="https://docs.oracle.com/javase/specs/jvms/se8/html/index.html">https://docs.oracle.com/javase/specs/jvms/se8/html/index.html</a></p></blockquote>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;一、概述&quot;&gt;&lt;a href=&quot;#一、概述&quot; class=&quot;headerlink&quot; title=&quot;一、概述&quot;&gt;&lt;/a&gt;一、概述&lt;/h1&gt;&lt;h2 id=&quot;1-字节码文件的跨平台型&quot;&gt;&lt;a href=&quot;#1-字节码文件的跨平台型&quot; class=&quot;headerlink&quot; </summary>
      
    
    
    
    <category term="JVM" scheme="https://georgechan95.github.io/categories/JVM/"/>
    
    
    <category term="java" scheme="https://georgechan95.github.io/tags/java/"/>
    
    <category term="jvm" scheme="https://georgechan95.github.io/tags/jvm/"/>
    
  </entry>
  
  <entry>
    <title>第十五章-GC日志分析</title>
    <link href="https://georgechan95.github.io/blog/309245330.html"/>
    <id>https://georgechan95.github.io/blog/309245330.html</id>
    <published>2024-07-13T00:34:00.000Z</published>
    <updated>2024-08-28T04:17:33.364Z</updated>
    
    <content type="html"><![CDATA[<h1 id="一、GC日志参数"><a href="#一、GC日志参数" class="headerlink" title="一、GC日志参数"></a>一、GC日志参数</h1><p>通过阅读Gc日志，我们可以了解Java虚拟机内存分配与回收策略。 内存分配与垃圾回收的参数列表.</p><ul><li><p><code>-XX:+PrintGC</code> 输出GC日志。类似：<code>-verbose:gc</code></p></li><li><p><code>-XX:+PrintGCDetails</code> 输出GC的详细日志</p></li><li><p><code>-XX:+PrintGCTimestamps</code> 输出GC的时间戳（以基准时间的形式）</p></li><li><p><code>-XX:+PrintGCDatestamps</code> 输出GC的时间戳（以日期的形式，如2013-05-04T21：53：59.234+0800）</p></li><li><p><code>-XX:+PrintHeapAtGC</code> 在进行GC的前后打印出堆的信息</p></li><li><p><code>-Xloggc:../logs/gc.log</code> 日志文件的输出路径</p></li></ul><h2 id="1-实例1"><a href="#1-实例1" class="headerlink" title="1. 实例1"></a>1. 实例1</h2><p>打开GC日志</p><pre><code class="highlight shell">-verbose:gc</code></pre><p>这个只会显示总的GC堆的变化，如下：</p><pre><code class="highlight shell">[GC (Allocation Failure) 80832K-&gt;19298K(227840K),0.0084018 secs][GC (Metadata GC Threshold) 109499K-&gt;21465K(228352K),0.0184066 secs][Full GC (Metadata GC Threshold) 21465K-&gt;16716K(201728K),0.0619261 secs]</code></pre><p>参数解析</p><pre><code class="highlight shell">GC、Full GC：GC的类型，GC只在新生代上进行，Full GC包括永生代，新生代，老年代。Allocation Failure：GC发生的原因。<span class="meta prompt_">80832K-&gt;</span><span class="language-bash">19298K：堆在GC前的大小和GC后的大小。</span>227840k：现在的堆大小。0.0084018 secs：GC持续的时间。</code></pre><h2 id="2-实例2"><a href="#2-实例2" class="headerlink" title="2. 实例2"></a>2. 实例2</h2><p>查看GC日志详细</p><pre><code class="highlight shell">-verbose:gc -XX:+PrintGCDetails</code></pre><p>输出信息如下</p><pre><code class="highlight shell">[GC (Allocation Failure) [PSYoungGen:70640K-&gt;10116K(141312K)] 80541K-&gt;20017K(227328K),0.0172573 secs] [Times:user=0.03 sys=0.00,real=0.02 secs][GC (Metadata GC Threshold) [PSYoungGen:98859K-&gt;8154K(142336K)] 108760K-&gt;21261K(228352K),0.0151573 secs] [Times:user=0.00 sys=0.01,real=0.02 secs][Full GC (Metadata GC Threshold)[PSYoungGen:8154K-&gt;0K(142336K)][ParOldGen:13107K-&gt;16809K(62464K)] 21261K-&gt;16809K(204800K),[Metaspace:20599K-&gt;20599K(1067008K)],0.0639732 secs][Times:user=0.14 sys=0.00,real=0.06 secs]</code></pre><p>参数解析</p><pre><code class="highlight java">GC，Full FC：同样是GC的类型Allocation Failure：GC原因PSYoungGen：使用了Parallel Scavenge并行垃圾收集器的新生代GC前后大小的变化ParOldGen：使用了Parallel Old并行垃圾收集器的老年代GC前后大小的变化Metadata：元数据区GC前后大小的变化，JDK1<span class="number">.8</span>中引入了元数据区以替代永久代xxx secs：指GC花费的时间Times：user：指的是垃圾收集器花费的所有CPU时间，sys：花费在等待系统调用或系统事件的时间，real：GC从开始到结束的时间，包括其他进程占用时间片的实际时间。</code></pre><h2 id="3-实例3"><a href="#3-实例3" class="headerlink" title="3. 实例3"></a>3. 实例3</h2><p>打开GC日志</p><pre><code class="highlight shell">-verbose:gc -XX:+PrintGCDetails -XX:+PrintGCTimestamps -XX:+PrintGCDatestamps</code></pre><p>输出信息如下</p><pre><code class="highlight shell">2019-09-24T22:15:24.518+0800: 3.287: [GC (Allocation Failure) [PSYoungGen:136162K-&gt;5113K(136192K)] 141425K-&gt;17632K(222208K),0.0248249 secs] [Times:user=0.05 sys=0.00,real=0.03 secs]2019-09-24T22:15:25.559+0800: 4.329: [GC (Metadata GC Threshold) [PSYoungGen:97578K-&gt;10068K(274944K)] 110096K-&gt;22658K(360960K),0.0094071 secs] [Times: user=0.00 sys=0.00,real=0.01 secs]2019-09-24T22:15:25.569+0800: 4.338: [Full GC (Metadata GC Threshold) [PSYoungGen:10068K-&gt;0K(274944K)][ParoldGen:12590K-&gt;13564K(56320K)] 22658K-&gt;13564K(331264K),[Metaspace:20590K-&gt;20590K(1067008K)],0.0494875 secs] [Times: user=0.17 sys=0.02,real=0.05 secs]</code></pre><p>说明：带上了日期和时间</p><h2 id="4-日出输出log"><a href="#4-日出输出log" class="headerlink" title="4. 日出输出log"></a>4. 日出输出log</h2><p>如果想把GC日志存到文件的话，是下面的参数：</p><pre><code class="highlight shell">-Xloggc:/path/to/gc.log</code></pre><h2 id="5-日志补充说明"><a href="#5-日志补充说明" class="headerlink" title="5. 日志补充说明"></a>5. 日志补充说明</h2><ul><li><p>“<code>[GC</code>“和”<code>[Full GC</code>“说明了这次垃圾收集的停顿类型，如果有”Full”则说明GC发生了”Stop The World” </p></li><li><p>使用Serial收集器在新生代的名字是Default New Generation，因此显示的是”<code>[DefNew</code>“ </p></li><li><p>使用ParNew收集器在新生代的名字会变成”<code>[ParNew</code>“，意思是”Parallel New Generation” </p></li><li><p>使用Parallel scavenge收集器在新生代的名字是”<code>[PSYoungGen</code>“ </p></li><li><p>老年代的收集和新生代道理一样，名字也是收集器决定的 </p></li><li><p>使用G1收集器的话，会显示为”garbage-first heap” </p></li><li><p>Allocation Failure<br>  表明本次引起GC的原因是因为在年轻代中没有足够的空间能够存储新的数据了。 </p></li><li><p>[PSYoungGen：5986K-&gt;696K(8704K) ] 5986K-&gt;704K(9216K)<br>  中括号内：GC回收前年轻代大小，回收后大小，（年轻代总大小）<br>  括号外：GC回收前年轻代和老年代大小，回收后大小，（年轻代和老年代总大小） </p></li><li><p>user代表用户态回收耗时，sys内核态回收耗时，real实际耗时。由于多核的原因，时间总和可能会超过real时间</p></li></ul><pre><code class="highlight java">Heap（堆）PSYoungGen（Parallel Scavenge收集器新生代）total 9216K，used 6234K [<span class="number">0x00000000ff600000</span>,<span class="number">0x0000000100000000</span>,<span class="number">0x0000000100000000</span>)eden space（堆中的Eden区默认占比是<span class="number">8</span>）8192K，<span class="number">768</span> used [<span class="number">0x00000000ff600000</span>,<span class="number">0x00000000ffc16b08</span>,<span class="number">0x00000000ffe00000</span>)from space（堆中的Survivor，这里是From Survivor区默认占比是<span class="number">1</span>）1024K， <span class="number">0</span>% used [<span class="number">0x00000000fff00000</span>,<span class="number">0x00000000fff00000</span>,<span class="number">0x0000000100000000</span>)to space（堆中的Survivor，这里是to Survivor区默认占比是<span class="number">1</span>，需要先了解一下堆的分配策略）1024K, <span class="number">0</span>% used [<span class="number">0x00000000ffe00000</span>,<span class="number">0x00000000ffe00000</span>,<span class="number">0x00000000fff00000</span>)                                                                         ParOldGen（老年代总大小和使用大小）total 10240K， used 7001K ［<span class="number">0x00000000fec00000</span>,<span class="number">0x00000000ff600000</span>,<span class="number">0x00000000ff600000</span>)object space（显示个使用百分比）10240K，<span class="number">688</span> used [<span class="number">0x00000000fec00000</span>,<span class="number">0x00000000ff2d6630</span>,<span class="number">0x00000000ff600000</span>)PSPermGen（永久代总大小和使用大小）total 21504K， used 4949K [<span class="number">0x00000000f9a00000</span>,<span class="number">0x00000000faf00000</span>,<span class="number">0x00000000fec00000</span>)object space（显示个使用百分比，自己能算出来）21504K， <span class="number">238</span> used [<span class="number">0x00000000f9a00000</span>,<span class="number">0x00000000f9ed55e0</span>,<span class="number">0x00000000faf00000</span>)</code></pre><h1 id="二、Minor-GC日志"><a href="#二、Minor-GC日志" class="headerlink" title="二、Minor GC日志"></a>二、Minor GC日志</h1><p><img src="https://raw.githubusercontent.com/GeorgeChan95/blogimg/master/img/2024/07/13/20240713-172009.png" alt="Minor GC"></p><h1 id="三、Full-GC日志"><a href="#三、Full-GC日志" class="headerlink" title="三、Full GC日志"></a>三、Full GC日志</h1><p><img src="https://raw.githubusercontent.com/GeorgeChan95/blogimg/master/img/2024/07/13/20240713-192253.png" alt="Full GC日志"></p><h1 id="四、举例"><a href="#四、举例" class="headerlink" title="四、举例"></a>四、举例</h1><p>**代码如下: **</p><pre><code class="highlight shell">private static final int _1MB = 1024 * 1024;public static void testAllocation() &#123;    byte [] allocation1, allocation2, allocation3, allocation4;    allocation1 = new byte[2 *_1MB];    allocation2 = new byte[2 *_1MB];    allocation3 = new byte[2 *_1MB];    allocation4 = new byte[4 *_1MB];&#125;public static void main(String[] args) &#123;    testAllocation();&#125;</code></pre><p><strong>设置JVM参数(使用SerialGC)</strong></p><p><strong>JDK8环境</strong></p><pre><code class="highlight shell">-verbose:gc -Xms20M -Xmx20M -Xmn10M -XX:+PrintGCDetails -XX:SurvivorRatio=8 -XX:+UseSerialGC</code></pre><p>打印GC日志如下:</p><pre><code class="highlight shell">[GC (Allocation Failure) [DefNew: 7953K-&gt;624K(9216K), 0.0043498 secs] 7953K-&gt;6768K(19456K), 0.0043857 secs] [Times: user=0.00 sys=0.00, real=0.00 secs] Heap def new generation   total 9216K, used 4802K [0x00000000fec00000, 0x00000000ff600000, 0x00000000ff600000)  eden space 8192K,  51% used [0x00000000fec00000, 0x00000000ff014930, 0x00000000ff400000)  from space 1024K,  60% used [0x00000000ff500000, 0x00000000ff59c198, 0x00000000ff600000)  to   space 1024K,   0% used [0x00000000ff400000, 0x00000000ff400000, 0x00000000ff500000) tenured generation   total 10240K, used 6144K [0x00000000ff600000, 0x0000000100000000, 0x0000000100000000)   the space 10240K,  60% used [0x00000000ff600000, 0x00000000ffc00030, 0x00000000ffc00200, 0x0000000100000000) Metaspace       used 3222K, capacity 4496K, committed 4864K, reserved 1056768K  class space    used 348K, capacity 388K, committed 512K, reserved 1048576K</code></pre><p><strong>解析:</strong></p><p>使用Serial GC, 当需要分配4MB的对象 allocation4 时, 此时年轻代的内存不足了, 这时先将年轻代的数据移动到老年代,然后再将 allocation4 对象放到年轻代. 从日志可以看出来, eden 内存使用了约51%, eden又占整个年轻代的80%(8MB), 老年代GC后使用了 6144K (约6MB) . 从日志中这里也能看出来, Serial GC 的内存分配逻辑.</p><p><strong>图示</strong></p><p><img src="https://raw.githubusercontent.com/GeorgeChan95/blogimg/master/img/2024/07/13/20240713-192925.png" alt="d95ef629-b9fa-43d7-86d2-d1cc26ca9c61"></p><p><img src="https://raw.githubusercontent.com/GeorgeChan95/blogimg/master/img/2024/07/13/20240713-192946.png" alt="bd35738f-276b-4a8c-8d28-cb24aaa99503"></p><p><strong>重新设置JVM参数:</strong></p><p><strong>JDK8环境, 使用默认的Parallel GC</strong></p><pre><code class="highlight shell">-verbose:gc -Xms20M -Xmx20M -Xmn10M -XX:+PrintGCDetails -XX:SurvivorRatio=8</code></pre><p>打印日志如下:</p><pre><code class="highlight shell">Heap PSYoungGen      total 9216K, used 8118K [0x00000000ff600000, 0x0000000100000000, 0x0000000100000000)  eden space 8192K, 99% used [0x00000000ff600000,0x00000000ffded800,0x00000000ffe00000)  from space 1024K, 0% used [0x00000000fff00000,0x00000000fff00000,0x0000000100000000)  to   space 1024K, 0% used [0x00000000ffe00000,0x00000000ffe00000,0x00000000fff00000) ParOldGen       total 10240K, used 4096K [0x00000000fec00000, 0x00000000ff600000, 0x00000000ff600000)  object space 10240K, 40% used [0x00000000fec00000,0x00000000ff000010,0x00000000ff600000) Metaspace       used 3221K, capacity 4496K, committed 4864K, reserved 1056768K  class space    used 348K, capacity 388K, committed 512K, reserved 1048576K</code></pre><p><strong>解析:</strong></p><p>当不指定垃圾收集器时,默认使用的是 Parallel GC. 当需要给 allocation4 分配内存空间时, 此时年轻代的空间已经不够了, 年轻代发生了一次 Minor GC, 由于 allocation1, allocation2, allocation3 没有被释放掉, 年龄也不到默认的阈值 15, 所以只能往 Survivor 区移动,但是 Survivor 区的空间又不够,只能回退到 Eden区. 这样就导致了 allocation4 对象被直接分配到了老年代. 所以老年代使用了 40% 的空间(老年代共10MB). </p><p>至于为什么年轻代使用了99%, 这是由于在分配<code>allocation4</code>时，JVM触发了Minor GC，但并未完全清理Eden区，导致一些对象仍然保留在Eden区。</p><p>这也是 Parallel GC 与 Serial GC 的不同之处.</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;一、GC日志参数&quot;&gt;&lt;a href=&quot;#一、GC日志参数&quot; class=&quot;headerlink&quot; title=&quot;一、GC日志参数&quot;&gt;&lt;/a&gt;一、GC日志参数&lt;/h1&gt;&lt;p&gt;通过阅读Gc日志，我们可以了解Java虚拟机内存分配与回收策略。 内存分配与垃圾回收的参数列</summary>
      
    
    
    
    <category term="JVM" scheme="https://georgechan95.github.io/categories/JVM/"/>
    
    
    <category term="java" scheme="https://georgechan95.github.io/tags/java/"/>
    
    <category term="jvm" scheme="https://georgechan95.github.io/tags/jvm/"/>
    
  </entry>
  
  <entry>
    <title>第十四章-垃圾收集器</title>
    <link href="https://georgechan95.github.io/blog/1750792302.html"/>
    <id>https://georgechan95.github.io/blog/1750792302.html</id>
    <published>2024-07-10T11:27:00.000Z</published>
    <updated>2024-08-28T04:17:33.374Z</updated>
    
    <content type="html"><![CDATA[<h1 id="一、GC分类与性能指标"><a href="#一、GC分类与性能指标" class="headerlink" title="一、GC分类与性能指标"></a>一、GC分类与性能指标</h1><h2 id="1-垃圾回收器概述"><a href="#1-垃圾回收器概述" class="headerlink" title="1. 垃圾回收器概述"></a>1. 垃圾回收器概述</h2><ul><li>垃圾收集器没有在规范中进行过多的规定，可以由不同的厂商、不同版本的JVM来实现。</li><li>由于JDK的版本处于高速迭代过程中，因此Java发展至今已经衍生了众多的GC版本。</li><li>从不同角度分析垃圾收集器，可以将GC分为不同的类型。</li></ul><h2 id="2-垃圾收集器分类"><a href="#2-垃圾收集器分类" class="headerlink" title="2. 垃圾收集器分类"></a>2. 垃圾收集器分类</h2><ul><li><p>按线程数分，可以分为串行垃圾回收器和并行垃圾回收器。</p><p><img src="https://raw.githubusercontent.com/GeorgeChan95/blogimg/master/img/2024/07/10/20240710-194330.png" alt="串行与并行"></p><ul><li><p><strong>串行回收</strong>指的是在同一时间段内只允许有一个CPU用于执行垃圾回收操作，此时工作线程被暂停，直至垃圾收集工作结束。</p><ul><li>在诸如单CPU处理器或者较小的应用内存等硬件平台不是特别优越的场合，串行回收器的性能表现可以超过并行回收器和并发回收器。所以，串行回收默认被应用在客户端的Client模式下的JVM中</li><li>在并发能力比较强的CPU上，并行回收器产生的停顿时间要短于串行回收器。</li></ul></li><li><p><strong>并行收集</strong>可以运用多个CPU同时执行垃圾回收，因此提升了应用的吞吐量，不过并行回收仍然与串行回收一样，采用独占式，使用了“Stop-the-World”机制。</p><ul><li>按照工作模式分，可以分为并发式垃圾回收器和独占式垃圾回收器。<ul><li><strong>并发式垃圾回收器</strong>与应用程序线程交替工作，以尽可能减少应用程序的停顿时间。</li><li><strong>独占式垃圾回收器</strong>（Stop the world）一旦运行，就停止应用程序中的所有用户线程，直到垃圾回收过程完全结束。</li></ul></li></ul><p><img src="https://raw.githubusercontent.com/GeorgeChan95/blogimg/master/img/2024/07/10/20240710-194733.png" alt="独占与并发"></p></li></ul></li><li><p>按碎片处理方式分，可分为压缩式垃圾回收器和非压缩式垃圾回收器。</p><ul><li><p><strong>压缩式垃圾回收器</strong>会在回收完成后，对存活对象进行压缩整理，消除回收后的碎片。</p></li><li><p><strong>非压缩式的垃圾回收器</strong>不进行这步操作。</p></li></ul></li><li><p>按工作的内存区间分，又可分为<strong>年轻代垃圾回收器</strong>和<strong>老年代垃圾回收器</strong>。</p></li></ul><h2 id="3-评估GC的性能指标"><a href="#3-评估GC的性能指标" class="headerlink" title="3. 评估GC的性能指标"></a>3. 评估GC的性能指标</h2><ul><li><p><strong>吞吐量</strong>：运行用户代码的时间占总运行时间的比例（总运行时间 &#x3D; 程序的运行时间 + 内存回收的时间）</p></li><li><p>垃圾收集开销：吞吐量的补数，垃圾收集所用时间与总运行时间的比例。</p></li><li><p><strong>暂停时间</strong>：执行垃圾收集时，程序的工作线程被暂停的时间。</p></li><li><p>收集频率：相对于应用程序的执行，收集操作发生的频率。</p></li><li><p><strong>内存占用</strong>：Java堆区所占的内存大小。</p></li><li><p>快速：一个对象从诞生到被回收所经历的时间。</p></li></ul><p>吞吐量、暂停时间、内存占用 这三者共同构成一个“不可能三角”。三者总体的表现会随着技术进步而越来越好。一款优秀的收集器通常最多同时满足其中的两项。</p><p>这三项里，暂停时间的重要性日益凸显。因为随着硬件发展，内存占用多些越来越能容忍，硬件性能的提升也有助于降低收集器运行时对应用程序的影响，即提高了吞吐量。而内存的扩大，对延迟反而带来负面效果。</p><p><strong>简单来说，主要抓住两点：吞吐量、暂停时间</strong></p><h3 id="3-1-吞吐量"><a href="#3-1-吞吐量" class="headerlink" title="3.1 吞吐量"></a>3.1 吞吐量</h3><p>吞吐量就是CPU用于运行用户代码的时间与CPU总消耗时间的比值，即吞吐量 &#x3D; 运行用户代码时间 &#x2F;（运行用户代码时间+垃圾收集时间）。比如：虚拟机总共运行了100分钟，其中垃圾收集花掉1分钟，那吞吐量就是99%。</p><p>这种情况下，应用程序能容忍较高的暂停时间，因此，高吞吐量的应用程序有更长的时间基准，快速响应是不必考虑的.</p><p>吞吐量优先，意味着在单位时间内，STW的时间最短：0.2 + 0.2 &#x3D; 0.4</p><p><img src="https://raw.githubusercontent.com/GeorgeChan95/blogimg/master/img/2024/07/10/20240710-195512.png" alt="吞吐量优先"></p><h3 id="3-2-暂停时间"><a href="#3-2-暂停时间" class="headerlink" title="3.2 暂停时间"></a>3.2 暂停时间</h3><p>“暂停时间”是指一个时间段内应用程序线程暂停，让GC线程执行的状态。</p><p>例如，GC期间100毫秒的暂停时间意味着在这100毫秒期间内没有应用程序线程是活动的。</p><p>暂停时间优先，意味着尽可能让单次STW的时间最短：0.1 + 0.1 + 0.1 + 0.1 + 0.1 &#x3D; 0.5</p><p><img src="https://raw.githubusercontent.com/GeorgeChan95/blogimg/master/img/2024/07/10/20240710-195651.png" alt="暂停时间优先"></p><h3 id="3-3-吞吐量-vs-暂停时间"><a href="#3-3-吞吐量-vs-暂停时间" class="headerlink" title="3.3 吞吐量 vs 暂停时间"></a>3.3 吞吐量 vs 暂停时间</h3><p>高吞吐量较好因为这会让应用程序的最终用户感觉只有应用程序线程在做“生产性”工作。直觉上，吞吐量越高程序运行越快。</p><p>低暂停时间（低延迟）较好因为从最终用户的角度来看不管是GC还是其他原因导致一个应用被挂起始终是不好的。这取决于应用程序的类型，有时候甚至短暂的200毫秒暂停都可能打断终端用户体验。因此，具有低的较大暂停时间是非常重要的，特别是对于一个交互式应用程序。</p><p>不幸的是”高吞吐量”和”低暂停时间”是一对相互竞争的目标（矛盾）。</p><ul><li>因为如果选择以吞吐量优先，那么必然需要降低内存回收的执行频率，但是这样会导致GC需要更长的暂停时间来执行内存回收。</li><li>相反的，如果选择以低延迟优先为原则，那么为了降低每次执行内存回收时的暂停时间，也只能频繁地执行内存回收，但这又引起了年轻代内存的缩减和导致程序吞吐量的下降。</li></ul><p>在设计（或使用）GC算法时，我们必须确定我们的目标：一个GC算法只可能针对两个目标之一（即只专注于较大吞吐量或最小暂停时间），或尝试找到一个二者的折衷。</p><p>现在标准：<strong>在最大吞吐量优先的情况下，降低停顿时间</strong></p><h1 id="二、不同的垃圾回收器概述"><a href="#二、不同的垃圾回收器概述" class="headerlink" title="二、不同的垃圾回收器概述"></a>二、不同的垃圾回收器概述</h1><h2 id="1-垃圾回收器发展史"><a href="#1-垃圾回收器发展史" class="headerlink" title="1. 垃圾回收器发展史"></a>1. 垃圾回收器发展史</h2><p>有了虚拟机，就一定需要收集垃圾的机制，这就是Garbage Collection，对应的产品我们称为Garbage Collector。</p><ul><li><p>1999年随JDK1.3.1一起来的是串行方式的serialGc，它是第一款GC。ParNew垃圾收集器是Serial收集器的多线程版本</p></li><li><p>2002年2月26日，Parallel GC和Concurrent Mark Sweep GC跟随JDK1.4.2一起发布·</p></li><li><p>Parallel GC在JDK6之后成为HotSpot默认GC。</p></li><li><p>2012年，在JDK1.7u4版本中，G1可用。</p></li><li><p>2017年，JDK9中G1变成默认的垃圾收集器，以替代CMS。</p></li><li><p>2018年3月，JDK10中G1垃圾回收器的并行完整垃圾回收，实现并行性来改善最坏情况下的延迟。</p></li><li><p>2018年9月，JDK11发布。引入Epsilon 垃圾回收器，又被称为 “No-Op(无操作)“ 回收器。同时，引入ZGC：可伸缩的低延迟垃圾回收器（Experimental）</p></li><li><p>2019年3月，JDK12发布。增强G1，自动返回未用堆内存给操作系统。同时，引入Shenandoah GC：低停顿时间的GC（Experimental）。·</p></li><li><p>2019年9月，JDK13发布。增强ZGC，自动返回未用堆内存给操作系统。</p></li><li><p>2020年3月，JDK14发布。删除CMS垃圾回收器。扩展ZGC在macos和Windows上的应用</p></li></ul><h2 id="2-7种经典的垃圾收集器"><a href="#2-7种经典的垃圾收集器" class="headerlink" title="2. 7种经典的垃圾收集器"></a>2. 7种经典的垃圾收集器</h2><ul><li><p>串行回收器：Serial、Serial Old</p></li><li><p>并行回收器：ParNew、Parallel Scavenge、Parallel old</p></li><li><p>并发回收器：CMS、G1</p></li></ul><img src="https://raw.githubusercontent.com/GeorgeChan95/blogimg/master/img/2024/07/10/20240710-201713.png" alt="经典垃圾回收器" style="zoom:67%;" /><p>官方手册：<a href="https://www.oracle.com/technetwork/java/javase/tech/memorymanagement-whitepaper-1-150020.pdf">https://www.oracle.com/technetwork/java/javase/tech/memorymanagement-whitepaper-1-150020.pdf</a></p><h2 id="3-7款经典收集器与垃圾分代之间的关系"><a href="#3-7款经典收集器与垃圾分代之间的关系" class="headerlink" title="3. 7款经典收集器与垃圾分代之间的关系"></a>3. 7款经典收集器与垃圾分代之间的关系</h2><ul><li><p>新生代收集器：Serial、ParNew、Parallel Scavenge； </p></li><li><p>老年代收集器：Serial Old、Parallel Old、CMS； </p></li><li><p>整堆收集器：G1；</p></li></ul><p><img src="https://raw.githubusercontent.com/GeorgeChan95/blogimg/master/img/2024/07/10/20240710-201821.png" alt="经典收集器与垃圾分代之间的关系"></p><h2 id="4-垃圾收集器的组合关系"><a href="#4-垃圾收集器的组合关系" class="headerlink" title="4. 垃圾收集器的组合关系"></a>4. 垃圾收集器的组合关系</h2><p><img src="https://raw.githubusercontent.com/GeorgeChan95/blogimg/master/img/2024/07/10/20240710-201913.png" alt="垃圾收集器的组合关系"></p><ol><li>两个收集器间有连线，表明它们可以搭配使用：Serial&#x2F;Serial Old、Serial&#x2F;CMS、ParNew&#x2F;Serial Old、ParNew&#x2F;CMS、Parallel Scavenge&#x2F;Serial Old、Parallel Scavenge&#x2F;Parallel Old、G1；</li><li>其中Serial Old作为CMS出现”<code>Concurrent Mode Failure</code>“失败的后备预案。</li><li>（红色虚线）由于维护和兼容性测试的成本，在JDK 8时将Serial+CMS、ParNew+Serial Old这两个组合声明为废弃（JEP173），并在JDK9中完全取消了这些组合的支持（JEP214），即：移除。</li><li>（绿色虚线）JDK14中：弃用Parallel Scavenge和Serialold GC组合（JEP366）</li><li>（绿色虚框）JDK14中：删除CMS垃圾回收器（JEP363）</li></ol><h2 id="5-不同的垃圾收集器概述"><a href="#5-不同的垃圾收集器概述" class="headerlink" title="5.  不同的垃圾收集器概述"></a>5.  不同的垃圾收集器概述</h2><p>为什么要有很多收集器，一个不够吗？因为Java的使用场景很多，移动端，服务器等。所以就需要针对不同的场景，提供不同的垃圾收集器，提高垃圾收集的性能。</p><p>虽然我们会对各个收集器进行比较，但并非为了挑选一个最好的收集器出来。没有一种放之四海皆准、任何场景下都适用的完美收集器存在，更加没有万能的收集器。所以我们选择的只是对具体应用最合适的收集器。</p><h2 id="6-如何查看默认垃圾收集器"><a href="#6-如何查看默认垃圾收集器" class="headerlink" title="6. 如何查看默认垃圾收集器"></a>6. 如何查看默认垃圾收集器</h2><ul><li><p><code>-XX:+PrintCommandLineFlags</code>：查看命令行相关参数（包含使用的垃圾收集器）</p></li><li><p>使用命令行指令：<code>jinfo -flag 相关垃圾回收器参数 进程ID</code></p></li></ul><h1 id="三、Serial垃圾回收器-串行回收"><a href="#三、Serial垃圾回收器-串行回收" class="headerlink" title="三、Serial垃圾回收器:串行回收"></a>三、Serial垃圾回收器:串行回收</h1><ul><li><p>Serial收集器是最基本、历史最悠久的垃圾收集器了。JDK1.3之前回收新生代唯一的选择。</p></li><li><p>Serial收集器作为<strong>HotSpot中client模式下的默认新生代垃圾收集器</strong>。</p></li><li><p>Serial收集器采用<strong>复制算法、串行回收</strong>和”stop-the-World”机制的方式执行内存回收。</p></li><li><p>除了年轻代之外，Serial收集器还提供用于执行老年代垃圾收集的<strong>Serial Old收集器</strong>。Serial Old收集器同样也采用了<strong>串行回收</strong>和”Stop the World”机制，只不过内存回收算法使用的是<strong>标记-压缩算法</strong>。</p><ul><li><p>Serial old是运行在Client模式下默认的老年代的垃圾回收器</p></li><li><p>Serial 0ld在Server模式下主要有两个用途：① 与新生代的Parallel scavenge配合使用 ② 作为老年代CMS收集器的后备垃圾收集方案</p><p><img src="https://raw.githubusercontent.com/GeorgeChan95/blogimg/master/img/2024/07/10/20240710-202618.png" alt="Serial与Serial Old"></p></li></ul></li></ul><p>这个收集器是一个单线程的收集器，但它的“单线程”的意义并不仅仅说明它只会使用一个CPU或一条收集线程去完成垃圾收集工作，更重要的是在它进行垃圾收集时，必须暂停其他所有的工作线程，直到它收集结束（Stop The World）</p><p><strong>优势：简单而高效</strong>（与其他收集器的单线程比），对于限定单个CPU的环境来说，Serial收集器由于没有线程交互的开销，专心做垃圾收集自然可以获得最高的单线程收集效率。运行在Client模式下的虚拟机是个不错的选择。在用户的桌面应用场景中，可用内存一般不大（几十MB至一两百MB），可以在较短时间内完成垃圾收集（几十ms至一百多ms），只要不频繁发生，使用串行回收器是可以接受的。</p><p>在HotSpot虚拟机中，使用**<code>-XX:+UseSerialGC</code>参数**可以指定年轻代和老年代都使用串行收集器。等价于新生代用Serial GC，且老年代用Serial Old GC</p><ul><li><code>-XX:+UseSerialGC</code> : 使用Serial 与 Serial Old GC</li></ul><p><strong>总结</strong></p><p>了解即可,现在的CPU都不是单核的了.对于交互较强的应用而言，这种垃圾收集器是不能接受的。一般在Java web应用程序中是不会采用串行垃圾收集器的。</p><h1 id="四、ParNew回收器-并行回收"><a href="#四、ParNew回收器-并行回收" class="headerlink" title="四、ParNew回收器:并行回收"></a>四、ParNew回收器:并行回收</h1><p>如果说Serial GC是年轻代中的单线程垃圾收集器，那么ParNew收集器则是Serial收集器的多线程版本。Par是Parallel的缩写，New：只能处理的是新生代.</p><p>ParNew 收集器除了采用并行回收的方式执行内存回收外，两款垃圾收集器之间几乎没有任何区别。ParNew收集器在年轻代中同样也是采用复制算法、”Stop-the-World”机制。</p><p>ParNew 是很多JVM运行在Server模式下新生代的默认垃圾收集器。</p><p><img src="C:/Users/kd/Desktop/f0178eb2-630b-40ae-86e7-2b37c00351ce.png" alt="ParNew/SerialOld"></p><ul><li>对于新生代，回收次数频繁，使用并行方式高效。</li><li>对于老年代，回收次数少，使用串行方式节省资源。（CPU并行需要切换线程，串行可以省去切换线程的资源）</li></ul><p>由于ParNew收集器是基于并行回收，那么是否可以断定ParNew收集器的回收效率在任何场景下都会比serial收集器更高效？</p><ul><li><p>ParNew 收集器运行在多CPU的环境下，由于可以充分利用多CPU、多核心等物理硬件资源优势，可以更快速地完成垃圾收集，提升程序的吞吐量。</p></li><li><p>但是在单个CPU的环境下，ParNew收集器不比Serial 收集器更高效。虽然Serial收集器是基于串行回收，但是由于CPU不需要频繁地做任务切换，因此可以有效避免多线程交互过程中产生的一些额外开销。</p></li></ul><p><strong>除Serial外，目前只有ParNew GC能与CMS收集器配合工作.</strong></p><p>在程序中，开发人员可以通过选项 <strong>“<code>-XX:+UseParNewGC</code>“</strong> 手动指定使用ParNew收集器执行内存回收任务。它表示年轻代使用并行收集器，不影响老年代。</p><p><strong><code>-XX:ParallelGCThreads</code></strong> : 限制线程数量，默认开启和CPU数据相同的线程数。</p><h1 id="五、Parallel回收器-吞吐量优先"><a href="#五、Parallel回收器-吞吐量优先" class="headerlink" title="五、Parallel回收器:吞吐量优先"></a>五、Parallel回收器:吞吐量优先</h1><p>HotSpot的年轻代中除了拥有ParNew收集器是基于并行回收的以外，Parallel Scavenge收集器同样也采用了复制算法、并行回收和”Stop the World”机制。</p><p>那么Parallel 收集器的出现是否多此一举？</p><ul><li><p>和ParNew收集器不同，ParallelScavenge收集器的目标则是达到一个<strong>可控制的吞吐量（Throughput）</strong>，它也被称为<strong>吞吐量优先的垃圾收集器</strong>。</p></li><li><p><strong>自适应调节策略</strong>也是Parallel Scavenge与ParNew一个重要区别。</p></li></ul><p>高吞吐量则可以高效率地利用CPU时间，尽快完成程序的运算任务，主要适合在后台运算而不需要太多交互的任务。因此，常见在服务器环境中使用。例如，那些执行批量处理、订单处理、工资支付、科学计算的应用程序。</p><p>Parallel 收集器在JDK1.6时提供了用于执行老年代垃圾收集的Parallel Old收集器，用来代替老年代的Serial Old收集器。</p><p><strong>Parallel Old收集器采用了标记-压缩算法，但同样也是基于并行回收和”Stop-the-World”机制。</strong></p><p><img src="https://raw.githubusercontent.com/GeorgeChan95/blogimg/master/img/2024/07/11/20240711-154238.png" alt="Parallel Scavenge/Parallel Old"></p><p>在程序吞吐量优先的应用场景中，Parallel 收集器和Parallel Old收集器的组合，在Server模式下的内存回收性能很不错。在<strong>Java8中，默认是此垃圾收集器。</strong></p><p><strong>参数配置</strong></p><ul><li><p><code>-XX:+UseParallelGC</code> 手动指定年轻代使用Parallel并行收集器执行内存回收任务。 </p></li><li><p><code>-XX:+UseParallelOldGC</code> 手动指定老年代都是使用并行回收收集器。 </p></li><li><ul><li>分别适用于新生代和老年代。默认jdk8是开启的。</li></ul></li><li><ul><li>上面两个参数，默认开启一个，另一个也会被开启。（互相激活）</li></ul></li><li><p><code>-XX:ParallelGCThreads</code> 设置年轻代并行收集器的线程数。一般地，最好与CPU数量相等，以避免过多的线程数影响垃圾收集性能。</p></li></ul><p>  <img src="https://raw.githubusercontent.com/GeorgeChan95/blogimg/master/img/2024/07/11/20240711-154905.png" alt="ParallelGC线程数分配算法"></p><ul><li><p><code>-XX:MaxGCPauseMillis</code> 设置垃圾收集器最大停顿时间（即STW的时间）。单位是毫秒。 </p></li><li><ul><li>为了尽可能地把停顿时间控制在MaxGCPauseMills以内，收集器在工作时会调整Java堆大小或者其他一些参数。</li></ul></li><li><ul><li>对于用户来讲，停顿时间越短体验越好。但是在服务器端，我们注重高并发，整体的吞吐量。所以服务器端适合Parallel，进行控制。</li></ul></li><li><ul><li>该参数使用需谨慎。</li></ul></li><li><p><code>-XX:GCTimeRatio</code> 垃圾收集时间占总时间的比例（&#x3D;1 &#x2F;（N+1））。用于衡量吞吐量的大小。 </p></li><li><ul><li>取值范围（0, 100）。默认值99，也就是垃圾回收时间不超过1%。</li></ul></li><li><ul><li>与前一个<code>-XX:MaxGCPauseMillis</code>参数有一定矛盾性。暂停时间越长，Radio参数就容易超过设定的比例。</li></ul></li><li><p><code>-XX:+UseAdaptivesizePolicy</code> 设置Parallel Scavenge收集器具有自适应调节策略 </p></li><li><ul><li>在这种模式下，年轻代的大小、Eden和Survivor的比例、晋升老年代的对象年龄等参数会被自动调整，已达到在堆大小、吞吐量和停顿时间之间的平衡点。</li></ul></li><li><ul><li>在手动调优比较困难的场合，可以直接使用这种自适应的方式，仅指定虚拟机的最大堆、目标的吞吐量（<code>GCTimeRatio</code>）和停顿时间（<code>MaxGCPauseMills</code>），让虚拟机自己完成调优工作。</li></ul></li></ul><h1 id="六、CMS回收器-低延迟"><a href="#六、CMS回收器-低延迟" class="headerlink" title="六、CMS回收器:低延迟"></a>六、CMS回收器:低延迟</h1><h2 id="1-CMS概述"><a href="#1-CMS概述" class="headerlink" title="1. CMS概述"></a>1. CMS概述</h2><p>在JDK1.5时期，Hotspot推出了一款在<em>强交互应用中</em>几乎可认为有划时代意义的垃圾收集器：CMS（Concurrent-Mark-Sweep）收集器，这款收集器是HotSpot虚拟机中第一款真正意义上的并发收集器，它第一次实现了让垃圾收集线程与用户线程同时工作。</p><p>CMS收集器的关注点是尽可能缩短垃圾收集时用户线程的停顿时间。停顿时间越短（低延迟）就越适合与用户交互的程序，良好的响应速度能提升用户体验。</p><p><strong>CMS的垃圾收集算法采用标记-清除算法，并且也会”Stop-the-World”</strong></p><p>不幸的是，CMS作为老年代的收集器，却无法与JDK1.4.0中已经存在的新生代收集器Parallel Scavenge配合工作，所以在JDK1.5中使用CMS来收集老年代的时候，新生代只能选择ParNew或者Serial收集器中的一个。</p><p>在G1出现之前，CMS使用还是非常广泛的。一直到今天，仍然有很多系统使用CMS GC。</p><p><img src="https://raw.githubusercontent.com/GeorgeChan95/blogimg/master/img/2024/07/11/20240711-155804.png" alt="CMS GC"></p><p>CMS整个过程比之前的收集器要复杂，整个过程分为4个主要阶段，即初始标记阶段、并发标记阶段、重新标记阶段和并发清除阶段</p><ul><li><p><strong>初始标记</strong>（Initial-Mark）阶段：在这个阶段中，程序中所有的工作线程都将会因为“Stop-the-World”机制而出现短暂的暂停，这个阶段的主要任务仅仅只是标记出GCRoots能直接关联到的对象。一旦标记完成之后就会恢复之前被暂停的所有应用线程。由于直接关联对象比较小，所以这里的速度非常快。</p></li><li><p><strong>并发标记</strong>（Concurrent-Mark）阶段：从GC Roots的直接关联对象开始遍历整个对象图的过程，这个过程耗时较长但是不需要停顿用户线程，可以与垃圾收集线程一起并发运行。</p></li><li><p><strong>重新标记</strong>（Remark）阶段：由于在并发标记阶段中，程序的工作线程会和垃圾收集线程同时运行或者交叉运行，因此为了修正并发标记期间，因用户程序继续运作而导致标记产生变动的那一部分对象的标记记录，这个阶段的停顿时间通常会比初始标记阶段稍长一些，但也远比并发标记阶段的时间短。</p></li><li><p><strong>并发清除</strong>（Concurrent-Sweep）阶段：此阶段清理删除掉标记阶段判断的已经死亡的对象，释放内存空间。由于不需要移动存活对象，所以这个阶段也是可以与用户线程同时并发的</p></li></ul><p>尽管CMS收集器采用的是并发回收（非独占式），但是在其初始化标记和再次标记这两个阶段中仍然需要执行“Stop-the-World”机制暂停程序中的工作线程，不过暂停时间并不会太长，因此可以说明目前所有的垃圾收集器都做不到完全不需要“stop-the-World”，只是尽可能地缩短暂停时间。</p><p>由于最耗费时间的并发标记与并发清除阶段都不需要暂停工作，所以整体的回收是低停顿的。</p><p>另外，由于在垃圾收集阶段用户线程没有中断，所以在CMS回收过程中，还应该确保应用程序用户线程有足够的内存可用。因此，CMS收集器不能像其他收集器那样等到老年代几乎完全被填满了再进行收集，而是当堆内存使用率达到某一阈值时，便开始进行回收，以确保应用程序在CMS工作过程中依然有足够的空间支持应用程序运行。要是CMS运行期间预留的内存无法满足程序需要，就会出现一次“<code>Concurrent Mode Failure</code>” 失败，这时虚拟机将启动后备预案：临时启用Serial Old收集器来重新进行老年代的垃圾收集，这样停顿时间就很长了。</p><p><strong>CMS收集器的垃圾收集算法采用的是标记清除算法</strong>，这意味着每次执行完内存回收后，由于被执行内存回收的无用对象所占用的内存空间极有可能是不连续的一些内存块，不可避免地将会产生一些内存碎片。那么CMS在为新对象分配内存空间时，将无法使用指针碰撞（Bump the Pointer）技术，而<strong>只能够选择空闲列表（Free List）执行内存分配。</strong></p><p><img src="https://raw.githubusercontent.com/GeorgeChan95/blogimg/master/img/2024/07/11/20240711-160320.png" alt="CMS垃圾清理"></p><p><strong>有人会觉得既然Mark Sweep会造成内存碎片，那么为什么不把算法换成Mark Compact？</strong></p><p>答案其实很简单，因为当并发清除的时候，用Compact整理内存的话，原来的用户线程使用的内存还怎么用呢？要保证用户线程能继续执行，前提的它运行的资源不受影响嘛。Mark Compact更适合“Stop the World” 这种场景下使用</p><h2 id="2-CMS的优点"><a href="#2-CMS的优点" class="headerlink" title="2. CMS的优点"></a>2. CMS的优点</h2><ul><li><p>并发收集</p></li><li><p>低延迟</p></li></ul><h2 id="3-CMS的弊端"><a href="#3-CMS的弊端" class="headerlink" title="3. CMS的弊端"></a>3. CMS的弊端</h2><ul><li><p>会产生内存碎片，导致并发清除后，用户线程可用的空间不足。在无法分配大对象的情况下，不得不提前触发FullGC。</p></li><li><p>CMS收集器对CPU资源非常敏感。在并发阶段，它虽然不会导致用户停顿，但是会因为占用了一部分线程而导致应用程序变慢，总吞吐量会降低。</p></li><li><p>CMS收集器无法处理浮动垃圾。可能出现“<code>Concurrent Mode Failure</code>“失败而导致另一次Full GC的产生。在并发标记阶段由于程序的工作线程和垃圾收集线程是同时运行或者交叉运行的，那么在并发标记阶段如果产生新的垃圾对象，CMS将无法对这些垃圾对象进行标记，最终会导致这些新产生的垃圾对象没有被及时回收，从而只能在下一次执行GC时释放这些之前未被回收的内存空间。</p></li></ul><h3 id=""><a href="#" class="headerlink" title=""></a></h3><h2 id="4-参数设置"><a href="#4-参数设置" class="headerlink" title="4. 参数设置"></a>4. 参数设置</h2><ul><li><p><code>-XX:+UseConcMarkSweepGC</code> 手动指定使用CMS收集器执行内存回收任务。<br>开启该参数后会自动将<code>-xx:+UseParNewGC</code>打开。即：ParNew（Young区用）+CMS（Old区用）+ Serial Old的组合。 </p></li><li><p><code>-XX:CMSInitiatingOccupanyFraction</code> 设置堆内存使用率的阈值，一旦达到该阈值，便开始进行回收。 </p></li><li><ul><li>JDK5及以前版本的默认值为68，即当老年代的空间使用率达到68%时，会执行一次CMS回收。JDK6及以上版本默认值为92%</li></ul></li><li><ul><li>如果内存增长缓慢，则可以设置一个稍大的值，大的阀值可以有效降低CMS的触发频率，减少老年代回收的次数可以较为明显地改善应用程序性能。反之，如果应用程序内存使用率增长很快，则应该降低这个阈值，以避免频繁触发老年代串行收集器。因此通过该选项便可以有效降低Ful1Gc的执行次数。</li></ul></li><li><p><code>-XX:+UseCMSCompactAtFullCollection</code> 用于指定在执行完Full GC后对内存空间进行压缩整理，以此避免内存碎片的产生。不过由于内存压缩整理过程无法并发执行，所带来的问题就是停顿时间变得更长了。 </p></li><li><p><code>-XX:CMSFullGCsBeforeCompaction</code> 设置在执行多少次Full GC后对内存空间进行压缩整理。 </p></li><li><p><code>-XX:ParallelCMSThreads=&lt;number&gt;</code> 设置CMS的线程数量。 </p></li><li><ul><li>CMS默认启动的线程数是（ParallelGCThreads+3）&#x2F;4，ParallelGCThreads是年轻代并行收集器的线程数。当CPU资源比较紧张时，受到CMS收集器线程的影响，应用程序的性能在垃圾回收阶段可能会非常糟糕。</li></ul></li></ul><h2 id="5-总结"><a href="#5-总结" class="headerlink" title="5. 总结"></a>5. 总结</h2><p>Serial GC、Parallel GC、Concurrent Mark Sweep GC这三个Gc有什么不同？</p><ul><li><p>如果你想要最小化地使用内存和并行开销，请选Serial GC；</p></li><li><p>如果你想要最大化应用程序的吞吐量，请选Parallel GC；</p></li><li><p>如果你想要最小化GC的中断或停顿时间，请选CMS GC。</p></li></ul><h2 id="6-JDK后续版本中CMS的变化"><a href="#6-JDK后续版本中CMS的变化" class="headerlink" title="6. JDK后续版本中CMS的变化"></a>6. JDK后续版本中CMS的变化</h2><p>JDK9新特性：CMS被标记为Deprecate了（JEP291）</p><ul><li>如果对JDK9及以上版本的HotSpot虚拟机使用参数<code>-XX: +UseConcMarkSweepGC</code>来开启CMS收集器的话，用户会收到一个警告信息，提示CMS未来将会被废弃。</li></ul><p>JDK14新特性：删除CMS垃圾回收器（JEP363）</p><ul><li>移除了CMS垃圾收集器，如果在JDK14中使用 <code>-XX:+UseConcMarkSweepGC</code>的话，JVM不会报错，只是给出一个warning信息，但是不会exit。JVM会自动回退以默认GC方式启动JVM</li></ul><h1 id="七、G1回收器-区域化分代式"><a href="#七、G1回收器-区域化分代式" class="headerlink" title="七、G1回收器:区域化分代式"></a>七、G1回收器:区域化分代式</h1><h2 id="1-概述"><a href="#1-概述" class="headerlink" title="1. 概述"></a>1. 概述</h2><p><strong>既然我们已经有了前面几个强大的GC，为什么还要发布Garbage First（G1）？</strong></p><ul><li><p>原因就在于应用程序所应对的业务越来越庞大、复杂，用户越来越多，没有GC就不能保证应用程序正常进行，而经常造成STW的GC又跟不上实际的需求，所以才会不断地尝试对GC进行优化。G1（Garbage-First）垃圾回收器是在Java7 update4之后引入的一个新的垃圾回收器，是当今收集器技术发展的最前沿成果之一。</p></li><li><p>与此同时，为了适应现在不断扩大的内存和不断增加的处理器数量，进一步降低暂停时间（pause time），同时兼顾良好的吞吐量。官方给G1设定的目标是<strong>在延迟可控的情况下获得尽可能高的吞吐量</strong>，所以才担当起“<strong>全功能收集器</strong>”的重任与期望。</p></li></ul><p><strong>为什么名字叫 Garbage First(G1)呢？</strong></p><ul><li>因为G1是一个并行回收器，它把堆内存分割为很多不相关的区域（Region）（物理上不连续的）。使用不同的Region来表示Eden、幸存者0区，幸存者1区，老年代等。</li><li>G1 GC有计划地避免在整个Java堆中进行全区域的垃圾收集。G1跟踪各个Region里面的垃圾堆积的价值大小（回收所获得的空间大小以及回收所需时间的经验值），在后台维护一个优先列表，每次根据允许的收集时间，优先回收价值最大的Region。</li><li>由于这种方式的侧重点在于回收垃圾最大量的区间（Region），所以我们给G1一个名字：<strong>垃圾优先（Garbage First）</strong>。</li><li>G1（Garbage-First）是一款面向服务端应用的垃圾收集器，主要针对配备多核CPU及大容量内存的机器，以极高概率满足GC停顿时间的同时，还兼具高吞吐量的性能特征。</li><li>在JDK1.7版本正式启用，移除了Experimenta1的标识，是JDK9以后的默认垃圾回收器，取代了CMS回收器以及Parallel+Parallel Old组合。被Oracle官方称为“全功能的垃圾收集器”。</li><li>与此同时，CMS已经在JDK9中被标记为废弃（deprecated）。在jdk8中还不是默认的垃圾回收器，需要使用<code>-XX:+UseG1GC</code>来启用。</li></ul><h2 id="2-G1回收器的特点（优势）"><a href="#2-G1回收器的特点（优势）" class="headerlink" title="2. G1回收器的特点（优势）"></a>2. G1回收器的特点（优势）</h2><p>与其他GC收集器相比，G1使用了全新的分区算法，其特点如下所示：</p><h3 id="2-1-并行与并发"><a href="#2-1-并行与并发" class="headerlink" title="2.1 并行与并发"></a>2.1 并行与并发</h3><ul><li><p>并行性：G1在回收期间，可以有多个GC线程同时工作，有效利用多核计算能力。此时用户线程STW</p></li><li><p>并发性：G1拥有与应用程序交替执行的能力，部分工作可以和应用程序同时执行，因此，一般来说，不会在整个回收阶段发生完全阻塞应用程序的情况</p></li></ul><h3 id="2-2-分代收集"><a href="#2-2-分代收集" class="headerlink" title="2.2 分代收集"></a>2.2 分代收集</h3><ul><li><p>从分代上看，G1依然属于分代型垃圾回收器，它会区分年轻代和老年代，年轻代依然有Eden区和Survivor区。但从堆的结构上看，它不要求整个Eden区、年轻代或者老年代都是连续的，也不再坚持固定大小和固定数量。</p></li><li><p>将堆空间分为若干个区域（Region），这些区域中包含了逻辑上的年轻代和老年代。</p></li><li><p>和之前的各类回收器不同，它同时兼顾年轻代和老年代。对比其他回收器，要么只能工作在年轻代，要么只能工作在老年代；</p></li></ul><p><img src="https://raw.githubusercontent.com/GeorgeChan95/blogimg/master/img/2024/07/12/20240712-160058.png" alt="G1内存划分"></p><h3 id="2-3-空间整合"><a href="#2-3-空间整合" class="headerlink" title="2.3 空间整合"></a>2.3 空间整合</h3><ul><li><p>CMS：“标记-清除”算法、内存碎片、若干次GC后进行一次碎片整理</p></li><li><p>G1将内存划分为一个个的region。内存的回收是以region作为基本单位的。Region之间是复制算法，但整体上实际可看作是标记-压缩（Mark-Compact）算法，两种算法都可以避免内存碎片。这种特性有利于程序长时间运行，分配大对象时不会因为无法找到连续内存空间而提前触发下一次GC。尤其是当Java堆非常大的时候，G1的优势更加明显。</p></li></ul><h3 id="2-4-可预测的停顿时间模型（即：软实时soft-real-time）"><a href="#2-4-可预测的停顿时间模型（即：软实时soft-real-time）" class="headerlink" title="2.4 可预测的停顿时间模型（即：软实时soft real-time）"></a>2.4 可预测的停顿时间模型（即：软实时soft real-time）</h3><p>这是G1相对于CMS的另一大优势，G1除了追求低停顿外，还能建立可预测的停顿时间模型，能让使用者明确指定在一个长度为M毫秒的时间片段内，消耗在垃圾收集上的时间不得超过N毫秒。</p><ul><li><p>由于分区的原因，G1可以只选取部分区域进行内存回收，这样缩小了回收的范围，因此对于全局停顿情况的发生也能得到较好的控制。</p></li><li><p>G1跟踪各个Region里面的垃圾堆积的价值大小（回收所获得的空间大小以及回收所需时间的经验值），在后台维护一个优先列表，每次根据允许的收集时间，优先回收价值最大的Region。保证了G1收集器在有限的时间内可以获取尽可能高的收集效率。</p></li><li><p>相比于CMS，G1未必能做到CMS在最好情况下的延时停顿，但是最差情况要好很多。</p></li></ul><h2 id="3-G1垃圾收集器的缺点"><a href="#3-G1垃圾收集器的缺点" class="headerlink" title="3. G1垃圾收集器的缺点"></a>3. G1垃圾收集器的缺点</h2><p>相较于CMS，G1还不具备全方位、压倒性优势。比如在用户程序运行过程中，G1无论是为了垃圾收集产生的内存占用（Footprint）还是程序运行时的额外执行负载（Overload）都要比CMS要高。</p><p>从经验上来说，在小内存应用上CMS的表现大概率会优于G1，而G1在大内存应用上则发挥其优势。平衡点在6-8GB之间。</p><h2 id="4-G1回收器的参数设置"><a href="#4-G1回收器的参数设置" class="headerlink" title="4. G1回收器的参数设置"></a>4. G1回收器的参数设置</h2><ul><li><p><code>-XX:+UseG1GC</code>：手动指定使用G1垃圾收集器执行内存回收任务</p></li><li><p><code>-XX:G1HeapRegionSize</code> 设置每个Region的大小。值是2的幂，范围是1MB到32MB之间，目标是根据最小的Java堆大小划分出约2048个区域。默认是堆内存的1&#x2F;2000。</p></li><li><p><code>-XX:MaxGCPauseMillis</code> 设置期望达到的最大GC停顿时间指标（JVM会尽力实现，但不保证达到）。默认值是200ms（人的平均反应速度）</p></li><li><p><code>-XX:+ParallelGCThreads</code> 设置STW工作线程数的值。最多设置为8（上面说过Parallel回收器的线程计算公式，当CPU_Count &gt; 8时，ParallelGCThreads 也会大于8）</p></li><li><p><code>-XX:ConcGCThreads</code> 设置并发标记的线程数。将n设置为并行垃圾回收线程数（ParallelGCThreads）的1&#x2F;4左右。</p></li><li><p><code>-XX:InitiatingHeapOccupancyPercent</code> 设置触发并发GC周期的Java堆占用率阈值。超过此值，就触发GC。默认值是45。</p></li></ul><h2 id="5-G1收集器的常见操作步骤"><a href="#5-G1收集器的常见操作步骤" class="headerlink" title="5. G1收集器的常见操作步骤"></a>5. G1收集器的常见操作步骤</h2><p>G1的设计原则就是简化JVM性能调优，开发人员只需要简单的三步即可完成调优：</p><ul><li><p>第一步：开启G1垃圾收集器</p></li><li><p>第二步：设置堆的最大内存</p></li><li><p>第三步：设置最大的停顿时间</p></li></ul><p>G1中提供了三种垃圾回收模式：<strong>Young GC</strong>、<strong>Mixed GC</strong> 和 <strong>Full GC</strong>，在不同的条件下被触发。</p><h2 id="6-G1收集器的适用场景"><a href="#6-G1收集器的适用场景" class="headerlink" title="6. G1收集器的适用场景"></a>6. G1收集器的适用场景</h2><p><strong>面向服务端应用，针对具有大内存、多处理器的机器。</strong>（在普通大小的堆里表现并不惊喜）</p><p>最主要的<strong>应用是需要低GC延迟</strong>，并具有大堆的应用程序提供解决方案；如：在堆大小约6GB或更大时，可预测的暂停时间可以低于0.5秒；（G1通过每次只清理一部分而不是全部的Region的增量式清理来保证每次GC停顿时间不会过长）。</p><p>用来替换掉JDK1.5中的CMS收集器；在下面的情况时，使用G1可能比CMS好：</p><ul><li><p>超过50%的Java堆被活动数据占用；</p></li><li><p>对象分配频率或年代提升频率变化很大；</p></li><li><p>GC停顿时间过长（长于0.5至1秒）</p></li></ul><p>HotSpot垃圾收集器里，除了G1以外，其他的垃圾收集器使用内置的 JVM 线程执行GC的多线程操作，而G1 GC可以采用应用线程承担后台运行的 GC 工作，即当JVM 的 GC 线程处理速度慢时，系统会调用应用程序线程帮助加速垃圾回收过程。</p><h2 id="7-分区Region：化整为零"><a href="#7-分区Region：化整为零" class="headerlink" title="7. 分区Region：化整为零"></a>7. 分区Region：化整为零</h2><p>使用G1收集器时，它将整个Java堆划分成约2048个大小相同的独立Region块，每个Region块大小根据堆空间的实际大小而定，整体被控制在1MB到32MB之间，且为2的N次幂，即1MB，2MB，4MB，8MB，16MB，32MB。可以通过 <strong><code>-XX:G1HeapRegionSize</code></strong> 设定。所有的Region大小相同，且在JVM生命周期内不会被改变。</p><p>虽然还保留有新生代和老年代的概念，但新生代和老年代不再是物理隔离的了，它们都是一部分Region（不需要连续）的集合。通过Region的动态分配方式实现逻辑上的连续。</p><p><img src="https://raw.githubusercontent.com/GeorgeChan95/blogimg/master/img/2024/07/12/20240712-162935.png" alt="G1 Region"></p><p>一个region有可能属于Eden，Survivor或者Old&#x2F;Tenured内存区域。但是一个region只可能属于一个角色。图中的E表示该region属于Eden内存区域，S表示属于survivor内存区域，O表示属于Old内存区域。图中空白的表示未使用的内存空间。</p><p>G1垃圾收集器还增加了一种新的内存区域，叫做 <strong>Humongous</strong> 内存区域，如图中的H块。主要用于存储大对象，如果超过1.5个region，就放到H。</p><p><strong>设置H的原因：</strong>对于堆中的对象，默认直接会被分配到老年代，但是如果它是一个短期存在的大对象就会对垃圾收集器造成负面影响。为了解决这个问题，G1划分了一个Humongous区，它用来专门存放大对象。如果一个H区装不下一个大对象，那么G1会寻找连续的H区来存储。为了能找到连续的H区，有时候不得不启动Full GC。G1的大多数行为都把H区作为老年代的一部分来看待。</p><p><strong>每个Region都是通过指针碰撞来分配空间</strong></p><p><img src="https://raw.githubusercontent.com/GeorgeChan95/blogimg/master/img/2024/07/12/20240712-163408.png" alt="region分配方式"></p><h2 id="8-G1垃圾回收器的回收过程"><a href="#8-G1垃圾回收器的回收过程" class="headerlink" title="8. G1垃圾回收器的回收过程"></a>8. G1垃圾回收器的回收过程</h2><p>G1GC的垃圾回收过程主要包括如下三个环节：</p><ul><li><p>年轻代GC（Young GC） </p></li><li><p>老年代并发标记过程（Concurrent Marking） </p></li><li><p>混合回收（Mixed GC）<br>  （如果需要，单线程、独占式、高强度的Full GC还是继续存在的。它针对GC的评估失败提供了一种失败保护机制，即强力回收。）</p></li></ul><p><img src="https://raw.githubusercontent.com/GeorgeChan95/blogimg/master/img/2024/07/12/20240712-163649.png" alt="G1垃圾回收器的回收过程"></p><p>顺时针，Young gc -&gt; Young gc + Concurrent mark-&gt;Mixed GC顺序，进行垃圾回收。</p><p>应用程序分配内存，当年轻代的Eden区用尽时开始年轻代回收过程；<strong>G1的年轻代收集阶段是一个并行的独占式收集器。</strong>在年轻代回收期，G1GC暂停所有应用程序线程，启动多线程执行年轻代回收。然后从年轻代区间移动存活对象到Survivor区间或者老年区间，也有可能是两个区间都会涉及。</p><p><strong>当堆内存使用达到一定值（默认45%）时，开始老年代并发标记过程。</strong></p><p>标记完成马上开始混合回收过程。对于一个混合回收期，G1 GC从老年区间移动存活对象到空闲区间，这些空闲区间也就成为了老年代的一部分。和年轻代不同，老年代的G1回收器和其他GC不同，G1的老年代回收器不需要整个老年代被回收，一次只需要扫描&#x2F;回收一小部分老年代的Region就可以了。同时，这个老年代Region是和年轻代一起被回收的。</p><p>举个例子：一个Web服务器，Java进程最大堆内存为4G，每分钟响应1500个请求，每45秒钟会新分配大约2G的内存。G1会每45秒钟进行一次年轻代回收，每31个小时整个堆的使用率会达到45%，会开始老年代并发标记过程，标记完成后开始四到五次的混合回收。</p><h2 id="9-Remembered-Set"><a href="#9-Remembered-Set" class="headerlink" title="9. Remembered Set"></a>9. Remembered Set</h2><ul><li><p>一个对象被不同区域引用的问题 </p></li><li><p>一个Region不可能是孤立的，一个Region中的对象可能被其他任意Region中对象引用，判断对象存活时，是否需要扫描整个Java堆才能保证准确？ </p></li><li><p>在其他的分代收集器，也存在这样的问题（而G1更突出）回收新生代也不得不同时扫描老年代？ </p></li><li><p>这样的话会降低MinorGC的效率；</p></li></ul><p><strong>解决方法：</strong></p><ul><li><p>无论G1还是其他分代收集器，JVM都是使用Remembered Set来避免全局扫描, </p></li><li><p>每个Region都有一个对应的Remembered Set；</p></li><li><p>每次Reference类型数据写操作时，都会产生一个Write Barrier暂时中断操作；</p></li><li><p>然后检查将要写入的引用指向的对象是否和该Reference类型数据在不同的Region（其他收集器：检查老年代对象是否引用了新生代对象）；</p></li><li><p>如果不同，通过CardTable把相关引用信息记录到引用指向对象的所在Region对应的Remembered Set中；</p></li><li><p>当进行垃圾收集时，在GC根节点的枚举范围加入Remembered Set；就可以保证不进行全局扫描，也不会有遗漏。</p></li></ul><p><img src="https://raw.githubusercontent.com/GeorgeChan95/blogimg/master/img/2024/07/12/20240712-165200.png" alt="记忆集"></p><h2 id="10-G1回收过程"><a href="#10-G1回收过程" class="headerlink" title="10. G1回收过程"></a>10. G1回收过程</h2><h3 id="10-1-回收过程一-年轻代GC"><a href="#10-1-回收过程一-年轻代GC" class="headerlink" title="10.1 回收过程一: 年轻代GC"></a>10.1 回收过程一: 年轻代GC</h3><p>JVM启动时，G1先准备好Eden区，程序在运行过程中不断创建对象到Eden区，当Eden空间耗尽时，G1会启动一次年轻代垃圾回收过程。</p><p>年轻代垃圾回收只会回收Eden区和Survivor区。</p><p>首先G1停止应用程序的执行（Stop-The-World），G1创建回收集（Collection Set），回收集是指需要被回收的内存分段的集合，年轻代回收过程的回收集包含年轻代Eden区和Survivor区所有的内存分段。</p><p><img src="https://raw.githubusercontent.com/GeorgeChan95/blogimg/master/img/2024/07/12/20240712-170726.png" alt="G1年轻代垃圾收集"></p><p>然后开始如下回收过程：</p><ol><li><strong>第一阶段，扫描根。</strong>根是指static变量指向的对象，正在执行的方法调用链条上的局部变量等。根引用连同RSet记录的外部引用作为扫描存活对象的入口。</li><li><strong>第二阶段，更新RSet</strong>。处理dirty card queue（见备注）中的card，更新RSet。此阶段完成后，RSet可以准确的反映老年代对所在的内存分段中对象的引用。</li><li><strong>第三阶段，处理RSet</strong>。识别被老年代对象指向的Eden中的对象，这些被指向的Eden中的对象被认为是存活的对象。</li><li><strong>第四阶段，复制对象</strong>。此阶段，对象树被遍历，Eden区内存段中存活的对象会被复制到Survivor区中空的内存分段，Survivor区内存段中存活的对象如果年龄未达阈值，年龄会加1，达到阀值会被会被复制到Old区中空的内存分段。如果Survivor空间不够，Eden空间的部分数据会直接晋升到老年代空间。</li><li><strong>第五阶段，处理引用</strong>。处理Soft，Weak，Phantom，Final，JNI Weak 等引用。最终Eden空间的数据为空，GC停止工作，而目标内存中的对象都是连续存储的，没有碎片，所以复制过程可以达到内存整理的效果，减少碎片。</li></ol><h3 id="10-2-回收过程二-并发标记过程"><a href="#10-2-回收过程二-并发标记过程" class="headerlink" title="10.2 回收过程二: 并发标记过程"></a>10.2 回收过程二: 并发标记过程</h3><ol><li><strong>初始标记</strong>阶段：标记从根节点直接可达的对象。这个阶段是STW的，并且会触发一次年轻代GC。</li><li><strong>根区域扫描</strong>（Root Region Scanning）：G1 GC扫描Survivor区直接可达的老年代区域对象，并标记被引用的对象。这一过程必须在YoungGC之前完成。</li><li><strong>并发标记</strong>（Concurrent Marking）：在整个堆中进行并发标记（和应用程序并发执行），此过程可能被YoungGC中断。在并发标记阶段，若发现区域对象中的所有对象都是垃圾，那这个区域会被立即回收。同时，并发标记过程中，会计算每个区域的对象活性（区域中存活对象的比例）。</li><li><strong>再次标记</strong>（Remark）：由于应用程序持续进行，需要修正上一次的标记结果。是STW的。<strong>G1中采用了比CMS更快的初始快照算法：snapshot-at-the-beginning（SATB）。</strong></li><li><strong>独占清理</strong>（cleanup，STW）：计算各个区域的存活对象和GC回收比例，并进行排序，识别可以混合回收的区域。为下阶段做铺垫。是STW的。这个阶段并不会实际上去做垃圾的收集</li><li><strong>并发清理阶段</strong>：识别并清理完全空闲的区域。</li></ol><h3 id="10-3-G1回收过程三-混合回收"><a href="#10-3-G1回收过程三-混合回收" class="headerlink" title="10.3 G1回收过程三: 混合回收"></a>10.3 G1回收过程三: 混合回收</h3><p>当越来越多的对象晋升到老年代old region时，为了避免堆内存被耗尽，虚拟机会触发一个混合的垃圾收集器，即Mixed GC，该算法并不是一个Old GC，除了回收整个Young Region，还会回收一部分的Old Region。这里需要注意：是一部分老年代，而不是全部老年代。可以选择哪些Old Region进行收集，从而可以对垃圾回收的耗时时间进行控制。也要注意的是Mixed GC并不是Full GC。</p><p><img src="https://raw.githubusercontent.com/GeorgeChan95/blogimg/master/img/2024/07/12/20240712-175608.png" alt="混合回收"></p><p>并发标记结束以后，老年代中百分百为垃圾的内存分段被回收了，部分为垃圾的内存分段被计算了出来。默认情况下，这些老年代的内存分段会分8次（可以通过 <code>-XX:G1MixedGCCountTarget</code> 设置）被回收.</p><p>混合回收的回收集（Collection Set）包括八分之一的老年代内存分段，Eden区内存分段，Survivor区内存分段。混合回收的算法和年轻代回收的算法完全一样，只是回收集多了老年代的内存分段。具体过程请参考上面的年轻代回收过程。</p><p>由于老年代中的内存分段默认分8次回收，G1会优先回收垃圾多的内存分段。垃圾占内存分段比例越高的，越会被先回收。并且有一个阈值会决定内存分段是否被回收，<code>-XX:G1MixedGCLiveThresholdPercent</code>，默认为65%，意思是垃圾占内存分段比例要达到65%才会被回收。如果垃圾占比太低，意味着存活的对象占比高，在复制的时候会花费更多的时间。</p><p>混合回收并不一定要进行8次。有一个阈值<code>-XX:G1HeapWastePercent</code>，默认值为10%，意思是允许整个堆内存中有10%的空间被浪费，意味着如果发现可以回收的垃圾占堆内存的比例低于10%，则不再进行混合回收。因为GC会花费很多的时间但是回收到的内存却很少。</p><h3 id="10-4-G1回收可选的过程四：Full-GC"><a href="#10-4-G1回收可选的过程四：Full-GC" class="headerlink" title="10.4 G1回收可选的过程四：Full GC"></a>10.4 G1回收可选的过程四：Full GC</h3><p>G1的初衷就是要避免Full GC的出现。但是如果上述方式不能正常工作，G1会停止应用程序的执行（Stop-The-World），使用单线程的内存回收算法进行垃圾回收，性能会非常差，应用程序停顿时间会很长。</p><p>要避免Full GC的发生，一旦发生需要进行调整。什么时候会发生Full GC呢？比如堆内存太小，当G1在复制存活对象的时候没有空的内存分段可用，则会回退到Full GC，这种情况可以通过增大内存解决。</p><p>导致G1 Full GC的原因可能有两个：</p><ul><li><p>Evacuation的时候没有足够的to-space来存放晋升的对象；</p></li><li><p>并发处理过程完成之前空间耗尽。</p></li></ul><h2 id="10-5-补充"><a href="#10-5-补充" class="headerlink" title="10.5 补充"></a>10.5 补充</h2><p>从Oracle官方透露出来的信息可获知，回收阶段（Evacuation）其实本也有想过设计成与用户程序一起并发执行，但这件事情做起来比较复杂，考虑到G1只是回一部分Region，停顿时间是用户可控制的，所以并不迫切去实现，而选择把这个特性放到了G1之后出现的低延迟垃圾收集器（即ZGC）中。另外，还考虑到G1不是仅仅面向低延迟，停顿用户线程能够最大幅度提高垃圾收集效率，为了保证吞吐量所以才选择了完全暂停用户线程的实现方案。</p><h2 id="10-6-G1回收器优化建议"><a href="#10-6-G1回收器优化建议" class="headerlink" title="10.6 G1回收器优化建议"></a>10.6 G1回收器优化建议</h2><ul><li><p>年轻代</p><ul><li><p>避免使用<code>-Xmn</code>或<code>-XX:NewRatio</code>等相关选项显式设置年轻代大小</p></li><li><p>固定年轻代的大小会覆盖暂停时间目标</p></li></ul></li><li><p>暂停时间目标不要太过严苛</p><ul><li><p>G1 GC的吞吐量目标是90%的应用程序时间和10%的垃圾回收时间</p></li><li><p>评估G1 GC的吞吐量时，暂停时间目标不要太严苛。目标太过严苛表示你愿意承受更多的垃圾回收开销，而这些会直接影响到吞吐量。</p></li></ul></li></ul><h1 id="八、垃圾回收器总结"><a href="#八、垃圾回收器总结" class="headerlink" title="八、垃圾回收器总结"></a>八、垃圾回收器总结</h1><h2 id="1-7种经典垃圾回收器总结"><a href="#1-7种经典垃圾回收器总结" class="headerlink" title="1. 7种经典垃圾回收器总结"></a>1. 7种经典垃圾回收器总结</h2><p>截止JDK1.8，一共有7款不同的垃圾收集器。每一款的垃圾收集器都有不同的特点，在具体使用的时候，需要根据具体的情况选用不同的垃圾收集器。</p><table><thead><tr><th>垃圾收集器</th><th>分类</th><th>作用位置</th><th>使用算法</th><th>特点</th><th>适用场景</th></tr></thead><tbody><tr><td>Serial</td><td>串行运行</td><td>作用于新生代</td><td>复制算法</td><td>响应速度优先</td><td>适用于单CPU环境下的client模式</td></tr><tr><td>ParNew</td><td>并行运行</td><td>作用于新生代</td><td>复制算法</td><td>响应速度优先</td><td>多CPU环境Server模式下与CMS配合使用</td></tr><tr><td>Parallel</td><td>并行运行</td><td>作用于新生代</td><td>复制算法</td><td>吞吐量优先</td><td>适用于后台运算而不需要太多交互的场景</td></tr><tr><td>Serial Old</td><td>串行运行</td><td>作用于老年代</td><td>标记-压缩算法</td><td>响应速度优先</td><td>适用于单CPU环境下的Client模式</td></tr><tr><td>Parallel Old</td><td>并行运行</td><td>作用于老年代</td><td>标记-压缩算法</td><td>吞吐量优先</td><td>适用于后台运算而不需要太多交互的场景</td></tr><tr><td>CMS</td><td>并发运行</td><td>作用于老年代</td><td>标记-清除算法</td><td>响应速度优先</td><td>适用于互联网或B／S业务</td></tr><tr><td>G1</td><td>并发、并行运行</td><td>作用于新生代、老年代</td><td>标记-压缩算法、复制算法</td><td>响应速度优先</td><td>面向服务端应用</td></tr></tbody></table><p>GC发展阶段：Serial &#x3D;&gt; Parallel（并行）&#x3D;&gt; CMS（并发）&#x3D;&gt; G1 &#x3D;&gt; ZGC</p><h2 id="2-垃圾回收器组合"><a href="#2-垃圾回收器组合" class="headerlink" title="2. 垃圾回收器组合"></a>2. 垃圾回收器组合</h2><p>不同厂商、不同版本的虚拟机实现差距比较大。HotSpot虚拟机在JDK7&#x2F;8后所有收集器及组合如下图</p><p><img src="https://raw.githubusercontent.com/GeorgeChan95/blogimg/master/img/2024/07/12/20240712-181450.png" alt="垃圾回收器组合"></p><ul><li>两个收集器间有连线，表明它们可以搭配使用：Serial&#x2F;Serial Old、Serial&#x2F;CMS、ParNew&#x2F;Serial Old、ParNew&#x2F;CMS、Parallel Scavenge&#x2F;Serial Old、Parallel Scavenge&#x2F;Parallel Old、G1; </li><li>其中Serial Old作为CMS出现＂<code>Concurrent Mode Failure</code>＂失败的后备预案。 </li><li>（红色虚线）由于维护和兼容性测试的成本，在JDK 8时将Serial＋CMS、ParNew＋Serial old这两个组合声明为Deprecated（JEP 173），并在JDK 9中完全取消了这些组合的支持（JEP214），即：移除。</li><li>（绿色虚线）JDK 14中：弃用ParallelScavenge和SeriaOold GC组合(JEP 366) </li><li>（绿色虚框）JDK 14中：删除CMS垃圾回收器（JEP 363）</li></ul><h2 id="3-怎么选择垃圾回收器"><a href="#3-怎么选择垃圾回收器" class="headerlink" title="3. 怎么选择垃圾回收器"></a>3. 怎么选择垃圾回收器</h2><p>Java垃圾收集器的配置对于JVM优化来说是一个很重要的选择，选择合适的垃圾收集器可以让JVM的性能有一个很大的提升。</p><p>怎么选择垃圾收集器？</p><ul><li>优先调整堆的大小让JVM自适应完成。 </li><li>如果内存小于100M，使用串行收集器 </li><li>如果是单核、单机程序，并且没有停顿时间的要求，串行收集器 </li><li>如果是多CPU、需要高吞吐量、允许停顿时间超过1秒，选择并行或者JVM自己选择 </li><li>如果是多CPU、追求低停顿时间，需快速响应（比如延迟不能超过1秒，如互联网应用），使用并发收集器<br>官方推荐G1，性能高。现在互联网的项目，基本都是使用G1。</li></ul><p>最后需要明确一个观点：</p><ul><li>没有最好的收集器，更没有万能的收集</li><li>调优永远是针对特定场景、特定需求，不存在一劳永逸的收集器</li></ul>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;一、GC分类与性能指标&quot;&gt;&lt;a href=&quot;#一、GC分类与性能指标&quot; class=&quot;headerlink&quot; title=&quot;一、GC分类与性能指标&quot;&gt;&lt;/a&gt;一、GC分类与性能指标&lt;/h1&gt;&lt;h2 id=&quot;1-垃圾回收器概述&quot;&gt;&lt;a href=&quot;#1-垃圾回收器概</summary>
      
    
    
    
    <category term="JVM" scheme="https://georgechan95.github.io/categories/JVM/"/>
    
    
    <category term="java" scheme="https://georgechan95.github.io/tags/java/"/>
    
    <category term="jvm" scheme="https://georgechan95.github.io/tags/jvm/"/>
    
  </entry>
  
  <entry>
    <title>合并两个有序链表</title>
    <link href="https://georgechan95.github.io/blog/484946532.html"/>
    <id>https://georgechan95.github.io/blog/484946532.html</id>
    <published>2024-07-06T01:11:00.000Z</published>
    <updated>2024-08-28T04:17:33.334Z</updated>
    
    <content type="html"><![CDATA[<h1 id="1-题目描述"><a href="#1-题目描述" class="headerlink" title="1. 题目描述"></a>1. 题目描述</h1><p>将两个升序链表合并为一个新的 <strong>升序</strong> 链表并返回。新链表是通过拼接给定的两个链表的所有节点组成的。 </p><p><strong>示例 1：</strong></p><p><img src="https://raw.githubusercontent.com/GeorgeChan95/blogimg/master/img/2024/07/06/20240706-125245.jpg" alt="img"></p><blockquote><p><strong>输入：</strong>l1 &#x3D; [1,2,4], l2 &#x3D; [1,3,4]<br><strong>输出：</strong>[1,1,2,3,4,4]</p></blockquote><p><strong>示例 2：</strong></p><blockquote><p><strong>输入：</strong>l1 &#x3D; [], l2 &#x3D; []<br><strong>输出：</strong>[]</p></blockquote><p><strong>示例 3：</strong></p><blockquote><p><strong>输入：</strong>l1 &#x3D; [], l2 &#x3D; [0]<br><strong>输出：</strong>[0]</p></blockquote><h1 id="2-解决思路"><a href="#2-解决思路" class="headerlink" title="2. 解决思路"></a>2. 解决思路</h1><p>可以使用迭代方法来实现有序链表的合并.</p><p>假设有两个有序链表 list1和list2, 当这两个链表都不是空链表时,选择头节点中较小的一个作为合并链表的头节点,.</p><p>移动有序链表的指针,比较list1和list2最新的头节点, 添加到合并链表中.</p><h1 id="3-关键代码"><a href="#3-关键代码" class="headerlink" title="3. 关键代码"></a>3. 关键代码</h1><pre><code class="highlight java"><span class="comment">/**</span><span class="comment"> * 合并两个有序列表</span><span class="comment"> *</span><span class="comment"> * <span class="doctag">@param</span> list1 有序链表1, 顺序: 由小到大</span><span class="comment"> * <span class="doctag">@param</span> list2 有序链表2, 顺序: 由小到大</span><span class="comment"> * <span class="doctag">@return</span> ListNode 合并后的有序链表</span><span class="comment"> */</span><span class="keyword">public</span> <span class="keyword">static</span> ListNode <span class="title function_">merge</span><span class="params">(ListNode list1, ListNode list2)</span> &#123;    <span class="comment">// 极值判断</span>    <span class="keyword">if</span> (list1 == <span class="literal">null</span> || list2 == <span class="literal">null</span>) &#123;        <span class="keyword">return</span> list1 == <span class="literal">null</span> ? list2 : list1;    &#125;    <span class="type">ListNode</span> <span class="variable">cur1</span> <span class="operator">=</span> list1; <span class="comment">// list1中当前正在比较的头节点</span>    <span class="type">ListNode</span> <span class="variable">cur2</span> <span class="operator">=</span> list2; <span class="comment">// list2中当前正在比较的头节点</span>    <span class="type">ListNode</span> <span class="variable">head</span> <span class="operator">=</span> <span class="literal">null</span>; <span class="comment">// 已完成合并操作的链表(默认头节点是两个有序链表头节点中较小的一个)</span>    <span class="keyword">if</span> (cur1.val &lt;= cur2.val) &#123;        head = cur1;        cur1 = cur1.next; <span class="comment">// 更新cur1的头节点</span>    &#125; <span class="keyword">else</span> &#123;        head = cur2;        cur2 = cur2.next; <span class="comment">// 更新cur2的头节点</span>    &#125;    <span class="type">ListNode</span> <span class="variable">pre</span> <span class="operator">=</span> head; <span class="comment">// 临时节点,开始指向head, 后面通过pre不断调整head节点的next属性的引用</span>    <span class="keyword">while</span> (cur1 != <span class="literal">null</span> &amp;&amp; cur2 != <span class="literal">null</span>) &#123; <span class="comment">// 仅当两个队列当前操作的节点都不为空时,才需要进行比较与合并操作</span>        <span class="keyword">if</span> (cur1.val &lt;= cur2.val) &#123;            pre.next = cur1; <span class="comment">// 当cur1的值小于cur2时,next指向cur1</span>            cur1 = cur1.next; <span class="comment">// cur1节点后移,继续后面节点的比较</span>        &#125; <span class="keyword">else</span> &#123;            pre.next = cur2; <span class="comment">// 当cur2的值小于cur1时,将cur2作为待合并的节点</span>            cur2 = cur2.next; <span class="comment">// cur2节点后移,继续后面节点的比较</span>        &#125;        <span class="comment">// 这一行同时也不断调整了head节点的next属性,扩充了head链表</span>        pre = pre.next; <span class="comment">// 链表指针后移</span>    &#125;    <span class="comment">// 当其中一个链表(假设是cur1)的最后一个节点完成了合并操作,而另一个链表(假设是cur2)还有剩余节点未合并,</span>    <span class="comment">// 此时就需要将最后完成合并的节点(pre节点)的next指向还有节点未合并的链表(不为空的链表).</span>    <span class="comment">// 这一步是必须存在的,因为两个有序链表合并,必然会存在其中一个节点先完成合并.</span>    pre.next = cur1 != <span class="literal">null</span> ? cur1 : cur2;    <span class="comment">// 返回合并后,完整的有序链表</span>    <span class="keyword">return</span> head;&#125;</code></pre><p>完整测试代码:</p><p><a href="https://github.com/GeorgeChan95/algorithm/blob/master/src/main/java/com/george/mergeTwoList/MergeTwoList.java">https://github.com/GeorgeChan95/algorithm/blob/master/src/main/java/com/george/mergeTwoList/MergeTwoList.java</a></p><h1 id="4-复杂度分析"><a href="#4-复杂度分析" class="headerlink" title="4. 复杂度分析"></a>4. 复杂度分析</h1><ul><li><p>时间复杂度：O(n+m)，其中 n 和 m 分别为两个链表的长度。因为每次循环迭代中，l1 和 l2 只有一个元素会被放进合并链表中， 因此 while 循环的次数不会超过两个链表的长度之和。所有其他操作的时间复杂度都是常数级别的，因此总的时间复杂度为 O(n+m)。</p></li><li><p>空间复杂度：O(1)。我们只需要常数的空间存放若干变量。</p></li></ul>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;1-题目描述&quot;&gt;&lt;a href=&quot;#1-题目描述&quot; class=&quot;headerlink&quot; title=&quot;1. 题目描述&quot;&gt;&lt;/a&gt;1. 题目描述&lt;/h1&gt;&lt;p&gt;将两个升序链表合并为一个新的 &lt;strong&gt;升序&lt;/strong&gt; 链表并返回。新链表是通过拼接给定的</summary>
      
    
    
    
    <category term="算法" scheme="https://georgechan95.github.io/categories/%E7%AE%97%E6%B3%95/"/>
    
    
    <category term="算法" scheme="https://georgechan95.github.io/tags/%E7%AE%97%E6%B3%95/"/>
    
    <category term="合并有序链表" scheme="https://georgechan95.github.io/tags/%E5%90%88%E5%B9%B6%E6%9C%89%E5%BA%8F%E9%93%BE%E8%A1%A8/"/>
    
  </entry>
  
  <entry>
    <title>链表反转</title>
    <link href="https://georgechan95.github.io/blog/2929260443.html"/>
    <id>https://georgechan95.github.io/blog/2929260443.html</id>
    <published>2024-07-05T11:45:45.000Z</published>
    <updated>2024-08-28T04:17:33.333Z</updated>
    
    <content type="html"><![CDATA[<h1 id="1-单向链表反转"><a href="#1-单向链表反转" class="headerlink" title="1. 单向链表反转"></a>1. 单向链表反转</h1><h2 id="1-1-题目要求"><a href="#1-1-题目要求" class="headerlink" title="1.1 题目要求"></a>1.1 题目要求</h2><p>给你单链表的头节点 <code>head</code> ，请你反转链表，并返回反转后的链表。</p><p><strong>示例1:</strong></p><p><img src="https://raw.githubusercontent.com/GeorgeChan95/blogimg/master/img/2024/07/05/20240705-194718.jpg" alt="img"></p><blockquote><p><strong>输入：</strong>head &#x3D; [1,2,3,4,5]</p><p><strong>输出：</strong>[5,4,3,2,1]</p></blockquote><p><strong>示例2:</strong></p><p><img src="https://raw.githubusercontent.com/GeorgeChan95/blogimg/master/img/2024/07/05/20240705-195131.jpg" alt="img"></p><blockquote><p>输入：head &#x3D; [1,2]<br>输出：[2,1]</p></blockquote><p><strong>示例3:</strong></p><blockquote><p>输入：head &#x3D; []<br>输出：[]</p></blockquote><h2 id="1-2-思路分析"><a href="#1-2-思路分析" class="headerlink" title="1.2 思路分析"></a>1.2 思路分析</h2><p>假设链表为 1→2→3→∅，我们想要把它改成 ∅←1←2←3。</p><p>在遍历链表时，将当前节点的 next 指针改为指向前一个节点。由于节点没有引用其前一个节点，因此必须事先存储其前一个节点。在更改引用之前，还需要存储后一个节点。最后返回新的头引用。</p><h2 id="1-3-关键代码"><a href="#1-3-关键代码" class="headerlink" title="1.3 关键代码"></a>1.3 关键代码</h2><pre><code class="highlight java"><span class="comment">/**</span><span class="comment"> * 单向节点</span><span class="comment"> */</span><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">SinglyNode</span> &#123;    <span class="keyword">public</span> <span class="type">int</span> val;    <span class="comment">/**</span><span class="comment">     * 下一个节点</span><span class="comment">     */</span>    <span class="keyword">public</span> SinglyNode next;    <span class="keyword">public</span> <span class="title function_">SinglyNode</span><span class="params">(<span class="type">int</span> val)</span> &#123;        <span class="built_in">this</span>.val = val;    &#125;    <span class="keyword">public</span> <span class="title function_">SinglyNode</span><span class="params">(<span class="type">int</span> val, SinglyNode next)</span> &#123;        <span class="built_in">this</span>.val = val;        <span class="built_in">this</span>.next = next;    &#125;&#125;<span class="comment">/**</span><span class="comment"> * 单向链表反转</span><span class="comment"> * <span class="doctag">@param</span> head 头节点</span><span class="comment"> * <span class="doctag">@return</span></span><span class="comment"> */</span><span class="keyword">public</span> <span class="keyword">static</span> SinglyNode <span class="title function_">reverseSinglyList</span><span class="params">(SinglyNode head)</span> &#123;    <span class="type">SinglyNode</span> <span class="variable">pre</span> <span class="operator">=</span> <span class="literal">null</span>; <span class="comment">// 当前节点的前一个节点,默认是null</span>    <span class="type">SinglyNode</span> <span class="variable">next</span> <span class="operator">=</span> <span class="literal">null</span>; <span class="comment">// 当前节点的下一个节点,默认是null</span>    <span class="keyword">while</span> (head != <span class="literal">null</span>) &#123;        next = head.next; <span class="comment">// 获取当前节点的下一个节点</span>        head.next = pre; <span class="comment">// 当前节点的前一个节点变成当前的下一个节点(方向反转)</span>        pre = head; <span class="comment">// 当前节点赋值给pre,指针后移</span>        head = next; <span class="comment">// 指针移动到next节点,继续循环</span>    &#125;    <span class="keyword">return</span> pre; <span class="comment">// 最后头节点的引用</span>&#125;</code></pre><p>完整测试代码见: <a href="https://github.com/GeorgeChan95/algorithm/blob/master/src/main/java/com/george/reverseList/ReverseSingleList.java">https://github.com/GeorgeChan95/algorithm/blob/master/src/main/java/com/george/reverseList/ReverseSingleList.java</a></p><h1 id="2-双向链表反转"><a href="#2-双向链表反转" class="headerlink" title="2. 双向链表反转"></a>2. 双向链表反转</h1><h2 id="2-1-关键代码"><a href="#2-1-关键代码" class="headerlink" title="2.1 关键代码"></a>2.1 关键代码</h2><pre><code class="highlight java"><span class="comment">/**</span><span class="comment"> * 双向链表节点</span><span class="comment"> */</span><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">DoubleListNode</span> &#123;    <span class="keyword">public</span> <span class="type">int</span> value;    <span class="comment">/**</span><span class="comment">     * 前一个节点</span><span class="comment">     */</span>    <span class="keyword">public</span> DoubleListNode last;    <span class="comment">/**</span><span class="comment">     * 下一个节点</span><span class="comment">     */</span>    <span class="keyword">public</span> DoubleListNode next;    <span class="keyword">public</span> <span class="title function_">DoubleListNode</span><span class="params">(<span class="type">int</span> value)</span> &#123;        <span class="built_in">this</span>.value = value;    &#125;&#125;<span class="comment">/**</span><span class="comment"> * 双向链表反转</span><span class="comment"> * <span class="doctag">@param</span> head 头节点</span><span class="comment"> * <span class="doctag">@return</span></span><span class="comment"> */</span><span class="keyword">public</span> <span class="keyword">static</span> DoubleListNode <span class="title function_">reverseList</span><span class="params">(DoubleListNode head)</span> &#123;    <span class="type">DoubleListNode</span> <span class="variable">last</span> <span class="operator">=</span> <span class="literal">null</span>; <span class="comment">// 前一个节点</span>    <span class="type">DoubleListNode</span> <span class="variable">next</span> <span class="operator">=</span> <span class="literal">null</span>; <span class="comment">// 下一个节点</span>    <span class="keyword">while</span> (head != <span class="literal">null</span>) &#123;        next = head.next; <span class="comment">// 获取当前节点的下一个节点</span>        head.next = last; <span class="comment">// 前一个节点变成当前节点的下一个节点(链表方向反转)[原来头节点的last节点为空,反转后在链表末尾,next节点为空]</span>        head.last = next; <span class="comment">// 下一个节点变成当前节点的前一个节点(方向反转)[原链表末尾节next节点为空,反转后变成头节点,last节点为空]</span>        last = head; <span class="comment">// 当前节点变成前一个节点,指针后移</span>        head = next; <span class="comment">// 指针指向下一个节点,进入下一轮循环.</span>    &#125;    <span class="keyword">return</span> last; <span class="comment">// 返回反转后的头节点的引用</span>&#125;</code></pre>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;1-单向链表反转&quot;&gt;&lt;a href=&quot;#1-单向链表反转&quot; class=&quot;headerlink&quot; title=&quot;1. 单向链表反转&quot;&gt;&lt;/a&gt;1. 单向链表反转&lt;/h1&gt;&lt;h2 id=&quot;1-1-题目要求&quot;&gt;&lt;a href=&quot;#1-1-题目要求&quot; class=&quot;he</summary>
      
    
    
    
    <category term="算法" scheme="https://georgechan95.github.io/categories/%E7%AE%97%E6%B3%95/"/>
    
    
    <category term="算法" scheme="https://georgechan95.github.io/tags/%E7%AE%97%E6%B3%95/"/>
    
    <category term="链表" scheme="https://georgechan95.github.io/tags/%E9%93%BE%E8%A1%A8/"/>
    
  </entry>
  
</feed>
