<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>George&#39;s Blog</title>
  
  <subtitle>个人邮箱：george_95@126.com</subtitle>
  <link href="https://georgechan95.github.io/atom.xml" rel="self"/>
  
  <link href="https://georgechan95.github.io/"/>
  <updated>2024-11-23T07:04:41.175Z</updated>
  <id>https://georgechan95.github.io/</id>
  
  <author>
    <name>George</name>
    
  </author>
  
  <generator uri="https://hexo.io/">Hexo</generator>
  
  <entry>
    <title>16-命令模式</title>
    <link href="https://georgechan95.github.io/blog/60fd53f.html"/>
    <id>https://georgechan95.github.io/blog/60fd53f.html</id>
    <published>2024-11-23T12:30:00.000Z</published>
    <updated>2024-11-23T07:04:41.175Z</updated>
    
    <content type="html"><![CDATA[<p><strong>命令模式属于对象的行为模式。命令模式又称为行动(Action)模式或交易(Transaction)模式。</strong></p><p><strong>命令模式把一个请求或者操作封装到一个对象中。命令模式允许系统使用不同的请求把客户端参数化，对请求排队或者记录请求日志，可以提供命令的撤销和恢复功能。</strong></p><h1 id="一、命令模式的结构"><a href="#一、命令模式的结构" class="headerlink" title="一、命令模式的结构"></a>一、命令模式的结构</h1><p>命令模式是对命令的封装。命令模式把发出命令的责任和执行命令的责任分割开，委派给不同的对象。</p><p>每一个命令都是一个操作：请求的一方发出请求要求执行一个操作；接收的一方收到请求，并执行操作。命令模式允许请求的一方和接收的一方独立开来，使得请求的一方不必知道接收请求的一方的接口，更不必知道请求是怎么被接收，以及操作是否被执行、何时被执行，以及是怎么被执行的。</p><p>命令允许请求的一方和接收请求的一方能够独立演化，从而具有以下的优点：</p><ul><li><p>命令模式使新的命令很容易地被加入到系统里。</p></li><li><p>允许接收请求的一方决定是否要否决请求。</p></li><li><p>能较容易地设计一个命令队列。</p></li><li><p>可以容易地实现对请求的撤销和恢复。</p></li><li><p>在需要的情况下，可以较容易地将命令记入日志。</p></li></ul><p>下面以一个示意性的系统，说明命令模式的结构。</p><p><img src="https://raw.githubusercontent.com/GeorgeChan95/blogimg/master/img/2024/11/23/20241123-140717.png" alt="命令模式UML"></p><p>命令模式涉及到五个角色，它们分别是：</p><ul><li><strong>客户端(Client)角色：</strong>创建一个具体命令(ConcreteCommand)对象并确定其接收者。</li><li><strong>命令(Command)角色：</strong>声明了一个给所有具体命令类的抽象接口。</li><li><strong>具体命令(ConcreteCommand)角色：</strong>定义一个接收者和行为之间的弱耦合；实现execute()方法，负责调用接收者的相应操作。execute()方法通常叫做执行方法。</li><li><strong>请求者(Invoker)角色：</strong>负责调用命令对象执行请求，相关的方法叫做行动方法。</li><li><strong>接收者(Receiver)角色：</strong>负责具体实施和执行一个请求。任何一个类都可以成为接收者，实施和执行请求的方法叫做行动方法。</li></ul><p><strong>代码示例</strong></p><pre><code class="highlight java"><span class="comment">/**</span><span class="comment"> * 命令接收者</span><span class="comment"> */</span><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Receiver</span> &#123;    <span class="comment">/**</span><span class="comment">     * 真正执行命令相应的操作</span><span class="comment">     */</span>    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">action</span><span class="params">()</span>&#123;        System.out.println(<span class="string">&quot;==命令接收者执行操作==&quot;</span>);    &#125;&#125;<span class="comment">/**</span><span class="comment"> * 抽象命令角色</span><span class="comment"> */</span><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">Command</span> &#123;    <span class="comment">/**</span><span class="comment">     * 执行方法</span><span class="comment">     */</span>    <span class="keyword">void</span> <span class="title function_">execute</span><span class="params">()</span>;&#125;<span class="comment">/**</span><span class="comment"> * 具体命令角色</span><span class="comment"> */</span><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ConcreteCommand</span> <span class="keyword">implements</span> <span class="title class_">Command</span> &#123;    <span class="comment">// 聚合命令接收者</span>    <span class="keyword">private</span> Receiver receiver;    <span class="keyword">public</span> <span class="title function_">ConcreteCommand</span><span class="params">(Receiver receiver)</span> &#123;        <span class="built_in">this</span>.receiver = receiver;    &#125;    <span class="meta">@Override</span>    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">execute</span><span class="params">()</span> &#123;        <span class="comment">// 调用接收者执行具体的方法</span>        receiver.action();    &#125;&#125;<span class="comment">/**</span><span class="comment"> * 请求者角色</span><span class="comment"> */</span><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Invoker</span> &#123;    <span class="comment">// 聚合抽象命令角色</span>    <span class="keyword">private</span> Command command;    <span class="keyword">public</span> <span class="title function_">Invoker</span><span class="params">(Command command)</span> &#123;        <span class="built_in">this</span>.command = command;    &#125;    <span class="comment">/**</span><span class="comment">     * 行动方法：调用命令对象执行请求</span><span class="comment">     */</span>    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">action</span><span class="params">()</span> &#123;        command.execute();    &#125;&#125;<span class="comment">/**</span><span class="comment"> * 测试类</span><span class="comment"> */</span><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Client</span> &#123;    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;        <span class="comment">// 命令接收者</span>        <span class="type">Receiver</span> <span class="variable">receiver</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Receiver</span>();        <span class="comment">// 创建命令对象，将命令接受者设置进去</span>        <span class="type">Command</span> <span class="variable">command</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ConcreteCommand</span>(receiver);        <span class="comment">// 创建请求执行者，并将命令对象设置进去</span>        <span class="type">Invoker</span> <span class="variable">invoker</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Invoker</span>(command);        <span class="comment">// 执行命令</span>        invoker.action();    &#125;&#125;</code></pre><blockquote><p>运行结果：</p><pre><code class="highlight shell">==命令接收者执行操作==</code></pre></blockquote><h1 id="二、案例：AudioPlayer系统"><a href="#二、案例：AudioPlayer系统" class="headerlink" title="二、案例：AudioPlayer系统"></a>二、案例：AudioPlayer系统</h1><p>小女孩茱丽(Julia)有一个盒式录音机，此录音机有播音(Play)、倒带(Rewind)和停止(Stop)功能，录音机的键盘便是请求者(Invoker)角色；茱丽(Julia)是客户端角色，而录音机便是接收者角色。Command类扮演抽象命令角色，而PlayCommand、StopCommand和RewindCommand便是具体命令类。茱丽(Julia)不需要知道播音(play)、倒带(rewind)和停止(stop)功能是怎么具体执行的，这些命令执行的细节全都由键盘(Keypad)具体实施。茱丽(Julia)只需要在键盘上按下相应的键便可以了。</p><p>录音机是典型的命令模式。录音机按键把客户端与录音机的操作细节分割开来。</p><p><strong>UML类图</strong></p><p><img src="https://raw.githubusercontent.com/GeorgeChan95/blogimg/master/img/2024/11/23/20241123-142909.png" alt="命令模式案例：AudioPlayer系统"></p><p><strong>代码如下：</strong></p><pre><code class="highlight java"><span class="comment">/**</span><span class="comment"> * 接收者角色：录音机</span><span class="comment"> */</span><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">AudioPlayer</span> &#123;    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">play</span><span class="params">()</span>&#123;        System.out.println(<span class="string">&quot;录音机播放...&quot;</span>);    &#125;    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">rewind</span><span class="params">()</span>&#123;        System.out.println(<span class="string">&quot;录音机倒带...&quot;</span>);    &#125;    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">stop</span><span class="params">()</span>&#123;        System.out.println(<span class="string">&quot;录音机停止...&quot;</span>);    &#125;&#125;<span class="comment">/**</span><span class="comment"> * 命令角色</span><span class="comment"> */</span><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">Command</span> &#123;    <span class="comment">/**</span><span class="comment">     * 执行方法</span><span class="comment">     */</span>    <span class="keyword">void</span> <span class="title function_">execute</span><span class="params">()</span>;&#125;<span class="comment">/**</span><span class="comment"> * 具体命令角色：播放命令</span><span class="comment"> */</span><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">PlayCommand</span> <span class="keyword">implements</span> <span class="title class_">Command</span> &#123;    <span class="comment">// 命令接收者</span>    <span class="keyword">private</span> AudioPlayer audioPlayer;    <span class="keyword">public</span> <span class="title function_">PlayCommand</span><span class="params">(AudioPlayer audioPlayer)</span> &#123;        <span class="built_in">this</span>.audioPlayer = audioPlayer;    &#125;    <span class="comment">/**</span><span class="comment">     * 执行方法</span><span class="comment">     */</span>    <span class="meta">@Override</span>    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">execute</span><span class="params">()</span> &#123;        audioPlayer.play();    &#125;&#125;<span class="comment">/**</span><span class="comment"> * 具体命令角色：倒带命令</span><span class="comment"> */</span><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">RewindCommand</span> <span class="keyword">implements</span> <span class="title class_">Command</span> &#123;    <span class="comment">// 命令接收者</span>    <span class="keyword">private</span> AudioPlayer audioPlayer;    <span class="keyword">public</span> <span class="title function_">RewindCommand</span><span class="params">(AudioPlayer audioPlayer)</span> &#123;        <span class="built_in">this</span>.audioPlayer = audioPlayer;    &#125;    <span class="comment">/**</span><span class="comment">     * 执行方法</span><span class="comment">     */</span>    <span class="meta">@Override</span>    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">execute</span><span class="params">()</span> &#123;        audioPlayer.rewind();    &#125;&#125;<span class="comment">/**</span><span class="comment"> * 具体命令角色：停止命令</span><span class="comment"> */</span><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">StopCommand</span> <span class="keyword">implements</span> <span class="title class_">Command</span> &#123;    <span class="comment">// 命令接收者</span>    <span class="keyword">private</span> AudioPlayer audioPlayer;    <span class="keyword">public</span> <span class="title function_">StopCommand</span><span class="params">(AudioPlayer audioPlayer)</span> &#123;        <span class="built_in">this</span>.audioPlayer = audioPlayer;    &#125;    <span class="comment">/**</span><span class="comment">     * 执行方法</span><span class="comment">     */</span>    <span class="meta">@Override</span>    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">execute</span><span class="params">()</span> &#123;        audioPlayer.stop();    &#125;&#125;<span class="comment">/**</span><span class="comment"> * 请求者角色：键盘</span><span class="comment"> */</span><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Keypad</span> &#123;    <span class="keyword">private</span> Command playCommand;    <span class="keyword">private</span> Command rewindCommand;    <span class="keyword">private</span> Command stopCommand;    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setPlayCommand</span><span class="params">(Command playCommand)</span> &#123;        <span class="built_in">this</span>.playCommand = playCommand;    &#125;    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setRewindCommand</span><span class="params">(Command rewindCommand)</span> &#123;        <span class="built_in">this</span>.rewindCommand = rewindCommand;    &#125;    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setStopCommand</span><span class="params">(Command stopCommand)</span> &#123;        <span class="built_in">this</span>.stopCommand = stopCommand;    &#125;    <span class="comment">/**</span><span class="comment">     * 执行播放方法</span><span class="comment">     */</span>    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">play</span><span class="params">()</span>&#123;        playCommand.execute();    &#125;    <span class="comment">/**</span><span class="comment">     * 执行倒带方法</span><span class="comment">     */</span>    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">rewind</span><span class="params">()</span>&#123;        rewindCommand.execute();    &#125;    <span class="comment">/**</span><span class="comment">     * 执行播放方法</span><span class="comment">     */</span>    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">stop</span><span class="params">()</span>&#123;        stopCommand.execute();    &#125;&#125;<span class="comment">/**</span><span class="comment"> * 测试类</span><span class="comment"> */</span><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Julia</span> &#123;    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;        <span class="comment">// 创建接收者对象</span>        <span class="type">AudioPlayer</span> <span class="variable">audioPlayer</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">AudioPlayer</span>();        <span class="comment">// 创建命令对象</span>        <span class="type">Command</span> <span class="variable">playCommand</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">PlayCommand</span>(audioPlayer);        <span class="type">Command</span> <span class="variable">rewindCommand</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">RewindCommand</span>(audioPlayer);        <span class="type">Command</span> <span class="variable">stopCommand</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">StopCommand</span>(audioPlayer);        <span class="comment">// 创建请求者对象</span>        <span class="type">Keypad</span> <span class="variable">keypad</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Keypad</span>();        keypad.setPlayCommand(playCommand);        keypad.setRewindCommand(rewindCommand);        keypad.setStopCommand(stopCommand);        <span class="comment">// 测试</span>        keypad.play();        keypad.stop();        keypad.rewind();        keypad.stop();        keypad.play();    &#125;&#125;</code></pre><blockquote><p>运行结果：</p><pre><code class="highlight shell">录音机播放...录音机停止...录音机倒带...录音机停止...录音机播放...</code></pre></blockquote><h1 id="三、宏命令"><a href="#三、宏命令" class="headerlink" title="三、宏命令"></a>三、宏命令</h1><p>所谓宏命令简单点说就是包含多个命令的命令，是一个命令的组合。</p><p>设想茱丽的录音机有一个记录功能，可以把一个一个的命令记录下来，再在任何需要的时候重新把这些记录下来的命令一次性执行，这就是所谓的宏命令集功能。因此，茱丽的录音机系统现在有四个键，分别为播音、倒带、停止和宏命令功能。此时系统的设计与前面的设计相比有所增强，主要体现在Julia类现在有了一个新方法，用以操作宏命令键。</p><p><img src="https://raw.githubusercontent.com/GeorgeChan95/blogimg/master/img/2024/11/23/20241123-144947.png" alt="宏命令"></p><p><strong>代码如下：</strong></p><p>系统需要一个代表宏命令的接口，以定义出具体宏命令所需要的接口。</p><pre><code class="highlight java"><span class="comment">/**</span><span class="comment"> * 系统需要一个代表宏命令的接口，以定义出具体宏命令所需要的接口。</span><span class="comment"> */</span><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">MacroCommand</span> <span class="keyword">extends</span> <span class="title class_">Command</span> &#123;    <span class="comment">/**</span><span class="comment">     * 宏命令聚集的管理方法，可以添加一个成员命令</span><span class="comment">     * <span class="doctag">@param</span> cmd</span><span class="comment">     */</span>    <span class="keyword">void</span> <span class="title function_">add</span><span class="params">(Command cmd)</span>;    <span class="comment">/**</span><span class="comment">     * 宏命令聚集的管理方法, 可以删除一个成员命令</span><span class="comment">     * <span class="doctag">@param</span> cmd</span><span class="comment">     */</span>    <span class="keyword">void</span> <span class="title function_">remove</span><span class="params">(Command cmd)</span>;&#125;<span class="comment">/**</span><span class="comment"> * 具体的宏命令MacroAudioCommand类负责把个别的命令合成宏命令。</span><span class="comment"> */</span><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">MacroAudioCommand</span> <span class="keyword">implements</span> <span class="title class_">MacroCommand</span> &#123;    List&lt;Command&gt; commandList = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();    <span class="meta">@Override</span>    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">add</span><span class="params">(Command cmd)</span> &#123;        commandList.add(cmd);    &#125;    <span class="meta">@Override</span>    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">remove</span><span class="params">(Command cmd)</span> &#123;        commandList.remove(cmd);    &#125;    <span class="comment">/**</span><span class="comment">     * 执行方法</span><span class="comment">     */</span>    <span class="meta">@Override</span>    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">execute</span><span class="params">()</span> &#123;        <span class="keyword">for</span> (Command command : commandList) &#123;            command.execute();        &#125;    &#125;&#125;<span class="comment">/**</span><span class="comment"> * 测试类</span><span class="comment"> */</span><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Julia</span> &#123;    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;        <span class="comment">// 创建接收者对象</span>        <span class="type">AudioPlayer</span> <span class="variable">audioPlayer</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">AudioPlayer</span>();        <span class="comment">//创建命令对象</span>        <span class="type">Command</span> <span class="variable">playCommand</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">PlayCommand</span>(audioPlayer);        <span class="type">Command</span> <span class="variable">rewindCommand</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">RewindCommand</span>(audioPlayer);        <span class="type">Command</span> <span class="variable">stopCommand</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">StopCommand</span>(audioPlayer);        <span class="type">MacroCommand</span> <span class="variable">marco</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">MacroAudioCommand</span>();        marco.add(playCommand);        marco.add(rewindCommand);        marco.add(stopCommand);        marco.execute();    &#125;&#125;</code></pre><blockquote><p>运行结果：</p><pre><code class="highlight shell">录音机播放...录音机倒带...录音机停止..</code></pre></blockquote><h1 id="四、命令模式的优点"><a href="#四、命令模式的优点" class="headerlink" title="四、命令模式的优点"></a>四、命令模式的优点</h1><ul><li><p><strong>更松散的耦合</strong></p><p>命令模式使得发起命令的对象——客户端，和具体实现命令的对象——接收者对象完全解耦，也就是说发起命令的对象完全不知道具体实现对象是谁，也不知道如何实现。</p></li><li><p><strong>更动态的控制</strong></p><p>命令模式把请求封装起来，可以动态地对它进行参数化、队列化和日志化等操作，从而使得系统更灵活。</p></li><li><p><strong>很自然的复合命令</strong></p><p>命令模式中的命令对象能够很容易地组合成复合命令，也就是宏命令，从而使系统操作更简单，功能更强大。</p></li><li><p><strong>更好的扩展性</strong></p><p>由于发起命令的对象和具体的实现完全解耦，因此扩展新的命令就很容易，只需要实现新的命令对象，然后在装配的时候，把具体的实现对象设置到命令对象中，然后就可以使用这个命令对象，已有的实现完全不用变化。</p></li></ul>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;&lt;strong&gt;命令模式属于对象的行为模式。命令模式又称为行动(Action)模式或交易(Transaction)模式。&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;命令模式把一个请求或者操作封装到一个对象中。命令模式允许系统使用不同的请求把客户端参数化，对请求排队或者</summary>
      
    
    
    
    <category term="设计模式" scheme="https://georgechan95.github.io/categories/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"/>
    
    
    <category term="设计模式" scheme="https://georgechan95.github.io/tags/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"/>
    
  </entry>
  
  <entry>
    <title>15-模板方法模式</title>
    <link href="https://georgechan95.github.io/blog/4930323d.html"/>
    <id>https://georgechan95.github.io/blog/4930323d.html</id>
    <published>2024-11-23T11:40:00.000Z</published>
    <updated>2024-11-23T05:12:39.298Z</updated>
    
    <content type="html"><![CDATA[<h1 id="一、什么是模板方法设计模式"><a href="#一、什么是模板方法设计模式" class="headerlink" title="一、什么是模板方法设计模式"></a>一、什么是模板方法设计模式</h1><p>从字面意义上理解, 模板方法就是定义出来一套方法, 作为模板, 也就是基础。 在这个基础上, 我们可以进行加工，实现个性化的实现。比如：一日餐三. 早餐, 中餐, 晚餐. 每个人都要吃三餐, 但每个人的三餐吃的可能都不一样. 一日三餐定义了模板–早中晚, 每个人的三餐就是模板的具体实现.</p><h2 id="1-模板方法的用途"><a href="#1-模板方法的用途" class="headerlink" title="1. 模板方法的用途"></a>1. 模板方法的用途</h2><ul><li>将不变的行为从子类搬到超类，去除了子类中的重复代码。</li><li>规范子类的结构</li></ul><h2 id="2-模板方法的定义"><a href="#2-模板方法的定义" class="headerlink" title="2. 模板方法的定义"></a>2. 模板方法的定义</h2><p>定义一个操作中的算法骨架，而将算法的一些步骤延迟到子类中，使得子类可以不改变该算法结构的情况下重定义该算法的某些特定步骤。它是一种类<strong>行为型模式</strong>。</p><h1 id="二、定义模板方法的步骤"><a href="#二、定义模板方法的步骤" class="headerlink" title="二、定义模板方法的步骤"></a>二、定义模板方法的步骤</h1><blockquote><p>第一步: 定义模板类 </p><p>第二步: 定义具体子类 </p><p>第三步: 客户端调用</p></blockquote><p>下面来了解每一个步骤：</p><h2 id="1-定义模板类"><a href="#1-定义模板类" class="headerlink" title="1. 定义模板类"></a>1. 定义模板类</h2><p>通常模板类是抽象类，负责给出算法的轮廓或者框架。他是有若干个<strong>模板方法</strong>和若干个<strong>基本方法</strong>构成。</p><h3 id="1-1-模板方法"><a href="#1-1-模板方法" class="headerlink" title="1.1 模板方法"></a>1.1 模板方法</h3><p>定义了算法的骨架， 定义了方法调用的顺序， 其中包含一个或者多个基本方法</p><h3 id="1-2-基本方法"><a href="#1-2-基本方法" class="headerlink" title="1.2 基本方法"></a>1.2 基本方法</h3><p>基本方法有三种类型：</p><ul><li>抽象方法：子类必须重写的方法。没有默认实现。</li><li>具体方法：父类定义的默认实现，有实现逻辑，可以被具体的子类继承或重写</li><li>钩子方法：判断的逻辑方法和需要子类重写的空方法两种。</li></ul><h2 id="2-定义具体子类"><a href="#2-定义具体子类" class="headerlink" title="2. 定义具体子类"></a>2. 定义具体子类</h2><p>具体子类，也就是具体的实现类， 实现抽象类中的抽象方法。他们是抽象的模板方法中一个组成部分。</p><h2 id="3-定义客户端调用"><a href="#3-定义客户端调用" class="headerlink" title="3. 定义客户端调用"></a>3. 定义客户端调用</h2><p>客户端调用抽象类， 实例化的时候实例化具体类， 只需要调用抽象类的模板方法就可以了。</p><h2 id="4-实例演示"><a href="#4-实例演示" class="headerlink" title="4. 实例演示"></a>4. 实例演示</h2><p>下面来看一下抽象类和子类之间的UML图和源码实现</p><p><strong>UML类图</strong></p><img src="https://raw.githubusercontent.com/GeorgeChan95/blogimg/master/img/2024/11/23/20241123-102632.png" alt="模板方法设计模式" style="zoom: 50%;" /><p>从图中可以看出抽象类的结构可以定义三类方法。 可以有一个也可以有多个。子类必须需要实现抽象类中的抽象方法，可以选择性重写父类的具体方法。子类实现接口的时候，要多思考设计模式的六大原则。</p><p><strong>代码实现</strong></p><ul><li><p>先定义抽象类， 也就是框架。</p><pre><code class="highlight java"><span class="comment">/**</span><span class="comment"> * 抽象类, 定义模板</span><span class="comment"> */</span><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">class</span> <span class="title class_">AbstractClass</span> &#123;    <span class="comment">/**</span><span class="comment">     * 模板方法</span><span class="comment">     * 规范了流程的框架</span><span class="comment">     */</span>    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">templateMethod</span><span class="params">()</span> &#123;        <span class="comment">// 先调用具体方法</span>        specificMethod();        <span class="comment">// 在调用抽象方法</span>        abstractMethod();    &#125;    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">specificMethod</span><span class="params">()</span> &#123;        <span class="comment">// 具体的公共逻辑, 父子类通用</span>        System.out.println(<span class="string">&quot;具体方法---父子类通用逻辑&quot;</span>);    &#125;    <span class="comment">/**</span><span class="comment">     * 抽象方法</span><span class="comment">     * 抽象方法, 子类必须重写</span><span class="comment">     */</span>    <span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">void</span> <span class="title function_">abstractMethod</span><span class="params">()</span>;&#125;</code></pre></li><li><p>定义具体的实现类， 实现父类的抽象方法</p><pre><code class="highlight java"><span class="comment">/**</span><span class="comment"> * 具体实现类</span><span class="comment"> */</span><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ConcreteClass</span> <span class="keyword">extends</span> <span class="title class_">AbstractClass</span> &#123;    <span class="comment">/**</span><span class="comment">     * 重写父类的抽象方法</span><span class="comment">     */</span>    <span class="meta">@Override</span>    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">abstractMethod</span><span class="params">()</span> &#123;        System.out.println(<span class="string">&quot;具体实现类--重写父类的抽象方法&quot;</span>);    &#125;&#125;</code></pre></li><li><p>最后定义客户端调用</p><pre><code class="highlight java"><span class="comment">/**</span><span class="comment"> * 模板方法客户端</span><span class="comment"> */</span><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">TemplateClient</span> &#123;    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;        <span class="type">AbstractClass</span> <span class="variable">abstractClass</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ConcreteClass</span>();        abstractClass.templateMethod();    &#125;&#125;</code></pre><blockquote><p>运行结果：</p><pre><code class="highlight shell">具体方法---父子类通用逻辑具体实现类--重写父类的抽象方法</code></pre></blockquote></li></ul><p>对照模板方法设计模式，我们来看一个具体的案例。</p><h1 id="三、案例解析"><a href="#三、案例解析" class="headerlink" title="三、案例解析"></a>三、案例解析</h1><h2 id="1-案例1：-一日规划"><a href="#1-案例1：-一日规划" class="headerlink" title="1. 案例1： 一日规划"></a>1. 案例1： 一日规划</h2><p>每个人的一日安排都有三餐， 早餐， 中餐，晚参。 但每个人的三餐食物不尽相同，我们来看看每个人的三餐变化， 以及三餐前后要做的事情。</p><pre><code class="highlight java"><span class="comment">/**</span><span class="comment"> * 一日三餐抽象类</span><span class="comment"> */</span><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">class</span> <span class="title class_">ArrangementAbstract</span> &#123;    <span class="comment">/**</span><span class="comment">     * 模板方法</span><span class="comment">     * 规定了一天的框架</span><span class="comment">     */</span>    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">templateMethod</span><span class="params">()</span> &#123;        System.out.println(<span class="string">&quot;一日安排如下: &quot;</span>);        getUp();        breakfast();        lunch();        dinner();        getDown();    &#125;    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">getUp</span><span class="params">()</span> &#123;        System.out.println(<span class="string">&quot;起床&quot;</span>);    &#125;    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">getDown</span><span class="params">()</span> &#123;        System.out.println(<span class="string">&quot;睡觉&quot;</span>);    &#125;    <span class="comment">/**</span><span class="comment">     * 早餐抽象类</span><span class="comment">     */</span>    <span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">void</span> <span class="title function_">breakfast</span><span class="params">()</span>;    <span class="comment">/**</span><span class="comment">     * 午餐抽象类</span><span class="comment">     */</span>    <span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">void</span> <span class="title function_">lunch</span><span class="params">()</span>;    <span class="comment">/**</span><span class="comment">     * 晚餐抽象类</span><span class="comment">     */</span>    <span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">void</span> <span class="title function_">dinner</span><span class="params">()</span>;&#125;</code></pre><p>定义一日三餐抽象类。每个人的日程安排都是，起床，早餐，中餐，晚餐，睡觉。 其中起床和睡觉是每个人都要做的事情，三餐也是，但三餐的食物不同，于是我们将三餐定义为抽象</p><p>一日安排实现类</p><pre><code class="highlight java"><span class="comment">/**</span><span class="comment"> * 张三的一日三餐安排</span><span class="comment"> */</span><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">PersonArrangement</span> <span class="keyword">extends</span> <span class="title class_">ArrangementAbstract</span> &#123;    <span class="keyword">private</span> String name;    <span class="keyword">public</span> <span class="title function_">PersonArrangement</span><span class="params">(String name)</span> &#123;        <span class="built_in">this</span>.name = name;    &#125;    <span class="comment">/**</span><span class="comment">     * 早餐抽象类</span><span class="comment">     */</span>    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">breakfast</span><span class="params">()</span> &#123;        System.out.println(name + <span class="string">&quot;--早餐吃牛奶面包&quot;</span>);    &#125;    <span class="comment">/**</span><span class="comment">     * 午餐抽象类</span><span class="comment">     */</span>    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">lunch</span><span class="params">()</span> &#123;        System.out.println(name + <span class="string">&quot;--中餐吃食堂&quot;</span>);    &#125;    <span class="comment">/**</span><span class="comment">     * 晚餐抽象类</span><span class="comment">     */</span>    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">dinner</span><span class="params">()</span> &#123;        System.out.println(name + <span class="string">&quot;--晚餐吃水果&quot;</span>);    &#125;&#125;</code></pre><p>客户端调用</p><pre><code class="highlight java"><span class="comment">/**</span><span class="comment"> * 测试类</span><span class="comment"> */</span><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Client</span> &#123;    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;        <span class="type">ArrangementAbstract</span> <span class="variable">arrangementAbstract</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">PersonArrangement</span>(<span class="string">&quot;张三&quot;</span>);        arrangementAbstract.templateMethod();    &#125;&#125;</code></pre><blockquote><p>运行结果：</p><pre><code class="highlight shell">一日安排如下: 起床张三--早餐吃牛奶面包张三--中餐吃食堂张三--晚餐吃水果睡觉</code></pre></blockquote><p>可以看出， 完全按照模板方法的步骤实现。</p><h2 id="2-案例2：-钩子方法"><a href="#2-案例2：-钩子方法" class="headerlink" title="2. 案例2： 钩子方法"></a>2. 案例2： 钩子方法</h2><p>我们上面说了, 模板方法设计模式中, 基本方法包括抽象方法,具体方法和钩子方法. 如果能够使用好钩子方法, 可以在程序中完美实现子类控制父类的行为. 我们来看下面的案例:</p><p>我们在抽象方法中定义一个钩子方法 <code>hookMethod()</code> , 在模板方法 <code>templateMethod()</code> 中,钩子方法控制了代码的流程.</p><p><strong>UML类图</strong></p><p><img src="https://raw.githubusercontent.com/GeorgeChan95/blogimg/master/img/2024/11/23/20241123-121856.png" alt="模板方法模式-钩子方法"></p><p><strong>代码实现如下：</strong></p><pre><code class="highlight java"><span class="comment">/**</span><span class="comment"> * 抽象类, 定义模板</span><span class="comment"> */</span><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">class</span> <span class="title class_">AbstractClass</span> &#123;    <span class="comment">/**</span><span class="comment">     * 定义模板方法</span><span class="comment">     * 规范了流程的框架</span><span class="comment">     */</span>    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">templateMethod</span><span class="params">()</span> &#123;        <span class="comment">// 调用具体方法</span>        specificMethod();        <span class="comment">// 钩子方法控制下一步骤</span>        <span class="keyword">if</span> (hookMethod()) &#123;            <span class="comment">// 调用抽象方法</span>            abstractMethod();        &#125;    &#125;    <span class="comment">/**</span><span class="comment">     * 具体方法</span><span class="comment">     */</span>    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">specificMethod</span><span class="params">()</span> &#123;        <span class="comment">// 具体的公共逻辑, 父子类通用</span>        System.out.println(<span class="string">&quot;具体方法---父子类通用逻辑&quot;</span>);    &#125;    <span class="comment">/**</span><span class="comment">     * 抽象方法</span><span class="comment">     *</span><span class="comment">     * 抽象方法, 子类必须重写</span><span class="comment">     */</span>    <span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">void</span> <span class="title function_">abstractMethod</span><span class="params">()</span>;    <span class="comment">/**</span><span class="comment">     * 钩子方法</span><span class="comment">     * 钩子方法是有具体实现的,</span><span class="comment">     */</span>    <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">hookMethod</span><span class="params">()</span> &#123;        <span class="keyword">return</span> <span class="literal">true</span>;    &#125;&#125;<span class="comment">/**</span><span class="comment"> * 具体实现类</span><span class="comment"> */</span><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ConcreteClass</span> <span class="keyword">extends</span> <span class="title class_">AbstractClass</span>&#123;    <span class="comment">/**</span><span class="comment">     * 重写父类的抽象方法</span><span class="comment">     */</span>    <span class="meta">@Override</span>    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">abstractMethod</span><span class="params">()</span> &#123;        System.out.println(<span class="string">&quot;具体实现类--重写父类的抽象方法&quot;</span>);    &#125;    <span class="comment">/**</span><span class="comment">     * 子类重写钩子方法，非必须</span><span class="comment">     * <span class="doctag">@return</span></span><span class="comment">     */</span>    <span class="meta">@Override</span>    <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">hookMethod</span><span class="params">()</span> &#123;        System.out.println(<span class="string">&quot;重写了父类的钩子方法, 反向控制父类的行为&quot;</span>);        <span class="keyword">return</span> <span class="literal">false</span>;    &#125;&#125;<span class="comment">/**</span><span class="comment"> * 测试类</span><span class="comment"> */</span><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">TemplateClient</span> &#123;    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;        <span class="type">AbstractClass</span> <span class="variable">abstractClass</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ConcreteClass</span>();        abstractClass.templateMethod();    &#125;&#125;</code></pre><blockquote><p>运行结果</p><pre><code class="highlight shell">具体方法---父子类通用逻辑重写了父类的钩子方法, 反向控制父类的行为</code></pre></blockquote><p>如果子类钩子方法 <code>HookMethod()</code> 的代码改变，则程序的运行结果也会发生改变。</p><h1 id="四、模板方法的优缺点"><a href="#四、模板方法的优缺点" class="headerlink" title="四、模板方法的优缺点"></a>四、模板方法的优缺点</h1><p><strong>优点</strong></p><ul><li>规范了框架, 封装了不变的部分, 扩展了可变的部分. 父类定义框架, 并抽象了公共不变的部分, 子类通过重写扩展完善了框架的实现.</li><li>使用了”开闭原则”, 对扩展开放, 对修改关闭. 子类可以通过重写父类的抽象方法来扩展父类的实现.</li><li>行为集中有父类控制, 规范流程。</li></ul><p><strong>缺点</strong></p><ul><li>每一种实现都需要定义一个具体实现类, 增加类的数量, 系统更加复杂</li><li>继承的缺点, 一旦父类增加一个抽象方法, 所有子类都需要增加. 这一点违背”开闭原则”.</li><li>父类中的抽象方法由子类实现, 子类的执行结果影响父类, 这种”反向控制”结构, 会增加代码的复杂性。</li></ul><h1 id="五、使用场景"><a href="#五、使用场景" class="headerlink" title="五、使用场景"></a>五、使用场景</h1><ul><li>算法的整体步骤是固定的，但个别部分容易发生变化时，可以考虑使用模板方法设计模式，将容易发生变化的部分抽象出来，提供给子类去实现。</li><li>当多个子类存在公共的行为时，可以将其提取出来并集中到一个公共父类中以避免代码重复。首先，要识别现有代码中的不同之处，并且将不同之处分离为新的操作。最后，用一个调用这些新的操作的模板方法来替换这些不同的代码。</li><li>当需要控制子类的扩展时，模板方法只在特定点调用钩子操作，这样就只允许在这些点进行扩展。</li><li>重构时，模板方法模式是一个经常使用到的模式，把相同的代码抽取到父类中，通过钩子函数约束其行为</li></ul><h1 id="六、对设计模式六大原则的应用思考"><a href="#六、对设计模式六大原则的应用思考" class="headerlink" title="六、对设计模式六大原则的应用思考"></a>六、对设计模式六大原则的应用思考</h1><ul><li>单一职责原则: 一个方法只有一个引起变化的原因, 这个不太好看出, 要看子类代码的具体实现</li><li>里式替换原则： 父类出现的地方都可以使用子类替换,并且结果保持一致. 子类重写了父类的方法。 模板方法设计模式可能违背里式替换原则, 不过，这正是能够“反向控制”的原理</li><li>接口隔离原则: 依赖于最小的单一接口, 而不是胖接口. 符合</li><li>依赖倒置原则: 依赖于抽象, 而不是依赖于具体. 符合</li><li>迪米特法则: 最少知识原则. 之和朋友沟通, 减少和朋友的沟通. 这个需要看子类具体实现是否符合</li><li>开闭原则: 违背开闭原则,  一旦父类增加一个抽象方法， 所有子类都需要对应增加</li></ul>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;一、什么是模板方法设计模式&quot;&gt;&lt;a href=&quot;#一、什么是模板方法设计模式&quot; class=&quot;headerlink&quot; title=&quot;一、什么是模板方法设计模式&quot;&gt;&lt;/a&gt;一、什么是模板方法设计模式&lt;/h1&gt;&lt;p&gt;从字面意义上理解, 模板方法就是定义出来一套方法, </summary>
      
    
    
    
    <category term="设计模式" scheme="https://georgechan95.github.io/categories/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"/>
    
    
    <category term="设计模式" scheme="https://georgechan95.github.io/tags/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"/>
    
  </entry>
  
  <entry>
    <title>14-代理模式</title>
    <link href="https://georgechan95.github.io/blog/e4235185.html"/>
    <id>https://georgechan95.github.io/blog/e4235185.html</id>
    <published>2024-11-21T15:16:00.000Z</published>
    <updated>2024-11-23T01:52:19.969Z</updated>
    
    <content type="html"><![CDATA[<h1 id="一、代理模式的基本介绍"><a href="#一、代理模式的基本介绍" class="headerlink" title="一、代理模式的基本介绍"></a>一、代理模式的基本介绍</h1><ul><li><p>代理模式：为一个对象提供一个替身，以控制对这个对象的访问。即通过代理对象访问目标对象.这样做的好处 是:可以在目标对象实现的基础上,增强额外的功能操作, 即扩展目标对象的功能。</p></li><li><p>被代理的对象可以是远程对象、创建开销大的对象或需要安全控制的对象.</p></li><li><p>代理模式有不同的形式,  主要有三种 <strong>静态代理</strong>、<strong>动态代理</strong> (JDK 代理、接口代理)和 <strong>Cglib 代理</strong> (可以在内存 动态的创建对象，而不需要实现接口， 他是属于动态代理的范畴)  。</p></li></ul><p>代理模式示意图</p><p><img src="https://raw.githubusercontent.com/GeorgeChan95/blogimg/master/img/2024/11/21/20241121-231932.png" alt="代理模式"></p><h1 id="二静态代理"><a href="#二静态代理" class="headerlink" title="二静态代理"></a>二静态代理</h1><h2 id="1-基本介绍"><a href="#1-基本介绍" class="headerlink" title="1. 基本介绍"></a>1. 基本介绍</h2><p>静态代理在使用时,需要定义接口或者父类,被代理对象(即目标对象)与代理对象一起实现相同的接口或者是继承相同父类</p><h2 id="2-应用实例"><a href="#2-应用实例" class="headerlink" title="2. 应用实例"></a>2. 应用实例</h2><p><strong>具体要求</strong></p><ul><li>定义一个接口: <code>ITeacherDao</code></li><li>目标对象 <code>TeacherDAO</code> 实现接口 <code>ITeacherDAO</code></li></ul><ol start="3"><li>使用静态代理方式,就需要在代理对象 <code>TeacherDAOProxy</code> 中也实现 <code>ITeacherDAO</code></li><li>调用的时候通过调用代理对象的方法来调用目标对象.</li><li>特别提醒：代理对象与目标对象要实现相同的接口,然后通过调用相同的方法来调用目标对象的方法</li></ol><p><strong>思路分析图解(类图)</strong></p><p><img src="https://raw.githubusercontent.com/GeorgeChan95/blogimg/master/img/2024/11/21/20241121-234014.png" alt="静态代理UML图"></p><p><strong>代码实现</strong></p><pre><code class="highlight java"><span class="comment">// 接口</span><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">ITeacherDao</span> &#123;    <span class="keyword">void</span> <span class="title function_">teach</span><span class="params">()</span>; <span class="comment">// 授课的方法</span>&#125;<span class="comment">// 被代理的类</span><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">TeacherDao</span> <span class="keyword">implements</span> <span class="title class_">ITeacherDao</span> &#123;    <span class="meta">@Override</span>    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">teach</span><span class="params">()</span> &#123;        System.out.println(<span class="string">&quot; 老师授课中  。。。。。&quot;</span>);    &#125;&#125;<span class="comment">//代理对象,静态代理</span><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">TeacherDaoProxy</span> <span class="keyword">implements</span> <span class="title class_">ITeacherDao</span> &#123;    <span class="keyword">private</span> ITeacherDao target; <span class="comment">// 目标对象，通过接口来聚合</span>    <span class="keyword">public</span> <span class="title function_">TeacherDaoProxy</span><span class="params">(ITeacherDao target)</span> &#123;        <span class="built_in">this</span>.target = target;    &#125;    <span class="meta">@Override</span>    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">teach</span><span class="params">()</span> &#123;        <span class="built_in">this</span>.before();        target.teach();        <span class="built_in">this</span>.after();    &#125;    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">before</span><span class="params">()</span> &#123;        System.out.println(<span class="string">&quot;准备课程&quot;</span>);    &#125;    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">after</span><span class="params">()</span> &#123;        System.out.println(<span class="string">&quot;结束课程&quot;</span>);    &#125;&#125;<span class="comment">// 测试类</span><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Client</span> &#123;    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;        <span class="comment">//创建目标对象(被代理对象)</span>        <span class="type">TeacherDao</span> <span class="variable">teacherDao</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">TeacherDao</span>();        <span class="comment">//创建代理对象, 同时将被代理对象传递给代理对象</span>        <span class="type">TeacherDaoProxy</span> <span class="variable">teacherDaoProxy</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">TeacherDaoProxy</span>(teacherDao);        <span class="comment">//通过代理对象，调用到被代理对象的方法</span>        <span class="comment">//即：执行的是代理对象的方法，代理对象再去调用目标对象的方法</span>        teacherDaoProxy.teach();    &#125;&#125;</code></pre><blockquote><p>运行结果:</p><pre><code class="highlight shell">准备课程 老师授课中  。。。。。结束课程</code></pre></blockquote><h2 id="3-静态代理优缺点"><a href="#3-静态代理优缺点" class="headerlink" title="3. 静态代理优缺点"></a>3. 静态代理优缺点</h2><ul><li>优点：在不修改目标对象的功能前提下,  能通过代理对象对目标功能扩展</li><li>缺点：因为代理对象需要与目标对象实现一样的接口,所以会有很多代理类</li><li>一旦接口增加方法, 目标对象与代理对象都要维护</li></ul><h1 id="三、动态代理"><a href="#三、动态代理" class="headerlink" title="三、动态代理"></a>三、动态代理</h1><h2 id="1-基本介绍-1"><a href="#1-基本介绍-1" class="headerlink" title="1. 基本介绍"></a>1. 基本介绍</h2><ul><li>代理对象,不需要实现接口，但是目标对象要实现接口，否则不能用动态代理</li><li>代理对象的生成，是利用 JDK 的 API ，动态的在内存中构建代理对象</li><li>动态代理也叫做：JDK 代理、接口代理</li></ul><h2 id="2-JDK-中生成代理对象的-API"><a href="#2-JDK-中生成代理对象的-API" class="headerlink" title="2. JDK 中生成代理对象的 API"></a>2. JDK 中生成代理对象的 API</h2><ul><li>代理类所在包: <code>java.lang.reflect.Proxy</code></li><li>JDK 实现代理只需要使用 <code>newProxyInstance</code> 方法,但是该方法需要接收三个参数,完整的写法是: <code>static Object newProxyInstance(ClassLoader loader, Class&lt;?&gt;[] interfaces,InvocationHandler h )</code></li></ul><h2 id="3-应用实例"><a href="#3-应用实例" class="headerlink" title="3. 应用实例"></a>3. 应用实例</h2><p><strong>应用实例要求</strong></p><p>将前面的静态代理改进成动态代理模式(即：JDK 代理模式)</p><p><strong>思路图解(类图)</strong></p><p><img src="https://raw.githubusercontent.com/GeorgeChan95/blogimg/master/img/2024/11/21/20241121-235947.png" alt="动态代理UML图"></p><p><strong>代码实现</strong></p><pre><code class="highlight java"><span class="comment">// 接口</span><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">ITeacherDao</span> &#123;    <span class="keyword">void</span> <span class="title function_">teach</span><span class="params">()</span>; <span class="comment">// 授课的方法</span>    <span class="keyword">void</span> <span class="title function_">sayHello</span><span class="params">(String name)</span>;&#125;<span class="comment">// 被代理的类</span><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">TeacherDao</span> <span class="keyword">implements</span> <span class="title class_">ITeacherDao</span> &#123;    <span class="meta">@Override</span>    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">teach</span><span class="params">()</span> &#123;        System.out.println(<span class="string">&quot; 老师授课中  。。。。。&quot;</span>);    &#125;    <span class="meta">@Override</span>    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">sayHello</span><span class="params">(String name)</span> &#123;        System.out.println(<span class="string">&quot;hello &quot;</span> + name);    &#125;&#125;<span class="comment">// JDK动态代理类</span><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ProxyFactory</span> &#123;    <span class="keyword">private</span> ITeacherDao target;    <span class="keyword">public</span> <span class="title function_">ProxyFactory</span><span class="params">(ITeacherDao target)</span> &#123;        <span class="built_in">this</span>.target = target;    &#125;    <span class="comment">//说明</span>    <span class="comment">/*</span><span class="comment">     *  public static Object newProxyInstance(ClassLoader loader,</span><span class="comment">                                      Class&lt;?&gt;[] interfaces,</span><span class="comment">                                      InvocationHandler h)</span><span class="comment"></span><span class="comment">        //1. ClassLoader loader ： 指定当前目标对象使用的类加载器, 获取加载器的方法固定</span><span class="comment">        //2. Class&lt;?&gt;[] interfaces: 目标对象实现的接口类型，使用泛型方法确认类型</span><span class="comment">        //3. InvocationHandler h : 事情处理，执行目标对象的方法时，会触发事情处理器方法, 会把当前执行的目标对象方法作为参数传入</span><span class="comment">     */</span>    <span class="keyword">public</span> Object <span class="title function_">getProxyInstance</span><span class="params">()</span> &#123;        <span class="keyword">return</span> Proxy.newProxyInstance(target.getClass().getClassLoader(), target.getClass().getInterfaces(), <span class="keyword">new</span> <span class="title class_">InvocationHandler</span>() &#123;            <span class="meta">@Override</span>            <span class="keyword">public</span> Object <span class="title function_">invoke</span><span class="params">(Object proxy, Method method, Object[] args)</span> <span class="keyword">throws</span> Throwable &#123;                System.out.println(<span class="string">&quot;JDK代理开始~&quot;</span>);                <span class="type">Object</span> <span class="variable">resultVal</span> <span class="operator">=</span> method.invoke(target, args);                System.out.println(<span class="string">&quot;JDK代理提交~&quot;</span>);                <span class="keyword">return</span> resultVal;            &#125;        &#125;);    &#125;&#125;<span class="comment">// 测试类</span><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Client</span> &#123;    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;        <span class="comment">// 创建目标对象</span>        <span class="type">ITeacherDao</span> <span class="variable">target</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">TeacherDao</span>();        <span class="comment">// 给目标对象，创建代理对象, 可以转成 ITeacherDao</span>        <span class="type">ITeacherDao</span> <span class="variable">proxyInstance</span> <span class="operator">=</span> (ITeacherDao) <span class="keyword">new</span> <span class="title class_">ProxyFactory</span>(target).getProxyInstance();        <span class="comment">// proxyInstance=class com.sun.proxy.$Proxy0 内存中动态生成了代理对象</span>        System.out.println(<span class="string">&quot;proxyInstance=&quot;</span> + proxyInstance.getClass());        <span class="comment">//通过代理对象，调用目标对象的方法</span>        proxyInstance.teach();        proxyInstance.sayHello(<span class="string">&quot;George&quot;</span>);    &#125;&#125;</code></pre><blockquote><p>运行结果:</p><pre><code class="highlight shell">proxyInstance=class com.sun.proxy.$Proxy0JDK代理开始~ 老师授课中  。。。。。JDK代理提交~JDK代理开始~hello GeorgeJDK代理提交~</code></pre></blockquote><h1 id="四、Cglib-代理"><a href="#四、Cglib-代理" class="headerlink" title="四、Cglib 代理"></a>四、Cglib 代理</h1><h2 id="1-基本介绍-2"><a href="#1-基本介绍-2" class="headerlink" title="1. 基本介绍"></a>1. 基本介绍</h2><ul><li>静态代理和 JDK 代理模式都要求目标对象是实现一个接口,但是有时候目标对象只是一个单独的对象,并没有实 现任何的接口,这个时候可使用目标对象子类来实现代理-这就是 <strong>Cglib 代理</strong></li><li>Cglib代理也叫作子类代理,它是在内存中构建一个子类对象从而实现对目标对象功能扩展,  有些书也将Cglib代 理归属到动态代理。</li><li>Cglib 是一个强大的高性能的代码生成包,它可以在运行期扩展java 类与实现java 接口.它广泛的被许多 AOP 的 框架使用,例如 Spring AOP ，实现方法拦截</li><li>在 AOP 编程中如何选择代理模式：<ul><li>目标对象需要实现接口，用 JDK 代理</li><li>目标对象不需要实现接口，用 Cglib 代理</li></ul></li><li>Cglib 包的底层是通过使用字节码处理框架 ASM 来转换字节码并生成新的类</li></ul><h2 id="2-Cglib-代理模式实现步骤"><a href="#2-Cglib-代理模式实现步骤" class="headerlink" title="2. Cglib 代理模式实现步骤"></a>2. Cglib 代理模式实现步骤</h2><ul><li>需要引入 cglib 的jar 文件<ul><li>asm.jar</li><li>asm-commons.jar</li><li>asm-tree.jar</li><li>cglib-2.2.jar</li></ul></li><li>在内存中动态构建子类，注意<strong>代理的类不能为final</strong> ，否则报错 : java.lang.IllegalArgumentException:</li><li>目标对象的方法<strong>如果为 final&#x2F;static,那么就不会被拦截</strong>, 即不会执行目标对象额外的业务方法.</li></ul><h2 id="3-Cglib-代理模式应用实例"><a href="#3-Cglib-代理模式应用实例" class="headerlink" title="3. Cglib 代理模式应用实例"></a>3. Cglib 代理模式应用实例</h2><p><strong>应用实例要求</strong></p><p>将前面的案例用 Cglib 代理模式实现</p><p><strong>思路图解(类图)</strong></p><p><img src="https://raw.githubusercontent.com/GeorgeChan95/blogimg/master/img/2024/11/22/20241122-002025.png" alt="Cglib 代理UML图"></p><p><strong>代码实现</strong></p><pre><code class="highlight java"><span class="comment">// 目标代理的对象</span><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">TeacherDao</span> &#123;    <span class="keyword">public</span> String <span class="title function_">teach</span><span class="params">()</span> &#123;        System.out.println(<span class="string">&quot; 老师授课中  ， 我是cglib代理，不需要实现接口 &quot;</span>);        <span class="keyword">return</span> <span class="string">&quot;hello&quot;</span>;    &#125;&#125;<span class="comment">// Cglib代理类</span><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ProxyFactory</span> <span class="keyword">implements</span> <span class="title class_">MethodInterceptor</span> &#123;    <span class="keyword">private</span> TeacherDao target;    <span class="keyword">public</span> <span class="title function_">ProxyFactory</span><span class="params">(TeacherDao target)</span> &#123;        <span class="built_in">this</span>.target = target;    &#125;    <span class="comment">//返回一个代理对象:  是 target 对象的代理对象</span>    <span class="keyword">public</span> Object <span class="title function_">getProxyInstance</span><span class="params">()</span> &#123;        <span class="comment">// 创建一个工具类</span>        <span class="type">Enhancer</span> <span class="variable">enhancer</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Enhancer</span>();        <span class="comment">// 设置父类</span>        enhancer.setSuperclass(target.getClass());        <span class="comment">// 设置回调函数</span>        enhancer.setCallback(<span class="built_in">this</span>);        <span class="comment">//4. 创建子类对象，即代理对象</span>        <span class="keyword">return</span> enhancer.create();    &#125;    <span class="comment">//重写  intercept 方法，会调用目标对象的方法</span>    <span class="meta">@Override</span>    <span class="keyword">public</span> Object <span class="title function_">intercept</span><span class="params">(Object o, Method method, Object[] args, MethodProxy methodProxy)</span> <span class="keyword">throws</span> Throwable &#123;        System.out.println(<span class="string">&quot;Cglib代理模式 ~~ 开始&quot;</span>);        <span class="type">Object</span> <span class="variable">resultVal</span> <span class="operator">=</span> method.invoke(target, args);        System.out.println(<span class="string">&quot;Cglib代理模式 ~~ 提交&quot;</span>);        <span class="keyword">return</span> resultVal;    &#125;&#125;<span class="comment">// 测试类</span><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Client</span> &#123;    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;        <span class="type">TeacherDao</span> <span class="variable">target</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">TeacherDao</span>();        <span class="type">TeacherDao</span> <span class="variable">proxyInstance</span> <span class="operator">=</span> (TeacherDao) <span class="keyword">new</span> <span class="title class_">ProxyFactory</span>(target).getProxyInstance();        proxyInstance.teach();    &#125;&#125;</code></pre><blockquote><p>运行结果:</p><pre><code class="highlight shell">Cglib代理模式 ~~ 开始 老师授课中  ， 我是cglib代理，不需要实现接口 Cglib代理模式 ~~ 提交</code></pre></blockquote><h1 id="五、几种常见的代理模式介绍—-几种变体"><a href="#五、几种常见的代理模式介绍—-几种变体" class="headerlink" title="五、几种常见的代理模式介绍— 几种变体"></a>五、几种常见的代理模式介绍— 几种变体</h1><ul><li><p>防火墙代理</p><p>内网通过代理穿透防火墙，实现对公网的访问。</p></li><li><p>缓存代理</p><p>比如：当请求图片文件等资源时，先到缓存代理取，如果取到资源则 ok,如果取不到资源，再到公网或者数据 库取，然后缓存.</p></li><li><p>远程代理</p><p>远程对象的本地代表，通过它可以把远程对象当本地对象来调用。远程代理通过网络和真正的远程对象沟通信息。</p></li><li><p>同步代理</p><p>主要使用在多线程编程中，完成多线程间同步工作.</p></li></ul>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;一、代理模式的基本介绍&quot;&gt;&lt;a href=&quot;#一、代理模式的基本介绍&quot; class=&quot;headerlink&quot; title=&quot;一、代理模式的基本介绍&quot;&gt;&lt;/a&gt;一、代理模式的基本介绍&lt;/h1&gt;&lt;ul&gt;
&lt;li&gt;&lt;p&gt;代理模式：为一个对象提供一个替身，以控制对这个对象</summary>
      
    
    
    
    <category term="设计模式" scheme="https://georgechan95.github.io/categories/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"/>
    
    
    <category term="设计模式" scheme="https://georgechan95.github.io/tags/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"/>
    
  </entry>
  
  <entry>
    <title>13-享元模式</title>
    <link href="https://georgechan95.github.io/blog/1b225c1f.html"/>
    <id>https://georgechan95.github.io/blog/1b225c1f.html</id>
    <published>2024-11-20T15:10:00.000Z</published>
    <updated>2024-11-20T13:28:40.844Z</updated>
    
    <content type="html"><![CDATA[<h1 id="一、展示网站项目需求"><a href="#一、展示网站项目需求" class="headerlink" title="一、展示网站项目需求"></a>一、展示网站项目需求</h1><p>当前假设有一个项目，给客户 A 做一个产品展示网站，客户 A 的朋友感觉效果不错，也希望做这样的产品展示网站，但是要求都有些不同：</p><ul><li>有客户要求以新闻的形式发布</li><li>有客户人要求以博客的形式发布</li><li>有客户希望以微信公众号的形式发布</li></ul><p><strong>传统方案解决网站展现项目</strong></p><ul><li>直接复制粘贴一份，然后根据客户不同要求，进行定制修改</li><li>给每个网站租用一个空间</li><li>方案设计示意图</li></ul><p><img src="https://raw.githubusercontent.com/GeorgeChan95/blogimg/master/img/2024/11/20/20241120-205250.png" alt="传统方式"></p><p>传统方案解决网站展现项目存在以下问题：</p><ul><li>需要的网站结构相似度很高，而且都不是高问量网站，如果分成多个虚拟空间来处理，相当于一个相同网站的实例对象很多，造成服务器的资源浪费。</li><li>解决思路：整合到一个网站中，共享其相关的代码和数据，对于硬盘、内存、CPU、数据库空间等服务器资源都可以达成共享，减少服务器资源。</li><li>对于代码来说，由于是一份实例，维护和扩展都更加容易。</li><li>上面的解决思路就可以使用 <strong>享元模式</strong> 来解决。</li></ul><h1 id="二、享元模式基本介绍"><a href="#二、享元模式基本介绍" class="headerlink" title="二、享元模式基本介绍"></a>二、享元模式基本介绍</h1><ul><li>享元模式（Flyweight Pattern）也叫蝇量模式：运用共享技术有效地支持大量细粒度的对象。</li><li>常用于系统底层开发，解决系统的性能问题。像数据库连接池，里面都是创建好的连接对象，在这些连接对象 中有我们需要的则直接拿来用，避免重新创建，如果没有我们需要的，则创建一个。</li><li>享元模式能够解决重复对象的内存浪费的问题，当系统中有大量相似对象，需要缓冲池时。不需总是创建新对 象，可以从缓冲池里拿。这样可以降低系统内存，同时提高效率。</li><li>享元模式经典的应用场景就是池技术了，String 常量池、数据库连接池、缓冲池等等都是享元模式的应用，享元模式是池技术的重要实现方式。</li></ul><h1 id="三、享元模式的原理类图"><a href="#三、享元模式的原理类图" class="headerlink" title="三、享元模式的原理类图"></a>三、享元模式的原理类图</h1><p><img src="https://raw.githubusercontent.com/GeorgeChan95/blogimg/master/img/2024/11/20/20241120-205914.png" alt="享元模式原理图"></p><p><strong>对类图的说明</strong></p><p>对原理图的说明-即(模式的角色及职责)</p><ul><li>FlyWeight：是抽象的享元角色,  他是产品的抽象类,   同时定义出对象的<strong>外部状态</strong>和<strong>内部状态</strong>(后面介绍)   的接口或实现</li><li>ConcreteFlyweight：具体的享元角色，是具体的产品类，实现抽象角色定义的相关业务.</li><li>UnsharedConcreteFlyweight：不可共享的角色，一般不会出现在享元工厂中.</li><li>FlyweightFactory：享元工厂类，用于构建一个池容器（集合），同时提供从池中获取对象的方法</li></ul><h1 id="四、内部状态和外部状态"><a href="#四、内部状态和外部状态" class="headerlink" title="四、内部状态和外部状态"></a>四、内部状态和外部状态</h1><p>比如围棋、五子棋、跳棋，它们都有大量的棋子对象，围棋和五子棋只有黑白两色，跳棋颜色多一点。所以棋子颜色就是棋子的内部状态；而各个棋子之间的差别就是位置的不同。当我们落子后，落子颜色是定的，但位置是变化的，所以棋子坐标就是棋子的外部状态</p><ul><li>享元模式提出了两个要求：<strong>细粒度</strong> 和 <strong>共享对象</strong>。即将对象的信息分为两个部分：<strong>内部状态</strong> 和 <strong>外部状态</strong></li><li><strong>内部状态</strong>：指对象共享出来的信息，存储在享元对象内部且不会随环境的改变而改变。</li><li><strong>外部状态</strong>：指对象得以依赖的一个标记，是随环境改变而改变的、不可共享的状态。</li></ul><p>举个例子：围模理论上有 361 个空位可以放棋子，每盘棋都有可能有两三百个棋子对象产生。因为内存空间有限，一台服务器很难支持更多的玩家玩围模游戏。如果用享元模式来处理棋子，那么棋子对象就可以减少到只有两个实例，这样就很好的解决了对象的开销问题</p><h1 id="五、享元模式解决网站展现项目"><a href="#五、享元模式解决网站展现项目" class="headerlink" title="五、享元模式解决网站展现项目"></a>五、享元模式解决网站展现项目</h1><p><strong>原理类图</strong></p><p><img src="https://raw.githubusercontent.com/GeorgeChan95/blogimg/master/img/2024/11/20/20241120-210641.png" alt="享元模式"></p><p><strong>UML 类图</strong></p><p><img src="https://raw.githubusercontent.com/GeorgeChan95/blogimg/master/img/2024/11/20/20241120-210648.png" alt="img"></p><p><strong>代码如下：</strong></p><pre><code class="highlight java"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">User</span> &#123;    <span class="keyword">private</span> String name;    <span class="comment">// 省略 get/set 构造方法</span>&#125;<span class="comment">// 抽象的享元对象</span><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">class</span> <span class="title class_">WebSite</span> &#123;    <span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">void</span> <span class="title function_">use</span><span class="params">(User user)</span>;&#125;<span class="comment">// 具体的享元角色</span><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ConcreteWebSite</span> <span class="keyword">extends</span> <span class="title class_">WebSite</span> &#123;    <span class="comment">// 网站类型，享元模式中的内部状态</span>    <span class="keyword">private</span> String type;    <span class="keyword">public</span> <span class="title function_">ConcreteWebSite</span><span class="params">(String type)</span> &#123;        <span class="built_in">this</span>.type = type;    &#125;    <span class="meta">@Override</span>    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">use</span><span class="params">(User user)</span> &#123;        System.out.println(<span class="string">&quot;网站的发布形式为:&quot;</span> + type + <span class="string">&quot; 在使用中 .. 使用者是&quot;</span> + user.getName());    &#125;&#125;<span class="comment">// 享元工厂</span><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">WebSiteFactory</span> &#123;    <span class="comment">// 共享数据池</span>    <span class="keyword">private</span> Map&lt;String, WebSite&gt; pool = <span class="keyword">new</span> <span class="title class_">HashMap</span>&lt;&gt;();    <span class="comment">// 根据网站的类型，返回一个网站, 如果没有就创建一个网站，并放入到池中,并返回</span>    <span class="keyword">public</span> WebSite <span class="title function_">getWebSiteCategory</span><span class="params">(String type)</span> &#123;        <span class="keyword">if</span> (!pool.containsKey(type)) &#123;            <span class="comment">// 创建一个网站，并放入到池中</span>            pool.put(type, <span class="keyword">new</span> <span class="title class_">ConcreteWebSite</span>(type));        &#125;        <span class="keyword">return</span> pool.get(type);    &#125;    <span class="comment">// 获取网站分类的总数 (池中有多少个网站类型)</span>    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">getWebSiteCount</span><span class="params">()</span> &#123;        <span class="keyword">return</span> pool.size();    &#125;&#125;<span class="comment">// 测试类</span><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Client</span> &#123;    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;        <span class="type">WebSiteFactory</span> <span class="variable">factory</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">WebSiteFactory</span>();        <span class="comment">// 新闻形式的网站</span>        <span class="type">WebSite</span> <span class="variable">webSite1</span> <span class="operator">=</span> factory.getWebSiteCategory(<span class="string">&quot;新闻&quot;</span>);        webSite1.use(<span class="keyword">new</span> <span class="title class_">User</span>(<span class="string">&quot;Tom&quot;</span>));        <span class="comment">// 博客形式的网站</span>        <span class="type">WebSite</span> <span class="variable">webSite2</span> <span class="operator">=</span> factory.getWebSiteCategory(<span class="string">&quot;博客&quot;</span>);        webSite2.use(<span class="keyword">new</span> <span class="title class_">User</span>(<span class="string">&quot;Jack&quot;</span>));        <span class="type">int</span> <span class="variable">webSiteCount</span> <span class="operator">=</span> factory.getWebSiteCount();        System.out.println(<span class="string">&quot;网站分类数：&quot;</span> + webSiteCount);    &#125;&#125;</code></pre><blockquote><p>运行结果：</p><pre><code class="highlight shell">网站的发布形式为:新闻 在使用中 .. 使用者是Tom网站的发布形式为:博客 在使用中 .. 使用者是Jack网站分类数：2</code></pre></blockquote><h1 id="六、享元模式在JDK源码中的应用-Integer类"><a href="#六、享元模式在JDK源码中的应用-Integer类" class="headerlink" title="六、享元模式在JDK源码中的应用-Integer类"></a>六、享元模式在JDK源码中的应用-Integer类</h1><p>首先先看一段代码测试</p><pre><code class="highlight java"><span class="type">Integer</span> <span class="variable">x</span> <span class="operator">=</span> Integer.valueOf(<span class="number">127</span>);<span class="type">Integer</span> <span class="variable">y</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Integer</span>(<span class="number">127</span>);<span class="type">Integer</span> <span class="variable">z</span> <span class="operator">=</span> Integer.valueOf(<span class="number">127</span>);<span class="type">Integer</span> <span class="variable">w</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Integer</span>(<span class="number">127</span>);System.out.println(x.equals(y)); <span class="comment">// true</span>System.out.println(x == y);      <span class="comment">// false</span>System.out.println(x == z);      <span class="comment">// true</span>System.out.println(w == x);      <span class="comment">// false</span>System.out.println(w == y);      <span class="comment">// false</span></code></pre><p>我们知道：<code>equals</code>比较的是对象的内容，<code>==</code>比较的是对象的实例</p><ul><li><p><code>x.equals(y)</code>结果为<code>true</code>：比较的是大小，所以结果为<code>true</code></p></li><li><p><code>x == y</code>、<code>w == x</code>、<code>w == y</code>结果为<code>false</code>：由于 y 是 new 出来的，所以结果为<code>false</code></p></li><li><p><code>x == z</code>结果为<code>true</code>：<strong>这是为什么呢？？？</strong></p></li></ul><p>我们追踪一下<code>Integer</code>对象的<code>valueOf</code>方法，看一下源码</p><pre><code class="highlight java"><span class="keyword">public</span> <span class="keyword">static</span> Integer <span class="title function_">valueOf</span><span class="params">(<span class="type">int</span> i)</span> &#123;    <span class="keyword">if</span> (i &gt;= IntegerCache.low &amp;&amp; i &lt;= IntegerCache.high)        <span class="keyword">return</span> IntegerCache.cache[i + (-IntegerCache.low)];    <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">Integer</span>(i);&#125;</code></pre><p>这里的<code>low</code>和<code>high</code>是多少呢？</p><pre><code class="highlight java"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">class</span> <span class="title class_">IntegerCache</span> &#123;    <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">int</span> <span class="variable">low</span> <span class="operator">=</span> -<span class="number">128</span>;    <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">int</span> high;    <span class="keyword">static</span> <span class="keyword">final</span> Integer cache[];    <span class="keyword">static</span> &#123;        <span class="comment">// high value may be configured by property</span>        <span class="type">int</span> <span class="variable">h</span> <span class="operator">=</span> <span class="number">127</span>;        <span class="type">String</span> <span class="variable">integerCacheHighPropValue</span> <span class="operator">=</span>            sun.misc.VM.getSavedProperty(<span class="string">&quot;java.lang.Integer.IntegerCache.high&quot;</span>);        <span class="keyword">if</span> (integerCacheHighPropValue != <span class="literal">null</span>) &#123;            <span class="keyword">try</span> &#123;                <span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> parseInt(integerCacheHighPropValue);                i = Math.max(i, <span class="number">127</span>);                <span class="comment">// Maximum array size is Integer.MAX_VALUE</span>                h = Math.min(i, Integer.MAX_VALUE - (-low) -<span class="number">1</span>);            &#125; <span class="keyword">catch</span>( NumberFormatException nfe) &#123;                <span class="comment">// If the property cannot be parsed into an int, ignore it.</span>            &#125;        &#125;        high = h;        cache = <span class="keyword">new</span> <span class="title class_">Integer</span>[(high - low) + <span class="number">1</span>];        <span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> low;        <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">k</span> <span class="operator">=</span> <span class="number">0</span>; k &lt; cache.length; k++)            cache[k] = <span class="keyword">new</span> <span class="title class_">Integer</span>(j++);        <span class="comment">// range [-128, 127] must be interned (JLS7 5.1.7)</span>        <span class="keyword">assert</span> IntegerCache.high &gt;= <span class="number">127</span>;    &#125;    <span class="keyword">private</span> <span class="title function_">IntegerCache</span><span class="params">()</span> &#123;&#125;&#125;</code></pre><p>我们通过<code>IntegerCache</code>中源码大概基本分析出</p><ul><li><p><code>low</code>为<code>-128</code></p></li><li><p><code>high</code>为<code>127</code></p></li></ul><p>所以当<code>Integer</code>在<code>[-128, 127]</code>时，会返回<code>IntegerCache</code>的<code>cache[]</code>数组内容；否则，<code>valueOf</code>方法相当于<code>new Integer</code>了。也就是说，<code>Integer.valueOf(x)</code>方法使用的就是<strong>享元模式</strong>。</p><p>另外，我们也可以分析出：</p><ul><li>当数值范围在<code>[-128, 127]</code>时，使用<code>valueOf</code>方法执行速度比<code>new</code>更快</li></ul><h1 id="七、享元模式的注意事项和细节"><a href="#七、享元模式的注意事项和细节" class="headerlink" title="七、享元模式的注意事项和细节"></a>七、享元模式的注意事项和细节</h1><ul><li>在享元模式这样理解，“享”就表示共享，“元”表示对象</li><li>系统中有大量对象，这些对象消耗大量内存，并且对象的状态大部分可以外部化时，我们就可以考虑选用享元模式</li><li>用唯一标识码判断，如果在内存中有，则返回这个唯一标识码所标识的对象，用 HashMap&#x2F;HashTable 存储</li><li>享元模式大大减少了对象的创建，降低了程序内存的占用，提高效率</li><li>享元模式提高了系统的复杂度，需要分离出内部状态和外部状态。而内部状态具有固化特性，不应该随着外部状态的改变而改变，这是我们使用享元模式需要注意的地方</li><li>使用享元模式时，注意划分内部状态和外部状态，并且需要有一个工厂类加以控制</li><li>享元模式经典的应用场景是需要缓冲池的场景，比如 String 常量池、数据库连接池</li></ul>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;一、展示网站项目需求&quot;&gt;&lt;a href=&quot;#一、展示网站项目需求&quot; class=&quot;headerlink&quot; title=&quot;一、展示网站项目需求&quot;&gt;&lt;/a&gt;一、展示网站项目需求&lt;/h1&gt;&lt;p&gt;当前假设有一个项目，给客户 A 做一个产品展示网站，客户 A 的朋友感觉效果</summary>
      
    
    
    
    <category term="设计模式" scheme="https://georgechan95.github.io/categories/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"/>
    
    
    <category term="设计模式" scheme="https://georgechan95.github.io/tags/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"/>
    
  </entry>
  
  <entry>
    <title>12-外观模式</title>
    <link href="https://georgechan95.github.io/blog/906e9e8b.html"/>
    <id>https://georgechan95.github.io/blog/906e9e8b.html</id>
    <published>2024-11-20T14:09:00.000Z</published>
    <updated>2024-11-20T12:34:56.315Z</updated>
    
    <content type="html"><![CDATA[<h1 id="一、外观模式的定义"><a href="#一、外观模式的定义" class="headerlink" title="一、外观模式的定义"></a>一、外观模式的定义</h1><p>外观（Facade）模式的定义：又叫门面模式，是一种通过为多个复杂的子系统提供一个一致的接口，而使这些子系统更加容易被访问的模式。该模式对外有一个统一接口，外部应用程序不用关心内部子系统的具体的细节，这样会大大降低应用程序的复杂度，提高了程序的可维护性。</p><h1 id="二、外观模式优缺点"><a href="#二、外观模式优缺点" class="headerlink" title="二、外观模式优缺点"></a>二、外观模式优缺点</h1><p><strong>优点：</strong></p><ul><li>简化了调用过程，无需了解深入子系统，防止带来风险</li><li>减少系统依赖、松散耦合</li><li>更好的划分访问层次</li><li>符合迪米特法则，即最少知道原则</li></ul><p><strong>缺点：</strong></p><ul><li>增加子系统、扩展子系统行为容易引入风险</li><li>不符合开闭原则</li></ul><h1 id="三、外观模式的实现"><a href="#三、外观模式的实现" class="headerlink" title="三、外观模式的实现"></a>三、外观模式的实现</h1><p>外观（Facade）模式的结构比较简单，主要是定义了一个高层接口。它包含了对各个子系统的引用，客户端可以通过它访问各个子系统的功能。现在来分析其基本结构和实现方法。</p><p>外观（Facade）模式包含以下主要角色。</p><ul><li>外观（Facade）角色：为多个子系统对外提供一个共同的接口。</li><li>子系统（Sub System）角色：实现系统的部分功能，客户可以通过外观角色访问它。</li><li>客户（Client）角色：通过一个外观角色访问各个子系统的功能。</li></ul><p>其结构图如图所示:</p><img src="https://raw.githubusercontent.com/GeorgeChan95/blogimg/master/img/2024/11/20/20241120-195658.png" alt="外观模式结构图" style="zoom:50%;" /><p>代码常见有两种情况都是属于外观模式，如下代码：</p><p><strong>所有子系统实现统一接口</strong></p><pre><code class="highlight java"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">MySystem</span> &#123;    <span class="keyword">void</span> <span class="title function_">dosomething</span><span class="params">()</span>;&#125;<span class="comment">// 子系统A</span><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">SubSystemA</span> <span class="keyword">implements</span> <span class="title class_">MySystem</span> &#123;    <span class="meta">@Override</span>    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">dosomething</span><span class="params">()</span> &#123;        System.out.println(<span class="string">&quot;子系统方法A&quot;</span>);    &#125;&#125;<span class="comment">// 子系统B</span><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">SubSystemB</span> <span class="keyword">implements</span> <span class="title class_">MySystem</span> &#123;    <span class="meta">@Override</span>    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">dosomething</span><span class="params">()</span> &#123;        System.out.println(<span class="string">&quot;子系统方法B &quot;</span>);    &#125;&#125;<span class="comment">// 外观类</span><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Facade</span> &#123;    <span class="keyword">private</span> SubSystemA systemA;    <span class="keyword">private</span> SubSystemB systemB;    <span class="keyword">public</span> <span class="title function_">Facade</span><span class="params">()</span> &#123;        <span class="built_in">this</span>.systemA = <span class="keyword">new</span> <span class="title class_">SubSystemA</span>();        <span class="built_in">this</span>.systemB = <span class="keyword">new</span> <span class="title class_">SubSystemB</span>();    &#125;    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">methodA</span><span class="params">()</span> &#123;        systemA.dosomething();    &#125;    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">methodB</span><span class="params">()</span> &#123;        systemB.dosomething();    &#125;&#125;<span class="comment">// 测试类</span><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Client</span> &#123;    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;        <span class="type">Facade</span> <span class="variable">facade</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Facade</span>();        facade.methodA();        facade.methodB();    &#125;&#125;</code></pre><blockquote><p>运行结果：</p><pre><code class="highlight shell">子系统方法A子系统方法B</code></pre></blockquote><p><strong>所有子系统未实现统一接口</strong></p><pre><code class="highlight java"><span class="comment">// 子系统A</span><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">SubSystemA</span> &#123;    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">dosomething</span><span class="params">()</span> &#123;        System.out.println(<span class="string">&quot;子系统方法AA&quot;</span>);    &#125;&#125;<span class="comment">// 子系统B</span><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">SubSystemB</span> &#123;    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">dosomething</span><span class="params">()</span> &#123;        System.out.println(<span class="string">&quot;子系统方法BB &quot;</span>);    &#125;&#125;<span class="comment">// 外观类</span><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Facade</span> &#123;    <span class="keyword">private</span> SubSystemA systemA;    <span class="keyword">private</span> SubSystemB systemB;    <span class="keyword">public</span> <span class="title function_">Facade</span><span class="params">()</span> &#123;        <span class="built_in">this</span>.systemA = <span class="keyword">new</span> <span class="title class_">SubSystemA</span>();        <span class="built_in">this</span>.systemB = <span class="keyword">new</span> <span class="title class_">SubSystemB</span>();    &#125;    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">methodA</span><span class="params">()</span> &#123;        <span class="built_in">this</span>.systemA.dosomething();    &#125;    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">methodB</span><span class="params">()</span> &#123;        <span class="built_in">this</span>.systemB.dosomething();    &#125;&#125;<span class="comment">// 测试类</span><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Client</span> &#123;    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;        <span class="type">Facade</span> <span class="variable">facade</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Facade</span>();        facade.methodA();        facade.methodB();    &#125;&#125;</code></pre><blockquote><p>运行结果：</p><pre><code class="highlight shell">子系统方法AA子系统方法BB</code></pre></blockquote><h1 id="四、外观模式的应用场景"><a href="#四、外观模式的应用场景" class="headerlink" title="四、外观模式的应用场景"></a>四、外观模式的应用场景</h1><p>通常在以下情况下可以考虑使用外观模式。</p><ul><li>子系统越来越复杂，增加外观模式提供简单接口调用</li><li>构建多层系统结构，利用外观对象作为每层的入口，简化层间调用</li></ul><h1 id="五、外观模式的扩展"><a href="#五、外观模式的扩展" class="headerlink" title="五、外观模式的扩展"></a>五、外观模式的扩展</h1><p>在外观模式中，当增加或移除子系统时需要修改外观类，这违背了“开闭原则”。如果引入抽象外观类，则在一定程度上解决了该问题，其结构图如图所示：</p><img src="https://raw.githubusercontent.com/GeorgeChan95/blogimg/master/img/2024/11/20/20241120-201927.png" alt="引入抽象外观类" style="zoom:50%;" /><p>代码如下：</p><pre><code class="highlight java"><span class="comment">// 抽象外观类</span><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">Facade</span> &#123;    <span class="keyword">void</span> <span class="title function_">method</span><span class="params">()</span>;&#125;<span class="comment">// 具体外观类A</span><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">FacadeImplA</span> <span class="keyword">implements</span> <span class="title class_">Facade</span> &#123;    <span class="type">SubSystem1</span> <span class="variable">subSystem1</span> <span class="operator">=</span> <span class="literal">null</span>;    <span class="type">SubSystem2</span> <span class="variable">subSystem2</span> <span class="operator">=</span> <span class="literal">null</span>;    <span class="type">SubSystem3</span> <span class="variable">subSystem3</span> <span class="operator">=</span> <span class="literal">null</span>;    <span class="keyword">public</span> <span class="title function_">FacadeImplA</span><span class="params">()</span> &#123;        subSystem1 = <span class="keyword">new</span> <span class="title class_">SubSystem1</span>();        subSystem2 = <span class="keyword">new</span> <span class="title class_">SubSystem2</span>();        subSystem3 = <span class="keyword">new</span> <span class="title class_">SubSystem3</span>();    &#125;    <span class="meta">@Override</span>    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">method</span><span class="params">()</span> &#123;        subSystem1.method1();        subSystem2.method2();        subSystem3.method3();    &#125;&#125;<span class="comment">// 具体外观类B</span><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">FacadeImplB</span> <span class="keyword">implements</span> <span class="title class_">Facade</span> &#123;    <span class="type">SubSystem2</span> <span class="variable">subSystem2</span> <span class="operator">=</span> <span class="literal">null</span>;    <span class="type">SubSystem3</span> <span class="variable">subSystem3</span> <span class="operator">=</span> <span class="literal">null</span>;    <span class="type">SubSystem4</span> <span class="variable">subSystem4</span> <span class="operator">=</span> <span class="literal">null</span>;    <span class="keyword">public</span> <span class="title function_">FacadeImplB</span><span class="params">()</span> &#123;        subSystem2 = <span class="keyword">new</span> <span class="title class_">SubSystem2</span>();        subSystem3 = <span class="keyword">new</span> <span class="title class_">SubSystem3</span>();        subSystem4 = <span class="keyword">new</span> <span class="title class_">SubSystem4</span>();    &#125;    <span class="meta">@Override</span>    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">method</span><span class="params">()</span> &#123;        subSystem2.method2();        subSystem3.method3();        subSystem4.method4();    &#125;&#125;<span class="comment">// 子系统类1</span><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">SubSystem1</span> &#123;    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">method1</span><span class="params">()</span> &#123;        System.out.println(<span class="string">&quot;子系统1的method1()被调用！&quot;</span>);    &#125;&#125;<span class="comment">// 子系统类2</span><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">SubSystem2</span> &#123;    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">method2</span><span class="params">()</span> &#123;        System.out.println(<span class="string">&quot;子系统2的method2()被调用！&quot;</span>);    &#125;&#125;<span class="comment">// 子系统类3</span><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">SubSystem3</span> &#123;    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">method3</span><span class="params">()</span> &#123;        System.out.println(<span class="string">&quot;子系统3的method3()被调用！&quot;</span>);    &#125;&#125;<span class="comment">// 子系统类4</span><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">SubSystem4</span> &#123;    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">method4</span><span class="params">()</span> &#123;        System.out.println(<span class="string">&quot;子系统4的method4()被调用！&quot;</span>);    &#125;&#125;<span class="comment">// 测试类</span><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Client</span> &#123;    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;        <span class="type">Facade</span> <span class="variable">facade1</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">FacadeImplA</span>();        facade1.method();        <span class="type">Facade</span> <span class="variable">facade2</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">FacadeImplB</span>();        facade2.method();    &#125;&#125;</code></pre><blockquote><p>运行结果：</p><pre><code class="highlight shell">子系统1的method1()被调用！子系统2的method2()被调用！子系统3的method3()被调用！子系统2的method2()被调用！子系统3的method3()被调用！子系统4的method4()被调用！</code></pre></blockquote><h1 id="六、外观模式的注意事项和细节"><a href="#六、外观模式的注意事项和细节" class="headerlink" title="六、外观模式的注意事项和细节"></a>六、外观模式的注意事项和细节</h1><ul><li>外观模式对外屏蔽了子系统的细节，因此外观模式降低了客户端对子系统使用的复杂性</li><li>外观模式对客户端与子系统的耦合关系 -  解耦，让子系统内部的模块更易维护和扩展</li><li>通过合理的使用外观模式，可以帮我们更好的划分访问的层次</li><li>当系统需要进行分层设计时，可以考虑使用Facade 模式</li><li>在维护一个遗留的大型系统时，可能这个系统已经变得非常难以维护和扩展，此时可以考虑为新系统开发一个 Facade 类，来提供遗留系统的比较清晰简单的接口，让新系统与 Facade 类交互，提高复用性。</li><li>不能过多的或者不合理的使用外观模式，使用外观模式好，还是直接调用模块好。要以让系统有层次，利于维 护为目的。</li></ul>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;一、外观模式的定义&quot;&gt;&lt;a href=&quot;#一、外观模式的定义&quot; class=&quot;headerlink&quot; title=&quot;一、外观模式的定义&quot;&gt;&lt;/a&gt;一、外观模式的定义&lt;/h1&gt;&lt;p&gt;外观（Facade）模式的定义：又叫门面模式，是一种通过为多个复杂的子系统提供一个一</summary>
      
    
    
    
    <category term="设计模式" scheme="https://georgechan95.github.io/categories/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"/>
    
    
    <category term="设计模式" scheme="https://georgechan95.github.io/tags/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"/>
    
  </entry>
  
  <entry>
    <title>11-组合模式</title>
    <link href="https://georgechan95.github.io/blog/c456a66a.html"/>
    <id>https://georgechan95.github.io/blog/c456a66a.html</id>
    <published>2024-11-16T09:00:00.000Z</published>
    <updated>2024-11-20T12:35:57.137Z</updated>
    
    <content type="html"><![CDATA[<h1 id="一、什么是组合模式"><a href="#一、什么是组合模式" class="headerlink" title="一、什么是组合模式?"></a>一、什么是组合模式?</h1><p>组合模式定义了如何将容器对象和叶子对象进行递归组合，使得客户在使用的过程中无须进行区分到底是容器对象还是叶子对象，可以对他们进行一致的处理。</p><p>组合模式通过组合多个对象形成树形结构来表示“整体-部分”的结构层次。</p><p>组合模式对单个对象(叶子对象)和组合对象(组合对象)具有一致性，它将对象组织到树结构中，可以用来描述整体与部分的关系。同时它也模糊了**简单元素(叶子对象)和复杂元素(容器对象)**的概念，使得客户能够像处理简单元素一样来处理复杂元素，从而使客户程序能够与复杂元素的内部结构解耦。</p><p>到底是什么意思呢? 来看看下面的图片:</p><p><img src="https://raw.githubusercontent.com/GeorgeChan95/blogimg/master/img/2024/11/19/20241119-225338.png" alt="组合模式的示例"></p><p>现在有文件夹, 文件夹下可以有文件和文件夹. 这种递归调用, 我们拆分来看, 文件可以看做是叶子节点, 文件夹可以看做是容器. 文件夹容器下还有文件和文件夹. 使用组合模式来实现他们之间的关系.</p><p><strong>组合模式的关键是: 设计一个抽象的组合类, 让它可以代表组合对象和叶子对象。这样的好处是，客户端不需要区分到底是组合对象还是叶子对象了，只需要全部当成组合对象来处理即可。</strong></p><h1 id="二、组合模式的结构和案例"><a href="#二、组合模式的结构和案例" class="headerlink" title="二、组合模式的结构和案例"></a>二、组合模式的结构和案例</h1><h2 id="1-案例一-文件结构"><a href="#1-案例一-文件结构" class="headerlink" title="1. 案例一: 文件结构"></a>1. 案例一: 文件结构</h2><p>下面就来看看如何实现文件结构. 先来看看UML图:</p><p><img src="https://raw.githubusercontent.com/GeorgeChan95/blogimg/master/img/2024/11/19/20241119-201713.png" alt="组合模式-文件结构"></p><p>首先定义一个抽象类 <code>File</code>, 然后单个的具体文件和文件夹都实现了抽象文件接口, 在文件夹接口里面还有一个存放抽象文件的集合. 实现了文件和文件夹的组合.</p><p><strong>代码实现:</strong></p><pre><code class="highlight java"><span class="comment">// 抽象类</span><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">class</span> <span class="title class_">File</span> &#123;    <span class="keyword">public</span> String name;    <span class="keyword">public</span> <span class="title function_">File</span><span class="params">(String name)</span> &#123;        <span class="built_in">this</span>.name = name;    &#125;    <span class="comment">/**</span><span class="comment">     * 文件打印</span><span class="comment">     */</span>    <span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">void</span> <span class="title function_">show</span><span class="params">()</span>;&#125;<span class="comment">// 文本文件</span><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">TextFile</span> <span class="keyword">extends</span> <span class="title class_">File</span> &#123; <span class="comment">// 继承File</span>    <span class="keyword">public</span> <span class="title function_">TextFile</span><span class="params">(String name)</span> &#123;        <span class="built_in">super</span>(name);    &#125;    <span class="meta">@Override</span>    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">show</span><span class="params">()</span> &#123;        System.out.println(<span class="string">&quot;文本文件展示-----------&quot;</span>);    &#125;&#125;<span class="comment">// 图像文件</span><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ImageFile</span> <span class="keyword">extends</span> <span class="title class_">File</span> &#123; <span class="comment">// 继承File</span>    <span class="keyword">public</span> <span class="title function_">ImageFile</span><span class="params">(String name)</span> &#123;        <span class="built_in">super</span>(name);    &#125;    <span class="meta">@Override</span>    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">show</span><span class="params">()</span> &#123;        System.out.println(<span class="string">&quot;图片文件展示-----------&quot;</span>);    &#125;&#125;<span class="comment">// 音频文件</span><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">AudioFile</span> <span class="keyword">extends</span> <span class="title class_">File</span> &#123; <span class="comment">// 继承File</span>    <span class="keyword">public</span> <span class="title function_">AudioFile</span><span class="params">(String name)</span> &#123;        <span class="built_in">super</span>(name);    &#125;    <span class="meta">@Override</span>    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">show</span><span class="params">()</span> &#123;        System.out.println(<span class="string">&quot;图片文件展示-----------&quot;</span>);    &#125;&#125;<span class="comment">// 视频文件</span><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">VideoFile</span> <span class="keyword">extends</span> <span class="title class_">File</span> &#123; <span class="comment">// 继承File</span>    <span class="keyword">public</span> <span class="title function_">VideoFile</span><span class="params">(String name)</span> &#123;        <span class="built_in">super</span>(name);    &#125;    <span class="meta">@Override</span>    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">show</span><span class="params">()</span> &#123;        System.out.println(<span class="string">&quot;视频文件展示-----------&quot;</span>);    &#125;&#125;<span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Folder</span> <span class="keyword">extends</span> <span class="title class_">File</span> &#123; <span class="comment">// 继承File</span>    <span class="comment">// 组合File</span>    <span class="keyword">private</span> List&lt;File&gt; files = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();    <span class="keyword">public</span> <span class="title function_">Folder</span><span class="params">(String name)</span> &#123;        <span class="built_in">super</span>(name);    &#125;    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">add</span><span class="params">(File file)</span> &#123;        files.add(file);    &#125;    <span class="meta">@Override</span>    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">show</span><span class="params">()</span> &#123; <span class="comment">// 递归调用 show() 方法</span>        System.out.println(<span class="string">&quot;这是 &quot;</span> + <span class="built_in">this</span>.name + <span class="string">&quot; 的show方法&quot;</span>);        <span class="keyword">for</span> (File file : files) &#123;            file.show();        &#125;    &#125;&#125;<span class="comment">// 测试类</span><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">FileClient</span> &#123;    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;        <span class="type">File</span> <span class="variable">textFile1</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">TextFile</span>(<span class="string">&quot;text1文件&quot;</span>);        <span class="type">File</span> <span class="variable">imageFile1</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ImageFile</span>(<span class="string">&quot;image1文件&quot;</span>);        <span class="type">File</span> <span class="variable">audioFile1</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">AudioFile</span>(<span class="string">&quot;audio1文件&quot;</span>);        <span class="type">File</span> <span class="variable">videoFile1</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">VideoFile</span>(<span class="string">&quot;video1文件&quot;</span>);        <span class="type">Folder</span> <span class="variable">folder1</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Folder</span>(<span class="string">&quot;folder1&quot;</span>);        folder1.add(textFile1);        folder1.add(imageFile1);        folder1.add(audioFile1);        folder1.add(videoFile1);        <span class="type">File</span> <span class="variable">textFile2</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">TextFile</span>(<span class="string">&quot;text2文件&quot;</span>);        <span class="type">File</span> <span class="variable">imageFile2</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ImageFile</span>(<span class="string">&quot;image2文件&quot;</span>);        <span class="type">Folder</span> <span class="variable">folder2</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Folder</span>(<span class="string">&quot;folder2&quot;</span>);        folder2.add(textFile2);        folder2.add(imageFile2);        <span class="comment">// 将文件夹2 添加到文件夹1中</span>        folder1.add(folder2);        folder1.show();    &#125;&#125;</code></pre><blockquote><p>运行结果：</p><pre><code class="highlight shell">这是 folder1 的show方法文本文件展示-----------图片文件展示-----------图片文件展示-----------视频文件展示-----------这是 folder2 的show方法文本文件展示-----------图片文件展示-----------</code></pre></blockquote><p>最终展示的文件效果如下：</p><p><img src="https://raw.githubusercontent.com/GeorgeChan95/blogimg/master/img/2024/11/19/20241119-203431.png" alt="文件组合结果示意"></p><h2 id="2-案例二-公司组织架构"><a href="#2-案例二-公司组织架构" class="headerlink" title="2. 案例二: 公司组织架构"></a>2. 案例二: 公司组织架构</h2><p>先来看uml图: </p><p><img src="https://raw.githubusercontent.com/GeorgeChan95/blogimg/master/img/2024/11/19/20241119-203859.png" alt="组合模式-部门"></p><p>这里面通常公司下面会下设很多部门, 部门下面在设置子部门, 其组织架构如下图:</p><p><img src="https://raw.githubusercontent.com/GeorgeChan95/blogimg/master/img/2024/11/19/20241119-204031.png" alt="组织架构图"></p><p><strong>代码实现</strong> </p><pre><code class="highlight java"><span class="comment">// 第一步: 部门抽象接口</span><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">Department</span> &#123;    <span class="comment">// 打印部门信息</span>    <span class="keyword">void</span> <span class="title function_">show</span><span class="params">()</span>;&#125;<span class="comment">// 第二步: 叶子部门, 下面没有其他任何部门</span><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">LeafDepartment</span> <span class="keyword">implements</span> <span class="title class_">Department</span> &#123;    <span class="comment">// 部门名称</span>    <span class="keyword">public</span> String name;    <span class="keyword">public</span> <span class="title function_">LeafDepartment</span><span class="params">(String name)</span> &#123;        <span class="built_in">this</span>.name = name;    &#125;    <span class="meta">@Override</span>    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">show</span><span class="params">()</span> &#123;        System.out.println(<span class="built_in">this</span>.name);    &#125;&#125;<span class="comment">// 第三步: 聚合部门, 也就是下面还有子部门</span><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">AggregateDepartment</span> <span class="keyword">implements</span> <span class="title class_">Department</span> &#123;    <span class="keyword">private</span> String name;    <span class="comment">// 聚合下属部门</span>    List&lt;Department&gt; departmentList = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();    <span class="keyword">public</span> <span class="title function_">AggregateDepartment</span><span class="params">(String name)</span> &#123;        <span class="built_in">this</span>.name = name;    &#125;    <span class="comment">// 添加部门</span>    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">addDepartment</span><span class="params">(Department department)</span> &#123;        departmentList.add(department);    &#125;    <span class="meta">@Override</span>    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">show</span><span class="params">()</span> &#123;        System.out.println(<span class="string">&quot;当前部门为：&quot;</span> + <span class="built_in">this</span>.name + <span class="string">&quot; 下属部门为：&quot;</span>);        <span class="keyword">for</span> (Department department : departmentList) &#123;            department.show();        &#125;    &#125;&#125;<span class="comment">// 第四步: 客户端调用</span><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">DepartmentClient</span> &#123;    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;        <span class="type">AggregateDepartment</span> <span class="variable">company</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">AggregateDepartment</span>(<span class="string">&quot;公司&quot;</span>);        <span class="type">Department</span> <span class="variable">fawu</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">LeafDepartment</span>(<span class="string">&quot;法务部&quot;</span>);        <span class="type">Department</span> <span class="variable">xingzheng</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">LeafDepartment</span>(<span class="string">&quot;行政部&quot;</span>);        <span class="type">Department</span> <span class="variable">renshi</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">LeafDepartment</span>(<span class="string">&quot;人事部&quot;</span>);        <span class="type">AggregateDepartment</span> <span class="variable">jishu</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">AggregateDepartment</span>(<span class="string">&quot;技术部&quot;</span>);        <span class="type">Department</span> <span class="variable">java</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">LeafDepartment</span>(<span class="string">&quot;Java事业部&quot;</span>);        <span class="type">Department</span> <span class="variable">c</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">LeafDepartment</span>(<span class="string">&quot;C++事业部&quot;</span>);        <span class="type">Department</span> <span class="variable">go</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">LeafDepartment</span>(<span class="string">&quot;GO事业部&quot;</span>);        <span class="type">Department</span> <span class="variable">front</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">LeafDepartment</span>(<span class="string">&quot;大前端事业部&quot;</span>);        company.addDepartment(fawu);        company.addDepartment(xingzheng);        company.addDepartment(renshi);        company.addDepartment(jishu);        jishu.addDepartment(java);        jishu.addDepartment(c);        jishu.addDepartment(go);        jishu.addDepartment(front);        company.show();    &#125;&#125;</code></pre><blockquote><p>运行结果：</p><pre><code class="highlight shell">当前部门为：公司 下属部门为：法务部行政部人事部当前部门为：技术部 下属部门为：Java事业部C++事业部GO事业部大前端事业部</code></pre></blockquote><p>通过组合模式, 我们就将一个公司的组织架构画出来了, 即使是更复杂的架构, 使用这种方式也可实现.</p><h1 id="三、组合模式的使用场景"><a href="#三、组合模式的使用场景" class="headerlink" title="三、组合模式的使用场景"></a>三、组合模式的使用场景</h1><p>组合模式在我们日常生活中非常常见, 比如: 公司组织架构中架构关系. 总公司和分公司的关系, 下面分析它适用的以下应用场景。</p><ul><li>在需要表示一个对象整体与部分的层次结构的场合。</li><li>要求对用户隐藏组合对象与单个对象的不同，用户可以用统一的接口使用组合结构中的所有对象的场合。</li></ul><h1 id="四、组合模式的总结"><a href="#四、组合模式的总结" class="headerlink" title="四、组合模式的总结"></a>四、组合模式的总结</h1><ul><li>简化客户端操作。客户端只需要面对一致的对象而不用考虑整体部分或者节点叶子的问题。</li><li>具有较强的扩展性。当我们要更改组合对象时，我们只需要调整内部的层次关系，客户端不用做出任何改动.</li><li>方便创建出复杂的层次结构。客户端不用理会组合里面的组成细节，容易添加节点或者叶子从而创建出复杂的 树形结构</li><li><strong>方便创建出复杂的层次结构。客户端不用理会组合里面的组成细节，容易添加节点或者叶子从而创建出复杂的 树形结构</strong></li><li>要求较高的抽象性，如果节点和叶子有很多差异性的话，比如很多方法和属性都不一样，不适合使用组合模式</li></ul><h1 id="五、组合模式对设计模式六大原则的运用"><a href="#五、组合模式对设计模式六大原则的运用" class="headerlink" title="五、组合模式对设计模式六大原则的运用"></a>五、组合模式对设计模式六大原则的运用</h1><ul><li>单一职责原则: 一个接口只做一件事</li><li>里式替换原则: 父类出现的地方都可以使用子类替换, 这里父类方法都是接口</li><li>接口隔离原则: 最小接口, 不要出现胖接口</li><li>依赖倒置原则: 面向接口编程,而不是面向具体编程</li><li>迪米特法则: 和最少的对象产生关联</li><li>开闭原则: 对修改开放, 对扩展关闭</li></ul>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;一、什么是组合模式&quot;&gt;&lt;a href=&quot;#一、什么是组合模式&quot; class=&quot;headerlink&quot; title=&quot;一、什么是组合模式?&quot;&gt;&lt;/a&gt;一、什么是组合模式?&lt;/h1&gt;&lt;p&gt;组合模式定义了如何将容器对象和叶子对象进行递归组合，使得客户在使用的过程中无须进</summary>
      
    
    
    
    <category term="设计模式" scheme="https://georgechan95.github.io/categories/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"/>
    
    
    <category term="设计模式" scheme="https://georgechan95.github.io/tags/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"/>
    
  </entry>
  
  <entry>
    <title>10-装饰器模式</title>
    <link href="https://georgechan95.github.io/blog/90213fc6.html"/>
    <id>https://georgechan95.github.io/blog/90213fc6.html</id>
    <published>2024-11-16T06:06:00.000Z</published>
    <updated>2024-11-16T08:47:25.665Z</updated>
    
    <content type="html"><![CDATA[<h1 id="一、什么是装饰器模式"><a href="#一、什么是装饰器模式" class="headerlink" title="一、什么是装饰器模式?"></a>一、什么是装饰器模式?</h1><p>我们都知道装饰, 元旦, 圣诞节, 我们都需要装饰, 渲染节日气氛. . 所谓装饰, 就是在原来的基础上加东西.</p><p>装饰器模式（Decorator Pattern）允许向一个现有的对象添加新的功能，同时又不改变其结构。这种类型的设计模式属于结构型模式，它是对现有类的包装。</p><p>这种模式创建了一个装饰类，用来包装原有的类，并在保持类方法签名完整性的前提下，提供了额外的功能。 我们通过下面的实例来演示装饰器模式的用法。其中，我们将把圣诞节的房间在原来的基础上装饰上了气球。</p><p>我们来看看UML图: 最开始有房子, 房子有平房, 楼房, 别墅, 我们会打扫房间.</p><p><img src="https://raw.githubusercontent.com/GeorgeChan95/blogimg/master/img/2024/11/16/20241116-153413.png" alt="装饰者模式-基础类"></p><p>这时, 遇到节假日, 比如:圣诞节, 元旦, 我们会装饰房间, 给房间布置气球等. 我们可以采用装饰器设计模式. 这时, 装饰的主体依然房子. 装饰就像是一个壳子, 套在房子的外面.</p><p><img src="https://raw.githubusercontent.com/GeorgeChan95/blogimg/master/img/2024/11/16/20241116-153654.png" alt="添加装饰"></p><p><strong>代码实现如下：</strong></p><pre><code class="highlight java"><span class="comment">/**</span><span class="comment"> * 房子抽象类</span><span class="comment"> */</span><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">IHouse</span> &#123;    <span class="keyword">void</span> <span class="title function_">clean</span><span class="params">()</span>;&#125;<span class="comment">/**</span><span class="comment"> * 平房</span><span class="comment"> */</span><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Bungalow</span> <span class="keyword">implements</span> <span class="title class_">IHouse</span>&#123;    <span class="meta">@Override</span>    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">clean</span><span class="params">()</span> &#123;        System.out.println(<span class="string">&quot;平房打扫卫生&quot;</span>);    &#125;&#125;<span class="comment">/**</span><span class="comment"> * 楼房</span><span class="comment"> */</span><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">HighRiseBuilding</span> <span class="keyword">implements</span> <span class="title class_">IHouse</span>&#123;    <span class="meta">@Override</span>    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">clean</span><span class="params">()</span> &#123;        System.out.println(<span class="string">&quot;楼房打扫卫生&quot;</span>);    &#125;&#125;<span class="comment">/**</span><span class="comment"> * 别墅</span><span class="comment"> */</span><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Villa</span> <span class="keyword">implements</span> <span class="title class_">IHouse</span> &#123;    <span class="meta">@Override</span>    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">clean</span><span class="params">()</span> &#123;        System.out.println(<span class="string">&quot;别墅打扫卫生&quot;</span>);    &#125;&#125;<span class="comment">/**</span><span class="comment"> * 房间装饰器</span><span class="comment"> */</span><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">class</span> <span class="title class_">DecoratorHouse</span> <span class="keyword">implements</span> <span class="title class_">IHouse</span> &#123;    <span class="keyword">public</span> IHouse decoratedHouse;    <span class="keyword">public</span> <span class="title function_">DecoratorHouse</span><span class="params">(IHouse decoratedHouse)</span> &#123;        <span class="built_in">this</span>.decoratedHouse = decoratedHouse;    &#125;&#125;<span class="comment">/**</span><span class="comment"> * 具体的装饰：气球</span><span class="comment"> */</span><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">BalloonDecoratorHouse</span> <span class="keyword">extends</span> <span class="title class_">DecoratorHouse</span> &#123;    <span class="keyword">public</span> <span class="title function_">BalloonDecoratorHouse</span><span class="params">(IHouse decoratedHouse)</span> &#123;        <span class="built_in">super</span>(decoratedHouse);    &#125;    <span class="meta">@Override</span>    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">clean</span><span class="params">()</span> &#123;        <span class="built_in">super</span>.decoratedHouse.clean();    &#125;    <span class="comment">/**</span><span class="comment">     * 自定义装饰方法</span><span class="comment">     */</span>    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">ballonDecorate</span><span class="params">()</span> &#123;        <span class="comment">// 用气球装饰房间</span>        System.out.println(<span class="string">&quot;用气球装饰房间, 好漂亮&quot;</span>);    &#125;&#125;<span class="comment">/**</span><span class="comment"> * 具体的装饰：圣诞树</span><span class="comment"> */</span><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">TreeDecoratorHouse</span> <span class="keyword">extends</span> <span class="title class_">DecoratorHouse</span>&#123;    <span class="keyword">public</span> <span class="title function_">TreeDecoratorHouse</span><span class="params">(IHouse decoratedHouse)</span> &#123;        <span class="built_in">super</span>(decoratedHouse);    &#125;    <span class="meta">@Override</span>    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">clean</span><span class="params">()</span> &#123;        <span class="built_in">super</span>.decoratedHouse.clean();    &#125;    <span class="comment">/**</span><span class="comment">     * 自定义装饰方法</span><span class="comment">     */</span>    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">treeDecorate</span><span class="params">()</span> &#123;        <span class="comment">// 用圣诞树装饰房间</span>        System.out.println(<span class="string">&quot;用圣诞树装饰房间&quot;</span>);    &#125;&#125;<span class="comment">/**</span><span class="comment"> * 测试类</span><span class="comment"> */</span><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">DecoratorPatternTest</span> &#123;    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;        <span class="comment">// 不使用装饰</span>        <span class="type">IHouse</span> <span class="variable">house</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Villa</span>();        house.clean();        System.out.println(<span class="string">&quot;========================&quot;</span>);        <span class="comment">// 使用装饰: 气球</span>        <span class="type">BalloonDecoratorHouse</span> <span class="variable">decoratorHouse</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">BalloonDecoratorHouse</span>(<span class="keyword">new</span> <span class="title class_">Villa</span>());        decoratorHouse.clean();        decoratorHouse.ballonDecorate();        <span class="comment">// 使用装饰: 圣诞树</span>        <span class="type">TreeDecoratorHouse</span> <span class="variable">treeDecorator</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">TreeDecoratorHouse</span>(<span class="keyword">new</span> <span class="title class_">Villa</span>());        treeDecorator.treeDecorate();    &#125;&#125;</code></pre><blockquote><p>运行结果：</p><pre><code class="highlight shell">别墅打扫卫生========================别墅打扫卫生用气球装饰房间, 好漂亮用圣诞树装饰房间</code></pre></blockquote><p>使用装饰器模式以后, 我们在不改变原有房子的基础上进行了扩展. 节假日, 就可以使用装饰类装饰房间, 如果节日过去了, 我们就继续使用原来的房子.</p><p>接下来, 我们来总结一些上面的案例. </p><ul><li><p>首先, 我们有一个组件Component, 在这个组件里有一些自定义的功能. 通常这个组件Component是抽象的(接口或者抽象类) 然后, 抽象类会有一个具体的实现 ConcreteComponent, 除了实现组件 Component 的方法, 还可自定义方法</p></li><li><p>我们现在想要对具体实现 ConcreteComponent 进行包装, 定义一个包装类 DecoratorComponent. 通常这个包装类是抽象的。</p></li><li><p>包装类也实现组件 Component 接口, 然后引入一个 Component 的具体的成员变量. 为什么要引入成员变量呢? 这个也很好理解, 我们的目标是包装的具体类. </p></li><li><p>定义一个具体的装饰器 DecoratorComponent, 再具体的装饰器中, 可以增加额外的方法. 比如在之前后者之后增加一些逻辑. 具体关系图如下:</p><p><img src="https://raw.githubusercontent.com/GeorgeChan95/blogimg/master/img/2024/11/16/20241116-162312.png" alt="总结"></p></li></ul><p>代码实现如下:</p><pre><code class="highlight java"><span class="comment">/**</span><span class="comment"> * 抽象功能</span><span class="comment"> */</span><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">Component</span> &#123;    <span class="keyword">void</span> <span class="title function_">operate</span><span class="params">()</span>;&#125;<span class="comment">/**</span><span class="comment"> * 具体功能实现</span><span class="comment"> */</span><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ConcreteComponent</span> <span class="keyword">implements</span> <span class="title class_">Component</span>&#123;    <span class="meta">@Override</span>    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">operate</span><span class="params">()</span> &#123;        <span class="comment">// 实现具体的逻辑</span>        System.out.println(<span class="string">&quot;具体实现的逻辑&quot;</span>);    &#125;&#125;<span class="comment">/**</span><span class="comment"> * 用来装饰Component对象的类</span><span class="comment"> */</span><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">class</span> <span class="title class_">DeceratorComponent</span> <span class="keyword">implements</span> <span class="title class_">Component</span> &#123;    <span class="comment">// 指定装饰的对象</span>    <span class="keyword">protected</span> Component deceratedComponent;    <span class="keyword">public</span> <span class="title function_">DeceratorComponent</span><span class="params">(Component deceratedComponent)</span> &#123;        <span class="built_in">this</span>.deceratedComponent = deceratedComponent;    &#125;&#125;<span class="comment">/**</span><span class="comment"> * 具体的装饰类</span><span class="comment"> */</span><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ConcreteDeceratorComponent</span> <span class="keyword">extends</span> <span class="title class_">DeceratorComponent</span> &#123;    <span class="keyword">public</span> <span class="title function_">ConcreteDeceratorComponent</span><span class="params">(Component deceratedComponent)</span> &#123;        <span class="built_in">super</span>(deceratedComponent);    &#125;    <span class="meta">@Override</span>    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">operate</span><span class="params">()</span> &#123;        before();        <span class="built_in">super</span>.deceratedComponent.operate();        after();    &#125;    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">before</span><span class="params">()</span>&#123;        System.out.println(<span class="string">&quot;在原逻辑之前增加了逻辑&quot;</span>);    &#125;    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">after</span><span class="params">()</span>&#123;        System.out.println(<span class="string">&quot;在原逻辑之后增加了逻辑&quot;</span>);    &#125;&#125;<span class="comment">/**</span><span class="comment"> * 测试类</span><span class="comment"> */</span><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">DeceratorTest</span> &#123;    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;        <span class="type">Component</span> <span class="variable">concreteCom</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ConcreteComponent</span>();        concreteCom.operate();        System.out.println(<span class="string">&quot;============&quot;</span>);        <span class="type">DeceratorComponent</span> <span class="variable">decerator</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ConcreteDeceratorComponent</span>(<span class="keyword">new</span> <span class="title class_">ConcreteComponent</span>());        decerator.operate();    &#125;&#125;</code></pre><blockquote><p>运行结果：</p><pre><code class="highlight shell">具体实现的逻辑============在原逻辑之前增加了逻辑具体实现的逻辑在原逻辑之后增加了逻辑</code></pre></blockquote><p>设计模式的灵活应用. 假如当前具体类就只有一个. 我们就不需要定义抽象的Component了. 如何实现装饰模式呢? 那就让装饰器直接继承自原来的类就可以了。</p><p><img src="https://raw.githubusercontent.com/GeorgeChan95/blogimg/master/img/2024/11/16/20241116-163339.png" alt="装饰器模式"></p><h1 id="二、装饰器模式的特点"><a href="#二、装饰器模式的特点" class="headerlink" title="二、装饰器模式的特点"></a>二、装饰器模式的特点</h1><ul><li>装饰对象和真实对象有相同的接口。这样客户端对象就能以和真实对象相同的方式和装饰对象交互。</li><li>装饰对象包含一个真实对象的引用（reference）</li><li>装饰对象接受所有来自客户端的请求。它把这些请求转发给真实的对象。</li><li>装饰对象可以在转发这些请求以前或以后增加一些附加功能。这样就确保了在运行时，不用修改给定对象的结构就可以在外部增加附加的功能。在面向对象的设计中，通常是通过继承来实现对给定类的功能扩展。</li></ul><h1 id="三、装饰器模式的使用场景"><a href="#三、装饰器模式的使用场景" class="headerlink" title="三、装饰器模式的使用场景"></a>三、装饰器模式的使用场景</h1><p>以下情况可以考虑使用装饰器模式</p><ul><li>需要扩展一个类的功能，或给一个类添加附加职责。</li><li>需要动态的给一个对象添加功能，这些功能可以再动态的撤销。</li><li>需要增加由一些基本功能的排列组合而产生的非常大量的功能，从而使继承关系变的不现实。</li><li>当不能采用生成子类的方法进行扩充时。一种情况是，可能有大量独立的扩展，为支持每一种组合将产生大量的子类，使得子类数目呈爆炸性增长。另一种情况可能是因为类定义被隐藏，或类定义不能用于生成子类。</li></ul><h1 id="四、装饰器模式的优点"><a href="#四、装饰器模式的优点" class="headerlink" title="四、装饰器模式的优点"></a>四、装饰器模式的优点</h1><ul><li>Decorator模式与继承关系的目的都是要扩展对象的功能，但是Decorator可以提供比继承更多的灵活性。</li><li>通过使用不同的具体装饰类以及这些装饰类的排列组合，设计师可以创造出很多不同行为的组合。</li></ul><h1 id="五、装饰器模式的缺点"><a href="#五、装饰器模式的缺点" class="headerlink" title="五、装饰器模式的缺点"></a>五、装饰器模式的缺点</h1><ul><li>这种比继承更加灵活机动的特性，也同时意味着更加多的复杂性。</li><li>装饰模式会导致设计中出现许多小类，如果过度使用，会使程序变得很复杂。</li><li>装饰模式是针对抽象组件（Component）类型编程。但是，如果你要针对具体组件编程时，就应该重新思考你的应用架构，以及装饰者是否合适。当然也可以改变Component接口，增加新的公开的行为，实现“半透明”的装饰者模式。在实际项目中要做出最佳选择。</li></ul><h1 id="六、装饰器模式使用了哪些设计模式的原则？"><a href="#六、装饰器模式使用了哪些设计模式的原则？" class="headerlink" title="六、装饰器模式使用了哪些设计模式的原则？"></a>六、装饰器模式使用了哪些设计模式的原则？</h1><ul><li>最明显的体现就是开闭原则—对扩展开发, 对修改关闭. 当新的需求到达, 在不改变原来功能的基础上进行扩展.</li><li>依赖倒置原则—依赖于抽象, 而非具体. 方便扩展, 再来一种新房子, 不用修改房子装饰类.</li><li>单一职责原则: 一个类只负责一件事</li></ul>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;一、什么是装饰器模式&quot;&gt;&lt;a href=&quot;#一、什么是装饰器模式&quot; class=&quot;headerlink&quot; title=&quot;一、什么是装饰器模式?&quot;&gt;&lt;/a&gt;一、什么是装饰器模式?&lt;/h1&gt;&lt;p&gt;我们都知道装饰, 元旦, 圣诞节, 我们都需要装饰, 渲染节日气氛. .</summary>
      
    
    
    
    <category term="设计模式" scheme="https://georgechan95.github.io/categories/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"/>
    
    
    <category term="设计模式" scheme="https://georgechan95.github.io/tags/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"/>
    
  </entry>
  
  <entry>
    <title>09-桥接模式</title>
    <link href="https://georgechan95.github.io/blog/c7419cfa.html"/>
    <id>https://georgechan95.github.io/blog/c7419cfa.html</id>
    <published>2024-11-14T12:51:00.000Z</published>
    <updated>2024-11-16T06:03:46.011Z</updated>
    
    <content type="html"><![CDATA[<h1 id="一、传统方式解决手机操作问题"><a href="#一、传统方式解决手机操作问题" class="headerlink" title="一、传统方式解决手机操作问题"></a>一、传统方式解决手机操作问题</h1><p>现在对不同手机类型的不同品牌实现操作编程（比如：开机、关机、上网，打电话等），如图：</p><p><img src="https://raw.githubusercontent.com/GeorgeChan95/blogimg/master/img/2024/11/16/20241116-120934.png" alt="桥接模式-手机型号"></p><p><strong>UML类图</strong></p><p><img src="https://raw.githubusercontent.com/GeorgeChan95/blogimg/master/img/2024/11/16/20241116-121006.png" alt="桥接模式-UML类图"></p><p><strong>问题分析</strong></p><ul><li><strong>扩展性问题（类爆炸）</strong>：如果我们再增加手机的样式（旋转式），就需要增加各个品牌手机的类；同样如果我们增加一个手机品牌，也要在各个手机样式类下增加</li><li><strong>违反了单一职责原则</strong>，当我们增加手机样式时，要同时增加所有品牌的手机，这样增加了代码维护成本</li></ul><p><strong>解决方案-使用桥接模式</strong></p><h1 id="二、桥接模式-Bridge-基本介绍"><a href="#二、桥接模式-Bridge-基本介绍" class="headerlink" title="二、桥接模式(Bridge)-基本介绍"></a>二、桥接模式(Bridge)-基本介绍</h1><h2 id="1-基本介绍"><a href="#1-基本介绍" class="headerlink" title="1. 基本介绍"></a>1. 基本介绍</h2><ul><li><strong>桥接模式(Bridge 模式)是指</strong>：将实现与抽象放在两个不同的类层次中，使两个层次可以独立改变。</li><li>是一种结构型设计模式</li><li>Bridge 模式基于类的最小设计原则，通过使用封装、聚合及继承等行为让不同的类承担不同的职责。它的主要 特点是把抽象(Abstraction)与行为实现(Implementation)分离开来，从而可以保持各部分的独立性以及应对他们的 功能扩展</li></ul><h2 id="2-桥接模式-Bridge-原理类图"><a href="#2-桥接模式-Bridge-原理类图" class="headerlink" title="2. 桥接模式(Bridge)-原理类图"></a>2. 桥接模式(Bridge)-原理类图</h2><p><img src="https://raw.githubusercontent.com/GeorgeChan95/blogimg/master/img/2024/11/16/20241116-121618.png" alt="桥接模式-原理类图"></p><p><strong>类图说明</strong></p><ul><li>Client 类：桥接模式的调用者</li><li>抽象类(Abstraction) :维护了 Implementor &#x2F;  即它的实现类 ConcreteImplementorA.., 二者是聚合关系, Abstraction 充当桥接类</li><li>RefinedAbstraction :  是 Abstraction 抽象类的子类</li><li>Implementor :  行为实现类的接口</li><li>ConcreteImplementorA&#x2F;B  ：行为的具体实现类</li><li>从 UML 图：这里的抽象类和接口是聚合的关系，其实调用和被调用关系</li></ul><h1 id="三、桥接模式解决手机操作问题"><a href="#三、桥接模式解决手机操作问题" class="headerlink" title="三、桥接模式解决手机操作问题"></a>三、桥接模式解决手机操作问题</h1><p>使用桥接模式改进传统方式，让程序具有搞好的扩展性，利用程序维护</p><h2 id="1-设计UML类图"><a href="#1-设计UML类图" class="headerlink" title="1. 设计UML类图"></a>1. 设计UML类图</h2><p><img src="https://raw.githubusercontent.com/GeorgeChan95/blogimg/master/img/2024/11/16/20241116-133618.png" alt="image-20241116133617754"></p><h2 id="2-代码实现"><a href="#2-代码实现" class="headerlink" title="2. 代码实现"></a>2. 代码实现</h2><pre><code class="highlight java"><span class="comment">// 定义实现，对应 UML中的 Implementation</span><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">Brand</span> &#123;    <span class="comment">// 开机</span>    <span class="keyword">void</span> <span class="title function_">open</span><span class="params">()</span>;    <span class="comment">// 关机</span>    <span class="keyword">void</span> <span class="title function_">close</span><span class="params">()</span>;    <span class="comment">// 打电话</span>    <span class="keyword">void</span> <span class="title function_">call</span><span class="params">()</span>;    <span class="comment">// 设置手机款式</span>    <span class="keyword">void</span> <span class="title function_">setStype</span><span class="params">(String stype)</span>;&#125;<span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Vivo</span> <span class="keyword">implements</span> <span class="title class_">Brand</span>&#123;    <span class="comment">// 款式</span>    <span class="keyword">private</span> String style;    <span class="meta">@Override</span>    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">open</span><span class="params">()</span> &#123;        System.out.println(<span class="built_in">this</span>.style + <span class="string">&quot; Vivo手机开机 &quot;</span>);    &#125;    <span class="meta">@Override</span>    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">close</span><span class="params">()</span> &#123;        System.out.println(<span class="built_in">this</span>.style + <span class="string">&quot; Vivo手机关机 &quot;</span>);    &#125;    <span class="meta">@Override</span>    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">call</span><span class="params">()</span> &#123;        System.out.println(<span class="built_in">this</span>.style + <span class="string">&quot; Vivo手机打电话 &quot;</span>);    &#125;    <span class="meta">@Override</span>    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setStype</span><span class="params">(String stype)</span> &#123;        <span class="built_in">this</span>.style = stype;    &#125;&#125;<span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">XiaoMi</span> <span class="keyword">implements</span> <span class="title class_">Brand</span> &#123;<span class="comment">// 款式</span><span class="keyword">private</span> String style;<span class="meta">@Override</span><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">open</span><span class="params">()</span> &#123;System.out.println(<span class="built_in">this</span>.style + <span class="string">&quot; 小米手机开机&quot;</span>);&#125;<span class="meta">@Override</span><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">close</span><span class="params">()</span> &#123;System.out.println(<span class="built_in">this</span>.style + <span class="string">&quot; 小米手机关机 &quot;</span>);&#125;<span class="meta">@Override</span><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">call</span><span class="params">()</span> &#123;System.out.println(<span class="built_in">this</span>.style + <span class="string">&quot; 小米手机打电话&quot;</span>);&#125;<span class="meta">@Override</span><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setStype</span><span class="params">(String stype)</span> &#123;<span class="built_in">this</span>.style = stype;&#125;&#125;<span class="comment">// 定时抽象类，对应UML中的 Abstraction</span><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">class</span> <span class="title class_">Phone</span> &#123;    <span class="comment">// 聚合实现</span>    <span class="keyword">private</span> Brand brand;    <span class="keyword">public</span> <span class="title function_">Phone</span><span class="params">(Brand brand, String style)</span> &#123;        <span class="built_in">this</span>.brand = brand;        <span class="built_in">this</span>.brand.setStype(style);    &#125;    <span class="comment">// 通过聚合，让抽象类具有 Implementation 的功能</span>    <span class="keyword">protected</span> <span class="keyword">void</span> <span class="title function_">open</span><span class="params">()</span> &#123;        <span class="built_in">this</span>.brand.open();    &#125;    <span class="keyword">protected</span> <span class="keyword">void</span> <span class="title function_">close</span><span class="params">()</span> &#123;        brand.close();    &#125;    <span class="keyword">protected</span> <span class="keyword">void</span> <span class="title function_">call</span><span class="params">()</span> &#123;        brand.call();    &#125;&#125;<span class="comment">// 折叠手机</span><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">FoldedPhone</span> <span class="keyword">extends</span> <span class="title class_">Phone</span> &#123;    <span class="keyword">public</span> <span class="title function_">FoldedPhone</span><span class="params">(Brand brand)</span> &#123;        <span class="built_in">super</span>(brand, <span class="string">&quot;折叠式&quot;</span>);    &#125;    <span class="meta">@Override</span>    <span class="keyword">protected</span> <span class="keyword">void</span> <span class="title function_">open</span><span class="params">()</span> &#123;        <span class="built_in">super</span>.open();    &#125;    <span class="meta">@Override</span>    <span class="keyword">protected</span> <span class="keyword">void</span> <span class="title function_">close</span><span class="params">()</span> &#123;        <span class="built_in">super</span>.close();    &#125;    <span class="meta">@Override</span>    <span class="keyword">protected</span> <span class="keyword">void</span> <span class="title function_">call</span><span class="params">()</span> &#123;        <span class="built_in">super</span>.call();    &#125;&#125;<span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">UpRightPhone</span> <span class="keyword">extends</span> <span class="title class_">Phone</span>&#123;    <span class="keyword">public</span> <span class="title function_">UpRightPhone</span><span class="params">(Brand brand)</span> &#123;        <span class="built_in">super</span>(brand, <span class="string">&quot;直板式&quot;</span>);    &#125;    <span class="meta">@Override</span>    <span class="keyword">protected</span> <span class="keyword">void</span> <span class="title function_">open</span><span class="params">()</span> &#123;        <span class="built_in">super</span>.open();    &#125;    <span class="meta">@Override</span>    <span class="keyword">protected</span> <span class="keyword">void</span> <span class="title function_">close</span><span class="params">()</span> &#123;        <span class="built_in">super</span>.close();    &#125;    <span class="meta">@Override</span>    <span class="keyword">protected</span> <span class="keyword">void</span> <span class="title function_">call</span><span class="params">()</span> &#123;        <span class="built_in">super</span>.call();    &#125;&#125;<span class="comment">// 测试类</span><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Client</span> &#123;    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;        <span class="type">FoldedPhone</span> <span class="variable">foldedXiaomi</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">FoldedPhone</span>(<span class="keyword">new</span> <span class="title class_">XiaoMi</span>());        foldedXiaomi.open();        foldedXiaomi.call();        foldedXiaomi.close();        System.out.println(<span class="string">&quot;========================&quot;</span>);        <span class="type">FoldedPhone</span> <span class="variable">foldedVivo</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">FoldedPhone</span>(<span class="keyword">new</span> <span class="title class_">Vivo</span>());        foldedVivo.open();        foldedVivo.call();        foldedVivo.close();        System.out.println(<span class="string">&quot;========================&quot;</span>);        <span class="type">UpRightPhone</span> <span class="variable">upXiaomi</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">UpRightPhone</span>(<span class="keyword">new</span> <span class="title class_">XiaoMi</span>());        upXiaomi.open();        upXiaomi.call();        upXiaomi.close();        System.out.println(<span class="string">&quot;========================&quot;</span>);        <span class="type">UpRightPhone</span> <span class="variable">upVivo</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">UpRightPhone</span>(<span class="keyword">new</span> <span class="title class_">XiaoMi</span>());        upVivo.open();        upVivo.call();        upVivo.close();        System.out.println(<span class="string">&quot;========================&quot;</span>);    &#125;&#125;</code></pre><blockquote><p>运行结果：</p><pre><code class="highlight shell">折叠式 小米手机开机折叠式 小米手机打电话折叠式 小米手机关机 ========================折叠式 Vivo手机开机 折叠式 Vivo手机打电话 折叠式 Vivo手机关机 ========================直板式 小米手机开机直板式 小米手机打电话直板式 小米手机关机 ========================直板式 小米手机开机直板式 小米手机打电话直板式 小米手机关机 ========================</code></pre></blockquote><h1 id="四、JDK-源码分析"><a href="#四、JDK-源码分析" class="headerlink" title="四、JDK 源码分析"></a>四、JDK 源码分析</h1><p>JDBC 的 Driver 接口：如果从桥接模式来看，Driver 就是一个接口，下面可以有 MySQL 的 Driver、Oracle 的 Driver，这些就可以当做实现接口类</p><p><img src="https://raw.githubusercontent.com/GeorgeChan95/blogimg/master/img/2024/11/16/20241116-135126.png" alt="jdk-Connection继承体系"></p><p><strong>Connection 继承体系</strong></p><p><img src="https://raw.githubusercontent.com/GeorgeChan95/blogimg/master/img/2024/11/16/20241116-135208.png" alt="Connection 继承体系"></p><p><strong>Driver源码</strong></p><pre><code class="highlight java"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Driver</span> <span class="keyword">extends</span> <span class="title class_">NonRegisteringDriver</span> <span class="keyword">implements</span> <span class="title class_">java</span>.sql.Driver &#123;    <span class="keyword">static</span> &#123;        <span class="keyword">try</span> &#123;            java.sql.DriverManager.registerDriver(<span class="keyword">new</span> <span class="title class_">Driver</span>());        &#125; <span class="keyword">catch</span> (SQLException E) &#123;            <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">RuntimeException</span>(<span class="string">&quot;Can&#x27;t register driver!&quot;</span>);        &#125;    &#125;    <span class="keyword">public</span> <span class="title function_">Driver</span><span class="params">()</span> <span class="keyword">throws</span> SQLException &#123;        <span class="comment">// Required for Class.forName().newInstance()</span>    &#125;&#125;</code></pre><p><strong>DriverManager 结构</strong></p><p><img src="https://raw.githubusercontent.com/GeorgeChan95/blogimg/master/img/2024/11/16/20241116-135432.png" alt="DriverManager 结构"></p><p><strong>说明</strong></p><ul><li>MySQL 有自己的 Connectionlmpl 类，同样 Oracle 也有对应的实现类</li><li>Driver 和 Connection 之间是通过 DriverManager 类进行桥连接的</li></ul><h1 id="五、注意事项和细节"><a href="#五、注意事项和细节" class="headerlink" title="五、注意事项和细节"></a>五、注意事项和细节</h1><ul><li>实现了抽象和实现部分的分离，从而极大的提供了系统的灵活性，让抽象部分和实现部分独立开来。这有助于系统进行分层设计，从而产生更好的结构化系统</li></ul><ol start="2"><li>对于系统的高层部分，只需要知道抽象部分和实现部分的接口就可以了，其它的部分由具体业务来完成</li><li>桥接模式替代多层继承方案，可以减少子类的个数，降低系统的管理和维护成本</li><li>桥接模式的引入增加了系统的理解和设计难度，由于聚合关联关系建立在抽象层，要求开发者针对抽象进行设计和编程</li><li>桥接模式要求正确识别出系统中两个独立变化的维度，因此其使用范围有一定的后限性，即需要有这样的应用场景</li></ol>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;一、传统方式解决手机操作问题&quot;&gt;&lt;a href=&quot;#一、传统方式解决手机操作问题&quot; class=&quot;headerlink&quot; title=&quot;一、传统方式解决手机操作问题&quot;&gt;&lt;/a&gt;一、传统方式解决手机操作问题&lt;/h1&gt;&lt;p&gt;现在对不同手机类型的不同品牌实现操作编程（比</summary>
      
    
    
    
    <category term="设计模式" scheme="https://georgechan95.github.io/categories/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"/>
    
    
    <category term="设计模式" scheme="https://georgechan95.github.io/tags/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"/>
    
  </entry>
  
  <entry>
    <title>08-适配器模式</title>
    <link href="https://georgechan95.github.io/blog/f77fc055.html"/>
    <id>https://georgechan95.github.io/blog/f77fc055.html</id>
    <published>2024-11-12T14:55:00.000Z</published>
    <updated>2024-11-12T13:00:03.561Z</updated>
    
    <content type="html"><![CDATA[<h1 id="一、概述"><a href="#一、概述" class="headerlink" title="一、概述"></a>一、概述</h1><h2 id="1-基本介绍"><a href="#1-基本介绍" class="headerlink" title="1. 基本介绍"></a>1. 基本介绍</h2><ul><li>适配器模式(Adapter Pattern)将某个类的接口转换成客户端期望的另一个接口表示，主的目的是兼容性，让原本 因接口不匹配不能一起工作的两个类可以协同工作。其别名为包装器(Wrapper)</li><li>适配器模式属于结构型模式</li><li>主要分为三类：<strong>类适配器模式</strong>、<strong>对象适配器模式</strong>、<strong>接口适配器模式</strong></li></ul><h2 id="2-工作原理"><a href="#2-工作原理" class="headerlink" title="2. 工作原理"></a>2. 工作原理</h2><ul><li>适配器模式：将一个类的接口转换成另一种接口.让原本接口不兼容的类可以兼容</li><li>从用户的角度看不到被适配者，是解耦的</li><li>用户调用适配器转化出来的目标接口方法，适配器再调用被适配者的相关接口方法</li><li>用户收到反馈结果，感觉只是和目标接口交互，如图</li></ul><p><img src="https://raw.githubusercontent.com/GeorgeChan95/blogimg/master/img/2024/11/12/20241112-194016.png" alt="适配器模式"></p><h1 id="二、类适配器模式"><a href="#二、类适配器模式" class="headerlink" title="二、类适配器模式"></a>二、类适配器模式</h1><h2 id="1-类适配器模式介绍"><a href="#1-类适配器模式介绍" class="headerlink" title="1. 类适配器模式介绍"></a>1. 类适配器模式介绍</h2><p>基本介绍：Adapter 类，通过继承 src 类，实现 dst  类接口，完成 src -&gt; dst 的适配。</p><h2 id="2-类适配器模式应用实例"><a href="#2-类适配器模式应用实例" class="headerlink" title="2. 类适配器模式应用实例"></a>2. 类适配器模式应用实例</h2><h3 id="2-1-应用实例说明"><a href="#2-1-应用实例说明" class="headerlink" title="2.1 应用实例说明"></a>2.1 应用实例说明</h3><p>以生活中充电器的例子来讲解适配器，充电器本身相当于 Adapter，220V 交流电相当于 src (即被适配者)，dst (即 目标)是 5V 直流电</p><h3 id="2-2-思路分析-类图"><a href="#2-2-思路分析-类图" class="headerlink" title="2.2 思路分析(类图)"></a>2.2 思路分析(类图)</h3><p><img src="https://raw.githubusercontent.com/GeorgeChan95/blogimg/master/img/2024/11/12/20241112-200303.png" alt="类适配器模式应用实例"></p><h3 id="2-3-代码实现"><a href="#2-3-代码实现" class="headerlink" title="2.3 代码实现"></a>2.3 代码实现</h3><pre><code class="highlight java"><span class="comment">// 被适配的类</span><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Voltage220V</span> &#123;    <span class="comment">/**</span><span class="comment">     * 输出220V电压</span><span class="comment">     * <span class="doctag">@return</span></span><span class="comment">     */</span>    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">output220V</span><span class="params">()</span> &#123;        <span class="type">int</span> <span class="variable">src</span> <span class="operator">=</span> <span class="number">220</span>;        System.out.println(<span class="string">&quot;输出电压 &quot;</span> + src + <span class="string">&quot; V&quot;</span>);        <span class="keyword">return</span> src;    &#125;&#125;<span class="comment">// 适配接口</span><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">IVoltage5V</span> &#123;    <span class="comment">// 输出5V电压</span>    <span class="type">int</span> <span class="title function_">output5V</span><span class="params">()</span>;&#125;<span class="comment">// 适配器类</span><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">VoltageAdapter</span> <span class="keyword">extends</span> <span class="title class_">Voltage220V</span> <span class="keyword">implements</span> <span class="title class_">IVoltage5V</span>&#123;    <span class="meta">@Override</span>    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">output5V</span><span class="params">()</span> &#123;        <span class="comment">// 父类方法输出的结果</span>        <span class="type">int</span> <span class="variable">srcV</span> <span class="operator">=</span> output220V();        <span class="type">int</span> <span class="variable">out</span> <span class="operator">=</span> srcV / <span class="number">44</span>; <span class="comment">// 对父类输出结果进行适配</span>        <span class="comment">// 将适配后的接口返回</span>        <span class="keyword">return</span> out;    &#125;&#125;<span class="comment">// 使用适配器</span><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Phone</span> &#123;    <span class="comment">// 充电方法</span>    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">charging</span><span class="params">(IVoltage5V iVoltage5V)</span> &#123;        <span class="type">int</span> <span class="variable">data</span> <span class="operator">=</span> iVoltage5V.output5V();        <span class="keyword">if</span> (data == <span class="number">5</span>) &#123;            System.out.println(<span class="string">&quot;电压为5V，可以充电&quot;</span>);        &#125; <span class="keyword">else</span> &#123;            System.out.println(<span class="string">&quot;电压不符合使用标准&quot;</span>);        &#125;    &#125;&#125;<span class="comment">// 测试类</span><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Client</span> &#123;    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;        System.out.println(<span class="string">&quot; === 类适配器模式 ====&quot;</span>);        <span class="type">Phone</span> <span class="variable">phone</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Phone</span>();        phone.charging(<span class="keyword">new</span> <span class="title class_">VoltageAdapter</span>());    &#125;&#125;</code></pre><blockquote><p>运行结果：</p><pre><code class="highlight shell"> === 类适配器模式 ====输出电压 220 V电压为5V，可以充电</code></pre></blockquote><h3 id="2-4-类适配器模式注意事项和细节"><a href="#2-4-类适配器模式注意事项和细节" class="headerlink" title="2.4 类适配器模式注意事项和细节"></a>2.4 类适配器模式注意事项和细节</h3><ul><li>Java 是单继承机制，所以类适配器需要继承 src 类这一点算是一个缺点, 因为这要求 dst 必须是接口，有一定局限性;</li><li>src 类的方法在 Adapter 中都会暴露出来，也增加了使用的成本.</li><li>由于其继承了 src 类，所以它可以根据需求重写 src 类的方法，使得 Adapter 的灵活性增强了。</li></ul><h1 id="三、对象适配器模式"><a href="#三、对象适配器模式" class="headerlink" title="三、对象适配器模式"></a>三、对象适配器模式</h1><h2 id="1-对象适配器模式介绍"><a href="#1-对象适配器模式介绍" class="headerlink" title="1. 对象适配器模式介绍"></a>1. 对象适配器模式介绍</h2><ul><li>基本思路和类的适配器模式相同，只是将 Adapter 类作修改，不是继承 src 类，而是持有 src 类的实例，以解决兼容性的问题。 即：持有 src 类，实现 dst  类接口，完成 src-&gt;dst 的适配</li><li>根据“合成复用原则 ”，在系统中<strong>尽量使用关联关系（聚合）来替代继承关系</strong>。</li><li>对象适配器模式是适配器模式常用的一种</li></ul><h2 id="2-对象适配器模式应用实例"><a href="#2-对象适配器模式应用实例" class="headerlink" title="2. 对象适配器模式应用实例"></a>2. 对象适配器模式应用实例</h2><h3 id="2-1-应用实例说明-1"><a href="#2-1-应用实例说明-1" class="headerlink" title="2.1 应用实例说明"></a>2.1 应用实例说明</h3><p>以生活中充电器的例子来讲解适配器，充电器本身相当于 Adapter，220V 交流电相当于 src (即被适配者)，dst (即 目标)是 5V 直流电</p><h3 id="2-2-思路分析-类图-1"><a href="#2-2-思路分析-类图-1" class="headerlink" title="2.2 思路分析(类图)"></a>2.2 思路分析(类图)</h3><p><img src="https://raw.githubusercontent.com/GeorgeChan95/blogimg/master/img/2024/11/12/20241112-202023.png" alt="对象适配器模式应用实例"></p><h3 id="2-3-代码实现-1"><a href="#2-3-代码实现-1" class="headerlink" title="2.3 代码实现"></a>2.3 代码实现</h3><pre><code class="highlight java"><span class="comment">// 适配接口</span><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">IVoltage5V</span> &#123;    <span class="comment">// 输出5V电压</span>    <span class="type">int</span> <span class="title function_">output5V</span><span class="params">()</span>;&#125;<span class="comment">// 被适配的类</span><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Voltage220V</span> &#123;    <span class="comment">/**</span><span class="comment">     * 输出220V电压</span><span class="comment">     * <span class="doctag">@return</span></span><span class="comment">     */</span>    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">output220V</span><span class="params">()</span> &#123;        <span class="type">int</span> <span class="variable">src</span> <span class="operator">=</span> <span class="number">220</span>;        System.out.println(<span class="string">&quot;输出电压 &quot;</span> + src + <span class="string">&quot; V&quot;</span>);        <span class="keyword">return</span> src;    &#125;&#125;<span class="comment">// 适配器类</span><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">VoltageAdapter</span> <span class="keyword">implements</span> <span class="title class_">IVoltage5V</span> &#123;    <span class="keyword">private</span> Voltage220V voltage220V;    <span class="keyword">public</span> <span class="title function_">VoltageAdapter</span><span class="params">(Voltage220V voltage220V)</span> &#123;        <span class="built_in">this</span>.voltage220V = voltage220V;    &#125;    <span class="meta">@Override</span>    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">output5V</span><span class="params">()</span> &#123;        <span class="keyword">if</span> (voltage220V == <span class="literal">null</span>) <span class="keyword">return</span> <span class="number">0</span>;        <span class="comment">// 被适配类方法调用</span>        <span class="type">int</span> <span class="variable">srcV</span> <span class="operator">=</span> voltage220V.output220V();        <span class="type">int</span> <span class="variable">out</span> <span class="operator">=</span> srcV / <span class="number">44</span>; <span class="comment">// 对被适配输出结果进行适配</span>        <span class="comment">// 将适配后的结果返回</span>        <span class="keyword">return</span> out;    &#125;&#125;<span class="comment">// 使用适配器</span><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Phone</span> &#123;    <span class="comment">// 充电方法</span>    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">charging</span><span class="params">(IVoltage5V iVoltage5V)</span> &#123;        <span class="type">int</span> <span class="variable">data</span> <span class="operator">=</span> iVoltage5V.output5V();        <span class="keyword">if</span> (data == <span class="number">5</span>) &#123;            System.out.println(<span class="string">&quot;电压为5V，可以充电&quot;</span>);        &#125; <span class="keyword">else</span> &#123;            System.out.println(<span class="string">&quot;电压不符合使用标准&quot;</span>);        &#125;    &#125;&#125;<span class="comment">// 测试类</span><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Client</span> &#123;    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;        System.out.println(<span class="string">&quot; === 对象适配器模式 ====&quot;</span>);        <span class="type">Phone</span> <span class="variable">phone</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Phone</span>();        phone.charging(<span class="keyword">new</span> <span class="title class_">VoltageAdapter</span>(<span class="keyword">new</span> <span class="title class_">Voltage220V</span>()));    &#125;&#125;</code></pre><blockquote><p>运行结果：</p><pre><code class="highlight shell"> === 对象适配器模式 ====输出电压 220 V电压为5V，可以充电</code></pre></blockquote><h3 id="2-4-对象适配器模式注意事项和细节"><a href="#2-4-对象适配器模式注意事项和细节" class="headerlink" title="2.4 对象适配器模式注意事项和细节"></a>2.4 对象适配器模式注意事项和细节</h3><ul><li><p>对象适配器和类适配器其实算是同一种思想，只不过实现方式不同。</p><p>根据合成复用原则，使用组合替代继承， 所以它解决了类适配器必须继承 src 的局限性问题，也不再要求dst 必须是接口。</p></li><li><p>使用成本更低，更灵活。</p></li></ul><h1 id="四、接口适配器模式"><a href="#四、接口适配器模式" class="headerlink" title="四、接口适配器模式"></a>四、接口适配器模式</h1><h2 id="1-接口适配器模式介绍"><a href="#1-接口适配器模式介绍" class="headerlink" title="1. 接口适配器模式介绍"></a>1. 接口适配器模式介绍</h2><ul><li>接口适配器模式 也叫 缺省适配器模式</li><li>核心思路：当不需要全部实现接口提供的方法时，可先设计一个抽象类实现接口，并为该接口中每个方法提供 一个默认实现（空方法），那么该抽象类的子类可有选择地覆盖父类的某些方法来实现需求。</li><li>适用于一个接口不想使用其所有的方法的情况。</li></ul><h2 id="2-接口适配器模式应用实例"><a href="#2-接口适配器模式应用实例" class="headerlink" title="2. 接口适配器模式应用实例"></a>2. 接口适配器模式应用实例</h2><h3 id="2-1-思路分析-类图"><a href="#2-1-思路分析-类图" class="headerlink" title="2.1 思路分析(类图)"></a>2.1 思路分析(类图)</h3><p><img src="https://raw.githubusercontent.com/GeorgeChan95/blogimg/master/img/2024/11/12/20241112-203806.png" alt="接口适配器模式应用实例"></p><h3 id="2-2-代码实现"><a href="#2-2-代码实现" class="headerlink" title="2.2 代码实现"></a>2.2 代码实现</h3><pre><code class="highlight java"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">MyInterface</span> &#123;    <span class="keyword">void</span> <span class="title function_">m1</span><span class="params">()</span>;    <span class="keyword">void</span> <span class="title function_">m2</span><span class="params">()</span>;    <span class="keyword">void</span> <span class="title function_">m3</span><span class="params">()</span>;    <span class="keyword">void</span> <span class="title function_">m4</span><span class="params">()</span>;&#125;<span class="comment">// 在AbsAdapter 我们将 MyInterface 的方法进行默认实现</span><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">AbsAdapter</span> <span class="keyword">implements</span> <span class="title class_">MyInterface</span> &#123;    <span class="meta">@Override</span>    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">m1</span><span class="params">()</span> &#123;    &#125;    <span class="meta">@Override</span>    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">m2</span><span class="params">()</span> &#123;    &#125;    <span class="meta">@Override</span>    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">m3</span><span class="params">()</span> &#123;    &#125;    <span class="meta">@Override</span>    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">m4</span><span class="params">()</span> &#123;    &#125;&#125;<span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Client</span> &#123;    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;        System.out.println(<span class="string">&quot; === 接口适配器模式 ====&quot;</span>);        <span class="type">AbsAdapter</span> <span class="variable">absAdapter</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">AbsAdapter</span>() &#123;            <span class="meta">@Override</span>            <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">m1</span><span class="params">()</span> &#123;                System.out.println(<span class="string">&quot;使用了m1方法&quot;</span>);            &#125;        &#125;;        absAdapter.m1();    &#125;&#125;</code></pre><blockquote><p>运行结果：</p><pre><code class="highlight shell"> === 接口适配器模式 ====使用了m1方法</code></pre></blockquote><h1 id="五、适配器模式在-SpringMVC-框架应用的源码剖析"><a href="#五、适配器模式在-SpringMVC-框架应用的源码剖析" class="headerlink" title="五、适配器模式在 SpringMVC 框架应用的源码剖析"></a>五、适配器模式在 SpringMVC 框架应用的源码剖析</h1><p><strong>SpringMvc 中的 HandlerAdapter,  就使用了适配器模式</strong></p><p><img src="https://raw.githubusercontent.com/GeorgeChan95/blogimg/master/img/2024/11/12/20241112-204926.png" alt="SpringMVC 处理请求的流程"></p><p><strong>使用 HandlerAdapter 的原因分析：</strong></p><p>在 DispatcherServlet 中，有一个 doDispatch 方法，其中便使用到了 HandlerAdapter 适配器</p><p>org.springframework.web.servlet.DispatcherServlet#doDispatch</p><p><img src="https://raw.githubusercontent.com/GeorgeChan95/blogimg/master/img/2024/11/12/20241112-205310.png" alt="DispatcherServlet#doDispatch"></p><p>通过 request 可以获得一个 Handler，再根据这个 Handler 获得不同的 HandlerAdapter 进行处理</p><p><img src="https://raw.githubusercontent.com/GeorgeChan95/blogimg/master/img/2024/11/12/20241112-205418.png" alt="getHandlerAdapter"></p><p>HandlerAdapter 本质上是一个适配器接口，具体的适配器实现类有多种，其中有我们较为熟悉的 HttpRequestHandlerAdapter 和 RequestMappingHandlerAdapter</p><p><img src="https://raw.githubusercontent.com/GeorgeChan95/blogimg/master/img/2024/11/12/20241112-205500.png" alt="HandlerAdapter"></p><p>HandlerAdapter 的实现子类是的每一种 Controller 有一种对应的适配器实现类，每种 Controller 有不同的实现方式.</p><p>拿到 HandlerAdapter 适配器之后，便会调用其中的 handle 方法， 此方法便是具体的适配器实现类需要实现的方法.</p><p><img src="https://raw.githubusercontent.com/GeorgeChan95/blogimg/master/img/2024/11/12/20241112-205730.png" alt="handle 方法"></p><p>可以看到处理器的类型不同，有多重实现方式，那么调用方式就不是确定的。如果需要直接调用 Controller 方法，需要调用的时候就得不断使用<code>if-else</code>来进行判断是哪一种子类然后执行。那么如果后面要扩展 Controller，就得修改原来的代码，这样违背了 OCP 原则.</p><h1 id="六、注意事项和细节"><a href="#六、注意事项和细节" class="headerlink" title="六、注意事项和细节"></a>六、注意事项和细节</h1><ul><li>三种命名方式，是根据 src 是以怎样的形式给到 Adapter（在 Adapter 里的形式）来命名的。</li><li>三种适配器模式：<ul><li>类适配器：以类给到，在 Adapter 里，就是将 src 当做类，继承</li><li>对象适配器：以对象给到，在 Adapter 里，将 src 作为一个对象，持有</li><li>接口适配器：以接口给到，在 Adapter 里，将 src 作为一个接口，实现</li></ul></li><li>Adapter 模式最大的作用还是将原本不兼容的接口融合在一起工作。</li></ul>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;一、概述&quot;&gt;&lt;a href=&quot;#一、概述&quot; class=&quot;headerlink&quot; title=&quot;一、概述&quot;&gt;&lt;/a&gt;一、概述&lt;/h1&gt;&lt;h2 id=&quot;1-基本介绍&quot;&gt;&lt;a href=&quot;#1-基本介绍&quot; class=&quot;headerlink&quot; title=&quot;1. 基本</summary>
      
    
    
    
    <category term="设计模式" scheme="https://georgechan95.github.io/categories/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"/>
    
    
    <category term="设计模式" scheme="https://georgechan95.github.io/tags/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"/>
    
  </entry>
  
  <entry>
    <title>Spring Boot对Neo4j节点关系的增删改查</title>
    <link href="https://georgechan95.github.io/blog/a3b0b090.html"/>
    <id>https://georgechan95.github.io/blog/a3b0b090.html</id>
    <published>2024-11-12T13:00:30.000Z</published>
    <updated>2024-11-12T08:13:03.201Z</updated>
    
    <content type="html"><![CDATA[<p><strong>演示环境：</strong></p><blockquote><p>Neo4j: 3.5.5</p><p>JDK: 1.8</p><p>SpringBoot: 2.3.4</p><p>Maven: 3.8</p></blockquote><p>如何搭建neo4j数据库，参考：<a href="https://georgechan95.github.io/blog/5c93903a.html">Docker部署Neo4j并导入CSV数据</a></p><p>Spring Boot 对Neo4j单节点数据的增删改查：<a href="https://georgechan95.github.io/blog/7dc0fcde.html">Spring Boot整合Neo4j实现增删改查</a></p><p>本篇主要介绍Spring Boot 对 Neo4j 节点之间关系的增删改查操作。例如 “肯德基” 是一家公司，“麦辣鸡腿堡” 就是一个具体的产品，那么“肯德基” 与 “麦辣鸡腿堡” 就是一种生产关系。如何对这种关系进行操作，就是本篇要讲述的内容。</p><h1 id="一、代码实现"><a href="#一、代码实现" class="headerlink" title="一、代码实现"></a>一、代码实现</h1><blockquote><p>Model层</p></blockquote><pre><code class="highlight java"><span class="meta">@NodeEntity(value = &quot;ProductNode&quot;, label = &quot;产品节点&quot;)</span> <span class="comment">// value：节点的Lable，label:用于描述该类</span><span class="meta">@Data</span><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ProductEntryNode</span> &#123;    <span class="meta">@Id</span>    <span class="meta">@GeneratedValue(strategy = UuidStrategy.class)</span> <span class="comment">// 将字段ID标识为主键，配合 @GeneratedValue 自动生成id值， 生成策略默认是 InternalIdStrategy.class 生成的Long值</span>    <span class="keyword">private</span> String productEntryId;    <span class="comment">/**</span><span class="comment">     * 词条名称</span><span class="comment">     */</span>    <span class="keyword">private</span> String name;    <span class="comment">/**</span><span class="comment">     * 模板id</span><span class="comment">     */</span>    <span class="keyword">private</span> String templateId;    <span class="comment">/**</span><span class="comment">     * 词条类型  1:产品种类 2:产品类型 3:产品单元</span><span class="comment">     */</span>    <span class="keyword">private</span> String type;    <span class="comment">/**</span><span class="comment">     * 别名</span><span class="comment">     */</span>    <span class="keyword">private</span> String aliasName;    <span class="comment">/**</span><span class="comment">     * 简介</span><span class="comment">     */</span>    <span class="keyword">private</span> String introduction;&#125;<span class="comment">// 公司-&gt;生产 产品关系</span><span class="comment">// 指定关系名称为Production</span><span class="meta">@Data</span><span class="meta">@RelationshipEntity(type = &quot;Production&quot;)</span><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ProductionRelationship</span> &#123;    <span class="meta">@Id</span>    <span class="meta">@GeneratedValue(strategy = UuidStrategy.class)</span> <span class="comment">// 将字段ID标识为主键，配合 @GeneratedValue 自动生成id值， 生成策略默认是 InternalIdStrategy.class 生成的Long值</span>    <span class="keyword">private</span> String uuid;    <span class="meta">@StartNode</span> <span class="comment">// 表示节点指向的起点</span>    <span class="keyword">private</span> CompanyEntryNode startNode;    <span class="meta">@EndNode</span> <span class="comment">// 表示节点指向的终点</span>    <span class="keyword">private</span> ProductEntryNode endNode;    <span class="comment">/**</span><span class="comment">     * 收入占比</span><span class="comment">     */</span>    <span class="keyword">private</span> String incomeProportion;    <span class="comment">/**</span><span class="comment">     * 毛利率</span><span class="comment">     */</span>    <span class="keyword">private</span> String productGross;    <span class="comment">/**</span><span class="comment">     * 产品单价</span><span class="comment">     */</span>    <span class="keyword">private</span> String productPrice;    <span class="comment">/**</span><span class="comment">     * 产能</span><span class="comment">     */</span>    <span class="keyword">private</span> String capacity;    <span class="comment">/**</span><span class="comment">     * 产能利用率</span><span class="comment">     */</span>    <span class="keyword">private</span> String capacityRatio;    <span class="comment">/**</span><span class="comment">     * 产能占比</span><span class="comment">     */</span>    <span class="keyword">private</span> String capacityProportion;&#125;</code></pre><blockquote><p>自定义查询结果集</p><p>用于接收Spring-Data-Neo4j 自定义返回的结果对象， 实体类必须添加  @QueryResult 注解</p></blockquote><pre><code class="highlight java"><span class="meta">@Data</span><span class="meta">@QueryResult</span> <span class="comment">// 此注解用于返回Spring-data-neo4j查询返回自定义结果集</span><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">RelationshipDto</span> &#123;    <span class="keyword">private</span> String uuid;    <span class="comment">/**</span><span class="comment">     * 收入占比</span><span class="comment">     */</span>    <span class="keyword">private</span> String incomeProportion;    <span class="comment">/**</span><span class="comment">     * 毛利率</span><span class="comment">     */</span>    <span class="keyword">private</span> String productGross;    <span class="comment">/**</span><span class="comment">     * 产品单价</span><span class="comment">     */</span>    <span class="keyword">private</span> String productPrice;&#125;</code></pre><blockquote><p>持久层</p></blockquote><pre><code class="highlight java"><span class="meta">@Repository</span><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">ProductEntryRepository</span> <span class="keyword">extends</span> <span class="title class_">Neo4jRepository</span>&lt;ProductEntryNode, String&gt; &#123;    <span class="comment">/**</span><span class="comment">     * 根据产品别名查询产品数据集</span><span class="comment">     * <span class="doctag">@param</span> aliasName 产品别名</span><span class="comment">     * <span class="doctag">@return</span></span><span class="comment">     */</span>    <span class="meta">@Query(&quot;match(n:ProductNode) where n.aliasName = &#123;aliasName&#125; return n&quot;)</span>    List&lt;ProductEntryNode&gt; <span class="title function_">getDataByQuery</span><span class="params">(<span class="meta">@Param(&quot;aliasName&quot;)</span> String aliasName)</span>;&#125;<span class="meta">@Repository</span><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">ProductionRelationshipRepository</span> <span class="keyword">extends</span> <span class="title class_">Neo4jRepository</span>&lt;ProductionRelationship, String&gt; &#123;    <span class="comment">/**</span><span class="comment">     * 根据产品获取供应商</span><span class="comment">     *</span><span class="comment">     * 经过测试，返回结果无法映射自定义DTO对象，这里需要用Map接收自定以返回数据</span><span class="comment">     * <span class="doctag">@param</span> productEntryId</span><span class="comment">     * <span class="doctag">@return</span></span><span class="comment">     */</span>    <span class="meta">@Query(&quot;match (c:CompanyNode)-[:Production]-&gt;(p:ProductNode) where p.productEntryId = &#123;productEntryId&#125; return c.companyId as companyId, c.name as name &quot;)</span>    List&lt;Map&lt;String, Object&gt;&gt; <span class="title function_">getCompanyByProductId</span><span class="params">(<span class="meta">@Param(&quot;productEntryId&quot;)</span> String productEntryId)</span>;    <span class="comment">/**</span><span class="comment">     * 根据产品获取供应商</span><span class="comment">     * <span class="doctag">@param</span> aliasName 产品名称</span><span class="comment">     * <span class="doctag">@return</span></span><span class="comment">     */</span>    <span class="meta">@Query(&quot;match (c:CompanyNode)-[:Production]-&gt;(p:ProductNode) where p.aliasName = &#123;aliasName&#125; return c&quot;)</span>    List&lt;CompanyEntryNode&gt; <span class="title function_">getCompanyByProductName</span><span class="params">(<span class="meta">@Param(&quot;aliasName&quot;)</span> String aliasName)</span>;    <span class="comment">/**</span><span class="comment">     * 根据参数查询并返回关系数据</span><span class="comment">     * match relationship = (c:CompanyNode)-[r:Production]-&gt;(p:ProductNode) where type(r) = &quot;Production&quot; and c.aliasName = &quot;肯德基&quot; and p.aliasName = &quot;麦辣鸡&quot; return relationship limit 1;</span><span class="comment">     * <span class="doctag">@param</span> typeName 关系类型名称</span><span class="comment">     * <span class="doctag">@param</span> companyName 公司名称</span><span class="comment">     * <span class="doctag">@param</span> productName 产品名称</span><span class="comment">     * <span class="doctag">@return</span></span><span class="comment">     */</span>    <span class="meta">@Query(&quot;match relationship = (c:CompanyNode)-[r]-&gt;(p:ProductNode) where type(r) = &#123;typeName&#125; and c.aliasName = &#123;companyName&#125; and p.aliasName = &#123;productName&#125; return relationship limit 1&quot;)</span>    ProductionRelationship <span class="title function_">getRelationshipByParam</span><span class="params">(<span class="meta">@Param(&quot;typeName&quot;)</span> String typeName, <span class="meta">@Param(&quot;companyName&quot;)</span> String companyName, <span class="meta">@Param(&quot;productName&quot;)</span> String productName)</span>;    <span class="comment">/**</span><span class="comment">     * 根据产品名称和公司名称获取之间的关系,返回自定义结果集</span><span class="comment">     * match relationship =  (p:ProductNode &#123;aliasName: &quot;麦辣鸡&quot;&#125;)-[r:Production]-(c:CompanyNode &#123;aliasName: &quot;肯德基&quot;&#125;) return relationship;</span><span class="comment">     * <span class="doctag">@param</span> productName 产品名称</span><span class="comment">     * <span class="doctag">@param</span> companyName 公司名称</span><span class="comment">     * <span class="doctag">@return</span></span><span class="comment">     */</span>    <span class="meta">@Query(&quot;match (p:ProductNode &#123;aliasName: &#123;productName&#125;&#125;)-[r:Production]-(c:CompanyNode &#123;aliasName: &#123;companyName&#125;&#125;) return r.uuid as uuid, r.incomeProportion as incomeProportion, r.productGross as productGross, r.productPrice as productPrice&quot;)</span>    List&lt;RelationshipDto&gt; <span class="title function_">getRelationshipByAliasName</span><span class="params">(<span class="meta">@Param(&quot;productName&quot;)</span> String productName, <span class="meta">@Param(&quot;companyName&quot;)</span> String companyName)</span>;&#125;</code></pre><p><strong>注意：</strong> 最后一个查询语句返回的是自定义结果集 <strong>RelationshipDto</strong> ， 查询出的属性都需要 as ***</p><blockquote><p>Service层</p></blockquote><pre><code class="highlight java"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">ProductEntryService</span> &#123;    <span class="comment">/**</span><span class="comment">     * 保存产品数据</span><span class="comment">     * <span class="doctag">@param</span> node</span><span class="comment">     * <span class="doctag">@return</span></span><span class="comment">     */</span>    R&lt;ProductEntryNode&gt; <span class="title function_">save</span><span class="params">(ProductEntryNode node)</span>;    <span class="comment">/**</span><span class="comment">     * 根据主键删除</span><span class="comment">     * <span class="doctag">@param</span> uuid</span><span class="comment">     * <span class="doctag">@return</span></span><span class="comment">     */</span>    R <span class="title function_">deleteById</span><span class="params">(String uuid)</span>;    <span class="comment">/**</span><span class="comment">     * 根据产品别名查询产品数据集</span><span class="comment">     * <span class="doctag">@param</span> aliasName 产品别名</span><span class="comment">     * <span class="doctag">@return</span></span><span class="comment">     */</span>    List&lt;ProductEntryNode&gt; <span class="title function_">getDataByQuery</span><span class="params">(String aliasName)</span>;&#125;<span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">ProductionRelationshipService</span> &#123;    <span class="comment">/**</span><span class="comment">     * 添加公司产品 关系</span><span class="comment">     * <span class="doctag">@param</span> startNode 公司节点</span><span class="comment">     * <span class="doctag">@param</span> toNode 产品节点</span><span class="comment">     * <span class="doctag">@param</span> incomeProportion 收入占比</span><span class="comment">     * <span class="doctag">@param</span> productGross 毛利率</span><span class="comment">     * <span class="doctag">@param</span> productPrice 产品单价</span><span class="comment">     * <span class="doctag">@return</span></span><span class="comment">     */</span>    ProductionRelationship <span class="title function_">addProductionRelationship</span><span class="params">(CompanyEntryNode startNode, ProductEntryNode toNode, String incomeProportion, String productGross, String productPrice)</span>;    <span class="comment">/**</span><span class="comment">     * 关联公司产品关系</span><span class="comment">     * <span class="doctag">@param</span> startNodeId 公司节点唯一标识</span><span class="comment">     * <span class="doctag">@param</span> toNodeId 产品唯一标识</span><span class="comment">     * <span class="doctag">@param</span> incomeProportion 收入占比</span><span class="comment">     * <span class="doctag">@param</span> productGross 毛利率</span><span class="comment">     * <span class="doctag">@param</span> productPrice 产品单价</span><span class="comment">     * <span class="doctag">@return</span></span><span class="comment">     */</span>    ProductionRelationship <span class="title function_">addProductionRelationship</span><span class="params">(String startNodeId, String toNodeId, String incomeProportion, String productGross, String productPrice)</span>;    <span class="comment">/**</span><span class="comment">     * 获取产品的供应商公司</span><span class="comment">     *</span><span class="comment">     * <span class="doctag">@param</span> productEntryId</span><span class="comment">     * <span class="doctag">@return</span></span><span class="comment">     */</span>    List&lt;CompanyDto&gt; <span class="title function_">getCompanyByProductId</span><span class="params">(String productEntryId)</span>;    <span class="comment">/**</span><span class="comment">     * 获取产品的供应商公司</span><span class="comment">     *</span><span class="comment">     * <span class="doctag">@param</span> aliasName 产品名称</span><span class="comment">     * <span class="doctag">@return</span></span><span class="comment">     */</span>    List&lt;CompanyEntryNode&gt; <span class="title function_">getCompanyByProductName</span><span class="params">(String aliasName)</span>;    <span class="comment">/**</span><span class="comment">     * 删除所有节点关系</span><span class="comment">     * <span class="doctag">@return</span></span><span class="comment">     */</span>    R <span class="title function_">deleteAllRelationship</span><span class="params">()</span>;    <span class="comment">/**</span><span class="comment">     * 根据参数查询并返回关系数据</span><span class="comment">     * <span class="doctag">@param</span> typeName 关系类型名称</span><span class="comment">     * <span class="doctag">@param</span> companyName 公司名称</span><span class="comment">     * <span class="doctag">@param</span> productName 产品名称</span><span class="comment">     * <span class="doctag">@return</span></span><span class="comment">     */</span>    ProductionRelationship <span class="title function_">getRelationshipByParam</span><span class="params">(String typeName, String companyName, String productName)</span>;    <span class="comment">/**</span><span class="comment">     * 根据产品名称和公司名称获取之间的关系</span><span class="comment">     * <span class="doctag">@param</span> productName 产品名称</span><span class="comment">     * <span class="doctag">@param</span> companyName 公司名称</span><span class="comment">     * <span class="doctag">@return</span></span><span class="comment">     */</span>    List&lt;RelationshipDto&gt; <span class="title function_">getRelationshipByAliasName</span><span class="params">(String productName, String companyName)</span>;&#125;<span class="meta">@Slf4j</span><span class="meta">@Service</span><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ProductEntryServiceImpl</span> <span class="keyword">implements</span> <span class="title class_">ProductEntryService</span> &#123;    <span class="meta">@Autowired</span>    <span class="keyword">private</span> ProductEntryRepository productEntryRepository;    <span class="meta">@Override</span>    <span class="keyword">public</span> R&lt;ProductEntryNode&gt; <span class="title function_">save</span><span class="params">(ProductEntryNode node)</span> &#123;        <span class="type">ProductEntryNode</span> <span class="variable">entryNode</span> <span class="operator">=</span> productEntryRepository.save(node);        <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">R</span>&lt;&gt;(entryNode);    &#125;    <span class="meta">@Override</span>    <span class="keyword">public</span> R <span class="title function_">deleteById</span><span class="params">(String uuid)</span> &#123;        productEntryRepository.deleteById(uuid);        <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">R</span>();    &#125;    <span class="meta">@Override</span>    <span class="keyword">public</span> List&lt;ProductEntryNode&gt; <span class="title function_">getDataByQuery</span><span class="params">(String aliasName)</span> &#123;        List&lt;ProductEntryNode&gt; list = productEntryRepository.getDataByQuery(aliasName);        <span class="keyword">return</span> list;    &#125;&#125;<span class="meta">@Slf4j</span><span class="meta">@Service</span><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ProductionRelationshipServiceImpl</span> <span class="keyword">implements</span> <span class="title class_">ProductionRelationshipService</span> &#123;    <span class="meta">@Autowired</span>    <span class="keyword">private</span> ProductionRelationshipRepository productionRelationshipRepository;    <span class="meta">@Autowired</span>    <span class="keyword">private</span> CompanyEntryRepository companyEntryRepository;    <span class="meta">@Autowired</span>    <span class="keyword">private</span> ProductEntryRepository productEntryRepository;    <span class="meta">@Autowired</span>    <span class="keyword">private</span> ObjectMapper objectMapper;    <span class="meta">@Override</span>    <span class="keyword">public</span> ProductionRelationship <span class="title function_">addProductionRelationship</span><span class="params">(CompanyEntryNode startNode, ProductEntryNode toNode, String incomeProportion, String productGross, String productPrice)</span> &#123;        <span class="type">ProductionRelationship</span> <span class="variable">productionRelationship</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ProductionRelationship</span>();        productionRelationship.setStartNode(startNode);        productionRelationship.setEndNode(toNode);        productionRelationship.setIncomeProportion(incomeProportion);        productionRelationship.setProductGross(productGross);        productionRelationship.setProductPrice(productPrice);        <span class="type">ProductionRelationship</span> <span class="variable">save</span> <span class="operator">=</span> productionRelationshipRepository.save(productionRelationship);        <span class="keyword">return</span> save;    &#125;    <span class="meta">@Override</span>    <span class="keyword">public</span> ProductionRelationship <span class="title function_">addProductionRelationship</span><span class="params">(String startNodeId, String toNodeId, String incomeProportion, String productGross, String productPrice)</span> &#123;        <span class="type">ProductionRelationship</span> <span class="variable">relationship</span> <span class="operator">=</span> <span class="literal">null</span>;        Optional&lt;CompanyEntryNode&gt; companyOptional = companyEntryRepository.findById(startNodeId);        Optional&lt;ProductEntryNode&gt; productOptional = productEntryRepository.findById(toNodeId);        <span class="keyword">if</span> (companyOptional.isPresent() &amp;&amp; productOptional.isPresent()) &#123;            relationship = addProductionRelationship(companyOptional.get(), productOptional.get(), incomeProportion, productGross, productPrice);        &#125;        <span class="keyword">return</span> relationship;    &#125;    <span class="meta">@Override</span>    <span class="keyword">public</span> List&lt;CompanyDto&gt; <span class="title function_">getCompanyByProductId</span><span class="params">(String productEntryId)</span> &#123;        List&lt;CompanyDto&gt; companyDtos = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();        List&lt;Map&lt;String, Object&gt;&gt; maps = productionRelationshipRepository.getCompanyByProductId(productEntryId);        <span class="keyword">try</span> &#123;            <span class="type">String</span> <span class="variable">json</span> <span class="operator">=</span> objectMapper.writeValueAsString(maps);            companyDtos = objectMapper.readValue(json, <span class="keyword">new</span> <span class="title class_">TypeReference</span>&lt;List&lt;CompanyDto&gt;&gt;() &#123;&#125;);        &#125; <span class="keyword">catch</span> (JsonProcessingException e) &#123;            e.printStackTrace();        &#125;        <span class="keyword">return</span> companyDtos;    &#125;    <span class="meta">@Override</span>    <span class="keyword">public</span> List&lt;CompanyEntryNode&gt; <span class="title function_">getCompanyByProductName</span><span class="params">(String aliasName)</span> &#123;        List&lt;CompanyEntryNode&gt; list = productionRelationshipRepository.getCompanyByProductName(aliasName);        <span class="keyword">return</span> list;    &#125;    <span class="meta">@Override</span>    <span class="keyword">public</span> R <span class="title function_">deleteAllRelationship</span><span class="params">()</span> &#123;        productionRelationshipRepository.deleteAll();        <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">R</span>();    &#125;    <span class="meta">@Override</span>    <span class="keyword">public</span> ProductionRelationship <span class="title function_">getRelationshipByParam</span><span class="params">(String typeName, String companyName, String productName)</span> &#123;        <span class="type">ProductionRelationship</span> <span class="variable">relationship</span> <span class="operator">=</span> productionRelationshipRepository.getRelationshipByParam(typeName, companyName, productName);        <span class="keyword">return</span> relationship;    &#125;    <span class="meta">@Override</span>    <span class="keyword">public</span> List&lt;RelationshipDto&gt; <span class="title function_">getRelationshipByAliasName</span><span class="params">(String productName, String companyName)</span> &#123;        List&lt;RelationshipDto&gt; relationship = productionRelationshipRepository.getRelationshipByAliasName(productName, companyName);        <span class="keyword">return</span> relationship;    &#125;&#125;</code></pre><blockquote><p>Controller层</p></blockquote><pre><code class="highlight java"><span class="meta">@Slf4j</span><span class="meta">@RestController</span><span class="meta">@RequestMapping(value = &quot;/productEntry&quot;)</span><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ProductEntryController</span> &#123;    <span class="meta">@Autowired</span>    <span class="keyword">private</span> ProductEntryService productEntryService;    <span class="comment">/**</span><span class="comment">     * 保存产品数据</span><span class="comment">     * <span class="doctag">@param</span> node 参数列表</span><span class="comment">     * <span class="doctag">@return</span></span><span class="comment">     */</span>    <span class="meta">@PostMapping(&quot;/save&quot;)</span>    <span class="keyword">public</span> R&lt;ProductEntryNode&gt; <span class="title function_">save</span><span class="params">(<span class="meta">@RequestBody</span> ProductEntryNode node)</span> &#123;        R&lt;ProductEntryNode&gt; result = productEntryService.save(node);        <span class="keyword">return</span> result;    &#125;    <span class="comment">/**</span><span class="comment">     * 根据id删除</span><span class="comment">     * <span class="doctag">@param</span> uuid</span><span class="comment">     * <span class="doctag">@return</span></span><span class="comment">     */</span>    <span class="meta">@DeleteMapping(&quot;/deleteById&quot;)</span>    <span class="keyword">public</span> R <span class="title function_">deleteById</span><span class="params">(<span class="meta">@RequestParam(value = &quot;uuid&quot;, required = false)</span> String uuid)</span> &#123;        <span class="type">R</span> <span class="variable">result</span> <span class="operator">=</span> productEntryService.deleteById(uuid);        <span class="keyword">return</span> result;    &#125;    <span class="comment">/**</span><span class="comment">     * 根据产品别名查询产品数据集</span><span class="comment">     * <span class="doctag">@param</span> aliasName 产品别名</span><span class="comment">     * <span class="doctag">@return</span></span><span class="comment">     */</span>    <span class="meta">@GetMapping(&quot;/getDataByQuery&quot;)</span>    <span class="keyword">public</span> R&lt;List&lt;ProductEntryNode&gt;&gt; <span class="title function_">getDataByQuery</span><span class="params">(<span class="meta">@RequestParam(value = &quot;aliasName&quot;, required = false)</span> String aliasName)</span> &#123;        List&lt;ProductEntryNode&gt; list = productEntryService.getDataByQuery(aliasName);        <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">R</span>&lt;&gt;(list);    &#125;&#125;<span class="meta">@Slf4j</span><span class="meta">@RestController</span><span class="meta">@RequestMapping(value = &quot;/productionRelationship&quot;)</span><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ProductionRelationshipController</span> &#123;    <span class="meta">@Autowired</span>    <span class="keyword">private</span> ProductionRelationshipService productionRelationshipService;    <span class="comment">/**</span><span class="comment">     * 关联公司产品关系</span><span class="comment">     * <span class="doctag">@param</span> companyUuid 公司节点唯一标识</span><span class="comment">     * <span class="doctag">@param</span> productId 产品唯一标识</span><span class="comment">     * <span class="doctag">@param</span> incomeProportion 收入占比</span><span class="comment">     * <span class="doctag">@param</span> productGross 毛利率</span><span class="comment">     * <span class="doctag">@param</span> productPrice 产品单价</span><span class="comment">     * <span class="doctag">@return</span></span><span class="comment">     */</span>    <span class="meta">@GetMapping(&quot;/addRelationship&quot;)</span>    <span class="keyword">public</span> R <span class="title function_">addRelationship</span><span class="params">(<span class="meta">@RequestParam(value = &quot;companyUuid&quot;, required = false)</span> String companyUuid,</span><span class="params">                             <span class="meta">@RequestParam(value = &quot;productId&quot;, required = false)</span> String productId,</span><span class="params">                             <span class="meta">@RequestParam(value = &quot;incomeProportion&quot;, required = false)</span> String incomeProportion,</span><span class="params">                             <span class="meta">@RequestParam(value = &quot;productGross&quot;, required = false)</span> String productGross,</span><span class="params">                             <span class="meta">@RequestParam(value = &quot;productPrice&quot;, required = false)</span> String productPrice)</span> &#123;        <span class="type">ProductionRelationship</span> <span class="variable">relationship</span> <span class="operator">=</span> productionRelationshipService.addProductionRelationship(companyUuid, productId, incomeProportion, productGross, productPrice);        <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">R</span>(relationship);    &#125;    <span class="comment">/**</span><span class="comment">     * 根据产品获取供应商信息</span><span class="comment">     * <span class="doctag">@param</span> productId 产品唯一标识</span><span class="comment">     * <span class="doctag">@return</span></span><span class="comment">     */</span>    <span class="meta">@GetMapping(&quot;/getCompanyByProductId&quot;)</span>    <span class="keyword">public</span> R&lt;List&lt;CompanyDto&gt;&gt; <span class="title function_">getCompanyByProductId</span><span class="params">(<span class="meta">@RequestParam(value = &quot;productId&quot;, required = false)</span> String productId)</span> &#123;        List&lt;CompanyDto&gt; companyDtos = productionRelationshipService.getCompanyByProductId(productId);        <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">R</span>(companyDtos);    &#125;    <span class="comment">/**</span><span class="comment">     * 根据产品名称获取供应商信息</span><span class="comment">     * <span class="doctag">@param</span> productName 产品名称</span><span class="comment">     * <span class="doctag">@return</span></span><span class="comment">     */</span>    <span class="meta">@GetMapping(&quot;/getCompanyByProductName&quot;)</span>    <span class="keyword">public</span> R&lt;List&lt;CompanyEntryNode&gt;&gt; <span class="title function_">getCompanyByProductName</span><span class="params">(<span class="meta">@RequestParam(value = &quot;productName&quot;, required = false)</span> String productName)</span> &#123;        List&lt;CompanyEntryNode&gt; companyDtos = productionRelationshipService.getCompanyByProductName(productName);        <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">R</span>(companyDtos);    &#125;    <span class="comment">/**</span><span class="comment">     * 删除所有节点关系</span><span class="comment">     * <span class="doctag">@return</span></span><span class="comment">     */</span>    <span class="meta">@DeleteMapping(&quot;/deleteAllRelationship&quot;)</span>    <span class="keyword">public</span> R <span class="title function_">deleteAllRelationship</span><span class="params">()</span> &#123;        <span class="type">R</span> <span class="variable">result</span> <span class="operator">=</span> productionRelationshipService.deleteAllRelationship();        <span class="keyword">return</span> result;    &#125;    <span class="comment">/**</span><span class="comment">     * 根据参数查询并返回关系数据</span><span class="comment">     * <span class="doctag">@param</span> typeName 关系类型名称</span><span class="comment">     * <span class="doctag">@param</span> companyName 公司名称</span><span class="comment">     * <span class="doctag">@param</span> productName 产品名称</span><span class="comment">     * <span class="doctag">@return</span></span><span class="comment">     */</span>    <span class="meta">@GetMapping(&quot;/getRelationshipByParam&quot;)</span>    <span class="keyword">public</span> R&lt;ProductionRelationship&gt; <span class="title function_">getRelationshipByParam</span><span class="params">(<span class="meta">@RequestParam(value = &quot;typeName&quot;, required = false)</span> String typeName,</span><span class="params">                                                            <span class="meta">@RequestParam(value = &quot;companyName&quot;, required = false)</span> String companyName,</span><span class="params">                                                            <span class="meta">@RequestParam(value = &quot;productName&quot;, required = false)</span> String productName)</span> &#123;        <span class="type">ProductionRelationship</span> <span class="variable">relationship</span> <span class="operator">=</span> productionRelationshipService.getRelationshipByParam(typeName, companyName, productName);        <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">R</span>&lt;&gt;(relationship);    &#125;    <span class="comment">/**</span><span class="comment">     * 根据产品名称和公司名称获取之间的关系</span><span class="comment">     * <span class="doctag">@param</span> productName 产品名称</span><span class="comment">     * <span class="doctag">@param</span> companyName 公司名称</span><span class="comment">     * <span class="doctag">@return</span></span><span class="comment">     */</span>    <span class="meta">@GetMapping(&quot;/getRelationshipByAliasName&quot;)</span>    <span class="keyword">public</span> R&lt;List&lt;RelationshipDto&gt;&gt; <span class="title function_">getRelationshipByAliasName</span><span class="params">(<span class="meta">@RequestParam(value = &quot;productName&quot;, required = false)</span> String productName,</span><span class="params">                                                                      <span class="meta">@RequestParam(value = &quot;companyName&quot;, required = false)</span> String companyName)</span> &#123;        List&lt;RelationshipDto&gt; relationship = productionRelationshipService.getRelationshipByAliasName(productName, companyName);        <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">R</span>&lt;&gt;(relationship);    &#125;&#125;</code></pre><h1 id="二、API测试"><a href="#二、API测试" class="headerlink" title="二、API测试"></a>二、API测试</h1><blockquote><p>将公司与产品建立关系</p></blockquote><p><img src="https://raw.githubusercontent.com/GeorgeChan95/blogimg/master/img/2024/11/12/20241112-160551.png" alt="将公司与产品建立关系"></p><p><img src="https://raw.githubusercontent.com/GeorgeChan95/blogimg/master/img/2024/11/12/20241112-160616.png" alt="节点关系"></p><blockquote><p>删除所有节点关系</p></blockquote><p><img src="https://raw.githubusercontent.com/GeorgeChan95/blogimg/master/img/2024/11/12/20241112-160655.png" alt="删除所有节点关系"></p><blockquote><p>根据产品id获取供应商信息</p></blockquote><p><img src="https://raw.githubusercontent.com/GeorgeChan95/blogimg/master/img/2024/11/12/20241112-160755.png" alt="根据产品id获取供应商信息"></p><blockquote><p>根据产品名称获取供应商</p></blockquote><p><img src="https://raw.githubusercontent.com/GeorgeChan95/blogimg/master/img/2024/11/12/20241112-160930.png" alt="根据产品名称获取供应商"></p><blockquote><p>根据参数查询并返回关系数据</p></blockquote><p><img src="https://raw.githubusercontent.com/GeorgeChan95/blogimg/master/img/2024/11/12/20241112-161017.png" alt="根据参数查询并返回关系数据"></p><p><img src="https://raw.githubusercontent.com/GeorgeChan95/blogimg/master/img/2024/11/12/20241112-161218.png" alt="根据参数查询并返回关系数据"></p><blockquote><p>查询关系数据，返回自定义结果集</p></blockquote><p><img src="https://raw.githubusercontent.com/GeorgeChan95/blogimg/master/img/2024/11/12/20241112-161110.png" alt="查询关系数据，返回自定义结果集"></p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;&lt;strong&gt;演示环境：&lt;/strong&gt;&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;Neo4j: 3.5.5&lt;/p&gt;
&lt;p&gt;JDK: 1.8&lt;/p&gt;
&lt;p&gt;SpringBoot: 2.3.4&lt;/p&gt;
&lt;p&gt;Maven: 3.8&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;如</summary>
      
    
    
    
    <category term="neo4j" scheme="https://georgechan95.github.io/categories/neo4j/"/>
    
    
    <category term="neo4j" scheme="https://georgechan95.github.io/tags/neo4j/"/>
    
    <category term="SpringBoot" scheme="https://georgechan95.github.io/tags/SpringBoot/"/>
    
  </entry>
  
  <entry>
    <title>07-建造者模式</title>
    <link href="https://georgechan95.github.io/blog/3ab9aa56.html"/>
    <id>https://georgechan95.github.io/blog/3ab9aa56.html</id>
    <published>2024-11-11T13:55:00.000Z</published>
    <updated>2024-11-12T00:59:46.066Z</updated>
    
    <content type="html"><![CDATA[<h1 id="一、盖房项目需求"><a href="#一、盖房项目需求" class="headerlink" title="一、盖房项目需求"></a>一、盖房项目需求</h1><ul><li>需要建房子：这一过程为打桩、砌墙、封顶</li><li>房子有各种各样的，比如普通房，高楼，别墅，各种房子的过程虽然一样，但是要求不要相同的</li><li>请编写程序，完成需求</li></ul><h1 id="二、传统方式解决盖房需求"><a href="#二、传统方式解决盖房需求" class="headerlink" title="二、传统方式解决盖房需求"></a>二、传统方式解决盖房需求</h1><p><img src="https://raw.githubusercontent.com/GeorgeChan95/blogimg/master/img/2024/11/11/20241111-221208.png" alt="传统方式"></p><pre><code class="highlight java"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">class</span> <span class="title class_">AbstractHouse</span> &#123;    <span class="comment">//打地基</span>    <span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">void</span> <span class="title function_">buildBasic</span><span class="params">()</span>;    <span class="comment">//砌墙</span>    <span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">void</span> <span class="title function_">buildWalls</span><span class="params">()</span>;    <span class="comment">//封顶</span>    <span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">void</span> <span class="title function_">roofed</span><span class="params">()</span>;    <span class="comment">/**</span><span class="comment">     * 构建方法</span><span class="comment">     */</span>    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">build</span><span class="params">()</span> &#123;        buildBasic();        buildWalls();        roofed();    &#125;&#125;<span class="comment">// 普通房屋</span><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">CommonHouse</span> <span class="keyword">extends</span> <span class="title class_">AbstractHouse</span>&#123;    <span class="meta">@Override</span>    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">buildBasic</span><span class="params">()</span> &#123;        System.out.println(<span class="string">&quot;普通房屋打地基&quot;</span>);    &#125;    <span class="meta">@Override</span>    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">buildWalls</span><span class="params">()</span> &#123;        System.out.println(<span class="string">&quot;普通房屋砌墙&quot;</span>);    &#125;    <span class="meta">@Override</span>    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">roofed</span><span class="params">()</span> &#123;        System.out.println(<span class="string">&quot;普通房屋封顶&quot;</span>);    &#125;&#125;<span class="comment">// 高楼</span><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">HighRises</span> <span class="keyword">extends</span> <span class="title class_">AbstractHouse</span>&#123;    <span class="meta">@Override</span>    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">buildBasic</span><span class="params">()</span> &#123;        System.out.println(<span class="string">&quot;高楼打地基&quot;</span>);    &#125;    <span class="meta">@Override</span>    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">buildWalls</span><span class="params">()</span> &#123;        System.out.println(<span class="string">&quot;高楼砌墙&quot;</span>);    &#125;    <span class="meta">@Override</span>    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">roofed</span><span class="params">()</span> &#123;        System.out.println(<span class="string">&quot;高楼封顶&quot;</span>);    &#125;&#125;<span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Client</span> &#123;    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;        <span class="type">AbstractHouse</span> <span class="variable">common</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">CommonHouse</span>();        common.build();        <span class="type">AbstractHouse</span> <span class="variable">high</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">HighRises</span>();        high.build();    &#125;&#125;</code></pre><blockquote><p>运行结果:</p><pre><code class="highlight shell">普通房屋打地基普通房屋砌墙普通房屋封顶高楼打地基高楼砌墙高楼封顶</code></pre></blockquote><h1 id="三、传统方式的问题分析"><a href="#三、传统方式的问题分析" class="headerlink" title="三、传统方式的问题分析"></a>三、传统方式的问题分析</h1><ul><li>优点是比较好理解，简单易操作</li><li>设计的程序结构，过于简单，没有设计缓存层对象，程序的扩展和维护不好.  也就是说，这种设计方案，把对象(即：房子)  和 创建对象的过程(即：建房子流程)  封装在一起，耦合性增强了。</li><li>解决方案：将对象和创建过程解耦  &#x3D;&gt;   <strong>建造者模式</strong></li></ul><h1 id="四、建造者模式基本介绍"><a href="#四、建造者模式基本介绍" class="headerlink" title="四、建造者模式基本介绍"></a>四、建造者模式基本介绍</h1><ul><li><strong>建造者模式（Builder Pattern） 又叫生成器模式</strong>，是一种对象构建模式。它可以将复杂对象的建造过程抽象出来（抽象类别），使这个抽象过程的不同实现方法可以构造出不同表现（属性）的对象。</li><li>建造者模式 是一步一步创建一个复杂的对象，它允许用户只通过指定复杂对象的类型和内容就可以构建它们， 用户不需要知道内部的具体构建细节。</li></ul><h1 id="五、建造者模式的四个角色"><a href="#五、建造者模式的四个角色" class="headerlink" title="五、建造者模式的四个角色"></a>五、建造者模式的四个角色</h1><ul><li>Product（产品角色）： 一个具体的产品对象。</li><li>Builder（抽象建造者）： 创建一个 Product 对象的各个部件指定的 接口&#x2F;抽象类。</li><li>ConcreteBuilder（具体建造者）： 实现接口，构建和装配各个部件。</li><li>Director（指挥者）： 构建一个使用Builder 接口的对象。它主要是用于创建一个复杂的对象。它主要有两个作 用，一是：隔离了客户与对象的生产过程，二是：负责控制产品对象的生产过程。</li></ul><h1 id="六、建造者模式解决盖房需求应用实例"><a href="#六、建造者模式解决盖房需求应用实例" class="headerlink" title="六、建造者模式解决盖房需求应用实例"></a>六、建造者模式解决盖房需求应用实例</h1><p><strong>思路分析图解(类图)</strong></p><p><img src="https://raw.githubusercontent.com/GeorgeChan95/blogimg/master/img/2024/11/11/20241111-222922.jpg" alt="建造者模式"></p><p><strong>代码实现</strong></p><pre><code class="highlight java"><span class="comment">//产品-&gt;Product</span><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">House</span> &#123;    <span class="comment">// 地基</span>    <span class="keyword">private</span> String baise;    <span class="comment">// 墙</span>    <span class="keyword">private</span> String wall;    <span class="comment">// 屋顶</span>    <span class="keyword">private</span> String roofed;    <span class="keyword">public</span> String <span class="title function_">getBaise</span><span class="params">()</span> &#123;        <span class="keyword">return</span> baise;    &#125;    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setBaise</span><span class="params">(String baise)</span> &#123;        <span class="built_in">this</span>.baise = baise;    &#125;    <span class="keyword">public</span> String <span class="title function_">getWall</span><span class="params">()</span> &#123;        <span class="keyword">return</span> wall;    &#125;    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setWall</span><span class="params">(String wall)</span> &#123;        <span class="built_in">this</span>.wall = wall;    &#125;    <span class="keyword">public</span> String <span class="title function_">getRoofed</span><span class="params">()</span> &#123;        <span class="keyword">return</span> roofed;    &#125;    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setRoofed</span><span class="params">(String roofed)</span> &#123;        <span class="built_in">this</span>.roofed = roofed;    &#125;    <span class="meta">@Override</span>    <span class="keyword">public</span> String <span class="title function_">toString</span><span class="params">()</span> &#123;        <span class="keyword">return</span> <span class="string">&quot;House&#123;&quot;</span> + <span class="string">&quot;baise=&quot;</span> + baise + <span class="string">&quot;, wall=&quot;</span> + wall + <span class="string">&quot;, roofed=&quot;</span> + roofed + <span class="string">&quot;&#125;&quot;</span>;    &#125;&#125;<span class="comment">// 抽象构建者</span><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">class</span> <span class="title class_">HouseBuilder</span> &#123;    <span class="comment">// 聚合产品</span>    <span class="keyword">protected</span> <span class="type">House</span> <span class="variable">house</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">House</span>();    <span class="comment">//将建造的流程写好, 抽象的方法</span>    <span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">void</span> <span class="title function_">buildBasic</span><span class="params">()</span>;    <span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">void</span> <span class="title function_">buildWalls</span><span class="params">()</span>;    <span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">void</span> <span class="title function_">roofed</span><span class="params">()</span>;    <span class="comment">//建造房子好， 将产品(房子) 返回</span>    <span class="keyword">public</span> House <span class="title function_">buildHouse</span><span class="params">()</span> &#123;        <span class="keyword">return</span> house;    &#125;&#125;<span class="comment">// 具体建造者</span><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">CommonHouse</span> <span class="keyword">extends</span> <span class="title class_">HouseBuilder</span>&#123;    <span class="meta">@Override</span>    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">buildBasic</span><span class="params">()</span> &#123;        house.setBaise(<span class="string">&quot;5米&quot;</span>);    &#125;    <span class="meta">@Override</span>    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">buildWalls</span><span class="params">()</span> &#123;        house.setWall(<span class="string">&quot;0.2米&quot;</span>);    &#125;    <span class="meta">@Override</span>    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">roofed</span><span class="params">()</span> &#123;        house.setRoofed(<span class="string">&quot;普通屋顶&quot;</span>);    &#125;&#125;<span class="comment">// 具体建造者</span><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">HighBuilding</span> <span class="keyword">extends</span> <span class="title class_">HouseBuilder</span>&#123;    <span class="meta">@Override</span>    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">buildBasic</span><span class="params">()</span> &#123;        house.setBaise(<span class="string">&quot;30米&quot;</span>);    &#125;    <span class="meta">@Override</span>    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">buildWalls</span><span class="params">()</span> &#123;        house.setWall(<span class="string">&quot;2米&quot;</span>);    &#125;    <span class="meta">@Override</span>    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">roofed</span><span class="params">()</span> &#123;        house.setRoofed(<span class="string">&quot;玻璃屋顶&quot;</span>);    &#125;&#125;<span class="comment">// 指挥者，这里去指定制作流程，返回产品</span><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">HouseDirector</span> &#123;    <span class="type">HouseBuilder</span> <span class="variable">houseBuilder</span> <span class="operator">=</span> <span class="literal">null</span>;    <span class="comment">// 构造器传入 houseBuilder</span>    <span class="keyword">public</span> <span class="title function_">HouseDirector</span><span class="params">(HouseBuilder houseBuilder)</span> &#123;        <span class="built_in">this</span>.houseBuilder = houseBuilder;    &#125;    <span class="comment">// 通过setter 传入 houseBuilder</span>    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setHouseBuilder</span><span class="params">(HouseBuilder houseBuilder)</span> &#123;        <span class="built_in">this</span>.houseBuilder = houseBuilder;    &#125;    <span class="comment">// 如何处理建造房子的流程，交给指挥者</span>    <span class="keyword">public</span> House <span class="title function_">constructHouse</span><span class="params">()</span> &#123;        houseBuilder.buildBasic();        houseBuilder.buildWalls();        houseBuilder.roofed();        <span class="type">House</span> <span class="variable">house</span> <span class="operator">=</span> houseBuilder.buildHouse();        <span class="keyword">return</span> house;    &#125;&#125;<span class="comment">// 测试类</span><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Client</span> &#123;    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;        <span class="type">HouseDirector</span> <span class="variable">commonDirector</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">HouseDirector</span>(<span class="keyword">new</span> <span class="title class_">CommonHouse</span>());        <span class="type">House</span> <span class="variable">common</span> <span class="operator">=</span> commonDirector.constructHouse();        System.out.println(common.toString()); <span class="comment">// House&#123;baise=5米, wall=0.2米, roofed=普通屋顶&#125;</span>        <span class="type">HouseDirector</span> <span class="variable">highDirector</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">HouseDirector</span>(<span class="keyword">new</span> <span class="title class_">HighBuilding</span>());        <span class="type">House</span> <span class="variable">high</span> <span class="operator">=</span> highDirector.constructHouse();        System.out.println(high.toString()); <span class="comment">// House&#123;baise=30米, wall=2米, roofed=玻璃屋顶&#125;</span>    &#125;&#125;</code></pre><blockquote><p>运行结果:</p><pre><code class="highlight shell">House&#123;baise=5米, wall=0.2米, roofed=普通屋顶&#125;House&#123;baise=30米, wall=2米, roofed=玻璃屋顶&#125;</code></pre></blockquote><h1 id="七、建造者模式的注意事项和细节"><a href="#七、建造者模式的注意事项和细节" class="headerlink" title="七、建造者模式的注意事项和细节"></a>七、建造者模式的注意事项和细节</h1><ul><li>客户端(使用程序)不必知道产品内部组成的细节，将产品本身与产品的创建过程解耦，使得相同的创建过程可 以创建不同的产品对象</li><li>每一个具体建造者都相对独立，而与其他的具体建造者无关，因此可以很方便地替换具体建造者或增加新的具体建造者， 用户使用不同的具体建造者即可得到不同的产品对象</li><li>可以更加精细地控制产品的创建过程 。将复杂产品的创建步骤分解在不同的方法中，使得创建过程更加清晰， 也更方便使用程序来控制创建过程</li><li>增加新的具体建造者无须修改原有类库的代码，指挥者类针对抽象建造者类编程，系统扩展方便，符合 “开闭 原则 ”</li><li>建造者模式所创建的产品一般具有较多的共同点，其组成部分相似，如果产品之间的差异性很大，则不适合使 用建造者模式，因此其使用范围受到一定的限制。</li><li>如果产品的内部变化复杂，可能会导致需要定义很多具体建造者类来实现这种变化，导致系统变得很庞大，因 此在这种情况下，要考虑是否选择建造者模式.</li></ul><h1 id="八、抽象工厂模式-VS-建造者模式"><a href="#八、抽象工厂模式-VS-建造者模式" class="headerlink" title="八、抽象工厂模式 VS 建造者模式"></a>八、抽象工厂模式 VS 建造者模式</h1><p>抽象工厂模式实现对产品家族的创建，一个产品家族是这样的一系列产品：具有不同分类维度的产品组合，采用抽象工厂模式不需要关心构建过程，只关心什么产品由什么工厂生产即可。而建造者模式则是要求按照指定 的蓝图建造产品，它的主要目的是通过组装零配件而产生一个新产品</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;一、盖房项目需求&quot;&gt;&lt;a href=&quot;#一、盖房项目需求&quot; class=&quot;headerlink&quot; title=&quot;一、盖房项目需求&quot;&gt;&lt;/a&gt;一、盖房项目需求&lt;/h1&gt;&lt;ul&gt;
&lt;li&gt;需要建房子：这一过程为打桩、砌墙、封顶&lt;/li&gt;
&lt;li&gt;房子有各种各样的，比如</summary>
      
    
    
    
    <category term="设计模式" scheme="https://georgechan95.github.io/categories/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"/>
    
    
    <category term="设计模式" scheme="https://georgechan95.github.io/tags/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"/>
    
  </entry>
  
  <entry>
    <title>Spring Boot整合Neo4j实现增删改查</title>
    <link href="https://georgechan95.github.io/blog/7dc0fcde.html"/>
    <id>https://georgechan95.github.io/blog/7dc0fcde.html</id>
    <published>2024-11-07T11:04:30.000Z</published>
    <updated>2024-11-12T03:17:55.283Z</updated>
    
    <content type="html"><![CDATA[<p><strong>演示环境：</strong></p><blockquote><p>Neo4j: 3.5.5</p><p>JDK: 1.8</p><p>SpringBoot: 2.3.4</p><p>Maven: 3.8</p></blockquote><p>关于如何搭建neo4j数据库，参考：<a href="https://georgechan95.github.io/blog/5c93903a.html">Docker部署Neo4j并导入CSV数据</a></p><h1 id="一、pom文件如下"><a href="#一、pom文件如下" class="headerlink" title="一、pom文件如下"></a>一、pom文件如下</h1><pre><code class="highlight xml"><span class="tag">&lt;<span class="name">parent</span>&gt;</span>    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.boot<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span>    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-boot-starter-parent<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span>    <span class="tag">&lt;<span class="name">version</span>&gt;</span>2.3.4.RELEASE<span class="tag">&lt;/<span class="name">version</span>&gt;</span>    <span class="tag">&lt;<span class="name">relativePath</span>/&gt;</span> <span class="comment">&lt;!-- lookup parent from repository --&gt;</span><span class="tag">&lt;/<span class="name">parent</span>&gt;</span><span class="tag">&lt;<span class="name">properties</span>&gt;</span>    <span class="tag">&lt;<span class="name">maven.compiler.source</span>&gt;</span>8<span class="tag">&lt;/<span class="name">maven.compiler.source</span>&gt;</span>    <span class="tag">&lt;<span class="name">maven.compiler.target</span>&gt;</span>8<span class="tag">&lt;/<span class="name">maven.compiler.target</span>&gt;</span>    <span class="tag">&lt;<span class="name">project.build.sourceEncoding</span>&gt;</span>UTF-8<span class="tag">&lt;/<span class="name">project.build.sourceEncoding</span>&gt;</span>    <span class="tag">&lt;<span class="name">project.reporting.outputEncoding</span>&gt;</span>UTF-8<span class="tag">&lt;/<span class="name">project.reporting.outputEncoding</span>&gt;</span>    <span class="tag">&lt;<span class="name">maven.test.skip</span>&gt;</span>true<span class="tag">&lt;/<span class="name">maven.test.skip</span>&gt;</span>    <span class="tag">&lt;<span class="name">spring-boot.version</span>&gt;</span>2.3.4.RELEASE<span class="tag">&lt;/<span class="name">spring-boot.version</span>&gt;</span>    <span class="tag">&lt;<span class="name">commons-lang3.version</span>&gt;</span>3.12.0<span class="tag">&lt;/<span class="name">commons-lang3.version</span>&gt;</span>    <span class="tag">&lt;<span class="name">hutool-all.version</span>&gt;</span>5.8.6<span class="tag">&lt;/<span class="name">hutool-all.version</span>&gt;</span><span class="tag">&lt;/<span class="name">properties</span>&gt;</span><span class="tag">&lt;<span class="name">dependencies</span>&gt;</span>    <span class="comment">&lt;!--web依赖--&gt;</span>    <span class="tag">&lt;<span class="name">dependency</span>&gt;</span>        <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.boot<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span>        <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-boot-starter-web<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span>    <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span>    <span class="comment">&lt;!-- spring boot 服务监控--&gt;</span>    <span class="tag">&lt;<span class="name">dependency</span>&gt;</span>        <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.boot<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span>        <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-boot-starter-actuator<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span>    <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span>    <span class="comment">&lt;!-- aop --&gt;</span>    <span class="tag">&lt;<span class="name">dependency</span>&gt;</span>        <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.boot<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span>        <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-boot-starter-aop<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span>    <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span>    <span class="comment">&lt;!--springboot读取自定义配置依赖--&gt;</span>    <span class="tag">&lt;<span class="name">dependency</span>&gt;</span>        <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.boot<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span>        <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-boot-configuration-processor<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span>        <span class="tag">&lt;<span class="name">optional</span>&gt;</span>true<span class="tag">&lt;/<span class="name">optional</span>&gt;</span>    <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span>    <span class="comment">&lt;!-- 测试依赖 --&gt;</span>    <span class="tag">&lt;<span class="name">dependency</span>&gt;</span>        <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.boot<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span>        <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-boot-starter-test<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span>        <span class="tag">&lt;<span class="name">scope</span>&gt;</span>test<span class="tag">&lt;/<span class="name">scope</span>&gt;</span>        <span class="tag">&lt;<span class="name">exclusions</span>&gt;</span>            <span class="tag">&lt;<span class="name">exclusion</span>&gt;</span>                <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.junit.vintage<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span>                <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>junit-vintage-engine<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span>            <span class="tag">&lt;/<span class="name">exclusion</span>&gt;</span>        <span class="tag">&lt;/<span class="name">exclusions</span>&gt;</span>    <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span>    <span class="comment">&lt;!-- commons-lang3 --&gt;</span>    <span class="tag">&lt;<span class="name">dependency</span>&gt;</span>        <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.apache.commons<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span>        <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>commons-lang3<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span>        <span class="tag">&lt;<span class="name">version</span>&gt;</span>$&#123;commons-lang3.version&#125;<span class="tag">&lt;/<span class="name">version</span>&gt;</span>    <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span>    <span class="comment">&lt;!-- lombok --&gt;</span>    <span class="tag">&lt;<span class="name">dependency</span>&gt;</span>        <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.projectlombok<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span>        <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>lombok<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span>        <span class="tag">&lt;<span class="name">scope</span>&gt;</span>provided<span class="tag">&lt;/<span class="name">scope</span>&gt;</span>    <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span>    <span class="comment">&lt;!-- hutool工具 --&gt;</span>    <span class="tag">&lt;<span class="name">dependency</span>&gt;</span>        <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>cn.hutool<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span>        <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>hutool-all<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span>        <span class="tag">&lt;<span class="name">version</span>&gt;</span>$&#123;hutool-all.version&#125;<span class="tag">&lt;/<span class="name">version</span>&gt;</span>    <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span>    <span class="comment">&lt;!--整合neo4j--&gt;</span>    <span class="tag">&lt;<span class="name">dependency</span>&gt;</span>        <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.boot<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span>        <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-boot-starter-data-neo4j<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span>    <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span><span class="tag">&lt;/<span class="name">dependencies</span>&gt;</span><span class="tag">&lt;<span class="name">build</span>&gt;</span>    <span class="comment">&lt;!--配置jar包名称--&gt;</span>    <span class="tag">&lt;<span class="name">finalName</span>&gt;</span>ioms-data-service<span class="tag">&lt;/<span class="name">finalName</span>&gt;</span>    <span class="tag">&lt;<span class="name">plugins</span>&gt;</span>        <span class="tag">&lt;<span class="name">plugin</span>&gt;</span>            <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.boot<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span>            <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-boot-maven-plugin<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span>            <span class="tag">&lt;<span class="name">version</span>&gt;</span>$&#123;spring-boot.version&#125;<span class="tag">&lt;/<span class="name">version</span>&gt;</span>            <span class="tag">&lt;<span class="name">configuration</span>&gt;</span>                <span class="tag">&lt;<span class="name">includeSystemScope</span>&gt;</span>true<span class="tag">&lt;/<span class="name">includeSystemScope</span>&gt;</span>                <span class="tag">&lt;<span class="name">fork</span>&gt;</span>true<span class="tag">&lt;/<span class="name">fork</span>&gt;</span>     <span class="comment">&lt;!--fork :  如果没有该项配置devtools不会起作用，即应用不会restart --&gt;</span>            <span class="tag">&lt;/<span class="name">configuration</span>&gt;</span>        <span class="tag">&lt;/<span class="name">plugin</span>&gt;</span>        <span class="tag">&lt;<span class="name">plugin</span>&gt;</span>            <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.apache.maven.plugins<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span>            <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>maven-compiler-plugin<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span>            <span class="tag">&lt;<span class="name">version</span>&gt;</span>3.8.1<span class="tag">&lt;/<span class="name">version</span>&gt;</span>            <span class="tag">&lt;<span class="name">configuration</span>&gt;</span>                <span class="tag">&lt;<span class="name">source</span>&gt;</span>1.8<span class="tag">&lt;/<span class="name">source</span>&gt;</span>                <span class="tag">&lt;<span class="name">target</span>&gt;</span>1.8<span class="tag">&lt;/<span class="name">target</span>&gt;</span>            <span class="tag">&lt;/<span class="name">configuration</span>&gt;</span>        <span class="tag">&lt;/<span class="name">plugin</span>&gt;</span>    <span class="tag">&lt;/<span class="name">plugins</span>&gt;</span><span class="tag">&lt;/<span class="name">build</span>&gt;</span></code></pre><h1 id="二、配置文件：application-yml"><a href="#二、配置文件：application-yml" class="headerlink" title="二、配置文件：application.yml"></a>二、配置文件：application.yml</h1><pre><code class="highlight yaml"><span class="attr">server:</span>  <span class="comment"># 程序启动端口</span>  <span class="attr">port:</span> <span class="number">1180</span><span class="attr">spring:</span>  <span class="attr">data:</span>    <span class="attr">neo4j:</span>      <span class="comment"># neo4j用户名</span>      <span class="attr">username:</span> <span class="string">neo4j</span>      <span class="comment"># neo4j密码</span>      <span class="attr">password:</span> <span class="number">123456</span>      <span class="comment"># 程序链接数据库地址</span>      <span class="attr">uri:</span> <span class="string">bolt://192.168.6.131:7687</span><span class="attr">logging:</span>  <span class="attr">level:</span>    <span class="comment"># 打印neo4j日志</span>    <span class="attr">org.springframework.data.neo4j:</span> <span class="string">debug</span></code></pre><h1 id="三、启动类-Neo4jApplication"><a href="#三、启动类-Neo4jApplication" class="headerlink" title="三、启动类 Neo4jApplication"></a>三、启动类 Neo4jApplication</h1><pre><code class="highlight java"><span class="meta">@Slf4j</span><span class="meta">@SpringBootApplication</span><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Neo4jApplication</span> &#123;    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;        SpringApplication.run(Neo4jApplication.class, args);        log.info(<span class="string">&quot;neo4j-demo启动成功&quot;</span>);    &#125;&#125;</code></pre><h1 id="四、项目结构"><a href="#四、项目结构" class="headerlink" title="四、项目结构"></a>四、项目结构</h1><p><img src="https://raw.githubusercontent.com/GeorgeChan95/blogimg/master/img/2024/11/07/20241107-202636.png" alt="项目结构"></p><h1 id="五、增删改查"><a href="#五、增删改查" class="headerlink" title="五、增删改查"></a>五、增删改查</h1><p>这里演示简单的单表增删改查操作，关于节点的关系维护，后面再做讲解。</p><blockquote><p>数据实体类：CompanyEntryNode</p><p>主键：uuid，通过@Id标识，通过@GeneratedValue在插入数据库时自动生成</p></blockquote><pre><code class="highlight java"><span class="meta">@NodeEntity(value = &quot;CompanyNode&quot;, label = &quot;公司节点&quot;)</span> <span class="comment">// value：节点的Lable，label:用户描述该类</span><span class="meta">@Data</span><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">CompanyEntryNode</span> &#123;    <span class="meta">@Id</span>    <span class="meta">@GeneratedValue(strategy = UuidStrategy.class)</span> <span class="comment">// 将字段ID标识为主键，配合 @GeneratedValue 自动生成id值， 生成策略默认是 InternalIdStrategy.class 生成的Long值</span>    <span class="keyword">private</span> String uuid;    <span class="comment">/**</span><span class="comment">     * 名称</span><span class="comment">     */</span>    <span class="keyword">private</span> String name;    <span class="comment">/**</span><span class="comment">     * 公司表id</span><span class="comment">     */</span>    <span class="keyword">private</span> String companyId;    <span class="comment">/**</span><span class="comment">     * 类型</span><span class="comment">     */</span>    <span class="keyword">private</span> String type;    <span class="comment">/**</span><span class="comment">     * 别名</span><span class="comment">     */</span>    <span class="keyword">private</span> String aliasName;    <span class="comment">/**</span><span class="comment">     * 行业</span><span class="comment">     */</span>    <span class="keyword">private</span> String industry;    <span class="comment">/**</span><span class="comment">     * 经营范围</span><span class="comment">     */</span>    <span class="keyword">private</span> String scope;    <span class="comment">/**</span><span class="comment">     * 简介</span><span class="comment">     */</span>    <span class="keyword">private</span> String introduction;    <span class="comment">/**</span><span class="comment">     * 图片路径</span><span class="comment">     */</span>    <span class="keyword">private</span> String imagePath;    <span class="comment">/**</span><span class="comment">     * 状态 0草稿 1已审核</span><span class="comment">     */</span>    <span class="keyword">private</span> String status;    <span class="comment">/**</span><span class="comment">     * 修改人Id</span><span class="comment">     */</span>    <span class="keyword">private</span> String modifyUserId;    <span class="comment">/**</span><span class="comment">     * 修改时间</span><span class="comment">     */</span>    <span class="keyword">private</span> Long modifyTime;    <span class="comment">/**</span><span class="comment">     * 创建人Id</span><span class="comment">     */</span>    <span class="keyword">private</span> String createUserId;    <span class="comment">/**</span><span class="comment">     * 创建时间</span><span class="comment">     */</span>    <span class="keyword">private</span> Long createTime;&#125;</code></pre><blockquote><p>持久层：CompanyEntryRepository</p><p>通过继承 Neo4jRepository&lt;Entity, ID&gt;, spring-data-neo4j 已经替我们完成大部分的增删改查的操作了，但是仍不能满足复杂查询，删除的需要。所以这里也通过 Cypher 语句以及传参的形式完成复杂需求的开发。</p></blockquote><pre><code class="highlight java"><span class="meta">@Repository</span><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">CompanyEntryRepository</span> <span class="keyword">extends</span> <span class="title class_">Neo4jRepository</span>&lt;CompanyEntryNode, String&gt; &#123; <span class="comment">// &lt;实体类, 主键&gt;</span>    <span class="comment">/**</span><span class="comment">     * 根据公司id判断 公司是否已经存在</span><span class="comment">     * match(n:CompanyNode &#123;companyId: &quot;id1&quot;&#125;) return n.aliasName;</span><span class="comment">     * <span class="doctag">@param</span> companyId 查询参数companyId</span><span class="comment">     * <span class="doctag">@return</span></span><span class="comment">     */</span>    <span class="meta">@Query(&quot;match(n:CompanyNode &#123;companyId: &#123;companyId&#125;&#125;) return n.introduction&quot;)</span>    List&lt;String&gt; <span class="title function_">existsByCompanyId</span><span class="params">(String companyId)</span>;    <span class="comment">/**</span><span class="comment">     * 根据companyId删除数据</span><span class="comment">     * <span class="doctag">@param</span> companyId 查询参数companyId</span><span class="comment">     * <span class="doctag">@return</span></span><span class="comment">     */</span>    <span class="meta">@Query(&quot;match(n:CompanyNode &#123;companyId: &#123;companyId&#125;&#125;) delete n&quot;)</span>    <span class="keyword">void</span> <span class="title function_">deleteByCompanyId</span><span class="params">(String companyId)</span>;    <span class="comment">/**</span><span class="comment">     * 删除实体类的某个属性</span><span class="comment">     * <span class="doctag">@param</span> companyId 查询参数companyId</span><span class="comment">     * <span class="doctag">@return</span></span><span class="comment">     */</span>    <span class="meta">@Query(&quot;match(n:CompanyNode &#123;companyId: &#123;companyId&#125;&#125;) remove n.type&quot;)</span>    <span class="keyword">void</span> <span class="title function_">removeTypeByCompanyId</span><span class="params">(String companyId)</span>;&#125;</code></pre><blockquote><p>Service层：CompanyEntryService、CompanyEntryServiceImpl、</p><p>通过调用 CompanyEntryRepository 完成数据的操作</p></blockquote><pre><code class="highlight java"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">CompanyEntryService</span> &#123;    <span class="comment">/**</span><span class="comment">     * 新增数据</span><span class="comment">     * <span class="doctag">@param</span> entryNode</span><span class="comment">     * <span class="doctag">@return</span></span><span class="comment">     */</span>    R <span class="title function_">save</span><span class="params">(CompanyEntryNode entryNode)</span>;    <span class="comment">/**</span><span class="comment">     * 根据主键ID，主键：uuid</span><span class="comment">     * <span class="doctag">@param</span> uuid</span><span class="comment">     * <span class="doctag">@return</span></span><span class="comment">     */</span>    R <span class="title function_">deleteById</span><span class="params">(String uuid)</span>;    <span class="comment">/**</span><span class="comment">     * 根据 companyId 属性删除数据</span><span class="comment">     * <span class="doctag">@param</span> companyId</span><span class="comment">     * <span class="doctag">@return</span></span><span class="comment">     */</span>    R <span class="title function_">deleteByCompanyId</span><span class="params">(String companyId)</span>;    <span class="comment">/**</span><span class="comment">     * 删除实体类的type属性</span><span class="comment">     * <span class="doctag">@param</span> companyId 查询参数companyId</span><span class="comment">     * <span class="doctag">@return</span></span><span class="comment">     */</span>    R <span class="title function_">removeType</span><span class="params">(String companyId)</span>;    <span class="comment">/**</span><span class="comment">     * 数据更新</span><span class="comment">     * <span class="doctag">@param</span> entryNode</span><span class="comment">     * <span class="doctag">@return</span></span><span class="comment">     */</span>    R <span class="title function_">update</span><span class="params">(CompanyEntryNode entryNode)</span>;    <span class="comment">/**</span><span class="comment">     * 获取所有数据</span><span class="comment">     *</span><span class="comment">     * <span class="doctag">@return</span></span><span class="comment">     */</span>    List&lt;CompanyEntryNode&gt; <span class="title function_">getAll</span><span class="params">()</span>;    <span class="comment">/**</span><span class="comment">     * 根据companyId查询</span><span class="comment">     * <span class="doctag">@param</span> companyId</span><span class="comment">     * <span class="doctag">@return</span></span><span class="comment">     */</span>    List&lt;String&gt; <span class="title function_">getByCompanyId</span><span class="params">(String companyId)</span>;&#125;<span class="meta">@Slf4j</span><span class="meta">@Service</span><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">CompanyEntryServiceImpl</span> <span class="keyword">implements</span> <span class="title class_">CompanyEntryService</span> &#123;    <span class="meta">@Autowired</span>    <span class="keyword">private</span> CompanyEntryRepository companyEntryRepository;    <span class="meta">@Override</span>    <span class="keyword">public</span> R <span class="title function_">save</span><span class="params">(CompanyEntryNode entryNode)</span> &#123;        <span class="type">CompanyEntryNode</span> <span class="variable">data</span> <span class="operator">=</span> companyEntryRepository.save(entryNode);        <span class="keyword">if</span> (ObjectUtils.isEmpty(data)) <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">R</span>(<span class="literal">false</span>, CommonConstants.FAIL, <span class="string">&quot;操作失败&quot;</span>);        <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">R</span>(data);    &#125;    <span class="meta">@Override</span>    <span class="keyword">public</span> R <span class="title function_">deleteById</span><span class="params">(String uuid)</span> &#123;        companyEntryRepository.deleteById(uuid);        <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">R</span>();    &#125;    <span class="meta">@Override</span>    <span class="keyword">public</span> R <span class="title function_">deleteByCompanyId</span><span class="params">(String companyId)</span> &#123;        <span class="keyword">try</span> &#123;            companyEntryRepository.deleteByCompanyId(companyId);        &#125; <span class="keyword">catch</span> (Exception e) &#123;            e.printStackTrace();            <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">R</span>(<span class="literal">false</span>, CommonConstants.FAIL, <span class="string">&quot;操作失败&quot;</span>);        &#125;        <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">R</span>();    &#125;    <span class="meta">@Override</span>    <span class="keyword">public</span> R <span class="title function_">removeType</span><span class="params">(String companyId)</span> &#123;        companyEntryRepository.removeTypeByCompanyId(companyId);        <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">R</span>();    &#125;    <span class="meta">@Override</span>    <span class="keyword">public</span> R <span class="title function_">update</span><span class="params">(CompanyEntryNode entryNode)</span> &#123;        <span class="keyword">if</span> (StringUtils.isEmpty(entryNode.getUuid())) <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">R</span>(<span class="literal">false</span>, CommonConstants.FAIL, <span class="string">&quot;操作失败，参数异常&quot;</span>);        <span class="type">CompanyEntryNode</span> <span class="variable">data</span> <span class="operator">=</span> companyEntryRepository.save(entryNode);        <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">R</span>(data);    &#125;    <span class="meta">@Override</span>    <span class="keyword">public</span> List&lt;CompanyEntryNode&gt; <span class="title function_">getAll</span><span class="params">()</span> &#123;        Iterable&lt;CompanyEntryNode&gt; all = companyEntryRepository.findAll();        List&lt;CompanyEntryNode&gt; companyEntryNodes = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();        CollectionUtil.addAll(companyEntryNodes, all);        <span class="keyword">return</span> companyEntryNodes;    &#125;    <span class="meta">@Override</span>    <span class="keyword">public</span> List&lt;String&gt; <span class="title function_">getByCompanyId</span><span class="params">(String companyId)</span> &#123;        List&lt;String&gt; names = companyEntryRepository.existsByCompanyId(companyId);        <span class="keyword">return</span> names;    &#125;&#125;</code></pre><blockquote><p>Controller层：CompanyEntryController</p><p>对Service层调用</p></blockquote><pre><code class="highlight java"><span class="meta">@Slf4j</span><span class="meta">@RestController</span><span class="meta">@RequestMapping(value = &quot;/companyEntry&quot;)</span><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">CompanyEntryController</span> &#123;    <span class="meta">@Autowired</span>    <span class="keyword">private</span> CompanyEntryService companyEntryService;    <span class="comment">/**</span><span class="comment">     * 新增数据</span><span class="comment">     * <span class="doctag">@param</span> node</span><span class="comment">     * <span class="doctag">@return</span></span><span class="comment">     */</span>    <span class="meta">@PostMapping(&quot;/save&quot;)</span>    <span class="keyword">public</span> R <span class="title function_">save</span><span class="params">(<span class="meta">@RequestBody</span> CompanyEntryNode node)</span> &#123;        <span class="type">R</span> <span class="variable">result</span> <span class="operator">=</span> companyEntryService.save(node);        <span class="keyword">return</span> result;    &#125;    <span class="comment">/**</span><span class="comment">     * 根据主键删除</span><span class="comment">     * <span class="doctag">@param</span> uuid</span><span class="comment">     * <span class="doctag">@return</span></span><span class="comment">     */</span>    <span class="meta">@DeleteMapping(&quot;/deleteById&quot;)</span>    <span class="keyword">public</span> R <span class="title function_">deleteById</span><span class="params">(<span class="meta">@RequestParam(value = &quot;uuid&quot;, required = false)</span> String uuid)</span> &#123;        <span class="type">R</span> <span class="variable">result</span> <span class="operator">=</span> companyEntryService.deleteById(uuid);        <span class="keyword">return</span> result;    &#125;    <span class="comment">/**</span><span class="comment">     * 根据属性查询后删除</span><span class="comment">     * <span class="doctag">@param</span> companyId 查询条件companyId</span><span class="comment">     * <span class="doctag">@return</span></span><span class="comment">     */</span>    <span class="meta">@DeleteMapping(&quot;/deleteByParam&quot;)</span>    <span class="keyword">public</span> R <span class="title function_">deleteByParam</span><span class="params">(<span class="meta">@RequestParam(value = &quot;companyId&quot;, required = false)</span> String companyId)</span> &#123;        <span class="type">R</span> <span class="variable">result</span> <span class="operator">=</span> companyEntryService.deleteByCompanyId(companyId);        <span class="keyword">return</span> result;    &#125;    <span class="comment">/**</span><span class="comment">     * 删除实体类的某个属性字段</span><span class="comment">     * <span class="doctag">@param</span> companyId 查询条件companyId</span><span class="comment">     * <span class="doctag">@return</span></span><span class="comment">     */</span>    <span class="meta">@GetMapping(&quot;/removeType&quot;)</span>    <span class="keyword">public</span> R <span class="title function_">removeType</span><span class="params">(<span class="meta">@RequestParam(value = &quot;companyId&quot;, required = false)</span> String companyId)</span> &#123;        <span class="type">R</span> <span class="variable">result</span> <span class="operator">=</span> companyEntryService.removeType(companyId);        <span class="keyword">return</span> result;    &#125;    <span class="comment">/**</span><span class="comment">     * 数据更新</span><span class="comment">     * <span class="doctag">@param</span> node</span><span class="comment">     * <span class="doctag">@return</span></span><span class="comment">     */</span>    <span class="meta">@PostMapping(&quot;/update&quot;)</span>    <span class="keyword">public</span> R <span class="title function_">update</span><span class="params">(<span class="meta">@RequestBody</span> CompanyEntryNode node)</span> &#123;        <span class="type">R</span> <span class="variable">result</span> <span class="operator">=</span> companyEntryService.update(node);        <span class="keyword">return</span> result;    &#125;    <span class="comment">/**</span><span class="comment">     * 获取所有Company数据</span><span class="comment">     * <span class="doctag">@return</span></span><span class="comment">     */</span>    <span class="meta">@GetMapping(&quot;/getAll&quot;)</span>    <span class="keyword">public</span> R&lt;List&lt;CompanyEntryNode&gt;&gt; <span class="title function_">getAll</span><span class="params">()</span> &#123;        List&lt;CompanyEntryNode&gt; list = companyEntryService.getAll();        <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">R</span>(list);    &#125;    <span class="comment">/**</span><span class="comment">     * 根据CompanyId查询</span><span class="comment">     * <span class="doctag">@param</span> companyId</span><span class="comment">     * <span class="doctag">@return</span></span><span class="comment">     */</span>    <span class="meta">@GetMapping(&quot;/getNameByCompanyId&quot;)</span>    <span class="keyword">public</span> R&lt;List&lt;String&gt;&gt; <span class="title function_">getNameByCompanyId</span><span class="params">(<span class="meta">@RequestParam(value = &quot;companyId&quot;, required = false)</span> String companyId)</span> &#123;        List&lt;String&gt; names = companyEntryService.getByCompanyId(companyId);        <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">R</span>&lt;&gt;(names);    &#125;&#125;</code></pre><h1 id="六、API测试"><a href="#六、API测试" class="headerlink" title="六、API测试"></a>六、API测试</h1><blockquote><p>01-新增数据</p></blockquote><pre><code class="highlight json"><span class="punctuation">&#123;</span>    <span class="attr">&quot;name&quot;</span><span class="punctuation">:</span> <span class="string">&quot;肯德基&quot;</span><span class="punctuation">,</span>    <span class="attr">&quot;companyId&quot;</span><span class="punctuation">:</span> <span class="string">&quot;f1&quot;</span><span class="punctuation">,</span>    <span class="attr">&quot;type&quot;</span><span class="punctuation">:</span> <span class="string">&quot;fast food&quot;</span><span class="punctuation">,</span>    <span class="attr">&quot;aliasName&quot;</span><span class="punctuation">:</span> <span class="string">&quot;肯德基&quot;</span><span class="punctuation">,</span>    <span class="attr">&quot;industry&quot;</span><span class="punctuation">:</span> <span class="string">&quot;food&quot;</span><span class="punctuation">,</span>    <span class="attr">&quot;introduction&quot;</span><span class="punctuation">:</span> <span class="string">&quot;做快餐肯德基&quot;</span><span class="punctuation">&#125;</span></code></pre><p><img src="https://raw.githubusercontent.com/GeorgeChan95/blogimg/master/img/2024/11/07/20241107-203759.png" alt="新增数据"></p><p><img src="https://raw.githubusercontent.com/GeorgeChan95/blogimg/master/img/2024/11/07/20241107-203930.png" alt="新增数据"></p><blockquote><p>02-根据主键删除</p></blockquote><p><img src="https://raw.githubusercontent.com/GeorgeChan95/blogimg/master/img/2024/11/07/20241107-203850.png" alt="02-根据主键删除"></p><blockquote><p>03-根据属性查询后删除</p></blockquote><p><img src="https://raw.githubusercontent.com/GeorgeChan95/blogimg/master/img/2024/11/07/20241107-204428.png" alt="03-根据属性查询后删除"></p><blockquote><p>04-删除实体类的某个属性字段</p><p>这里将匹配到Company对象的type属性置为null</p></blockquote><p><img src="https://raw.githubusercontent.com/GeorgeChan95/blogimg/master/img/2024/11/07/20241107-204125.png" alt="image-20241107204124647"></p><blockquote><p>05-更新数据</p></blockquote><pre><code class="highlight json"><span class="punctuation">&#123;</span>    <span class="attr">&quot;uuid&quot;</span><span class="punctuation">:</span> <span class="string">&quot;d7de403d-0262-4589-9116-87dde707aae4&quot;</span><span class="punctuation">,</span>    <span class="attr">&quot;name&quot;</span><span class="punctuation">:</span> <span class="string">&quot;肯德基&quot;</span><span class="punctuation">,</span>    <span class="attr">&quot;companyId&quot;</span><span class="punctuation">:</span> <span class="string">&quot;f1&quot;</span><span class="punctuation">,</span>    <span class="attr">&quot;type&quot;</span><span class="punctuation">:</span> <span class="string">&quot;fast food&quot;</span><span class="punctuation">,</span>    <span class="attr">&quot;aliasName&quot;</span><span class="punctuation">:</span> <span class="string">&quot;肯德基&quot;</span><span class="punctuation">,</span>    <span class="attr">&quot;industry&quot;</span><span class="punctuation">:</span> <span class="string">&quot;food&quot;</span><span class="punctuation">,</span>    <span class="attr">&quot;introduction&quot;</span><span class="punctuation">:</span> <span class="string">&quot;做快餐肯德基更新了~~~~&quot;</span><span class="punctuation">&#125;</span></code></pre><p><img src="https://raw.githubusercontent.com/GeorgeChan95/blogimg/master/img/2024/11/07/20241107-204355.png" alt="05-更新数据"></p><blockquote><p>06-查询所有数据</p></blockquote><p><img src="https://raw.githubusercontent.com/GeorgeChan95/blogimg/master/img/2024/11/07/20241107-204600.png" alt="06-查询所有数据"></p><blockquote><p>07-根据参数查询</p></blockquote><p><img src="https://raw.githubusercontent.com/GeorgeChan95/blogimg/master/img/2024/11/07/20241107-204656.png" alt="07-根据参数查询"></p><p>到此基于Spring Boot对Neo4j的增删该查就完成了，后面再更新如果通过Java对节点间的关系进行维护。</p><blockquote><p>参考链接</p><p><a href="https://www.zhihu.com/column/c_1364222745673261056">https://www.zhihu.com/column/c_1364222745673261056</a></p><p><a href="https://blog.csdn.net/qq_35754073/article/details/137144515">https://blog.csdn.net/qq_35754073/article/details/137144515</a></p></blockquote>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;&lt;strong&gt;演示环境：&lt;/strong&gt;&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;Neo4j: 3.5.5&lt;/p&gt;
&lt;p&gt;JDK: 1.8&lt;/p&gt;
&lt;p&gt;SpringBoot: 2.3.4&lt;/p&gt;
&lt;p&gt;Maven: 3.8&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;关</summary>
      
    
    
    
    <category term="neo4j" scheme="https://georgechan95.github.io/categories/neo4j/"/>
    
    
    <category term="neo4j" scheme="https://georgechan95.github.io/tags/neo4j/"/>
    
    <category term="SpringBoot" scheme="https://georgechan95.github.io/tags/SpringBoot/"/>
    
  </entry>
  
  <entry>
    <title>06-原型模式</title>
    <link href="https://georgechan95.github.io/blog/564adc33.html"/>
    <id>https://georgechan95.github.io/blog/564adc33.html</id>
    <published>2024-11-06T11:00:00.000Z</published>
    <updated>2024-11-07T05:43:36.705Z</updated>
    
    <content type="html"><![CDATA[<h1 id="一、需求：克隆羊问题"><a href="#一、需求：克隆羊问题" class="headerlink" title="一、需求：克隆羊问题"></a>一、需求：克隆羊问题</h1><p>现在有一只羊 tom ，姓名为: tom,  年龄为：1 ，颜色为： 白色，请编写程序创建和 tom 羊属性完全相同的 10 只羊。</p><h2 id="1-传统方式解决克隆羊问题"><a href="#1-传统方式解决克隆羊问题" class="headerlink" title="1. 传统方式解决克隆羊问题"></a>1. 传统方式解决克隆羊问题</h2><h3 id="1-1-思路分析-图解"><a href="#1-1-思路分析-图解" class="headerlink" title="1.1 思路分析(图解)"></a>1.1 思路分析(图解)</h3><p><img src="https://raw.githubusercontent.com/GeorgeChan95/blogimg/master/img/2024/11/06/20241106-191055.png" alt="传统方式克隆对象"></p><h3 id="1-2-代码实现"><a href="#1-2-代码实现" class="headerlink" title="1.2 代码实现"></a>1.2 代码实现</h3><pre><code class="highlight java"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Sheep</span> &#123;    <span class="keyword">private</span> String name;    <span class="keyword">private</span> <span class="type">int</span> age;    <span class="keyword">private</span> String color;    <span class="keyword">public</span> <span class="title function_">Sheep</span><span class="params">(String name, <span class="type">int</span> age, String color)</span> &#123;        <span class="built_in">this</span>.name = name;        <span class="built_in">this</span>.age = age;        <span class="built_in">this</span>.color = color;    &#125;    <span class="comment">// 省略getter / setter</span>&#125;<span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Client</span> &#123;    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;        <span class="comment">//传统的方法</span>        <span class="type">Sheep</span> <span class="variable">sheep</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Sheep</span>(<span class="string">&quot;tom&quot;</span>, <span class="number">1</span>, <span class="string">&quot;白色&quot;</span>);        <span class="type">Sheep</span> <span class="variable">sheep2</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Sheep</span>(sheep.getName(), sheep.getAge(), sheep.getColor());        <span class="type">Sheep</span> <span class="variable">sheep3</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Sheep</span>(sheep.getName(), sheep.getAge(), sheep.getColor());        <span class="type">Sheep</span> <span class="variable">sheep4</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Sheep</span>(sheep.getName(), sheep.getAge(), sheep.getColor());        <span class="type">Sheep</span> <span class="variable">sheep5</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Sheep</span>(sheep.getName(), sheep.getAge(), sheep.getColor());        <span class="comment">//....</span>        System.out.println(sheep);        System.out.println(sheep2);        System.out.println(sheep3);        System.out.println(sheep4);        System.out.println(sheep5);        <span class="comment">// ....</span>    &#125;&#125;</code></pre><blockquote><p>运行结果：</p><pre><code class="highlight shell">com.george.prototype.Sheep@1b6d3586com.george.prototype.Sheep@4554617ccom.george.prototype.Sheep@74a14482com.george.prototype.Sheep@1540e19dcom.george.prototype.Sheep@677327b6</code></pre></blockquote><h3 id="1-3-传统的方式的优缺点"><a href="#1-3-传统的方式的优缺点" class="headerlink" title="1.3 传统的方式的优缺点"></a>1.3 传统的方式的优缺点</h3><ul><li>优点是比较好理解，简单易操作。</li><li>在创建新的对象时，总是需要重新获取原始对象的属性，如果创建的对象比较复杂时，效率较低</li><li>总是需要重新初始化对象，而不是动态地获得对象运行时的状态,  不够灵活</li></ul><h3 id="1-4-改进的思路分析"><a href="#1-4-改进的思路分析" class="headerlink" title="1.4 改进的思路分析"></a>1.4 改进的思路分析</h3><p>java 中 Object 类是所有类的根类，Object 类提供了一个 clone()方法，该方法可以将一个 Java 对象复制 一份，但是需要实现 clone 的 Java 类必须要实现一个接口 Cloneable，该接口表示该类能够复制且具有复制的能力， 这实际上就引入了后面要说的：<strong>原型模式</strong>。</p><h1 id="二、原型模式"><a href="#二、原型模式" class="headerlink" title="二、原型模式"></a>二、原型模式</h1><h2 id="1-基本介绍"><a href="#1-基本介绍" class="headerlink" title="1. 基本介绍"></a>1. 基本介绍</h2><ul><li>原型模式(Prototype 模式)是指：用原型实例指定创建对象的种类，并且通过拷贝这些原型，创建新的对象</li><li>原型模式是一种创建型设计模式，允许一个对象再创建另外一个可定制的对象，无需知道如何创建的细节</li><li>工作原理是:通过将一个原型对象传给那个要发动创建的对象，这个要发动创建的对象通过请求原型对象拷贝它们自己来实施创建，即 <strong>对象.clone()</strong></li></ul><h2 id="2-原型模式原理结构图-uml-类图"><a href="#2-原型模式原理结构图-uml-类图" class="headerlink" title="2. 原型模式原理结构图-uml 类图"></a>2. 原型模式原理结构图-uml 类图</h2><p><img src="https://raw.githubusercontent.com/GeorgeChan95/blogimg/master/img/2024/11/06/20241106-192159.png" alt="原型模式原理结构图"></p><p><strong>原理结构图说明</strong></p><ul><li>Prototype :  原型类，声明一个克隆自己的接口</li><li>ConcretePrototype:  具体的原型类,  实现一个克隆自己的操作</li><li>Client:  让一个原型对象克隆自己，从而创建一个新的对象(属性一样）</li></ul><h2 id="3-原型模式解决克隆羊问题"><a href="#3-原型模式解决克隆羊问题" class="headerlink" title="3. 原型模式解决克隆羊问题"></a>3. 原型模式解决克隆羊问题</h2><h3 id="3-1-代码如下"><a href="#3-1-代码如下" class="headerlink" title="3.1 代码如下"></a>3.1 代码如下</h3><pre><code class="highlight java"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Sheep</span> <span class="keyword">implements</span> <span class="title class_">Cloneable</span>&#123; <span class="comment">// 实现Cloneable接口， 重写clone方法</span>    <span class="keyword">private</span> String name;    <span class="keyword">private</span> <span class="type">int</span> age;    <span class="keyword">private</span> String color;    <span class="comment">// 对象.clone() 操作是浅拷贝，对于引用类型的属性，仅复制引用地址。</span>    <span class="keyword">public</span> Sheep friend; <span class="comment">// 这里添加了friend属性，属性值是一个引用类型</span>    <span class="keyword">public</span> <span class="title function_">Sheep</span><span class="params">(String name, <span class="type">int</span> age, String color)</span> &#123;        <span class="built_in">this</span>.name = name;        <span class="built_in">this</span>.age = age;        <span class="built_in">this</span>.color = color;    &#125;    <span class="comment">// 省略 getter / setter 方法</span>    <span class="meta">@Override</span>    <span class="keyword">protected</span> Sheep <span class="title function_">clone</span><span class="params">()</span> &#123;        <span class="type">Sheep</span> <span class="variable">sheep</span> <span class="operator">=</span> <span class="literal">null</span>;        <span class="keyword">try</span> &#123;            sheep = (Sheep) <span class="built_in">super</span>.clone();        &#125; <span class="keyword">catch</span> (Exception e) &#123;            e.printStackTrace();        &#125;        <span class="keyword">return</span> sheep;    &#125;&#125;<span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Client</span> &#123;<span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> CloneNotSupportedException &#123;System.out.println(<span class="string">&quot;原型模式完成对象的创建&quot;</span>);<span class="type">Sheep</span> <span class="variable">sheep</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Sheep</span>(<span class="string">&quot;tom&quot;</span>, <span class="number">1</span>, <span class="string">&quot;白色&quot;</span>);sheep.friend = <span class="keyword">new</span> <span class="title class_">Sheep</span>(<span class="string">&quot;jack&quot;</span>, <span class="number">2</span>, <span class="string">&quot;黑色&quot;</span>);<span class="type">Sheep</span> <span class="variable">sheep2</span> <span class="operator">=</span> sheep.clone(); <span class="comment">//克隆</span><span class="type">Sheep</span> <span class="variable">sheep3</span> <span class="operator">=</span> sheep.clone(); <span class="comment">//克隆</span><span class="type">Sheep</span> <span class="variable">sheep4</span> <span class="operator">=</span> sheep.clone(); <span class="comment">//克隆</span><span class="type">Sheep</span> <span class="variable">sheep5</span> <span class="operator">=</span> sheep.clone(); <span class="comment">//克隆</span>System.out.println(<span class="string">&quot;sheep2 =&quot;</span> + sheep2 + <span class="string">&quot;sheep2.friend=&quot;</span> + sheep2.friend.hashCode());System.out.println(<span class="string">&quot;sheep3 =&quot;</span> + sheep3 + <span class="string">&quot;sheep3.friend=&quot;</span> + sheep3.friend.hashCode());System.out.println(<span class="string">&quot;sheep4 =&quot;</span> + sheep4 + <span class="string">&quot;sheep4.friend=&quot;</span> + sheep4.friend.hashCode());System.out.println(<span class="string">&quot;sheep5 =&quot;</span> + sheep5 + <span class="string">&quot;sheep5.friend=&quot;</span> + sheep5.friend.hashCode());&#125;&#125;</code></pre><blockquote><p>运行结果：</p><pre><code class="highlight shell">原型模式完成对象的创建sheep2 =com.george.prototype.improve.Sheep@1b6d3586sheep2.friend=1163157884sheep3 =com.george.prototype.improve.Sheep@74a14482sheep3.friend=1163157884sheep4 =com.george.prototype.improve.Sheep@1540e19dsheep4.friend=1163157884sheep5 =com.george.prototype.improve.Sheep@677327b6sheep5.friend=1163157884</code></pre></blockquote><h3 id="3-2-解析"><a href="#3-2-解析" class="headerlink" title="3.2 解析"></a>3.2 解析</h3><ul><li>通过对象实现Cloneable接口， 重写clone方法的形式，是原型模式的具体体现， 在对象较为复杂的情况下效率更高且无需暴露对象的实现细节。</li><li>需要注意的是，这里的Sheep对象添加了引用类型的属性friend，而使用clone() 方法复制对象时，并不会完全复制引用类型的属性，仅仅复制了它的引用地址值。所以通过Cloneable复制对象的操作仅是 <strong>浅拷贝</strong> 。</li></ul><h1 id="三、原型模式在-Spring-中的应用"><a href="#三、原型模式在-Spring-中的应用" class="headerlink" title="三、原型模式在 Spring 中的应用"></a>三、原型模式在 Spring 中的应用</h1><ul><li><p>场景一：用户请求的处理</p><p>假设你有一个Web应用，其中每个用户请求需要一个独立的处理器（例如，RequestProcessor）来处理。由于每个请求可能包含不同的数据和处理逻辑，使用原型Bean可以为每个请求提供一个新的处理器实例，从而避免了由于实例之间的数据共享所带来的潜在冲突或安全问题。</p><pre><code class="highlight java"><span class="meta">@Component</span><span class="meta">@Scope(&quot;prototype&quot;)</span><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">RequestProcessor</span> &#123;    <span class="comment">// 请求处理逻辑</span>&#125;</code></pre></li><li><p>场景二：多线程任务</p><p>在执行多线程任务时，如果任务对象包含了任务执行状态，使用原型Bean可以为每个任务提供一个独立的实例。这样，即使任务是并行执行的，任务间也不会相互干扰，因为它们各自操作自己状态的独立副本。</p><pre><code class="highlight java"><span class="meta">@Component</span><span class="meta">@Scope(&quot;prototype&quot;)</span><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Task</span> <span class="keyword">implements</span> <span class="title class_">Runnable</span> &#123;    <span class="comment">// 实现Runnable接口的任务逻辑</span>&#125;</code></pre></li></ul><h1 id="四、浅拷贝与深拷贝"><a href="#四、浅拷贝与深拷贝" class="headerlink" title="四、浅拷贝与深拷贝"></a>四、浅拷贝与深拷贝</h1><h2 id="1-浅拷贝的介绍"><a href="#1-浅拷贝的介绍" class="headerlink" title="1. 浅拷贝的介绍"></a>1. 浅拷贝的介绍</h2><ul><li><p>对于数据类型是基本数据类型的成员变量，浅拷贝会直接进行值传递，也就是将该属性值复制一份给新的对象</p></li><li><p>对于数据类型是引用数据类型的成员变量，比如说成员变量是某个数组、某个类的对象等，那么浅拷贝会进行 引用传递，也就是只是将该成员变量的引用值（内存地址）复制一份给新的对象。因为实际上两个对象的该成 员变量都指向同一个实例。在这种情况下，在一个对象中修改该成员变量会影响到另一个对象的该成员变量值</p></li><li><p>前面我们克隆羊就是浅拷贝</p></li><li><p>浅拷贝是使用默认的 clone()方法来实现</p><blockquote><p>sheep &#x3D; (Sheep) super.clone();</p></blockquote></li></ul><h2 id="2-深拷贝基本介绍"><a href="#2-深拷贝基本介绍" class="headerlink" title="2. 深拷贝基本介绍"></a>2. 深拷贝基本介绍</h2><ul><li>复制对象的所有基本数据类型的成员变量值</li><li>为所有引用数据类型的成员变量申请存储空间，并复制每个引用数据类型成员变量所引用的对象，直到该对象 可达的所有对象。也就是说，<strong>对象进行深拷贝要对整个对象(包括对象的引用类型)进行拷贝</strong></li><li>深拷贝实现方式 1 ：<strong>重写 clone</strong> 方法来实现深拷贝</li><li>深拷贝实现方式 2 ：<strong>通过对象序列化实现深拷贝(推荐)</strong></li></ul><h2 id="3-深拷贝应用实例"><a href="#3-深拷贝应用实例" class="headerlink" title="3. 深拷贝应用实例"></a>3. 深拷贝应用实例</h2><h3 id="3-1-方式一：重写-clone-方法"><a href="#3-1-方式一：重写-clone-方法" class="headerlink" title="3.1 方式一：重写 clone() 方法"></a>3.1 方式一：重写 clone() 方法</h3><pre><code class="highlight java"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">SheepFriend</span> <span class="keyword">implements</span> <span class="title class_">Cloneable</span> &#123;    <span class="keyword">private</span> String name;    <span class="keyword">private</span> <span class="type">int</span> age;    <span class="keyword">private</span> String color;    <span class="keyword">public</span> <span class="title function_">SheepFriend</span><span class="params">(String name, <span class="type">int</span> age, String color)</span> &#123;        <span class="built_in">this</span>.name = name;        <span class="built_in">this</span>.age = age;        <span class="built_in">this</span>.color = color;    &#125;    <span class="comment">// 省略 getter / setter 方法</span>    <span class="meta">@Override</span>    <span class="keyword">protected</span> SheepFriend <span class="title function_">clone</span><span class="params">()</span> &#123;        <span class="type">SheepFriend</span> <span class="variable">friend</span> <span class="operator">=</span> <span class="literal">null</span>;        <span class="keyword">try</span> &#123;            friend = (SheepFriend) <span class="built_in">super</span>.clone();        &#125; <span class="keyword">catch</span> (CloneNotSupportedException e) &#123;            e.printStackTrace();        &#125;        <span class="keyword">return</span> friend;    &#125;&#125;<span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Sheep</span> <span class="keyword">implements</span> <span class="title class_">Cloneable</span>&#123; <span class="comment">// 实现Cloneable接口， 重写clone方法</span>    <span class="keyword">private</span> String name;    <span class="keyword">private</span> <span class="type">int</span> age;    <span class="keyword">private</span> String color;    <span class="comment">// 对象.clone() 操作是浅拷贝，对于引用类型的属性，仅复制引用地址。</span>    <span class="keyword">public</span> SheepFriend friend; <span class="comment">// 这里添加了friend属性，属性值是一个引用类型</span>    <span class="keyword">public</span> <span class="title function_">Sheep</span><span class="params">(String name, <span class="type">int</span> age, String color)</span> &#123;        <span class="built_in">this</span>.name = name;        <span class="built_in">this</span>.age = age;        <span class="built_in">this</span>.color = color;    &#125;    <span class="comment">// 省略 getter / setter 方法</span>    <span class="comment">/**</span><span class="comment">     * 深拷贝方式一：重写 clone() 方法</span><span class="comment">     * <span class="doctag">@return</span></span><span class="comment">     */</span>    <span class="meta">@Override</span>    <span class="keyword">protected</span> Sheep <span class="title function_">clone</span><span class="params">()</span> &#123;        <span class="type">Sheep</span> <span class="variable">sheep</span> <span class="operator">=</span> <span class="literal">null</span>;        <span class="keyword">try</span> &#123;            sheep = (Sheep) <span class="built_in">super</span>.clone();            <span class="comment">// 将引用属性也调用clone() 方法复制一份</span>            <span class="type">SheepFriend</span> <span class="variable">sheepFriend</span> <span class="operator">=</span> friend.clone();            <span class="comment">// 重新设置引用属性</span>            sheep.friend = sheepFriend;        &#125; <span class="keyword">catch</span> (Exception e) &#123;            e.printStackTrace();        &#125;        <span class="keyword">return</span> sheep;    &#125;&#125;<span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Client</span> &#123;<span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> CloneNotSupportedException &#123;System.out.println(<span class="string">&quot;原型模式完成对象的创建&quot;</span>);<span class="type">Sheep</span> <span class="variable">sheep</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Sheep</span>(<span class="string">&quot;tom&quot;</span>, <span class="number">1</span>, <span class="string">&quot;白色&quot;</span>);sheep.friend = <span class="keyword">new</span> <span class="title class_">SheepFriend</span>(<span class="string">&quot;jack&quot;</span>, <span class="number">2</span>, <span class="string">&quot;黑色&quot;</span>);<span class="type">Sheep</span> <span class="variable">sheep2</span> <span class="operator">=</span> sheep.clone(); <span class="comment">//克隆</span><span class="type">Sheep</span> <span class="variable">sheep3</span> <span class="operator">=</span> sheep.clone(); <span class="comment">//克隆</span><span class="type">Sheep</span> <span class="variable">sheep4</span> <span class="operator">=</span> sheep.clone(); <span class="comment">//克隆</span><span class="type">Sheep</span> <span class="variable">sheep5</span> <span class="operator">=</span> sheep.clone(); <span class="comment">//克隆</span>System.out.println(<span class="string">&quot;sheep2 =&quot;</span> + sheep2 + <span class="string">&quot;sheep2.friend=&quot;</span> + sheep2.friend.hashCode());System.out.println(<span class="string">&quot;sheep3 =&quot;</span> + sheep3 + <span class="string">&quot;sheep3.friend=&quot;</span> + sheep3.friend.hashCode());System.out.println(<span class="string">&quot;sheep4 =&quot;</span> + sheep4 + <span class="string">&quot;sheep4.friend=&quot;</span> + sheep4.friend.hashCode());System.out.println(<span class="string">&quot;sheep5 =&quot;</span> + sheep5 + <span class="string">&quot;sheep5.friend=&quot;</span> + sheep5.friend.hashCode());&#125;&#125;</code></pre><blockquote><p>运行结果：</p><pre><code class="highlight shell">原型模式完成对象的创建sheep2 =com.george.prototype.deepclone.Sheep@1b6d3586sheep2.friend=1163157884sheep3 =com.george.prototype.deepclone.Sheep@74a14482sheep3.friend=356573597sheep4 =com.george.prototype.deepclone.Sheep@677327b6sheep4.friend=21685669sheep5 =com.george.prototype.deepclone.Sheep@7f31245asheep5.friend=1836019240</code></pre></blockquote><h3 id="3-2-通过对象的序列化实现-推荐"><a href="#3-2-通过对象的序列化实现-推荐" class="headerlink" title="3.2 通过对象的序列化实现 (推荐)"></a>3.2 通过对象的序列化实现 (推荐)</h3><p><strong>对象需要实现序列化接口</strong></p><pre><code class="highlight java"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Sheep</span> <span class="keyword">implements</span> <span class="title class_">Serializable</span>, Cloneable&#123; <span class="comment">// 实现Cloneable接口， 重写clone方法</span>    <span class="keyword">private</span> String name;    <span class="keyword">private</span> <span class="type">int</span> age;    <span class="keyword">private</span> String color;    <span class="comment">// 对象.clone() 操作是浅拷贝，对于引用类型的属性，仅复制引用地址。</span>    <span class="keyword">public</span> SheepFriend friend; <span class="comment">// 这里添加了friend属性，属性值是一个引用类型</span>    <span class="keyword">public</span> <span class="title function_">Sheep</span><span class="params">(String name, <span class="type">int</span> age, String color)</span> &#123;        <span class="built_in">this</span>.name = name;        <span class="built_in">this</span>.age = age;        <span class="built_in">this</span>.color = color;    &#125;    <span class="comment">// 省略 getter / setter 方法</span>    <span class="comment">/**</span><span class="comment">     * 深拷贝-方式2：通过对象序列化实现(推荐)</span><span class="comment">     * <span class="doctag">@return</span></span><span class="comment">     */</span>    <span class="keyword">public</span> Sheep <span class="title function_">deepClone</span><span class="params">()</span> &#123;        <span class="comment">// 创建流对象</span>        <span class="type">ByteArrayOutputStream</span> <span class="variable">bos</span> <span class="operator">=</span> <span class="literal">null</span>;        <span class="type">ObjectOutputStream</span> <span class="variable">oos</span> <span class="operator">=</span> <span class="literal">null</span>;        <span class="type">ByteArrayInputStream</span> <span class="variable">bis</span> <span class="operator">=</span> <span class="literal">null</span>;        <span class="type">ObjectInputStream</span> <span class="variable">ois</span> <span class="operator">=</span> <span class="literal">null</span>;        <span class="keyword">try</span> &#123;            <span class="comment">// 序列化</span>            bos = <span class="keyword">new</span> <span class="title class_">ByteArrayOutputStream</span>();            oos = <span class="keyword">new</span> <span class="title class_">ObjectOutputStream</span>(bos);            oos.writeObject(<span class="built_in">this</span>); <span class="comment">// 将当前对象以对象流的形式输出</span>            <span class="comment">// 反序列化</span>            bis = <span class="keyword">new</span> <span class="title class_">ByteArrayInputStream</span>(bos.toByteArray());            ois = <span class="keyword">new</span> <span class="title class_">ObjectInputStream</span>(bis);            <span class="type">Sheep</span> <span class="variable">sheep</span> <span class="operator">=</span> (Sheep) ois.readObject();            <span class="keyword">return</span> sheep;        &#125; <span class="keyword">catch</span> (IOException e) &#123;            e.printStackTrace();        &#125; <span class="keyword">catch</span> (ClassNotFoundException e) &#123;            e.printStackTrace();        &#125;        <span class="keyword">return</span> <span class="literal">null</span>;    &#125;&#125;<span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">SheepFriend</span> <span class="keyword">implements</span> <span class="title class_">Serializable</span> &#123;    <span class="keyword">private</span> String name;    <span class="keyword">private</span> <span class="type">int</span> age;    <span class="keyword">private</span> String color;    <span class="keyword">public</span> <span class="title function_">SheepFriend</span><span class="params">(String name, <span class="type">int</span> age, String color)</span> &#123;        <span class="built_in">this</span>.name = name;        <span class="built_in">this</span>.age = age;        <span class="built_in">this</span>.color = color;    &#125;    <span class="comment">// 省略 getter / setter 方法</span>&#125;<span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Client</span> &#123;<span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> CloneNotSupportedException &#123;System.out.println(<span class="string">&quot;原型模式完成对象的创建&quot;</span>);<span class="type">Sheep</span> <span class="variable">sheep</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Sheep</span>(<span class="string">&quot;tom&quot;</span>, <span class="number">1</span>, <span class="string">&quot;白色&quot;</span>);sheep.friend = <span class="keyword">new</span> <span class="title class_">SheepFriend</span>(<span class="string">&quot;jack&quot;</span>, <span class="number">2</span>, <span class="string">&quot;黑色&quot;</span>);<span class="type">Sheep</span> <span class="variable">sheep2</span> <span class="operator">=</span> sheep.deepClone(); <span class="comment">//克隆</span><span class="type">Sheep</span> <span class="variable">sheep3</span> <span class="operator">=</span> sheep.deepClone(); <span class="comment">//克隆</span><span class="type">Sheep</span> <span class="variable">sheep4</span> <span class="operator">=</span> sheep.deepClone(); <span class="comment">//克隆</span><span class="type">Sheep</span> <span class="variable">sheep5</span> <span class="operator">=</span> sheep.deepClone(); <span class="comment">//克隆</span>System.out.println(<span class="string">&quot;sheep2 =&quot;</span> + sheep2 + <span class="string">&quot;sheep2.friend=&quot;</span> + sheep2.friend.hashCode());System.out.println(<span class="string">&quot;sheep3 =&quot;</span> + sheep3 + <span class="string">&quot;sheep3.friend=&quot;</span> + sheep3.friend.hashCode());System.out.println(<span class="string">&quot;sheep4 =&quot;</span> + sheep4 + <span class="string">&quot;sheep4.friend=&quot;</span> + sheep4.friend.hashCode());System.out.println(<span class="string">&quot;sheep5 =&quot;</span> + sheep5 + <span class="string">&quot;sheep5.friend=&quot;</span> + sheep5.friend.hashCode());&#125;&#125;</code></pre><blockquote><p>运行结果：</p><pre><code class="highlight shell">原型模式完成对象的创建sheep2 =com.george.prototype.deepclone.Sheep@3feba861sheep2.friend=1531448569sheep3 =com.george.prototype.deepclone.Sheep@6f496d9fsheep3.friend=1915910607sheep4 =com.george.prototype.deepclone.Sheep@10f87f48sheep4.friend=189568618sheep5 =com.george.prototype.deepclone.Sheep@2f4d3709sheep5.friend=1313922862</code></pre></blockquote><h1 id="五、原型模式的注意事项和细节"><a href="#五、原型模式的注意事项和细节" class="headerlink" title="五、原型模式的注意事项和细节"></a>五、原型模式的注意事项和细节</h1><ul><li>创建新的对象比较复杂时，可以利用原型模式简化对象的创建过程，同时也能够提高效率</li><li>不用重新初始化对象，而是动态地获得对象运行时的状态</li><li>如果原始对象发生变化(增加或者减少属性) ，其它克隆对象的也会发生相应的变化，无需修改代码</li><li>在实现深克隆的时候可能需要比较复杂的代码</li><li><strong>缺点：</strong>需要为每一个类配备一个克隆方法，这对全新的类来说不是很难，但对已有的类进行改造时，需要修改 其源代码，违背了ocp 原则.</li></ul>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;一、需求：克隆羊问题&quot;&gt;&lt;a href=&quot;#一、需求：克隆羊问题&quot; class=&quot;headerlink&quot; title=&quot;一、需求：克隆羊问题&quot;&gt;&lt;/a&gt;一、需求：克隆羊问题&lt;/h1&gt;&lt;p&gt;现在有一只羊 tom ，姓名为: tom,  年龄为：1 ，颜色为： 白色，</summary>
      
    
    
    
    <category term="设计模式" scheme="https://georgechan95.github.io/categories/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"/>
    
    
    <category term="设计模式" scheme="https://georgechan95.github.io/tags/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"/>
    
  </entry>
  
  <entry>
    <title>05-工厂模式</title>
    <link href="https://georgechan95.github.io/blog/effeea78.html"/>
    <id>https://georgechan95.github.io/blog/effeea78.html</id>
    <published>2024-11-04T13:00:00.000Z</published>
    <updated>2024-11-04T09:31:25.451Z</updated>
    
    <content type="html"><![CDATA[<h1 id="一、工厂模式概述"><a href="#一、工厂模式概述" class="headerlink" title="一、工厂模式概述"></a>一、工厂模式概述</h1><h2 id="1-什么是工厂设计模式？"><a href="#1-什么是工厂设计模式？" class="headerlink" title="1. 什么是工厂设计模式？"></a>1. 什么是工厂设计模式？</h2><p><strong>对象都需要创建，如果创建的时候直接 new 该对象，就会对该对象严重耦合</strong></p><p>假如我们要更换对象，所有 new 对象的地方都需要修改一遍，显然违背了软件设计的开闭原则（OCP）。如果我们使用工厂来生产对象，我们就只和工厂打交道就可以了，彻底和对象解耦，如果要更换对象，直接在工厂里更换该对象即可，达到了与对象解耦的目的；</p><p><strong><code>工厂模式最大的优点就是：解耦</code></strong></p><h2 id="2-工厂模式的实现方式"><a href="#2-工厂模式的实现方式" class="headerlink" title="2. 工厂模式的实现方式"></a>2. 工厂模式的实现方式</h2><p>一般情况下，工厂模式分为三种更加细分的类型：</p><ul><li>简单工厂</li><li>工厂方法</li><li>抽象工厂</li></ul><p>不过，在 GoF 的《设计模式》一书中，它将简单工厂模式看作是工厂方法模式的一种特例，所以工厂模式只被分成了工厂方法和抽象工厂两类。</p><h1 id="二、简单工厂（Simple-Factory）模式"><a href="#二、简单工厂（Simple-Factory）模式" class="headerlink" title="二、简单工厂（Simple Factory）模式"></a>二、简单工厂（Simple Factory）模式</h1><h2 id="1-业务需求：制作披萨"><a href="#1-业务需求：制作披萨" class="headerlink" title="1. 业务需求：制作披萨"></a>1. 业务需求：制作披萨</h2><p>当前有一个制作披萨的项目：要便于披萨种类的扩展，要便于维护</p><ul><li>披萨的种类很多(比如 GreekPizz[希腊披萨] 、CheesePizz[奶酪披萨]  等)</li><li>披萨的制作有 prepare(准备) ，bake(烘烤), cut(裁切), box(装盒)<ul><li>不同种类的披萨，要准备的食材是不同的</li></ul></li><li>披萨的制作有 prepare ，bake, cut, box</li></ul><h2 id="2-使用传统的方式来完成"><a href="#2-使用传统的方式来完成" class="headerlink" title="2. 使用传统的方式来完成"></a>2. 使用传统的方式来完成</h2><h3 id="2-1-UML类图"><a href="#2-1-UML类图" class="headerlink" title="2.1 UML类图"></a>2.1 UML类图</h3><p><img src="https://raw.githubusercontent.com/GeorgeChan95/blogimg/master/img/2024/11/04/20241104-111751.png" alt="传统方式订购披萨流程"></p><h3 id="2-2-关键代码"><a href="#2-2-关键代码" class="headerlink" title="2.2 关键代码"></a>2.2 关键代码</h3><pre><code class="highlight java"><span class="comment">// 将Pizza 类做成抽象</span><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">class</span> <span class="title class_">Pizza</span> &#123;    <span class="keyword">protected</span> String name; <span class="comment">//名字</span>    <span class="comment">//准备原材料, 不同的披萨不一样，因此，我们做成抽象方法</span>    <span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">void</span> <span class="title function_">prepare</span><span class="params">()</span>;    <span class="comment">// 烘培</span>    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">bake</span><span class="params">()</span> &#123;        System.out.println(name + <span class="string">&quot; baking;&quot;</span>);    &#125;    <span class="comment">// 裁切</span>    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">cut</span><span class="params">()</span> &#123;        System.out.println(name + <span class="string">&quot; cutting;&quot;</span>);    &#125;    <span class="comment">// 打包</span>    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">box</span><span class="params">()</span> &#123;        System.out.println(name + <span class="string">&quot; boxing;&quot;</span>);    &#125;    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setName</span><span class="params">(String name)</span> &#123;        <span class="built_in">this</span>.name = name;    &#125;&#125;<span class="comment">// 奶酪披萨</span><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">CheesePizza</span> <span class="keyword">extends</span> <span class="title class_">Pizza</span> &#123;    <span class="meta">@Override</span>    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">prepare</span><span class="params">()</span> &#123;        System.out.println(<span class="string">&quot; 给制作奶酪披萨 准备原材料 &quot;</span>);    &#125;&#125;<span class="comment">// 希腊披萨</span><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">GreekPizza</span> <span class="keyword">extends</span> <span class="title class_">Pizza</span> &#123;<span class="meta">@Override</span><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">prepare</span><span class="params">()</span> &#123;System.out.println(<span class="string">&quot; 给希腊披萨 准备原材料 &quot;</span>);&#125;&#125;<span class="comment">// 订购披萨</span><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">OrderPizza</span> &#123;    <span class="comment">// 构造器</span><span class="keyword">public</span> <span class="title function_">OrderPizza</span><span class="params">()</span> &#123;<span class="type">Pizza</span> <span class="variable">pizza</span> <span class="operator">=</span> <span class="literal">null</span>;String orderType; <span class="comment">// 订购披萨的类型</span><span class="keyword">do</span> &#123;orderType = getType();<span class="keyword">if</span> (orderType.equals(<span class="string">&quot;greek&quot;</span>)) &#123;pizza = <span class="keyword">new</span> <span class="title class_">GreekPizza</span>();pizza.setName(<span class="string">&quot; 希腊披萨 &quot;</span>);&#125; <span class="keyword">else</span> <span class="keyword">if</span> (orderType.equals(<span class="string">&quot;cheese&quot;</span>)) &#123;pizza = <span class="keyword">new</span> <span class="title class_">CheesePizza</span>();pizza.setName(<span class="string">&quot; 奶酪披萨 &quot;</span>);&#125; <span class="keyword">else</span> &#123;<span class="keyword">break</span>;&#125;<span class="comment">//输出pizza 制作过程</span>pizza.prepare();pizza.bake();pizza.cut();pizza.box();&#125; <span class="keyword">while</span> (<span class="literal">true</span>);&#125;    <span class="comment">// 写一个方法，获取客户希望订购的披萨种类</span>    <span class="keyword">private</span> String <span class="title function_">getType</span><span class="params">()</span> &#123;        <span class="keyword">try</span> &#123;            <span class="type">BufferedReader</span> <span class="variable">strin</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">BufferedReader</span>(<span class="keyword">new</span> <span class="title class_">InputStreamReader</span>(System.in));            System.out.println(<span class="string">&quot;input pizza 种类:&quot;</span>);            <span class="type">String</span> <span class="variable">str</span> <span class="operator">=</span> strin.readLine();            <span class="keyword">return</span> str;        &#125; <span class="keyword">catch</span> (IOException e) &#123;            e.printStackTrace();            <span class="keyword">return</span> <span class="string">&quot;&quot;</span>;        &#125;    &#125;&#125;<span class="comment">// 测试类</span><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">PizzaStore</span> &#123;    <span class="comment">// 测试披萨订购操作</span>    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;        <span class="keyword">new</span> <span class="title class_">OrderPizza</span>();    &#125;&#125;</code></pre><blockquote><p>测试结果：</p><pre><code class="highlight shell">input pizza 种类:greek 给希腊披萨 准备原材料  希腊披萨  baking; 希腊披萨  cutting; 希腊披萨  boxing;input pizza 种类:</code></pre></blockquote><h3 id="2-3-传统的方式的优缺点"><a href="#2-3-传统的方式的优缺点" class="headerlink" title="2.3 传统的方式的优缺点"></a>2.3 传统的方式的优缺点</h3><ul><li>优点是比较好理解，简单易操作。</li><li>缺点是违反了设计模式的 <strong>ocp 原则</strong>，即对扩展开放，对修改关闭。即当我们给类增加新功能的时候，尽量不修 改代码，或者尽可能少修改代码.</li><li>比如我们这时要新<strong>增加一个 Pizza 的种类(Pepper 披萨)</strong> ，我们需要做如下修改.</li></ul><pre><code class="highlight java"><span class="comment">// 胡椒披萨</span><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">PepperPizza</span> <span class="keyword">extends</span> <span class="title class_">Pizza</span> &#123;    <span class="meta">@Override</span>    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">prepare</span><span class="params">()</span> &#123;        System.out.println(<span class="string">&quot; 给胡椒披萨准备原材料 &quot;</span>);    &#125;&#125;<span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">OrderPizza</span> &#123;    <span class="comment">// 构造器</span><span class="keyword">public</span> <span class="title function_">OrderPizza</span><span class="params">()</span> &#123;<span class="type">Pizza</span> <span class="variable">pizza</span> <span class="operator">=</span> <span class="literal">null</span>;String orderType; <span class="comment">// 订购披萨的类型</span><span class="keyword">do</span> &#123;<span class="comment">// ...</span>&#125; <span class="keyword">else</span> <span class="keyword">if</span> (orderType.equals(<span class="string">&quot;pepper&quot;</span>)) &#123;pizza = <span class="keyword">new</span> <span class="title class_">PepperPizza</span>();pizza.setName(<span class="string">&quot;胡椒披萨&quot;</span>);&#125;         <span class="comment">// ...</span>&#125; <span class="keyword">while</span> (<span class="literal">true</span>);&#125;&#125;</code></pre><p><img src="https://raw.githubusercontent.com/GeorgeChan95/blogimg/master/img/2024/11/04/20241104-134414.png" alt="传统方式UML类图"></p><h3 id="2-4-改进的思路分析"><a href="#2-4-改进的思路分析" class="headerlink" title="2.4 改进的思路分析"></a>2.4 改进的思路分析</h3><p>分析：修改代码可以接受，但是如果我们在其它的地方也有创建 Pizza 的代码，就意味着，也需要修改，而创建 Pizza 的代码，往往有多处。</p><p>思路：把创建 Pizza 对象封装到一个类中，这样我们有新的 Pizza 种类时，只需要修改该类就可，其它有创建到 Pizza  对象的代码就不需要修改了 即：简单工厂模式</p><h3 id="2-5-简单工厂模式基本介绍"><a href="#2-5-简单工厂模式基本介绍" class="headerlink" title="2.5 简单工厂模式基本介绍"></a>2.5 简单工厂模式基本介绍</h3><ul><li><strong>简单工厂模式是属于创建型模式</strong>，是工厂模式的一种。简单工厂模式是由一个工厂对象决定创建出哪一种产品类的实例。简单工厂模式是工厂模式家族中最简单实用的模式</li><li>简单工厂模式：定义了一个创建对象的类，由这个类来封装实例化对象的行为(代码)</li><li>在软件开发中，当我们会用到大量的创建某种、某类或者某批对象时，就会使用到工厂模式.</li></ul><h3 id="2-6-使用简单工厂模式"><a href="#2-6-使用简单工厂模式" class="headerlink" title="2.6 使用简单工厂模式"></a>2.6 使用简单工厂模式</h3><p>简单工厂模式的设计方案:  定义一个可以实例化 Pizaa 对象的类: PizzaSimpleFactory，封装创建对象的代码。</p><p><img src="https://raw.githubusercontent.com/GeorgeChan95/blogimg/master/img/2024/11/04/20241104-144340.png" alt="使用简单工厂模式创建Pizza"></p><p><strong>关键代码</strong></p><pre><code class="highlight java"><span class="comment">// 简单工厂模式</span><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">PizzaSimpleFactory</span> &#123;    <span class="comment">/**</span><span class="comment">     * 简单工厂模式，创建Pizza对象</span><span class="comment">     * <span class="doctag">@param</span> orderType</span><span class="comment">     * <span class="doctag">@return</span></span><span class="comment">     */</span>    <span class="keyword">public</span> Pizza <span class="title function_">createPizza</span><span class="params">(String orderType)</span> &#123;        <span class="type">Pizza</span> <span class="variable">pizza</span> <span class="operator">=</span> <span class="literal">null</span>;        System.out.println(<span class="string">&quot;使用简单工厂模式&quot;</span>);        <span class="keyword">if</span> (orderType.equals(<span class="string">&quot;greek&quot;</span>)) &#123;            pizza = <span class="keyword">new</span> <span class="title class_">GreekPizza</span>();            pizza.setName(<span class="string">&quot; 希腊披萨 &quot;</span>);        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (orderType.equals(<span class="string">&quot;cheese&quot;</span>)) &#123;            pizza = <span class="keyword">new</span> <span class="title class_">CheesePizza</span>();            pizza.setName(<span class="string">&quot; 奶酪披萨 &quot;</span>);        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (orderType.equals(<span class="string">&quot;pepper&quot;</span>)) &#123;            pizza = <span class="keyword">new</span> <span class="title class_">PepperPizza</span>();            pizza.setName(<span class="string">&quot;胡椒披萨&quot;</span>);        &#125;        <span class="keyword">return</span> pizza;    &#125;&#125;<span class="comment">// 订购披萨</span><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">OrderPizza</span> &#123;<span class="comment">// 披萨工厂</span><span class="keyword">private</span> PizzaSimpleFactory pizzaFactory;<span class="comment">/**</span><span class="comment"> * 使用简单工厂模式构建Pizza对象</span><span class="comment"> * <span class="doctag">@param</span> simpleFactory</span><span class="comment"> */</span><span class="keyword">public</span> <span class="title function_">OrderPizza</span><span class="params">(PizzaSimpleFactory simpleFactory)</span> &#123;<span class="comment">// 设置披萨工厂</span>setFactory(simpleFactory);<span class="type">String</span> <span class="variable">orderType</span> <span class="operator">=</span> <span class="string">&quot;&quot;</span>; <span class="comment">//用户输入要制作的Pizza类型</span><span class="type">Pizza</span> <span class="variable">pizza</span> <span class="operator">=</span> <span class="literal">null</span>;<span class="keyword">do</span> &#123;orderType = getType();<span class="comment">// 使用披萨工厂对象创建披萨</span>pizza = <span class="built_in">this</span>.pizzaFactory.createPizza(orderType);<span class="comment">//输出pizza</span><span class="keyword">if</span>(pizza != <span class="literal">null</span>) &#123; <span class="comment">//订购成功</span>pizza.prepare();pizza.bake();pizza.cut();pizza.box();&#125; <span class="keyword">else</span> &#123;System.out.println(<span class="string">&quot; 订购披萨失败 &quot;</span>);<span class="keyword">break</span>;&#125;&#125; <span class="keyword">while</span> (<span class="literal">true</span>);&#125;<span class="comment">// 设置pizza工厂</span><span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">setFactory</span><span class="params">(PizzaSimpleFactory simpleFactory)</span> &#123;<span class="built_in">this</span>.pizzaFactory = simpleFactory;&#125;<span class="comment">// 写一个方法，获取客户希望订购的披萨种类</span>    <span class="keyword">private</span> String <span class="title function_">getType</span><span class="params">()</span> &#123;        <span class="keyword">try</span> &#123;            <span class="type">BufferedReader</span> <span class="variable">strin</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">BufferedReader</span>(<span class="keyword">new</span> <span class="title class_">InputStreamReader</span>(System.in));            System.out.println(<span class="string">&quot;input pizza 种类:&quot;</span>);            <span class="type">String</span> <span class="variable">str</span> <span class="operator">=</span> strin.readLine();            <span class="keyword">return</span> str;        &#125; <span class="keyword">catch</span> (IOException e) &#123;            e.printStackTrace();            <span class="keyword">return</span> <span class="string">&quot;&quot;</span>;        &#125;    &#125;&#125;</code></pre><h3 id="2-7-使用静态工厂模式"><a href="#2-7-使用静态工厂模式" class="headerlink" title="2.7 使用静态工厂模式"></a>2.7 使用静态工厂模式</h3><p>静态工厂模式也是简单工厂模式的一种，只是将工厂方法改为静态方法</p><p><img src="https://raw.githubusercontent.com/GeorgeChan95/blogimg/master/img/2024/11/04/20241104-145915.png" alt="静态工厂模式"></p><p><strong>关键代码：</strong></p><pre><code class="highlight java"><span class="comment">// 简单工厂模式</span><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">PizzaSimpleFactory</span> &#123;    <span class="comment">/**</span><span class="comment">     * 使用静态工厂模式创建Pizza对象</span><span class="comment">     * <span class="doctag">@param</span> orderType 用户输入的Pizza类型</span><span class="comment">     * <span class="doctag">@return</span></span><span class="comment">     */</span>    <span class="keyword">public</span> <span class="keyword">static</span> Pizza <span class="title function_">createPizza2</span><span class="params">(String orderType)</span> &#123;        <span class="type">Pizza</span> <span class="variable">pizza</span> <span class="operator">=</span> <span class="literal">null</span>;        System.out.println(<span class="string">&quot;使用静态工厂模式&quot;</span>);        <span class="keyword">if</span> (orderType.equals(<span class="string">&quot;greek&quot;</span>)) &#123;            pizza = <span class="keyword">new</span> <span class="title class_">GreekPizza</span>();            pizza.setName(<span class="string">&quot; 希腊披萨 &quot;</span>);        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (orderType.equals(<span class="string">&quot;cheese&quot;</span>)) &#123;            pizza = <span class="keyword">new</span> <span class="title class_">CheesePizza</span>();            pizza.setName(<span class="string">&quot; 奶酪披萨 &quot;</span>);        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (orderType.equals(<span class="string">&quot;pepper&quot;</span>)) &#123;            pizza = <span class="keyword">new</span> <span class="title class_">PepperPizza</span>();            pizza.setName(<span class="string">&quot;胡椒披萨&quot;</span>);        &#125;        <span class="keyword">return</span> pizza;    &#125;&#125;<span class="comment">// 使用静态工厂模式创建对象</span><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">OrderPizza2</span> &#123;    <span class="comment">/**</span><span class="comment">     * 使用静态工厂模式构建Pizza对象</span><span class="comment">     */</span>    <span class="keyword">public</span> <span class="title function_">OrderPizza2</span><span class="params">()</span> &#123;        <span class="type">String</span> <span class="variable">orderType</span> <span class="operator">=</span> <span class="string">&quot;&quot;</span>; <span class="comment">//用户输入要制作的Pizza类型</span>        <span class="type">Pizza</span> <span class="variable">pizza</span> <span class="operator">=</span> <span class="literal">null</span>;        <span class="keyword">do</span> &#123;            orderType = getType();            <span class="comment">// 使用披萨工厂对象创建披萨</span>            pizza = PizzaSimpleFactory.createPizza2(orderType);            <span class="comment">//输出pizza</span>            <span class="keyword">if</span>(pizza != <span class="literal">null</span>) &#123; <span class="comment">//订购成功</span>                pizza.prepare();                pizza.bake();                pizza.cut();                pizza.box();            &#125; <span class="keyword">else</span> &#123;                System.out.println(<span class="string">&quot; 订购披萨失败 &quot;</span>);                <span class="keyword">break</span>;            &#125;        &#125; <span class="keyword">while</span> (<span class="literal">true</span>);    &#125;&#125;</code></pre><h1 id="三、工厂方法（Factory-Method）模式"><a href="#三、工厂方法（Factory-Method）模式" class="headerlink" title="三、工厂方法（Factory Method）模式"></a>三、工厂方法（Factory Method）模式</h1><h2 id="1-披萨需求变更"><a href="#1-披萨需求变更" class="headerlink" title="1. 披萨需求变更"></a>1. 披萨需求变更</h2><p>披萨项目新的需求：客户在点披萨时，<strong>可以点不同口味的披萨</strong>，比如 北京的奶酪 pizza、北京的胡椒 pizza  或 者是伦敦的奶酪 pizza 、伦敦的胡椒 pizza。</p><p><strong>思路 1</strong></p><p>使用简单工厂模式，创建不同的简单工厂类，比如 BJPizzaSimpleFactory 、LDPizzaSimpleFactory  等等.从当前 这个案例来说，也是可以的，但是考虑到项目的规模，以及软件的可维护性、可扩展性并不是特别好</p><p><strong>思路 2</strong></p><p>使用工厂方法模式</p><h2 id="2-工厂方法模式介绍"><a href="#2-工厂方法模式介绍" class="headerlink" title="2. 工厂方法模式介绍"></a>2. 工厂方法模式介绍</h2><ul><li>工厂方法模式设计方案：将披萨项目的<strong>实例化功能抽象成抽象方法，在不同的口味点餐子类中具体实现</strong>。</li><li>工厂方法模式：<strong>定义了一个创建对象的抽象方法，由子类决定要实例化的类。工厂方法模式将对象的实例化推迟到子类</strong>。</li></ul><h2 id="3-工厂方法模式应用案例"><a href="#3-工厂方法模式应用案例" class="headerlink" title="3. 工厂方法模式应用案例"></a>3. 工厂方法模式应用案例</h2><p><strong>需求：</strong></p><p>客户在点披萨时，可以点不同口味的披萨，比如 北京的奶酪 pizza、北京的胡椒 pizza  或 者是伦敦的奶酪 pizza 、伦敦的胡椒 pizza</p><p><strong>设计UML类图</strong></p><p><img src="https://raw.githubusercontent.com/GeorgeChan95/blogimg/master/img/2024/11/04/20241104-154928.png" alt="工厂方法模式"></p><p><strong>关键代码</strong></p><pre><code class="highlight java"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">class</span> <span class="title class_">OrderPizza</span> &#123;    <span class="comment">// 定义成抽象方法，具体如何制作pizza由子类实现</span>    <span class="keyword">abstract</span> Pizza <span class="title function_">createPizza</span><span class="params">(String orderType)</span>;    <span class="comment">/**</span><span class="comment">     * 父类无参构造器</span><span class="comment">     * 当父类被子类继承后，自己调用子类的无参构造前，会先调用父类的无参构造</span><span class="comment">     */</span>    <span class="keyword">public</span> <span class="title function_">OrderPizza</span><span class="params">()</span> &#123;        <span class="type">Pizza</span> <span class="variable">pizza</span> <span class="operator">=</span> <span class="literal">null</span>;        String orderType; <span class="comment">// 订购披萨的类型</span>        <span class="keyword">do</span> &#123;            orderType = getType();            pizza = createPizza(orderType); <span class="comment">//抽象方法，由工厂子类完成</span>            <span class="comment">//输出pizza 制作过程</span>            pizza.prepare();            pizza.bake();            pizza.cut();            pizza.box();        &#125; <span class="keyword">while</span> (<span class="literal">true</span>);    &#125;    <span class="comment">// 写一个方法，可以获取客户希望订购的披萨种类</span>    <span class="keyword">private</span> String <span class="title function_">getType</span><span class="params">()</span> &#123;        <span class="keyword">try</span> &#123;            <span class="type">BufferedReader</span> <span class="variable">strin</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">BufferedReader</span>(<span class="keyword">new</span> <span class="title class_">InputStreamReader</span>(System.in));            System.out.println(<span class="string">&quot;input pizza 种类:&quot;</span>);            <span class="type">String</span> <span class="variable">str</span> <span class="operator">=</span> strin.readLine();            <span class="keyword">return</span> str;        &#125; <span class="keyword">catch</span> (IOException e) &#123;            e.printStackTrace();            <span class="keyword">return</span> <span class="string">&quot;&quot;</span>;        &#125;    &#125;&#125;<span class="comment">// 子类继承抽象类，实现具体的实例化对象方法</span><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">BJOrderPizza</span> <span class="keyword">extends</span> <span class="title class_">OrderPizza</span>&#123;    <span class="meta">@Override</span>    Pizza <span class="title function_">createPizza</span><span class="params">(String orderType)</span> &#123;        <span class="type">Pizza</span> <span class="variable">pizza</span> <span class="operator">=</span> <span class="literal">null</span>;        <span class="keyword">if</span> (orderType.equals(<span class="string">&quot;cheese&quot;</span>)) &#123;            pizza = <span class="keyword">new</span> <span class="title class_">BJCheesePizza</span>();        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (orderType.equals(<span class="string">&quot;pepper&quot;</span>)) &#123;            pizza = <span class="keyword">new</span> <span class="title class_">BJPepperPizza</span>();        &#125;        <span class="keyword">return</span> pizza;    &#125;&#125;<span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">LDOrderPizza</span> <span class="keyword">extends</span> <span class="title class_">OrderPizza</span>&#123;    <span class="meta">@Override</span>    Pizza <span class="title function_">createPizza</span><span class="params">(String orderType)</span> &#123;        <span class="type">Pizza</span> <span class="variable">pizza</span> <span class="operator">=</span> <span class="literal">null</span>;        <span class="keyword">if</span>(orderType.equals(<span class="string">&quot;cheese&quot;</span>)) &#123;            pizza = <span class="keyword">new</span> <span class="title class_">LDCheesePizza</span>();        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (orderType.equals(<span class="string">&quot;pepper&quot;</span>)) &#123;            pizza = <span class="keyword">new</span> <span class="title class_">LDPepperPizza</span>();        &#125;        <span class="keyword">return</span> pizza;    &#125;&#125;</code></pre><h1 id="四、抽象工厂（Abstract-Factory）模式"><a href="#四、抽象工厂（Abstract-Factory）模式" class="headerlink" title="四、抽象工厂（Abstract Factory）模式"></a>四、抽象工厂（Abstract Factory）模式</h1><h2 id="1-抽象工厂模式基本介绍"><a href="#1-抽象工厂模式基本介绍" class="headerlink" title="1. 抽象工厂模式基本介绍"></a>1. 抽象工厂模式基本介绍</h2><ul><li>抽象工厂模式：定义了一个 interface 用于创建相关或有依赖关系的对象簇，而无需指明具体的类</li><li>抽象工厂模式可以将简单工厂模式和工厂方法模式进行整合。</li><li>从设计层面看，抽象工厂模式就是对简单工厂模式的改进(或者称为进一步的抽象)。</li><li>将工厂抽象成两层，AbsFactory(抽象工厂)  和 具体实现的工厂子类。程序员可以根据创建对象类型使用对应 的工厂子类。这样将单个的简单工厂类变成了工厂簇，更利于代码的维护和扩展。</li></ul><h2 id="2-UML类图设计"><a href="#2-UML类图设计" class="headerlink" title="2. UML类图设计"></a>2. UML类图设计</h2><p><img src="https://raw.githubusercontent.com/GeorgeChan95/blogimg/master/img/2024/11/04/20241104-162713.png" alt="抽象工厂模式类图设计"></p><h2 id="3-关键代码"><a href="#3-关键代码" class="headerlink" title="3. 关键代码"></a>3. 关键代码</h2><pre><code class="highlight java"><span class="comment">// 定义抽象工厂模式的抽象层（接口）</span><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">AbsFactory</span> &#123;    <span class="comment">// 定义生产Pizza的方法，由子类具体实现</span>    Pizza <span class="title function_">createPizza</span><span class="params">(String orderType)</span>;&#125;<span class="comment">// 工厂子类，继承抽象工厂，实现生产实例的方法</span><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">BJFactory</span> <span class="keyword">implements</span> <span class="title class_">AbsFactory</span> &#123;    <span class="meta">@Override</span>    <span class="keyword">public</span> Pizza <span class="title function_">createPizza</span><span class="params">(String orderType)</span> &#123;        System.out.println(<span class="string">&quot;~使用的是抽象工厂模式~&quot;</span>);        <span class="type">Pizza</span> <span class="variable">pizza</span> <span class="operator">=</span> <span class="literal">null</span>;        <span class="keyword">if</span>(orderType.equals(<span class="string">&quot;cheese&quot;</span>)) &#123;            pizza = <span class="keyword">new</span> <span class="title class_">BJCheesePizza</span>();        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (orderType.equals(<span class="string">&quot;pepper&quot;</span>))&#123;            pizza = <span class="keyword">new</span> <span class="title class_">BJPepperPizza</span>();        &#125;        <span class="keyword">return</span> pizza;    &#125;&#125;<span class="comment">// 工厂子类，继承抽象工厂，实现生产实例的方法</span><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">LDFactory</span> <span class="keyword">implements</span> <span class="title class_">AbsFactory</span> &#123;    <span class="meta">@Override</span>    <span class="keyword">public</span> Pizza <span class="title function_">createPizza</span><span class="params">(String orderType)</span> &#123;        System.out.println(<span class="string">&quot;~使用的是抽象工厂模式~&quot;</span>);        <span class="type">Pizza</span> <span class="variable">pizza</span> <span class="operator">=</span> <span class="literal">null</span>;        <span class="keyword">if</span> (orderType.equals(<span class="string">&quot;cheese&quot;</span>)) &#123;            pizza = <span class="keyword">new</span> <span class="title class_">LDCheesePizza</span>();        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (orderType.equals(<span class="string">&quot;pepper&quot;</span>)) &#123;            pizza = <span class="keyword">new</span> <span class="title class_">LDPepperPizza</span>();        &#125;        <span class="keyword">return</span> pizza;    &#125;&#125;<span class="comment">// 订购Pizza类，完成工厂对象设置，生产实例的构建</span><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">OrderPizza</span> &#123;    <span class="keyword">private</span> AbsFactory factory;    <span class="comment">// 构造器传参，设置生产对象的具体工厂子类</span>    <span class="keyword">public</span> <span class="title function_">OrderPizza</span><span class="params">(AbsFactory factory)</span> &#123;        <span class="built_in">this</span>.factory = factory;        <span class="comment">// 生产Pizza</span>        createPizza();    &#125;    <span class="comment">/**</span><span class="comment">     * 生产pizza方法</span><span class="comment">     * <span class="doctag">@return</span></span><span class="comment">     */</span>    <span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">createPizza</span><span class="params">()</span> &#123;        <span class="type">Pizza</span> <span class="variable">pizza</span> <span class="operator">=</span> <span class="literal">null</span>;        <span class="type">String</span> <span class="variable">orderType</span> <span class="operator">=</span> <span class="string">&quot;&quot;</span>; <span class="comment">// 用户输入</span>        <span class="keyword">do</span> &#123;            orderType = getType();            <span class="comment">// factory 可能是北京的工厂子类，也可能是伦敦的工厂子类</span>            pizza = <span class="built_in">this</span>.factory.createPizza(orderType);            <span class="keyword">if</span> (pizza != <span class="literal">null</span>) &#123; <span class="comment">// 订购ok</span>                pizza.prepare();                pizza.bake();                pizza.cut();                pizza.box();            &#125; <span class="keyword">else</span> &#123;                System.out.println(<span class="string">&quot;订购失败&quot;</span>);                <span class="keyword">break</span>;            &#125;        &#125; <span class="keyword">while</span> (<span class="literal">true</span>);    &#125;    <span class="comment">// 写一个方法，可以获取客户希望订购的披萨种类</span>    <span class="keyword">private</span> String <span class="title function_">getType</span><span class="params">()</span> &#123;        <span class="keyword">try</span> &#123;            <span class="type">BufferedReader</span> <span class="variable">strin</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">BufferedReader</span>(<span class="keyword">new</span> <span class="title class_">InputStreamReader</span>(System.in));            System.out.println(<span class="string">&quot;input pizza 种类:&quot;</span>);            <span class="type">String</span> <span class="variable">str</span> <span class="operator">=</span> strin.readLine();            <span class="keyword">return</span> str;        &#125; <span class="keyword">catch</span> (IOException e) &#123;            e.printStackTrace();            <span class="keyword">return</span> <span class="string">&quot;&quot;</span>;        &#125;    &#125;&#125;</code></pre><h1 id="五、工厂模式总结"><a href="#五、工厂模式总结" class="headerlink" title="五、工厂模式总结"></a>五、工厂模式总结</h1><ul><li><p>工厂模式小结</p><p>将实例化对象的代码提取出来，放到一个类中统一管理和维护，达到和主项目的依赖关系的解耦。从而提高项 目的扩展和维护性。</p></li><li><p>三种工厂模式 (简单工厂模式、工厂方法模式、抽象工厂模式)</p></li><li><p>设计模式的依赖抽象原则</p><ul><li>创建对象实例时，不要直接 new  类,  而是把这个 new  类的动作放在一个工厂的方法中，并返回。有的书上说， 变量不要直接持有具体类的引用。</li><li>不要让类继承具体类，而是继承抽象类或者是实现 interface(接口)</li><li>不要覆盖基类中已经实现的方法。</li></ul></li></ul>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;一、工厂模式概述&quot;&gt;&lt;a href=&quot;#一、工厂模式概述&quot; class=&quot;headerlink&quot; title=&quot;一、工厂模式概述&quot;&gt;&lt;/a&gt;一、工厂模式概述&lt;/h1&gt;&lt;h2 id=&quot;1-什么是工厂设计模式？&quot;&gt;&lt;a href=&quot;#1-什么是工厂设计模式？&quot; cla</summary>
      
    
    
    
    <category term="设计模式" scheme="https://georgechan95.github.io/categories/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"/>
    
    
    <category term="设计模式" scheme="https://georgechan95.github.io/tags/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"/>
    
  </entry>
  
  <entry>
    <title>04-单例模式</title>
    <link href="https://georgechan95.github.io/blog/d7e99843.html"/>
    <id>https://georgechan95.github.io/blog/d7e99843.html</id>
    <published>2024-11-04T11:00:00.000Z</published>
    <updated>2024-11-04T02:16:24.422Z</updated>
    
    <content type="html"><![CDATA[<h1 id="一、单例设计模式介绍"><a href="#一、单例设计模式介绍" class="headerlink" title="一、单例设计模式介绍"></a>一、单例设计模式介绍</h1><p>所谓类的单例设计模式，就是采取一定的方法保证在整个的软件系统中，对某个类只能存在一个对象实例， 并且该类只提供一个取得其对象实例的方法(静态方法)。</p><p>比如 Hibernate 的 SessionFactory ，它充当数据存储源的代理，并负责创建 Session 对象。SessionFactory 并不是 轻量级的，一般情况下，一个项目通常只需要一个 SessionFactory 就够，这是就会使用到单例模式。</p><p><strong>实现单例模式的8种方式</strong></p><ul><li><strong>饿汉式(静态常量)</strong></li><li><strong>饿汉式（静态代码块）</strong></li><li>懒汉式(线程不安全)</li><li>懒汉式(线程安全，同步方法)</li><li>懒汉式(线程安全，同步代码块)</li><li><strong>双重检查</strong></li><li><strong>静态内部类</strong></li><li><strong>枚举</strong></li></ul><h1 id="二、饿汉式（静态常量）"><a href="#二、饿汉式（静态常量）" class="headerlink" title="二、饿汉式（静态常量）"></a>二、饿汉式（静态常量）</h1><p><strong>编程步骤如下：</strong></p><ul><li>构造器私有化 (防止 new )</li><li>类的内部创建对象</li><li>向外暴露一个静态的公共方法：<code>getInstance</code></li></ul><p><strong>代码实现如下：</strong></p><pre><code class="highlight java"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">SingletonTest01</span> &#123;    <span class="comment">/**</span><span class="comment">     * 测试方法</span><span class="comment">     * <span class="doctag">@param</span> args</span><span class="comment">     */</span>    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;        <span class="comment">//测试</span>        <span class="type">Singleton</span> <span class="variable">instance</span> <span class="operator">=</span> Singleton.getInstance();        <span class="type">Singleton</span> <span class="variable">instance2</span> <span class="operator">=</span> Singleton.getInstance();        System.out.println(instance == instance2); <span class="comment">// true</span>        System.out.println(<span class="string">&quot;instance.hashCode=&quot;</span> + instance.hashCode()); <span class="comment">// instance.hashCode=460141958</span>        System.out.println(<span class="string">&quot;instance2.hashCode=&quot;</span> + instance2.hashCode()); <span class="comment">// instance2.hashCode=460141958</span>    &#125;&#125;<span class="comment">/**</span><span class="comment"> * 单例模式：饿汉式（静态常量）</span><span class="comment"> */</span><span class="keyword">class</span> <span class="title class_">Singleton</span> &#123;    <span class="comment">// 1.构造器私有化</span>    <span class="keyword">private</span> <span class="title function_">Singleton</span><span class="params">()</span> &#123;    &#125;    <span class="comment">// 2.在类的内部创建对象实例</span>    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">Singleton</span> <span class="variable">instance</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Singleton</span>();    <span class="comment">// 3.提供一个公有的静态方法，返回实例对象</span>    <span class="keyword">public</span> <span class="keyword">static</span> Singleton <span class="title function_">getInstance</span><span class="params">()</span> &#123;        <span class="keyword">return</span> instance;    &#125;&#125;</code></pre><blockquote><p>测试结果：</p><pre><code class="highlight shell">trueinstance.hashCode=460141958instance2.hashCode=460141958</code></pre></blockquote><p><strong>优缺点说明</strong></p><ul><li>优点：这种写法比较简单，就是在类装载的时候就完成实例化。避免了线程同步问题。</li><li>缺点：在类装载的时候就完成实例化，没有达到 Lazy Loading 的效果。如果从始至终从未使用过这个实例，则 会造成内存的浪费</li></ul><p>结论：这种单例模式可用，可能造成内存浪费</p><h1 id="三、饿汉式（静态代码块）"><a href="#三、饿汉式（静态代码块）" class="headerlink" title="三、饿汉式（静态代码块）"></a>三、饿汉式（静态代码块）</h1><p><strong>代码实现如下：</strong></p><pre><code class="highlight java"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">SingletonTest02</span> &#123;    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;        <span class="comment">//测试</span>        <span class="type">Singleton</span> <span class="variable">instance</span> <span class="operator">=</span> Singleton.getInstance();        <span class="type">Singleton</span> <span class="variable">instance2</span> <span class="operator">=</span> Singleton.getInstance();        System.out.println(instance == instance2); <span class="comment">// true</span>        System.out.println(<span class="string">&quot;instance.hashCode=&quot;</span> + instance.hashCode());        System.out.println(<span class="string">&quot;instance2.hashCode=&quot;</span> + instance2.hashCode());    &#125;&#125;<span class="comment">/**</span><span class="comment"> * 单例模式：饿汉式(静态变量)</span><span class="comment"> */</span><span class="keyword">class</span> <span class="title class_">Singleton</span> &#123;    <span class="comment">//1. 构造器私有化, 外部能new</span>    <span class="keyword">private</span> <span class="title function_">Singleton</span><span class="params">()</span> &#123;    &#125;    <span class="comment">//2.本类内部创建对象实例</span>    <span class="keyword">private</span> <span class="keyword">static</span> Singleton instance;    <span class="keyword">static</span> &#123; <span class="comment">// 在静态代码块中，创建单例对象</span>        instance = <span class="keyword">new</span> <span class="title class_">Singleton</span>();    &#125;    <span class="comment">//3. 提供一个公有的静态方法，返回实例对象</span>    <span class="keyword">public</span> <span class="keyword">static</span> Singleton <span class="title function_">getInstance</span><span class="params">()</span> &#123;        <span class="keyword">return</span> instance;    &#125;&#125;</code></pre><blockquote><p>测试结果：</p><pre><code class="highlight shell">trueinstance.hashCode=460141958instance2.hashCode=460141958</code></pre></blockquote><p><strong>优缺点说明</strong></p><ul><li>优点：这种写法比较简单，就是在类装载的时候就完成实例化。避免了线程同步问题。(与上一种方式类似)</li><li>缺点：在类装载的时候就完成实例化，没有达到 Lazy Loading 的效果。如果从始至终从未使用过这个实例，则 会造成内存的浪费</li></ul><p>结论：这种单例模式可用，可能造成内存浪费</p><h1 id="四、懒汉式-线程不安全"><a href="#四、懒汉式-线程不安全" class="headerlink" title="四、懒汉式(线程不安全)"></a>四、懒汉式(线程不安全)</h1><p><strong>代码实现如下：</strong></p><pre><code class="highlight java"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">SingletonTest03</span> &#123;    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;        System.out.println(<span class="string">&quot;懒汉式1 ， 线程不安全~&quot;</span>);        <span class="type">Singleton</span> <span class="variable">instance</span> <span class="operator">=</span> Singleton.getInstance();        <span class="type">Singleton</span> <span class="variable">instance2</span> <span class="operator">=</span> Singleton.getInstance();        System.out.println(instance == instance2); <span class="comment">// true</span>        System.out.println(<span class="string">&quot;instance.hashCode=&quot;</span> + instance.hashCode());        System.out.println(<span class="string">&quot;instance2.hashCode=&quot;</span> + instance2.hashCode());    &#125;&#125;<span class="comment">/**</span><span class="comment"> * 单例模式：懒汉式（线程不安全的实现）</span><span class="comment"> */</span><span class="keyword">class</span> <span class="title class_">Singleton</span> &#123;    <span class="keyword">private</span> <span class="keyword">static</span> Singleton instance;    <span class="comment">//1. 构造器私有化, 外部能new</span>    <span class="keyword">private</span> <span class="title function_">Singleton</span><span class="params">()</span> &#123;    &#125;    <span class="comment">//提供一个静态的公有方法，当使用到该方法时，才去创建 instance</span>    <span class="comment">//即懒汉式</span>    <span class="keyword">public</span> <span class="keyword">static</span> Singleton <span class="title function_">getInstance</span><span class="params">()</span> &#123;        <span class="keyword">if</span> (instance == <span class="literal">null</span>) &#123; <span class="comment">// 多线程并发下，可能会new多个实例对象</span>            instance = <span class="keyword">new</span> <span class="title class_">Singleton</span>();        &#125;        <span class="keyword">return</span> instance;    &#125;&#125;</code></pre><blockquote><p>测试结果：</p><pre><code class="highlight shell">懒汉式1 ， 线程不安全~trueinstance.hashCode=460141958instance2.hashCode=460141958</code></pre></blockquote><p><strong>优缺点说明</strong></p><ul><li>起到了<strong>Lazy Loading</strong> 的效果，但是只能在单线程下使用。</li><li>如果在多线程下，一个线程进入了if (singleton &#x3D;&#x3D; null)判断语句块，还未来得及往下执行，另一个线程也通过 了这个判断语句，这时便会产生多个实例。所以在多线程环境下不可使用这种方式</li></ul><p>结论：<strong>在实际开发中，不要使用这种方式</strong>.</p><h1 id="五、懒汉式-线程安全，同步方法"><a href="#五、懒汉式-线程安全，同步方法" class="headerlink" title="五、懒汉式(线程安全，同步方法)"></a>五、懒汉式(线程安全，同步方法)</h1><p><strong>代码实现如下：</strong></p><pre><code class="highlight java"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">SingletonTest04</span> &#123;    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;        System.out.println(<span class="string">&quot;懒汉式2 ， 线程安全~&quot;</span>);        <span class="type">Singleton</span> <span class="variable">instance</span> <span class="operator">=</span> Singleton.getInstance();        <span class="type">Singleton</span> <span class="variable">instance2</span> <span class="operator">=</span> Singleton.getInstance();        System.out.println(instance == instance2); <span class="comment">// true</span>        System.out.println(<span class="string">&quot;instance.hashCode=&quot;</span> + instance.hashCode());        System.out.println(<span class="string">&quot;instance2.hashCode=&quot;</span> + instance2.hashCode());    &#125;&#125;<span class="comment">/**</span><span class="comment"> * 单例模式：懒汉式(线程安全，同步方法)</span><span class="comment"> */</span><span class="keyword">class</span> <span class="title class_">Singleton</span> &#123;    <span class="keyword">private</span> <span class="keyword">static</span> Singleton instance;    <span class="keyword">private</span> <span class="title function_">Singleton</span><span class="params">()</span> &#123;    &#125;    <span class="comment">//提供一个静态的公有方法，加入同步处理的代码，解决线程安全问题</span>    <span class="comment">//即懒汉式</span>    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">synchronized</span> Singleton <span class="title function_">getInstance</span><span class="params">()</span> &#123;        <span class="keyword">if</span> (instance == <span class="literal">null</span>) &#123;            instance = <span class="keyword">new</span> <span class="title class_">Singleton</span>();        &#125;        <span class="keyword">return</span> instance;    &#125;&#125;</code></pre><blockquote><p>测试结果：</p><pre><code class="highlight shell">懒汉式2 ， 线程安全~trueinstance.hashCode=460141958instance2.hashCode=460141958</code></pre></blockquote><p><strong>优缺点说明</strong></p><ul><li>解决了线程安全问题</li><li>效率太低了，每个线程在想获得类的实例时候，执行 getInstance()方法都要进行同步。而其实这个方法只执行 一次实例化代码就够了，后面的想获得该类实例，直接 return 就行了。<strong>方法执行效率太低</strong></li></ul><p>结论：在实际开发中，<strong>不推荐</strong>使用这种方式</p><h1 id="六、懒汉式-线程不安全，同步代码块"><a href="#六、懒汉式-线程不安全，同步代码块" class="headerlink" title="六、懒汉式(线程不安全，同步代码块)"></a>六、懒汉式(线程不安全，同步代码块)</h1><p><strong>代码实现如下</strong></p><pre><code class="highlight java"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">SingletonTest05</span> &#123;    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;        System.out.println(<span class="string">&quot;~懒汉式(线程不安全，同步代码块)~&quot;</span>);        <span class="type">Singleton</span> <span class="variable">instance</span> <span class="operator">=</span> Singleton.getInstance();        <span class="type">Singleton</span> <span class="variable">instance2</span> <span class="operator">=</span> Singleton.getInstance();        System.out.println(instance == instance2); <span class="comment">// true</span>        System.out.println(<span class="string">&quot;instance.hashCode=&quot;</span> + instance.hashCode());        System.out.println(<span class="string">&quot;instance2.hashCode=&quot;</span> + instance2.hashCode());    &#125;&#125;<span class="comment">/**</span><span class="comment"> * 单例模式：懒汉式(线程不安全，同步代码块)</span><span class="comment"> */</span><span class="keyword">class</span> <span class="title class_">Singleton</span> &#123;    <span class="keyword">private</span> <span class="keyword">static</span> Singleton instance;    <span class="keyword">private</span> <span class="title function_">Singleton</span><span class="params">()</span> &#123;    &#125;    <span class="keyword">public</span> <span class="keyword">static</span> Singleton <span class="title function_">getInstance</span><span class="params">()</span> &#123;        <span class="keyword">if</span> (instance == <span class="literal">null</span>) &#123;            <span class="comment">// 同步代码框放到 instance == null 后面，解决不了线程安全问题</span>            <span class="keyword">synchronized</span> (Singleton.class) &#123;                instance = <span class="keyword">new</span> <span class="title class_">Singleton</span>();            &#125;        &#125;        <span class="keyword">return</span> instance;    &#125;&#125;</code></pre><blockquote><p>测试结果：</p><pre><code class="highlight shell">~懒汉式(线程不安全，同步代码块)~trueinstance.hashCode=460141958instance2.hashCode=460141958</code></pre></blockquote><p><strong>优缺点说明</strong></p><ul><li>虽然加了 synchronized 做了同步，但是依然解决不了线程安全问题。在并发情况下，可能会出现两个线程都通过了if (singleton &#x3D;&#x3D; null)判断语句块，那么即使有synchronized， 也会创建多个实例。</li></ul><p>结论：在实际开发中，<strong>不可以</strong>使用这种方式</p><h1 id="七、双重检查"><a href="#七、双重检查" class="headerlink" title="七、双重检查"></a>七、双重检查</h1><p><strong>代码实现如下</strong></p><pre><code class="highlight java"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">SingletonTest06</span> &#123;    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;        System.out.println(<span class="string">&quot;双重检查&quot;</span>);        <span class="type">Singleton</span> <span class="variable">instance</span> <span class="operator">=</span> Singleton.getInstance();        <span class="type">Singleton</span> <span class="variable">instance2</span> <span class="operator">=</span> Singleton.getInstance();        System.out.println(instance == instance2); <span class="comment">// true</span>        System.out.println(<span class="string">&quot;instance.hashCode=&quot;</span> + instance.hashCode());        System.out.println(<span class="string">&quot;instance2.hashCode=&quot;</span> + instance2.hashCode());    &#125;&#125;<span class="comment">// 懒汉式(线程安全，同步方法)</span><span class="keyword">class</span> <span class="title class_">Singleton</span> &#123;    <span class="comment">// 使用 volatile 关键字，当对象发生变化时，其它线程及时感知到</span>    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">volatile</span> Singleton instance;    <span class="comment">// 构造器私有，不允许外部new对象</span>    <span class="keyword">private</span> <span class="title function_">Singleton</span><span class="params">()</span> &#123;    &#125;    <span class="comment">//提供一个静态的公有方法，加入双重检查代码，解决线程安全问题, 同时解决懒加载问题</span>    <span class="comment">//同时保证了效率, 推荐使用</span>    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">synchronized</span> Singleton <span class="title function_">getInstance</span><span class="params">()</span> &#123;        <span class="keyword">if</span> (instance == <span class="literal">null</span>) &#123;            <span class="keyword">synchronized</span> (Singleton.class) &#123;                <span class="keyword">if</span> (instance == <span class="literal">null</span>) &#123;                    instance = <span class="keyword">new</span> <span class="title class_">Singleton</span>();                &#125;            &#125;        &#125;        <span class="keyword">return</span> instance;    &#125;&#125;</code></pre><blockquote><p>测试结果：</p><pre><code class="highlight shell">双重检查trueinstance.hashCode=460141958instance2.hashCode=460141958</code></pre></blockquote><p><strong>优缺点说明</strong></p><ul><li>Double-Check 概念是多线程开发中常使用到的，如代码中所示，我们进行了两次 if (singleton &#x3D;&#x3D; null)检查，这 样就可以保证线程安全了。</li><li>这样，实例化代码只用执行一次，后面再次访问时，判断 if (singleton &#x3D;&#x3D; null) ，直接 return 实例化对象，也避 免的反复进行方法同步.</li><li><strong>线程安全；延迟加载；效率较高</strong></li></ul><p>结论：在实际开发中，<strong>推荐使用</strong>这种单例设计模式</p><h1 id="八、静态内部类"><a href="#八、静态内部类" class="headerlink" title="八、静态内部类"></a>八、静态内部类</h1><p><strong>代码实现如下</strong></p><pre><code class="highlight java"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">SingletonTest07</span> &#123;    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;        System.out.println(<span class="string">&quot;使用静态内部类完成单例模式&quot;</span>);        <span class="type">Singleton</span> <span class="variable">instance</span> <span class="operator">=</span> Singleton.getInstance();        <span class="type">Singleton</span> <span class="variable">instance2</span> <span class="operator">=</span> Singleton.getInstance();        System.out.println(instance == instance2); <span class="comment">// true</span>        System.out.println(<span class="string">&quot;instance.hashCode=&quot;</span> + instance.hashCode());        System.out.println(<span class="string">&quot;instance2.hashCode=&quot;</span> + instance2.hashCode());    &#125;&#125;<span class="comment">/**</span><span class="comment"> * 单例模式：静态内部类完成，推荐使用</span><span class="comment"> */</span><span class="keyword">class</span> <span class="title class_">Singleton</span> &#123;    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">volatile</span> Singleton instance;    <span class="comment">//构造器私有化</span>    <span class="keyword">private</span> <span class="title function_">Singleton</span><span class="params">()</span> &#123;    &#125;    <span class="comment">//写一个静态内部类,该类中有一个静态属性 Singleton</span>    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">class</span> <span class="title class_">SingletonInstance</span> &#123;        <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">Singleton</span> <span class="variable">INSTANCE</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Singleton</span>();    &#125;    <span class="comment">//提供一个静态的公有方法，直接返回SingletonInstance.INSTANCE</span>    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">synchronized</span> Singleton <span class="title function_">getInstance</span><span class="params">()</span> &#123;        <span class="keyword">return</span> SingletonInstance.INSTANCE;    &#125;&#125;</code></pre><blockquote><p>测试结果：</p><pre><code class="highlight shell">使用静态内部类完成单例模式trueinstance.hashCode=460141958instance2.hashCode=460141958</code></pre></blockquote><p><strong>优缺点说明：</strong></p><ul><li>这种方式采用了类装载的机制来保证初始化实例时只有一个线程。</li><li>静态内部类方式在 Singleton 类被装载时并不会立即实例化，而是在需要实例化时，调用 getInstance 方法，才会装载 SingletonInstance 类，从而完成 Singleton 的实例化。</li><li>类的静态属性只会在第一次加载类的时候初始化，所以在这里，JVM 帮助我们保证了线程的安全性，在类进行 初始化时，别的线程是无法进入的。</li><li><strong>优点：避免了线程不安全，利用静态内部类特点实现延迟加载，效率高</strong></li></ul><p>结论：推荐使用.</p><h1 id="九、枚举"><a href="#九、枚举" class="headerlink" title="九、枚举"></a>九、枚举</h1><p><strong>代码实现如下</strong></p><pre><code class="highlight java"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">SingletonTest08</span> &#123;    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;        <span class="type">Singleton</span> <span class="variable">instance</span> <span class="operator">=</span> Singleton.INSTANCE;        <span class="type">Singleton</span> <span class="variable">instance2</span> <span class="operator">=</span> Singleton.INSTANCE;        System.out.println(instance == instance2);        System.out.println(instance.hashCode());        System.out.println(instance2.hashCode());        instance.sayOk();    &#125;&#125;<span class="comment">/**</span><span class="comment"> * 单例模式，基于枚举实现，（推荐）</span><span class="comment"> */</span><span class="keyword">enum</span> <span class="title class_">Singleton</span> &#123;    INSTANCE;    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">sayOk</span><span class="params">()</span> &#123;        System.out.println(<span class="string">&quot;~ok~&quot;</span>);    &#125;&#125;</code></pre><blockquote><p>测试结果：</p><pre><code class="highlight shell">true460141958460141958~ok~</code></pre></blockquote><p><strong>优缺点说明</strong></p><ul><li>这借助 JDK1.5 中添加的枚举来实现单例模式。不仅能避免多线程同步问题，而且还能防止反序列化重新创建 新的对象。</li><li>这种方式是 <strong>Effective Java 作者 Josh Bloch  提倡的方式</strong></li></ul><p>结论：推荐使用</p><h1 id="十、单例模式在JDK源码中的应用"><a href="#十、单例模式在JDK源码中的应用" class="headerlink" title="十、单例模式在JDK源码中的应用"></a>十、单例模式在JDK源码中的应用</h1><p>最典型的就是 java.lang.Runtime 类，获取Runtime对象使用到的就是单例模式，且是饿汉式。</p><pre><code class="highlight java"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Runtime</span> &#123;    <span class="keyword">private</span> <span class="keyword">static</span> <span class="type">Runtime</span> <span class="variable">currentRuntime</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Runtime</span>();    <span class="comment">/**</span><span class="comment">     * Returns the runtime object associated with the current Java application.</span><span class="comment">     * Most of the methods of class &lt;code&gt;Runtime&lt;/code&gt; are instance</span><span class="comment">     * methods and must be invoked with respect to the current runtime object.</span><span class="comment">     *</span><span class="comment">     * <span class="doctag">@return</span>  the &lt;code&gt;Runtime&lt;/code&gt; object associated with the current</span><span class="comment">     *          Java application.</span><span class="comment">     */</span>    <span class="keyword">public</span> <span class="keyword">static</span> Runtime <span class="title function_">getRuntime</span><span class="params">()</span> &#123;        <span class="keyword">return</span> currentRuntime;    &#125;    <span class="comment">/** Don&#x27;t let anyone else instantiate this class */</span>    <span class="keyword">private</span> <span class="title function_">Runtime</span><span class="params">()</span> &#123;&#125;    &#125;</code></pre><h1 id="十一、单例模式注意事项和细节说明"><a href="#十一、单例模式注意事项和细节说明" class="headerlink" title="十一、单例模式注意事项和细节说明"></a>十一、单例模式注意事项和细节说明</h1><ul><li>单例模式保证了 系统内存中该类只存在一个对象，节省了系统资源，对于一些需要频繁创建销毁的对象，使用单例模式可以提高系统性能。</li><li>当想实例化一个单例类的时候，必须要记住使用相应的获取对象的方法，而不是使用 new</li></ul><p><strong>单例模式使用的场景：</strong></p><ul><li>需要频繁的进行创建和销毁的对象</li><li>创建对象时耗时过多或耗费资源过多(即：重量级 对象) ，但又经常用到的对象</li><li>工具类对象</li><li>频繁访问数据库或文件的对象(比如数据源、session 工厂等)</li></ul>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;一、单例设计模式介绍&quot;&gt;&lt;a href=&quot;#一、单例设计模式介绍&quot; class=&quot;headerlink&quot; title=&quot;一、单例设计模式介绍&quot;&gt;&lt;/a&gt;一、单例设计模式介绍&lt;/h1&gt;&lt;p&gt;所谓类的单例设计模式，就是采取一定的方法保证在整个的软件系统中，对某个类只能</summary>
      
    
    
    
    <category term="设计模式" scheme="https://georgechan95.github.io/categories/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"/>
    
    
    <category term="设计模式" scheme="https://georgechan95.github.io/tags/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"/>
    
  </entry>
  
  <entry>
    <title>03-UML类图</title>
    <link href="https://georgechan95.github.io/blog/90f1850a.html"/>
    <id>https://georgechan95.github.io/blog/90f1850a.html</id>
    <published>2024-11-02T06:57:00.000Z</published>
    <updated>2024-11-04T00:36:27.094Z</updated>
    
    <content type="html"><![CDATA[<h1 id="一、UML-基本介绍"><a href="#一、UML-基本介绍" class="headerlink" title="一、UML 基本介绍"></a>一、UML 基本介绍</h1><ul><li>UML—-Unified modeling language UML（统一建模语言），是一种用于软件系统分析和设计的语言工具，它用于帮助软件开发人员进行思考和记录思路的结果 </li><li>UML 本身是一套符号的规定，就像数学符号和化学符号一样，这些符号用于描述软件模型中的各个元素和他们之间的关系，比如类、接口、实现、泛化、依赖、组合、聚合等 </li><li>使用 UML 来建模，常用的工具有 Rational Rose、Astah Professional，也可以使用一些插件来建模</li></ul><h1 id="二、UML-图"><a href="#二、UML-图" class="headerlink" title="二、UML 图"></a>二、UML 图</h1><p>画 UML 图与写文章差不多，都是把自己的思想描述给别人看，关键在于思路和条理，UML图分类：</p><ul><li>用例图（use case）</li><li>静态结构图：<strong>类图</strong>、对象图、包图、组件图、部署图</li><li>动态行为图：交互图（时序图与协作图）、状态图、活动图</li></ul><p>**说明: **类图是描述类与类之间的关系的，是 UML 图中最核心的</p><h1 id="三、UML类图"><a href="#三、UML类图" class="headerlink" title="三、UML类图"></a>三、UML类图</h1><ul><li>用于描述系统中的类(对象)本身的组成和类(对象)之间的各种静态关系。</li><li>类之间的关系：依赖、泛化（继承）、实现、关联、聚合与组合。</li></ul><h2 id="1-为什么要用UML？类图的作用"><a href="#1-为什么要用UML？类图的作用" class="headerlink" title="1. 为什么要用UML？类图的作用"></a>1. 为什么要用UML？类图的作用</h2><p>UML展现了一系列最佳工程实践，这些最佳实践在对大规模，复杂系统进行建模方面，特别是在软件架构层次已经被验证有效。</p><p> <strong>类图的作用：</strong></p><ul><li>在软件工程中，类图是一种静态的结构图，描述了系统的类的集合，类的属性和类之间的关系，可以简化了人们对系统的理解；</li><li>类图是系统分析和设计阶段的重要产物，是系统编码和测试的重要模型。</li></ul><h2 id="2-UML-类图可见性符号的表示"><a href="#2-UML-类图可见性符号的表示" class="headerlink" title="2. UML 类图可见性符号的表示"></a>2. UML 类图可见性符号的表示</h2><ul><li>可见性<ul><li>公有（public） “+”</li><li>受保护（protected） “#”</li><li>私有（private） “-”</li></ul></li></ul><p>类与类之间的关系主要有六种：<strong>继承、实现、组合、聚合、关联 和 依赖</strong>，这六种关系的箭头表示都不一样</p><img src="https://raw.githubusercontent.com/GeorgeChan95/blogimg/master/img/2024/11/02/20241102-160513.png!large" alt="类图关系符号表示" style="zoom: 67%;" /><h2 id="3-类的UML的介绍和画法"><a href="#3-类的UML的介绍和画法" class="headerlink" title="3. 类的UML的介绍和画法"></a>3. 类的UML的介绍和画法</h2><p>类的UML使用包含<strong>类名、属性、方法名以及参数</strong>。使用带分割线的长方形表示。</p><p><strong>代码演示：</strong></p><pre><code class="highlight java"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Person</span> &#123;    <span class="keyword">public</span> String name;    <span class="keyword">protected</span> <span class="type">int</span> age;    <span class="keyword">private</span> <span class="type">String</span> <span class="variable">accommodation</span> <span class="operator">=</span> <span class="string">&quot;Earth&quot;</span>;<span class="comment">//住所</span>    <span class="keyword">public</span> String <span class="title function_">getName</span><span class="params">()</span> &#123;        <span class="keyword">return</span> name;    &#125;    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setName</span><span class="params">(String name)</span> &#123;        <span class="built_in">this</span>.name = name;    &#125;    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">getAge</span><span class="params">()</span> &#123;        <span class="keyword">return</span> age;    &#125;    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setAge</span><span class="params">(<span class="type">int</span> age)</span> &#123;        <span class="built_in">this</span>.age = age;    &#125;    <span class="keyword">public</span> String <span class="title function_">getAccommodation</span><span class="params">()</span> &#123;        <span class="keyword">return</span> accommodation;    &#125;    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setAccommodation</span><span class="params">(String accommodation)</span> &#123;        <span class="built_in">this</span>.accommodation = accommodation;    &#125;&#125;</code></pre><p><strong>UML类图</strong></p><p><img src="https://raw.githubusercontent.com/GeorgeChan95/blogimg/master/img/2024/11/03/20241103-150807.jpeg" alt="UML类图"></p><p> 如上这个类图，Person类有三部分组成，分别是<strong>类名</strong>、<strong>属性</strong>和<strong>操作方法</strong>，下面一一进行介绍：</p><ul><li><p>类名</p><p>就是Java类的名字， 如果是类是抽象类则类名显示为斜体！ 其他地方不做改动。</p><blockquote><p><em>Person</em></p></blockquote></li><li><p>属性名</p><p>就是java中的成员变量，一个类可以零到多个属性，java中属性（成员变量）的修饰符，类型和默认值都可以在UML中体现出来。通常用的表达式如下：</p><blockquote><p>可见性 名称：类型[&#x3D;默认值]</p></blockquote><ul><li><p>在Java中可见性分为三类，分别是public、private和protected，在类图分别用+、-和#表示；</p></li><li><p>名称为属性的名称；</p></li><li><p>类型在java中有八种基本的数据类型（byte、short、 int、long、 float、 double、 char、 boolean）及String和一些自定义的类型。默认值如变量 accommodation 有初始值为 Earth！</p></li></ul></li><li><p>操作方法</p><p>在java中类的操作方法也是有个通用的表达式如下：</p><blockquote><p>可见性 名称（[参数列表：参数1，参数2]）：返回类型[：void]</p></blockquote><p>可见性如上名称表达式的介绍，名称就是方法名，参数列表是可选的项，多参数的话参数直接用英文逗号隔开；返回值也是个可选项，返回值类型可以说基本的数据类型、用户自定义类型和void。如果是构造方法，则无返回类型！</p></li></ul><h2 id="4-类之间关系UML的介绍和画法"><a href="#4-类之间关系UML的介绍和画法" class="headerlink" title="4. 类之间关系UML的介绍和画法"></a>4. 类之间关系UML的介绍和画法</h2><h3 id="4-1-泛化（Generalization）关系"><a href="#4-1-泛化（Generalization）关系" class="headerlink" title="4.1 泛化（Generalization）关系"></a>4.1 泛化（Generalization）关系</h3><p>泛化（Generalization）关系 ：<strong>空心箭头实线表示，箭头指向个人</strong></p><blockquote><p>泛化关系表示类与类之间的继承关系，类和类，接口和接口都可以是继承关系，父类称为基类或者超类，子类称为派生类。子类继承父类实现父类的所有功能，并拥有父类没有的功能！</p></blockquote><p>**示例代码:**两个子类继承Person类</p><pre><code class="highlight java"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Person</span> &#123;    <span class="keyword">public</span> String name;    <span class="keyword">protected</span> <span class="type">int</span> age;    <span class="keyword">private</span> <span class="type">String</span> <span class="variable">accommodation</span> <span class="operator">=</span> <span class="string">&quot;Earth&quot;</span>;<span class="comment">//住所</span>    <span class="keyword">public</span> String <span class="title function_">getName</span><span class="params">()</span> &#123;        <span class="keyword">return</span> name;    &#125;    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setName</span><span class="params">(String name)</span> &#123;        <span class="built_in">this</span>.name = name;    &#125;    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">getAge</span><span class="params">()</span> &#123;        <span class="keyword">return</span> age;    &#125;    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setAge</span><span class="params">(<span class="type">int</span> age)</span> &#123;        <span class="built_in">this</span>.age = age;    &#125;    <span class="keyword">public</span> String <span class="title function_">getAccommodation</span><span class="params">()</span> &#123;        <span class="keyword">return</span> accommodation;    &#125;    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setAccommodation</span><span class="params">(String accommodation)</span> &#123;        <span class="built_in">this</span>.accommodation = accommodation;    &#125;&#125;<span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">USAMan</span> <span class="keyword">extends</span> <span class="title class_">Person</span> &#123;    <span class="keyword">private</span> <span class="type">String</span> <span class="variable">language</span> <span class="operator">=</span> <span class="string">&quot;English&quot;</span>;    <span class="keyword">public</span>  <span class="keyword">void</span> <span class="title function_">sayHello</span><span class="params">()</span>&#123;        System.out.println(<span class="string">&quot;Welcome to USA !&quot;</span>);    &#125;&#125;<span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ChineseMan</span> <span class="keyword">extends</span> <span class="title class_">Person</span> &#123;    <span class="keyword">private</span> <span class="type">String</span> <span class="variable">skinColor</span> <span class="operator">=</span> <span class="string">&quot;yellow&quot;</span>;    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">sayHello</span><span class="params">()</span> &#123;        System.out.println(<span class="string">&quot;欢迎来中国 !&quot;</span>);    &#125;&#125;</code></pre><p><strong>UML图</strong></p><p><img src="https://raw.githubusercontent.com/GeorgeChan95/blogimg/master/img/2024/11/03/20241103-152201.jpeg" alt="泛化关系UML图"></p><h3 id="4-2-实现（Realization）关系"><a href="#4-2-实现（Realization）关系" class="headerlink" title="4.2 实现（Realization）关系"></a>4.2 实现（Realization）关系</h3><p>实现（Realization）关系 ：<strong>空心箭头虚线表示，箭头指向约定的元素</strong></p><blockquote><p>实现关系就是java中的一个类和接口之间的关系，接口中一般是没有成员变量。所有操作都是抽象的，只有声明没有具体的实现。</p></blockquote><p><strong>示例代码</strong></p><pre><code class="highlight java"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">Car</span> &#123;    <span class="comment">//车的牌子</span>    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">brand</span><span class="params">()</span>;&#125;<span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">LandRover</span> <span class="keyword">implements</span> <span class="title class_">Car</span>&#123;    <span class="meta">@Override</span>    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">brand</span><span class="params">()</span> &#123;        System.out.println(<span class="string">&quot;This is a LandRover&quot;</span>);    &#125;&#125;</code></pre><p><strong>UML类图</strong></p><p><img src="https://raw.githubusercontent.com/GeorgeChan95/blogimg/master/img/2024/11/03/20241103-162026.jpeg" alt="实现关系"></p><h3 id="4-3-依赖（Dependence）关系"><a href="#4-3-依赖（Dependence）关系" class="headerlink" title="4.3 依赖（Dependence）关系"></a>4.3 依赖（Dependence）关系</h3><p>依赖（Dependence）关系：<strong>虚线箭头表示，箭头指向被依赖的对象</strong></p><blockquote><p>依赖关系是类与类之间最弱的关系，A元素变化会影响B元素，反之不成立。说简单点就是一个类使用了另一个类，这种关系具有临时性特征，一个类的改变由于另一类而受影响。</p></blockquote><p><strong>示例代码</strong></p><pre><code class="highlight java"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ChineseMan</span> <span class="keyword">extends</span> <span class="title class_">LandRover</span> &#123;    <span class="keyword">private</span> <span class="type">String</span> <span class="variable">skinColor</span> <span class="operator">=</span> <span class="string">&quot;yellow&quot;</span>;    <span class="keyword">public</span>  <span class="keyword">void</span> <span class="title function_">sayHello</span><span class="params">()</span>&#123;        System.out.println(<span class="string">&quot;欢迎来中国 !&quot;</span>);    &#125;    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">useCar</span><span class="params">(LandRover car)</span>&#123;        car.brand();    &#125;&#125;</code></pre><p><strong>UML类图</strong></p><p><img src="https://raw.githubusercontent.com/GeorgeChan95/blogimg/master/img/2024/11/03/20241103-163200.jpeg" alt="依赖关系"></p><h3 id="4-4-关联（Association）关系"><a href="#4-4-关联（Association）关系" class="headerlink" title="4.4 关联（Association）关系"></a>4.4 关联（Association）关系</h3><p>关联关系：<strong>实线箭头表示，箭头指向（也可以双向）被依赖元素</strong></p><blockquote><p>关联关系表示一个类和另一类有联系，它使一个类知道另一个类的属性和方法，被关联的元素间通常可以被独立的考虑。</p></blockquote><ul><li>关联具有导航性：即双向关系或单向关系</li><li>关系具有多重性：如“1”（表示有且仅有一个），“0…”（表示0个或者多个），“0，1”（表示0个或者一个），“n…m”（表示n到m个都可以），“m…*”（表示至少m个）</li></ul><p><strong>一对一的关联关系</strong></p><pre><code class="highlight java"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">YanAnMan</span> &#123;    <span class="keyword">public</span> ChineseMan cm;&#125;</code></pre><p><img src="https://raw.githubusercontent.com/GeorgeChan95/blogimg/master/img/2024/11/03/20241103-164514.png" alt="一对一的关联关系"></p><p><strong>一对多的关联关系</strong></p><pre><code class="highlight java"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">YanAnMan</span> &#123;    <span class="keyword">public</span> List&lt;ChineseMan&gt; manList;&#125;</code></pre><p><img src="https://raw.githubusercontent.com/GeorgeChan95/blogimg/master/img/2024/11/03/20241103-164620.png" alt="一对多的关联关系"></p><p><strong>说明:</strong></p><ul><li><p>1…1表示另一个类的一个对象只与该类的一个对象有关系 </p></li><li><p>0…* 表示另一个类的一个对象与该类的零个或多个对象有关系 </p></li><li><p>1…* 表示另一个类的一个对象与该类的一个或多个对象有关系 </p></li><li><p>0…1表示另一个类的一个对象没有或只与该类的一个对象有关系</p></li></ul><h3 id="4-5-聚合（Aggregation）关系"><a href="#4-5-聚合（Aggregation）关系" class="headerlink" title="4.5 聚合（Aggregation）关系"></a>4.5 聚合（Aggregation）关系</h3><p>聚合（Aggregation）关系：<strong>带空心菱形头的实线表示，菱形头指向整体</strong></p><blockquote><p>聚合关系是整体和部分的关系，是一种强的关系，但是部分可以脱离整体而存在。是关联关系的一种。</p></blockquote><p>例如电脑与鼠标, 显示器就是一种聚合关系<br><strong>示例代码:</strong></p><pre><code class="highlight java"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Computer</span> &#123;    <span class="keyword">private</span> Mouse mouse; <span class="comment">//鼠标可以和computer分离</span>    <span class="keyword">private</span> Moniter moniter;<span class="comment">//显示器可以和Computer分离</span>    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setMouse</span><span class="params">(Mouse mouse)</span> &#123;        <span class="built_in">this</span>.mouse = mouse;    &#125;    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setMoniter</span><span class="params">(Moniter moniter)</span> &#123;        <span class="built_in">this</span>.moniter = moniter;    &#125;&#125;<span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Moniter</span> &#123;&#125;<span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Mouse</span> &#123;&#125;</code></pre><p><img src="C:/Users/George/AppData/Roaming/Typora/typora-user-images/image-20241103170123052.png" alt="聚合关系"></p><h3 id="4-6-组合（Composition）关系"><a href="#4-6-组合（Composition）关系" class="headerlink" title="4.6 组合（Composition）关系"></a>4.6 组合（Composition）关系</h3><p>组合（Composition）关系：<strong>带实心菱形头的实线表示，菱形头指向整体</strong></p><blockquote><p> 组合关系是聚合关系的一种变种，便是了更强的组合关系，它要求整体的对象代表部分对象的生命周期。</p></blockquote><p>例如没个人都有头和脚, 那么头和脚与人之间就是组合关系</p><p><strong>示例代码</strong></p><pre><code class="highlight java"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Person</span> &#123;    <span class="keyword">private</span> <span class="type">Head</span> <span class="variable">head</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Head</span>();    <span class="keyword">private</span> <span class="type">Foot</span> <span class="variable">foot</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Foot</span>();&#125;<span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Head</span> &#123;&#125;<span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Foot</span> &#123;&#125;</code></pre><p><img src="https://raw.githubusercontent.com/GeorgeChan95/blogimg/master/img/2024/11/03/20241103-171114.png" alt="image-20241103171111415"></p><h1 id="四、常用的UML绘图工具"><a href="#四、常用的UML绘图工具" class="headerlink" title="四、常用的UML绘图工具"></a>四、常用的UML绘图工具</h1><p>Visual Paradigm,  ProcessOn,  Microsoft Visio,  百度脑图</p><p>本篇使用了 <code>百度脑图</code> 和 <code>Visual Paradigm</code></p><p><strong>参考链接</strong></p><blockquote><p><a href="https://learnku.com/articles/30316">https://learnku.com/articles/30316</a></p><p><a href="https://www.yuque.com/u21195183/fnz31h/oo4otl#11394542">https://www.yuque.com/u21195183/fnz31h/oo4otl#11394542</a></p><p><a href="https://www.cnblogs.com/StarbucksBoy/p/16795809.html">https://www.cnblogs.com/StarbucksBoy/p/16795809.html</a></p></blockquote>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;一、UML-基本介绍&quot;&gt;&lt;a href=&quot;#一、UML-基本介绍&quot; class=&quot;headerlink&quot; title=&quot;一、UML 基本介绍&quot;&gt;&lt;/a&gt;一、UML 基本介绍&lt;/h1&gt;&lt;ul&gt;
&lt;li&gt;UML—-Unified modeling language U</summary>
      
    
    
    
    <category term="设计模式" scheme="https://georgechan95.github.io/categories/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"/>
    
    
    <category term="设计模式" scheme="https://georgechan95.github.io/tags/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"/>
    
    <category term="UML" scheme="https://georgechan95.github.io/tags/UML/"/>
    
  </entry>
  
  <entry>
    <title>02-UML图绘制工具</title>
    <link href="https://georgechan95.github.io/blog/c13304c1.html"/>
    <id>https://georgechan95.github.io/blog/c13304c1.html</id>
    <published>2024-11-02T01:57:00.000Z</published>
    <updated>2024-11-02T03:40:23.311Z</updated>
    
    <content type="html"><![CDATA[<h1 id="一、UML绘图工具"><a href="#一、UML绘图工具" class="headerlink" title="一、UML绘图工具"></a>一、UML绘图工具</h1><p>UML绘制工具有很多，这里仅介绍两种。</p><ul><li><p>IDEA自带插件：<code>Diagrams</code></p><p>用于查看类与类之间的关联关系</p></li><li><p>UML绘制工具：Astah Professional</p><p>专业的UML绘图工具，这里使用的是 <code>Astah Pro 8</code></p></li></ul><h2 id="1-IDEA自带插件：Diagrams"><a href="#1-IDEA自带插件：Diagrams" class="headerlink" title="1. IDEA自带插件：Diagrams"></a>1. IDEA自带插件：Diagrams</h2><h3 id="1-1-设置-Diagrams"><a href="#1-1-设置-Diagrams" class="headerlink" title="1.1 设置 Diagrams"></a>1.1 设置 Diagrams</h3><p>在idea中，依次打开 <code>File</code> –&gt; Settings –&gt; <code>Tools</code> –&gt; <code>Diagrams</code> </p><p>设置Diagrams如下，选择： <code>字段</code>、<code>构造器</code>、<code>方法</code></p><p><img src="https://raw.githubusercontent.com/GeorgeChan95/blogimg/master/img/2024/11/02/20241102-101823.png" alt="设置 Diagrams"></p><h3 id="1-2-使用-Diagrams"><a href="#1-2-使用-Diagrams" class="headerlink" title="1.2 使用 Diagrams"></a>1.2 使用 Diagrams</h3><h4 id="1-2-1-示例代码"><a href="#1-2-1-示例代码" class="headerlink" title="1.2.1 示例代码"></a>1.2.1 示例代码</h4><p>有如下三个类，<code>Computer</code>、<code>Moniter</code> 、<code>Mouse</code></p><pre><code class="highlight java"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Computer</span> &#123;<span class="keyword">private</span> Mouse mouse; <span class="comment">//鼠标可以和computer分离</span><span class="keyword">private</span> Moniter moniter;<span class="comment">//显示器可以和Computer分离</span><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setMouse</span><span class="params">(Mouse mouse)</span> &#123;<span class="built_in">this</span>.mouse = mouse;&#125;<span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setMoniter</span><span class="params">(Moniter moniter)</span> &#123;<span class="built_in">this</span>.moniter = moniter;&#125;&#125;<span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Moniter</span> &#123;&#125;<span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Mouse</span> &#123;&#125;</code></pre><p>从代码可以看出，他们之间为 <code>聚合关系（Aggregation）</code>，如果不知道什么是聚合关系，本篇后面会介绍。</p><h4 id="1-2-2-使用IDEA查看UML关系图"><a href="#1-2-2-使用IDEA查看UML关系图" class="headerlink" title="1.2.2 使用IDEA查看UML关系图"></a>1.2.2 使用IDEA查看UML关系图</h4><p>同时选中这三个类，鼠标右键选择 Diagrams ， 然后选择 Show Diagram…</p><p><img src="https://raw.githubusercontent.com/GeorgeChan95/blogimg/master/img/2024/11/02/20241102-103131.png" alt="使用IDEA查看UML关系图"></p><p><img src="https://raw.githubusercontent.com/GeorgeChan95/blogimg/master/img/2024/11/02/20241102-103440.png" alt="UML关系图"></p><h4 id="1-2-3-在UML图中添加类或接口"><a href="#1-2-3-在UML图中添加类或接口" class="headerlink" title="1.2.3 在UML图中添加类或接口"></a>1.2.3 在UML图中添加类或接口</h4><p>UML图中鼠标右键 –&gt; <code>Content</code> –&gt; <code>Add Class to Diagram</code> </p><p><img src="https://raw.githubusercontent.com/GeorgeChan95/blogimg/master/img/2024/11/02/20241102-103622.png" alt="在UML图中添加类或接口"></p><p>找到要添加的类，选择它</p><p><img src="https://raw.githubusercontent.com/GeorgeChan95/blogimg/master/img/2024/11/02/20241102-103800.png" alt="添加类到UML图中"></p><p><img src="https://raw.githubusercontent.com/GeorgeChan95/blogimg/master/img/2024/11/02/20241102-103847.png" alt="完成类在UML图中添加"></p><h2 id="2-UML绘制工具：Astah-Professional"><a href="#2-UML绘制工具：Astah-Professional" class="headerlink" title="2. UML绘制工具：Astah Professional"></a>2. UML绘制工具：Astah Professional</h2><p>官网：<a href="http://astah.net/cn/">http://astah.net/cn/</a></p><p>Astah Professional 是一款专业的UML绘图工具，除了绘制UML图以外，还可以绘制ER图、流程图和数据流图等，这里仅介绍它的安装、破解、汉化。</p><blockquote></blockquote><h3 id="2-1-安装-Astah-Pro"><a href="#2-1-安装-Astah-Pro" class="headerlink" title="2.1 安装 Astah Pro"></a>2.1 安装 Astah Pro</h3><p><strong>下载</strong></p><p>百度网盘：<a href="https://pan.baidu.com/s/1Is0BpNy41uI5U9woFIVu_Q?pwd=0000">https://pan.baidu.com/s/1Is0BpNy41uI5U9woFIVu_Q?pwd=0000</a></p><p><strong>解压</strong></p><p><img src="https://raw.githubusercontent.com/GeorgeChan95/blogimg/master/img/2024/11/02/20241102-110113.png" alt="安装包"></p><p>从上往下依次是：破解包、汉化包、安装文件</p><p><strong>开始安装</strong></p><p>首先确保你的电脑上有JDK环境，我的电脑上目前已安装并配置好了JDK8的开发环境</p><pre><code class="highlight shell">C:\Users\kd&gt;java -versionjava version &quot;1.8.0_241&quot;Java(TM) SE Runtime Environment (build 1.8.0_241-b07)Java HotSpot(TM) 64-Bit Server VM (build 25.241-b07, mixed mode)</code></pre><p><img src="https://raw.githubusercontent.com/GeorgeChan95/blogimg/master/img/2024/11/02/20241102-110416.png" alt="选择语言"></p><p><img src="https://raw.githubusercontent.com/GeorgeChan95/blogimg/master/img/2024/11/02/20241102-110443.png" alt="next"></p><p><img src="https://raw.githubusercontent.com/GeorgeChan95/blogimg/master/img/2024/11/02/20241102-110514.png" alt="同意用户协议"></p><p><img src="https://raw.githubusercontent.com/GeorgeChan95/blogimg/master/img/2024/11/02/20241102-110544.png" alt="选择安装位置"></p><p><img src="https://raw.githubusercontent.com/GeorgeChan95/blogimg/master/img/2024/11/02/20241102-110630.png" alt="确保磁盘有足够的空间"></p><p><img src="https://raw.githubusercontent.com/GeorgeChan95/blogimg/master/img/2024/11/02/20241102-110658.png" alt="添加到开始菜单"></p><p><img src="https://raw.githubusercontent.com/GeorgeChan95/blogimg/master/img/2024/11/02/20241102-110742.png" alt="为所有用户安装"></p><p><img src="https://raw.githubusercontent.com/GeorgeChan95/blogimg/master/img/2024/11/02/20241102-110757.png" alt="开始安装"></p><p><img src="https://raw.githubusercontent.com/GeorgeChan95/blogimg/master/img/2024/11/02/20241102-110808.png" alt="软件安装中"></p><p><strong>安装完成，取消勾选 <code>启用应用</code>， 再点击 Finish</strong></p><p>这么做的目的是为了后面对软件做破解。</p><p><img src="https://raw.githubusercontent.com/GeorgeChan95/blogimg/master/img/2024/11/02/20241102-110958.png" alt="安装完成"></p><h3 id="2-2-破解-Astah-Pro"><a href="#2-2-破解-Astah-Pro" class="headerlink" title="2.2 破解 Astah Pro"></a>2.2 破解 Astah Pro</h3><p><strong>复制破解Jar包</strong></p><p>将破解jar包复制到软件的安装目录中， 就是安装Astah时选择的路径，我这里安装到了：E:\software\astah-professional </p><p><img src="https://raw.githubusercontent.com/GeorgeChan95/blogimg/master/img/2024/11/02/20241102-111158.png" alt="复制破解Jar包"></p><p><strong>粘贴破解包</strong></p><p><img src="https://raw.githubusercontent.com/GeorgeChan95/blogimg/master/img/2024/11/02/20241102-111507.png" alt="替换文件"></p><p><strong>新建文件夹“License”</strong></p><p> 在这个目录下新建一个文件夹“License”</p><p><img src="https://raw.githubusercontent.com/GeorgeChan95/blogimg/master/img/2024/11/02/20241102-111725.png" alt="新建文件夹“License”"></p><p><strong>打开CMD</strong></p><p>cd到破解jar所在目录</p><p>执行命令：<code>java -jar dvt-AstahKeyfileMaker.jar</code></p><p><img src="https://raw.githubusercontent.com/GeorgeChan95/blogimg/master/img/2024/11/02/20241102-112057.png" alt="执行Java命令"></p><p>执行完java命令后，自动打开弹窗如下：</p><p><img src="https://raw.githubusercontent.com/GeorgeChan95/blogimg/master/img/2024/11/02/20241102-112129.png" alt="破解jar包弹窗"></p><p><strong>选择 Astah Professional， 点击 Generate</strong></p><p><img src="https://raw.githubusercontent.com/GeorgeChan95/blogimg/master/img/2024/11/02/20241102-112252.png" alt="生成许可文件"></p><p><strong>选择刚才创建的License目录，点击 保存</strong></p><p>会在该目录下自动创建 license.xml 文件，此文件就用于激活 Astah</p><p><img src="https://raw.githubusercontent.com/GeorgeChan95/blogimg/master/img/2024/11/02/20241102-112346.png" alt="生成激活文件"></p><p><img src="https://raw.githubusercontent.com/GeorgeChan95/blogimg/master/img/2024/11/02/20241102-112521.png" alt="文件生成成功"></p><p><strong>激活Astah Pro</strong></p><p>打开Astah， 点击 Help –&gt; License ，设置许可证为刚才生成的 xml 文件</p><p><img src="https://raw.githubusercontent.com/GeorgeChan95/blogimg/master/img/2024/11/02/20241102-112656.png" alt="查看许可证"></p><p><img src="https://raw.githubusercontent.com/GeorgeChan95/blogimg/master/img/2024/11/02/20241102-112734.png" alt="设置许可证"></p><p><img src="https://raw.githubusercontent.com/GeorgeChan95/blogimg/master/img/2024/11/02/20241102-112756.png" alt="选择生成的xml文件"></p><p>再次查看许可信息，发现有效期到 2030年。</p><p><img src="https://raw.githubusercontent.com/GeorgeChan95/blogimg/master/img/2024/11/02/20241102-112936.png" alt="验证许可信息"></p><h3 id="2-3-汉化-Astah-Pro"><a href="#2-3-汉化-Astah-Pro" class="headerlink" title="2.3 汉化 Astah Pro"></a>2.3 汉化 Astah Pro</h3><p>复制汉化文件：<code>astah-gui_zh_cn.properties</code> 到安装根目录即可</p><p><img src="https://raw.githubusercontent.com/GeorgeChan95/blogimg/master/img/2024/11/02/20241102-113141.png" alt="复制汉化文件"></p><p>重新打开 Astah， 发现已汉化成功</p><p><img src="https://raw.githubusercontent.com/GeorgeChan95/blogimg/master/img/2024/11/02/20241102-113308.png" alt="汉化成功"></p><p><strong>参考链接</strong></p><blockquote><p><a href="https://www.cnblogs.com/xsge/p/15871002.html">https://www.cnblogs.com/xsge/p/15871002.html</a></p><p><a href="https://github.com/QingMings/astah-professional-8.1-zh_CN">https://github.com/QingMings/astah-professional-8.1-zh_CN</a></p></blockquote>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;一、UML绘图工具&quot;&gt;&lt;a href=&quot;#一、UML绘图工具&quot; class=&quot;headerlink&quot; title=&quot;一、UML绘图工具&quot;&gt;&lt;/a&gt;一、UML绘图工具&lt;/h1&gt;&lt;p&gt;UML绘制工具有很多，这里仅介绍两种。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;p&gt;IDEA自带</summary>
      
    
    
    
    <category term="UML" scheme="https://georgechan95.github.io/categories/UML/"/>
    
    
    <category term="设计模式" scheme="https://georgechan95.github.io/tags/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"/>
    
    <category term="UML" scheme="https://georgechan95.github.io/tags/UML/"/>
    
  </entry>
  
  <entry>
    <title>Docker环境下RTSP流转RTMP和HLS</title>
    <link href="https://georgechan95.github.io/blog/2e826df1.html"/>
    <id>https://georgechan95.github.io/blog/2e826df1.html</id>
    <published>2024-11-01T07:17:33.000Z</published>
    <updated>2024-11-01T08:12:48.876Z</updated>
    
    <content type="html"><![CDATA[<h1 id="一、RTSP转RTMP"><a href="#一、RTSP转RTMP" class="headerlink" title="一、RTSP转RTMP"></a>一、RTSP转RTMP</h1><h2 id="Nginx-Rtmp环境搭建"><a href="#Nginx-Rtmp环境搭建" class="headerlink" title="Nginx-Rtmp环境搭建"></a>Nginx-Rtmp环境搭建</h2><pre><code class="highlight shell"><span class="meta prompt_"># </span><span class="language-bash">拉取镜像</span>docker pull tiangolo/nginx-rtmp:latest-2024-08-26<span class="meta prompt_"></span><span class="meta prompt_"># </span><span class="language-bash">启动镜像</span>docker run --name nginx-rtmp -itd --restart=always -p 1935:1935 tiangolo/nginx-rtmp</code></pre><h2 id="ffmpeg环境搭建"><a href="#ffmpeg环境搭建" class="headerlink" title="ffmpeg环境搭建"></a>ffmpeg环境搭建</h2><pre><code class="highlight shell"><span class="meta prompt_"># </span><span class="language-bash">拉取镜像</span>docker pull chainguard/ffmpeg:latest<span class="meta prompt_"></span><span class="meta prompt_"># </span><span class="language-bash">启动镜像，并将一个rtsp流转为rtmp流</span>docker run --name ffmpeg29 -itd --restart=always chainguard/ffmpeg -rtsp_transport tcp -i rtsp://admin:CSG300222@10.10.10.29:554/h264/ch1/main/av_stream -f flv -r 25 -s 1920*1080 -an rtmp://192.168.6.209:1935/live/29</code></pre><h2 id="测试"><a href="#测试" class="headerlink" title="测试"></a>测试</h2><p><img src="https://raw.githubusercontent.com/GeorgeChan95/blogimg/master/img/2024/08/30/20240830-154304.png" alt="VLC测试" title="VLC测试"></p><p><img src="https://raw.githubusercontent.com/GeorgeChan95/blogimg/master/img/2024/08/30/20240830-154420.png" alt="VLC播放成功" title="VLC播放成功"></p><h1 id="二、RTSP流转HLS"><a href="#二、RTSP流转HLS" class="headerlink" title="二、RTSP流转HLS"></a>二、RTSP流转HLS</h1><h2 id="创建映射目录"><a href="#创建映射目录" class="headerlink" title="创建映射目录"></a>创建映射目录</h2><pre><code class="highlight shell">mkdir /usr/local/docker/data/nginx/hlschmod 777 /usr/local/docker/data/nginx/hls</code></pre><h2 id="nginx-配置"><a href="#nginx-配置" class="headerlink" title="nginx 配置"></a>nginx 配置</h2><pre><code class="highlight shell">server &#123;  listen       8002;  server_name  server_hls;  location / &#123;    types &#123;       application/vnd.apple.mpegusr m3u8;       video/mp2t ts;    &#125;    root hls;    #8002端口服务的根目录,nginx目录下的hls目录    add_header Cache-Control no-cache;    add_header Access-Control-Allow-Origin *;    add_header Access-Control-Allow-Headers &quot;Origin, X-Requested-With,      Content-Type, Accept&quot;;    add_header Access-Control-Methods &quot;GET, POST, OPTIONS&quot;;  &#125;&#125;</code></pre><h2 id="nginx-映射路径"><a href="#nginx-映射路径" class="headerlink" title="nginx 映射路径"></a>nginx 映射路径</h2><pre><code class="highlight shell">-v /usr/local/docker/data/nginx/hls:/etc/nginx/hls</code></pre><h2 id="nginx-映射端口"><a href="#nginx-映射端口" class="headerlink" title="nginx 映射端口"></a>nginx 映射端口</h2><pre><code>-p 8002:8002</code></pre><h2 id="ffmpeg启动容器"><a href="#ffmpeg启动容器" class="headerlink" title="ffmpeg启动容器"></a>ffmpeg启动容器</h2><pre><code class="highlight shell">docker run --name ffmpeghls --privileged=true -v /usr/local/docker/data/nginx/hls:/hls -itd --restart=always chainguard/ffmpeg -f rtsp -rtsp_transport tcp -i rtsp://admin:CSG300222@10.10.10.29:554/h264/ch1/main/av_stream -codec copy -f hls -hls_list_size 10 -hls_flags 20 -hls_time 15 /hls/test.m3u8</code></pre><h2 id="hls流访问地址"><a href="#hls流访问地址" class="headerlink" title="hls流访问地址"></a>hls流访问地址</h2><pre><code class="highlight shell"><span class="meta prompt_"># </span><span class="language-bash">nginx ip + 映射端口</span>http://192.168.6.209:8002/test.m3u8</code></pre><p><img src="https://raw.githubusercontent.com/GeorgeChan95/blogimg/master/img/2024/08/30/20240830-164326.png" alt="hls流播放效果" title="hls流播放效果"></p>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;一、RTSP转RTMP&quot;&gt;&lt;a href=&quot;#一、RTSP转RTMP&quot; class=&quot;headerlink&quot; title=&quot;一、RTSP转RTMP&quot;&gt;&lt;/a&gt;一、RTSP转RTMP&lt;/h1&gt;&lt;h2 id=&quot;Nginx-Rtmp环境搭建&quot;&gt;&lt;a href=&quot;#Ngi</summary>
      
    
    
    
    <category term="linux" scheme="https://georgechan95.github.io/categories/linux/"/>
    
    
    <category term="linux" scheme="https://georgechan95.github.io/tags/linux/"/>
    
    <category term="ubuntu18" scheme="https://georgechan95.github.io/tags/ubuntu18/"/>
    
  </entry>
  
  <entry>
    <title>01-设计模式六大原则</title>
    <link href="https://georgechan95.github.io/blog/cd625bba.html"/>
    <id>https://georgechan95.github.io/blog/cd625bba.html</id>
    <published>2024-10-31T09:00:00.000Z</published>
    <updated>2024-11-01T08:14:11.787Z</updated>
    
    <content type="html"><![CDATA[<h1 id="一、设计模式的目的"><a href="#一、设计模式的目的" class="headerlink" title="一、设计模式的目的"></a>一、设计模式的目的</h1><p>编写软件过程中，程序员面临着来自<strong>耦合性</strong>，<strong>内聚性</strong>以及<strong>可维护性</strong>，<strong>可扩展性</strong>，重用性，<strong>灵活性</strong> 等多方面的 挑战，设计模式是为了让程序(软件) ，具有更好的</p><ul><li>代码重用性 (即：相同功能的代码，不用多次编写)</li><li>可读性 (即：编程规范性,  便于其他程序员的阅读和理解)</li><li>可扩展性 (即：当需要增加新的功能时，非常的方便，称为可维护)</li><li>可靠性 (即：当我们增加新的功能后，对原来的功能没有影响)</li><li>可靠性 (即：当我们增加新的功能后，对原来的功能没有影响)</li></ul><h1 id="二、单一职责原则（Single-Responsibility-Principle）"><a href="#二、单一职责原则（Single-Responsibility-Principle）" class="headerlink" title="二、单一职责原则（Single Responsibility Principle）"></a>二、单一职责原则（Single Responsibility Principle）</h1><h2 id="1-基本介绍"><a href="#1-基本介绍" class="headerlink" title="1. 基本介绍"></a>1. 基本介绍</h2><p>就一个类而言，应该仅有一个引起它变化的原因。应该只有一个职责。如果一个类有一个以上的职责，这些职责就耦合在了一起。一个职责的变化可能会削弱或者抑制这个类完成其他职责的能力。这会导致脆弱的设计。当一个职责发生变化时，可能会影响其它的职责。另外，多个职责耦合在一起，会影响复用性。想要避免这种现象的发生，就要尽可能的遵守单一职责原则。</p><p>单一职责原则的核心就是<strong>解耦和增强内聚性</strong>。</p><h2 id="2-为什么要遵守单一职责原则？"><a href="#2-为什么要遵守单一职责原则？" class="headerlink" title="2. 为什么要遵守单一职责原则？"></a>2. 为什么要遵守单一职责原则？</h2><ul><li><p>提高类的可维护性和可读写性</p><p>一个类的职责少了，复杂度降低了，代码就少了，可读性也就好了，可维护性自然就高了。</p></li><li><p>提高系统的可维护性</p><p>系统是由类组成的，每个类的可维护性高，相对来讲整个系统的可维护性就高。当然，前提是系统的架构没有问题。</p></li><li><p>降低变更的风险</p><p>一个类的职责越多，变更的可能性就越大，变更带来的风险也就越大</p></li></ul><p>如果在一个类中可能会有多个发生变化的东西，这样的设计会带来风险, 我们尽量保证只有一个可以变化，其他变化的就放在其他类中，这样的好处就是 <strong>提高内聚，降低耦合</strong>。</p><h2 id="3-单一职责原则应用的范围"><a href="#3-单一职责原则应用的范围" class="headerlink" title="3. 单一职责原则应用的范围"></a>3. 单一职责原则应用的范围</h2><p>单一职责原则适用的范围有接口、方法类。按大家的说法，<strong>接口和方法必须保证单一职责</strong>，类就不必保证，只要符合业务就行。</p><h3 id="3-1-【方法层面】单一职责原则的应用"><a href="#3-1-【方法层面】单一职责原则的应用" class="headerlink" title="3.1  【方法层面】单一职责原则的应用"></a>3.1  【方法层面】单一职责原则的应用</h3><p>现在有一个场景, 需要修改用户的用户名和密码. 就针对这个功能我们可以有多种实现.</p><p><strong>第一种:</strong></p><pre><code class="highlight java"><span class="comment">/**</span><span class="comment"> * 操作的类型</span><span class="comment"> */</span><span class="keyword">public</span> <span class="keyword">enum</span> <span class="title class_">OperateEnum</span> &#123;    UPDATE_USERNAME,    UPDATE_PASSWORD;&#125;<span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">UserOperate</span> &#123;    <span class="keyword">void</span> <span class="title function_">updateUserInfo</span><span class="params">(OperateEnum type, UserInfo userInfo)</span>;&#125;<span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">UserOperateImpl</span> <span class="keyword">implements</span> <span class="title class_">UserOperate</span>&#123;    <span class="meta">@Override</span>    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">updateUserInfo</span><span class="params">(OperateEnum type, UserInfo userInfo)</span> &#123;        <span class="keyword">if</span> (type == OperateEnum.UPDATE_PASSWORD) &#123;            <span class="comment">// 修改密码</span>        &#125; <span class="keyword">else</span> <span class="keyword">if</span>(type == OperateEnum.UPDATE_USERNAME) &#123;            <span class="comment">// 修改用户名</span>        &#125;    &#125;&#125;</code></pre><p><strong>第二种方法:</strong></p><pre><code class="highlight java"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">UserOperate</span> &#123;    <span class="keyword">void</span> <span class="title function_">updateUserName</span><span class="params">(UserInfo userInfo)</span>;    <span class="keyword">void</span> <span class="title function_">updateUserPassword</span><span class="params">(UserInfo userInfo)</span>;&#125;<span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">UserOperateImpl</span> <span class="keyword">implements</span> <span class="title class_">UserOperate</span> &#123;    <span class="meta">@Override</span>    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">updateUserName</span><span class="params">(UserInfo userInfo)</span> &#123;        <span class="comment">// 修改用户名逻辑</span>    &#125;    <span class="meta">@Override</span>    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">updateUserPassword</span><span class="params">(UserInfo userInfo)</span> &#123;        <span class="comment">// 修改密码逻辑</span>    &#125;&#125;</code></pre><p>来看看这两种实现的区别: </p><ul><li>第一种实现是根据操作类型进行区分, 不同类型执行不同的逻辑. 把修改用户名和修改密码这两件事耦合在一起了. 如果客户端在操作的时候传错了类型, 那么就会发生错误. </li><li>第二种实现是我们推荐的实现方式. 修改用户名和修改密码逻辑分开. 各自执行各自的职责, 互不干扰. 功能清晰明了.</li></ul><p>由此可见, 第二种设计是符合单一职责原则的. 这是在方法层面实现单一职责原则.</p><h3 id="3-2-【接口层面】单一职责原则的应用"><a href="#3-2-【接口层面】单一职责原则的应用" class="headerlink" title="3.2 【接口层面】单一职责原则的应用"></a>3.2 【接口层面】单一职责原则的应用</h3><p>我们假设一个场景, 大家一起做家务, 张三扫地, 李四买菜. 李四买完菜回来还得做饭. 这个逻辑怎么实现呢?</p><p><strong>方式一</strong></p><pre><code class="highlight java"><span class="comment">/**</span><span class="comment"> * 做家务</span><span class="comment"> */</span><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">HouseWork</span> &#123;    <span class="comment">// 扫地</span>    <span class="keyword">void</span> <span class="title function_">sweepFloor</span><span class="params">()</span>;    <span class="comment">// 购物</span>    <span class="keyword">void</span> <span class="title function_">shopping</span><span class="params">()</span>;&#125;<span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Zhangsan</span> <span class="keyword">implements</span> <span class="title class_">HouseWork</span>&#123;    <span class="meta">@Override</span>    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">sweepFloor</span><span class="params">()</span> &#123;        <span class="comment">// 扫地</span>    &#125;    <span class="meta">@Override</span>    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">shopping</span><span class="params">()</span> &#123;    &#125;&#125;<span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Lisi</span> <span class="keyword">implements</span> <span class="title class_">HouseWork</span>&#123;    <span class="meta">@Override</span>    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">sweepFloor</span><span class="params">()</span> &#123;    &#125;    <span class="meta">@Override</span>    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">shopping</span><span class="params">()</span> &#123;        <span class="comment">// 购物</span>    &#125;&#125;</code></pre><p>首先定义了一个做家务的接口, 定义两个方法扫地和买菜. 张三扫地, 就实现扫地接口. 李四买菜, 就实现买菜接口. 然后李四买完菜回来还要做饭, 于是就要在接口类中增加一个方法cooking. 张三和李四都重写这个方法, 但只有李四有具体实现.</p><p>这样设计本身就是不合理的. 首先: 张三只扫地, 但是他需要重写买菜方法, 李四不需要扫地, 但是李四也要重写扫地方法. 第二: 这也不符合开闭原则. 增加一种类型做饭, 要修改3个类. 这样当逻辑很复杂的时候, 很容易引起意外错误.</p><p>上面这种设计不符合单一职责原则, 修改一个地方, 影响了其他不需要修改的地方.</p><p><strong>方法二</strong></p><pre><code class="highlight java"><span class="comment">/**</span><span class="comment"> * 做家务</span><span class="comment"> */</span><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">Hoursework</span> &#123;&#125;<span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">Shopping</span> <span class="keyword">extends</span> <span class="title class_">Hoursework</span>&#123;    <span class="comment">// 购物</span>    <span class="keyword">void</span> <span class="title function_">shopping</span><span class="params">()</span>;&#125;<span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">SweepFloor</span> <span class="keyword">extends</span> <span class="title class_">Hoursework</span>&#123;    <span class="comment">// 扫地</span>    <span class="keyword">void</span> <span class="title function_">sweepFlooring</span><span class="params">()</span>;&#125;<span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Zhangsan</span> <span class="keyword">implements</span> <span class="title class_">SweepFloor</span>&#123;    <span class="meta">@Override</span>    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">sweepFlooring</span><span class="params">()</span> &#123;        <span class="comment">// 张三扫地</span>    &#125;&#125;<span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Lisi</span> <span class="keyword">implements</span> <span class="title class_">Shopping</span>&#123;    <span class="meta">@Override</span>    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">shopping</span><span class="params">()</span> &#123;        <span class="comment">// 李四购物</span>    &#125;&#125;</code></pre><p>上面做家务不是定义成一个接口, 而是将扫地和做家务分开了. 张三扫地, 那么张三就实现扫地的接口. 李四购物, 李四就实现购物的接口. 后面李四要增加一个功能做饭. 那么就新增一个做饭接口, 这次只需要李四实现做饭接口就可以了.</p><pre><code class="highlight java"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">Cooking</span> <span class="keyword">extends</span> <span class="title class_">Hoursework</span>&#123;     <span class="keyword">void</span> <span class="title function_">cooking</span><span class="params">()</span>;&#125;<span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Lisi</span> <span class="keyword">implements</span> <span class="title class_">Shopping</span>, Cooking&#123;    <span class="meta">@Override</span>    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">shopping</span><span class="params">()</span> &#123;        <span class="comment">// 李四购物</span>    &#125;    <span class="meta">@Override</span>    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">cooking</span><span class="params">()</span> &#123;        <span class="comment">// 李四做饭</span>    &#125;&#125;</code></pre><p>如上, 我们看到张三没有实现多余的接口, 李四也没有. 而且当新增功能的时候, 只影响了李四, 并没有影响张三. 这就是符合单一职责原则. 一个类只做一件事. 并且他的修改不会带来其他的变化.</p><h2 id="4-如何遵守单一职责原则"><a href="#4-如何遵守单一职责原则" class="headerlink" title="4. 如何遵守单一职责原则"></a>4. 如何遵守单一职责原则</h2><h3 id="4-1-合理的职责分解"><a href="#4-1-合理的职责分解" class="headerlink" title="4.1 合理的职责分解"></a>4.1 合理的职责分解</h3><p>相同的职责放到一起，不同的职责分解到不同的接口和实现中去，这个是最容易也是最难运用的原则，关键还是要从业务出发，从需求出发，识别出同一种类型的职责。</p><p>例子：人的行为分析，包括了生活和工作等行为的分析，生活行为包括吃、跑、睡等行为，工作行为包括上下班，开会等行为，如下图所示：</p><p><img src="https://raw.githubusercontent.com/GeorgeChan95/blogimg/master/img/2024/10/31/20241031-161624.png" alt="单一职责原则"></p><p>人类的行为分成了两个接口：生活行为接口、工作行为接口，以及两个实现类。如果都用一个实现类来承担这两个接口的职责，就会导致代码臃肿，不易维护，如果以后再加上其他行为，例如学习行为接口，将会产生变更风险（这里还用到了组合模式）。</p><h3 id="4-2-代码实现"><a href="#4-2-代码实现" class="headerlink" title="4.2 代码实现"></a>4.2 代码实现</h3><p><strong>第一步: 定义一个行为接口</strong></p><pre><code class="highlight java"><span class="comment">/**</span><span class="comment"> * 人的行为</span><span class="comment"> * 人的行为包括两种: 生活行为, 工作行为</span><span class="comment"> */</span><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">IBehavior</span> &#123;    &#125;</code></pre><p>这里面定义了一个空的接口, 行为接口. 具体这个行为接口下面有哪些接口呢?有生活和工作两方面的行为.</p><p><strong>第二步: 定义生活和工作接口, 并且他们都是行为接口的子类</strong></p><p>生活行为接口:</p><pre><code class="highlight java"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">LivingBehavior</span> <span class="keyword">extends</span> <span class="title class_">IBehavior</span>&#123;    <span class="comment">/** 吃饭 */</span>    <span class="keyword">void</span> <span class="title function_">eat</span><span class="params">()</span>;    <span class="comment">/** 跑步 */</span>    <span class="keyword">void</span> <span class="title function_">running</span><span class="params">()</span>;    <span class="comment">/** 睡觉 */</span>    <span class="keyword">void</span> <span class="title function_">sleeping</span><span class="params">()</span>;&#125;</code></pre><p>工作行为接口:</p><pre><code class="highlight java"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">WorkingBehavior</span> <span class="keyword">extends</span> <span class="title class_">IBehavior</span>&#123;    <span class="comment">/** 上班 */</span>    <span class="keyword">void</span> <span class="title function_">goToWork</span><span class="params">()</span>;    <span class="comment">/** 下班 */</span>    <span class="keyword">void</span> <span class="title function_">goOffWork</span><span class="params">()</span>;    <span class="comment">/** 开会 */</span>    <span class="keyword">void</span> <span class="title function_">meeting</span><span class="params">()</span>;&#125;</code></pre><p><strong>第三步: 定义工作行为接口和生活行为接口的实现类</strong></p><p>生活行为接口实现类:</p><pre><code class="highlight java"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">LivingBehaviorImpl</span> <span class="keyword">implements</span> <span class="title class_">LivingBehavior</span>&#123;    <span class="meta">@Override</span>    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">eat</span><span class="params">()</span> &#123;        System.out.println(<span class="string">&quot;吃饭&quot;</span>);    &#125;    <span class="meta">@Override</span>    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">running</span><span class="params">()</span> &#123;        System.out.println(<span class="string">&quot;跑步&quot;</span>);    &#125;    <span class="meta">@Override</span>    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">sleeping</span><span class="params">()</span> &#123;        System.out.println(<span class="string">&quot;睡觉&quot;</span>);    &#125;&#125;</code></pre><p>工作行为接口实现类:</p><pre><code class="highlight java"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">WorkingBehaviorImpl</span> <span class="keyword">implements</span> <span class="title class_">WorkingBehavior</span>&#123;    <span class="meta">@Override</span>    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">goToWork</span><span class="params">()</span> &#123;        System.out.println(<span class="string">&quot;上班&quot;</span>);    &#125;    <span class="meta">@Override</span>    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">goOffWork</span><span class="params">()</span> &#123;        System.out.println(<span class="string">&quot;下班&quot;</span>);    &#125;    <span class="meta">@Override</span>    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">meeting</span><span class="params">()</span> &#123;        System.out.println(<span class="string">&quot;开会&quot;</span>);    &#125;&#125;</code></pre><p><strong>第四步: 行为组合调用</strong></p><p>行为接口定义好了. 接下来会定义一个行为集合. 不同的用户拥有的行为是不一样 , 有的用户只用生活行为, 有的用户既有生活行为又有工作行为. 我们并不知道具体用户到底会有哪些行为, 所以,通常使用一个集合来接收用户的行为. 用户有哪些行为, 就往里面添加哪些行为.</p><ul><li><p>行为组合接口BehaviorComposer</p><pre><code class="highlight java"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">BehaviorComposer</span> &#123;    <span class="keyword">void</span> <span class="title function_">add</span><span class="params">(IBehavior behavior)</span>;&#125;</code></pre></li><li><p>行为组合接口实现类IBehaviorComposerImpl</p><pre><code class="highlight java"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">IBehaviorComposerImpl</span> <span class="keyword">implements</span> <span class="title class_">BehaviorComposer</span> &#123;    <span class="keyword">private</span> List&lt;IBehavior&gt; behaviors = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();    <span class="meta">@Override</span>    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">add</span><span class="params">(IBehavior behavior)</span> &#123;        System.out.println(<span class="string">&quot;添加行为&quot;</span>);        behaviors.add(behavior);    &#125;    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">doSomeThing</span><span class="params">()</span> &#123;        behaviors.forEach(b-&gt;&#123;            <span class="keyword">if</span>(b <span class="keyword">instanceof</span> LivingBehavior) &#123;                <span class="type">LivingBehavior</span> <span class="variable">li</span> <span class="operator">=</span> (LivingBehavior)b;                <span class="comment">// 处理生活行为</span>            &#125; <span class="keyword">else</span> <span class="keyword">if</span>(b <span class="keyword">instanceof</span> WorkingBehavior) &#123;                <span class="type">WorkingBehavior</span> <span class="variable">wb</span> <span class="operator">=</span> (WorkingBehavior) b;                <span class="comment">// 处理工作行为</span>            &#125;        &#125;);    &#125;&#125;</code></pre></li></ul><p><strong>第五步: 客户端调用</strong></p><p>用户在调用的时候, 根据实际情况调用就可以了, 比如下面的代码: 张三是全职妈妈, 只有生活行为, 李四是职场妈妈, 既有生活行为又有工作行为.</p><pre><code class="highlight java"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;    <span class="comment">//  张三--全职妈妈</span>    <span class="type">LivingBehavior</span> <span class="variable">zslivingBehavior</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">LivingBehaviorImpl</span>();    <span class="type">BehaviorComposer</span> <span class="variable">zsBehaviorComposer</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">IBehaviorComposerImpl</span>();    zsBehaviorComposer.add(zslivingBehavior);    <span class="comment">// 李四--职场妈妈</span>    <span class="type">LivingBehavior</span> <span class="variable">lsLivingBehavior</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">LivingBehaviorImpl</span>();    <span class="type">WorkingBehavior</span> <span class="variable">lsWorkingBehavior</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">WorkingBehaviorImpl</span>();    <span class="type">BehaviorComposer</span> <span class="variable">lsBehaviorComposer</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">IBehaviorComposerImpl</span>();    lsBehaviorComposer.add(lsLivingBehavior);    lsBehaviorComposer.add(lsWorkingBehavior);&#125;</code></pre><h2 id="5-单一职责原则的优缺点"><a href="#5-单一职责原则的优缺点" class="headerlink" title="5. 单一职责原则的优缺点"></a>5. 单一职责原则的优缺点</h2><ul><li>类的复杂性降低: 一个类实现什么职责都有清晰明确的定义了, 复杂性自然就降低了 </li><li>可读性提高: 复杂性降低了，可读性自然就提高了 </li><li>可维护性提高: 可读性提高了，代码就更容易维护了 </li><li>变更引起的风险降低: 变更是必不可少的，如果接口的单一职责做得好，一个接口修改只对相应的实现类有影响，对其他的接口和类无影响，这对系统的扩展性、维护性都有非常大的帮助</li></ul><h1 id="三、接口隔离原则-Interface-Segregation-Principle"><a href="#三、接口隔离原则-Interface-Segregation-Principle" class="headerlink" title="三、接口隔离原则(Interface Segregation Principle)"></a>三、接口隔离原则(Interface Segregation Principle)</h1><h2 id="1-接口隔离原则的定义"><a href="#1-接口隔离原则的定义" class="headerlink" title="1. 接口隔离原则的定义"></a>1. 接口隔离原则的定义</h2><p>客户端只依赖于它所需要的接口；它需要什么接口就提供什么接口，把不需要的接口剔除掉。</p><p>类间的依赖关系应建立在最小的接口上。</p><p>也就是说: 接口尽量细化，接口中的方法尽量少</p><h2 id="2-接口隔离原则和单一职责原则"><a href="#2-接口隔离原则和单一职责原则" class="headerlink" title="2. 接口隔离原则和单一职责原则"></a>2. 接口隔离原则和单一职责原则</h2><p>功能上来看，接口隔离原则和单一职责原则都是为了提高类的内聚, 降低类之间的耦合, 体现了封装的思想。但二者还是有区别的。</p><ul><li>从原则约束来看: 接口隔离原则更关注的是接口依赖程度的隔离；而单一职责原则更加注重的是接口职责的划分。</li><li>从接口的细化程度来看: 单一职责原则对接口的划分更加精细，而接口隔离原则注重的是相同功能的接口的隔离。接口隔离里面的最小接口有时可以是多个单一职责的公共接口。</li><li>单一职责原则更加偏向对业务的约束: 接口隔离原则更加偏向设计架构的约束。这个应该好理解，职责是根据业务功能来划分的，所以单一原则更加偏向业务；而接口隔离更多是为了“高内聚”，偏向架构的设计。</li></ul><h2 id="3-接口隔离原则的优点"><a href="#3-接口隔离原则的优点" class="headerlink" title="3. 接口隔离原则的优点"></a>3. 接口隔离原则的优点</h2><p>接口隔离原则是为了约束接口、降低类对接口的依赖性，遵循接口隔离原则有以下 5 个优点。</p><ul><li>将臃肿庞大的接口分解为多个粒度小的接口，可以预防外来变更的扩散，提高系统的灵活性和可维护性。</li><li>接口隔离提高了系统的内聚性，减少了对外交互，降低了系统的耦合性。</li><li>如果接口的粒度大小定义合理，能够保证系统的稳定性；然而，如果定义过小，则会造成接口数量过多，使设计复杂化；如果定义太大，灵活性降低，无法提供定制服务，给整体项目带来无法预料的风险。</li><li>使用多个专门的接口能够体现对象的层次，因为可以通过接口的继承，实现对总接口的定义。</li><li>能减少项目工程中的代码冗余。过大的大接口里面通常放置许多不用的方法，当实现这个接口的时候，被迫设计冗余的代码。</li></ul><h2 id="4-接口隔离原则的实现方法"><a href="#4-接口隔离原则的实现方法" class="headerlink" title="4. 接口隔离原则的实现方法"></a>4. 接口隔离原则的实现方法</h2><p>在具体应用接口隔离原则时，应该根据以下几个规则来衡量。</p><ul><li><p>接口要尽量小</p><p>不能出现Fat Interface；但是要有限度，首先不能违反单一职责原则（不能一个接口对应半个职责）。</p></li><li><p>接口要高内聚</p><p> 在接口中尽量少公布public方法。 接口是对外的承诺，承诺越少对系统的开发越有利。</p></li><li><p>定制服务</p><p>只提供访问者需要的方法。例如，为管理员提供IComplexSearcher接口，为公网提供ISimpleSearcher接口。</p></li><li><p>接口的设计是有限度的</p><p>了解环境，拒绝盲从。每个项目或产品都有选定的环境因素，环境不同，接口拆分的标准就不同, 需要深入了解业务逻辑。</p></li></ul><h2 id="5-接口隔离原则的建议"><a href="#5-接口隔离原则的建议" class="headerlink" title="5. 接口隔离原则的建议"></a>5. 接口隔离原则的建议</h2><ul><li>一个接口只服务于一个子模块或业务逻辑；</li><li>通过业务逻辑压缩接口中的public方法；</li><li>已被污染了的接口，尽量去修改；若变更的风险较大，则采用适配器模式转化处理；</li><li>拒绝盲从</li></ul><h2 id="6-案例分析"><a href="#6-案例分析" class="headerlink" title="6. 案例分析"></a>6. 案例分析</h2><p>下面以学生成绩管理为例来说明接口隔离原则:</p><p>分析：学生成绩管理程序一般包含查询成绩、新增成绩、删除成绩、修改成绩、计算总分、计算平均分、打印成绩信息等功能，通常我们会怎么做呢？</p><h3 id="6-1-最初的设计"><a href="#6-1-最初的设计" class="headerlink" title="6.1 最初的设计"></a>6.1 最初的设计</h3><p>通常我们设计接口的方式如下:</p><pre><code class="highlight java"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">IStudentScore</span> &#123;    <span class="comment">// 查询成绩</span>    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">queryScore</span><span class="params">()</span>;    <span class="comment">// 修改成绩</span>    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">updateScore</span><span class="params">()</span>;    <span class="comment">// 添加成绩</span>    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">saveScore</span><span class="params">()</span>;    <span class="comment">// 删除成绩</span>    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">delete</span><span class="params">()</span>;    <span class="comment">// 计算总分</span>    <span class="keyword">public</span> <span class="type">double</span> <span class="title function_">sum</span><span class="params">()</span>;    <span class="comment">// 计算平均分</span>    <span class="keyword">public</span> <span class="type">double</span> <span class="title function_">avg</span><span class="params">()</span>;    <span class="comment">// 打印成绩单</span>    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">printScore</span><span class="params">()</span>;&#125;</code></pre><p>我们会吧所有的功能都放在一个接口里面. 这会产生什么样的问题呢?</p><p>首先, 接口的方法很多, 不利于扩展. 比如: 学生只有查看成绩,打印成绩单的权限, 没有增删改的权限; 老师拥有所有的权限.</p><p><strong>查询成绩单:</strong></p><pre><code class="highlight java"><span class="keyword">package</span> com.lxl.www.designPatterns.sixPrinciple.interfaceSegregationPrinciple.score;<span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">QueryScore</span> <span class="keyword">implements</span> <span class="title class_">IStudentScore</span>&#123;    <span class="meta">@Override</span>    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">queryScore</span><span class="params">()</span> &#123;        <span class="comment">// 查询成绩</span>    &#125;    <span class="meta">@Override</span>    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">updateScore</span><span class="params">()</span> &#123;         <span class="comment">// 没有权限</span>    &#125;    <span class="meta">@Override</span>    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">saveScore</span><span class="params">()</span> &#123;        <span class="comment">// 没有权限</span>    &#125;    <span class="meta">@Override</span>    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">delete</span><span class="params">()</span> &#123;        <span class="comment">// 没有权限</span>    &#125;    <span class="meta">@Override</span>    <span class="keyword">public</span> <span class="type">double</span> <span class="title function_">sum</span><span class="params">()</span> &#123;        <span class="comment">// 没有权限</span>        <span class="keyword">return</span> <span class="number">0</span>;    &#125;    <span class="meta">@Override</span>    <span class="keyword">public</span> <span class="type">double</span> <span class="title function_">avg</span><span class="params">()</span> &#123;        <span class="comment">// 没有权限</span>        <span class="keyword">return</span> <span class="number">0</span>;    &#125;    <span class="meta">@Override</span>    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">printScore</span><span class="params">()</span> &#123;        <span class="comment">//打印成绩单</span>    &#125;&#125;</code></pre><p><strong>操作成绩单</strong></p><pre><code class="highlight java"><span class="keyword">package</span> com.lxl.www.designPatterns.sixPrinciple.interfaceSegregationPrinciple.score;<span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Operate</span> <span class="keyword">implements</span> <span class="title class_">IStudentScore</span>&#123;    <span class="meta">@Override</span>    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">queryScore</span><span class="params">()</span> &#123;            &#125;    <span class="meta">@Override</span>    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">updateScore</span><span class="params">()</span> &#123;    &#125;    <span class="meta">@Override</span>    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">saveScore</span><span class="params">()</span> &#123;    &#125;    <span class="meta">@Override</span>    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">delete</span><span class="params">()</span> &#123;    &#125;    <span class="meta">@Override</span>    <span class="keyword">public</span> <span class="type">double</span> <span class="title function_">sum</span><span class="params">()</span> &#123;        <span class="keyword">return</span> <span class="number">0</span>;    &#125;    <span class="meta">@Override</span>    <span class="keyword">public</span> <span class="type">double</span> <span class="title function_">avg</span><span class="params">()</span> &#123;        <span class="keyword">return</span> <span class="number">0</span>;    &#125;    <span class="meta">@Override</span>    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">printScore</span><span class="params">()</span> &#123;    &#125;&#125;</code></pre><p>可以看出问题. 查询成绩单, 我们只会用到两个方法, 可是因为实现了接口, 不得不重写所有的方法.</p><p> 如果这时候增加需求–发送给家长, 只有老师才有这个权限, 学生没有这个权限. 可是, 在接口中增加一个抽象方法以后, 所有的实现类都要重写这个方法. 这就违背了开闭原则.</p><h3 id="6-2-使用接口隔离原则的设计"><a href="#6-2-使用接口隔离原则的设计" class="headerlink" title="6.2 使用接口隔离原则的设计"></a>6.2 使用接口隔离原则的设计</h3><p>采用接口隔离原则设计的接口, 代码如下:</p><pre><code class="highlight java"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">IQueryScore</span> &#123;    <span class="comment">// 查询成绩</span>    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">queryScore</span><span class="params">()</span>;    <span class="comment">// 打印成绩单</span>    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">printScore</span><span class="params">()</span>;&#125;<span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">IOperateScore</span> &#123;    <span class="comment">// 修改成绩</span>    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">updateScore</span><span class="params">()</span>;    <span class="comment">// 添加成绩</span>    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">saveScore</span><span class="params">()</span>;    <span class="comment">// 删除成绩</span>    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">delete</span><span class="params">()</span>;    <span class="comment">// 计算总分</span>    <span class="keyword">public</span> <span class="type">double</span> <span class="title function_">sum</span><span class="params">()</span>;    <span class="comment">// 计算平均分</span>    <span class="keyword">public</span> <span class="type">double</span> <span class="title function_">avg</span><span class="params">()</span>;&#125;<span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">StudentOperate</span> <span class="keyword">implements</span> <span class="title class_">IQueryScore</span>&#123;    <span class="meta">@Override</span>    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">queryScore</span><span class="params">()</span> &#123;        <span class="comment">// 查询成绩</span>    &#125;    <span class="meta">@Override</span>    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">printScore</span><span class="params">()</span> &#123;        <span class="comment">//打印成绩单</span>    &#125;&#125;<span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">TeacherOperate</span> <span class="keyword">implements</span> <span class="title class_">IQueryScore</span>, IOperateScore&#123;    <span class="meta">@Override</span>    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">queryScore</span><span class="params">()</span> &#123;    &#125;    <span class="meta">@Override</span>    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">updateScore</span><span class="params">()</span> &#123;    &#125;    <span class="meta">@Override</span>    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">saveScore</span><span class="params">()</span> &#123;    &#125;    <span class="meta">@Override</span>    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">delete</span><span class="params">()</span> &#123;    &#125;    <span class="meta">@Override</span>    <span class="keyword">public</span> <span class="type">double</span> <span class="title function_">sum</span><span class="params">()</span> &#123;        <span class="keyword">return</span> <span class="number">0</span>;    &#125;    <span class="meta">@Override</span>    <span class="keyword">public</span> <span class="type">double</span> <span class="title function_">avg</span><span class="params">()</span> &#123;        <span class="keyword">return</span> <span class="number">0</span>;    &#125;    <span class="meta">@Override</span>    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">printScore</span><span class="params">()</span> &#123;    &#125;&#125;</code></pre><p>我们将原来的一个接口进行了接口拆分. 分为查询接口和操作接口. 这样学生端就不需要重写和他不相关的接口了.</p><p>如果将这些功能全部放到一个接口中显然不太合理，正确的做法是将它们分别放在输入模块、统计模块和打印模块等 3 个模块中。</p><h1 id="四、依赖倒转原则（Dependence-Inversion-Principle）"><a href="#四、依赖倒转原则（Dependence-Inversion-Principle）" class="headerlink" title="四、依赖倒转原则（Dependence Inversion Principle）"></a>四、依赖倒转原则（Dependence Inversion Principle）</h1><h2 id="1-概念"><a href="#1-概念" class="headerlink" title="1. 概念"></a>1. 概念</h2><p>依赖倒置原则(Dependence Inversion Principle, DIP), 其含义:</p><ul><li>高层模块不应该依赖低层模块，两者都应该依赖其抽象</li><li>抽象不应该依赖细节, 细节应该依赖于抽象</li><li>要针对接口编程，不要针对实现编程</li></ul><h2 id="2-什么是依赖？"><a href="#2-什么是依赖？" class="headerlink" title="2. 什么是依赖？"></a>2. 什么是依赖？</h2><p>这里的依赖关系我们理解为UML关系中的依赖。简单的说就是A use B，那么A对B产生了依赖。具体请看下面的例子。</p><p><img src="https://raw.githubusercontent.com/GeorgeChan95/blogimg/master/img/2024/10/31/20241031-190021.png" alt="依赖"></p><p>从上图中我们可以发现, 类A中的<code>方法a()</code>里面用到了类B, 其实这就是依赖关系, A依赖了B. 需要注意的是: 并不是说A中声明了B就叫依赖, 如果引用了但是没有真实调用方法, 那么叫做零耦合关系. 如下图:</p><p><img src="https://raw.githubusercontent.com/GeorgeChan95/blogimg/master/img/2024/10/31/20241031-190058.png" alt="零耦合"></p><h2 id="3-依赖的关系种类"><a href="#3-依赖的关系种类" class="headerlink" title="3. 依赖的关系种类"></a>3. 依赖的关系种类</h2><p>1、零耦合关系：如果两个类之间没有耦合关系，称之为零耦合</p><p><img src="https://raw.githubusercontent.com/GeorgeChan95/blogimg/master/img/2024/10/31/20241031-190458.png" alt="零耦合关系"></p><p>2、直接耦合关系: 具体耦合发生在两个具体类（可实例化的）之间，经由一个类对另一个类的直接引用造成。</p><p><img src="https://raw.githubusercontent.com/GeorgeChan95/blogimg/master/img/2024/10/31/20241031-190516.png" alt="直接耦合关系"></p><p>3、抽象耦合关系: 抽象耦合关系发生在一个具体类和一个抽象类（或者java接口）之间，使两个必须发生关系的类之间存在最大的灵活性。</p><p><img src="https://raw.githubusercontent.com/GeorgeChan95/blogimg/master/img/2024/10/31/20241031-190525.png" alt="抽象耦合关系"></p><p>依赖倒转原则就是要针对接口编程，不要针对实现编程。这就是说，应当使用接口或者抽象类进行<strong>变量的类型声明</strong>，<strong>参数的类型声明</strong>，<strong>方法的返回类型说明</strong>，<strong>以及数据类型的转换</strong>等。</p><h2 id="4-依赖倒置的案例"><a href="#4-依赖倒置的案例" class="headerlink" title="4. 依赖倒置的案例"></a>4. 依赖倒置的案例</h2><h3 id="4-1-初步设计方案"><a href="#4-1-初步设计方案" class="headerlink" title="4.1 初步设计方案"></a>4.1 初步设计方案</h3><pre><code class="highlight java"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Benz</span> &#123;    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span> &#123;        System.out.println(<span class="string">&quot;奔驰跑起来了!&quot;</span>);    &#125;&#125;<span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Driver</span> &#123;    <span class="keyword">private</span> String name;    <span class="keyword">public</span> <span class="title function_">Driver</span><span class="params">(String name)</span> &#123;        <span class="built_in">this</span>.name = name;    &#125;    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">driver</span><span class="params">(Benz benz)</span> &#123;        benz.run();    &#125;&#125;<span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">CarTest</span> &#123;    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;        <span class="type">Benz</span> <span class="variable">benz</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Benz</span>();        <span class="type">Driver</span> <span class="variable">driver</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Driver</span>(<span class="string">&quot;张三&quot;</span>);        driver.driver(benz);    &#125;&#125;</code></pre><p>有一个驾驶员张三可以驾驶奔驰汽车, 于是最开始我们思考, 会有一个驾驶员类, 有一个奔驰汽车类. 随着业务的发展, 我们发现, 驾驶员张三还可以驾驶宝马.</p><p>于是,我们定义一个BM类,</p><pre><code class="highlight java"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">BM</span> &#123;    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span> &#123;        System.out.println(<span class="string">&quot;宝马跑起来了!&quot;</span>);    &#125;&#125;</code></pre><p>这时, 张三如果想要开宝马, 就要将宝马注册在他名下.</p><pre><code class="highlight java"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Driver</span> &#123;    <span class="keyword">private</span> String name;    <span class="keyword">public</span> <span class="title function_">Driver</span><span class="params">(String name)</span> &#123;        <span class="built_in">this</span>.name = name;    &#125;    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">driver</span><span class="params">(Benz benz)</span> &#123;        benz.run();    &#125;    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">driver</span><span class="params">(BM bm)</span> &#123;        bm.run();    &#125;&#125;<span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">CarTest</span> &#123;    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;        <span class="type">Benz</span> <span class="variable">benz</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Benz</span>();        <span class="type">BM</span> <span class="variable">bm</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">BM</span>();        <span class="type">Driver</span> <span class="variable">driver</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Driver</span>(<span class="string">&quot;张三&quot;</span>);        driver.driver(benz);        driver.driver(bm);    &#125;&#125;</code></pre><p>似乎这样就可以了, 但是这样有什么问题呢?</p><ul><li>如果张三有一天要开大众, 还要增加一个大众车类, 同时还得挂载司机名下.</li><li>不是所有的人都要开奔驰, 开宝马. 开大众.</li></ul><p>这就是面向实现编程的问题, 接下来我们就要考虑面向接口编程.</p><h3 id="4-2-改进后的方案"><a href="#4-2-改进后的方案" class="headerlink" title="4.2 改进后的方案"></a>4.2 改进后的方案</h3><pre><code class="highlight java"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">ICar</span> &#123;    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span>;&#125;<span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Benz</span> <span class="keyword">implements</span> <span class="title class_">ICar</span>&#123;    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span> &#123;        System.out.println(<span class="string">&quot;奔驰跑起来了!&quot;</span>);    &#125;&#125;<span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">BM</span> <span class="keyword">implements</span> <span class="title class_">ICar</span>&#123;    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span> &#123;        System.out.println(<span class="string">&quot;宝马跑起来了!&quot;</span>);    &#125;&#125;<span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">IDriver</span> &#123;    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">driver</span><span class="params">(ICar car)</span>;&#125;<span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Driver</span> <span class="keyword">implements</span> <span class="title class_">IDriver</span>&#123;    <span class="meta">@Override</span>    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">driver</span><span class="params">(ICar car)</span> &#123;        car.run();    &#125;&#125;<span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">CarTest</span> &#123;    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;        <span class="type">IDriver</span> <span class="variable">driver</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Driver</span>();        driver.driver(<span class="keyword">new</span> <span class="title class_">Benz</span>());        driver.driver(<span class="keyword">new</span> <span class="title class_">BM</span>());    &#125;&#125;</code></pre><p>修改后的代码, 提炼出来一个IDriver接口和ICar接口, 面向接口编程. IDriver的实现类驾驶员可以driver任何类型的汽车, 所以传入参数也是一个接口ICar. 任何类型的汽车, 都可以通过实现ICar接口注册为一种新的汽车类型. 当客户端调用的时候, 将对应的汽车传入就可以了.</p><h2 id="5-依赖的方式"><a href="#5-依赖的方式" class="headerlink" title="5.依赖的方式"></a>5.依赖的方式</h2><h3 id="5-1-依赖注入主要有三种方式"><a href="#5-1-依赖注入主要有三种方式" class="headerlink" title="5.1 依赖注入主要有三种方式"></a>5.1 依赖注入主要有三种方式</h3><ul><li><p>构造注入</p><p>在构造的时候注入依赖</p></li><li><p>Setter方法注入</p></li><li><p>接口方法中注入(汽车的例子使用的就是此方法)</p></li></ul><h3 id="5-2-依赖倒置原则在设计模式中的体现"><a href="#5-2-依赖倒置原则在设计模式中的体现" class="headerlink" title="5.2 依赖倒置原则在设计模式中的体现"></a>5.2 依赖倒置原则在设计模式中的体现</h3><ul><li>简单工厂设计模式, 使用的是接口方法中注入</li><li>策略设计模式: 在构造函数中注入</li></ul><h1 id="五、里氏替换原则（Liskov-Substitution-Principle）"><a href="#五、里氏替换原则（Liskov-Substitution-Principle）" class="headerlink" title="五、里氏替换原则（Liskov Substitution Principle）"></a>五、里氏替换原则（Liskov Substitution Principle）</h1><h2 id="1-什么是里式替换原则"><a href="#1-什么是里式替换原则" class="headerlink" title="1. 什么是里式替换原则"></a>1. 什么是里式替换原则</h2><h3 id="1-1-里式替换原则定义"><a href="#1-1-里式替换原则定义" class="headerlink" title="1.1 里式替换原则定义"></a>1.1 里式替换原则定义</h3><p>里式替换原则是用来帮助我们在继承关系中进行父子类的设计。</p><p>里氏替换原则（Liskov Substitution principle）是对子类型的特别定义的. 为什么叫里式替换原则呢?因为这项原则最早是在1988年，由麻省理工学院的一位姓里的女士（Barbara Liskov）提出来的。</p><p>里氏替换原则主要阐述了有关继承的一些原则，也就是什么时候应该使用继承，什么时候不应该使用继承，以及其中蕴含的原理。里氏替换原是继承复用的基础，它反映了基类与子类之间的关系，是对开闭原则的补充，是对实现抽象化的具体步骤的规范。</p><p>里式替换原则有两层定义: </p><p>定义1：</p><blockquote><p>If S is a subtype of T, then objects of type T may be replaced with objects of type S, without breaking the program。 如果S是T的子类，则T的对象可以替换为S的对象，而不会破坏程序。</p></blockquote><p>定义2：</p><blockquote><p>Functions that use pointers of references to base classes must be able to use objects of derived classes without knowing it。<br>所有引用其父类对象方法的地方，都可以透明的替换为其子类对象</p></blockquote><p>这两种定义方式其实都是一个意思，即：应用程序中任何父类对象出现的地方，我们都可以用其子类的对象来替换，并且可以保证原有程序的逻辑行为和正确性。</p><h3 id="1-2-里氏替换原则有至少有两种含义"><a href="#1-2-里氏替换原则有至少有两种含义" class="headerlink" title="1.2 里氏替换原则有至少有两种含义"></a>1.2 里氏替换原则有至少有两种含义</h3><ul><li>里氏替换原则是针对继承而言的，如果继承是为了实现代码重用，也就是为了共享方法，那么共享的父类方法就应该保持不变，不能被子类重新定义。子类只能通过新添加方法来扩展功能，父类和子类都可以实例化，而子类继承的方法和父类是一样的，父类调用方法的地方，子类也可以调用同一个继承得来的，逻辑和父类一致的方法，这时用子类对象将父类对象替换掉时，当然逻辑一致，相安无事。</li><li>如果继承的目的是为了多态，而多态的前提就是子类覆盖并重新定义父类的方法，为了符合LSP，我们应该将父类定义为抽象类，并定义抽象方法，让子类重新定义这些方法，当父类是抽象类时，父类就是不能实例化，所以也不存在可实例化的父类对象在程序里。也就不存在子类替换父类实例（根本不存在父类实例了）时逻辑不一致的可能。</li></ul><p>不符合LSP的最常见的情况是，父类和子类都是可实例化的非抽象类，且父类的方法被子类重新定义，这一类的实现继承会造成父类和子类间的强耦合，也就是实际上并不相关的属性和方法牵强附会在一起，不利于程序扩展和维护。</p><h2 id="2-使用里式替换原则的目的"><a href="#2-使用里式替换原则的目的" class="headerlink" title="2. 使用里式替换原则的目的"></a>2. 使用里式替换原则的目的</h2><p>采用里氏替换原则就是为了减少继承带来的缺点，增强程序的健壮性，版本升级时也可以保持良好的兼容性。即使增加子类，原有的子类也可以继续运行。</p><h2 id="3-里式替换原则与继承多态之间的关系"><a href="#3-里式替换原则与继承多态之间的关系" class="headerlink" title="3. 里式替换原则与继承多态之间的关系"></a>3. 里式替换原则与继承多态之间的关系</h2><p>里式替换原则和继承多态有关系, 但是他俩并不是一回事. 我们来看看下面的案例</p><pre><code class="highlight java"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Cache</span> &#123;    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">set</span><span class="params">(String key, String value)</span> &#123;    &#125;&#125;<span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Redis</span> <span class="keyword">extends</span> <span class="title class_">Cache</span> &#123;    <span class="meta">@Override</span>    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">set</span><span class="params">(String key, String value)</span> &#123;    &#125;&#125;<span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Memcache</span> <span class="keyword">extends</span> <span class="title class_">Cache</span> &#123;    <span class="meta">@Override</span>    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">set</span><span class="params">(String key, String value)</span> &#123;    &#125;&#125;<span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">CacheTest</span> &#123;    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;        <span class="comment">// 父类对象都可以接收子类对象</span>        <span class="type">Cache</span> <span class="variable">cache</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Cache</span>();        cache.set(<span class="string">&quot;key123&quot;</span>, <span class="string">&quot;key123&quot;</span>);        cache = <span class="keyword">new</span> <span class="title class_">Redis</span>();        cache.set(<span class="string">&quot;key123&quot;</span>, <span class="string">&quot;key123&quot;</span>);        cache = <span class="keyword">new</span> <span class="title class_">Memcache</span>();        cache.set(<span class="string">&quot;key123&quot;</span>, <span class="string">&quot;key123&quot;</span>);    &#125;&#125;</code></pre><p>通过上面的例子, 可以看出Cache是父类, Redis 和 Memcache是子类, 他们继承自Cache. 这是继承和多态的思想. 而且这两个子类目前为止也都符合里式替换原则.可以替换父类出现的任何位置，并且原来代码的逻辑行为不变且正确性也没有被破坏。 看最后的CacheTest类, 我们使用父类的cache可以接收任何一种类型的缓存对象, 包括父类和子类.</p><p>但如果我们对Redis中的set方法做了长度校验</p><pre><code class="highlight java"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Redis</span> <span class="keyword">extends</span> <span class="title class_">Cache</span>&#123;    <span class="meta">@Override</span>    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">set</span><span class="params">(String key, String value)</span> &#123;        <span class="keyword">if</span> (key == <span class="literal">null</span> || key.length() &lt; <span class="number">10</span> || key.length() &gt; <span class="number">100</span>) &#123;            System.out.println(<span class="string">&quot;key的长度不符合要求&quot;</span>);            <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">IllegalArgumentException</span>(key的长度不符合要求);        &#125;    &#125;&#125;<span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">CacheTest</span> &#123;    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;        <span class="comment">// 父类对象都可以接收子类对象</span>        <span class="type">Cache</span> <span class="variable">cache</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Cache</span>();        cache.set(<span class="string">&quot;key123&quot;</span>, <span class="string">&quot;key123&quot;</span>);        cache = <span class="keyword">new</span> <span class="title class_">Redis</span>();        cache.set(<span class="string">&quot;key123&quot;</span>, <span class="string">&quot;key123&quot;</span>);    &#125;&#125;</code></pre><p>如上情况, 如果我们使用父类对象时替换成子类对象, 那么就会抛出异常. 程序的逻辑行为就发生了变化，虽然改造之后的代码仍然可以通过子类来替换父类 ，但是，从设计思路上来讲，Redis子类的设计是不符合里式替换原则的。</p><p>继承和多态是面向对象语言所提供的一种语法，是代码实现的思路，而里式替换则是一种思想，一种设计原则，是用来指导继承关系中子类该如何设计的，子类的设计要保证在替换父类的时候，不改变原有程序的逻辑以及不破坏原有程序的正确性。</p><h2 id="4-里式替换的规则"><a href="#4-里式替换的规则" class="headerlink" title="4. 里式替换的规则"></a>4. 里式替换的规则</h2><p>里式替换原则的核心就是“约定”，父类与子类的约定。里氏替换原则要求子类在进行设计的时候要遵守父类的一些行为约定。这里的行为约定包括：函数所要实现的功能，对输入、输出、异常的约定，甚至包括注释中一些特殊说明等。</p><h3 id="4-1-子类方法不能违背父类方法对输入输出异常的约定"><a href="#4-1-子类方法不能违背父类方法对输入输出异常的约定" class="headerlink" title="4.1 子类方法不能违背父类方法对输入输出异常的约定"></a>4.1 子类方法不能违背父类方法对输入输出异常的约定</h3><p>1、前置条件不能被加强</p><p>前置条件即输入参数是不能被加强的，就像上面Cache的示例，Redis子类对输入参数Key的要求进行了加强，此时在调用处替换父类对象为子类对象就可能引发异常。</p><p>也就是说，子类对输入的数据的校验比父类更加严格，那子类的设计就违背了里式替换原则。</p><p>2、后置条件不能被削弱</p><p>后置条件即输出，假设我们的父类方法约定输出参数要大于0，调用父类方法的程序根据约定对输出参数进行了大于0的验证。而子类在实现的时候却输出了小于等于0的值。此时子类的涉及就违背了里氏替换原则</p><p>3、不能违背对异常的约定</p><p>在父类中，某个函数约定，只会抛出 ArgumentNullException 异常， 那子类的设计实现中只允许抛出 ArgumentNullException 异常，任何其他异常的抛出，都会导致子类违背里式替换原则。</p><h3 id="4-2-子类方法不能违背父类方法定义的功能"><a href="#4-2-子类方法不能违背父类方法定义的功能" class="headerlink" title="4.2 子类方法不能违背父类方法定义的功能"></a>4.2 子类方法不能违背父类方法定义的功能</h3><pre><code class="highlight java"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Product</span> &#123;    <span class="keyword">private</span> BigDecimal amount;    <span class="keyword">private</span> Calendar createTime;     <span class="keyword">public</span> BigDecimal <span class="title function_">getAmount</span><span class="params">()</span> &#123;        <span class="keyword">return</span> amount;    &#125;    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setAmount</span><span class="params">(BigDecimal amount)</span> &#123;        <span class="built_in">this</span>.amount = amount;    &#125;     <span class="keyword">public</span> Calendar <span class="title function_">getCreateTime</span><span class="params">()</span> &#123;        <span class="keyword">return</span> createTime;    &#125;    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setCreateTime</span><span class="params">(Calendar createTime)</span> &#123;        <span class="built_in">this</span>.createTime = createTime;    &#125;&#125; <span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ProductSort</span> <span class="keyword">extends</span> <span class="title class_">Sort</span>&lt;Product&gt; &#123;     <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">sortByAmount</span><span class="params">(List&lt;Product&gt; list)</span> &#123;        <span class="comment">//根据时间进行排序</span>        list.sort((h1, h2)-&gt;h1.getCreateTime().compareTo(h2.getCreateTime()));    &#125;&#125;</code></pre><p>父类中提供的 sortByAmount() 排序函数，是按照金额从小到大来进行排序的，而子类重写这个 sortByAmount() 排序函数之后，却是是按照创建日期来进行排序的。那子类的设计就违背里式替换原则。</p><p>实际上对于如何验证子类设计是否符合里氏替换原则其实有一个小技巧，那就是你可以使用父类的单测来运行子类的代码，如果不可以正常运行，那么你就要考虑一下自己的设计是否合理了！</p><h3 id="4-3-子类必须完全实现父类的抽象方法"><a href="#4-3-子类必须完全实现父类的抽象方法" class="headerlink" title="4.3 子类必须完全实现父类的抽象方法"></a>4.3 子类必须完全实现父类的抽象方法</h3><p>如果你设计的子类不能完全实现父类的抽象方法那么你的设计就不满足里式替换原则。</p><pre><code class="highlight java"><span class="comment">// 定义抽象类枪</span><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">class</span> <span class="title class_">AbstractGun</span>&#123;    <span class="comment">// 射击</span>    <span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">void</span> <span class="title function_">shoot</span><span class="params">()</span>;        <span class="comment">// 杀人</span>    <span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">void</span> <span class="title function_">kill</span><span class="params">()</span>;&#125;</code></pre><p>比如我们定义了一个抽象的枪类，可以射击和杀人。无论是步枪还是手枪都可以射击和杀人，我们可以定义子类来继承父类</p><pre><code class="highlight java"><span class="comment">// 定义手枪，步枪，机枪</span><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Handgun</span> <span class="keyword">extends</span> <span class="title class_">AbstractGun</span>&#123;       <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">shoot</span><span class="params">()</span>&#123;           <span class="comment">// 手枪射击</span>    &#125;        <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">kill</span><span class="params">()</span>&#123;            <span class="comment">// 手枪杀人</span>    &#125;&#125;<span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Rifle</span> <span class="keyword">extends</span> <span class="title class_">AbstractGun</span>&#123;    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">shoot</span><span class="params">()</span>&#123;         <span class="comment">// 步枪射击</span>    &#125;        <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">kill</span><span class="params">()</span>&#123;             <span class="comment">// 步枪杀人</span>    &#125;&#125;</code></pre><p>但是如果我们在这个继承体系内加入一个玩具枪，就会有问题了，因为玩具枪只能射击，不能杀人。但是很多人写代码经常会这么写。</p><pre><code class="highlight java"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ToyGun</span> <span class="keyword">extends</span> <span class="title class_">AbstractGun</span>&#123;    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">shoot</span><span class="params">()</span>&#123;        <span class="comment">// 玩具枪射击</span>    &#125;        <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">kill</span><span class="params">()</span>&#123;         <span class="comment">// 因为玩具枪不能杀人，就返回空，或者直接throw一个异常出去</span>        <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">Exception</span>(<span class="string">&quot;我是个玩具枪，惊不惊喜，意不意外，刺不刺激？&quot;</span>);    &#125;&#125;</code></pre><p>这时，我们如果把使用父类对象的地方替换为子类对象，显然是会有问题的。</p><p>而这种情况不仅仅不满足里氏替换原则，也不满足接口隔离原则，对于这种场景可以通过 <strong>接口隔离+委托</strong> 的方式来解决。</p><h2 id="5-里氏替换原则的作用"><a href="#5-里氏替换原则的作用" class="headerlink" title="5. 里氏替换原则的作用"></a>5. 里氏替换原则的作用</h2><ul><li>里氏替换原则是实现开闭原则的重要方式之一。</li><li>它克服了继承中重写父类造成的可复用性变差的缺点。</li><li>它是动作正确性的保证。即类的扩展不会给已有的系统引入新的错误，降低了代码出错的可能性。</li><li>加强程序的健壮性，同时变更时可以做 到非常好的兼容性，提高程序的维护性、可扩展性，降低需求变更时引入的风险。</li></ul><p><strong>尽量不要从可实例化的父类中继承，而是要使用基于抽象类和接口的继承。</strong></p><h2 id="6-里氏替换原则的实现方法"><a href="#6-里氏替换原则的实现方法" class="headerlink" title="6. 里氏替换原则的实现方法"></a>6. 里氏替换原则的实现方法</h2><p>里氏替换原则通俗来讲就是：子类可以扩展父类的功能，但不能改变父类原有的功能。也就是说：子类继承父类时，除添加新的方法完成新增功能外，尽量不要重写父类的方法。</p><p>根据上述理解，对里氏替换原则的定义可以总结如下：</p><ul><li>子类可以实现父类的抽象方法，但不能覆盖父类的非抽象方法</li><li>子类中可以增加自己特有的方法</li><li>当子类的方法重载父类的方法时，方法的前置条件（即方法的输入参数）要比父类的方法更宽松</li><li>当子类的方法实现父类的方法时（重写&#x2F;重载或实现抽象方法），方法的后置条件（即方法的的输出&#x2F;返回值）要比父类的方法更严格或相等</li></ul><p>通过重写父类的方法来完成新的功能写起来虽然简单，但是整个继承体系的可复用性会比较差，特别是运用多态比较频繁时，程序运行出错的概率会非常大。</p><p>如果程序违背了里氏替换原则，则继承类的对象在基类出现的地方会出现运行错误。这时其修正方法是：取消原来的继承关系，重新设计它们之间的关系。</p><h2 id="7-案例分析"><a href="#7-案例分析" class="headerlink" title="7. 案例分析"></a>7. 案例分析</h2><h3 id="7-1-案例一-两数相减"><a href="#7-1-案例一-两数相减" class="headerlink" title="7.1 案例一: 两数相减"></a>7.1 案例一: 两数相减</h3><p>当使用继承时，遵循里氏替换原则。类B继承类A时，除添加新的方法完成新增功能P2外，尽量不要重写父类A的方法，也尽量不要重载父类A的方法。</p><p>继承包含这样一层含义：父类中凡是已经实现好的方法（相对于抽象方法而言），实际上是在设定一系列的规范和契约，虽然它不强制要求所有的子类必须遵从这些契约，但是如果子类对这些非抽象方法任意修改，就会对整个继承体系造成破坏。而里氏替换原则就是表达了这一层含义。</p><blockquote><p>继承作为面向对象三大特性之一，在给程序设计带来巨大便利的同时，也带来了弊端。比如使用继承会给程序带来侵入性，程序的可移植性降低，增加了对象间的耦合性，如果一个类被其他的类所继承，则当这个类需要修改时，必须考虑到所有的子类，并且父类修改后，所有涉及到子类的功能都有可能会产生故障。</p></blockquote><pre><code class="highlight java"><span class="keyword">class</span> <span class="title class_">A</span>&#123;<span class="keyword">public</span> <span class="type">int</span> <span class="title function_">func1</span><span class="params">(<span class="type">int</span> a, <span class="type">int</span> b)</span>&#123;<span class="keyword">return</span> a-b;&#125;&#125; <span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Client</span>&#123;<span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span>&#123;<span class="type">A</span> <span class="variable">a</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">A</span>();System.out.println(<span class="string">&quot;100-50=&quot;</span>+a.func1(<span class="number">100</span>, <span class="number">50</span>));System.out.println(<span class="string">&quot;100-80=&quot;</span>+a.func1(<span class="number">100</span>, <span class="number">80</span>));&#125;&#125;</code></pre><p>运行结果：</p><pre><code class="highlight shell">100-50=50 100-80=20</code></pre><p>后来，我们需要增加一个新的功能：完成两数相加，然后再与100求和，由类B来负责。即类B需要完成两个功能：</p><ol><li>两数相减。</li><li>两数相加，然后再加100。</li></ol><p>由于类A已经实现了第一个功能，所以类B继承类A后，只需要再完成第二个功能就可以了，代码如下：</p><pre><code class="highlight java"><span class="keyword">class</span> <span class="title class_">B</span> <span class="keyword">extends</span> <span class="title class_">A</span>&#123;<span class="keyword">public</span> <span class="type">int</span> <span class="title function_">func1</span><span class="params">(<span class="type">int</span> a, <span class="type">int</span> b)</span>&#123;<span class="keyword">return</span> a+b;&#125;<span class="keyword">public</span> <span class="type">int</span> <span class="title function_">func2</span><span class="params">(<span class="type">int</span> a, <span class="type">int</span> b)</span>&#123;<span class="keyword">return</span> func1(a,b)+<span class="number">100</span>;&#125;&#125; <span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Client</span>&#123;<span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span>&#123;<span class="type">B</span> <span class="variable">b</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">B</span>();System.out.println(<span class="string">&quot;100-50=&quot;</span>+b.func1(<span class="number">100</span>, <span class="number">50</span>));System.out.println(<span class="string">&quot;100-80=&quot;</span>+b.func1(<span class="number">100</span>, <span class="number">80</span>));System.out.println(<span class="string">&quot;100+20+100=&quot;</span>+b.func2(<span class="number">100</span>, <span class="number">20</span>));&#125;&#125;</code></pre><p>类B完成后，运行结果：</p><pre><code class="highlight shell">100-50=150 100-80=180 100+20+100=220</code></pre><p>我们发现原本运行正常的相减功能发生了错误。原因就是类B在给方法起名时无意中重写了父类的方法，造成所有运行相减功能的代码全部调用了类B重写后的方法，造成原本运行正常的功能出现了错误。在本例中，引用基类A完成的功能，换成子类B之后，发生了异常。在实际编程中，我们常常会通过重写父类的方法来完成新的功能，这样写起来虽然简单，但是整个继承体系的可复用性会比较差，特别是运用多态比较频繁时，程序运行出错的几率非常大。如果非要重写父类的方法，比较<strong>通用的做法是：原来的父类和子类都继承一个更通俗的基类，原有的继承关系去掉，采用依赖、聚合，组合等关系代替。</strong></p><h3 id="7-2-案例二-“几维鸟不是鸟”"><a href="#7-2-案例二-“几维鸟不是鸟”" class="headerlink" title="7.2 案例二: “几维鸟不是鸟”"></a>7.2 案例二: “几维鸟不是鸟”</h3><p>需求分析: 鸟通常都是会飞的, 比如燕子每小时120千米, 但是新西兰的几维鸟由于翅膀退化不会飞. 假如要设计一个实例，计算这两种鸟飞行 300 千米要花费的时间。显然，拿燕子来测试这段代码，结果正确，能计算出所需要的时间；但拿几维鸟来测试，结果会发生“除零异常”或是“无穷大”，明显不符合预期，其类图如图 下 所示。</p><p><img src="https://raw.githubusercontent.com/GeorgeChan95/blogimg/master/img/2024/10/31/20241031-202900.png" alt="里氏替换原则"></p><p>源码如下:</p><pre><code class="highlight java"><span class="comment">/**</span><span class="comment"> * 鸟</span><span class="comment"> */</span><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Bird</span> &#123;    <span class="comment">// 飞行的速度</span>    <span class="keyword">private</span> <span class="type">double</span> flySpeed;    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setFlySpeed</span><span class="params">(<span class="type">double</span> flySpeed)</span> &#123;        <span class="built_in">this</span>.flySpeed = flySpeed;    &#125;    <span class="keyword">public</span> <span class="type">double</span> <span class="title function_">getFlyTime</span><span class="params">(<span class="type">double</span> distance)</span> &#123;        <span class="keyword">return</span> distance/flySpeed;    &#125;&#125;<span class="comment">/**</span><span class="comment"> * 燕子</span><span class="comment"> */</span><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Swallow</span> <span class="keyword">extends</span> <span class="title class_">Bird</span>&#123;&#125;<span class="comment">/**</span><span class="comment"> * 几维鸟</span><span class="comment"> */</span><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Kiwi</span> <span class="keyword">extends</span> <span class="title class_">Bird</span> &#123;    <span class="meta">@Override</span>    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setFlySpeed</span><span class="params">(<span class="type">double</span> flySpeed)</span> &#123;        flySpeed = <span class="number">0</span>;    &#125;&#125;<span class="comment">/**</span><span class="comment">  * 测试飞行耗费时间</span><span class="comment">  */</span><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">BirdTest</span> &#123;    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;        <span class="type">Bird</span> <span class="variable">bird1</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Swallow</span>();        <span class="type">Bird</span> <span class="variable">bird2</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Kiwi</span>();        bird1.setFlySpeed(<span class="number">120</span>);        bird2.setFlySpeed(<span class="number">120</span>);        System.out.println(<span class="string">&quot;如果飞行300公里：&quot;</span>);        <span class="keyword">try</span> &#123;            System.out.println(<span class="string">&quot;燕子花费&quot;</span> + bird1.getFlyTime(<span class="number">300</span>) + <span class="string">&quot;小时.&quot;</span>);            System.out.println(<span class="string">&quot;几维花费&quot;</span> + bird2.getFlyTime(<span class="number">300</span>) + <span class="string">&quot;小时。&quot;</span>);        &#125; <span class="keyword">catch</span> (Exception err) &#123;            System.out.println(<span class="string">&quot;发生错误了!&quot;</span>);        &#125;    &#125;&#125;</code></pre><p>运行结果:</p><pre><code class="highlight java">如果飞行<span class="number">300</span>公里： 燕子花费<span class="number">2.5</span>小时. 几维花费Infinity小时。</code></pre><p>程序运行错误的原因是：几维鸟类重写了鸟类的 setSpeed(double speed) 方法，这违背了里氏替换原则。正确的做法是：取消几维鸟原来的继承关系，定义鸟和几维鸟的更一般的父类，如动物类，它们都有奔跑的能力。几维鸟的飞行速度虽然为 0，但奔跑速度不为 0，可以计算出其奔跑 300 千米所要花费的时间。其类图如图 下所示。</p><p><img src="https://raw.githubusercontent.com/GeorgeChan95/blogimg/master/img/2024/10/31/20241031-203352.png" alt="里氏替换原则2"></p><p>源代码实现如下</p><pre><code class="highlight java"><span class="comment">/**</span><span class="comment"> * 动物</span><span class="comment"> */</span><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Animal</span> &#123;    <span class="keyword">private</span> <span class="type">double</span> runSpeed;    <span class="keyword">public</span> <span class="type">double</span> <span class="title function_">getRunTime</span><span class="params">(<span class="type">double</span> distance)</span> &#123;        <span class="keyword">return</span> distance/runSpeed;    &#125;    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setRunSpeed</span><span class="params">(<span class="type">double</span> runSpeed)</span> &#123;        <span class="built_in">this</span>.runSpeed = runSpeed;    &#125;&#125;<span class="comment">/**</span><span class="comment"> * 鸟</span><span class="comment"> */</span><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Bird</span> &#123;    <span class="comment">// 飞行的速度</span>    <span class="keyword">private</span> <span class="type">double</span> flySpeed;    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setFlySpeed</span><span class="params">(<span class="type">double</span> flySpeed)</span> &#123;        <span class="built_in">this</span>.flySpeed = flySpeed;    &#125;    <span class="keyword">public</span> <span class="type">double</span> <span class="title function_">getFlyTime</span><span class="params">(<span class="type">double</span> distance)</span> &#123;        <span class="keyword">return</span> distance/flySpeed;    &#125;&#125;<span class="comment">/**</span><span class="comment"> * 燕子</span><span class="comment"> */</span><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Swallow</span> <span class="keyword">extends</span> <span class="title class_">Bird</span> &#123;&#125;<span class="comment">/**</span><span class="comment"> * 几维鸟</span><span class="comment"> */</span><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Kiwi</span> <span class="keyword">extends</span> <span class="title class_">Animal</span> &#123;    <span class="meta">@Override</span>    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setRunSpeed</span><span class="params">(<span class="type">double</span> runSpeed)</span> &#123;        <span class="built_in">super</span>.setRunSpeed(runSpeed);    &#125;&#125;<span class="comment">/**</span><span class="comment">  * 测试飞行耗费时间</span><span class="comment">  */</span><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">BirdTest</span> &#123;    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;        <span class="type">Bird</span> <span class="variable">bird1</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Swallow</span>();        <span class="type">Animal</span> <span class="variable">bird2</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Kiwi</span>();        bird1.setFlySpeed(<span class="number">120</span>);        bird2.setRunSpeed(<span class="number">110</span>);        System.out.println(<span class="string">&quot;如果飞行300公里：&quot;</span>);        <span class="keyword">try</span> &#123;            System.out.println(<span class="string">&quot;燕子花费&quot;</span> + bird1.getFlyTime(<span class="number">300</span>) + <span class="string">&quot;小时.&quot;</span>);            System.out.println(<span class="string">&quot;几维鸟花费&quot;</span> + bird2.getRunTime(<span class="number">300</span>) + <span class="string">&quot;小时。&quot;</span>);        &#125; <span class="keyword">catch</span> (Exception err) &#123;            System.out.println(<span class="string">&quot;发生错误了!&quot;</span>);        &#125;    &#125;&#125;</code></pre><p>运行结果</p><pre><code class="highlight shell">如果飞行300公里： 燕子花费2.5小时. 几维鸟花费2.727272727272727小时。</code></pre><p><strong>总结:</strong></p><p>面向对象的编程思想中提供了继承和多态是我们可以很好的实现代码的复用性和可扩展性，但继承并非没有缺点，因为继承的本身就是具有侵入性的，如果使用不当就会大大增加代码的耦合性，而降低代码的灵活性，增加我们的维护成本，然而在实际使用过程中却往往会出现滥用继承的现象，而里式替换原则可以很好的帮助我们在继承关系中进行父子类的设计。</p><h1 id="六、开闭原则（Open-Closed-Principle）"><a href="#六、开闭原则（Open-Closed-Principle）" class="headerlink" title="六、开闭原则（Open Closed Principle）"></a>六、开闭原则（Open Closed Principle）</h1><h2 id="1-什么是开闭原则"><a href="#1-什么是开闭原则" class="headerlink" title="1. 什么是开闭原则"></a>1. 什么是开闭原则</h2><p>开放封闭原则（OCP，Open Closed Principle）是所有面向对象原则的核心。软件设计本身所追求的目标就是封装变化、降低耦合，而开放封闭原则正是对这一目标的最直接体现。其他的设计原则，很多时候是为实现这一目标服务的.</p><h3 id="1-1-开闭原则的定义"><a href="#1-1-开闭原则的定义" class="headerlink" title="1.1 开闭原则的定义"></a>1.1 开闭原则的定义</h3><blockquote><p>Software entities like classes,modules and functions should be open for extension but closed for modifications 一个软件实体, 如类, 模块, 函数等应该对扩展开放, 对修改封闭.</p></blockquote><p>这也是开放封闭原则的核心思想：对扩展开放，对修改封闭.</p><ul><li>对扩展开放，意味着有新的需求或变化时，可以对现有代码进行扩展，以适应新的情况。</li><li>对修改封闭，意味着类一旦设计完成，就可以独立完成其工作，而不要对已有代码进行任何修改</li></ul><h2 id="2-如何实现开放封闭原则"><a href="#2-如何实现开放封闭原则" class="headerlink" title="2. 如何实现开放封闭原则"></a>2. 如何实现开放封闭原则</h2><p>“需求总是变化”、“世界上没有一个软件是不变的”。这里投射出的意思是：需求总是变化的， 可是对于软件设计者来说, 如何才能做到不对原有系统修改的前提下, 实现灵活的扩展. 这就是开闭原则要实现的.</p><p>我们在设计系统的时候, 不可能设想一次性把需求确定后, 后面就不改变了.这不科学也不现实的. 既然需求是一定会变化的, 那么我们要如何优雅的面对这种变化呢? 如何设计可以使软件相对容易修改, 不至于需求一变, 就要把整个程序推到重来?</p><blockquote><p>开封-封闭原则. 设计软件要容易维护且不容易出问题的最好办法, 就是多扩展, 少修改.</p></blockquote><h3 id="2-1-依赖与抽象"><a href="#2-1-依赖与抽象" class="headerlink" title="2.1 依赖与抽象"></a>2.1 依赖与抽象</h3><p>实现开放封闭的核心思想就是面对抽象编程，而不是面对具体编程，因为抽象相对稳定。 让类依赖于固定的抽象，所以对修改是封闭的；而通过面向对象的继承和多态机制，可以实现对抽象体的继承，通过覆写其方法来改变固有行为，实现新的扩展方法，所以对于扩展就是开放的。这是实施开放封闭原则的基本思路。</p><h3 id="2-2-如何落地开闭原则"><a href="#2-2-如何落地开闭原则" class="headerlink" title="2.2 如何落地开闭原则"></a>2.2 如何落地开闭原则</h3><p>如果当前的设计不符合开放封闭原则，则必须进行重构。常用的设计模式主要有 <strong>模板方法（Template Method）设计模式</strong> 和 <strong>策略（Strategy）设计模式</strong> 。而封装变化，是实现这一原则的重要手段，将经常发生变化的部分封装为一个类。</p><h3 id="2-3-开闭原则的重要性"><a href="#2-3-开闭原则的重要性" class="headerlink" title="2.3 开闭原则的重要性"></a>2.3 开闭原则的重要性</h3><ol><li><p>开闭原则对测试的影响</p><p>开闭原则可是保持原有的测试代码仍然能够正常运行，我们只需要对扩展的代码进行测试就可以了。</p></li><li><p>开闭原则可以提高复用性</p><p>在面向对象的设计中，所有的逻辑都是从原子逻辑组合而来的，而不是在一个类中独立实现一个业务逻辑。只有这样代码才可以复用，粒度越小，被复用的可能性就越大。</p></li><li><p>开闭原则可以提高可维护性</p><p>面向对象开发的要求。</p></li></ol><h3 id="2-4-如何使用开闭原则"><a href="#2-4-如何使用开闭原则" class="headerlink" title="2.4 如何使用开闭原则"></a>2.4 如何使用开闭原则</h3><ul><li><p>抽象约束</p><ul><li>第一，通过接口或者抽象类约束扩展，对扩展进行边界限定，不允许出现在接口或抽象类中不存在的<strong>public</strong>方法；</li><li>第二，参数类型、引用对象尽量使用接口或者抽象类，而不是实现类； </li><li>第三，抽象层尽量保持稳定，一旦确定即不允许修改。</li></ul></li><li><p>元数据（metadata）控制模块行为</p><p>元数据就是用来描述环境和数据的数据，通俗地说就是配置参数，参数可以从文件中获得，也可以从数据库中获得。 </p><p>Spring容器就是一个典型的元数据控制模块行为的例子，其中达到极致的就是控制反转（Inversion of Control）</p></li><li><p>制定项目章程</p><p>在一个团队中，建立项目章程是非常重要的，因为章程中指定了所有人员都必须遵守的约定，对项目来说，约定优于配置。</p></li><li><p>封装变化</p><p>对变化的封装包含两层含义： </p><p>​第一，将相同的变化封装到一个接口或者抽象类中； </p><p>​第二，将不同的变化封装到不同的接口或抽象类中，不应该有两个不同的变化出现在同一个接口或抽象类中。</p></li></ul><h2 id="3-案例分析"><a href="#3-案例分析" class="headerlink" title="3. 案例分析"></a>3. 案例分析</h2><h3 id="3-1-案例一-画形状"><a href="#3-1-案例一-画形状" class="headerlink" title="3.1 案例一: 画形状"></a>3.1 案例一: 画形状</h3><p>需求: 有圆形, 有椭圆形, 根据要求画出相应的形状</p><pre><code class="highlight java"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">GraphicEditor</span> &#123;    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">draw</span><span class="params">(Shape shape)</span> &#123;        <span class="keyword">if</span> (shape.m_type == <span class="number">1</span>) &#123;            drawRectangle();        &#125; <span class="keyword">else</span> <span class="keyword">if</span>(shape.m_type == <span class="number">2</span>) &#123;            drawCircle();        &#125;    &#125;    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">drawRectangle</span><span class="params">()</span> &#123;        System.out.println(<span class="string">&quot;画长方形&quot;</span>);    &#125;    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">drawCircle</span><span class="params">()</span> &#123;        System.out.println(<span class="string">&quot;画圆形&quot;</span>);    &#125;    <span class="keyword">class</span> <span class="title class_">Shape</span> &#123;        <span class="type">int</span> m_type;    &#125;    <span class="keyword">class</span> <span class="title class_">Rectangle</span> <span class="keyword">extends</span> <span class="title class_">Shape</span> &#123;        Rectangle() &#123;            <span class="built_in">super</span>.m_type=<span class="number">1</span>;        &#125;    &#125;    <span class="keyword">class</span> <span class="title class_">Circle</span> <span class="keyword">extends</span> <span class="title class_">Shape</span> &#123;        Circle() &#123;            <span class="built_in">super</span>.m_type=<span class="number">2</span>;        &#125;    &#125;&#125;</code></pre><p>我们来看看, 这个代码, 初看是符合要求了, 再想想, 要是我增加一种形状呢? 比如增加三角形. </p><ul><li><p>首先, 要增加一个三角形的类, 继承自Shape ;</p></li><li><p>第二, 要增加一个画三角形的方法drawTrriage() ;</p></li><li><p>第三, 在draw方法中增加一种类型type&#x3D;3的处理方案</p></li></ul><p> 这就违背了开闭原则-对扩展开发, 对修改关闭. 增加一个类型, 修改了三处代码.</p><p>我们来看看合适的设计</p><pre><code class="highlight java"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">GraphicEditor1</span> &#123;    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">draw</span><span class="params">(Shape shape)</span> &#123;        shape.draw();    &#125;    <span class="keyword">interface</span> <span class="title class_">Shape</span> &#123;        <span class="keyword">void</span> <span class="title function_">draw</span><span class="params">()</span>;    &#125;    <span class="keyword">class</span> <span class="title class_">Rectangle</span> <span class="keyword">implements</span> <span class="title class_">Shape</span> &#123;        <span class="meta">@Override</span>        <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">draw</span><span class="params">()</span> &#123;            System.out.println(<span class="string">&quot;画矩形&quot;</span>);        &#125;    &#125;    <span class="keyword">class</span> <span class="title class_">Circle</span> <span class="keyword">implements</span> <span class="title class_">Shape</span> &#123;        <span class="meta">@Override</span>        <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">draw</span><span class="params">()</span> &#123;            System.out.println(<span class="string">&quot;画圆形&quot;</span>);        &#125;    &#125;&#125;</code></pre><p>各种类型的形状自己规范自己的行为, 而 <code>GraphicEditor.draw()</code> 只负责画出来. 当增加一种类型三角形. 只需要 </p><ul><li><p>第一: 增加一个三角形的类,实现Shape接口 </p></li><li><p>第二, 调用draw方法,划出来就可以了.</p></li></ul><p>整个过程都是在扩展, 而没有修改原来的类. 这个设计是符合开闭原则的.</p><h3 id="3-2-案例二"><a href="#3-2-案例二" class="headerlink" title="3.2 案例二"></a>3.2 案例二</h3><p>比如现在有一个银行业务, 存钱, 取钱和转账. 最初我们会怎么思考呢?</p><ul><li>首先有一个银行业务类, 用来处理银行的业务</li><li>银行有哪些业务呢? 存钱,取钱,转账, 这都是银行要执行的操作</li><li>那外部说我要存钱, 我要取钱,我要转账, 通过一个类型来告诉我们 代码就生成了</li></ul><pre><code class="highlight java"><span class="comment">/**</span><span class="comment">* 银行业务</span><span class="comment">*/</span><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">BankBusiness</span> &#123;   <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">operate</span><span class="params">(<span class="type">int</span> type)</span> &#123;       <span class="keyword">if</span> (type == <span class="number">1</span>) &#123;           save();       &#125; <span class="keyword">else</span> <span class="keyword">if</span>(type == <span class="number">2</span>) &#123;           take();       &#125; <span class="keyword">else</span> <span class="keyword">if</span>(type == <span class="number">3</span>) &#123;           transfer();       &#125;   &#125;   <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">save</span><span class="params">()</span>&#123;       System.out.println(<span class="string">&quot;存钱&quot;</span>);   &#125;   <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">take</span><span class="params">()</span>&#123;       System.out.println(<span class="string">&quot;取钱&quot;</span>);   &#125;   <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">transfer</span><span class="params">()</span> &#123;       System.out.println(<span class="string">&quot;转账&quot;</span>);   &#125;&#125;</code></pre><p>咋一看已经实现了需求. 但是现在有新的需求来了, 银行要增加功能—理财. 理财是银行业务的一种, 自然是新增一个方法. 然后在operate()方法里增加一种类型. 这就是一个糟糕的设计, 增加新功能, 但是却修改了原来的代码.</p><p>们设计成接口抽象的形式,源码如下：</p><pre><code class="highlight java"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">Business</span> &#123;    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">operate</span><span class="params">()</span>;&#125;<span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Save</span> <span class="keyword">implements</span> <span class="title class_">Business</span>&#123;    <span class="meta">@Override</span>    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">operate</span><span class="params">()</span> &#123;        System.out.println(<span class="string">&quot;存钱业务&quot;</span>);    &#125;&#125;<span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Take</span> <span class="keyword">implements</span> <span class="title class_">Business</span> &#123;    <span class="meta">@Override</span>    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">operate</span><span class="params">()</span> &#123;        System.out.println(<span class="string">&quot;取钱业务&quot;</span>);    &#125;&#125;<span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Transfer</span> <span class="keyword">implements</span> <span class="title class_">Business</span> &#123;    <span class="meta">@Override</span>    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">operate</span><span class="params">()</span> &#123;        System.out.println(<span class="string">&quot;转账业务&quot;</span>);    &#125;&#125;<span class="comment">/**</span><span class="comment"> * 银行业务类</span><span class="comment"> */</span><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">BankBusinesses</span> &#123;    <span class="comment">/**</span><span class="comment">     * 处理银行业务</span><span class="comment">     * <span class="doctag">@param</span> business</span><span class="comment">     */</span>    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">operate</span><span class="params">(Business business)</span> &#123;        System.out.println(<span class="string">&quot;处理银行业务&quot;</span>);        business.operate();    &#125;&#125;</code></pre><p>通过接口抽象的形式方便扩展, 加入要新增理财功能. 只需新增一个理财类, 其他业务代码都不需要修改.</p><p>其实, 在日常工作中, 经常会遇到这种情况. 因为我们平时写业务逻辑会更多一些, 而业务就像流水账, 今天一个明天一个一点一点的增加. 所以,当业务增加到3个的时候, 我们就要思考, 如何写能够方便扩展.</p><p><strong>总结</strong></p><ul><li>遵守开闭原则可以提高软件扩展性和维护性。</li><li>大部分的设计模式和设计原则都是在实现开闭原则。</li></ul><h1 id="七、迪米特法则（Demeter-Principle）"><a href="#七、迪米特法则（Demeter-Principle）" class="headerlink" title="七、迪米特法则（Demeter Principle）"></a>七、迪米特法则（Demeter Principle）</h1><h2 id="1-什么是迪米特法则"><a href="#1-什么是迪米特法则" class="headerlink" title="1. 什么是迪米特法则"></a>1. 什么是迪米特法则</h2><p>迪米特法则(Law of Demeter )又叫做最少知识原则，也就是说，一个对象应当对其他对象尽可能少的了解。不和陌生人说话。英文简写为: LoD。</p><p>迪米特法则的目的在于降低类之间的耦合。由于每个类尽量减少对其他类的依赖，因此，很容易使得系统的功能模块功能独立，相互之间不存在（或很少有）依赖关系。</p><p>迪米特法则不希望类之间建立直接的联系。如果真的有需要建立联系，也希望能通过它的友元类来转达。因此，应用迪米特法则有可能造成的一个后果就是：系统中存在大量的中介类，这些类之所以存在完全是为了传递类之间的相互调用关系——这在一定程度上增加了系统的复杂度。</p><h2 id="2-为什么要遵守迪米特法则"><a href="#2-为什么要遵守迪米特法则" class="headerlink" title="2. 为什么要遵守迪米特法则?"></a>2. 为什么要遵守迪米特法则?</h2><p>在面向对象编程中有一些众所周知的抽象概念，比如封装、内聚和耦合，理论上可以用来生成清晰的设计和良好的代码。虽然这些都是非常重要的概念，但它们不够实用，不能直接用于开发环境，这些概念是比较主观的，非常依赖于使用人的经验和知识。对于其他概念，如单一责任原则、开闭原则等，情况也是一样的。迪米特法则的独特之处在于它简洁而准确的定义，它允许在编写代码时直接应用，几乎自动地应用了适当的封装、低内聚和松耦合。</p><h2 id="3-迪米特法则的广狭义"><a href="#3-迪米特法则的广狭义" class="headerlink" title="3. 迪米特法则的广狭义"></a>3. 迪米特法则的广狭义</h2><h3 id="3-1-狭义的迪米特法则"><a href="#3-1-狭义的迪米特法则" class="headerlink" title="3.1 狭义的迪米特法则"></a>3.1 狭义的迪米特法则</h3><p>如果两个类不必彼此直接通信，那么这两个类就不应当发生直接的相互作用。如果其中的一个类需要调用另一个类的某一个方法的话，可以通过第三者转发这个调用。</p><p><strong>朋友圈的确定“朋友”条件：</strong></p><ul><li><p>当前对象本身（this）</p></li><li><p>以参数形式传入到当前对象方法中的对象.</p><p>方法入参是一个对象, 这时这个对象和当前类是朋友</p></li><li><p>当前对象的实例变量直接引用的对象</p><p>定义一个类, 里面的属性引用了其他对象, 那么引用对象的实例和当前实例是朋友</p></li><li><p>当前对象的实例变量如果是一个聚集，那么聚集中的元素也都是朋友</p><p>如果属性是一个对象, 那么属性和对象里的元素都是朋友</p></li><li><p>当前对象所创建的对象</p></li></ul><p>任何一个对象，如果满足上面的条件之一，就是当前对象的“朋友”；否则就是“陌生人”。</p><p><strong>狭义的迪米特法则的缺点：</strong></p><p>在系统里造出大量的小方法，这些方法仅仅是传递间接的调用，与系统的业务逻辑无关。 遵循类之间的迪米特法则会是一个系统的局部设计简化，因为每一个局部都不会和远距离的对象有直接的关联。但是，这也会造成系统的不同模块之间的通信效率降低，也会使系统的不同模块之间不容易协调。</p><h3 id="3-2-广义的迪米特法则在类的设计上的体现"><a href="#3-2-广义的迪米特法则在类的设计上的体现" class="headerlink" title="3.2 广义的迪米特法则在类的设计上的体现"></a>3.2 广义的迪米特法则在类的设计上的体现</h3><ul><li>优先考虑将一个类设置成不变类。 </li><li>尽量降低一个类的访问权限。  </li><li>谨慎使用Serializable。  </li><li>尽量降低成员的访问权限。</li></ul><h2 id="4-迪米特法则在设计模式中的应用"><a href="#4-迪米特法则在设计模式中的应用" class="headerlink" title="4. 迪米特法则在设计模式中的应用"></a>4. 迪米特法则在设计模式中的应用</h2><p>设计模式的门面模式（Facade）和中介模式（Mediator），都是迪米特法则的应用</p><p>下面我们已经租房为例, 来研究迪米特法则. 通常 客户要找房子住, 我们就直接建一个房子类, 建一个客户类, 客户找房子即可.</p><pre><code class="highlight java"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">IHouse</span> &#123;    <span class="comment">// 住房子</span>    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">Housing</span><span class="params">()</span>;&#125;<span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">House</span> <span class="keyword">implements</span> <span class="title class_">IHouse</span>&#123;    <span class="meta">@Override</span>    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">Housing</span><span class="params">()</span> &#123;        System.out.println(<span class="string">&quot;住房子&quot;</span>);    &#125;&#125;<span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Customer</span> &#123;    <span class="keyword">public</span> String name;    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">findHourse</span><span class="params">(IHouse house)</span> &#123;        house.Housing();    &#125;&#125;</code></pre><p>客户找房子住, 逻辑很简单, 这样是ok的. 虽然违背了迪米特法则, 但符合业务逻辑也说得通. 但是, 通常我们找房子, 不是一下子就能找到的, 我们要找很多家, 这就很费劲, 那不如交给中介. 中介有很多房源, 房东吧房子给了中介, 不需要关心租户是谁, 租户将找房的事交给房东, 他也不用管房东是谁, 而且租户+房东都很省事.</p><pre><code class="highlight java"><span class="comment">/**</span><span class="comment"> * 房子</span><span class="comment"> */</span><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">IHouse</span> &#123;    <span class="comment">// 住房子</span>    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">Housing</span><span class="params">()</span>;&#125;<span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">House</span> <span class="keyword">implements</span> <span class="title class_">IHouse</span>&#123;    <span class="meta">@Override</span>    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">Housing</span><span class="params">()</span> &#123;        System.out.println(<span class="string">&quot;住房子&quot;</span>);    &#125;&#125;<span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">ICustomer</span> &#123;    <span class="keyword">void</span> <span class="title function_">findHourse</span><span class="params">(IHouse house)</span> ;&#125;<span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Customer</span> <span class="keyword">implements</span> <span class="title class_">ICustomer</span> &#123;    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">findHourse</span><span class="params">(IHouse house)</span> &#123;        house.Housing();    &#125;&#125;<span class="comment">/**</span><span class="comment"> * 中介</span><span class="comment"> */</span><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Intermediary</span> &#123;    <span class="comment">// 找房子</span>    <span class="keyword">public</span> IHouse <span class="title function_">findHouse</span><span class="params">(ICustomer customer)</span>&#123;        <span class="comment">// 帮租户找房子</span>        <span class="keyword">return</span> <span class="literal">null</span>;    &#125;&#125;</code></pre><p>房子,客户是相互独立的, 彼此之间没有引用. 他们之间建立关系是通过中介. 也就是, 客户找中介租房子, 房东吧房子交给租户, 最后中介将找好的房子给到客户. 客户和房东彼此隔离, 符合迪米特法则.</p><h2 id="5-迪米特法则实践"><a href="#5-迪米特法则实践" class="headerlink" title="5. 迪米特法则实践"></a>5. 迪米特法则实践</h2><p>那么在实践中如何做到一个对象应该对其他对象有最少的了解呢？如果我们把一个对象看作是一个人，那么要实现“一个人应该对其他人有最少的了解”，做到两点就足够了：</p><ul><li>只和直接的朋友交流；</li><li>减少对朋友的了解。下面就详细说说如何做到这两点。</li></ul><h3 id="5-1-只和直接的朋友交流"><a href="#5-1-只和直接的朋友交流" class="headerlink" title="5.1 只和直接的朋友交流"></a>5.1 只和直接的朋友交流</h3><p>迪米特法则还有一个英文解释是：talk only to your immediate friends（只和直接的朋友交流）。</p><p><strong>什么是朋友呢？</strong></p><p>每个对象都必然会与其他的对象有耦合关系，两个对象之间的耦合就会成为朋友关系。那么什么又是直接的朋友呢？出现在<strong>成员变量</strong>、<strong>方法的输入输出参数</strong>中的类就是直接的朋友。迪米特法则要求只和直接的朋友通信。</p><blockquote><p><strong>注意：</strong><br>只出现在方法体内部的类就不是直接的朋友，如果一个类和不是直接的朋友进行交流，就属于违反迪米特法则。</p></blockquote><p>我们举一个例子说明什么是朋友，什么是直接的朋友。很简单的例子：老师让班长清点全班同学的人数。这个例子中总共有三个类：老师Teacher、班长GroupLeader和学生Student。</p><pre><code class="highlight java"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">ITeacher</span> &#123;    <span class="keyword">void</span> <span class="title function_">command</span><span class="params">(IGroupLeader groupLeader)</span>;&#125;<span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Teacher</span> <span class="keyword">implements</span> <span class="title class_">ITeacher</span>&#123;    <span class="meta">@Override</span>    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">command</span><span class="params">(IGroupLeader groupLeader)</span> &#123;        <span class="comment">// 全班同学</span>        List&lt;Student&gt; allStudent = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();        allStudent.add(<span class="keyword">new</span> <span class="title class_">Student</span>());        allStudent.add(<span class="keyword">new</span> <span class="title class_">Student</span>());        allStudent.add(<span class="keyword">new</span> <span class="title class_">Student</span>());        allStudent.add(<span class="keyword">new</span> <span class="title class_">Student</span>());        allStudent.add(<span class="keyword">new</span> <span class="title class_">Student</span>());        <span class="comment">// 班长清点人数</span>        groupLeader.count(allStudent);    &#125;&#125;** * 班长类 */<span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">IGroupLeader</span> &#123;    <span class="comment">// 班长清点人数</span>    <span class="keyword">void</span> <span class="title function_">count</span><span class="params">(List&lt;Student&gt; students)</span>;&#125;<span class="comment">/**</span><span class="comment"> * 班长类</span><span class="comment"> */</span><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">GroupLeader</span> <span class="keyword">implements</span> <span class="title class_">IGroupLeader</span>&#123;    <span class="comment">/**</span><span class="comment">     * 班长清点人数</span><span class="comment">     * <span class="doctag">@param</span> students</span><span class="comment">     */</span>    <span class="meta">@Override</span>    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">count</span><span class="params">(List&lt;Student&gt; students)</span> &#123;        <span class="comment">// 班长清点人数</span>        System.out.println(<span class="string">&quot;上课的学生人数是: &quot;</span> + students.size());    &#125;&#125;<span class="comment">/**</span><span class="comment"> * 学生类</span><span class="comment"> */</span><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">IStudent</span> &#123;&#125;<span class="comment">/**</span><span class="comment"> * 学生类</span><span class="comment"> */</span><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Student</span> <span class="keyword">implements</span> <span class="title class_">IStudent</span> &#123;&#125;<span class="comment">/**</span><span class="comment"> * 客户端</span><span class="comment"> */</span><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Client</span> &#123;    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;        <span class="comment">// 老师类</span>        <span class="type">ITeacher</span> <span class="variable">wangTeacher</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Teacher</span>();        <span class="comment">// 班长</span>        <span class="type">IGroupLeader</span> <span class="variable">zhangBanzhang</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">GroupLeader</span>();        wangTeacher.command(zhangBanzhang);    &#125;&#125;</code></pre><p>运行结果:</p><pre><code class="highlight shell">上课的学生人数是: 5</code></pre><p>在这个例子中，我们的Teacher有几个朋友？两个，一个是GroupLeader，它是Teacher的command()方法的入参；另一个是Student，因为在Teacher的command()方法体中使用了Student。</p><p>那么Teacher有几个是直接的朋友？按照直接的朋友的定义</p><blockquote><p>出现在成员变量、方法的输入输出参数中的类就是直接的朋友</p></blockquote><p>只有GroupLeader是Teacher的直接的朋友。</p><p>Teacher在command()方法中创建了Student的数组，和非直接的朋友Student发生了交流，所以，上述例子<strong>违反了迪米特法则</strong>。方法是类的一个行为，类竟然不知道自己的行为与其他的类产生了依赖关系，这是不允许的，<strong>严重违反了迪米特法则</strong>！</p><p><strong>为了使上述例子符合迪米特法则，我们可以做如下修改：</strong></p><pre><code class="highlight java"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">ITeacher</span> &#123;    <span class="keyword">void</span> <span class="title function_">command</span><span class="params">(IGroupLeader groupLeader)</span>;&#125;<span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Teacher</span> <span class="keyword">implements</span> <span class="title class_">ITeacher</span> &#123;    <span class="meta">@Override</span>    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">command</span><span class="params">(IGroupLeader groupLeader)</span> &#123;        <span class="comment">// 班长清点人数</span>        groupLeader.count();    &#125;&#125;<span class="comment">/**</span><span class="comment"> * 班长类</span><span class="comment"> */</span><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">IGroupLeader</span> &#123;    <span class="comment">// 班长清点人数</span>    <span class="keyword">void</span> <span class="title function_">count</span><span class="params">()</span>;&#125;<span class="comment">/**</span><span class="comment"> * 班长类</span><span class="comment"> */</span><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">GroupLeader</span> <span class="keyword">implements</span> <span class="title class_">IGroupLeader</span> &#123;    <span class="keyword">private</span> List&lt;Student&gt; students;    <span class="keyword">public</span> <span class="title function_">GroupLeader</span><span class="params">(List&lt;Student&gt; students)</span> &#123;        <span class="built_in">this</span>.students = students;    &#125;    <span class="comment">/**</span><span class="comment">     * 班长清点人数</span><span class="comment">     */</span>    <span class="meta">@Override</span>    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">count</span><span class="params">()</span> &#123;        <span class="comment">// 班长清点人数</span>        System.out.println(<span class="string">&quot;上课的学生人数是: &quot;</span> + students.size());    &#125;&#125;<span class="comment">/**</span><span class="comment"> * 学生类</span><span class="comment"> */</span><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">IStudent</span> &#123;&#125;<span class="comment">/**</span><span class="comment"> * 学生类</span><span class="comment"> */</span><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Student</span> <span class="keyword">implements</span> <span class="title class_">IStudent</span> &#123;&#125;<span class="comment">/**</span><span class="comment"> * 客户端</span><span class="comment"> */</span><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Client</span> &#123;    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;        <span class="comment">// 老师类</span>        <span class="type">ITeacher</span> <span class="variable">wangTeacher</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Teacher</span>();        List&lt;Student&gt; allStudent = <span class="keyword">new</span> <span class="title class_">ArrayList</span>(<span class="number">10</span>);        allStudent.add(<span class="keyword">new</span> <span class="title class_">Student</span>());        allStudent.add(<span class="keyword">new</span> <span class="title class_">Student</span>());        allStudent.add(<span class="keyword">new</span> <span class="title class_">Student</span>());        allStudent.add(<span class="keyword">new</span> <span class="title class_">Student</span>());        <span class="comment">// 班长</span>        <span class="type">IGroupLeader</span> <span class="variable">zhangBanzhang</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">GroupLeader</span>(allStudent);        wangTeacher.command(zhangBanzhang);    &#125;&#125;</code></pre><p>运行结果: </p><pre><code class="highlight shell">上课的学生人数是: 4</code></pre><p>这样修改后，每个类都只和直接的朋友交流，有效减少了类之间的耦合</p><h3 id="5-2-减少对朋友的了解"><a href="#5-2-减少对朋友的了解" class="headerlink" title="5.2 减少对朋友的了解"></a>5.2 减少对朋友的了解</h3><p>如何减少对朋友的了解？即：<strong>在一个类中，就是尽量减少一个类对外暴露的方法</strong></p><p>举一个简单的例子说明一个类暴露方法过多的情况。一个人用咖啡机煮咖啡的过程，例子中只有两个类，一个是人，一个是咖啡机。</p><p>首先是咖啡机类CoffeeMachine，咖啡机制作咖啡只需要三个方法：1.加咖啡豆；2.加水；3.制作咖啡：</p><pre><code class="highlight java"><span class="comment">/**</span><span class="comment"> * 咖啡机抽象接口</span><span class="comment"> */</span><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">ICoffeeMachine</span> &#123;    <span class="comment">//加咖啡豆</span>    <span class="keyword">void</span> <span class="title function_">addCoffeeBean</span><span class="params">()</span>;    <span class="comment">//加水</span>    <span class="keyword">void</span> <span class="title function_">addWater</span><span class="params">()</span>;    <span class="comment">//制作咖啡</span>    <span class="keyword">void</span> <span class="title function_">makeCoffee</span><span class="params">()</span>;&#125;<span class="comment">/**</span><span class="comment"> * 咖啡机实现类</span><span class="comment"> */</span><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">CoffeeMachine</span> <span class="keyword">implements</span> <span class="title class_">ICoffeeMachine</span>&#123;    <span class="comment">//加咖啡豆</span>    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">addCoffeeBean</span><span class="params">()</span> &#123;        System.out.println(<span class="string">&quot;放咖啡豆&quot;</span>);    &#125;    <span class="comment">//加水</span>    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">addWater</span><span class="params">()</span> &#123;        System.out.println(<span class="string">&quot;加水&quot;</span>);    &#125;    <span class="comment">//制作咖啡</span>    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">makeCoffee</span><span class="params">()</span> &#123;        System.out.println(<span class="string">&quot;制作咖啡&quot;</span>);    &#125;&#125;<span class="comment">/**</span><span class="comment"> * 人, 制作咖啡</span><span class="comment"> */</span><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">IMan</span> &#123;    <span class="comment">/**</span><span class="comment">     * 制作咖啡</span><span class="comment">     */</span>    <span class="keyword">void</span> <span class="title function_">makeCoffee</span><span class="params">()</span>;&#125;<span class="comment">/**</span><span class="comment"> * 人制作咖啡</span><span class="comment"> */</span><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Man</span> <span class="keyword">implements</span> <span class="title class_">IMan</span> &#123;    <span class="keyword">private</span> ICoffeeMachine coffeeMachine;    <span class="keyword">public</span> <span class="title function_">Man</span><span class="params">(ICoffeeMachine coffeeMachine)</span> &#123;        <span class="built_in">this</span>.coffeeMachine = coffeeMachine;    &#125;    <span class="comment">/**</span><span class="comment">     * 制作咖啡</span><span class="comment">     */</span>    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">makeCoffee</span><span class="params">()</span> &#123;        coffeeMachine.addWater();        coffeeMachine.addCoffeeBean();        coffeeMachine.makeCoffee();    &#125;&#125;<span class="comment">/**</span><span class="comment"> * 客户端</span><span class="comment"> */</span><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Client</span> &#123;    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;        <span class="type">ICoffeeMachine</span> <span class="variable">coffeeMachine</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">CoffeeMachine</span>();        <span class="type">IMan</span> <span class="variable">man</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Man</span>(coffeeMachine);        man.makeCoffee();    &#125;&#125;</code></pre><p>运行结果:</p><pre><code class="highlight shell">加水放咖啡豆制作咖啡</code></pre><p>在这个例子中，CoffeeMachine是Man的直接好友，但问题是Man对CoffeeMachine了解的太多了，其实人根本不关心咖啡机具体制作咖啡的过程。所以我们可以作如下优化：</p><p>优化后的咖啡机类，只暴露一个work方法，把制作咖啡的三个具体的方法addCoffeeBean、addWater、makeCoffee设为私有.</p><pre><code class="highlight java"><span class="comment">/**</span><span class="comment"> * 咖啡机抽象接口</span><span class="comment"> */</span><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">ICoffeeMachine</span> &#123;    <span class="comment">//咖啡机工作</span>    <span class="keyword">void</span> <span class="title function_">work</span><span class="params">()</span>;&#125;<span class="comment">/**</span><span class="comment"> * 咖啡机实现类</span><span class="comment"> */</span><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">CoffeeMachine</span> <span class="keyword">implements</span> <span class="title class_">ICoffeeMachine</span> &#123;    <span class="comment">//加咖啡豆</span>    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">addCoffeeBean</span><span class="params">()</span> &#123;        System.out.println(<span class="string">&quot;放咖啡豆&quot;</span>);    &#125;    <span class="comment">//加水</span>    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">addWater</span><span class="params">()</span> &#123;        System.out.println(<span class="string">&quot;加水&quot;</span>);    &#125;    <span class="comment">//制作咖啡</span>    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">makeCoffee</span><span class="params">()</span> &#123;        System.out.println(<span class="string">&quot;制作咖啡&quot;</span>);    &#125;    <span class="meta">@Override</span>    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">work</span><span class="params">()</span> &#123;        addCoffeeBean();        addWater();        makeCoffee();    &#125;&#125;<span class="comment">/**</span><span class="comment"> * 人, 制作咖啡</span><span class="comment"> */</span><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">IMan</span> &#123;    <span class="comment">/**</span><span class="comment">     * 制作咖啡</span><span class="comment">     */</span>    <span class="keyword">void</span> <span class="title function_">makeCoffee</span><span class="params">()</span>;&#125;<span class="comment">/**</span><span class="comment"> * 人制作咖啡</span><span class="comment"> */</span><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Man</span> <span class="keyword">implements</span> <span class="title class_">IMan</span> &#123;    <span class="keyword">private</span> ICoffeeMachine coffeeMachine;    <span class="keyword">public</span> <span class="title function_">Man</span><span class="params">(ICoffeeMachine coffeeMachine)</span> &#123;        <span class="built_in">this</span>.coffeeMachine = coffeeMachine;    &#125;    <span class="comment">/**</span><span class="comment">     * 制作咖啡</span><span class="comment">     */</span>    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">makeCoffee</span><span class="params">()</span> &#123;        coffeeMachine.work();    &#125;&#125;<span class="comment">/**</span><span class="comment"> * 客户端</span><span class="comment"> */</span><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Client</span> &#123;    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;        <span class="type">ICoffeeMachine</span> <span class="variable">coffeeMachine</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">CoffeeMachine</span>();        <span class="type">IMan</span> <span class="variable">man</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Man</span>(coffeeMachine);        man.makeCoffee();    &#125;&#125;</code></pre><p>这样修改后，通过减少CoffeeMachine对外暴露的方法，减少Man对CoffeeMachine的了解，从而降低了它们之间的耦合。</p><p><strong>注意事项</strong></p><ul><li><p>第一：在类的划分上，应当创建弱耦合的类，类与类之间的耦合越弱，就越有利于实现可复用的目标。 </p></li><li><p>第二：在类的结构设计上，每个类都应该降低成员的访问权限。 </p></li><li><p>第三：在类的设计上，只要有可能，一个类应当设计成不变的类。 </p></li><li><p>第四：在对其他类的引用上，一个对象对其他类的对象的引用应该降到最低。 </p></li><li><p>第五：尽量限制局部变量的有效范围，降低类的访问权限。</p></li></ul><p>参考链接</p><blockquote><p><a href="https://juejin.cn/column/6966429007785459749">https://juejin.cn/column/6966429007785459749</a></p></blockquote>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;一、设计模式的目的&quot;&gt;&lt;a href=&quot;#一、设计模式的目的&quot; class=&quot;headerlink&quot; title=&quot;一、设计模式的目的&quot;&gt;&lt;/a&gt;一、设计模式的目的&lt;/h1&gt;&lt;p&gt;编写软件过程中，程序员面临着来自&lt;strong&gt;耦合性&lt;/strong&gt;，&lt;stro</summary>
      
    
    
    
    <category term="设计模式" scheme="https://georgechan95.github.io/categories/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"/>
    
    
    <category term="设计模式" scheme="https://georgechan95.github.io/tags/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"/>
    
    <category term="java" scheme="https://georgechan95.github.io/tags/java/"/>
    
  </entry>
  
  <entry>
    <title>13-JUC进阶-ReentrantReadWriteLock与StampedLock</title>
    <link href="https://georgechan95.github.io/blog/1a649f4c.html"/>
    <id>https://georgechan95.github.io/blog/1a649f4c.html</id>
    <published>2024-10-19T01:26:00.000Z</published>
    <updated>2024-10-19T08:52:05.976Z</updated>
    
    <content type="html"><![CDATA[<h1 id="一、锁的演变"><a href="#一、锁的演变" class="headerlink" title="一、锁的演变"></a>一、锁的演变</h1><p>无锁  –&gt; 独占锁  –&gt; 读写锁  –&gt; 邮戳锁</p><ul><li><p>无锁：存在线程安全问题</p></li><li><p>独占锁（synchronized，ReentrantLock）</p><p>同一时刻只能有一个线程访问，在读多写少的场景下，效率并不高。</p></li><li><p>读写锁（ReentrantReadWriteLock）</p><p> 适应在多读写少的场景下，读锁可以被线程共享(<strong>共享锁</strong>)，写锁只能有一个线程获取(<strong>排它锁</strong>)。读的时候不允许写，写的时候不允许读。</p><ul><li>读写锁的缺点<ul><li>写锁饥饿问题</li><li>锁降级问题</li></ul></li></ul></li><li><p>邮戳锁（StampedLock）</p><p>是对ReentrantReadWriteLock读写锁的一种改进，主要的改进为：在没有写只有读的场景下，StampedLock支持不用加读锁而是直接进行读操作，最大程度提升读的效率，只有在发生过写操作之后，再加读锁才能进行读操作</p></li></ul><h1 id="二、ReentrantReadWriteLock"><a href="#二、ReentrantReadWriteLock" class="headerlink" title="二、ReentrantReadWriteLock"></a>二、ReentrantReadWriteLock</h1><p>关于读写锁的原理和锁降级，参考博客：<a href="https://georgechan95.github.io/blog/850dac3c.html">https://georgechan95.github.io/blog/850dac3c.html</a></p><h1 id="三、邮戳锁"><a href="#三、邮戳锁" class="headerlink" title="三、邮戳锁"></a>三、邮戳锁</h1><h2 id="1-StampedLock简介"><a href="#1-StampedLock简介" class="headerlink" title="1. StampedLock简介"></a>1. StampedLock简介</h2><p><code>StampedLock</code> 是JUC并发包里面 JDK8 版本新增的一个锁，是读写锁的一种具体实现，和 <code>ReentrantReadWriteLock</code> 不同的是其不提供可重入性，不基于某个类似<code>Lock</code> 或者 <code>ReadWriteLock</code> 接口实现,而是基于CLH锁思想实现这点这AQS有些类似，并且 <code>StampedLock</code> 不支持条件变量 <code>Condition</code> 。</p><h3 id="1-1-StampedLock-三个主要的锁模式"><a href="#1-1-StampedLock-三个主要的锁模式" class="headerlink" title="1.1 StampedLock 三个主要的锁模式"></a>1.1 StampedLock 三个主要的锁模式</h3><ul><li><p><strong>写锁模式（writeLock()）</strong></p><p>用于排他性地写操作。在写锁模式下，其他线程既无法获取读锁，也无法获取写锁。</p></li><li><p><strong>乐观读锁模式（tryOptimisticRead()）</strong></p><p>允许线程进行读操作而不获取读锁，这种模式假设在读操作过程中数据不会被其他线程修改。如果发现数据被修改，可以重新获取悲观读锁以保证数据一致性。</p></li><li><p><strong>悲观读锁模式（readLock()）</strong></p><p>类似于 ReadWriteLock 的读锁，允许多个线程同时获取读锁，但无法与写锁共存。</p></li></ul><h3 id="1-2-戳记"><a href="#1-2-戳记" class="headerlink" title="1.2 戳记"></a>1.2 戳记</h3><p>戳记（stamp） 是 StampedLock 的关键，表示当前锁的状态。获取锁时返回的戳记值在后续的锁操作中用于验证锁的有效性，确保在锁的释放或转换操作中锁的状态是正确的。使用戳记有助于减少锁的争用和开销， StampedLock 通过提供乐观读锁在多线程多读的情况下提供了更好的性能，这是因为获取乐观读锁时不需要进行 CAS 操作设置锁的状态，而只是简单地测试状态。</p><h3 id="1-3-获取锁和释放锁的方法"><a href="#1-3-获取锁和释放锁的方法" class="headerlink" title="1.3 获取锁和释放锁的方法"></a>1.3 获取锁和释放锁的方法</h3><ul><li>获取锁：<ul><li><code>tryOptimisticRead()</code>: 获取乐观读锁，返回戳记。</li><li><code>readLock()</code>: 获取悲观读锁，返回戳记</li><li><code>writeLock()</code>: 获取写锁，返回戳记。</li></ul></li><li>释放锁：<ul><li><code>unlockRead(stamp)</code>: 释放读锁（悲观读锁或乐观读锁）。</li><li><code>unlockWrite(stamp)</code>: 释放写锁。</li></ul></li><li>转换锁：<ul><li><code>tryConvertToWriteLock(long stamp)</code>：尝试将当前持有的锁转换为写锁</li><li><code>tryConvertToReadLock(long stamp)</code>：尝试将当前持有的写锁转换为读锁</li><li><code>tryConvertToOptimisticRead(long stamp)</code>：尝试将当前持有的悲观读锁转换为乐观读锁</li></ul></li></ul><p>可以看出<code>tryConvertToWriteLock</code> 方法表明 <code>StampedLock</code> 支持锁升级，这也是和<code>ReentrantReadWriteLock</code> 不同的点</p><h3 id="1-4-并发度比较"><a href="#1-4-并发度比较" class="headerlink" title="1.4 并发度比较"></a>1.4 并发度比较</h3><table><thead><tr><th align="left">锁</th><th align="left">并发度</th></tr></thead><tbody><tr><td align="left">ReentrantLock</td><td align="left">读读互斥，读写互斥，写写互斥</td></tr><tr><td align="left">ReentrantReadWriteLock</td><td align="left">读读不互斥、读写互斥、写写互斥</td></tr><tr><td align="left">StampedLock</td><td align="left">读读不互斥、读写不互斥、写写互斥</td></tr></tbody></table><p>上面对于StampedLock 的读写不互斥是指 乐观读和写，而不是悲观读和写。</p><p>乐观读的思想和数据库中MVCC（Multi-Version Concurrency Control，多版本并发控制）有点类似。</p><h2 id="2-StampedLock简单使用示例"><a href="#2-StampedLock简单使用示例" class="headerlink" title="2. StampedLock简单使用示例"></a>2. StampedLock简单使用示例</h2><h3 id="2-1-示例代码"><a href="#2-1-示例代码" class="headerlink" title="2.1 示例代码"></a>2.1 示例代码</h3><pre><code class="highlight java"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">TestStampedLock</span> &#123;    <span class="comment">// 声明邮戳锁</span>    <span class="keyword">private</span> <span class="type">StampedLock</span> <span class="variable">lock</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">StampedLock</span>();    <span class="keyword">private</span> <span class="keyword">volatile</span> <span class="type">int</span> <span class="variable">num</span> <span class="operator">=</span> <span class="number">10</span>;    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> InterruptedException &#123;        <span class="type">TestStampedLock</span> <span class="variable">test</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">TestStampedLock</span>();        <span class="type">Runnable</span> <span class="variable">readRun</span> <span class="operator">=</span> () -&gt; test.read();        <span class="type">Runnable</span> <span class="variable">writeRun</span> <span class="operator">=</span> () -&gt; test.write(<span class="number">5</span>);        <span class="comment">// 读数据线程</span>        <span class="type">Thread</span> <span class="variable">thread1</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Thread</span>(readRun, <span class="string">&quot;thread1&quot;</span>);        <span class="comment">// 写数据线程</span>        <span class="type">Thread</span> <span class="variable">thread2</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Thread</span>(writeRun, <span class="string">&quot;thread2&quot;</span>);        <span class="comment">// 读数据线程</span>        <span class="type">Thread</span> <span class="variable">thread3</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Thread</span>(readRun, <span class="string">&quot;thread3&quot;</span>);        thread1.start();        thread2.start();        thread3.start();        <span class="keyword">try</span> &#123;            thread1.join();            thread1.join();            thread1.join();        &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;            Thread.currentThread().interrupt();        &#125;    &#125;    <span class="comment">/**</span><span class="comment">     * 读数据</span><span class="comment">     */</span>    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">read</span><span class="params">()</span> &#123;        <span class="type">long</span> <span class="variable">stamp</span> <span class="operator">=</span> lock.tryOptimisticRead();        <span class="keyword">try</span> &#123;            System.out.println(Thread.currentThread().getName() + <span class="string">&quot;开始读数据&quot;</span>);            <span class="comment">// 初次尝试乐观读</span>            <span class="type">int</span> <span class="variable">currentNum</span> <span class="operator">=</span> num;            <span class="comment">// 模拟读取时间延迟</span>            TimeUnit.MILLISECONDS.sleep(<span class="number">300</span>);            <span class="keyword">if</span> (!lock.validate(stamp)) &#123;                <span class="comment">// 乐观读失败，开始悲观读</span>                stamp = lock.readLock();                <span class="keyword">try</span> &#123;                    <span class="comment">// 再次读取内容</span>                    currentNum = num;                &#125; <span class="keyword">finally</span> &#123;                    <span class="comment">// 释放悲观读</span>                    lock.unlockRead(stamp);                &#125;            &#125;            System.out.println(Thread.currentThread().getName() + <span class="string">&quot;读取到的数值：&quot;</span> + currentNum);        &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;            System.out.println(Thread.currentThread().getName() + <span class="string">&quot; 发生异常，异常消息：&quot;</span> + e.getMessage());            <span class="comment">// 终端线程执行</span>            Thread.currentThread().interrupt();        &#125;    &#125;    <span class="comment">/**</span><span class="comment">     * 写数据</span><span class="comment">     * <span class="doctag">@param</span> number</span><span class="comment">     */</span>    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">write</span><span class="params">(<span class="type">int</span> number)</span> &#123;        <span class="type">long</span> <span class="variable">stamp</span> <span class="operator">=</span> lock.writeLock();        <span class="keyword">try</span> &#123;            System.out.println(Thread.currentThread().getName() + <span class="string">&quot;开始写数据&quot;</span>);            num += number;            System.out.println(Thread.currentThread().getName() + <span class="string">&quot;将数据写为：&quot;</span> + num);        &#125; <span class="keyword">finally</span> &#123;            lock.unlockWrite(stamp);        &#125;    &#125;&#125;</code></pre><blockquote><p>运行结果</p></blockquote><pre><code class="highlight shell">thread1开始读数据thread3开始读数据thread2开始写数据thread2将数据写为：15thread3读取到的数值：15thread1读取到的数值：15</code></pre><p>需要注意的点就是，<code>lock.tryOptimisticRead();</code> 获取悲观锁方法并不真正获取锁，而是假设在读操作期间数据不会被修改。使用戳记来验证数据是否在读操作期间被修改，必要时需要升级为悲观读锁来保证数据一致性。</p><h3 id="2-2-使用乐观读锁需要遵循一定的规则："><a href="#2-2-使用乐观读锁需要遵循一定的规则：" class="headerlink" title="2.2 使用乐观读锁需要遵循一定的规则："></a>2.2 使用乐观读锁需要遵循一定的规则：</h3><p>比如 <code>read()</code> 方法中获取 <code>num</code> 的时候需要遵循下面几个步骤：<br>并且一定要按照下面几个步骤顺序处理。</p><ul><li><p><strong>乐观读操作：</strong></p><p>先尝试使用 <code>tryOptimisticRead()</code> 获取乐观读锁。此时不持有实际的读锁，仅仅假设数据在读取期间不会被修改。进行乐观读操作，相当于把共享变量读取到线程的栈内存，这一步很重要需要在验证之前执行。</p></li><li><p><strong>验证和转换：</strong></p><p>使用 <code>validate(stamp)</code> 检查在乐观读期间数据是否被修改。如果数据未被修改，读取的结果就是可靠的。如果数据被修改，需要使用 <code>readLock()</code> 获取悲观读锁，再进行一遍悲观读取操作来确保数据的一致性。</p></li><li><p><strong>释放锁：</strong></p><p>如果获取了悲观读锁，必须在读操作完成后使用 <code>unlockRead(stamp)</code> 释放锁。</p></li></ul><pre><code class="highlight java"><span class="comment">/**</span><span class="comment"> * 读数据</span><span class="comment"> */</span><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">read</span><span class="params">()</span> &#123;    <span class="type">long</span> <span class="variable">stamp</span> <span class="operator">=</span> lock.tryOptimisticRead();    <span class="keyword">try</span> &#123;        System.out.println(Thread.currentThread().getName() + <span class="string">&quot;开始读数据&quot;</span>);        <span class="comment">// 初次尝试乐观读</span>        <span class="type">int</span> <span class="variable">currentNum</span> <span class="operator">=</span> num;        <span class="comment">// 模拟读取时间延迟</span>        TimeUnit.MILLISECONDS.sleep(<span class="number">300</span>);        <span class="keyword">if</span> (!lock.validate(stamp)) &#123;            <span class="comment">// 乐观读失败，开始悲观读</span>            stamp = lock.readLock();            <span class="keyword">try</span> &#123;                <span class="comment">// 再次读取内容</span>                currentNum = num;            &#125; <span class="keyword">finally</span> &#123;                <span class="comment">// 释放悲观读</span>                lock.unlockRead(stamp);            &#125;        &#125;        System.out.println(Thread.currentThread().getName() + <span class="string">&quot;读取到的数值：&quot;</span> + currentNum);    &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;        System.out.println(Thread.currentThread().getName() + <span class="string">&quot; 发生异常，异常消息：&quot;</span> + e.getMessage());        <span class="comment">// 终端线程执行</span>        Thread.currentThread().interrupt();    &#125;&#125;</code></pre><p>使用乐观锁、悲观锁思想也是 <code>StampedLock</code> 提升读取性能的一个方式。因为<code>tryOptimisticRead</code> 和 <code>validate</code> 这两个方法都比悲观读锁的CAS操作要快。</p><h3 id="2-3-validate方法的注意点"><a href="#2-3-validate方法的注意点" class="headerlink" title="2.3 validate方法的注意点"></a>2.3 <code>validate</code>方法的注意点</h3><p>由于乐观读操作对顺序要求很严格，并且乐观读返回的是普通long类型变量，所以为了防止重排序，在validate方法中使用了读屏障（ <code>U.loadFence();</code>） 确保在屏障之前的所有读操作在屏障之后的读操作之前完成。这意味着，<code>U.loadFence(</code>) 保证了在它之前的内存读取操作不会被重新排序到它之后。</p><p><code>StampedLock</code> 中的 <code>state</code> 变量是<code>volatile</code>修饰的，但是<code>validate</code>方法的入参<code>stamp</code>并不能保证是 <code>volatile</code> 变量，所以需要加个读屏障，确保 <code>stamp</code> 和 <code>state</code> 的读取操作不会被重排序，从而保证 <code>stamp</code> 的有效性检查是准确的。如果不使用读屏障，可能会出现 <code>stamp</code> 和 <code>state</code> 的读取操作被重排序的情况，这可能导致 <code>validate</code> 方法返回不正确的结果。</p><pre><code class="highlight java"><span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">validate</span><span class="params">(<span class="type">long</span> stamp)</span> &#123;    U.loadFence();    <span class="keyword">return</span> (stamp &amp; SBITS) == (state &amp; SBITS);&#125;</code></pre><h2 id="3-StampedLock获取释放锁详解"><a href="#3-StampedLock获取释放锁详解" class="headerlink" title="3. StampedLock获取释放锁详解"></a>3. StampedLock获取释放锁详解</h2><h3 id="3-1-类继承结构"><a href="#3-1-类继承结构" class="headerlink" title="3.1 类继承结构"></a>3.1 类继承结构</h3><p><img src="https://raw.githubusercontent.com/GeorgeChan95/blogimg/master/img/2024/10/19/20241019-154603.png" alt="类继承结构"></p><pre><code class="highlight java"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">StampedLock</span> <span class="keyword">implements</span> <span class="title class_">java</span>.io.Serializable</code></pre><h3 id="3-2-类属性"><a href="#3-2-类属性" class="headerlink" title="3.2 类属性"></a>3.2 类属性</h3><pre><code class="highlight java"><span class="comment">/** CPU 核心数，用于自旋控制 */</span><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">int</span> <span class="variable">NCPU</span> <span class="operator">=</span> Runtime.getRuntime().availableProcessors();<span class="comment">/** 尝试获取锁时的最大自旋次数。自旋是指在短时间内反复检查锁状态，而不是立即阻塞线程。 */</span><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">int</span> <span class="variable">SPINS</span> <span class="operator">=</span> (NCPU &gt; <span class="number">1</span>) ? <span class="number">1</span> &lt;&lt; <span class="number">6</span> : <span class="number">0</span>;<span class="comment">/** 尝试获取锁时，最大自旋次数，超出此值后会尝试阻塞在队列的头部。 */</span><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">int</span> <span class="variable">HEAD_SPINS</span> <span class="operator">=</span> (NCPU &gt; <span class="number">1</span>) ? <span class="number">1</span> &lt;&lt; <span class="number">10</span> : <span class="number">0</span>;<span class="comment">/** 自旋时的最大重试次数，超出此值后会重新尝试阻塞。 */</span><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">int</span> <span class="variable">MAX_HEAD_SPINS</span> <span class="operator">=</span> (NCPU &gt; <span class="number">1</span>) ? <span class="number">1</span> &lt;&lt; <span class="number">16</span> : <span class="number">0</span>;<span class="comment">/** 等待溢出自旋锁时的放弃 CPU 使用的周期。这是一个幂次 2 - 1 的值。 */</span><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">int</span> <span class="variable">OVERFLOW_YIELD_RATE</span> <span class="operator">=</span> <span class="number">7</span>; <span class="comment">// 必须是 2 的幂次 - 1</span><span class="comment">/** 用于表示读锁计数的位数，超出此范围会发生溢出。  范围是1~126  */</span><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">int</span> <span class="variable">LG_READERS</span> <span class="operator">=</span> <span class="number">7</span>;<span class="comment">/** 锁状态和印章操作的相关常量值 */</span><span class="comment">// 单位读操作的位掩码</span><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">long</span> <span class="variable">RUNIT</span> <span class="operator">=</span> <span class="number">1L</span>;<span class="comment">// 写操作的位掩码（位移了 LG_READERS 位）</span><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">long</span> <span class="variable">WBIT</span>  <span class="operator">=</span> <span class="number">1L</span> &lt;&lt; LG_READERS;<span class="comment">// 读操作的位掩码范围</span><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">long</span> <span class="variable">RBITS</span> <span class="operator">=</span> WBIT - <span class="number">1L</span>;<span class="comment">// 读操作的满位掩码</span><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">long</span> <span class="variable">RFULL</span> <span class="operator">=</span> RBITS - <span class="number">1L</span>;<span class="comment">// 所有锁的位掩码（包括读和写）</span><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">long</span> <span class="variable">ABITS</span> <span class="operator">=</span> RBITS | WBIT;<span class="comment">// 只有写锁的位掩码 ( ~ 是按位取反操作符)</span><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">long</span> <span class="variable">SBITS</span> <span class="operator">=</span> ~RBITS; <span class="comment">// 注意与 ABITS 的重叠</span><span class="comment">// 锁状态的初始值; 避免零值作为失败值</span><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">long</span> <span class="variable">ORIGIN</span> <span class="operator">=</span> WBIT &lt;&lt; <span class="number">1</span>;<span class="comment">/** 从被取消的获取方法返回的特殊值，用于抛出中断异常。 */</span><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">long</span> <span class="variable">INTERRUPTED</span> <span class="operator">=</span> <span class="number">1L</span>;<span class="comment">/** 节点状态的相关常量值，顺序很重要 */</span><span class="comment">// 等待状态</span><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">int</span> <span class="variable">WAITING</span>   <span class="operator">=</span> -<span class="number">1</span>;<span class="comment">// 取消状态</span><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">int</span> <span class="variable">CANCELLED</span> <span class="operator">=</span>  <span class="number">1</span>;<span class="comment">/** 节点模式; 用整数而不是布尔值，以允许进行算术操作 */</span><span class="comment">// 读模式</span><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">int</span> <span class="variable">RMODE</span> <span class="operator">=</span> <span class="number">0</span>;<span class="comment">// 写模式</span><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">int</span> <span class="variable">WMODE</span> <span class="operator">=</span> <span class="number">1</span>;<span class="comment">/** 等待节点的内部类，用于管理队列中的节点 */</span><span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">class</span> <span class="title class_">WNode</span> &#123;    <span class="keyword">volatile</span> WNode prev;    <span class="comment">// 上一个节点</span>    <span class="keyword">volatile</span> WNode next;    <span class="comment">// 下一个节点</span>    <span class="keyword">volatile</span> WNode cowait;  <span class="comment">// 链接的读线程列表</span>    <span class="keyword">volatile</span> Thread thread; <span class="comment">// 线程对象; 如果非空，则线程可能被挂起</span>    <span class="keyword">volatile</span> <span class="type">int</span> status;    <span class="comment">// 节点状态; 0, WAITING 或 CANCELLED</span>    <span class="keyword">final</span> <span class="type">int</span> mode;         <span class="comment">// 节点模式; RMODE 或 WMODE</span>    WNode(<span class="type">int</span> m, WNode p) &#123; mode = m; prev = p; &#125;&#125;<span class="comment">/** CLH 队列的头部节点 */</span><span class="keyword">private</span> <span class="keyword">transient</span> <span class="keyword">volatile</span> WNode whead;<span class="comment">/** CLH 队列的尾部节点 */</span><span class="keyword">private</span> <span class="keyword">transient</span> <span class="keyword">volatile</span> WNode wtail;<span class="comment">/** 锁视图，用于提供不同类型的锁视图 */</span><span class="keyword">transient</span> ReadLockView readLockView;<span class="keyword">transient</span> WriteLockView writeLockView;<span class="keyword">transient</span> ReadWriteLockView readWriteLockView;<span class="comment">/** 锁的状态*/</span><span class="keyword">private</span> <span class="keyword">transient</span> <span class="keyword">volatile</span> <span class="type">long</span> state;<span class="comment">/** 当状态的读计数饱和时，所使用的额外读锁计数 */</span><span class="keyword">private</span> <span class="keyword">transient</span> <span class="type">int</span> readerOverflow;</code></pre><p>可以看出<code>StampedLock</code>是通过内部类 <code>WNode</code> 来管理队列中的节点(队列属于双向链表结构，利用了CLH锁思想)。并且用了大量的标志位和位运算来处理锁的逻辑。</p><h3 id="3-3-StampedLock对于state变量的设计"><a href="#3-3-StampedLock对于state变量的设计" class="headerlink" title="3.3 StampedLock对于state变量的设计"></a>3.3 StampedLock对于state变量的设计</h3><pre><code class="highlight java"><span class="comment">/** 用于表示读锁计数的位数，超出此范围会发生溢出。  范围是1~126  */</span><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">int</span> <span class="variable">LG_READERS</span> <span class="operator">=</span> <span class="number">7</span>;<span class="comment">// 写操作的位掩码（位移了 LG_READERS 位）</span><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">long</span> <span class="variable">WBIT</span>  <span class="operator">=</span> <span class="number">1L</span> &lt;&lt; LG_READERS;<span class="comment">// 锁状态的初始值; 避免零值作为失败值</span><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">long</span> <span class="variable">ORIGIN</span> <span class="operator">=</span> WBIT &lt;&lt; <span class="number">1</span>;<span class="comment">/** 锁的状态*/</span><span class="keyword">private</span> <span class="keyword">transient</span> <span class="keyword">volatile</span> <span class="type">long</span> state;</code></pre><p>由于只有一个<code>state</code>变量，又需要表示读写锁，所以<code>StampedLock</code>也把state变量拆成了读和写的部分，但是不同于 <code>ReentrantReadWriteLock</code>的int类型的state变量把高16位表示读锁计数，低16位表示写锁计数。</p><p><code>StampedLock</code>中 锁状态的初始值是 <code>ORIGIN</code> 也就是 1&lt;&lt;7,也就是 <code>1000 0000</code>（前面的0省略）用最低的8位表示读和写的状态，其中最低的7位表示读锁的状态(版本)，第8位表示写锁的状态。因为写锁是互斥的且不可重入，用一位就够了。</p><h3 id="3-4-StampedLock乐观锁实现原理"><a href="#3-4-StampedLock乐观锁实现原理" class="headerlink" title="3.4 StampedLock乐观锁实现原理"></a>3.4 StampedLock乐观锁实现原理</h3><p>结合<code>tryOptimisticRead</code>和<code>validate</code>方法分析：</p><pre><code class="highlight java"><span class="keyword">public</span> <span class="type">long</span> <span class="title function_">tryOptimisticRead</span><span class="params">()</span> &#123;    <span class="type">long</span> s;    <span class="keyword">return</span> (((s = state) &amp; WBIT) == <span class="number">0L</span>) ? (s &amp; SBITS) : <span class="number">0L</span>;&#125;</code></pre><pre><code class="highlight java"><span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">validate</span><span class="params">(<span class="type">long</span> stamp)</span> &#123;    U.loadFence();    <span class="keyword">return</span> (stamp &amp; SBITS) == (state &amp; SBITS);&#125;</code></pre><p><code>tryOptimisticRead</code> 方法中 <code>state&amp;WBIT！=0</code>，说明 <code>state</code> 变量表示写锁的第八位为1，也就是有线程持有写锁，那么 <code>tryOptimisticRead</code> 方法就会返回0。表示获取乐观读锁失败。然后我们再调用 <code>validate(0)</code> 一定会得到false，也就是校验失败。这个符合当有线程持有写锁时与其他锁互斥的逻辑。</p><p>为什么<code>validate</code>方法，比较的是<code>(stamp &amp; SBITS) == (state &amp; SBITS);</code>？<br>因为需要支持读读不互斥，即使修改了state的低7位也就是读锁的部分，<code>(stamp &amp; SBITS) == (state &amp; SBITS);</code>依然会返回true。</p><h3 id="3-5-StampedLock的构造方法"><a href="#3-5-StampedLock的构造方法" class="headerlink" title="3.5 StampedLock的构造方法"></a>3.5 StampedLock的构造方法</h3><pre><code class="highlight java"><span class="comment">/** 用于表示读锁状态的位数，超出此范围会发生溢出。  范围是1~126  */</span><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">int</span> <span class="variable">LG_READERS</span> <span class="operator">=</span> <span class="number">7</span>;<span class="comment">/** 写操作的位掩码（位移了 LG_READERS 位） */</span><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">long</span> <span class="variable">WBIT</span>  <span class="operator">=</span> <span class="number">1L</span> &lt;&lt; LG_READERS;<span class="comment">/** 锁状态的初始值; 避免零值作为失败值 */</span><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">long</span> <span class="variable">ORIGIN</span> <span class="operator">=</span> WBIT &lt;&lt; <span class="number">1</span>;<span class="comment">/** 锁的状态*/</span><span class="keyword">private</span> <span class="keyword">transient</span> <span class="keyword">volatile</span> <span class="type">long</span> state;<span class="comment">/**</span><span class="comment"> * 默认构造方法。</span><span class="comment"> * 初始化 `StampedLock` 对象，将锁状态设置为初始值。</span><span class="comment"> */</span><span class="keyword">public</span> <span class="title function_">StampedLock</span><span class="params">()</span> &#123;    <span class="comment">// 初始化锁状态为初始值 ORIGIN，避免状态为零作为失败值。</span>    state = ORIGIN;&#125;</code></pre><h3 id="3-6-tryOptimisticRead方法"><a href="#3-6-tryOptimisticRead方法" class="headerlink" title="3.6 tryOptimisticRead方法"></a>3.6 tryOptimisticRead方法</h3><pre><code class="highlight java"><span class="comment">/** 用于表示读锁状态的位数 */</span><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">int</span> <span class="variable">LG_READERS</span> <span class="operator">=</span> <span class="number">7</span>;<span class="comment">/** 写操作的位掩码（位移了 LG_READERS 位） */</span><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">long</span> <span class="variable">WBIT</span>  <span class="operator">=</span> <span class="number">1L</span> &lt;&lt; LG_READERS;<span class="comment">/** 只有写锁的位掩码 */</span><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">long</span> <span class="variable">SBITS</span> <span class="operator">=</span> ~RBITS;<span class="comment">/** 读操作的位掩码范围 */</span><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">long</span> <span class="variable">RBITS</span> <span class="operator">=</span> WBIT - <span class="number">1L</span>;<span class="comment">/**</span><span class="comment"> * 尝试以乐观读模式获取锁。</span><span class="comment"> * </span><span class="comment"> * 这个方法检查当前锁状态以确定是否可以进行乐观读操作。</span><span class="comment"> * 如果没有写锁持有者（即锁的写位没有被设置），方法返回当前的读者计数（即锁的状态）。</span><span class="comment"> * 否则，返回 0 表示无法进行乐观读操作。</span><span class="comment"> * </span><span class="comment"> * <span class="doctag">@return</span> 如果可以进行乐观读，则返回当前的读者计数；否则返回 0。</span><span class="comment"> */</span><span class="keyword">public</span> <span class="type">long</span> <span class="title function_">tryOptimisticRead</span><span class="params">()</span> &#123;    <span class="type">long</span> s;    <span class="comment">// 读取当前锁状态</span>    s = state;    <span class="comment">// 检查写锁位是否被设置。如果没有写锁持有者（写位为 0），则返回当前读者计数（即去除写锁位后的状态值）。</span>    <span class="keyword">return</span> (((s &amp; WBIT) == <span class="number">0L</span>) ? (s &amp; SBITS) : <span class="number">0L</span>);&#125;</code></pre><p>这个方法允许线程在没有写锁持有者的情况下进行乐观读操作，这可以提高并发性能，因为乐观读操作不需要获取实际的读锁。</p><h3 id="3-7-readLock-方法"><a href="#3-7-readLock-方法" class="headerlink" title="3.7 readLock 方法"></a>3.7 readLock 方法</h3><pre><code class="highlight java"><span class="comment">/**</span><span class="comment"> * 尝试获取读锁。</span><span class="comment"> * </span><span class="comment"> * 在常见的无竞争情况下，这个方法会直接返回一个读锁的印章。</span><span class="comment"> * 如果当前队列为空（即 `whead` 等于 `wtail`），并且没有写锁持有者（即当前状态的读位小于 RFULL），</span><span class="comment"> * 则通过 CAS 操作将状态值加上 `RUNIT` 以尝试获取读锁。</span><span class="comment"> * 否则，调用 `acquireRead` 方法来实际获取读锁。</span><span class="comment"> * </span><span class="comment"> * <span class="doctag">@return</span> 成功获取读锁时的印章值。如果无法获取，则调用 `acquireRead` 方法来处理。</span><span class="comment"> */</span><span class="keyword">public</span> <span class="type">long</span> <span class="title function_">readLock</span><span class="params">()</span> &#123;    <span class="type">long</span> <span class="variable">s</span> <span class="operator">=</span> state, next;  <span class="comment">// 读取当前锁状态，并为下一个状态准备变量</span>    <span class="comment">// 如果当前队列为空且状态值允许新的读操作，则尝试通过 CAS 操作增加读锁计数</span>    <span class="keyword">return</span> ((whead == wtail &amp;&amp; (s &amp; ABITS) &lt; RFULL &amp;&amp;             U.compareAndSwapLong(<span class="built_in">this</span>, STATE, s, next = s + RUNIT)) ?            next : acquireRead(<span class="literal">false</span>, <span class="number">0L</span>));  <span class="comment">// 否则调用 acquireRead 方法来获取读锁</span>&#125;</code></pre><p><strong><code>readLock</code> 方法总结：</strong></p><ul><li><p><strong>目标：</strong> 尝试在无竞争情况下快速获取读锁。如果直接获取失败，则调用 <code>acquireRead</code> 处理复杂情况。</p></li><li><p><strong>具体步骤：</strong></p><ul><li><p><strong>检查队列状态：</strong></p><p>如果队列为空（whead &#x3D;&#x3D; wtail）且状态允许增加读锁计数（(s &amp; ABITS) &lt; RFULL），即没有达到读锁计数上限：尝试通过 CAS 操作将 state 增加 RUNIT，即增加读锁计数。如果 CAS 操作成功，返回新的状态 next。</p></li><li><p><strong>调用 acquireRead：</strong></p><p>如果队列不为空，或者 CAS 操作失败，则调用 acquireRead 方法来处理更复杂的情况，实际获取读锁。</p></li></ul></li></ul><h3 id="3-8-acquireRead方法"><a href="#3-8-acquireRead方法" class="headerlink" title="3.8 acquireRead方法"></a>3.8 acquireRead方法</h3><pre><code class="highlight java"><span class="comment">/**</span><span class="comment"> * 实际获取读锁的方法。</span><span class="comment"> * </span><span class="comment"> * 这个方法会尝试获取读锁。如果直接获取失败，它会通过自旋、队列管理和线程等待来确保获取读锁。</span><span class="comment"> * </span><span class="comment"> * <span class="doctag">@param</span> interruptible 是否可中断。</span><span class="comment"> * <span class="doctag">@param</span> deadline 线程等待的截止时间（纳秒）。</span><span class="comment"> * <span class="doctag">@return</span> 成功获取读锁时的印章值。如果超时或中断，则可能会取消等待。</span><span class="comment"> */</span><span class="keyword">private</span> <span class="type">long</span> <span class="title function_">acquireRead</span><span class="params">(<span class="type">boolean</span> interruptible, <span class="type">long</span> deadline)</span> &#123;    <span class="type">WNode</span> <span class="variable">node</span> <span class="operator">=</span> <span class="literal">null</span>, p;    <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">spins</span> <span class="operator">=</span> -<span class="number">1</span>;;) &#123;        WNode h;        <span class="keyword">if</span> ((h = whead) == (p = wtail)) &#123;  <span class="comment">// 检查队列是否为空</span>            <span class="keyword">for</span> (<span class="type">long</span> m, s, ns;;) &#123;                <span class="comment">// 检查当前状态是否允许增加读锁计数</span>                <span class="keyword">if</span> ((m = (s = state) &amp; ABITS) &lt; RFULL ?                    U.compareAndSwapLong(<span class="built_in">this</span>, STATE, s, ns = s + RUNIT) :                    (m &lt; WBIT &amp;&amp; (ns = tryIncReaderOverflow(s)) != <span class="number">0L</span>))                    <span class="keyword">return</span> ns;  <span class="comment">// 成功获取读锁</span>                <span class="keyword">else</span> <span class="keyword">if</span> (m &gt;= WBIT) &#123;                    <span class="keyword">if</span> (spins &gt; <span class="number">0</span>) &#123;                        <span class="keyword">if</span> (LockSupport.nextSecondarySeed() &gt;= <span class="number">0</span>)                            --spins;                    &#125;                    <span class="keyword">else</span> &#123;                        <span class="keyword">if</span> (spins == <span class="number">0</span>) &#123;                            <span class="type">WNode</span> <span class="variable">nh</span> <span class="operator">=</span> whead, np = wtail;                            <span class="keyword">if</span> ((nh == h &amp;&amp; np == p) || (h = nh) != (p = np))                                <span class="keyword">break</span>;                        &#125;                        spins = SPINS;  <span class="comment">// 重置自旋次数</span>                    &#125;                &#125;            &#125;        &#125;        <span class="keyword">if</span> (p == <span class="literal">null</span>) &#123; <span class="comment">// 如果队列为空，初始化队列</span>            <span class="type">WNode</span> <span class="variable">hd</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">WNode</span>(WMODE, <span class="literal">null</span>);            <span class="keyword">if</span> (U.compareAndSwapObject(<span class="built_in">this</span>, WHEAD, <span class="literal">null</span>, hd))                wtail = hd;        &#125;        <span class="keyword">else</span> <span class="keyword">if</span> (node == <span class="literal">null</span>)            node = <span class="keyword">new</span> <span class="title class_">WNode</span>(RMODE, p);  <span class="comment">// 创建新的读节点</span>        <span class="keyword">else</span> <span class="keyword">if</span> (h == p || p.mode != RMODE) &#123;  <span class="comment">// 如果队列中的前驱节点不是读节点，尝试加入队列</span>            <span class="keyword">if</span> (node.prev != p)                node.prev = p;            <span class="keyword">else</span> <span class="keyword">if</span> (U.compareAndSwapObject(<span class="built_in">this</span>, WTAIL, p, node)) &#123;                p.next = node;                <span class="keyword">break</span>;            &#125;        &#125;        <span class="keyword">else</span> <span class="keyword">if</span> (!U.compareAndSwapObject(p, WCOWAIT,                                         node.cowait = p.cowait, node))            node.cowait = <span class="literal">null</span>;  <span class="comment">// 更新前驱节点的等待列表</span>        <span class="keyword">else</span> &#123;            <span class="keyword">for</span> (;;) &#123;                WNode pp, c; Thread w;                <span class="keyword">if</span> ((h = whead) != <span class="literal">null</span> &amp;&amp; (c = h.cowait) != <span class="literal">null</span> &amp;&amp;                    U.compareAndSwapObject(h, WCOWAIT, c, c.cowait) &amp;&amp;                    (w = c.thread) != <span class="literal">null</span>) <span class="comment">// 唤醒等待线程</span>                    U.unpark(w);                <span class="keyword">if</span> (h == (pp = p.prev) || h == p || pp == <span class="literal">null</span>) &#123;                    <span class="type">long</span> m, s, ns;                    <span class="keyword">do</span> &#123;                        <span class="comment">// 检查状态是否允许增加读锁计数</span>                        <span class="keyword">if</span> ((m = (s = state) &amp; ABITS) &lt; RFULL ?                            U.compareAndSwapLong(<span class="built_in">this</span>, STATE, s,                                                 ns = s + RUNIT) :                            (m &lt; WBIT &amp;&amp;                             (ns = tryIncReaderOverflow(s)) != <span class="number">0L</span>))                            <span class="keyword">return</span> ns;  <span class="comment">// 成功获取读锁</span>                    &#125; <span class="keyword">while</span> (m &lt; WBIT);                &#125;                <span class="keyword">if</span> (whead == h &amp;&amp; p.prev == pp) &#123;                    <span class="type">long</span> time;                    <span class="keyword">if</span> (pp == <span class="literal">null</span> || h == p || p.status &gt; <span class="number">0</span>) &#123;                        node = <span class="literal">null</span>; <span class="comment">// 丢弃节点</span>                        <span class="keyword">break</span>;                    &#125;                    <span class="keyword">if</span> (deadline == <span class="number">0L</span>)                        time = <span class="number">0L</span>;                    <span class="keyword">else</span> <span class="keyword">if</span> ((time = deadline - System.nanoTime()) &lt;= <span class="number">0L</span>)                        <span class="keyword">return</span> cancelWaiter(node, p, <span class="literal">false</span>);  <span class="comment">// 超时取消等待</span>                    <span class="type">Thread</span> <span class="variable">wt</span> <span class="operator">=</span> Thread.currentThread();                    U.putObject(wt, PARKBLOCKER, <span class="built_in">this</span>);                    node.thread = wt;                    <span class="keyword">if</span> ((h != pp || (state &amp; ABITS) == WBIT) &amp;&amp;                        whead == h &amp;&amp; p.prev == pp)                        U.park(<span class="literal">false</span>, time);  <span class="comment">// 线程等待</span>                    node.thread = <span class="literal">null</span>;                    U.putObject(wt, PARKBLOCKER, <span class="literal">null</span>);                    <span class="keyword">if</span> (interruptible &amp;&amp; Thread.interrupted())                        <span class="keyword">return</span> cancelWaiter(node, p, <span class="literal">true</span>);  <span class="comment">// 处理中断</span>                &#125;            &#125;        &#125;    &#125;    <span class="comment">// 在队列头部自旋等待</span>    <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">spins</span> <span class="operator">=</span> -<span class="number">1</span>;;) &#123;        WNode h, np, pp; <span class="type">int</span> ps;        <span class="keyword">if</span> ((h = whead) == p) &#123;            <span class="keyword">if</span> (spins &lt; <span class="number">0</span>)                spins = HEAD_SPINS;  <span class="comment">// 初始化自旋次数</span>            <span class="keyword">else</span> <span class="keyword">if</span> (spins &lt; MAX_HEAD_SPINS)                spins &lt;&lt;= <span class="number">1</span>;  <span class="comment">// 增加自旋次数</span>            <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">k</span> <span class="operator">=</span> spins;;) &#123; <span class="comment">// 在队列头部自旋</span>                <span class="type">long</span> m, s, ns;                <span class="keyword">if</span> ((m = (s = state) &amp; ABITS) &lt; RFULL ?                    U.compareAndSwapLong(<span class="built_in">this</span>, STATE, s, ns = s + RUNIT) :                    (m &lt; WBIT &amp;&amp; (ns = tryIncReaderOverflow(s)) != <span class="number">0L</span>)) &#123;                    WNode c; Thread w;                    whead = node;  <span class="comment">// 更新队列头部</span>                    node.prev = <span class="literal">null</span>;                    <span class="keyword">while</span> ((c = node.cowait) != <span class="literal">null</span>) &#123;                        <span class="keyword">if</span> (U.compareAndSwapObject(node, WCOWAIT,                                                   c, c.cowait) &amp;&amp;                            (w = c.thread) != <span class="literal">null</span>)                            U.unpark(w);  <span class="comment">// 唤醒等待线程</span>                    &#125;                    <span class="keyword">return</span> ns;  <span class="comment">// 成功获取读锁</span>                &#125;                <span class="keyword">else</span> <span class="keyword">if</span> (m &gt;= WBIT &amp;&amp;                         LockSupport.nextSecondarySeed() &gt;= <span class="number">0</span> &amp;&amp; --k &lt;= <span class="number">0</span>)                    <span class="keyword">break</span>;  <span class="comment">// 超过自旋次数，退出自旋</span>            &#125;        &#125;        <span class="keyword">else</span> <span class="keyword">if</span> (h != <span class="literal">null</span>) &#123;            WNode c; Thread w;            <span class="keyword">while</span> ((c = h.cowait) != <span class="literal">null</span>) &#123;                <span class="keyword">if</span> (U.compareAndSwapObject(h, WCOWAIT, c, c.cowait) &amp;&amp;                    (w = c.thread) != <span class="literal">null</span>)                    U.unpark(w);  <span class="comment">// 唤醒等待线程</span>            &#125;        &#125;        <span class="keyword">if</span> (whead == h) &#123;            <span class="keyword">if</span> ((np = node.prev) != p) &#123;                <span class="keyword">if</span> (np != <span class="literal">null</span>)                    (p = np).next = node;   <span class="comment">// 更新前驱节点的 next 指针</span>            &#125;            <span class="keyword">else</span> <span class="keyword">if</span> ((ps = p.status) == <span class="number">0</span>)                U.compareAndSwapInt(p, WSTATUS, <span class="number">0</span>, WAITING);  <span class="comment">// 设置节点状态为等待</span>            <span class="keyword">else</span> <span class="keyword">if</span> (ps == CANCELLED) &#123;                <span class="keyword">if</span> ((pp = p.prev) != <span class="literal">null</span>) &#123;                    node.prev = pp;                    pp.next = node;  <span class="comment">// 更新前驱节点的 next 指针</span>                &#125;            &#125;            <span class="keyword">else</span> &#123;                <span class="type">long</span> time;                <span class="keyword">if</span> (deadline == <span class="number">0L</span>)                    time = <span class="number">0L</span>;                <span class="keyword">else</span> <span class="keyword">if</span> ((time = deadline - System.nanoTime()) &lt;= <span class="number">0L</span>)                    <span class="keyword">return</span> cancelWaiter(node, node, <span class="literal">false</span>);  <span class="comment">// 超时取消等待</span>                <span class="type">Thread</span> <span class="variable">wt</span> <span class="operator">=</span> Thread.currentThread();                U.putObject(wt, PARKBLOCKER, <span class="built_in">this</span>);                node.thread = wt;                <span class="keyword">if</span> (p.status &lt; <span class="number">0</span> &amp;&amp;                    (p != h || (state &amp; ABITS) == WBIT) &amp;&amp;                    whead == h &amp;&amp; node.prev == p)                    U.park(<span class="literal">false</span>, time);  <span class="comment">// 线程等待</span>                node.thread = <span class="literal">null</span>;                U.putObject(wt, PARKBLOCKER, <span class="literal">null</span>);                <span class="keyword">if</span> (interruptible &amp;&amp;</code></pre><p><strong>acquireRead 方法总结：</strong></p><ul><li><p><strong>目标：</strong> 在有竞争的情况下获取读锁，包括处理线程等待、队列管理、自旋等。</p></li><li><p><strong>acquireRead 的详细步骤：</strong></p><ul><li><p><strong>检查队列状态</strong></p><p>如果队列为空（whead &#x3D;&#x3D; wtail），尝试直接增加读锁计数（state）。如果成功，返回新的状态 ns。否则，进行自旋尝试。</p></li><li><p><strong>创建或管理节点</strong></p><p>如果队列为空，初始化一个新的头节点。如果节点 node 为空，则创建一个新的读节点。尝试将新的读节点添加到队列中，处理节点前驱和队列管理。</p></li><li><p><strong>处理自旋等待</strong></p><p>如果直接获取读锁失败，通过自旋等待的方式尝试获取读锁。</p></li><li><p><strong>处理线程等待</strong></p><p>如果自旋仍然失败，将线程放入等待队列中，处理中断和超时。</p></li><li><p><strong>唤醒等待线程</strong></p><p>当读锁被成功获取后，唤醒等待的线程。</p></li></ul></li></ul><h3 id="3-9-unlockRead方法"><a href="#3-9-unlockRead方法" class="headerlink" title="3.9 unlockRead方法"></a>3.9 unlockRead方法</h3><pre><code class="highlight java"><span class="comment">/**</span><span class="comment"> * 解锁读锁。</span><span class="comment"> * </span><span class="comment"> * 这个方法会验证提供的印章（`stamp`）是否与当前锁状态一致。如果印章无效或锁状态不匹配，会抛出 `IllegalMonitorStateException`。</span><span class="comment"> * 如果锁的读计数低于 `RFULL`，尝试通过 CAS 操作减少读计数。如果读计数减少到 0，则释放队列中可能被阻塞的线程。</span><span class="comment"> * 如果读计数达到了 `RFULL`，则调用 `tryDecReaderOverflow` 方法来处理溢出读线程计数。</span><span class="comment"> * </span><span class="comment"> * <span class="doctag">@param</span> stamp 读锁的印章值。</span><span class="comment"> * <span class="doctag">@throws</span> IllegalMonitorStateException 如果印章无效或状态不匹配。</span><span class="comment"> */</span><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">unlockRead</span><span class="params">(<span class="type">long</span> stamp)</span> &#123;    <span class="type">long</span> s, m; WNode h;    <span class="keyword">for</span> (;;) &#123;  <span class="comment">// 自旋</span>        <span class="comment">// 获取当前锁状态</span>        s = state;        <span class="comment">// 检查印章是否与当前状态匹配，或者印章是否有效</span>        <span class="keyword">if</span> (((s &amp; SBITS) != (stamp &amp; SBITS)) ||            (stamp &amp; ABITS) == <span class="number">0L</span> || (m = s &amp; ABITS) == <span class="number">0L</span> || m == WBIT)            <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">IllegalMonitorStateException</span>();  <span class="comment">// 印章无效，抛出异常</span>        <span class="keyword">if</span> (m &lt; RFULL) &#123;            <span class="comment">// 如果读计数小于 RFULL，尝试减少读计数</span>            <span class="keyword">if</span> (U.compareAndSwapLong(<span class="built_in">this</span>, STATE, s, s - RUNIT)) &#123;                <span class="comment">// 如果减少后读计数为 RUNIT 且队列头部节点状态不为 0，释放队列中的线程</span>                <span class="keyword">if</span> (m == RUNIT &amp;&amp; (h = whead) != <span class="literal">null</span> &amp;&amp; h.status != <span class="number">0</span>)                    release(h);                <span class="keyword">break</span>;            &#125;        &#125;        <span class="keyword">else</span> <span class="keyword">if</span> (tryDecReaderOverflow(s) != <span class="number">0L</span>)            <span class="keyword">break</span>;  <span class="comment">// 处理溢出的读者计数</span>    &#125;&#125;</code></pre><p><strong><code>unlockRead</code> 方法总结：</strong></p><ul><li><p><code>目标：</code>释放读锁，验证印章的有效性，并根据读锁计数的状态更新锁状态。</p></li><li><p><strong>步骤：</strong></p><ul><li><p>自旋检查印章有效性</p><p>进入自旋循环，获取当前锁状态 s。<br>检查传入的印章 stamp 是否与当前状态一致（通过比较 SBITS），以及印章是否有效（(stamp &amp; ABITS) &#x3D;&#x3D; 0L），或者当前状态是否无效（m &#x3D;&#x3D; WBIT）。<br>如果印章无效，抛出 IllegalMonitorStateException。</p></li><li><p>处理读计数</p><p>如果读计数小于 RFULL：<br>尝试通过 CAS 操作将状态 s 减少 RUNIT，即减少读锁计数。<br>如果读计数减少后为 RUNIT，并且队列头部节点状态不为 0，调用 release(h) 释放队列中的线程。<br>跳出循环，完成解锁。</p><p>如果读计数达到 RFULL：<br>调用 tryDecReaderOverflow 方法处理读计数溢出情况。</p></li><li><p>处理读计数溢出</p><p><code>tryDecReaderOverflow</code> 方法用于减少在 RFULL 状态下的溢出读线程计数。</p></li></ul></li></ul><h3 id="3-10-tryDecReaderOverflow方法"><a href="#3-10-tryDecReaderOverflow方法" class="headerlink" title="3.10 tryDecReaderOverflow方法"></a>3.10 tryDecReaderOverflow方法</h3><pre><code class="highlight java"><span class="comment">/**</span><span class="comment"> * 尝试减少溢出的读计数。</span><span class="comment"> * </span><span class="comment"> * 这个方法会处理在读锁计数达到 `RFULL` 后的溢出情况。如果当前状态的读计数已经达到 `RFULL`，</span><span class="comment"> * 通过 CAS 操作将状态更新为包含读位的值，并减少 `readerOverflow` 计数器。</span><span class="comment"> * 如果 `readerOverflow` 计数器为 0，则直接减少读计数。</span><span class="comment"> * </span><span class="comment"> * <span class="doctag">@param</span> s 当前锁状态。</span><span class="comment"> * <span class="doctag">@return</span> 更新后的状态值。如果无法减少读者计数，则返回 0L。</span><span class="comment"> */</span><span class="keyword">private</span> <span class="type">long</span> <span class="title function_">tryDecReaderOverflow</span><span class="params">(<span class="type">long</span> s)</span> &#123;    <span class="comment">// 确保当前状态的读位计数达到了 RFULL</span>    <span class="keyword">if</span> ((s &amp; ABITS) == RFULL) &#123;        <span class="comment">// 通过 CAS 操作将状态值更新为包含读位的状态</span>        <span class="keyword">if</span> (U.compareAndSwapLong(<span class="built_in">this</span>, STATE, s, s | RBITS)) &#123;            <span class="type">int</span> r; <span class="type">long</span> next;            <span class="keyword">if</span> ((r = readerOverflow) &gt; <span class="number">0</span>) &#123;                <span class="comment">// 如果溢出计数器大于 0，减少计数器并保持状态</span>                readerOverflow = r - <span class="number">1</span>;                next = s;            &#125;            <span class="keyword">else</span>                <span class="comment">// 否则，减少读锁计数</span>                next = s - RUNIT;            state = next;  <span class="comment">// 更新锁状态</span>            <span class="keyword">return</span> next;  <span class="comment">// 返回更新后的状态值</span>        &#125;    &#125;    <span class="keyword">else</span> <span class="keyword">if</span> ((LockSupport.nextSecondarySeed() &amp; OVERFLOW_YIELD_RATE) == <span class="number">0</span>)        Thread.<span class="keyword">yield</span>();  <span class="comment">// 在不能处理溢出时，让线程让步</span>    <span class="keyword">return</span> <span class="number">0L</span>;  <span class="comment">// 无法减少读者计数时返回 0L</span>&#125;</code></pre><p><strong>tryDecReaderOverflow方法总结：</strong></p><ul><li><p>目标： 处理在读锁计数达到上限时的溢出情况，确保锁状态的正确性。</p></li><li><p>步骤：</p><ul><li><p>检查读计数是否达到 RFULL：如果当前状态的读位计数等于 RFULL，则尝试更新状态以处理溢出情况。</p></li><li><p>更新状态：</p><p>通过 CAS 操作将状态更新为包含读位的状态<code>（s | RBITS）</code>。<br>如果 readerOverflow 计数器大于 0，减少计数器并保持状态。<br>如果 readerOverflow 为 0，减少读锁计数。<br>更新 state 变量，并返回更新后的状态值。</p></li><li><p>处理无法减少计数的情况：</p><p>如果无法处理溢出情况，让线程让步（Thread.yield()），并返回 0L。</p></li></ul></li></ul><h3 id="3-11-writeLock-方法"><a href="#3-11-writeLock-方法" class="headerlink" title="3.11 writeLock 方法"></a>3.11 writeLock 方法</h3><pre><code class="highlight java"><span class="comment">/**</span><span class="comment"> * 尝试获取写锁。</span><span class="comment"> * </span><span class="comment"> * 这个方法首先检查当前锁状态，如果当前没有读锁或写锁（`ABITS` 中没有任何标志位），</span><span class="comment"> * 直接通过 CAS 操作将状态更新为加上写锁位 `WBIT` 的新状态。如果更新成功，返回新的状态值。</span><span class="comment"> * 如果锁已被其他线程持有，或者队列中存在等待写锁的线程，则调用 `acquireWrite` 方法，</span><span class="comment"> * 通过排队的方式来获取写锁。</span><span class="comment"> * </span><span class="comment"> * <span class="doctag">@return</span> 成功获取的写锁印章。</span><span class="comment"> */</span><span class="keyword">public</span> <span class="type">long</span> <span class="title function_">writeLock</span><span class="params">()</span> &#123;    <span class="type">long</span> s, next;  <span class="comment">// 当前锁状态和新的状态</span>    <span class="comment">// 检查当前锁状态是否为完全解锁状态</span>    <span class="keyword">return</span> ((((s = state) &amp; ABITS) == <span class="number">0L</span> &amp;&amp;             U.compareAndSwapLong(<span class="built_in">this</span>, STATE, s, next = s + WBIT)) ?            next : acquireWrite(<span class="literal">false</span>, <span class="number">0L</span>));&#125;</code></pre><p><strong>writeLock 方法总结：</strong></p><ul><li><p>目标： writeLock 方法尝试直接获取写锁，如果失败则调用 acquireWrite 方法通过排队的方式获取写锁。</p></li><li><p>步骤：</p><ul><li><p>检查当前锁状态：</p><p>获取当前锁状态 s。<br>如果当前状态没有任何读锁或写锁（即 ABITS 中没有任何标志位），尝试通过 CAS 操作将状态更新为加上写锁位 WBIT 的新状态 next。</p></li><li><p>更新锁状态：</p><p>如果 CAS 操作成功，则返回新的状态值 next。</p></li><li><p>调用 acquireWrite：</p><p>如果状态更新失败（锁已被其他线程持有或队列中存在等待写锁的线程），调用 acquireWrite 方法来通过排队的方式获取写锁。</p></li></ul></li></ul><h3 id="3-12-acquireWrite方法"><a href="#3-12-acquireWrite方法" class="headerlink" title="3.12 acquireWrite方法"></a>3.12 acquireWrite方法</h3><pre><code class="highlight java"><span class="comment">/**</span><span class="comment"> * 尝试获取写锁。</span><span class="comment"> * </span><span class="comment"> * 这个方法通过自旋和排队的方式获取写锁。如果直接获取写锁失败，则将当前线程排入等待队列，</span><span class="comment"> * 并在队列中等待直到能够获取写锁。</span><span class="comment"> * </span><span class="comment"> * <span class="doctag">@param</span> interruptible 是否可中断。</span><span class="comment"> * <span class="doctag">@param</span> deadline 等待的最大时间（以纳秒为单位），0 表示不超时。</span><span class="comment"> * <span class="doctag">@return</span> 成功获取的写锁印章。</span><span class="comment"> */</span><span class="keyword">private</span> <span class="type">long</span> <span class="title function_">acquireWrite</span><span class="params">(<span class="type">boolean</span> interruptible, <span class="type">long</span> deadline)</span> &#123;    <span class="type">WNode</span> <span class="variable">node</span> <span class="operator">=</span> <span class="literal">null</span>, p;    <span class="comment">// 自旋尝试将当前线程排入等待队列</span>    <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">spins</span> <span class="operator">=</span> -<span class="number">1</span>;;) &#123; <span class="comment">// 自旋，直到将节点加入队列</span>        <span class="type">long</span> m, s, ns;        <span class="comment">// 获取当前锁状态</span>        <span class="keyword">if</span> ((m = (s = state) &amp; ABITS) == <span class="number">0L</span>) &#123;            <span class="comment">// 如果当前没有读锁或写锁，通过 CAS 操作将状态更新为加上写锁位 WBIT</span>            <span class="keyword">if</span> (U.compareAndSwapLong(<span class="built_in">this</span>, STATE, s, ns = s + WBIT))                <span class="keyword">return</span> ns;  <span class="comment">// 返回更新后的状态值</span>        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (spins &lt; <span class="number">0</span>)            <span class="comment">// 如果当前状态为写锁且队列为空，设置自旋次数</span>            spins = (m == WBIT &amp;&amp; wtail == whead) ? SPINS : <span class="number">0</span>;        <span class="keyword">else</span> <span class="keyword">if</span> (spins &gt; <span class="number">0</span>) &#123;            <span class="comment">// 自旋，减少自旋次数</span>            <span class="keyword">if</span> (LockSupport.nextSecondarySeed() &gt;= <span class="number">0</span>)                --spins;        &#125; <span class="keyword">else</span> <span class="keyword">if</span> ((p = wtail) == <span class="literal">null</span>) &#123; <span class="comment">// 初始化队列</span>            <span class="type">WNode</span> <span class="variable">hd</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">WNode</span>(WMODE, <span class="literal">null</span>);            <span class="keyword">if</span> (U.compareAndSwapObject(<span class="built_in">this</span>, WHEAD, <span class="literal">null</span>, hd))                wtail = hd;        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (node == <span class="literal">null</span>)            <span class="comment">// 创建新的等待节点</span>            node = <span class="keyword">new</span> <span class="title class_">WNode</span>(WMODE, p);        <span class="keyword">else</span> <span class="keyword">if</span> (node.prev != p)            <span class="comment">// 确保节点的前驱节点正确</span>            node.prev = p;        <span class="keyword">else</span> <span class="keyword">if</span> (U.compareAndSwapObject(<span class="built_in">this</span>, WTAIL, p, node)) &#123;            <span class="comment">// 将当前节点加入队列</span>            p.next = node;            <span class="keyword">break</span>;  <span class="comment">// 成功将节点加入队列，退出自旋循环</span>        &#125;    &#125;    <span class="comment">// 自旋等待，直到获取写锁</span>    <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">spins</span> <span class="operator">=</span> -<span class="number">1</span>;;) &#123;        WNode h, np, pp;        <span class="type">int</span> ps;        <span class="comment">// 检查当前队列头节点</span>        <span class="keyword">if</span> ((h = whead) == p) &#123;            <span class="comment">// 如果当前节点是队列头节点，自旋等待写锁</span>            <span class="keyword">if</span> (spins &lt; <span class="number">0</span>)                spins = HEAD_SPINS;            <span class="keyword">else</span> <span class="keyword">if</span> (spins &lt; MAX_HEAD_SPINS)                spins &lt;&lt;= <span class="number">1</span>;            <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">k</span> <span class="operator">=</span> spins;;) &#123;                <span class="type">long</span> s, ns;                <span class="comment">// 获取当前锁状态</span>                <span class="keyword">if</span> (((s = state) &amp; ABITS) == <span class="number">0L</span>) &#123;                    <span class="comment">// 如果当前没有读锁或写锁，通过 CAS 操作更新状态</span>                    <span class="keyword">if</span> (U.compareAndSwapLong(<span class="built_in">this</span>, STATE, s, ns = s + WBIT)) &#123;                        <span class="comment">// 更新队列头部为当前节点</span>                        whead = node;                        node.prev = <span class="literal">null</span>;                        <span class="keyword">return</span> ns;  <span class="comment">// 返回新的状态值</span>                    &#125;                &#125; <span class="keyword">else</span> <span class="keyword">if</span> (LockSupport.nextSecondarySeed() &gt;= <span class="number">0</span> &amp;&amp;                         --k &lt;= <span class="number">0</span>)                    <span class="keyword">break</span>;  <span class="comment">// 超过自旋次数，退出循环</span>            &#125;        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (h != <span class="literal">null</span>) &#123; <span class="comment">// 帮助释放过时的等待节点</span>            WNode c;            Thread w;            <span class="keyword">while</span> ((c = h.cowait) != <span class="literal">null</span>) &#123;                <span class="keyword">if</span> (U.compareAndSwapObject(h, WCOWAIT, c, c.cowait) &amp;&amp;                    (w = c.thread) != <span class="literal">null</span>)                    U.unpark(w);            &#125;        &#125;        <span class="keyword">if</span> (whead == h) &#123;            <span class="keyword">if</span> ((np = node.prev) != p) &#123;                <span class="comment">// 更新链表，将当前节点插入到正确的位置</span>                <span class="keyword">if</span> (np != <span class="literal">null</span>)                    (p = np).next = node;   <span class="comment">// 处理过时的节点</span>            &#125; <span class="keyword">else</span> <span class="keyword">if</span> ((ps = p.status) == <span class="number">0</span>)                <span class="comment">// 如果节点状态为 0，设置为 WAITING</span>                U.compareAndSwapInt(p, WSTATUS, <span class="number">0</span>, WAITING);            <span class="keyword">else</span> <span class="keyword">if</span> (ps == CANCELLED) &#123;                <span class="comment">// 如果节点状态为 CANCELLED，处理取消的节点</span>                <span class="keyword">if</span> ((pp = p.prev) != <span class="literal">null</span>) &#123;                    node.prev = pp;                    pp.next = node;                &#125;            &#125; <span class="keyword">else</span> &#123;                <span class="comment">// 等待获取写锁</span>                <span class="type">long</span> time; <span class="comment">// 0 参数表示无超时</span>                <span class="keyword">if</span> (deadline == <span class="number">0L</span>)                    time = <span class="number">0L</span>;                <span class="keyword">else</span> <span class="keyword">if</span> ((time = deadline - System.nanoTime()) &lt;= <span class="number">0L</span>)                    <span class="comment">// 超过等待时间，取消等待</span>                    <span class="keyword">return</span> cancelWaiter(node, node, <span class="literal">false</span>);                <span class="type">Thread</span> <span class="variable">wt</span> <span class="operator">=</span> Thread.currentThread();                U.putObject(wt, PARKBLOCKER, <span class="built_in">this</span>);                node.thread = wt;                <span class="keyword">if</span> (p.status &lt; <span class="number">0</span> &amp;&amp; (p != h || (state &amp; ABITS) != <span class="number">0L</span>) &amp;&amp;                    whead == h &amp;&amp; node.prev == p)                    <span class="comment">// 如果条件满足，则使当前线程进入等待状态</span>                    U.park(<span class="literal">false</span>, time);  <span class="comment">// 模拟 LockSupport.park</span>                node.thread = <span class="literal">null</span>;                U.putObject(wt, PARKBLOCKER, <span class="literal">null</span>);                <span class="keyword">if</span> (interruptible &amp;&amp; Thread.interrupted())                    <span class="comment">// 如果线程被中断，取消等待</span>                    <span class="keyword">return</span> cancelWaiter(node, node, <span class="literal">true</span>);            &#125;        &#125;    &#125;&#125;</code></pre><p><strong>acquireWrite 方法总结：</strong></p><ul><li><p>目标： 负责处理排队、等待和自旋等复杂逻辑，确保在竞争条件下正确地获取写锁。</p></li><li><p>步骤：</p><ul><li><p>自旋排队:</p><p>方法开始时，尝试通过自旋的方式将当前线程排入等待队列。如果当前没有读锁或写锁，尝试直接获取写锁。如果无法直接获取写锁，初始化队列或创建新的等待节点，将其添加到队列中。</p></li><li><p>等待队列初始化:</p><p>如果队列为空，创建队列头节点，并将尾节点指向该头节点。若节点已经存在，则创建新的节点并将其加入队列。</p></li><li><p>自旋等待写锁:</p><p>在自旋阶段，尝试检查队列头节点并自旋等待写锁。更新队列头节点为当前节点，确保其他线程能够正确地获取写锁。</p></li><li><p>处理过时的等待节点:</p><p>在等待期间，帮助释放已经过时的等待节点，并唤醒那些被阻塞的线程。</p></li><li><p>等待获取写锁:</p><p>如果条件允许，将当前线程进入等待状态，直到写锁可用。支持中断处理，如果线程被中断则取消等待。</p></li></ul></li></ul><h3 id="3-13-unlockWrite方法"><a href="#3-13-unlockWrite方法" class="headerlink" title="3.13 unlockWrite方法"></a>3.13 unlockWrite方法</h3><pre><code class="highlight java"><span class="comment">/**</span><span class="comment"> * 解锁写锁。</span><span class="comment"> * </span><span class="comment"> * 这个方法会验证提供的印章（`stamp`）是否为当前锁的写锁印章。如果印章无效或不是写锁印章，会抛出 `IllegalMonitorStateException`。</span><span class="comment"> * 成功解锁后，将状态重置为原始值 `ORIGIN`（如果 `stamp` 变为 0L），或者恢复为提供的印章加上写锁位 `WBIT`。</span><span class="comment"> * 如果队列头部节点（`whead`）不为空且状态不为 0，则调用 `release` 方法释放队列中可能被阻塞的线程。</span><span class="comment"> * </span><span class="comment"> * <span class="doctag">@param</span> stamp 写锁的印章值。</span><span class="comment"> * <span class="doctag">@throws</span> IllegalMonitorStateException 如果印章无效或不是写锁印章。</span><span class="comment"> */</span><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">unlockWrite</span><span class="params">(<span class="type">long</span> stamp)</span> &#123;    WNode h;    <span class="comment">// 验证提供的印章是否与当前锁状态匹配，并且是写锁印章</span>    <span class="keyword">if</span> (state != stamp || (stamp &amp; WBIT) == <span class="number">0L</span>)        <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">IllegalMonitorStateException</span>();  <span class="comment">// 印章无效，抛出异常</span>    <span class="comment">// 更新锁状态。如果解锁后状态为 0L，重置为原始值 ORIGIN</span>    state = (stamp += WBIT) == <span class="number">0L</span> ? ORIGIN : stamp;        <span class="comment">// 如果队列头部节点不为空且状态不为 0，释放队列中的线程</span>    <span class="keyword">if</span> ((h = whead) != <span class="literal">null</span> &amp;&amp; h.status != <span class="number">0</span>)        release(h);&#125;</code></pre><p><strong>unlockWrite方法总结：</strong></p><ul><li><p>目标： 安全地释放持有的写锁，并确保相关线程被正确唤醒。</p></li><li><p>步骤：</p><ul><li><p>验证印章:</p><p>首先，方法会检查提供的印章是否与当前锁状态匹配，且印章是否包含写锁位 (WBIT)。如果不匹配或不包含写锁位，抛出 IllegalMonitorStateException。</p></li><li><p>更新锁状态:</p><p>如果印章有效，解锁后将状态重置为原始值 ORIGIN（如果 stamp 加上 WBIT 结果为 0L），否则将状态更新为印章加上 WBIT。这个操作确保锁的状态正确反映当前的锁持有情况。</p></li><li><p>释放阻塞线程:</p><p>检查队列头部节点 (whead) 是否存在且状态不为 0。如果存在，则调用 release 方法尝试释放队列中的线程。</p></li></ul></li></ul><h3 id="3-14-release方法"><a href="#3-14-release方法" class="headerlink" title="3.14 release方法"></a>3.14 release方法</h3><pre><code class="highlight java"><span class="comment">/**</span><span class="comment"> * 释放队列中阻塞的线程。</span><span class="comment"> * </span><span class="comment"> * 这个方法会尝试从队列中找到下一个需要被唤醒的节点（`WNode`）。</span><span class="comment"> * 将队列头部节点的状态从 `WAITING` 更新为 0（表示节点不再等待）。</span><span class="comment"> * 如果队列中的下一个节点（`q`）存在且状态不为 `CANCELLED`，唤醒线程。</span><span class="comment"> * </span><span class="comment"> * <span class="doctag">@param</span> h 队列中的头部节点。</span><span class="comment"> */</span><span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">release</span><span class="params">(WNode h)</span> &#123;    <span class="keyword">if</span> (h != <span class="literal">null</span>) &#123;        WNode q; Thread w;        <span class="comment">// 更新队列头部节点的状态为 0</span>        U.compareAndSwapInt(h, WSTATUS, WAITING, <span class="number">0</span>);                <span class="comment">// 查找下一个需要被唤醒的节点（如果下一个节点为空或者状态为 CANCELLED）</span>        <span class="keyword">if</span> ((q = h.next) == <span class="literal">null</span> || q.status == CANCELLED) &#123;            <span class="keyword">for</span> (<span class="type">WNode</span> <span class="variable">t</span> <span class="operator">=</span> wtail; t != <span class="literal">null</span> &amp;&amp; t != h; t = t.prev)                <span class="keyword">if</span> (t.status &lt;= <span class="number">0</span>)                    q = t;        &#125;                <span class="comment">// 如果找到的节点存在且线程不为空，唤醒线程</span>        <span class="keyword">if</span> (q != <span class="literal">null</span> &amp;&amp; (w = q.thread) != <span class="literal">null</span>)            U.unpark(w);    &#125;&#125;</code></pre><p><strong>release方法总结：</strong></p><ul><li><p>目标： 从队列中释放阻塞的线程，并确保下一个等待的线程被正确唤醒。</p></li><li><p>步骤：</p><ul><li><p>更新节点状态:</p><p>将队列头部节点的状态从 WAITING 更新为 0，表示该节点不再需要等待。此操作标志着头部节点已处理完毕，准备释放或处理下一个节点。</p></li><li><p>查找并设置下一个待唤醒的节点:</p><p>如果头部节点的下一个节点为空或状态为 CANCELLED，从队列尾部向前查找有效的待唤醒节点。这样可以确保唤醒操作的正确性，并避免唤醒已取消或不再需要的线程。</p></li><li><p>唤醒线程:</p><p>如果找到有效的待唤醒节点，并且该节点关联的线程不为空，则唤醒该线程。通过调用 U.unpark(w)，可以确保线程能够继续执行，减少系统中的线程阻塞时间。</p></li></ul></li></ul><h2 id="4-StampedLock管理线程的队列"><a href="#4-StampedLock管理线程的队列" class="headerlink" title="4. StampedLock管理线程的队列"></a>4. StampedLock管理线程的队列</h2><p>StampedLock内部基于<code>WNode</code>实现的阻塞队列和AQS实现的阻塞队列类似。<br>初始化时，新建个空节点，<code>whead=wtail=NULL</code> 。</p><p><img src="https://raw.githubusercontent.com/GeorgeChan95/blogimg/master/img/2024/10/19/20241019-164228.png" alt="队列初始化"></p><p>之后再往里面加入一个个读线程或写线程节点。</p><p>但是上面<code>acquireRead</code>和<code>acquireWrite</code>方法对于自旋的操作就和AQS有很大不同了。</p><p>在AQS里面，当一个线程CAS state失败之后，会立即加入阻塞队列，并且进入阻塞状态。但在StampedLock中，CAS state失败之后，会不断自旋，自旋足够多的次数之后，如果还拿不到锁，才进入阻塞状态。为此，根据CPU的核数，定义了自旋次数的常量值。如果是单核的CPU，肯定不能自旋，在多核情况下，才采用自旋策略。</p><p>还有个比较特殊的地方在于，每个WNode里面有一个cowait指针，用于串联起所有的读线程。<br>例如，队列尾部阻塞的是一个读线程 1，现在又来了读线程 2、3，那么会通过cowait指针，把1、2、3串联起来。1被唤醒之后，2、3也随之一起被唤醒，因为读和读之间不互斥。</p><p>也就是当入队一个线程时，如果队尾是写结点，则直接链接到队尾。<br>当入队一个读线程时，如果队尾是读节点，则直接链接到该读结点的cowait链中。</p><p><img src="https://raw.githubusercontent.com/GeorgeChan95/blogimg/master/img/2024/10/19/20241019-164402.png" alt="节点进入队列"></p><h1 id="四、StampedLock和ReentrantReadWriteLock对比"><a href="#四、StampedLock和ReentrantReadWriteLock对比" class="headerlink" title="四、StampedLock和ReentrantReadWriteLock对比"></a>四、StampedLock和ReentrantReadWriteLock对比</h1><table><thead><tr><th>特性</th><th><code>StampedLock</code></th><th><code>ReentrantReadWriteLock</code></th></tr></thead><tbody><tr><td><strong>引入版本</strong></td><td>JDK 8</td><td>JDK 5</td></tr><tr><td><strong>锁类型</strong></td><td>提供乐观读锁、悲观读锁和写锁</td><td>提供悲观读锁和写锁</td></tr><tr><td><strong>乐观读锁</strong></td><td>支持（<code>tryOptimisticRead()</code>）</td><td>不支持</td></tr><tr><td><strong>悲观读锁</strong></td><td>支持（<code>readLock()</code>）</td><td>支持（<code>readLock()</code>）</td></tr><tr><td><strong>写锁</strong></td><td>支持（<code>writeLock()</code>）</td><td>支持（<code>writeLock()</code>）</td></tr><tr><td><strong>锁升级</strong></td><td>支持从乐观读锁升级到悲观读锁或写锁（<code>tryConvertToWriteLock()</code>等）</td><td>不支持</td></tr><tr><td><strong>锁降级</strong></td><td>支持从写锁降级为读锁（<code>tryConvertToReadLock()</code>）</td><td>支持从写锁降级为读锁</td></tr><tr><td><strong>锁管理复杂度</strong></td><td>复杂，需要管理戳记，确保在转换锁时一致性</td><td>相对简单，直接使用 <code>readLock()</code> 和 <code>writeLock()</code></td></tr><tr><td><strong>性能优化</strong></td><td>乐观读锁减少了锁竞争，提高了读取性能</td><td>读写锁性能依赖于锁的竞争情况(大量并发读可能会导致写线程饥饿)</td></tr><tr><td><strong>公平性</strong></td><td>不提供公平性（锁的获取是非公平的）</td><td>可以选择公平性（通过构造函数 <code>ReentrantReadWriteLock(true)</code>）</td></tr><tr><td><strong>条件变量<code>Condition</code></strong></td><td>不支持</td><td>支持</td></tr></tbody></table><p><strong>总结</strong></p><p><strong><code>StampedLock</code></strong> 适用于需要高效读取性能的场景，通过乐观读锁减少锁竞争，同时支持锁的升级和降级，但锁的管理相对复杂，不支持重入，并且使用乐观读锁时需要遵循一定的顺序，所以使用时一定要谨慎。</p><p><strong>参考链接：</strong></p><blockquote><p><a href="https://blog.csdn.net/qq_37883866/article/details/140664358">https://blog.csdn.net/qq_37883866/article/details/140664358</a></p></blockquote>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;一、锁的演变&quot;&gt;&lt;a href=&quot;#一、锁的演变&quot; class=&quot;headerlink&quot; title=&quot;一、锁的演变&quot;&gt;&lt;/a&gt;一、锁的演变&lt;/h1&gt;&lt;p&gt;无锁  –&amp;gt; 独占锁  –&amp;gt; 读写锁  –&amp;gt; 邮戳锁&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;p&gt;无锁</summary>
      
    
    
    
    <category term="JUC" scheme="https://georgechan95.github.io/categories/JUC/"/>
    
    
    <category term="java" scheme="https://georgechan95.github.io/tags/java/"/>
    
    <category term="juc" scheme="https://georgechan95.github.io/tags/juc/"/>
    
  </entry>
  
</feed>
