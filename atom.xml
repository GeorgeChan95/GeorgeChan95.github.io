<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>George&#39;s Blog</title>
  
  <subtitle>个人邮箱：george_95@126.com</subtitle>
  <link href="https://georgechan95.github.io/atom.xml" rel="self"/>
  
  <link href="https://georgechan95.github.io/"/>
  <updated>2025-01-02T06:57:09.768Z</updated>
  <id>https://georgechan95.github.io/</id>
  
  <author>
    <name>George</name>
    
  </author>
  
  <generator uri="https://hexo.io/">Hexo</generator>
  
  <entry>
    <title>002-Rocky9.3系统初始化设置和Docker安装</title>
    <link href="https://georgechan95.github.io/blog/3c79d8d9.html"/>
    <id>https://georgechan95.github.io/blog/3c79d8d9.html</id>
    <published>2025-01-02T05:25:00.000Z</published>
    <updated>2025-01-02T06:57:09.768Z</updated>
    
    <content type="html"><![CDATA[<p><strong>系统环境</strong></p><blockquote><p>RockyLinux：9.3</p><p>镜像下载官网：<a href="https://rockylinux.org/zh-CN/download">https://rockylinux.org/zh-CN/download</a></p><p>镜像下载地址：<a href="https://dl.rockylinux.org/vault/rocky/9.3/isos/x86_64/">https://dl.rockylinux.org/vault/rocky/9.3/isos/x86_64/</a></p><p>安装镜像文件：Rocky-9.3-x86_64-minimal.iso</p></blockquote><h1 id="1、环境初始化"><a href="#1、环境初始化" class="headerlink" title="1、环境初始化"></a>1、环境初始化</h1><h2 id="1-1-配置静态IP"><a href="#1-1-配置静态IP" class="headerlink" title="1.1 配置静态IP"></a>1.1 配置静态IP</h2><ul><li><p>查看当前要设置的网卡</p><pre><code class="highlight shell">ip addr</code></pre><p><img src="https://raw.githubusercontent.com/GeorgeChan95/blogimg/master/img/2025/01/02/20250102-133612.png" alt="查看网卡信息"></p></li><li><p>编辑网卡配置</p><pre><code class="highlight shell">vi /etc/NetworkManager/system-connections/ens34.nmconnection</code></pre><ul><li><p>添加如下配置</p><pre><code class="highlight shell">[ipv4]method=manualaddress1=192.168.6.221/24,192.168.6.1dns=114.114.114.114;8.8.8.8</code></pre></li><li><p>配置解析</p><pre><code class="highlight shell">[ipv4]<span class="meta prompt_"># </span><span class="language-bash">ip设置为手动配置</span>method=manual<span class="meta prompt_"># </span><span class="language-bash">设置IP为：192.168.6.222</span><span class="meta prompt_"># </span><span class="language-bash">/24 表示子网掩码为：255.255.255.0</span><span class="meta prompt_"># </span><span class="language-bash">,192.168.6.1 表示网关地址为：192.168.6.1</span>address1=192.168.6.222/24,192.168.6.1<span class="meta prompt_"># </span><span class="language-bash">dns地址</span>dns=114.114.114.114;8.8.8.8</code></pre></li></ul><h2 id="1-2-重启设备和连接配置"><a href="#1-2-重启设备和连接配置" class="headerlink" title="1.2 重启设备和连接配置"></a>1.2 重启设备和连接配置</h2><pre><code class="highlight shell"><span class="meta prompt_"># </span><span class="language-bash">重新应用网络设备 ens34 的当前配置</span>nmcli device reapply ens34<span class="meta prompt_"></span><span class="meta prompt_"># </span><span class="language-bash">重新加载 ens34 的网络连接配置。在网络配置文件被手动更改后，通过此命令重新加载连接设置，使更改生效。</span>nmcli connection reload ens34<span class="meta prompt_"></span><span class="meta prompt_"># </span><span class="language-bash">使用 nmcli 命令激活网络设备</span>nmcli device connect ens34<span class="meta prompt_"></span><span class="meta prompt_"># </span><span class="language-bash">查看IP配置是否成功</span>ip addrping www.baidu.com</code></pre><ul><li><p>其它命令</p><pre><code class="highlight shell"><span class="meta prompt_"># </span><span class="language-bash">断开网络设备 ens34 的网络连接。</span>nmcli device disconnect ens34<span class="meta prompt_"></span><span class="meta prompt_"># </span><span class="language-bash">激活连接（Connection）如果设备已连接，但未启用对应的网络连接配置，可以激活配置：</span>nmcli connection up ens34<span class="meta prompt_"></span><span class="meta prompt_"># </span><span class="language-bash">检查设备状态</span>nmcli device status<span class="meta prompt_"></span><span class="meta prompt_"># </span><span class="language-bash">如果希望设备在每次系统启动时自动启用，可以执行以下命令：</span>nmcli connection modify ens34 connection.autoconnect yes</code></pre></li></ul></li></ul><h2 id="1-3-更换系统软件源"><a href="#1-3-更换系统软件源" class="headerlink" title="1.3 更换系统软件源"></a>1.3 更换系统软件源</h2><pre><code class="highlight shell"><span class="meta prompt_"># </span><span class="language-bash">更新源</span>sed -e &#x27;s|^mirrorlist=|#mirrorlist=|g&#x27; \    -e &#x27;s|^#baseurl=http://dl.rockylinux.org/$contentdir|baseurl=https://mirrors.aliyun.com/rockylinux|g&#x27; \    -i.bak /etc/yum.repos.d/[Rr]ocky*.repo    <span class="meta prompt_"></span><span class="meta prompt_"># </span><span class="language-bash">刷新dnf缓存</span>dnf makecache<span class="meta prompt_"></span><span class="meta prompt_"># </span><span class="language-bash">验证源更新</span>dnf repolist</code></pre><ul><li><p>命令解析</p><pre><code class="highlight shell"><span class="meta prompt_"># </span><span class="language-bash">使用 sed 命令修改 Rocky Linux 的 YUM/DNF 源配置文件，切换到阿里云的镜像源。</span>sed -e &#x27;s|^mirrorlist=|#mirrorlist=|g&#x27; \    -e &#x27;s|^#baseurl=http://dl.rockylinux.org/$contentdir|baseurl=https://mirrors.aliyun.com/rockylinux|g&#x27; \    -i.bak /etc/yum.repos.d/[Rr]ocky*.repo    <span class="meta prompt_"># </span><span class="language-bash">将以 mirrorlist= 开头的行注释掉（在前面加 <span class="comment">#）</span></span>-e &#x27;s|^mirrorlist=|#mirrorlist=|g&#x27;<span class="meta prompt_"></span><span class="meta prompt_"># </span><span class="language-bash">将以 <span class="comment">#baseurl= 开头并指向默认 Rocky Linux 源的行取消注释，并替换为阿里云镜像源 URL。</span></span>&#x27;s|^#baseurl=http://dl.rockylinux.org/$contentdir|baseurl=https://mirrors.aliyun.com/rockylinux|g&#x27;<span class="meta prompt_"></span><span class="meta prompt_"># </span><span class="language-bash">-i.bak：直接修改文件，并为原文件创建备份（扩展名为 .bak）。</span><span class="meta prompt_"># </span><span class="language-bash">修改 /etc/yum.repos.d/ 目录下所有以 rocky 或 Rocky 开头的 .repo 文件。</span><span class="meta prompt_"># </span><span class="language-bash">修改完成后，原始文件会被备份为 .bak 文件。</span>-i.bak /etc/yum.repos.d/[Rr]ocky*.repo<span class="meta prompt_"></span><span class="meta prompt_"></span><span class="meta prompt_"></span><span class="meta prompt_"># </span><span class="language-bash">更新本地缓存，确保系统可以快速查询软件包信息。</span>dnf makecache</code></pre></li></ul><h2 id="1-4-修改防火墙"><a href="#1-4-修改防火墙" class="headerlink" title="1.4 修改防火墙"></a>1.4 修改防火墙</h2><p>防火墙修改 firewalld 为 iptables</p><pre><code class="highlight shell">systemctl stop firewalldsystemctl disable firewalldyum -y install iptables-servicessystemctl start iptablesiptables -Fsystemctl enable iptables</code></pre><ul><li><p>命令解析</p><pre><code class="highlight shell"><span class="meta prompt_"># </span><span class="language-bash">停止运行 firewalld</span>systemctl stop firewalld<span class="meta prompt_"></span><span class="meta prompt_"># </span><span class="language-bash">禁止 firewalld 开机自启</span>systemctl disable firewalld<span class="meta prompt_"></span><span class="meta prompt_"># </span><span class="language-bash">安装 iptables 服务，用于管理 Linux 的防火墙规则</span>yum -y install iptables-services<span class="meta prompt_"></span><span class="meta prompt_"># </span><span class="language-bash">使防火墙规则立即生效，并开始运行 iptables 防火墙服务。</span>systemctl start iptables<span class="meta prompt_"></span><span class="meta prompt_"># </span><span class="language-bash">删除当前的防火墙规则，通常用于重置或清理防火墙规则。</span>iptables -F<span class="meta prompt_"></span><span class="meta prompt_"># </span><span class="language-bash">设置 iptables 服务开机自启动，确保服务器重启后，iptables 服务会自动加载防火墙规则。</span>systemctl enable iptables</code></pre></li></ul><h2 id="1-5-禁用-Selinux"><a href="#1-5-禁用-Selinux" class="headerlink" title="1.5 禁用 Selinux"></a>1.5 禁用 Selinux</h2><pre><code class="highlight shell">setenforce 0sed -i &quot;s/SELINUX=enforcing/SELINUX=disabled/g&quot; /etc/selinux/configgrubby --update-kernel ALL --args selinux=0</code></pre><ul><li><p>命令解析</p><pre><code class="highlight shell"><span class="meta prompt_"># </span><span class="language-bash">将 SELinux 的模式设置为 Permissive（宽容模式）。</span><span class="meta prompt_"># </span><span class="language-bash">0：表示设置为 Permissive 模式，此模式下 SELinux 不会强制执行安全策略，而是记录违规日志。</span><span class="meta prompt_"># </span><span class="language-bash">1：表示 Enforcing 模式，此模式下 SELinux 会强制执行安全策略。</span>setenforce 0<span class="meta prompt_"></span><span class="meta prompt_"># </span><span class="language-bash">修改 SELinux 配置文件 /etc/selinux/config，将 SELINUX 设置为 disabled。永久禁用 SELinux，即使系统重启也不会再启用。</span>sed -i &quot;s/SELINUX=enforcing/SELINUX=disabled/g&quot; /etc/selinux/config<span class="meta prompt_"></span><span class="meta prompt_"># </span><span class="language-bash">通过 grubby 工具将 selinux=0 参数添加到所有内核启动配置中。</span>grubby --update-kernel ALL --args selinux=0grubby --info DEFAULT<span class="meta prompt_"></span><span class="meta prompt_"># </span><span class="language-bash">查看是否禁用，</span>grubby --info DEFAULT<span class="meta prompt_"># </span><span class="language-bash">回滚内核层禁用操作，、</span>grubby --update-kernel ALL --remove-args selinux</code></pre></li><li><p>修改完成后重启系统</p><pre><code class="highlight shell">reboot</code></pre></li></ul><h2 id="1-6-设置时区"><a href="#1-6-设置时区" class="headerlink" title="1.6 设置时区"></a>1.6 设置时区</h2><pre><code class="highlight shell">timedatectl set-timezone Asia/Shanghai</code></pre><h1 id="2、安装Docker"><a href="#2、安装Docker" class="headerlink" title="2、安装Docker"></a>2、安装Docker</h1><h2 id="2-1-安装必要的库和网络设置"><a href="#2-1-安装必要的库和网络设置" class="headerlink" title="2.1 安装必要的库和网络设置"></a>2.1 安装必要的库和网络设置</h2><pre><code class="highlight shell">yum install -y epel-releaseyum install -y bridge-utilsmodprobe br_netfilterecho &#x27;br_netfilter&#x27; &gt;&gt; /etc/modules-load.d/bridge.confecho &#x27;net.bridge.bridge-nf-call-iptables=1&#x27; &gt;&gt; /etc/sysctl.confecho &#x27;net.bridge.bridge-nf-call-ip6tables=1&#x27; &gt;&gt; /etc/sysctl.confecho &#x27;net.ipv4.ip_forward=1&#x27; &gt;&gt; /etc/sysctl.confsysctl -p</code></pre><ul><li><p>命令解释</p><pre><code class="highlight shell"><span class="meta prompt_"># </span><span class="language-bash">安装 EPEL（Extra Packages <span class="keyword">for</span> Enterprise Linux） 仓库的 Release 包。</span><span class="meta prompt_"># </span><span class="language-bash">EPEL 是由 Fedora 社区维护的一个软件仓库，提供许多额外的软件包，这些包在默认的 RHEL（或其衍生版如 CentOS、Rocky Linux 等）中没有包含。</span>yum install -y epel-release<span class="meta prompt_"></span><span class="meta prompt_"># </span><span class="language-bash">安装 bridge-utils 软件包。</span><span class="meta prompt_"># </span><span class="language-bash">bridge-utils 是一个 Linux 工具集，用于创建和管理网络桥接（bridging）。</span>yum install -y bridge-utils<span class="meta prompt_"></span><span class="meta prompt_"># </span><span class="language-bash">加载 br_netfilter 内核模块。</span><span class="meta prompt_"># </span><span class="language-bash">该模块用于启用网络桥接（bridge）时的流量过滤功能。</span><span class="meta prompt_"># </span><span class="language-bash">允许通过桥接的网络流量被 iptables 规则管理。</span><span class="meta prompt_"># </span><span class="language-bash">在容器或虚拟化环境中，确保桥接网络的流量可以被正确处理。</span>modprobe br_netfilter<span class="meta prompt_"></span><span class="meta prompt_"># </span><span class="language-bash">将 br_netfilter 模块名称添加到 /etc/modules-load.d/bridge.conf 文件中。</span><span class="meta prompt_"># </span><span class="language-bash">配置系统在启动时自动加载 br_netfilter 模块。</span>echo &#x27;br_netfilter&#x27; &gt;&gt; /etc/modules-load.d/bridge.conf<span class="meta prompt_"></span><span class="meta prompt_"># </span><span class="language-bash">向 /etc/sysctl.conf 文件添加配置，使桥接流量可以通过 iptables 规则管理。</span><span class="meta prompt_"># </span><span class="language-bash">启用桥接网络上的 IPv4 流量通过 iptables 的规则处理。</span>echo &#x27;net.bridge.bridge-nf-call-iptables=1&#x27; &gt;&gt; /etc/sysctl.conf<span class="meta prompt_"></span><span class="meta prompt_"># </span><span class="language-bash">向 /etc/sysctl.conf 文件添加配置，使桥接流量中的 IPv6 流量可以通过 ip6tables 规则管理。</span>echo &#x27;net.bridge.bridge-nf-call-ip6tables=1&#x27; &gt;&gt; /etc/sysctl.conf<span class="meta prompt_"></span><span class="meta prompt_"># </span><span class="language-bash">向 /etc/sysctl.conf 文件添加配置，启用 IP 转发功能。</span><span class="meta prompt_"># </span><span class="language-bash">用途：在容器网络或 Kubernetes 集群中，允许跨子网通信。</span>echo &#x27;net.ipv4.ip_forward=1&#x27; &gt;&gt; /etc/sysctl.conf<span class="meta prompt_"></span><span class="meta prompt_"># </span><span class="language-bash">重新加载 /etc/sysctl.conf 中的所有内核参数配置，并使其立即生效。</span>sysctl -p</code></pre></li></ul><h2 id="2-2-安装docker"><a href="#2-2-安装docker" class="headerlink" title="2.2 安装docker"></a>2.2 安装docker</h2><p>添加 docker-ce yum 源</p><pre><code class="highlight shell">sudo dnf config-manager --add-repo https://mirrors.aliyun.com/docker-ce/linux/centos/docker-ce.reposudo sed -i &#x27;s+download.docker.com+mirrors.aliyun.com/docker-ce+&#x27; /etc/yum.repos.d/docker-ce.reposudo dnf install -y docker-ce docker-ce-cli containerd.io docker-buildx-plugin docker-compose-plugin</code></pre><ul><li><p>命令解析</p><pre><code class="highlight shell"><span class="meta prompt_"># </span><span class="language-bash">使用 dnf config-manager 命令添加 Docker 软件包的官方仓库（在这里是阿里云的镜像）。</span>sudo dnf config-manager --add-repo https://mirrors.aliyun.com/docker-ce/linux/centos/docker-ce.repo<span class="meta prompt_"></span><span class="meta prompt_"># </span><span class="language-bash">修改 docker-ce.repo 文件中的镜像源地址，将默认的 download.docker.com 替换为阿里云的镜像地址 mirrors.aliyun.com/docker-ce。</span>sudo sed -i &#x27;s+download.docker.com+mirrors.aliyun.com/docker-ce+&#x27; /etc/yum.repos.d/docker-ce.repo<span class="meta prompt_"></span><span class="meta prompt_"># </span><span class="language-bash">安装最新版本docker</span>sudo dnf install -y docker-ce docker-ce-cli containerd.io docker-buildx-plugin docker-compose-plugin</code></pre></li></ul><h2 id="2-3-开启Docker服务"><a href="#2-3-开启Docker服务" class="headerlink" title="2.3 开启Docker服务"></a>2.3 开启Docker服务</h2><pre><code class="highlight shell">systemctl start dockersystemctl enable docker</code></pre><h2 id="2-4-配置-daemon-json"><a href="#2-4-配置-daemon-json" class="headerlink" title="2.4 配置 daemon.json"></a>2.4 配置 daemon.json</h2><pre><code class="highlight shell">cat &gt;&gt;/etc/docker/daemon.json &lt;&lt;EOF&#123;  &quot;log-driver&quot;: &quot;json-file&quot;,  &quot;log-opts&quot;: &#123;        &quot;max-size&quot;: &quot;100m&quot;,        &quot;max-file&quot;: &quot;10&quot;  &#125;,  &quot;data-root&quot;:&quot;/data/docker&quot;,  &quot;exec-opts&quot;: [&quot;native.cgroupdriver=systemd&quot;],  &quot;registry-mirrors&quot;: [   &quot;https://kfp63jaj.mirror.aliyuncs.com&quot;,    &quot;https://hub-mirror.c.163.com&quot;,    &quot;https://mirror.baidubce.com&quot;  ]&#125;EOF</code></pre><ul><li><p>配置解析</p><pre><code class="highlight shell">&quot;data-root&quot;: &quot;/data/docker&quot;指定 Docker 数据的存储目录为 /data/docker。包括容器、镜像、卷等内容。默认存储在 /var/lib/docker，此配置用于更改默认路径。&quot;exec-opts&quot;: [&quot;native.cgroupdriver=systemd&quot;]配置 Docker 使用 systemd 作为 Cgroup 驱动程序。推荐在使用现代 Linux 发行版（如 Rocky Linux 9）或 Kubernetes 时采用此配置，以实现更好的资源管理和兼容性。&quot;log-driver&quot;: &quot;json-file&quot;指定 Docker 的日志驱动为 json-file。json-file 是 Docker 默认的日志存储方式，将日志保存在 JSON 文件中。&quot;log-opts&quot;: &#123;&#125;配置日志驱动的选项：&quot;max-size&quot;: &quot;100m&quot;：每个日志文件的最大大小为 100MB。&quot;max-file&quot;: &quot;100&quot;：最多保留 100 个日志文件（滚动日志机制）。&quot;insecure-registries&quot;: [&quot;harbor.xinxainghf.com&quot;]配置不安全的私有镜像仓库地址（即未启用 HTTPS 的仓库）。例如，harbor.xinxainghf.com 是一个私有仓库地址。&quot;registry-mirrors&quot;: [&quot;https://kfp63jaj.mirror.aliyuncs.com&quot;]配置 Docker 镜像加速器。镜像地址为阿里云镜像服务，加速从官方 Docker Hub 拉取镜像的速度。</code></pre></li></ul><h2 id="2-5-创建-Docker-服务的自定义配置目录"><a href="#2-5-创建-Docker-服务的自定义配置目录" class="headerlink" title="2.5 创建 Docker 服务的自定义配置目录"></a>2.5 创建 Docker 服务的自定义配置目录</h2><pre><code class="highlight shell">mkdir -p /etc/systemd/system/docker.service.d</code></pre><p>用于存放 Docker 服务的自定义配置文件。</p><h2 id="2-6-重新加载-Docker-配置"><a href="#2-6-重新加载-Docker-配置" class="headerlink" title="2.6 重新加载 Docker 配置"></a>2.6 重新加载 Docker 配置</h2><pre><code class="highlight shell">systemctl daemon-reloadsystemctl restart docker</code></pre><ul><li><p>验证配置是否生效</p><pre><code class="highlight shell">docker info</code></pre></li></ul>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;&lt;strong&gt;系统环境&lt;/strong&gt;&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;RockyLinux：9.3&lt;/p&gt;
&lt;p&gt;镜像下载官网：&lt;a href=&quot;https://rockylinux.org/zh-CN/download&quot;&gt;https://rockylinux</summary>
      
    
    
    
    <category term="linux" scheme="https://georgechan95.github.io/categories/linux/"/>
    
    
    <category term="linux" scheme="https://georgechan95.github.io/tags/linux/"/>
    
    <category term="Rocky" scheme="https://georgechan95.github.io/tags/Rocky/"/>
    
    <category term="Docker" scheme="https://georgechan95.github.io/tags/Docker/"/>
    
  </entry>
  
  <entry>
    <title>001-ESXi8安装Rocky9.3虚拟机</title>
    <link href="https://georgechan95.github.io/blog/7e3a5200.html"/>
    <id>https://georgechan95.github.io/blog/7e3a5200.html</id>
    <published>2025-01-02T01:34:00.000Z</published>
    <updated>2025-01-02T06:53:20.716Z</updated>
    
    <content type="html"><![CDATA[<p><strong>系统环境</strong></p><blockquote><p>ESXI：8.0</p><p>RockyLinux：9.3</p><p>镜像下载官网：<a href="https://rockylinux.org/zh-CN/download">https://rockylinux.org/zh-CN/download</a></p><p>镜像下载地址：<a href="https://dl.rockylinux.org/vault/rocky/9.3/isos/x86_64/">https://dl.rockylinux.org/vault/rocky/9.3/isos/x86_64/</a></p><p>安装镜像文件：Rocky-9.3-x86_64-minimal.iso</p></blockquote><h1 id="1、创建虚拟机"><a href="#1、创建虚拟机" class="headerlink" title="1、创建虚拟机"></a>1、创建虚拟机</h1><h2 id="1-1-创建新虚拟机"><a href="#1-1-创建新虚拟机" class="headerlink" title="1.1 创建新虚拟机"></a>1.1 创建新虚拟机</h2><p><img src="https://raw.githubusercontent.com/GeorgeChan95/blogimg/master/img/2025/01/02/20250102-111758.png" alt="创建新虚拟机"></p><h2 id="1-2-设置虚拟机名称和操作系统"><a href="#1-2-设置虚拟机名称和操作系统" class="headerlink" title="1.2 设置虚拟机名称和操作系统"></a>1.2 设置虚拟机名称和操作系统</h2><p><img src="https://raw.githubusercontent.com/GeorgeChan95/blogimg/master/img/2025/01/02/20250102-111812.png" alt="设置虚拟机名称和操作系统"></p><h2 id="1-3-选择磁盘"><a href="#1-3-选择磁盘" class="headerlink" title="1.3 选择磁盘"></a>1.3 选择磁盘</h2><p><img src="https://raw.githubusercontent.com/GeorgeChan95/blogimg/master/img/2025/01/02/20250102-111829.png" alt="选择磁盘"></p><h2 id="1-4-自定义虚拟机硬件设置，选择镜像文件"><a href="#1-4-自定义虚拟机硬件设置，选择镜像文件" class="headerlink" title="1.4 自定义虚拟机硬件设置，选择镜像文件"></a>1.4 自定义虚拟机硬件设置，选择镜像文件</h2><p><img src="https://raw.githubusercontent.com/GeorgeChan95/blogimg/master/img/2025/01/02/20250102-111938.png" alt="自定义虚拟机硬件设置，选择镜像文件"></p><h2 id="1-5-查看虚拟机设置"><a href="#1-5-查看虚拟机设置" class="headerlink" title="1.5 查看虚拟机设置"></a>1.5 查看虚拟机设置</h2><p><img src="https://raw.githubusercontent.com/GeorgeChan95/blogimg/master/img/2025/01/02/20250102-112008.png" alt="查看虚拟机设置"></p><h1 id="2、开始系统安装"><a href="#2、开始系统安装" class="headerlink" title="2、开始系统安装"></a>2、开始系统安装</h1><h2 id="2-1-打开虚拟机电源"><a href="#2-1-打开虚拟机电源" class="headerlink" title="2.1 打开虚拟机电源"></a>2.1 打开虚拟机电源</h2><p><img src="https://raw.githubusercontent.com/GeorgeChan95/blogimg/master/img/2025/01/02/20250102-130300.png" alt="打开虚拟机电源"></p><h2 id="2-2-键盘上下键，光标移动到-Install-Rocky-Linux-9-3-，回车开始安装系统"><a href="#2-2-键盘上下键，光标移动到-Install-Rocky-Linux-9-3-，回车开始安装系统" class="headerlink" title="2.2 键盘上下键，光标移动到 Install Rocky Linux 9.3 ，回车开始安装系统"></a>2.2 键盘上下键，光标移动到 Install Rocky Linux 9.3 ，回车开始安装系统</h2><p><img src="https://raw.githubusercontent.com/GeorgeChan95/blogimg/master/img/2025/01/02/20250102-130444.png" alt="Install Rocky Linux 9.3"></p><h2 id="2-3-等待系统加载"><a href="#2-3-等待系统加载" class="headerlink" title="2.3 等待系统加载"></a>2.3 等待系统加载</h2><p><img src="https://raw.githubusercontent.com/GeorgeChan95/blogimg/master/img/2025/01/02/20250102-130421.png" alt="等待系统加载"></p><h2 id="2-4-选择语言为中文，目的是这样会自动把时区设置到中国"><a href="#2-4-选择语言为中文，目的是这样会自动把时区设置到中国" class="headerlink" title="2.4 选择语言为中文，目的是这样会自动把时区设置到中国"></a>2.4 选择语言为中文，目的是这样会自动把时区设置到中国</h2><p><img src="https://raw.githubusercontent.com/GeorgeChan95/blogimg/master/img/2025/01/02/20250102-130501.png" alt="选择语言为中文"></p><h2 id="2-5-设置root和硬盘"><a href="#2-5-设置root和硬盘" class="headerlink" title="2.5 设置root和硬盘"></a>2.5 设置root和硬盘</h2><p><img src="https://raw.githubusercontent.com/GeorgeChan95/blogimg/master/img/2025/01/02/20250102-130628.png" alt="设置root，和硬盘"></p><h2 id="2-6-设置root密码，允许root远程登录"><a href="#2-6-设置root密码，允许root远程登录" class="headerlink" title="2.6 设置root密码，允许root远程登录"></a>2.6 设置root密码，允许root远程登录</h2><p><img src="https://raw.githubusercontent.com/GeorgeChan95/blogimg/master/img/2025/01/02/20250102-130711.png" alt="设置root密码，允许root远程登录"></p><h2 id="2-7-选择磁盘"><a href="#2-7-选择磁盘" class="headerlink" title="2.7 选择磁盘"></a>2.7 选择磁盘</h2><p><img src="https://raw.githubusercontent.com/GeorgeChan95/blogimg/master/img/2025/01/02/20250102-131738.png" alt="选择磁盘"></p><h2 id="2-8-设置完成后，正式开始安装"><a href="#2-8-设置完成后，正式开始安装" class="headerlink" title="2.8 设置完成后，正式开始安装"></a>2.8 设置完成后，正式开始安装</h2><p><img src="https://raw.githubusercontent.com/GeorgeChan95/blogimg/master/img/2025/01/02/20250102-130828.png" alt="设置完成后，正式开始安装"></p><h2 id="2-9-等待安装完成"><a href="#2-9-等待安装完成" class="headerlink" title="2.9 等待安装完成"></a>2.9 等待安装完成</h2><p><img src="https://raw.githubusercontent.com/GeorgeChan95/blogimg/master/img/2025/01/02/20250102-130851.png" alt="等待安装完成"></p><h2 id="2-10-安装完成，重启系统"><a href="#2-10-安装完成，重启系统" class="headerlink" title="2.10 安装完成，重启系统"></a>2.10 安装完成，重启系统</h2><p><img src="https://raw.githubusercontent.com/GeorgeChan95/blogimg/master/img/2025/01/02/20250102-131511.png" alt="安装完成，重启系统"></p><h2 id="2-11-等待系统重启中"><a href="#2-11-等待系统重启中" class="headerlink" title="2.11 等待系统重启中"></a>2.11 等待系统重启中</h2><p><img src="https://raw.githubusercontent.com/GeorgeChan95/blogimg/master/img/2025/01/02/20250102-131611.png" alt="等待系统重启中"></p><h2 id="2-12-重启完成，开始登录"><a href="#2-12-重启完成，开始登录" class="headerlink" title="2.12 重启完成，开始登录"></a>2.12 重启完成，开始登录</h2><p><img src="https://raw.githubusercontent.com/GeorgeChan95/blogimg/master/img/2025/01/02/20250102-131648.png" alt="重启完成，开始登录"></p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;&lt;strong&gt;系统环境&lt;/strong&gt;&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;ESXI：8.0&lt;/p&gt;
&lt;p&gt;RockyLinux：9.3&lt;/p&gt;
&lt;p&gt;镜像下载官网：&lt;a href=&quot;https://rockylinux.org/zh-CN/download&quot;&gt;ht</summary>
      
    
    
    
    <category term="linux" scheme="https://georgechan95.github.io/categories/linux/"/>
    
    
    <category term="linux" scheme="https://georgechan95.github.io/tags/linux/"/>
    
    <category term="Rocky" scheme="https://georgechan95.github.io/tags/Rocky/"/>
    
  </entry>
  
  <entry>
    <title>25-责任链模式</title>
    <link href="https://georgechan95.github.io/blog/77d85f50.html"/>
    <id>https://georgechan95.github.io/blog/77d85f50.html</id>
    <published>2024-12-03T13:08:00.000Z</published>
    <updated>2024-12-03T08:57:39.735Z</updated>
    
    <content type="html"><![CDATA[<p><strong>责任链模式是一种对象的行为模式。在责任链模式里，很多对象由每一个对象对其下家的引用而连接起来形成一条链。请求在这个链上传递，直到链上的某一个对象决定处理此请求。发出这个请求的客户端并不知道链上的哪一个对象最终处理这个请求，这使得系统可以在不影响客户端的情况下动态地重新组织和分配责任。</strong></p><p>一、从击鼓传花谈起</p><p>击鼓传花是一种热闹而又紧张的饮酒游戏。在酒宴上宾客依次坐定位置，由一人击鼓，击鼓的地方与传花的地方是分开的，以示公正。开始击鼓时，花束就开始依次传递，鼓声一落，如果花束在某人手中，则该人就得饮酒。</p><p>比如说，贾母、贾赦、贾政、贾宝玉和贾环是五个参加击鼓传花游戏的传花者，他们组成一个环链。击鼓者将花传给贾母，开始传花游戏。花由贾母传给贾赦，由贾赦传给贾政，由贾政传给贾宝玉，又贾宝玉传给贾环，由贾环传回给贾母，如此往复，如下图所示。当鼓声停止时，手中有花的人就得执行酒令。</p><p><img src="https://raw.githubusercontent.com/GeorgeChan95/blogimg/master/img/2024/12/03/20241203-155845.png" alt="击鼓传花"></p><p>击鼓传花便是责任链模式的应用。责任链可能是一条直线、一个环链或者一个树结构的一部分。</p><p>二、责任链模式的结构</p><p>下面使用了一个责任链模式的最简单的实现。</p><p><img src="https://raw.githubusercontent.com/GeorgeChan95/blogimg/master/img/2024/12/03/20241203-155934.png" alt="责任链模式结构图"></p><p>责任链模式涉及到的角色如下所示：</p><ul><li><p><strong>抽象处理者(Handler)角色：</strong>定义出一个处理请求的接口。如果需要，接口可以定义出一个方法以设定和返回对下家的引用。这个角色通常由一个Java抽象类或者Java接口实现。上图中Handler类的聚合关系给出了具体子类对下家的引用，抽象方法 <code>handleRequest()</code> 规范了子类处理请求的操作。</p></li><li><p><strong>具体处理者(ConcreteHandler)角色：</strong>具体处理者接到请求后，可以选择将请求处理掉，或者将请求传给下家。由于具体处理者持有对下家的引用，因此，如果需要，具体处理者可以访问下家。</p></li></ul><p><strong>代码实现如下：</strong></p><pre><code class="highlight java"><span class="comment">/**</span><span class="comment"> * 抽象处理者角色</span><span class="comment"> */</span><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">class</span> <span class="title class_">Handler</span> &#123;    <span class="comment">// 持有后继的责任对象</span>    <span class="keyword">private</span> Handler successor;    <span class="comment">/**</span><span class="comment">     * 处理请求方法的示例，这里没有传参，实际上可根据需要传参</span><span class="comment">     */</span>    <span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">void</span> <span class="title function_">handleRequest</span><span class="params">()</span>;    <span class="comment">/**</span><span class="comment">     * 获取后继责任对象</span><span class="comment">     * <span class="doctag">@return</span></span><span class="comment">     */</span>    <span class="keyword">public</span> Handler <span class="title function_">getSuccessor</span><span class="params">()</span> &#123;        <span class="keyword">return</span> successor;    &#125;    <span class="comment">/**</span><span class="comment">     * 设置后继责任对象</span><span class="comment">     * <span class="doctag">@param</span> successor</span><span class="comment">     */</span>    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setSuccessor</span><span class="params">(Handler successor)</span> &#123;        <span class="built_in">this</span>.successor = successor;    &#125;&#125;<span class="comment">/**</span><span class="comment"> * 具体处理者角色</span><span class="comment"> */</span><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ConcreteHandler</span> <span class="keyword">extends</span> <span class="title class_">Handler</span> &#123;    <span class="comment">/**</span><span class="comment">     * 请求处理方法</span><span class="comment">     */</span>    <span class="meta">@Override</span>    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">handleRequest</span><span class="params">()</span> &#123;        <span class="keyword">if</span> (getSuccessor() != <span class="literal">null</span>) &#123; <span class="comment">// 如果有后继处理者</span>            System.out.println(<span class="string">&quot;放过请求&quot;</span>);            <span class="comment">// 调用后继处理者，处理请求</span>            getSuccessor().handleRequest();        &#125; <span class="keyword">else</span> &#123; <span class="comment">// 自己处理请求</span>            System.out.println(<span class="string">&quot;处理请求&quot;</span>);        &#125;    &#125;&#125;<span class="comment">/**</span><span class="comment"> * 测试类</span><span class="comment"> */</span><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Client</span> &#123;    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;        <span class="comment">// 创建责任链上的具体处理者对象</span>        <span class="type">Handler</span> <span class="variable">handler1</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ConcreteHandler</span>();        <span class="type">Handler</span> <span class="variable">handler2</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ConcreteHandler</span>();        <span class="comment">// 组装责任链</span>        handler1.setSuccessor(handler2);        <span class="comment">// 处理请求</span>        handler1.handleRequest();    &#125;&#125;</code></pre><blockquote><p>运行结果：</p><pre><code class="highlight shell">放过请求处理请求</code></pre></blockquote><p>可以看出，客户端创建了两个处理者对象，并指定第一个处理者对象的下家是第二个处理者对象，而第二个处理者对象没有下家。然后客户端将请求传递给第一个处理者对象。</p><p>由于本示例的传递逻辑非常简单：只要有下家，就传给下家处理；如果没有下家，就自行处理。因此，第一个处理者对象接到请求后，会将请求传递给第二个处理者对象。由于第二个处理者对象没有下家，于是自行处理请求。活动时序图如下所示。</p><p><img src="https://raw.githubusercontent.com/GeorgeChan95/blogimg/master/img/2024/12/03/20241203-161859.png" alt="责任链处理时序图"></p><p>二、使用场景</p><p>来考虑这样一个功能: <strong>申请聚餐费用的管理。</strong></p><p>很多公司都是这样的福利，就是项目组或者是部门可以向公司申请一些聚餐费用，用于组织项目组成员或者是部门成员进行聚餐活动。</p><p>申请聚餐费用的大致流程一般是：由申请人先填写申请单，然后交给领导审批，如果申请批准下来，领导会通知申请人审批通过，然后申请人去财务领取费用，如果没有批准下来，领导会通知申请人审批未通过，此事也就此作罢。</p><p>不同级别的领导，对于审批的额度是不一样的，比如，项目经理只能审批500元以内的申请；部门经理能审批1000元以内的申请；而总经理可以审核任意额度的申请。</p><p>也就是说，当某人提出聚餐费用申请的请求后，该请求会经由项目经理、部门经理、总经理之中的某一位领导来进行相应的处理，但是提出申请的人并不知道最终会由谁来处理他的请求，一般申请人是把自己的申请提交给项目经理，或许最后是由总经理来处理他的请求。</p><p>可以使用责任链模式来实现上述功能：当某人提出聚餐费用申请的请求后，该请求会在 <strong>项目经理—〉部门经理—〉总经理</strong> 这样一条领导处理链上进行传递，发出请求的人并不知道谁会来处理他的请求，每个领导会根据自己的职责范围，来判断是处理请求还是把请求交给更高级别的领导，只要有领导处理了，传递就结束了。</p><p>需要把每位领导的处理独立出来，实现成单独的职责处理对象，然后为它们提供一个公共的、抽象的父职责对象，这样就可以在客户端来动态地组合职责链，实现不同的功能要求了。</p><p><img src="https://raw.githubusercontent.com/GeorgeChan95/blogimg/master/img/2024/12/03/20241203-162843.png" alt="责任链模式UML"></p><p><strong>代码实现如下：</strong></p><pre><code class="highlight java"><span class="comment">/**</span><span class="comment"> * 抽象处理者角色类</span><span class="comment"> */</span><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">class</span> <span class="title class_">Handler</span> &#123;    <span class="comment">/**</span><span class="comment">     * 持有下一个处理请求的对象</span><span class="comment">     */</span>    <span class="keyword">private</span> <span class="type">Handler</span> <span class="variable">successor</span> <span class="operator">=</span> <span class="literal">null</span>;    <span class="comment">/**</span><span class="comment">     * 获取下一个处理请求的对象</span><span class="comment">     *</span><span class="comment">     * <span class="doctag">@return</span></span><span class="comment">     */</span>    <span class="keyword">public</span> Handler <span class="title function_">getSuccessor</span><span class="params">()</span> &#123;        <span class="keyword">return</span> successor;    &#125;    <span class="comment">/**</span><span class="comment">     * 设置下一个处理请求的对象</span><span class="comment">     *</span><span class="comment">     * <span class="doctag">@param</span> successor</span><span class="comment">     */</span>    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setSuccessor</span><span class="params">(Handler successor)</span> &#123;        <span class="built_in">this</span>.successor = successor;    &#125;    <span class="comment">/**</span><span class="comment">     * 处理聚餐费用的申请</span><span class="comment">     *</span><span class="comment">     * <span class="doctag">@param</span> user 申请人</span><span class="comment">     * <span class="doctag">@param</span> fee  申请的钱数</span><span class="comment">     * <span class="doctag">@return</span> 成功或失败的具体通知</span><span class="comment">     */</span>    <span class="keyword">public</span> <span class="keyword">abstract</span> String <span class="title function_">handleFeeRequest</span><span class="params">(String user, <span class="type">double</span> fee)</span>;&#125;<span class="comment">/**</span><span class="comment"> * 具体处理者-项目经理</span><span class="comment"> */</span><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ProjectManager</span> <span class="keyword">extends</span> <span class="title class_">Handler</span> &#123;    <span class="meta">@Override</span>    <span class="keyword">public</span> String <span class="title function_">handleFeeRequest</span><span class="params">(String user, <span class="type">double</span> fee)</span> &#123;        <span class="type">String</span> <span class="variable">str</span> <span class="operator">=</span> <span class="string">&quot;&quot;</span>;        <span class="comment">//项目经理权限比较小，只能在500以内</span>        <span class="keyword">if</span> (fee &lt; <span class="number">500</span>) &#123;            <span class="comment">//为了测试，简单点，只同意张三的请求</span>            <span class="keyword">if</span> (<span class="string">&quot;张三&quot;</span>.equals(user)) &#123;                str = <span class="string">&quot;成功：项目经理同意【&quot;</span> + user + <span class="string">&quot;】的聚餐费用，金额为&quot;</span> + fee + <span class="string">&quot;元&quot;</span>;            &#125; <span class="keyword">else</span> &#123;                <span class="comment">//其他人一律不同意</span>                str = <span class="string">&quot;失败：项目经理不同意【&quot;</span> + user + <span class="string">&quot;】的聚餐费用，金额为&quot;</span> + fee + <span class="string">&quot;元&quot;</span>;            &#125;        &#125; <span class="keyword">else</span> &#123;            <span class="comment">//超过500，继续传递给级别更高的人处理</span>            <span class="keyword">if</span> (getSuccessor() != <span class="literal">null</span>) &#123;                <span class="keyword">return</span> getSuccessor().handleFeeRequest(user, fee);            &#125;        &#125;        <span class="keyword">return</span> str;    &#125;&#125;<span class="comment">/**</span><span class="comment"> * 具体处理者-部门经理</span><span class="comment"> */</span><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">DeptManager</span> <span class="keyword">extends</span> <span class="title class_">Handler</span> &#123;    <span class="meta">@Override</span>    <span class="keyword">public</span> String <span class="title function_">handleFeeRequest</span><span class="params">(String user, <span class="type">double</span> fee)</span> &#123;        <span class="type">String</span> <span class="variable">str</span> <span class="operator">=</span> <span class="string">&quot;&quot;</span>;        <span class="comment">//部门经理的权限只能在1000以内</span>        <span class="keyword">if</span> (fee &lt; <span class="number">1000</span>) &#123;            <span class="comment">//为了测试，简单点，只同意张三的请求</span>            <span class="keyword">if</span> (<span class="string">&quot;张三&quot;</span>.equals(user)) &#123;                str = <span class="string">&quot;成功：部门经理同意【&quot;</span> + user + <span class="string">&quot;】的聚餐费用，金额为&quot;</span> + fee + <span class="string">&quot;元&quot;</span>;            &#125; <span class="keyword">else</span> &#123;                <span class="comment">//其他人一律不同意</span>                str = <span class="string">&quot;失败：部门经理不同意【&quot;</span> + user + <span class="string">&quot;】的聚餐费用，金额为&quot;</span> + fee + <span class="string">&quot;元&quot;</span>;            &#125;        &#125; <span class="keyword">else</span> &#123;            <span class="comment">//超过1000，继续传递给级别更高的人处理</span>            <span class="keyword">if</span> (getSuccessor() != <span class="literal">null</span>) &#123;                <span class="keyword">return</span> getSuccessor().handleFeeRequest(user, fee);            &#125;        &#125;        <span class="keyword">return</span> str;    &#125;&#125;<span class="comment">/**</span><span class="comment"> * 具体处理者-总经理</span><span class="comment"> */</span><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">GeneralManager</span> <span class="keyword">extends</span> <span class="title class_">Handler</span> &#123;    <span class="meta">@Override</span>    <span class="keyword">public</span> String <span class="title function_">handleFeeRequest</span><span class="params">(String user, <span class="type">double</span> fee)</span> &#123;        <span class="type">String</span> <span class="variable">str</span> <span class="operator">=</span> <span class="string">&quot;&quot;</span>;        <span class="comment">//总经理的权限很大，只要请求到了这里，他都可以处理</span>        <span class="keyword">if</span> (fee &gt;= <span class="number">1000</span>) &#123;            <span class="comment">//为了测试，简单点，只同意张三的请求</span>            <span class="keyword">if</span> (<span class="string">&quot;张三&quot;</span>.equals(user)) &#123;                str = <span class="string">&quot;成功：总经理同意【&quot;</span> + user + <span class="string">&quot;】的聚餐费用，金额为&quot;</span> + fee + <span class="string">&quot;元&quot;</span>;            &#125; <span class="keyword">else</span> &#123;                <span class="comment">//其他人一律不同意</span>                str = <span class="string">&quot;失败：总经理不同意【&quot;</span> + user + <span class="string">&quot;】的聚餐费用，金额为&quot;</span> + fee + <span class="string">&quot;元&quot;</span>;            &#125;        &#125; <span class="keyword">else</span> &#123;            <span class="comment">//如果还有后继的处理对象，继续传递</span>            <span class="keyword">if</span> (getSuccessor() != <span class="literal">null</span>) &#123;                <span class="keyword">return</span> getSuccessor().handleFeeRequest(user, fee);            &#125;        &#125;        <span class="keyword">return</span> str;    &#125;&#125;<span class="comment">/**</span><span class="comment"> * 测试类</span><span class="comment"> */</span><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Client</span> &#123;    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;        <span class="comment">//先要组装责任链</span>        <span class="type">Handler</span> <span class="variable">h1</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">GeneralManager</span>();        <span class="type">Handler</span> <span class="variable">h2</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">DeptManager</span>();        <span class="type">Handler</span> <span class="variable">h3</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ProjectManager</span>();        h3.setSuccessor(h2);        h2.setSuccessor(h1);        <span class="comment">//开始测试</span>        <span class="type">String</span> <span class="variable">test1</span> <span class="operator">=</span> h3.handleFeeRequest(<span class="string">&quot;张三&quot;</span>, <span class="number">300</span>);        System.out.println(<span class="string">&quot;test1 = &quot;</span> + test1);        <span class="type">String</span> <span class="variable">test2</span> <span class="operator">=</span> h3.handleFeeRequest(<span class="string">&quot;李四&quot;</span>, <span class="number">300</span>);        System.out.println(<span class="string">&quot;test2 = &quot;</span> + test2);        System.out.println(<span class="string">&quot;---------------------------------------&quot;</span>);        <span class="type">String</span> <span class="variable">test3</span> <span class="operator">=</span> h3.handleFeeRequest(<span class="string">&quot;张三&quot;</span>, <span class="number">700</span>);        System.out.println(<span class="string">&quot;test3 = &quot;</span> + test3);        <span class="type">String</span> <span class="variable">test4</span> <span class="operator">=</span> h3.handleFeeRequest(<span class="string">&quot;李四&quot;</span>, <span class="number">700</span>);        System.out.println(<span class="string">&quot;test4 = &quot;</span> + test4);        System.out.println(<span class="string">&quot;---------------------------------------&quot;</span>);        <span class="type">String</span> <span class="variable">test5</span> <span class="operator">=</span> h3.handleFeeRequest(<span class="string">&quot;张三&quot;</span>, <span class="number">1500</span>);        System.out.println(<span class="string">&quot;test5 = &quot;</span> + test5);        <span class="type">String</span> <span class="variable">test6</span> <span class="operator">=</span> h3.handleFeeRequest(<span class="string">&quot;李四&quot;</span>, <span class="number">1500</span>);        System.out.println(<span class="string">&quot;test6 = &quot;</span> + test6);    &#125;&#125;</code></pre><blockquote><p>运行结果：</p><pre><code class="highlight shell">test1 = 成功：项目经理同意【张三】的聚餐费用，金额为300.0元test2 = 失败：项目经理不同意【李四】的聚餐费用，金额为300.0元---------------------------------------test3 = 成功：部门经理同意【张三】的聚餐费用，金额为700.0元test4 = 失败：部门经理不同意【李四】的聚餐费用，金额为700.0元---------------------------------------test5 = 成功：总经理同意【张三】的聚餐费用，金额为1500.0元test6 = 失败：总经理不同意【李四】的聚餐费用，金额为1500.0元</code></pre></blockquote><p>三、纯的与不纯的责任链模式</p><ul><li><p>一个纯的责任链模式要求一个具体的处理者对象只能在两个行为中选择一个：一是承担责任，而是把责任推给下家。不允许出现某一个具体处理者对象在承担了一部分责任后又 把责任向下传的情况。</p></li><li><p>在一个纯的责任链模式里面，一个请求必须被某一个处理者对象所接收；在一个不纯的责任链模式里面，一个请求可以最终不被任何接收端对象所接收。</p></li><li><p>纯的责任链模式的实际例子很难找到，一般看到的例子均是不纯的责任链模式的实现。有些人认为不纯的责任链根本不是责任链模式，这也许是有道理的。但是在实际的系统里，纯的责任链很难找到。如果坚持责任链不纯便不是责任链模式，那么责任链模式便不会有太大意义了。</p></li></ul><p>四、责任链模式在Tomcat中的应用</p><p>众所周知Tomcat中的Filter就是使用了责任链模式，创建一个Filter除了要在web.xml文件中做相应配置外，还需要实现javax.servlet.Filter接口。</p><pre><code class="highlight java"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">TestFilter</span> <span class="keyword">implements</span> <span class="title class_">Filter</span>&#123;    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">doFilter</span><span class="params">(ServletRequest request, ServletResponse response,</span><span class="params">            FilterChain chain)</span> <span class="keyword">throws</span> IOException, ServletException &#123;                chain.doFilter(request, response);    &#125;    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">destroy</span><span class="params">()</span> &#123;    &#125;    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">init</span><span class="params">(FilterConfig filterConfig)</span> <span class="keyword">throws</span> ServletException &#123;    &#125;&#125;</code></pre><p>使用DEBUG模式所看到的结果如下</p><p><img src="https://raw.githubusercontent.com/GeorgeChan95/blogimg/master/img/2024/12/03/20241203-164526.png" alt="Filter责任链"></p><p>其实在真正执行到TestFilter类之前，会经过很多Tomcat内部的类。<strong>顺带提一下其实Tomcat的容器设置也是责任链模式，注意被红色方框所圈中的类，从Engine到Host再到Context一直到Wrapper都是通过一个链传递请求</strong>。被绿色方框所圈中的地方有一个名为ApplicationFilterChain的类，ApplicationFilterChain类所扮演的就是抽象处理者角色，而具体处理者角色由各个Filter扮演。</p><p><em>第一个疑问是ApplicationFilterChain将所有的Filter存放在哪里？</em></p><p>答案是保存在ApplicationFilterChain类中的一个ApplicationFilterConfig对象的数组中。</p><pre><code class="highlight java"><span class="comment">/**</span><span class="comment"> * Filters.</span><span class="comment"> */</span><span class="keyword">private</span> ApplicationFilterConfig[] filters =     <span class="keyword">new</span> <span class="title class_">ApplicationFilterConfig</span>[<span class="number">0</span>];</code></pre><p><em>那ApplicationFilterConfig对象又是什么呢？</em></p><p>ApplicationFilterConfig是一个Filter容器。以下是ApplicationFilterConfig类的声明：</p><pre><code class="highlight java"><span class="comment">/**</span><span class="comment"> * Implementation of a &lt;code&gt;javax.servlet.FilterConfig&lt;/code&gt; useful in</span><span class="comment"> * managing the filter instances instantiated when a web application</span><span class="comment"> * is first started.</span><span class="comment"> *</span><span class="comment"> * <span class="doctag">@author</span> Craig R. McClanahan</span><span class="comment"> * <span class="doctag">@version</span> $Id: ApplicationFilterConfig.java 1201569 2011-11-14 01:36:07Z kkolinko $</span><span class="comment"> */</span></code></pre><p>当一个web应用首次启动时ApplicationFilterConfig会自动实例化，它会从该web应用的web.xml文件中读取配置的Filter的信息，然后装进该容器。</p><p><em>刚刚看到在ApplicationFilterChain类中所创建的ApplicationFilterConfig数组长度为零，那它是在什么时候被重新赋值的呢？</em></p><pre><code class="highlight java"><span class="keyword">private</span> ApplicationFilterConfig[] filters =         <span class="keyword">new</span> <span class="title class_">ApplicationFilterConfig</span>[<span class="number">0</span>];</code></pre><p>是在调用ApplicationFilterChain类的addFilter()方法时。</p><pre><code class="highlight java"><span class="comment">/**</span><span class="comment"> * The int which gives the current number of filters in the chain.</span><span class="comment"> */</span><span class="keyword">private</span> <span class="type">int</span> <span class="variable">n</span> <span class="operator">=</span> <span class="number">0</span>;</code></pre><pre><code class="highlight java"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">int</span> <span class="variable">INCREMENT</span> <span class="operator">=</span> <span class="number">10</span>;</code></pre><pre><code class="highlight java"><span class="keyword">void</span> <span class="title function_">addFilter</span><span class="params">(ApplicationFilterConfig filterConfig)</span> &#123;    <span class="comment">// Prevent the same filter being added multiple times</span>    <span class="keyword">for</span>(ApplicationFilterConfig filter:filters)        <span class="keyword">if</span>(filter==filterConfig)            <span class="keyword">return</span>;    <span class="keyword">if</span> (n == filters.length) &#123;        ApplicationFilterConfig[] newFilters =            <span class="keyword">new</span> <span class="title class_">ApplicationFilterConfig</span>[n + INCREMENT];        System.arraycopy(filters, <span class="number">0</span>, newFilters, <span class="number">0</span>, n);        filters = newFilters;    &#125;    filters[n++] = filterConfig;&#125;</code></pre><p>变量n用来记录当前过滤器链里面拥有的过滤器数目，默认情况下n等于0，ApplicationFilterConfig对象数组的长度也等于0，所以当第一次调用addFilter()方法时，if (n &#x3D;&#x3D; filters.length)的条件成立，ApplicationFilterConfig数组长度被改变。之后filters[n++] &#x3D; filterConfig;将变量filterConfig放入ApplicationFilterConfig数组中并将当前过滤器链里面拥有的过滤器数目+1。</p><p><em>那ApplicationFilterChain的addFilter()方法又是在什么地方被调用的呢？</em></p><p>是在ApplicationFilterFactory类的createFilterChain()方法中。</p><pre><code class="highlight java"><span class="keyword">public</span> ApplicationFilterChain <span class="title function_">createFilterChain</span>        <span class="params">(ServletRequest request, Wrapper wrapper, Servlet servlet)</span> &#123;    <span class="comment">// get the dispatcher type</span>    <span class="type">DispatcherType</span> <span class="variable">dispatcher</span> <span class="operator">=</span> <span class="literal">null</span>;    <span class="keyword">if</span> (request.getAttribute(DISPATCHER_TYPE_ATTR) != <span class="literal">null</span>) &#123;        dispatcher = (DispatcherType) request.getAttribute(DISPATCHER_TYPE_ATTR);    &#125;    <span class="type">String</span> <span class="variable">requestPath</span> <span class="operator">=</span> <span class="literal">null</span>;    <span class="type">Object</span> <span class="variable">attribute</span> <span class="operator">=</span> request.getAttribute(DISPATCHER_REQUEST_PATH_ATTR);    <span class="keyword">if</span> (attribute != <span class="literal">null</span>)&#123;        requestPath = attribute.toString();    &#125;    <span class="comment">// If there is no servlet to execute, return null</span>    <span class="keyword">if</span> (servlet == <span class="literal">null</span>)        <span class="keyword">return</span> (<span class="literal">null</span>);    <span class="type">boolean</span> <span class="variable">comet</span> <span class="operator">=</span> <span class="literal">false</span>;    <span class="comment">// Create and initialize a filter chain object</span>    <span class="type">ApplicationFilterChain</span> <span class="variable">filterChain</span> <span class="operator">=</span> <span class="literal">null</span>;    <span class="keyword">if</span> (request <span class="keyword">instanceof</span> Request) &#123;        <span class="type">Request</span> <span class="variable">req</span> <span class="operator">=</span> (Request) request;        comet = req.isComet();        <span class="keyword">if</span> (Globals.IS_SECURITY_ENABLED) &#123;            <span class="comment">// Security: Do not recycle</span>            filterChain = <span class="keyword">new</span> <span class="title class_">ApplicationFilterChain</span>();            <span class="keyword">if</span> (comet) &#123;                req.setFilterChain(filterChain);            &#125;        &#125; <span class="keyword">else</span> &#123;            filterChain = (ApplicationFilterChain) req.getFilterChain();            <span class="keyword">if</span> (filterChain == <span class="literal">null</span>) &#123;                filterChain = <span class="keyword">new</span> <span class="title class_">ApplicationFilterChain</span>();                req.setFilterChain(filterChain);            &#125;        &#125;    &#125; <span class="keyword">else</span> &#123;        <span class="comment">// Request dispatcher in use</span>        filterChain = <span class="keyword">new</span> <span class="title class_">ApplicationFilterChain</span>();    &#125;    filterChain.setServlet(servlet);    filterChain.setSupport        (((StandardWrapper)wrapper).getInstanceSupport());    <span class="comment">// Acquire the filter mappings for this Context</span>    <span class="type">StandardContext</span> <span class="variable">context</span> <span class="operator">=</span> (StandardContext) wrapper.getParent();    FilterMap filterMaps[] = context.findFilterMaps();    <span class="comment">// If there are no filter mappings, we are done</span>    <span class="keyword">if</span> ((filterMaps == <span class="literal">null</span>) || (filterMaps.length == <span class="number">0</span>))        <span class="keyword">return</span> (filterChain);    <span class="comment">// Acquire the information we will need to match filter mappings</span>    <span class="type">String</span> <span class="variable">servletName</span> <span class="operator">=</span> wrapper.getName();    <span class="comment">// Add the relevant path-mapped filters to this filter chain</span>    <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; filterMaps.length; i++) &#123;        <span class="keyword">if</span> (!matchDispatcher(filterMaps[i] ,dispatcher)) &#123;            <span class="keyword">continue</span>;        &#125;        <span class="keyword">if</span> (!matchFiltersURL(filterMaps[i], requestPath))            <span class="keyword">continue</span>;        <span class="type">ApplicationFilterConfig</span> <span class="variable">filterConfig</span> <span class="operator">=</span> (ApplicationFilterConfig)            context.findFilterConfig(filterMaps[i].getFilterName());        <span class="keyword">if</span> (filterConfig == <span class="literal">null</span>) &#123;            <span class="comment">// FIXME - log configuration problem</span>            <span class="keyword">continue</span>;        &#125;        <span class="type">boolean</span> <span class="variable">isCometFilter</span> <span class="operator">=</span> <span class="literal">false</span>;        <span class="keyword">if</span> (comet) &#123;            <span class="keyword">try</span> &#123;                isCometFilter = filterConfig.getFilter() <span class="keyword">instanceof</span> CometFilter;            &#125; <span class="keyword">catch</span> (Exception e) &#123;                <span class="comment">// Note: The try catch is there because getFilter has a lot of</span>                <span class="comment">// declared exceptions. However, the filter is allocated much</span>                <span class="comment">// earlier</span>                <span class="type">Throwable</span> <span class="variable">t</span> <span class="operator">=</span> ExceptionUtils.unwrapInvocationTargetException(e);                ExceptionUtils.handleThrowable(t);            &#125;            <span class="keyword">if</span> (isCometFilter) &#123;                filterChain.addFilter(filterConfig);            &#125;        &#125; <span class="keyword">else</span> &#123;            filterChain.addFilter(filterConfig);        &#125;    &#125;    <span class="comment">// Add filters that match on servlet name second</span>    <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; filterMaps.length; i++) &#123;        <span class="keyword">if</span> (!matchDispatcher(filterMaps[i] ,dispatcher)) &#123;            <span class="keyword">continue</span>;        &#125;        <span class="keyword">if</span> (!matchFiltersServlet(filterMaps[i], servletName))            <span class="keyword">continue</span>;        <span class="type">ApplicationFilterConfig</span> <span class="variable">filterConfig</span> <span class="operator">=</span> (ApplicationFilterConfig)            context.findFilterConfig(filterMaps[i].getFilterName());        <span class="keyword">if</span> (filterConfig == <span class="literal">null</span>) &#123;            <span class="comment">// FIXME - log configuration problem</span>            <span class="keyword">continue</span>;        &#125;        <span class="type">boolean</span> <span class="variable">isCometFilter</span> <span class="operator">=</span> <span class="literal">false</span>;        <span class="keyword">if</span> (comet) &#123;            <span class="keyword">try</span> &#123;                isCometFilter = filterConfig.getFilter() <span class="keyword">instanceof</span> CometFilter;            &#125; <span class="keyword">catch</span> (Exception e) &#123;                <span class="comment">// Note: The try catch is there because getFilter has a lot of</span>                <span class="comment">// declared exceptions. However, the filter is allocated much</span>                <span class="comment">// earlier</span>            &#125;            <span class="keyword">if</span> (isCometFilter) &#123;                filterChain.addFilter(filterConfig);            &#125;        &#125; <span class="keyword">else</span> &#123;            filterChain.addFilter(filterConfig);        &#125;    &#125;    <span class="comment">// Return the completed filter chain</span>    <span class="keyword">return</span> (filterChain);&#125;</code></pre><p>可以将如上代码分为两段，51行之前为第一段( <code>StandardContext context = (StandardContext) wrapper.getParent();</code> )，51行之后为第二段。</p><p>第一段的主要目的是创建ApplicationFilterChain对象以及一些参数设置。</p><p>第二段的主要目的是从上下文中获取所有Filter信息，之后使用for循环遍历并调用 <code>filterChain.addFilter(filterConfig);</code> 将filterConfig放入ApplicationFilterChain对象的ApplicationFilterConfig数组中。</p><p>那ApplicationFilterFactory类的createFilterChain()方法又是在什么地方被调用的呢？</p><p>是在StandardWrapperValue类的invoke()方法中被调用的。</p><p><img src="https://raw.githubusercontent.com/GeorgeChan95/blogimg/master/img/2024/12/03/20241203-165319.png" alt="StandardWrapperValue"></p><p>由于invoke()方法较长，所以将很多地方省略。</p><pre><code class="highlight java"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">void</span> <span class="title function_">invoke</span><span class="params">(Request request, Response response)</span>        <span class="keyword">throws</span> IOException, ServletException &#123;...省略中间代码　　　　 <span class="comment">// Create the filter chain for this request</span>    <span class="type">ApplicationFilterFactory</span> <span class="variable">factory</span> <span class="operator">=</span>        ApplicationFilterFactory.getInstance();    <span class="type">ApplicationFilterChain</span> <span class="variable">filterChain</span> <span class="operator">=</span>        factory.createFilterChain(request, wrapper, servlet);...省略中间代码     filterChain.doFilter(request.getRequest(), response.getResponse());...省略中间代码&#125;</code></pre><p>那正常的流程应该是这样的：</p><p>在<code>StandardWrapperValue</code>类的<code>invoke()</code>方法中调用<code>ApplicationFilterChai</code>类的<code>createFilterChain()</code>方法———&gt;在<code>ApplicationFilterChai</code>类的<code>createFilterChain()</code>方法中调用<code>ApplicationFilterChain</code>类的<code>addFilter()</code>方法———&gt;在<code>ApplicationFilterChain</code>类的<code>addFilter()</code>方法中给<code>ApplicationFilterConfig</code>数组赋值。</p><p><img src="https://raw.githubusercontent.com/GeorgeChan95/blogimg/master/img/2024/12/03/20241203-165514.png" alt="调用流程"></p><p>根据上面的代码可以看出StandardWrapperValue类的invoke()方法在执行完createFilterChain()方法后，会继续执行ApplicationFilterChain类的doFilter()方法，然后在doFilter()方法中会调用internalDoFilter()方法。</p><p>以下是internalDoFilter()方法的部分代码</p><pre><code class="highlight java"><span class="comment">// Call the next filter if there is one</span><span class="keyword">if</span> (pos &lt; n) &#123;　　　　　　　<span class="comment">//拿到下一个Filter，将指针向下移动一位            //pos它来标识当前ApplicationFilterChain（当前过滤器链）执行到哪个过滤器</span>    <span class="type">ApplicationFilterConfig</span> <span class="variable">filterConfig</span> <span class="operator">=</span> filters[pos++];    <span class="type">Filter</span> <span class="variable">filter</span> <span class="operator">=</span> <span class="literal">null</span>;    <span class="keyword">try</span> &#123;　　　　　　　　　 <span class="comment">//获取当前指向的Filter的实例</span>        filter = filterConfig.getFilter();        support.fireInstanceEvent(InstanceEvent.BEFORE_FILTER_EVENT,                                  filter, request, response);        <span class="keyword">if</span> (request.isAsyncSupported() &amp;&amp; <span class="string">&quot;false&quot;</span>.equalsIgnoreCase(                filterConfig.getFilterDef().getAsyncSupported())) &#123;            request.setAttribute(Globals.ASYNC_SUPPORTED_ATTR,                    Boolean.FALSE);        &#125;        <span class="keyword">if</span>( Globals.IS_SECURITY_ENABLED ) &#123;            <span class="keyword">final</span> <span class="type">ServletRequest</span> <span class="variable">req</span> <span class="operator">=</span> request;            <span class="keyword">final</span> <span class="type">ServletResponse</span> <span class="variable">res</span> <span class="operator">=</span> response;            <span class="type">Principal</span> <span class="variable">principal</span> <span class="operator">=</span>                 ((HttpServletRequest) req).getUserPrincipal();            Object[] args = <span class="keyword">new</span> <span class="title class_">Object</span>[]&#123;req, res, <span class="built_in">this</span>&#125;;            SecurityUtil.doAsPrivilege                (<span class="string">&quot;doFilter&quot;</span>, filter, classType, args, principal);        &#125; <span class="keyword">else</span> &#123;　　　　　　　　　　　　<span class="comment">//调用Filter的doFilter()方法  </span>            filter.doFilter(request, response, <span class="built_in">this</span>);        &#125;</code></pre><p>这里的filter.doFilter(request, response, this);就是调用我们前面创建的TestFilter中的doFilter()方法。而TestFilter中的doFilter()方法会继续调用chain.doFilter(request, response);方法，而这个chain其实就是ApplicationFilterChain,所以调用过程又回到了上面调用dofilter和调用internalDoFilter方法，这样执行直到里面的过滤器全部执行。</p><p>如果定义两个过滤器，则Debug结果如下：</p><p><img src="https://raw.githubusercontent.com/GeorgeChan95/blogimg/master/img/2024/12/03/20241203-165659.png" alt="Debug"></p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;&lt;strong&gt;责任链模式是一种对象的行为模式。在责任链模式里，很多对象由每一个对象对其下家的引用而连接起来形成一条链。请求在这个链上传递，直到链上的某一个对象决定处理此请求。发出这个请求的客户端并不知道链上的哪一个对象最终处理这个请求，这使得系统可以在不影响客户端的情况下</summary>
      
    
    
    
    <category term="设计模式" scheme="https://georgechan95.github.io/categories/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"/>
    
    
    <category term="设计模式" scheme="https://georgechan95.github.io/tags/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"/>
    
  </entry>
  
  <entry>
    <title>24-策略模式</title>
    <link href="https://georgechan95.github.io/blog/fcec839d.html"/>
    <id>https://georgechan95.github.io/blog/fcec839d.html</id>
    <published>2024-12-02T10:16:00.000Z</published>
    <updated>2024-12-03T05:08:38.752Z</updated>
    
    <content type="html"><![CDATA[<p><strong>策略模式属于对象的行为模式。其用意是针对一组算法，将每一个算法封装到具有共同接口的独立的类中，从而使得它们可以相互替换。策略模式使得算法可以在不影响到客户端的情况下发生变化。</strong></p><h1 id="一、策略模式的结构"><a href="#一、策略模式的结构" class="headerlink" title="一、策略模式的结构"></a>一、策略模式的结构</h1><p>策略模式是对算法的包装，是把使用算法的责任和算法本身分割开来，委派给不同的对象管理。策略模式通常把一个系列的算法包装到一系列的策略类里面，作为一个抽象策略类的子类。用一句话来说，就是：“准备一组算法，并将每一个算法封装起来，使得它们可以互换”。下面就以一个示意性的实现讲解策略模式实例的结构。</p><p><img src="https://raw.githubusercontent.com/GeorgeChan95/blogimg/master/img/2024/12/03/20241203-123412.png" alt="策略模式结构"></p><p>这个模式涉及到三个角色：</p><ul><li><strong>环境(Context)角色：</strong>持有一个Strategy的引用。</li><li><strong>抽象策略(Strategy)角色：</strong>这是一个抽象角色，通常由一个接口或抽象类实现。此角色给出所有的具体策略类所需的接口。</li><li><strong>具体策略(ConcreteStrategy)角色：</strong>包装了相关的算法或行为。</li></ul><p><strong>代码实现如下：</strong></p><pre><code class="highlight java"><span class="comment">/**</span><span class="comment"> * 环境角色类</span><span class="comment"> */</span><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Context</span> &#123;    <span class="comment">// 持有一个具体的策略对象</span>    <span class="keyword">private</span> Strategy strategy;    <span class="keyword">public</span> <span class="title function_">Context</span><span class="params">(Strategy strategy)</span> &#123;        <span class="built_in">this</span>.strategy = strategy;    &#125;    <span class="comment">/**</span><span class="comment">     * 调用策略方法</span><span class="comment">     */</span>    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">contextInterface</span><span class="params">()</span> &#123;        strategy.strategyInterface();    &#125;&#125;<span class="comment">/**</span><span class="comment"> * 抽象策略类</span><span class="comment"> */</span><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">Strategy</span> &#123;    <span class="comment">/**</span><span class="comment">     * 策略方法</span><span class="comment">     */</span>    <span class="keyword">void</span> <span class="title function_">strategyInterface</span><span class="params">()</span>;&#125;<span class="comment">/**</span><span class="comment"> * 具体策略类</span><span class="comment"> */</span><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ConcreteStrategyA</span> <span class="keyword">implements</span> <span class="title class_">Strategy</span> &#123;    <span class="meta">@Override</span>    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">strategyInterface</span><span class="params">()</span> &#123;    &#125;&#125;<span class="comment">/**</span><span class="comment"> * 具体策略类</span><span class="comment"> */</span><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ConcreteStrategyB</span> <span class="keyword">implements</span> <span class="title class_">Strategy</span> &#123;    <span class="meta">@Override</span>    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">strategyInterface</span><span class="params">()</span> &#123;    &#125;&#125;<span class="comment">/**</span><span class="comment"> * 具体策略类</span><span class="comment"> */</span><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ConcreteStrategyC</span> <span class="keyword">implements</span> <span class="title class_">Strategy</span> &#123;    <span class="meta">@Override</span>    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">strategyInterface</span><span class="params">()</span> &#123;    &#125;&#125;</code></pre><h1 id="二、使用场景"><a href="#二、使用场景" class="headerlink" title="二、使用场景"></a>二、使用场景</h1><p>假设现在要设计一个贩卖各类书籍的电子商务网站的购物车系统。一个最简单的情况就是把所有货品的单价乘上数量，但是实际情况肯定比这要复杂。比如，本网站可能对所有的高级会员提供每本20%的促销折扣；对中级会员提供每本10%的促销折扣；对初级会员没有折扣。</p><p>根据描述，折扣是根据以下的几个算法中的一个进行的：</p><ul><li>算法一：对初级会员没有折扣。</li><li>算法二：对中级会员提供10%的促销折扣。</li><li>算法三：对高级会员提供20%的促销折扣。</li></ul><p>使用策略模式来实现的结构图如下：</p><p><img src="https://raw.githubusercontent.com/GeorgeChan95/blogimg/master/img/2024/12/03/20241203-125237.png" alt="策略模式UML"></p><p><strong>代码实现如下：</strong></p><pre><code class="highlight java"><span class="comment">/**</span><span class="comment"> * 抽象折扣类</span><span class="comment"> */</span><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">MemberStrategy</span> &#123;    <span class="comment">/**</span><span class="comment">     * 计算图书的价格</span><span class="comment">     * <span class="doctag">@param</span> booksPrice 图书的原价</span><span class="comment">     * <span class="doctag">@return</span> 计算出打折后的价格</span><span class="comment">     */</span>    <span class="type">double</span> <span class="title function_">calcPrice</span><span class="params">(<span class="type">double</span> booksPrice)</span>;&#125;<span class="comment">/**</span><span class="comment"> * 初级会员折扣类</span><span class="comment"> */</span><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">PrimaryMemberStrategy</span> <span class="keyword">implements</span> <span class="title class_">MemberStrategy</span> &#123;    <span class="meta">@Override</span>    <span class="keyword">public</span> <span class="type">double</span> <span class="title function_">calcPrice</span><span class="params">(<span class="type">double</span> booksPrice)</span> &#123;        System.out.println(<span class="string">&quot;对于初级会员的没有折扣&quot;</span>);        <span class="keyword">return</span> booksPrice;    &#125;&#125;<span class="comment">/**</span><span class="comment"> * 中级会员折扣类</span><span class="comment"> */</span><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">IntermediateMemberStrategy</span> <span class="keyword">implements</span> <span class="title class_">MemberStrategy</span> &#123;    <span class="meta">@Override</span>    <span class="keyword">public</span> <span class="type">double</span> <span class="title function_">calcPrice</span><span class="params">(<span class="type">double</span> booksPrice)</span> &#123;        System.out.println(<span class="string">&quot;对于中级会员的折扣为10%&quot;</span>);        <span class="keyword">return</span> booksPrice * <span class="number">0.9</span>;    &#125;&#125;<span class="comment">/**</span><span class="comment"> * 高级会员折扣类</span><span class="comment"> */</span><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">AdvancedMemberStrategy</span> <span class="keyword">implements</span> <span class="title class_">MemberStrategy</span> &#123;    <span class="meta">@Override</span>    <span class="keyword">public</span> <span class="type">double</span> <span class="title function_">calcPrice</span><span class="params">(<span class="type">double</span> booksPrice)</span> &#123;        System.out.println(<span class="string">&quot;对于高级会员的折扣为20%&quot;</span>);        <span class="keyword">return</span> booksPrice * <span class="number">0.8</span>;    &#125;&#125;<span class="comment">/**</span><span class="comment"> * 价格计算类</span><span class="comment"> */</span><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Price</span> &#123;    <span class="comment">// 持有一个具体的策略对象</span>    <span class="keyword">private</span> MemberStrategy memberStrategy;    <span class="keyword">public</span> <span class="title function_">Price</span><span class="params">(MemberStrategy memberStrategy)</span> &#123;        <span class="built_in">this</span>.memberStrategy = memberStrategy;    &#125;    <span class="comment">/**</span><span class="comment">     * 计算图书的价格</span><span class="comment">     * <span class="doctag">@param</span> booksPrice 图书的原价</span><span class="comment">     * <span class="doctag">@return</span> 计算出打折后的价格</span><span class="comment">     */</span>    <span class="keyword">public</span> <span class="type">double</span> <span class="title function_">quote</span><span class="params">(<span class="type">double</span> booksPrice)</span> &#123;        <span class="keyword">return</span> <span class="built_in">this</span>.memberStrategy.calcPrice(booksPrice);    &#125;&#125;<span class="comment">/**</span><span class="comment"> * 测试类</span><span class="comment"> */</span><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Client</span> &#123;    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;        <span class="comment">//选择并创建需要使用的策略对象</span>        <span class="type">MemberStrategy</span> <span class="variable">strategy</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">AdvancedMemberStrategy</span>();        <span class="comment">//创建环境</span>        <span class="type">Price</span> <span class="variable">price</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Price</span>(strategy);        <span class="comment">//计算价格</span>        <span class="type">double</span> <span class="variable">quote</span> <span class="operator">=</span> price.quote(<span class="number">300</span>);        System.out.println(<span class="string">&quot;图书的最终价格为：&quot;</span> + quote);    &#125;&#125;</code></pre><blockquote><p>运行结果：</p><pre><code class="highlight shell">对于高级会员的折扣为20%图书的最终价格为：240.0</code></pre></blockquote><p>从上面的示例可以看出，策略模式仅仅封装算法，提供新的算法插入到已有系统中，以及老算法从系统中“退休”的方法，策略模式并不决定在何时使用何种算法。在什么情况下使用什么算法是由客户端决定的。</p><h1 id="三、认识策略模式"><a href="#三、认识策略模式" class="headerlink" title="三、认识策略模式"></a>三、认识策略模式</h1><ul><li><p><strong>策略模式的重心</strong></p><p>策略模式的重心不是如何实现算法，而是如何组织、调用这些算法，从而让程序结构更灵活，具有更好的维护性和扩展性。</p></li><li><p><strong>算法的平等性</strong></p><p>策略模式一个很大的特点就是各个策略算法的平等性。对于一系列具体的策略算法，大家的地位是完全一样的，正因为这个平等性，才能实现算法之间可以相互替换。所有的策略算法在实现上也是相互独立的，相互之间是没有依赖的。</p><p>所以可以这样描述这一系列策略算法：策略算法是相同行为的不同实现。</p></li><li><p><strong>运行时策略的唯一性</strong></p><p>运行期间，策略模式在每一个时刻只能使用一个具体的策略实现对象，虽然可以动态地在不同的策略实现中切换，但是同时只能使用一个。</p></li><li><p><strong>公有的行为</strong></p><p>经常见到的是，所有的具体策略类都有一些公有的行为。这时候，就应当把这些公有的行为放到共同的抽象策略角色Strategy类里面。当然这时候抽象策略角色必须要用Java抽象类实现，而不能使用接口。</p><p>这其实也是典型的将代码向继承等级结构的上方集中的标准做法。</p><p><img src="https://raw.githubusercontent.com/GeorgeChan95/blogimg/master/img/2024/12/03/20241203-130623.png" alt="使用抽象类实现共有行为"></p></li></ul><h1 id="四、策略模式的优-缺点"><a href="#四、策略模式的优-缺点" class="headerlink" title="四、策略模式的优&#x2F;缺点"></a>四、策略模式的优&#x2F;缺点</h1><ul><li>优点<ul><li>策略模式提供了管理相关的算法族的办法。策略类的等级结构定义了一个算法或行为族。恰当使用继承可以把公共的代码移到父类里面，从而避免代码重复。</li><li>使用策略模式可以避免使用多重条件(if-else)语句。多重条件语句不易维护，它把采取哪一种算法或采取哪一种行为的逻辑与算法或行为的逻辑混合在一起，统统列在一个多重条件语句里面，比使用继承的办法还要原始和落后</li></ul></li><li>缺点<ul><li>客户端必须知道所有的策略类，并自行决定使用哪一个策略类。这就意味着客户端必须理解这些算法的区别，以便适时选择恰当的算法类。换言之，策略模式只适用于客户端知道算法或行为的情况。</li><li>由于策略模式把每个具体的策略实现都单独封装成为类，如果备选的策略很多的话，那么对象的数目就会很可观。</li></ul></li></ul>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;&lt;strong&gt;策略模式属于对象的行为模式。其用意是针对一组算法，将每一个算法封装到具有共同接口的独立的类中，从而使得它们可以相互替换。策略模式使得算法可以在不影响到客户端的情况下发生变化。&lt;/strong&gt;&lt;/p&gt;
&lt;h1 id=&quot;一、策略模式的结构&quot;&gt;&lt;a href=&quot;</summary>
      
    
    
    
    <category term="设计模式" scheme="https://georgechan95.github.io/categories/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"/>
    
    
    <category term="设计模式" scheme="https://georgechan95.github.io/tags/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"/>
    
  </entry>
  
  <entry>
    <title>23-状态模式</title>
    <link href="https://georgechan95.github.io/blog/6109865a.html"/>
    <id>https://georgechan95.github.io/blog/6109865a.html</id>
    <published>2024-11-29T11:30:00.000Z</published>
    <updated>2024-11-30T09:49:58.580Z</updated>
    
    <content type="html"><![CDATA[<p><strong>状态模式，又称状态对象模式（Pattern of Objects for States），状态模式是对象的行为模式。</strong></p><p><strong>状态模式允许一个对象在其内部状态改变的时候改变其行为。这个对象看上去就像是改变了它的类一样。</strong></p><h1 id="一、状态模式的结构"><a href="#一、状态模式的结构" class="headerlink" title="一、状态模式的结构"></a>一、状态模式的结构</h1><p>用一句话来表述，状态模式把所研究的对象的行为包装在不同的状态对象里，每一个状态对象都属于一个抽象状态类的一个子类。状态模式的意图是让一个对象在其内部状态改变的时候，其行为也随之改变。状态模式的示意性类图如下所示：</p><p><img src="https://raw.githubusercontent.com/GeorgeChan95/blogimg/master/img/2024/11/30/20241130-164732.png" alt="状态模式结构"></p><p>状态模式所涉及到的角色有：</p><ul><li>环境(Context)角色，也称上下文：定义客户端所感兴趣的接口，并且保留一个具体状态类的实例。这个具体状态类的实例给出此环境对象的现有状态。</li><li>抽象状态(State)角色：定义一个接口，用以封装环境（Context）对象的一个特定的状态所对应的行为。</li><li>具体状态(ConcreteState)角色：每一个具体状态类都实现了环境（Context）的一个状态所对应的行为。</li></ul><p><strong>代码实现如下：</strong></p><pre><code class="highlight java"><span class="comment">/**</span><span class="comment"> * 抽象状态接口, 定义具体状态类共用的处理方法</span><span class="comment"> */</span><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">State</span> &#123;    <span class="comment">/**</span><span class="comment">     * 状态对应的处理</span><span class="comment">     * <span class="doctag">@param</span> sampleParameter 相同的参数</span><span class="comment">     */</span>    <span class="keyword">void</span> <span class="title function_">handle</span><span class="params">(String sampleParameter)</span>;&#125;<span class="comment">/***</span><span class="comment"> * 环境角色类， 当内部状态（state）改变的时候，行为（request）也发生了改变</span><span class="comment"> */</span><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Context</span> &#123;    <span class="comment">// 持有一个State类型的对象实例</span>    <span class="keyword">private</span> State state;    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setState</span><span class="params">(State state)</span> &#123;        <span class="built_in">this</span>.state = state;    &#125;    <span class="comment">/**</span><span class="comment">     * 请求的方法</span><span class="comment">     * <span class="doctag">@param</span> sampleParameter</span><span class="comment">     */</span>    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">request</span><span class="params">(String sampleParameter)</span> &#123;        state.handle(sampleParameter);    &#125;&#125;<span class="comment">/**</span><span class="comment"> * 具体状态类A</span><span class="comment"> */</span><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ConcreteStateA</span> <span class="keyword">implements</span> <span class="title class_">State</span> &#123;    <span class="meta">@Override</span>    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">handle</span><span class="params">(String sampleParameter)</span> &#123;        System.out.println(<span class="string">&quot;ConcreteStateA handle : &quot;</span> + sampleParameter);    &#125;&#125;<span class="comment">/**</span><span class="comment"> * 具体状态类B</span><span class="comment"> */</span><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ConcreteStateB</span> <span class="keyword">implements</span> <span class="title class_">State</span> &#123;    <span class="meta">@Override</span>    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">handle</span><span class="params">(String sampleParameter)</span> &#123;        System.out.println(<span class="string">&quot;ConcreteStateB handle : &quot;</span> + sampleParameter);    &#125;&#125;<span class="comment">/**</span><span class="comment"> * 测试类</span><span class="comment"> */</span><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Client</span> &#123;    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;        <span class="comment">// 创建一个State对象</span>        <span class="type">State</span> <span class="variable">state</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ConcreteStateA</span>();        <span class="comment">// 创建环境</span>        <span class="type">Context</span> <span class="variable">context</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Context</span>();        <span class="comment">// 将状态设置到环境中</span>        context.setState(state);        <span class="comment">// 调用请求</span>        context.request(<span class="string">&quot;param A&quot;</span>);    &#125;&#125;</code></pre><blockquote><p>运行结果：</p><pre><code class="highlight shell">ConcreteStateA handle : param A</code></pre></blockquote><p>从上面可以看出，环境类 <code>Context</code> 的行为<code>request()</code>是委派给某一个具体状态类的。通过使用多态性原则，可以动态改变环境类<code>Context</code>的属性<code>State</code>的内容，使其从指向一个具体状态类变换到指向另一个具体状态类，从而使环境类的行为<code>request(</code>)由不同的具体状态类来执行。</p><h1 id="二、使用场景"><a href="#二、使用场景" class="headerlink" title="二、使用场景"></a>二、使用场景</h1><p>考虑一个在线投票系统的应用，要实现控制同一个用户只能投一票，如果一个用户反复投票，而且投票次数超过5次，则判定为恶意刷票，要取消该用户投票的资格，当然同时也要取消他所投的票；如果一个用户的投票次数超过8次，将进入黑名单，禁止再登录和使用系统。</p><p>要使用状态模式实现，首先需要把投票过程的各种状态定义出来，根据以上描述大致分为四种状态：正常投票、反复投票、恶意刷票、进入黑名单。然后创建一个投票管理对象（相当于Context）。</p><p>系统的结构图如下所示：</p><p><img src="https://raw.githubusercontent.com/GeorgeChan95/blogimg/master/img/2024/11/30/20241130-172729.png" alt="状态模式UML"></p><p><strong>代码实现如下：</strong></p><pre><code class="highlight java"><span class="comment">/**</span><span class="comment"> * 抽象状态类</span><span class="comment"> */</span><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">VoteState</span> &#123;    <span class="comment">/**</span><span class="comment">     * 不同状态共有的投票方法</span><span class="comment">     * <span class="doctag">@param</span> user 投票人</span><span class="comment">     * <span class="doctag">@param</span> voteItem 投票项目</span><span class="comment">     * <span class="doctag">@param</span> voteManager 投票上下文，用来在实现状态对应的功能处理的时候，可以回调上下文的数据</span><span class="comment">     */</span>    <span class="keyword">void</span> <span class="title function_">vote</span><span class="params">(String user, String voteItem, VoteManager voteManager)</span>;&#125;<span class="comment">/**</span><span class="comment"> * 具体状态：正常投票</span><span class="comment"> */</span><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">NormalVoteState</span> <span class="keyword">implements</span> <span class="title class_">VoteState</span> &#123;    <span class="meta">@Override</span>    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">vote</span><span class="params">(String user, String voteItem, VoteManager voteManager)</span> &#123;        <span class="comment">//正常投票，记录到投票记录中</span>        Map&lt;String, String&gt; mapVote = voteManager.getMapVote();        mapVote.put(user, voteItem);        System.out.println(<span class="string">&quot;投票成功&quot;</span>);    &#125;&#125;<span class="comment">/**</span><span class="comment"> * 具体状态：重复投票</span><span class="comment"> */</span><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">RepeatVoteState</span> <span class="keyword">implements</span> <span class="title class_">VoteState</span> &#123;    <span class="meta">@Override</span>    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">vote</span><span class="params">(String user, String voteItem, VoteManager voteManager)</span> &#123;        System.out.println(<span class="string">&quot;请不要重复投票&quot;</span>);    &#125;&#125;<span class="comment">/**</span><span class="comment"> * 具体状态：恶意刷票</span><span class="comment"> */</span><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">SpiteVoteState</span> <span class="keyword">implements</span> <span class="title class_">VoteState</span> &#123;    <span class="meta">@Override</span>    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">vote</span><span class="params">(String user, String voteItem, VoteManager voteManager)</span> &#123;        Map&lt;String, String&gt; mapVote = voteManager.getMapVote();        <span class="keyword">if</span> (mapVote.get(user) != <span class="literal">null</span>) &#123;            mapVote.remove(user);        &#125;        System.out.println(<span class="string">&quot;你有恶意刷屏行为，取消投票资格&quot;</span>);    &#125;&#125;<span class="comment">/**</span><span class="comment"> * 具体状态类：进入黑名单</span><span class="comment"> */</span><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">BlackVoteState</span> <span class="keyword">implements</span> <span class="title class_">VoteState</span> &#123;    <span class="meta">@Override</span>    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">vote</span><span class="params">(String user, String voteItem, VoteManager voteManager)</span> &#123;        <span class="comment">//记录黑名单中，禁止登录系统</span>        System.out.println(<span class="string">&quot;进入黑名单，将禁止登录和使用本系统&quot;</span>);    &#125;&#125;<span class="comment">/**</span><span class="comment"> * 环境类</span><span class="comment"> */</span><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">VoteManager</span> &#123;    <span class="comment">// 持有的状态处理对象</span>    <span class="keyword">private</span> <span class="type">VoteState</span> <span class="variable">state</span> <span class="operator">=</span> <span class="literal">null</span>;    <span class="comment">// 记录用户投票的结果，Map&lt;String,String&gt;对应Map&lt;用户名称，投票的选项&gt;</span>    <span class="keyword">private</span> Map&lt;String, String&gt; mapVote = <span class="keyword">new</span> <span class="title class_">HashMap</span>&lt;&gt;();    <span class="comment">// 记录用户投票次数，Map&lt;String,Integer&gt;对应Map&lt;用户名称，投票的次数&gt;</span>    <span class="keyword">private</span> Map&lt;String, Integer&gt; mapVoteCount = <span class="keyword">new</span> <span class="title class_">HashMap</span>&lt;&gt;();    <span class="comment">/**</span><span class="comment">     * 获取用户投票结果的Map</span><span class="comment">     */</span>    <span class="keyword">public</span> Map&lt;String, String&gt; <span class="title function_">getMapVote</span><span class="params">()</span> &#123;        <span class="keyword">return</span> mapVote;    &#125;    <span class="comment">/**</span><span class="comment">     * 投票方法</span><span class="comment">     *</span><span class="comment">     * <span class="doctag">@param</span> user     投票人</span><span class="comment">     * <span class="doctag">@param</span> voteItem 投票项</span><span class="comment">     */</span>    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">vote</span><span class="params">(String user, String voteItem)</span> &#123;        <span class="comment">// 1.为该用户增加投票次数</span>        <span class="type">Integer</span> <span class="variable">voteCount</span> <span class="operator">=</span> mapVoteCount.get(user);        <span class="keyword">if</span> (voteCount == <span class="literal">null</span>) &#123;            voteCount = <span class="number">0</span>;        &#125;        voteCount++;        mapVoteCount.put(user, voteCount);        <span class="comment">// 2.判断该用户的投票类型，就相当于判断对应的状态</span>        <span class="keyword">if</span> (voteCount == <span class="number">1</span>) &#123; <span class="comment">// 正常投票</span>            state = <span class="keyword">new</span> <span class="title class_">NormalVoteState</span>();        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (voteCount &gt; <span class="number">1</span> &amp;&amp; voteCount &lt; <span class="number">5</span>) &#123; <span class="comment">// 重复投票</span>            state = <span class="keyword">new</span> <span class="title class_">RepeatVoteState</span>();        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (voteCount &gt;= <span class="number">5</span> &amp;&amp; voteCount &lt; <span class="number">8</span>) &#123; <span class="comment">// 恶意刷票</span>            state = <span class="keyword">new</span> <span class="title class_">SpiteVoteState</span>();        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (voteCount &gt; <span class="number">8</span>) &#123; <span class="comment">// 黑名单</span>            state = <span class="keyword">new</span> <span class="title class_">BlackVoteState</span>();        &#125;        <span class="comment">// 调用状态接口方法，进行投票</span>        state.vote(user, voteItem, <span class="built_in">this</span>);    &#125;&#125;<span class="comment">/**</span><span class="comment"> * 测试类</span><span class="comment"> */</span><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Client</span> &#123;    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;        <span class="type">VoteManager</span> <span class="variable">vm</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">VoteManager</span>();        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; <span class="number">9</span>; i++) &#123;            vm.vote(<span class="string">&quot;George&quot;</span>, <span class="string">&quot;A&quot;</span>);        &#125;    &#125;&#125;</code></pre><blockquote><p>运行结果：</p><pre><code class="highlight shell">投票成功请不要重复投票请不要重复投票请不要重复投票你有恶意刷屏行为，取消投票资格你有恶意刷屏行为，取消投票资格你有恶意刷屏行为，取消投票资格你有恶意刷屏行为，取消投票资格进入黑名单，将禁止登录和使用本系统</code></pre></blockquote><p>从上面的示例可以看出，状态的转换基本上都是内部行为，主要在状态模式内部来维护。比如对于投票的人员，任何时候他的操作都是投票，但是投票管理对象的处理却不一定一样，会根据投票的次数来判断状态，然后根据状态去选择不同的处理。</p><h1 id="三、认识状态模式"><a href="#三、认识状态模式" class="headerlink" title="三、认识状态模式"></a>三、认识状态模式</h1><ul><li><p><strong>状态和行为</strong></p><p>所谓对象的状态，通常指的就是对象实例的属性的值；而行为指的就是对象的功能，再具体点说，行为大多可以对应到方法上。</p><p>状态模式的功能就是分离状态的行为，通过维护状态的变化，来调用不同状态对应的不同功能。也就是说，状态和行为是相关联的，它们的关系可以描述为：<strong>状态决定行为</strong>。</p><p>由于状态是在运行期被改变的，因此行为也会在运行期根据状态的改变而改变。</p></li><li><p><strong>行为的平行性</strong></p><p>注意平行线而不是平等性。所谓平行性指的是各个状态的行为所处的层次是一样的，相互独立的、没有关联的，是根据不同的状态来决定到底走平行线的哪一条。行为是不同的，当然对应的实现也是不同的，相互之间是不可替换的。</p><p><img src="https://raw.githubusercontent.com/GeorgeChan95/blogimg/master/img/2024/11/30/20241130-174703.png" alt="状态的平行性示意图"></p><p>而平等性强调的是可替换性，大家是同一行为的不同描述或实现，因此在同一个行为发生的时候，可以根据条件挑选任意一个实现来进行相应的处理。</p><p><img src="https://raw.githubusercontent.com/GeorgeChan95/blogimg/master/img/2024/11/30/20241130-174758.png" alt="平等性"></p><p>大家可能会发现状态模式的结构和策略模式的结构完全一样，但是，它们的目的、实现、本质却是完全不一样的。还有行为之间的特性也是状态模式和策略模式一个很重要的区别，状态模式的行为是平行性的，不可相互替换的；而策略模式的行为是平等性的，是可以相互替换的。</p></li><li><p><strong>环境和状态处理对象</strong></p><ul><li>在状态模式中，环境(Context)是持有状态的对象，但是环境(Context)自身并不处理跟状态相关的行为，而是把处理状态的功能委托给了状态对应的状态处理类来处理。</li><li>在具体的状态处理类中经常需要获取环境(Context)自身的数据，甚至在必要的时候会回调环境(Context)的方法，因此，通常将环境(Context)自身当作一个参数传递给具体的状态处理类。</li><li>客户端一般只和环境(Context)交互。客户端可以用状态对象来配置一个环境(Context)，一旦配置完毕，就不再需要和状态对象打交道了。客户端通常不负责运行期间状态的维护，也不负责决定后续到底使用哪一个具体的状态处理对象。</li></ul></li></ul>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;&lt;strong&gt;状态模式，又称状态对象模式（Pattern of Objects for States），状态模式是对象的行为模式。&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;状态模式允许一个对象在其内部状态改变的时候改变其行为。这个对象看上去就像是改变了它的类一样。</summary>
      
    
    
    
    <category term="设计模式" scheme="https://georgechan95.github.io/categories/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"/>
    
    
    <category term="设计模式" scheme="https://georgechan95.github.io/tags/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"/>
    
  </entry>
  
  <entry>
    <title>22-解释器模式</title>
    <link href="https://georgechan95.github.io/blog/58d4db7.html"/>
    <id>https://georgechan95.github.io/blog/58d4db7.html</id>
    <published>2024-11-28T14:00:00.000Z</published>
    <updated>2024-11-30T08:03:09.600Z</updated>
    
    <content type="html"><![CDATA[<p><strong>解释器模式是类的行为模式。给定一个语言之后，解释器模式可以定义出其文法的一种表示，并同时提供一个解释器。客户端可以使用这个解释器来解释这个语言中的句子。</strong></p><p>一、解释器模式的结构</p><p>下面就以一个示意性的系统为例，讨论解释器模式的结构。系统的结构图如下所示：</p><p><img src="https://raw.githubusercontent.com/GeorgeChan95/blogimg/master/img/2024/11/30/20241130-144657.png" alt="解释器模式结构"></p><p>模式所涉及的角色如下所示：</p><ul><li><strong>抽象表达式(Expression)角色：</strong>声明一个所有的具体表达式角色都需要实现的抽象接口。这个接口主要是一个interpret()方法，称做解释操作。</li><li><strong>终结符表达式(Terminal Expression)角色：</strong>实现了抽象表达式角色所要求的接口，主要是一个interpret()方法；文法中的每一个终结符都有一个具体终结表达式与之相对应。比如有一个简单的公式R&#x3D;R1+R2，在里面R1和R2就是终结符，对应的解析R1和R2的解释器就是终结符表达式。</li><li><strong>非终结符表达式(Nonterminal Expression)角色：</strong>文法中的每一条规则都需要一个具体的非终结符表达式，非终结符表达式一般是文法中的运算符或者其他关键字，比如公式R&#x3D;R1+R2中，“+”就是非终结符，解析“+”的解释器就是一个非终结符表达式。</li><li><strong>环境(Context)角色：</strong>这个角色的任务一般是用来存放文法中各个终结符所对应的具体值，比如R&#x3D;R1+R2，我们给R1赋值100，给R2赋值200。这些信息需要存放到环境角色中，很多情况下我们使用Map来充当环境角色就足够了。</li></ul><p>为了说明解释器模式的实现办法，这里给出一个最简单的文法和对应的解释器模式的实现，这就是模拟Java语言中对布尔表达式进行操作和求值。</p><p>在这个语言中终结符是布尔变量，也就是常量true和false。非终结符表达式包含运算符and，or和not等布尔表达式。这个简单的文法如下：</p><p><strong>Expression::&#x3D; Constant | Variable | Or | And | Not</strong></p><p><strong>And::&#x3D; Expression ‘AND’ Expression</strong></p><p><strong>Or   ::&#x3D; Expression ‘OR’ Expression</strong></p><p><strong>Not  ::&#x3D; ‘NOT’ Expression</strong></p><p><strong>Variable  ::&#x3D; 任何标识符</strong></p><p><strong>Constant ::&#x3D; ‘true’ | ‘false’</strong></p><p>解释器模式的结构图如下所示：</p><p><img src="https://raw.githubusercontent.com/GeorgeChan95/blogimg/master/img/2024/11/30/20241130-145645.png" alt="解释器模式结构UML"></p><p><strong>代码实现如下：</strong></p><pre><code class="highlight java"><span class="comment">/**</span><span class="comment"> * 抽象表达式角色</span><span class="comment"> */</span><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">class</span> <span class="title class_">Expression</span> &#123;    <span class="comment">/**</span><span class="comment">     * 以环境为准，本方法解释给定的任何一个表达式</span><span class="comment">     */</span>    <span class="keyword">public</span> <span class="keyword">abstract</span> <span class="type">boolean</span> <span class="title function_">interpret</span><span class="params">(Context ctx)</span>;    <span class="comment">/**</span><span class="comment">     * 检验两个表达式在结构上是否相同</span><span class="comment">     */</span>    <span class="keyword">public</span> <span class="keyword">abstract</span> <span class="type">boolean</span> <span class="title function_">equals</span><span class="params">(Object obj)</span>;    <span class="comment">/**</span><span class="comment">     * 返回表达式的hash code</span><span class="comment">     */</span>    <span class="keyword">public</span> <span class="keyword">abstract</span> <span class="type">int</span> <span class="title function_">hashCode</span><span class="params">()</span>;    <span class="comment">/**</span><span class="comment">     * 将表达式转换成字符串</span><span class="comment">     */</span>    <span class="keyword">public</span> <span class="keyword">abstract</span> String <span class="title function_">toString</span><span class="params">()</span>;&#125;<span class="comment">/**</span><span class="comment"> * 一个Constant对象代表一个布尔常量</span><span class="comment"> */</span><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Constant</span> <span class="keyword">extends</span> <span class="title class_">Expression</span> &#123;    <span class="keyword">private</span> <span class="type">boolean</span> value;    <span class="keyword">public</span> <span class="title function_">Constant</span><span class="params">(<span class="type">boolean</span> value)</span> &#123;        <span class="built_in">this</span>.value = value;    &#125;    <span class="meta">@Override</span>    <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">interpret</span><span class="params">(Context ctx)</span> &#123;        <span class="keyword">return</span> value;    &#125;    <span class="comment">/**</span><span class="comment">     * 检验两个表达式在结构上是否相同</span><span class="comment">     */</span>    <span class="meta">@Override</span>    <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">equals</span><span class="params">(Object obj)</span> &#123;        <span class="keyword">if</span> (obj != <span class="literal">null</span> &amp;&amp; obj <span class="keyword">instanceof</span> Constant) &#123;            <span class="keyword">return</span> <span class="built_in">this</span>.value == ((Constant) obj).value;        &#125;        <span class="keyword">return</span> <span class="literal">false</span>;    &#125;    <span class="meta">@Override</span>    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">hashCode</span><span class="params">()</span> &#123;        <span class="keyword">return</span> <span class="built_in">this</span>.toString().hashCode();    &#125;    <span class="meta">@Override</span>    <span class="keyword">public</span> String <span class="title function_">toString</span><span class="params">()</span> &#123;        <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">Boolean</span>(value).toString();    &#125;&#125;<span class="comment">/**</span><span class="comment"> * 一个Variable对象代表一个有名变量</span><span class="comment"> */</span><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Variable</span> <span class="keyword">extends</span> <span class="title class_">Expression</span> &#123;    <span class="keyword">private</span> String name;    <span class="keyword">public</span> <span class="title function_">Variable</span><span class="params">(String name)</span> &#123;        <span class="built_in">this</span>.name = name;    &#125;    <span class="meta">@Override</span>    <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">interpret</span><span class="params">(Context ctx)</span> &#123;        <span class="comment">// 获取变量对应的值</span>        <span class="type">boolean</span> <span class="variable">value</span> <span class="operator">=</span> ctx.lookup(<span class="built_in">this</span>);        <span class="keyword">return</span> value;    &#125;    <span class="meta">@Override</span>    <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">equals</span><span class="params">(Object obj)</span> &#123;        <span class="keyword">if</span> (obj != <span class="literal">null</span> &amp;&amp; obj <span class="keyword">instanceof</span> Variable) &#123;            <span class="keyword">return</span> <span class="built_in">this</span>.name.equals(((Variable)obj).name);        &#125;        <span class="keyword">return</span> <span class="literal">false</span>;    &#125;    <span class="meta">@Override</span>    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">hashCode</span><span class="params">()</span> &#123;        <span class="keyword">return</span> <span class="built_in">this</span>.toString().hashCode();    &#125;    <span class="meta">@Override</span>    <span class="keyword">public</span> String <span class="title function_">toString</span><span class="params">()</span> &#123;        <span class="keyword">return</span> <span class="built_in">this</span>.name;    &#125;&#125;<span class="comment">/**</span><span class="comment"> * 代表逻辑“与”操作的And类，表示由两个布尔表达式通过逻辑“与”操作给出一个新的布尔表达式的操作</span><span class="comment"> */</span><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">And</span> <span class="keyword">extends</span> <span class="title class_">Expression</span> &#123;    <span class="keyword">private</span> Expression left, right;    <span class="keyword">public</span> <span class="title function_">And</span><span class="params">(Expression left, Expression right)</span> &#123;        <span class="built_in">this</span>.left = left;        <span class="built_in">this</span>.right = right;    &#125;    <span class="meta">@Override</span>    <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">interpret</span><span class="params">(Context ctx)</span> &#123;        <span class="keyword">return</span> left.interpret(ctx) &amp;&amp; right.interpret(ctx);    &#125;    <span class="comment">/**</span><span class="comment">     * 检验两个表达式在结构上是否相同</span><span class="comment">     */</span>    <span class="meta">@Override</span>    <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">equals</span><span class="params">(Object obj)</span> &#123;        <span class="keyword">if</span> (obj != <span class="literal">null</span> &amp;&amp; obj <span class="keyword">instanceof</span> And) &#123;            <span class="keyword">return</span> left.equals(((And) obj).left) &amp;&amp;                    right.equals(((And) obj).right);        &#125;        <span class="keyword">return</span> <span class="literal">false</span>;    &#125;    <span class="meta">@Override</span>    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">hashCode</span><span class="params">()</span> &#123;        <span class="keyword">return</span> <span class="built_in">this</span>.toString().hashCode();    &#125;    <span class="meta">@Override</span>    <span class="keyword">public</span> String <span class="title function_">toString</span><span class="params">()</span> &#123;        <span class="keyword">return</span> <span class="string">&quot;(&quot;</span> + left.toString() + <span class="string">&quot; AND &quot;</span> + right.toString() + <span class="string">&quot;)&quot;</span>;    &#125;&#125;<span class="comment">/**</span><span class="comment"> * 代表逻辑“或”操作的Or类，代表由两个布尔表达式通过逻辑“或”操作给出一个新的布尔表达式的操作</span><span class="comment"> */</span><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Or</span> <span class="keyword">extends</span> <span class="title class_">Expression</span> &#123;    <span class="keyword">private</span> Expression left, right;    <span class="keyword">public</span> <span class="title function_">Or</span><span class="params">(Expression left, Expression right)</span> &#123;        <span class="built_in">this</span>.left = left;        <span class="built_in">this</span>.right = right;    &#125;    <span class="meta">@Override</span>    <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">interpret</span><span class="params">(Context ctx)</span> &#123;        <span class="keyword">return</span> left.interpret(ctx) || right.interpret(ctx);    &#125;    <span class="meta">@Override</span>    <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">equals</span><span class="params">(Object obj)</span> &#123;        <span class="keyword">if</span> (obj != <span class="literal">null</span> &amp;&amp; obj <span class="keyword">instanceof</span> Or) &#123;            <span class="keyword">return</span> <span class="built_in">this</span>.left.equals(((Or) obj).left)                    &amp;&amp; <span class="built_in">this</span>.right.equals(((Or) obj).right);        &#125;        <span class="keyword">return</span> <span class="literal">false</span>;    &#125;    <span class="meta">@Override</span>    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">hashCode</span><span class="params">()</span> &#123;        <span class="keyword">return</span> <span class="built_in">this</span>.toString().hashCode();    &#125;    <span class="meta">@Override</span>    <span class="keyword">public</span> String <span class="title function_">toString</span><span class="params">()</span> &#123;        <span class="keyword">return</span> <span class="string">&quot;(&quot;</span> + left.toString() + <span class="string">&quot; OR &quot;</span> + right.toString() + <span class="string">&quot;)&quot;</span>;    &#125;&#125;<span class="comment">/**</span><span class="comment"> * 代表逻辑“非”操作的Not类，代表由一个布尔表达式通过逻辑“非”操作给出一个新的布尔表达式的操作</span><span class="comment"> */</span><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Not</span> <span class="keyword">extends</span> <span class="title class_">Expression</span> &#123;    <span class="keyword">private</span> Expression exp;    <span class="keyword">public</span> <span class="title function_">Not</span><span class="params">(Expression exp)</span> &#123;        <span class="built_in">this</span>.exp = exp;    &#125;    <span class="meta">@Override</span>    <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">interpret</span><span class="params">(Context ctx)</span> &#123;        <span class="keyword">return</span> !exp.interpret(ctx);    &#125;    <span class="meta">@Override</span>    <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">equals</span><span class="params">(Object obj)</span> &#123;        <span class="keyword">if</span> (obj != <span class="literal">null</span> &amp;&amp; obj <span class="keyword">instanceof</span> Not) &#123;            <span class="keyword">return</span> exp.equals(                    ((Not) obj).exp);        &#125;        <span class="keyword">return</span> <span class="literal">false</span>;    &#125;    <span class="meta">@Override</span>    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">hashCode</span><span class="params">()</span> &#123;        <span class="keyword">return</span> <span class="built_in">this</span>.toString().hashCode();    &#125;    <span class="meta">@Override</span>    <span class="keyword">public</span> String <span class="title function_">toString</span><span class="params">()</span> &#123;        <span class="keyword">return</span> <span class="string">&quot;(Not &quot;</span> + exp.toString() + <span class="string">&quot;)&quot;</span>;    &#125;&#125;<span class="comment">/**</span><span class="comment"> * 环境(Context)类定义出从变量到布尔值的一个映射</span><span class="comment"> */</span><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Context</span> &#123;    <span class="keyword">private</span> Map&lt;Variable, Boolean&gt; map = <span class="keyword">new</span> <span class="title class_">HashMap</span>&lt;&gt;();    <span class="comment">/**</span><span class="comment">     * 设置变量和值</span><span class="comment">     * <span class="doctag">@param</span> variable</span><span class="comment">     * <span class="doctag">@param</span> value</span><span class="comment">     */</span>    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">assign</span><span class="params">(Variable variable, <span class="type">boolean</span> value)</span> &#123;        map.put(variable, value);    &#125;    <span class="comment">/**</span><span class="comment">     * 根据变量获取变量的值</span><span class="comment">     * <span class="doctag">@param</span> var</span><span class="comment">     * <span class="doctag">@return</span></span><span class="comment">     */</span>    <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">lookup</span><span class="params">(Variable <span class="keyword">var</span>)</span> &#123;        <span class="type">Boolean</span> <span class="variable">value</span> <span class="operator">=</span> map.get(<span class="keyword">var</span>);        <span class="keyword">if</span> (value == <span class="literal">null</span>) &#123;            <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">IllegalArgumentException</span>();        &#125;        <span class="keyword">return</span> value.booleanValue();    &#125;&#125;<span class="comment">/**</span><span class="comment"> * 测试类</span><span class="comment"> */</span><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Client</span> &#123;    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;        <span class="comment">// 环境</span>        <span class="type">Context</span> <span class="variable">context</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Context</span>();        <span class="comment">// 变量</span>        <span class="type">Variable</span> <span class="variable">x</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Variable</span>(<span class="string">&quot;x&quot;</span>);        <span class="type">Variable</span> <span class="variable">y</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Variable</span>(<span class="string">&quot;y&quot;</span>);        <span class="comment">// 布尔常量</span>        <span class="type">Constant</span> <span class="variable">c</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Constant</span>(<span class="literal">true</span>);        <span class="comment">// 将变量名和常量值设置到环境中</span>        context.assign(x, <span class="literal">false</span>);        context.assign(y, <span class="literal">true</span>);        <span class="type">Expression</span> <span class="variable">exp</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Or</span>(<span class="keyword">new</span> <span class="title class_">And</span>(c,x) , <span class="keyword">new</span> <span class="title class_">And</span>(y,<span class="keyword">new</span> <span class="title class_">Not</span>(x)));        System.out.println(<span class="string">&quot;x=&quot;</span> + x.interpret(context));        System.out.println(<span class="string">&quot;y=&quot;</span> + y.interpret(context));        System.out.println(exp.toString() + <span class="string">&quot;=&quot;</span> + exp.interpret(context));    &#125;&#125;</code></pre><blockquote><p>运行结果：</p><pre><code class="highlight shell">x=falsey=true((true AND x) OR (y AND (Not x)))=true</code></pre></blockquote>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;&lt;strong&gt;解释器模式是类的行为模式。给定一个语言之后，解释器模式可以定义出其文法的一种表示，并同时提供一个解释器。客户端可以使用这个解释器来解释这个语言中的句子。&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;一、解释器模式的结构&lt;/p&gt;
&lt;p&gt;下面就以一个示意性的系统为例，讨论解</summary>
      
    
    
    
    <category term="设计模式" scheme="https://georgechan95.github.io/categories/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"/>
    
    
    <category term="设计模式" scheme="https://georgechan95.github.io/tags/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"/>
    
  </entry>
  
  <entry>
    <title>21-备忘录模式</title>
    <link href="https://georgechan95.github.io/blog/a5cf7eb4.html"/>
    <id>https://georgechan95.github.io/blog/a5cf7eb4.html</id>
    <published>2024-11-27T13:40:00.000Z</published>
    <updated>2024-11-30T06:29:06.910Z</updated>
    
    <content type="html"><![CDATA[<p><strong>备忘录模式又叫做快照模式(Snapshot Pattern)或Token模式，是对象的行为模式。</strong></p><p><strong>备忘录对象是一个用来存储另外一个对象内部状态的快照的对象。备忘录模式的用意是在不破坏封装的条件下，将一个对象的状态捕捉(Capture)住，并外部化，存储起来，从而可以在将来合适的时候把这个对象还原到存储起来的状态。备忘录模式常常与命令模式和迭代器模式一同使用。</strong></p><h1 id="一、备忘录模式的结构"><a href="#一、备忘录模式的结构" class="headerlink" title="一、备忘录模式的结构"></a>一、备忘录模式的结构</h1><p>备忘录模式的结构图如下所示</p><p><img src="https://raw.githubusercontent.com/GeorgeChan95/blogimg/master/img/2024/11/30/20241130-090723.png" alt="备忘录模式结构图"></p><p>备忘录模式所涉及的角色有三个：<strong>备忘录(Memento)角色、发起人(Originator)角色、负责人(Caretaker)角色</strong>。</p><h2 id="1-备忘录-Memento-角色"><a href="#1-备忘录-Memento-角色" class="headerlink" title="1. 备忘录(Memento)角色"></a>1. 备忘录(Memento)角色</h2><p>备忘录角色又如下责任：</p><ul><li>将发起人（Originator）对象的内存状态存储起来。备忘录可以根据发起人对象的判断来决定存储多少发起人（Originator）对象的内部状态。</li><li>备忘录可以保护其内容不被发起人（Originator）对象之外的任何对象所读取。</li></ul><p>备忘录有两个等效的接口：</p><ul><li><strong>窄接口：</strong>负责人（Caretaker）对象（和其他除发起人对象之外的任何对象）看到的是备忘录的窄接口(narrow interface)，这个窄接口只允许它把备忘录对象传给其他的对象。</li><li><strong>宽接口：</strong>与负责人对象看到的窄接口相反的是，发起人对象可以看到一个宽接口(wide interface)，这个宽接口允许它读取所有的数据，以便根据这些数据恢复这个发起人对象的内部状态。</li></ul><h2 id="2-发起人（Originator）角色"><a href="#2-发起人（Originator）角色" class="headerlink" title="2. 发起人（Originator）角色"></a>2. 发起人（Originator）角色</h2><p>发起人角色有如下责任：</p><ul><li>创建一个含有当前的内部状态的备忘录对象。</li><li>使用备忘录对象存储其内部状态。</li></ul><h2 id="3-负责人（Caretaker）角色"><a href="#3-负责人（Caretaker）角色" class="headerlink" title="3. 负责人（Caretaker）角色"></a>3. 负责人（Caretaker）角色</h2><p>负责人角色有如下责任：</p><ul><li>负责保存备忘录对象。</li><li>不检查备忘录对象的内容。</li></ul><h1 id="二、“白箱”备忘录模式的实现"><a href="#二、“白箱”备忘录模式的实现" class="headerlink" title="二、“白箱”备忘录模式的实现"></a>二、“白箱”备忘录模式的实现</h1><p>备忘录角色对任何对象都提供一个接口，即宽接口，备忘录角色的内部所存储的状态就对所有对象公开。因此这个实现又叫做“白箱实现”。</p><p>“白箱”实现将发起人角色的状态存储在一个大家都看得到的地方，因此是破坏封装性的。但是通过程序员自律，同样可以在一定程度上实现模式的大部分用意。因此白箱实现仍然是有意义的。</p><p>下面给出一个示意性的“白箱实现”。</p><p><img src="https://raw.githubusercontent.com/GeorgeChan95/blogimg/master/img/2024/11/30/20241130-092423.png" alt="备忘录-白箱模式"></p><p><strong>代码实现如下：</strong></p><pre><code class="highlight java"><span class="comment">/**</span><span class="comment"> * 备忘录角色，备忘录对象将发起人对象传入的状态存储起来。</span><span class="comment"> */</span><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Memento</span> &#123;    <span class="keyword">private</span> String state;    <span class="keyword">public</span> <span class="title function_">Memento</span><span class="params">(String state)</span> &#123;        <span class="built_in">this</span>.state = state;    &#125;    <span class="keyword">public</span> String <span class="title function_">getState</span><span class="params">()</span> &#123;        <span class="keyword">return</span> state;    &#125;    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setState</span><span class="params">(String state)</span> &#123;        <span class="built_in">this</span>.state = state;    &#125;&#125;<span class="comment">/**</span><span class="comment"> * 发起人角色类，利用备忘录角色对象存储自身的状态</span><span class="comment"> */</span><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Originator</span> &#123;    <span class="keyword">private</span> String state;    <span class="comment">/**</span><span class="comment">     * 工厂方法，创建一个新的备忘录对象</span><span class="comment">     * <span class="doctag">@return</span></span><span class="comment">     */</span>    <span class="keyword">public</span> Memento <span class="title function_">createMemento</span><span class="params">()</span> &#123;        <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">Memento</span>(state);    &#125;    <span class="comment">/**</span><span class="comment">     * 通过备忘录对象，将发起人状态恢复到备忘录记载的状态</span><span class="comment">     * <span class="doctag">@param</span> memento</span><span class="comment">     */</span>    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">restoreMemento</span><span class="params">(Memento memento)</span> &#123;        <span class="built_in">this</span>.state = memento.getState();    &#125;    <span class="keyword">public</span> String <span class="title function_">getState</span><span class="params">()</span> &#123;        <span class="keyword">return</span> state;    &#125;    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setState</span><span class="params">(String state)</span> &#123;        <span class="built_in">this</span>.state = state;        System.out.println(<span class="string">&quot;发起人当前状态：&quot;</span> + <span class="built_in">this</span>.state);    &#125;&#125;<span class="comment">/**</span><span class="comment"> * 负责人角色，负责保存备忘录对象，但是从不修改（甚至不查看）备忘录对象的内容。</span><span class="comment"> */</span><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Caretaker</span> &#123;    <span class="keyword">private</span> Memento memento;    <span class="comment">/**</span><span class="comment">     * 备忘录取值方法</span><span class="comment">     * <span class="doctag">@return</span></span><span class="comment">     */</span>    <span class="keyword">public</span> Memento <span class="title function_">retrieveMemento</span><span class="params">()</span> &#123;        <span class="keyword">return</span> <span class="built_in">this</span>.memento;    &#125;    <span class="comment">/**</span><span class="comment">     * 备忘录的赋值方法</span><span class="comment">     */</span>    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">saveMemento</span><span class="params">(Memento memento)</span> &#123;        <span class="built_in">this</span>.memento = memento;    &#125;&#125;<span class="comment">/**</span><span class="comment"> * 测试类</span><span class="comment"> */</span><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Client</span> &#123;    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;        <span class="comment">// 发起人角色</span>        <span class="type">Originator</span> <span class="variable">originator</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Originator</span>();        <span class="comment">// 负责人角色</span>        <span class="type">Caretaker</span> <span class="variable">caretaker</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Caretaker</span>();        <span class="comment">// 设置状态</span>        originator.setState(<span class="string">&quot;ON&quot;</span>);        <span class="comment">// 创建一个备忘录对象，并使用负责人对象保存</span>        caretaker.saveMemento(originator.createMemento());        <span class="comment">// 修改发起人状态</span>        originator.setState(<span class="string">&quot;OFF&quot;</span>);        <span class="comment">// 恢复发起人对象的状态</span>        originator.restoreMemento(caretaker.retrieveMemento());        System.out.println(<span class="string">&quot;发起人状态恢复到：&quot;</span> + originator.getState());    &#125;&#125;</code></pre><blockquote><p>运行结果：</p><pre><code class="highlight shell">发起人当前状态：ON发起人当前状态：OFF发起人状态恢复到：ON</code></pre></blockquote><p>在上面的这个示意性的客户端角色里面，首先将发起人对象的状态设置成“On”，并创建一个备忘录对象将这个状态存储起来；然后将发起人对象的状态改成“Off”；最后又将发起人对象恢复到备忘录对象所存储起来的状态，即“On”状态。</p><p>系统的时序图更能够反映出系统各个角色被调用的时间顺序。如下图是将发起人对象的状态存储到白箱备忘录对象中去的时序图。</p><p><img src="https://raw.githubusercontent.com/GeorgeChan95/blogimg/master/img/2024/11/30/20241130-095455.png" alt="时序图1"></p><p>可以看出系统运行的时序是这样的：</p><ul><li>将发起人对象的状态设置成“On”</li><li>调用发起人角色的 <code>createMemento()</code> 方法，创建一个备忘录对象将这个状态存储起来。</li><li>将备忘录对象存储到负责人对象中去。</li></ul><p><strong>将发起人对象恢复到备忘录对象所记录的状态的时序图如下所示：</strong></p><p><img src="https://raw.githubusercontent.com/GeorgeChan95/blogimg/master/img/2024/11/30/20241130-095703.png" alt="时序图2"></p><p>可以看出，将发起人对象恢复到备忘录对象所记录的状态时，系统的运行时序是这样的：</p><ul><li>将发起人状态设置成 “Off” 。</li><li>将备忘录对象从负责人对象中取出。</li><li>将发起人对象恢复到备忘录对象所存储起来的状态，即“On”状态。</li></ul><h1 id="三、“黑箱”备忘录模式的实现"><a href="#三、“黑箱”备忘录模式的实现" class="headerlink" title="三、“黑箱”备忘录模式的实现"></a>三、“黑箱”备忘录模式的实现</h1><p>备忘录角色对发起人（Originator）角色对象提供一个宽接口，而为其他对象提供一个窄接口。这样的实现叫做“黑箱实现”。</p><p>在JAVA语言中，实现双重接口的办法就是将 <strong>备忘录角色类</strong> 设计成 <strong>发起人角色类</strong> 的内部成员类。</p><p>将 <code>Memento</code> 设成 <code>Originator</code> 类的内部类，从而将 <code>Memento</code> 对象封装在 <code>Originator</code> 里面；在外部提供一个标识接口 <code>MementoIF</code> 给<code>Caretaker</code>以及其他对象。这样，<code>Originator</code> 类看到的是 <code>Menmento</code> 的所有接口，而 <code>Caretaker</code> 以及其他对象看到的仅仅是标识接口 <code>MementoIF</code> 所暴露出来的接口。</p><p>使用内部类实现备忘录模式的类图如下所示。</p><p><img src="https://raw.githubusercontent.com/GeorgeChan95/blogimg/master/img/2024/11/30/20241130-100422.png" alt="黑箱备忘录模式"></p><p><strong>代码实现如下：</strong></p><pre><code class="highlight java"><span class="comment">/**</span><span class="comment"> * 窄接口MementoIF，这是一个标识接口，没有定义出任何的方法。</span><span class="comment"> */</span><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">MementoIF</span> &#123;&#125;<span class="comment">/**</span><span class="comment"> * 发起人角色， 定义了一个内部的Memento类。由于此Memento类的全部接口都是私有的，因此只有它自己和发起人类可以调用。</span><span class="comment"> */</span><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Originator</span> &#123;    <span class="keyword">private</span> String state;    <span class="keyword">public</span> String <span class="title function_">getState</span><span class="params">()</span> &#123;        <span class="keyword">return</span> state;    &#125;    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setState</span><span class="params">(String state)</span> &#123;        <span class="built_in">this</span>.state = state;        System.out.println(<span class="string">&quot;发起人当前状态：&quot;</span> + <span class="built_in">this</span>.state);    &#125;    <span class="comment">/**</span><span class="comment">     * 工厂方法，创建一个新的备忘录对象</span><span class="comment">     * <span class="doctag">@return</span></span><span class="comment">     */</span>    <span class="keyword">public</span> MementoIF <span class="title function_">createMemento</span><span class="params">()</span> &#123;        <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">Memento</span>(<span class="built_in">this</span>.state);    &#125;    <span class="comment">/**</span><span class="comment">     * 发起人恢复到备忘录对象记录的状态</span><span class="comment">     */</span>    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">restoreMemento</span><span class="params">(MementoIF mementoIF)</span> &#123;        <span class="type">Memento</span> <span class="variable">memento</span> <span class="operator">=</span> (Memento) mementoIF;        <span class="built_in">this</span>.setState(memento.getState());    &#125;    <span class="comment">/**</span><span class="comment">     * 备忘录角色，实现MementoIF接口，作为内部类发起人类可以全部使用其功能接口，其它类只能获得其接口引用</span><span class="comment">     */</span>    <span class="keyword">private</span> <span class="keyword">class</span> <span class="title class_">Memento</span> <span class="keyword">implements</span> <span class="title class_">MementoIF</span> &#123;        <span class="keyword">private</span> String state;        <span class="keyword">private</span> <span class="title function_">Memento</span><span class="params">(String state)</span> &#123;            <span class="built_in">this</span>.state = state;        &#125;        <span class="keyword">private</span> String <span class="title function_">getState</span><span class="params">()</span> &#123;            <span class="keyword">return</span> state;        &#125;        <span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">setState</span><span class="params">(String state)</span> &#123;            <span class="built_in">this</span>.state = state;        &#125;    &#125;&#125;<span class="comment">/**</span><span class="comment"> * 负责人对象，得到的备忘录对象是以MementoIF为接口的，由于这个接口仅仅是一个标识接口，因此负责人角色不可能改变这个备忘录对象的内容。</span><span class="comment"> */</span><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Caretaker</span> &#123;    <span class="keyword">private</span> MementoIF mementoIF;    <span class="comment">/**</span><span class="comment">     * 获取备忘录对象</span><span class="comment">     * <span class="doctag">@return</span></span><span class="comment">     */</span>    <span class="keyword">public</span> MementoIF <span class="title function_">retrieveMemento</span><span class="params">()</span> &#123;        <span class="keyword">return</span> mementoIF;    &#125;    <span class="comment">/**</span><span class="comment">     * 备忘录赋值方法</span><span class="comment">     * <span class="doctag">@param</span> mementoIF</span><span class="comment">     */</span>    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">saveMemento</span><span class="params">(MementoIF mementoIF)</span> &#123;        <span class="built_in">this</span>.mementoIF = mementoIF;    &#125;&#125;<span class="comment">/**</span><span class="comment"> * 测试类</span><span class="comment"> */</span><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Client</span> &#123;    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;        <span class="comment">// 发起人对象</span>        <span class="type">Originator</span> <span class="variable">originator</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Originator</span>();        <span class="comment">// 负责人对象</span>        <span class="type">Caretaker</span> <span class="variable">caretaker</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Caretaker</span>();        <span class="comment">// 设置状态</span>        originator.setState(<span class="string">&quot;ON&quot;</span>);        <span class="comment">// 创建备忘录</span>        <span class="type">MementoIF</span> <span class="variable">mementoIF</span> <span class="operator">=</span> originator.createMemento();        <span class="comment">// 负责人对象保存备忘录</span>        caretaker.saveMemento(mementoIF);        <span class="comment">// 改变发起人状态</span>        originator.setState(<span class="string">&quot;OFF&quot;</span>);        <span class="comment">// 通过备忘录，恢复发起人对象的状态</span>        originator.restoreMemento(caretaker.retrieveMemento());    &#125;&#125;</code></pre><blockquote><p>运行结果如下：</p><pre><code class="highlight shell">发起人当前状态：ON发起人当前状态：OFF发起人当前状态：ON</code></pre></blockquote><p>客户端首先</p><ul><li>将发起人对象的状态设置为“On”。</li><li>调用 <code>createMemento()</code> 方法，创建一个备忘录对象将这个状态存储起来（此时 <code>createMemento()</code> 方法还回的类型是 <code>MementoIF</code> 接口，真实类型为<code>Originator</code>内部的 <code>Memento</code> 对象）。</li><li>将备忘录对象存储到负责人对象中去。由于负责人对象拿到的仅是 <code>MementoIF</code> 接口，因此无法读出备忘录对象内部的状态。</li><li>将发起人对象的状态设置为“Off”。</li><li>调用负责人对象的 <code>retrieveMemento()</code> 方法将备忘录对象取出。注意此时仅能得到 <code>MementoIF</code> 接口，因此无法读出此对象的内部状态。</li><li>调用发起人对象的 <code>restoreMemento()</code> 方法将发起人对象的状态恢复成备忘录对象所存储的起来的状态，即“On”状态。由于发起人对象的内部类<code>Memento</code>实现了<code>MementoIF</code>接口，这个内部类是传入的备忘录对象的真实类型，因此发起人对象可以利用内部类 <code>Memento</code> 的私有接口读出此对象的内部状态。</li></ul><h1 id="四、多重检查点"><a href="#四、多重检查点" class="headerlink" title="四、多重检查点"></a>四、多重检查点</h1><p>前面所给出的白箱和黑箱的示意性实现都是只存储一个状态的简单实现，也可以叫做只有一个检查点。常见的系统往往需要存储不止一个状态，而是需要存储多个状态，或者叫做有多个检查点。</p><p>备忘录模式可以将发起人对象的状态存储到备忘录对象里面，备忘录模式可以将发起人对象恢复到备忘录对象所存储的某一个检查点上。下面给出一个示意性的、有多重检查点的备忘录模式的实现。</p><p><img src="https://raw.githubusercontent.com/GeorgeChan95/blogimg/master/img/2024/11/30/20241130-112032.png" alt="多重检查点"></p><p><strong>代码实现如下：</strong></p><pre><code class="highlight java"><span class="comment">/**</span><span class="comment"> * 备忘录角色，这个实现可以存储任意多的状态，外界可以使用检查点索引index来取出检查点上的状态。　　</span><span class="comment"> */</span><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Memento</span> &#123;    <span class="keyword">private</span> List&lt;String&gt; states;    <span class="keyword">private</span> <span class="type">int</span> index;    <span class="keyword">public</span> <span class="title function_">Memento</span><span class="params">(List&lt;String&gt; states, <span class="type">int</span> index)</span> &#123;        <span class="comment">// states是引用，重新创建新的对象</span>        <span class="built_in">this</span>.states = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;(states);        <span class="built_in">this</span>.index = index;    &#125;    <span class="keyword">public</span> List&lt;String&gt; <span class="title function_">getStates</span><span class="params">()</span> &#123;        <span class="keyword">return</span> states;    &#125;    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">getIndex</span><span class="params">()</span> &#123;        <span class="keyword">return</span> index;    &#125;&#125;<span class="comment">/**</span><span class="comment"> * 发起人角色</span><span class="comment"> */</span><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Originator</span> &#123;    <span class="keyword">private</span> List&lt;String&gt; states;    <span class="comment">//检查点指数</span>    <span class="keyword">private</span> <span class="type">int</span> index;    <span class="keyword">public</span> <span class="title function_">Originator</span><span class="params">()</span> &#123;        <span class="built_in">this</span>.states = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();        <span class="built_in">this</span>.index = <span class="number">0</span>;    &#125;    <span class="comment">/**</span><span class="comment">     * 工厂方法，返还一个新的备忘录对象</span><span class="comment">     */</span>    <span class="keyword">public</span> Memento <span class="title function_">createMemento</span><span class="params">()</span>&#123;        <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">Memento</span>(states , index);    &#125;    <span class="comment">/**</span><span class="comment">     * 将发起人恢复到备忘录对象记录的状态上</span><span class="comment">     */</span>    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">restoreMemento</span><span class="params">(Memento memento)</span>&#123;        states = memento.getStates();        index = memento.getIndex();    &#125;    <span class="comment">/**</span><span class="comment">     * 状态赋值，更新states和索引</span><span class="comment">     * <span class="doctag">@param</span> state</span><span class="comment">     */</span>    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setState</span><span class="params">(String state)</span> &#123;        <span class="built_in">this</span>.states.add(state);        <span class="built_in">this</span>.index++;    &#125;    <span class="comment">/**</span><span class="comment">     * 打印当前检查点的状态</span><span class="comment">     */</span>    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">printStates</span><span class="params">()</span> &#123;        System.out.print(<span class="string">&quot;发起人检查点索引：&quot;</span> + <span class="built_in">this</span>.index + <span class="string">&quot;， 状态：&quot;</span>);        <span class="keyword">for</span> (String state : states) &#123;            System.out.print(state + <span class="string">&quot; &quot;</span>);        &#125;        System.out.println();    &#125;&#125;<span class="comment">/**</span><span class="comment"> * 负责人角色</span><span class="comment"> */</span><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Caretaker</span> &#123;    <span class="keyword">private</span> Originator originator;    <span class="keyword">private</span> List&lt;Memento&gt; mementos;    <span class="keyword">private</span> <span class="type">int</span> current;    <span class="keyword">public</span> <span class="title function_">Caretaker</span><span class="params">(Originator originator)</span> &#123;        <span class="built_in">this</span>.originator = originator;        mementos = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();        current = <span class="number">0</span>;    &#125;    <span class="comment">/**</span><span class="comment">     * 创建一个新的检查点</span><span class="comment">     * <span class="doctag">@return</span></span><span class="comment">     */</span>    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">createMemento</span><span class="params">()</span> &#123;        <span class="type">Memento</span> <span class="variable">memento</span> <span class="operator">=</span> originator.createMemento();        mementos.add(memento);        <span class="keyword">return</span> current++;    &#125;    <span class="comment">/**</span><span class="comment">     * 将发起人恢复到某个检查点</span><span class="comment">     * <span class="doctag">@param</span> index</span><span class="comment">     */</span>    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">restoreMemento</span><span class="params">(<span class="type">int</span> index)</span> &#123;        <span class="type">Memento</span> <span class="variable">memento</span> <span class="operator">=</span> mementos.get(index);        originator.restoreMemento(memento);    &#125;    <span class="comment">/**</span><span class="comment">     * 删除某个检查点</span><span class="comment">     * <span class="doctag">@param</span> index</span><span class="comment">     */</span>    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">removeMemento</span><span class="params">(<span class="type">int</span> index)</span> &#123;        mementos.remove(index);    &#125;&#125;<span class="comment">/**</span><span class="comment"> * 测试类</span><span class="comment"> */</span><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Client</span> &#123;    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;        <span class="comment">// 发起人</span>        <span class="type">Originator</span> <span class="variable">originator</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Originator</span>();        <span class="comment">// 负责人</span>        <span class="type">Caretaker</span> <span class="variable">caretaker</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Caretaker</span>(originator);        <span class="comment">// 变更状态，并保存检查点</span>        originator.setState(<span class="string">&quot;State 0&quot;</span>);        caretaker.createMemento();        <span class="comment">// 变更状态，并保存检查点</span>        originator.setState(<span class="string">&quot;State 1&quot;</span>);        caretaker.createMemento();        <span class="comment">// 变更状态，并保存检查点</span>        originator.setState(<span class="string">&quot;State 2&quot;</span>);        caretaker.createMemento();        <span class="comment">// 打印当前检查点</span>        originator.printStates();        <span class="comment">// 恢复到检查点1</span>        caretaker.restoreMemento(<span class="number">1</span>);        <span class="comment">// 打印当前检查点</span>        originator.printStates();        <span class="comment">// 恢复到检查点2</span>        caretaker.restoreMemento(<span class="number">2</span>);        <span class="comment">// 打印当前检查点</span>        originator.printStates();    &#125;&#125;</code></pre><blockquote><p>运行结果：</p><pre><code class="highlight shell">发起人检查点索引：3， 状态：State 0 State 1 State 2 发起人检查点索引：2， 状态：State 0 State 1 发起人检查点索引：3， 状态：State 0 State 1 State 2</code></pre></blockquote><p>可以看出，客户端角色通过不断改变发起人角色的状态，并将之存储在备忘录里面。通过指明检查点指数可以将发起人角色恢复到相应的检查点所对应的状态上。</p><p>将发起人的状态存储到备忘录对象中的活动序列图如下：</p><p><img src="https://raw.githubusercontent.com/GeorgeChan95/blogimg/master/img/2024/11/30/20241130-114712.png" alt="多重检查点时序图1"></p><p><strong>系统运行的时序是这样的：</strong></p><ul><li>将发起人对象的状态设置成某个有效状态；</li><li>调用负责人角色的 <code>createMemento()</code> 方法，负责人角色会负责调用发起人角色和备忘录角色，将发起人对象的状态存储起来。</li></ul><p><strong>将发起人对象恢复到某一个备忘录对象的检查点的活动序列图如下：</strong></p><p><img src="https://raw.githubusercontent.com/GeorgeChan95/blogimg/master/img/2024/11/30/20241130-114846.png" alt="多重检查点时序图2"></p><p>由于负责人角色的功能被增强了，因此将发起人对象恢复到备忘录对象所记录的状态时，系统运行的时序被简化了：</p><ul><li>调用负责人角色的 <code>restoreMemento()</code> 方法，将发起人恢复到某个检查点。</li></ul><h1 id="五、“自述历史”模式"><a href="#五、“自述历史”模式" class="headerlink" title="五、“自述历史”模式"></a>五、“自述历史”模式</h1><p>所谓“自述历史”模式(<code>History-On-Self Pattern</code>)实际上就是备忘录模式的一个变种。在备忘录模式中，发起人(Originator)角色、负责人(Caretaker)角色和备忘录(Memento)角色都是独立的角色。虽然在实现上备忘录类可以成为发起人类的内部成员类，但是备忘录类仍然保持作为一个角色的独立意义。在“自述历史”模式里面，发起人角色自己兼任负责人角色。</p><p>“自述历史”模式的类图如下所示：</p><p><img src="https://raw.githubusercontent.com/GeorgeChan95/blogimg/master/img/2024/11/30/20241130-115121.png" alt="自述历史模式"></p><p><strong>备忘录角色有如下责任：</strong></p><ul><li>将发起人（Originator）对象的内部状态存储起来。</li><li>备忘录可以保护其内容不被发起人（Originator）对象之外的任何对象所读取。</li></ul><p><strong>发起人角色有如下责任：</strong></p><ul><li>创建一个含有它当前的内部状态的备忘录对象。</li><li>使用备忘录对象存储其内部状态。</li></ul><p>客户端角色有负责保存备忘录对象的责任。</p><p><strong>代码实现如下：</strong></p><pre><code class="highlight java"><span class="comment">/**</span><span class="comment"> * 窄接口MementoIF，这是一个标识接口，因此它没有定义出任何的方法。</span><span class="comment"> */</span><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">MementoIF</span> &#123;&#125;<span class="comment">/**</span><span class="comment"> * 发起人角色同时还兼任负责人角色，也就是说它自己负责保持自己的备忘录对象。</span><span class="comment"> */</span><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Originator</span> &#123;    <span class="keyword">public</span> String state;    <span class="comment">/**</span><span class="comment">     * 改变状态</span><span class="comment">     * <span class="doctag">@param</span> state</span><span class="comment">     */</span>    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">changeState</span><span class="params">(String state)</span> &#123;        <span class="built_in">this</span>.state = state;        System.out.println(<span class="string">&quot;状态改变为：&quot;</span> + state);    &#125;    <span class="comment">/**</span><span class="comment">     * 工厂方法，返还一个新的备忘录对象</span><span class="comment">     */</span>    <span class="keyword">public</span> MementoIF <span class="title function_">createMemento</span><span class="params">()</span> &#123;        <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">Memento</span>(<span class="built_in">this</span>);    &#125;    <span class="comment">/**</span><span class="comment">     * 将发起人恢复到备忘录对象所记录的状态上</span><span class="comment">     */</span>    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">restoreMemento</span><span class="params">(MementoIF mementoIF)</span> &#123;        <span class="type">Memento</span> <span class="variable">memento</span> <span class="operator">=</span> (Memento) mementoIF;        changeState(memento.getState());    &#125;    <span class="keyword">public</span> String <span class="title function_">getState</span><span class="params">()</span> &#123;        <span class="keyword">return</span> state;    &#125;    <span class="comment">/**</span><span class="comment">     * 备忘录角色，作为内部类</span><span class="comment">     */</span>    <span class="keyword">private</span> <span class="keyword">class</span> <span class="title class_">Memento</span> <span class="keyword">implements</span> <span class="title class_">MementoIF</span> &#123;        <span class="keyword">private</span> String state;        <span class="comment">/**</span><span class="comment">         * 构造方法</span><span class="comment">         * <span class="doctag">@param</span> originator</span><span class="comment">         */</span>        <span class="keyword">public</span> <span class="title function_">Memento</span><span class="params">(Originator originator)</span> &#123;            <span class="built_in">this</span>.state = originator.getState();        &#125;        <span class="keyword">public</span> String <span class="title function_">getState</span><span class="params">()</span> &#123;            <span class="keyword">return</span> state;        &#125;    &#125;&#125;<span class="comment">/**</span><span class="comment"> * 客户端</span><span class="comment"> */</span><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Client</span> &#123;    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;        <span class="comment">// 发起人</span>        <span class="type">Originator</span> <span class="variable">originator</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Originator</span>();        <span class="comment">// 改变状态</span>        originator.changeState(<span class="string">&quot;ON&quot;</span>);        <span class="comment">// 存储发起人状态</span>        <span class="type">MementoIF</span> <span class="variable">memento</span> <span class="operator">=</span> originator.createMemento();        <span class="comment">// 改变状态</span>        originator.changeState(<span class="string">&quot;OFF&quot;</span>);        <span class="comment">// 恢复发起人状态</span>        originator.restoreMemento(memento);    &#125;&#125;</code></pre><blockquote><p>运行结果：</p><pre><code class="highlight shell">状态改变为：ON状态改变为：OFF状态改变为：ON</code></pre></blockquote><p>由于“自述历史”作为一个备忘录模式的特殊实现形式非常简单易懂，它可能是备忘录模式最为流行的实现形式。</p><blockquote><p>参考链接：<a href="https://www.cnblogs.com/java-my-life/archive/2012/06/06/2534942.html">https://www.cnblogs.com/java-my-life/archive/2012/06/06/2534942.html</a></p></blockquote>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;&lt;strong&gt;备忘录模式又叫做快照模式(Snapshot Pattern)或Token模式，是对象的行为模式。&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;备忘录对象是一个用来存储另外一个对象内部状态的快照的对象。备忘录模式的用意是在不破坏封装的条件下，将一个对象的状</summary>
      
    
    
    
    <category term="设计模式" scheme="https://georgechan95.github.io/categories/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"/>
    
    
    <category term="设计模式" scheme="https://georgechan95.github.io/tags/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"/>
    
  </entry>
  
  <entry>
    <title>20-中介者模式</title>
    <link href="https://georgechan95.github.io/blog/3148d6be.html"/>
    <id>https://georgechan95.github.io/blog/3148d6be.html</id>
    <published>2024-11-26T12:35:00.000Z</published>
    <updated>2024-11-27T05:21:35.927Z</updated>
    
    <content type="html"><![CDATA[<p><strong>中介者模式是对象的行为模式。中介者模式包装了一系列对象相互作用的方式，使得这些对象不必相互明显引用。从而使它们可以较松散地耦合。当这些对象中的某些对象之间的相互作用发生改变时，不会立即影响到其他的一些对象之间的相互作用。从而保证这些相互作用可以彼此独立地变化。</strong></p><h1 id="一、为什么需要中介者"><a href="#一、为什么需要中介者" class="headerlink" title="一、为什么需要中介者"></a>一、为什么需要中介者</h1><p>如下图所示，这个示意图中有大量的对象，这些对象既会影响别的对象，又会被别的对象所影响，因此常常叫做同事(Colleague)对象。这些同事对象通过彼此的相互作用形成系统的行为。从图中可以看出，几乎每一个对象都需要与其他的对象发生相互作用，而这种相互作用表现为一个对象与另一个对象的直接耦合。这就是过度耦合的系统。</p><p><img src="https://raw.githubusercontent.com/GeorgeChan95/blogimg/master/img/2024/11/26/20241126-122831.png" alt="过度耦合系统"></p><p>通过引入中介者对象(Mediator)，可以将系统的网状结构变成以中介者为中心的星形结构，如下图所示。在这个星形结构中，同事对象不再通过直接的联系与另一个对象发生相互作用；相反的，它通过中介者对象与另一个对象发生相互作用。中介者对象的存在保证了对象结构上的稳定，也就是说，系统的结构不会因为新对象的引入造成大量的修改工作。</p><p><img src="https://raw.githubusercontent.com/GeorgeChan95/blogimg/master/img/2024/11/26/20241126-122939.png" alt="有中介者的系统"></p><p>一个好的面向对象的设计可以使对象之间增加协作性(Collaboration)，减少耦合度(Couping)。一个深思熟虑的设计会把一个系统分解为一群相互协作的同事对象，然后给每一个同事对象以独特的责任，恰当的配置它们之间的协作关系，使它们可以在一起工作。</p><h1 id="二、中介者案例"><a href="#二、中介者案例" class="headerlink" title="二、中介者案例"></a>二、中介者案例</h1><h2 id="1-如果没有主板"><a href="#1-如果没有主板" class="headerlink" title="1. 如果没有主板"></a>1. 如果没有主板</h2><p>大家都知道，电脑里面各个配件之间的交互，主要是通过主板来完成的。如果电脑里面没有了主板，那么各个配件之间就必须自行相互交互，以互相传送数据。而且由于各个配件的接口不同，相互之间交互时，还必须把数据接口进行转换才能匹配上。</p><p><img src="https://raw.githubusercontent.com/GeorgeChan95/blogimg/master/img/2024/11/26/20241126-123241.png" alt="无主板的各组件之间的联系"></p><p>所幸是有了主板，各个配件的交互完全通过主板来完成，每个配件都只需要和主板交互，而主板知道如何跟所有的配件打交道，这样就简单多了。</p><p><img src="https://raw.githubusercontent.com/GeorgeChan95/blogimg/master/img/2024/11/26/20241126-123326.png" alt="通过主板连接各个组件"></p><h2 id="2-中介者模式的结构"><a href="#2-中介者模式的结构" class="headerlink" title="2. 中介者模式的结构"></a>2. 中介者模式的结构</h2><p>中介者模式的示意性类图如下所示：</p><p><img src="https://raw.githubusercontent.com/GeorgeChan95/blogimg/master/img/2024/11/26/20241126-123641.png" alt="中介者模式"></p><p>中介者模式包括以下角色：</p><ul><li><strong>抽象中介者(Mediator)角色：</strong>定义出同事对象到中介者对象的接口，其中主要方法是一个（或多个）事件方法。</li><li><strong>具体中介者(ConcreteMediator)角色：</strong>实现了抽象中介者所声明的事件方法。具体中介者知晓所有的具体同事类，并负责具体的协调各同事对象的交互关系。</li><li><strong>抽象同事类(Colleague)角色：</strong>定义出中介者到同事对象的接口。同事对象只知道中介者而不知道其余的同事对象。</li><li><strong>具体同事类(ConcreteColleague)角色：</strong>所有的具体同事类均从抽象同事类继承而来。实现自己的业务，在需要与其他同事通信的时候，就与持有的中介者通信，中介者会负责与其他的同事交互。</li></ul><p><strong>代码实现如下：</strong></p><pre><code class="highlight java"><span class="comment">/**</span><span class="comment"> * 抽象中介者类</span><span class="comment"> */</span><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">Mediator</span> &#123;    <span class="comment">/**</span><span class="comment">     * 同事对象在自身改变的时候来通知中介者方法</span><span class="comment">     * 让中介者去负责相应的与其他同事对象的交互</span><span class="comment">     */</span>    <span class="keyword">void</span> <span class="title function_">changed</span><span class="params">(Colleague c)</span>;&#125;<span class="comment">/**</span><span class="comment"> * 具体中介者</span><span class="comment"> */</span><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ConcreteMediator</span> <span class="keyword">implements</span> <span class="title class_">Mediator</span>&#123;    <span class="comment">// 持有并维护同事A</span>    <span class="keyword">private</span> ConcreteColleagueA colleagueA;    <span class="comment">// 持有并维护同事B</span>    <span class="keyword">private</span> ConcreteColleagueB colleagueB;    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setColleagueA</span><span class="params">(ConcreteColleagueA colleagueA)</span> &#123;        <span class="built_in">this</span>.colleagueA = colleagueA;    &#125;    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setColleagueB</span><span class="params">(ConcreteColleagueB colleagueB)</span> &#123;        <span class="built_in">this</span>.colleagueB = colleagueB;    &#125;    <span class="meta">@Override</span>    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">changed</span><span class="params">(Colleague c)</span> &#123;    &#125;&#125;<span class="comment">/**</span><span class="comment"> * 抽象同事类</span><span class="comment"> */</span><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">class</span> <span class="title class_">Colleague</span> &#123;    <span class="comment">// 持有一个中介者对象</span>    <span class="keyword">private</span> Mediator mediator;    <span class="keyword">public</span> <span class="title function_">Colleague</span><span class="params">(Mediator mediator)</span> &#123;        <span class="built_in">this</span>.mediator = mediator;    &#125;    <span class="comment">/**</span><span class="comment">     * 获取当前同事类对应的中介者对象</span><span class="comment">     * <span class="doctag">@return</span></span><span class="comment">     */</span>    <span class="keyword">public</span> Mediator <span class="title function_">getMediator</span><span class="params">()</span> &#123;        <span class="keyword">return</span> mediator;    &#125;&#125;<span class="comment">/**</span><span class="comment"> * 具体同事对象A</span><span class="comment"> */</span><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ConcreteColleagueA</span> <span class="keyword">extends</span> <span class="title class_">Colleague</span> &#123;    <span class="keyword">public</span> <span class="title function_">ConcreteColleagueA</span><span class="params">(Mediator mediator)</span> &#123;        <span class="built_in">super</span>(mediator);    &#125;    <span class="comment">/**</span><span class="comment">     * 示意方法，执行某些操作</span><span class="comment">     */</span>    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">operation</span><span class="params">()</span> &#123;        <span class="comment">//在需要跟其他同事通信的时候，通知中介者对象</span>        getMediator().changed(<span class="built_in">this</span>);    &#125;&#125;<span class="comment">/**</span><span class="comment"> * 具体同事对象B</span><span class="comment"> */</span><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ConcreteColleagueB</span> <span class="keyword">extends</span> <span class="title class_">Colleague</span> &#123;    <span class="keyword">public</span> <span class="title function_">ConcreteColleagueB</span><span class="params">(Mediator mediator)</span> &#123;        <span class="built_in">super</span>(mediator);    &#125;    <span class="comment">/**</span><span class="comment">     * 示意方法，执行某些操作</span><span class="comment">     */</span>    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">operation</span><span class="params">()</span> &#123;        <span class="comment">//在需要跟其他同事通信的时候，通知中介者对象</span>        getMediator().changed(<span class="built_in">this</span>);    &#125;&#125;</code></pre><h2 id="3-使用电脑来看电影"><a href="#3-使用电脑来看电影" class="headerlink" title="3. 使用电脑来看电影"></a>3. 使用电脑来看电影</h2><p>在日常生活中，我们经常使用电脑来看电影，把这个过程描述出来，简化后假定会有如下的交互过程：</p><ul><li>首先是光驱要读取光盘上的数据，然后告诉主板，它的状态改变了。</li><li>主板去得到光驱的数据，把这些数据交给CPU进行分析处理。</li><li>CPU处理完后，把数据分成了视频数据和音频数据，通知主板，它处理完了。</li><li>主板去得到CPU处理过后的数据，分别把数据交给显卡和声卡，去显示出视频和发出声音</li></ul><p>要使用中介者模式来实现示例，那就要区分出同事对象和中介者对象。很明显，主板是中介者，而光驱、声卡、CPU、显卡等配件，都是作为同事对象。</p><p><img src="https://raw.githubusercontent.com/GeorgeChan95/blogimg/master/img/2024/11/26/20241126-193234.png" alt="中介者模式应用"></p><p><strong>代码实现如下：</strong></p><pre><code class="highlight java"><span class="comment">/**</span><span class="comment"> * 抽象的同事类</span><span class="comment"> */</span><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">class</span> <span class="title class_">Colleague</span> &#123;    <span class="comment">// 持有一个中介者对象</span>    <span class="keyword">private</span> Mediator mediator;    <span class="keyword">public</span> <span class="title function_">Colleague</span><span class="params">(Mediator mediator)</span> &#123;        <span class="built_in">this</span>.mediator = mediator;    &#125;    <span class="comment">/**</span><span class="comment">     * 返回当前同事类持有的中介者对象</span><span class="comment">     * <span class="doctag">@return</span></span><span class="comment">     */</span>    <span class="keyword">public</span> Mediator <span class="title function_">getMediator</span><span class="params">()</span> &#123;        <span class="keyword">return</span> mediator;    &#125;&#125;<span class="comment">/**</span><span class="comment"> * 抽象中介者类</span><span class="comment"> */</span><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">Mediator</span> &#123;    <span class="comment">/**</span><span class="comment">     * 同事对象在自身改变的时候来通知中介者方法</span><span class="comment">     * 让中介者去负责相应的与其他同事对象的交互</span><span class="comment">     */</span>    <span class="keyword">void</span> <span class="title function_">changed</span><span class="params">(Colleague c)</span>;&#125;<span class="comment">/**</span><span class="comment"> * 同事类-光驱</span><span class="comment"> */</span><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">CDDriver</span> <span class="keyword">extends</span> <span class="title class_">Colleague</span> &#123;    <span class="comment">// 读取的数据</span>    <span class="keyword">private</span> String data;    <span class="keyword">public</span> <span class="title function_">CDDriver</span><span class="params">(Mediator mediator)</span> &#123;        <span class="built_in">super</span>(mediator);    &#125;    <span class="comment">/**</span><span class="comment">     * 读取数据</span><span class="comment">     * <span class="doctag">@return</span></span><span class="comment">     */</span>    <span class="keyword">public</span> String <span class="title function_">getData</span><span class="params">()</span> &#123;        <span class="keyword">return</span> data;    &#125;    <span class="comment">/**</span><span class="comment">     * 读取光盘</span><span class="comment">     */</span>    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">readCD</span><span class="params">()</span> &#123;        System.out.println(<span class="string">&quot;~驱动器工作中&quot;</span>);        <span class="comment">// 逗号前是视频显示的数据，逗号后是声音</span>        <span class="built_in">this</span>.data = <span class="string">&quot;One Piece,海贼王我当定了&quot;</span>;        <span class="comment">// 通知主板（中介者），已经读取到数据了</span>        <span class="built_in">this</span>.getMediator().changed(<span class="built_in">this</span>);    &#125;&#125;<span class="comment">/**</span><span class="comment"> * 同事类-CPU</span><span class="comment"> */</span><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">CPU</span> <span class="keyword">extends</span> <span class="title class_">Colleague</span> &#123;    <span class="comment">//分解出来的视频数据</span>    <span class="keyword">private</span> <span class="type">String</span> <span class="variable">videoData</span> <span class="operator">=</span> <span class="string">&quot;&quot;</span>;    <span class="comment">//分解出来的声音数据</span>    <span class="keyword">private</span> <span class="type">String</span> <span class="variable">soundData</span> <span class="operator">=</span> <span class="string">&quot;&quot;</span>;    <span class="keyword">public</span> <span class="title function_">CPU</span><span class="params">(Mediator mediator)</span> &#123;        <span class="built_in">super</span>(mediator);    &#125;    <span class="comment">/**</span><span class="comment">     * 获取视频数据</span><span class="comment">     * <span class="doctag">@return</span></span><span class="comment">     */</span>    <span class="keyword">public</span> String <span class="title function_">getVideoData</span><span class="params">()</span> &#123;        <span class="keyword">return</span> videoData;    &#125;    <span class="comment">/**</span><span class="comment">     * 获取音频数据</span><span class="comment">     * <span class="doctag">@return</span></span><span class="comment">     */</span>    <span class="keyword">public</span> String <span class="title function_">getSoundData</span><span class="params">()</span> &#123;        <span class="keyword">return</span> soundData;    &#125;    <span class="comment">/**</span><span class="comment">     * 接收主板调用，将数据解析成视频数据和音频数据</span><span class="comment">     * <span class="doctag">@param</span> data</span><span class="comment">     */</span>    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">executeData</span><span class="params">(String data)</span> &#123;        System.out.println(<span class="string">&quot;~CPU工作中&quot;</span>);        String[] dataArr = data.split(<span class="string">&quot;,&quot;</span>);        <span class="built_in">this</span>.soundData = dataArr[<span class="number">0</span>];        <span class="built_in">this</span>.videoData = dataArr[<span class="number">1</span>];        <span class="comment">// 解析完成后通知主板（中介者），进行下一步处理</span>        <span class="built_in">this</span>.getMediator().changed(<span class="built_in">this</span>);    &#125;&#125;<span class="comment">/**</span><span class="comment"> * 同事类-声卡</span><span class="comment"> */</span><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">SoundCard</span> <span class="keyword">extends</span> <span class="title class_">Colleague</span> &#123;    <span class="keyword">public</span> <span class="title function_">SoundCard</span><span class="params">(Mediator mediator)</span> &#123;        <span class="built_in">super</span>(mediator);    &#125;    <span class="comment">/**</span><span class="comment">     * 播放音频</span><span class="comment">     * <span class="doctag">@param</span> data</span><span class="comment">     */</span>    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">soundData</span><span class="params">(String data)</span> &#123;        System.out.println(<span class="string">&quot;~声卡工作中&quot;</span>);        System.out.println(<span class="string">&quot;您正在收听的是：&quot;</span> + data);    &#125;&#125;<span class="comment">/**</span><span class="comment"> * 同事类-显卡</span><span class="comment"> */</span><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">VideoCard</span> <span class="keyword">extends</span> <span class="title class_">Colleague</span> &#123;    <span class="keyword">public</span> <span class="title function_">VideoCard</span><span class="params">(Mediator mediator)</span> &#123;        <span class="built_in">super</span>(mediator);    &#125;    <span class="comment">/**</span><span class="comment">     * 播放视频内容</span><span class="comment">     * <span class="doctag">@param</span> data</span><span class="comment">     */</span>    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">showData</span><span class="params">(String data)</span> &#123;        System.out.println(<span class="string">&quot;~显卡工作中&quot;</span>);        System.out.println(<span class="string">&quot;您正在观看内容：&quot;</span> + data);    &#125;&#125;<span class="comment">/**</span><span class="comment"> * 具体中介者-主板</span><span class="comment"> */</span><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">MainBoard</span> <span class="keyword">implements</span> <span class="title class_">Mediator</span> &#123;    <span class="comment">// 驱动</span>    <span class="keyword">private</span> CDDriver cdDriver;    <span class="comment">// CPU</span>    <span class="keyword">private</span> CPU cpu;    <span class="comment">// 声卡</span>    <span class="keyword">private</span> SoundCard soundCard;    <span class="comment">// 显卡</span>    <span class="keyword">private</span> VideoCard videoCard;    <span class="meta">@Override</span>    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">changed</span><span class="params">(Colleague c)</span> &#123;        <span class="keyword">if</span> (c <span class="keyword">instanceof</span> CDDriver) &#123;            <span class="comment">// 数据读取</span>            <span class="built_in">this</span>.cdDriverReadData((CDDriver) c);        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (c <span class="keyword">instanceof</span> CPU) &#123;            <span class="built_in">this</span>.openCPU((CPU) c);        &#125;    &#125;    <span class="comment">/**</span><span class="comment">     * CDDriver读取数据，调用CPU处理数据</span><span class="comment">     * <span class="doctag">@param</span> cdDriver</span><span class="comment">     */</span>    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">cdDriverReadData</span><span class="params">(CDDriver cdDriver)</span> &#123;        <span class="type">String</span> <span class="variable">data</span> <span class="operator">=</span> cdDriver.getData();        cpu.executeData(data);    &#125;    <span class="comment">/**</span><span class="comment">     * CPU解析数据，调用显卡、声卡处理数据</span><span class="comment">     * <span class="doctag">@param</span> cpu</span><span class="comment">     */</span>    <span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">openCPU</span><span class="params">(CPU cpu)</span> &#123;        <span class="comment">// 解析数据</span>        <span class="type">String</span> <span class="variable">soundData</span> <span class="operator">=</span> cpu.getSoundData();        <span class="type">String</span> <span class="variable">videoData</span> <span class="operator">=</span> cpu.getVideoData();        <span class="comment">// 声卡播放数据</span>        <span class="built_in">this</span>.soundCard.soundData(soundData);        <span class="comment">// 显卡播放数据</span>        <span class="built_in">this</span>.videoCard.showData(videoData);    &#125;    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setCdDriver</span><span class="params">(CDDriver cdDriver)</span> &#123;        <span class="built_in">this</span>.cdDriver = cdDriver;    &#125;    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setCpu</span><span class="params">(CPU cpu)</span> &#123;        <span class="built_in">this</span>.cpu = cpu;    &#125;    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setSoundCard</span><span class="params">(SoundCard soundCard)</span> &#123;        <span class="built_in">this</span>.soundCard = soundCard;    &#125;    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setVideoCard</span><span class="params">(VideoCard videoCard)</span> &#123;        <span class="built_in">this</span>.videoCard = videoCard;    &#125;&#125;<span class="comment">/**</span><span class="comment"> * 测试类</span><span class="comment"> */</span><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Client</span> &#123;    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;        <span class="comment">// 创建中介者</span>        <span class="type">MainBoard</span> <span class="variable">mainBoard</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">MainBoard</span>();        <span class="comment">// 具体同事类-驱动器</span>        <span class="type">CDDriver</span> <span class="variable">cdDriver</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">CDDriver</span>(mainBoard);        <span class="comment">// 具体同事类-CPU</span>        <span class="type">CPU</span> <span class="variable">cpu</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">CPU</span>(mainBoard);        <span class="comment">// 具体同事类-显卡</span>        <span class="type">VideoCard</span> <span class="variable">videoCard</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">VideoCard</span>(mainBoard);        <span class="comment">// 具体同事类-声卡</span>        <span class="type">SoundCard</span> <span class="variable">soundCard</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">SoundCard</span>(mainBoard);        <span class="comment">// 设置中介者管理的同事类</span>        mainBoard.setCdDriver(cdDriver);        mainBoard.setCpu(cpu);        mainBoard.setSoundCard(soundCard);        mainBoard.setVideoCard(videoCard);        <span class="comment">// 开始读取CD</span>        cdDriver.readCD();    &#125;&#125;</code></pre><blockquote><p>运行结果</p><pre><code class="highlight shell">~驱动器工作中~CPU工作中~声卡工作中您正在收听的是：One Piece~显卡工作中您正在观看内容：海贼王我当定了</code></pre></blockquote><h1 id="三、中介者模式的优-缺点"><a href="#三、中介者模式的优-缺点" class="headerlink" title="三、中介者模式的优&#x2F;缺点"></a>三、中介者模式的优&#x2F;缺点</h1><h2 id="1-优点"><a href="#1-优点" class="headerlink" title="1. 优点"></a>1. 优点</h2><ul><li><p><strong>松散耦合</strong></p><p>中介者模式通过把多个同事对象之间的交互封装到中介者对象里面，从而使得同事对象之间松散耦合，基本上可以做到互不依赖。这样一来，同事对象就可以独立地变化和复用，而不再像以前那样“牵一处而动全身”了。</p></li><li><p><strong>集中控制交互</strong></p><p>多个同事对象的交互，被封装在中介者对象里面集中管理，使得这些交互行为发生变化的时候，只需要修改中介者对象就可以了，当然如果是已经做好的系统，那么就扩展中介者对象，而各个同事类不需要做修改。</p></li><li><p><strong>多对多变成一对多</strong></p><p>没有使用中介者模式的时候，同事对象之间的关系通常是多对多的，引入中介者对象以后，中介者对象和同事对象的关系通常变成双向的一对多，这会让对象的关系更容易理解和实现。</p></li></ul><h2 id="2-缺点"><a href="#2-缺点" class="headerlink" title="2. 缺点"></a>2. 缺点</h2><p>中介者模式的一个潜在缺点是，过度集中化。如果同事对象的交互非常多，而且比较复杂，当这些复杂性全部集中到中介者的时候，会导致中介者对象变得十分复杂，而且难于管理和维护。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;&lt;strong&gt;中介者模式是对象的行为模式。中介者模式包装了一系列对象相互作用的方式，使得这些对象不必相互明显引用。从而使它们可以较松散地耦合。当这些对象中的某些对象之间的相互作用发生改变时，不会立即影响到其他的一些对象之间的相互作用。从而保证这些相互作用可以彼此独立地变化</summary>
      
    
    
    
    <category term="设计模式" scheme="https://georgechan95.github.io/categories/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"/>
    
    
    <category term="设计模式" scheme="https://georgechan95.github.io/tags/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"/>
    
  </entry>
  
  <entry>
    <title>19-观察者模式</title>
    <link href="https://georgechan95.github.io/blog/f06aea0b.html"/>
    <id>https://georgechan95.github.io/blog/f06aea0b.html</id>
    <published>2024-11-25T13:07:00.000Z</published>
    <updated>2024-11-25T12:38:35.384Z</updated>
    
    <content type="html"><![CDATA[<p><strong>观察者模式是对象的行为模式，又叫发布-订阅(Publish&#x2F;Subscribe)模式、模型-视图(Model&#x2F;View)模式、源-监听器(Source&#x2F;Listener)模式或从属者(Dependents)模式。</strong></p><p><strong>观察者模式定义了一种一对多的依赖关系，让多个观察者对象同时监听某一个主题对象。这个主题对象在状态上发生变化时，会通知所有观察者对象，使它们能够自动更新自己。</strong></p><h1 id="一、观察者模式的结构"><a href="#一、观察者模式的结构" class="headerlink" title="一、观察者模式的结构"></a>一、观察者模式的结构</h1><p>一个软件系统里面包含了各种对象，就像一片欣欣向荣的森林充满了各种生物一样。在一片森林中，各种生物彼此依赖和约束，形成一个个生物链。一种生物的状态变化会造成其他一些生物的相应行动，每一个生物都处于别的生物的互动之中。</p><p>同样，一个软件系统常常要求在某一个对象的状态发生变化的时候，某些其他的对象做出相应的改变。做到这一点的设计方案有很多，但是为了使系统能够易于复用，应该选择低耦合度的设计方案。减少对象之间的耦合有利于系统的复用，但是同时设计师需要使这些低耦合度的对象之间能够维持行动的协调一致，保证高度的协作。观察者模式是满足这一要求的各种设计方案中最重要的一种。</p><p>下面以一个简单的示意性实现为例，讨论观察者模式的结构。</p><p><img src="https://raw.githubusercontent.com/GeorgeChan95/blogimg/master/img/2024/11/25/20241125-193801.png" alt="观察者模式"></p><p><em>观察者模式所涉及的角色有：</em></p><ul><li><strong>抽象主题(Subject)角色：</strong>抽象主题角色把所有对观察者对象的引用保存在一个聚集（比如ArrayList对象）里，每个主题都可以有任何数量的观察者。抽象主题提供一个接口，可以增加和删除观察者对象，抽象主题角色又叫做抽象被观察者(Observable)角色。</li><li><strong>具体主题(ConcreteSubject)角色：</strong>将有关状态存入具体观察者对象；在具体主题的内部状态改变时，给所有登记过的观察者发出通知。具体主题角色又叫做具体被观察者(Concrete Observable)角色。</li><li><strong>抽象观察者(Observer)角色：</strong>为所有的具体观察者定义一个接口，在得到主题的通知时更新自己，这个接口叫做更新接口。</li><li><strong>具体观察者(ConcreteObserver)角色：</strong>存储与主题的状态自恰的状态。具体观察者角色实现抽象观察者角色所要求的更新接口，以便使本身的状态与主题的状态相协调。如果需要，具体观察者角色可以保持一个指向具体主题对象的引用。</li></ul><p><strong>代码实现如下：</strong></p><pre><code class="highlight java"><span class="comment">/**</span><span class="comment"> * 抽象主题角色</span><span class="comment"> */</span><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">class</span> <span class="title class_">Subject</span> &#123;    <span class="comment">/**</span><span class="comment">     * 保存注册的观察者对象</span><span class="comment">     */</span>    <span class="keyword">private</span> List&lt;Observer&gt; list = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();    <span class="comment">/**</span><span class="comment">     * 注册观察者</span><span class="comment">     * <span class="doctag">@param</span> observer</span><span class="comment">     */</span>    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">attach</span><span class="params">(Observer observer)</span> &#123;        list.add(observer);        System.out.println(<span class="string">&quot;注册了一个观察者对象&quot;</span>);    &#125;    <span class="comment">/**</span><span class="comment">     * 移除观察者</span><span class="comment">     * <span class="doctag">@param</span> observer</span><span class="comment">     */</span>    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">detach</span><span class="params">(Observer observer)</span> &#123;        list.remove(observer);    &#125;    <span class="comment">/**</span><span class="comment">     * 通知所有的观察者对象</span><span class="comment">     * <span class="doctag">@param</span> newState</span><span class="comment">     */</span>    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">notifyObservers</span><span class="params">(String newState)</span> &#123;        <span class="keyword">for</span> (Observer observer : list) &#123;            observer.update(newState);        &#125;    &#125;&#125;<span class="comment">/**</span><span class="comment"> * 具体的观察者对象</span><span class="comment"> */</span><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ConcreteSubject</span> <span class="keyword">extends</span> <span class="title class_">Subject</span> &#123;    <span class="keyword">private</span> String state;    <span class="keyword">public</span> String <span class="title function_">getState</span><span class="params">()</span> &#123;        <span class="keyword">return</span> state;    &#125;    <span class="comment">/**</span><span class="comment">     * 主题状态更新方法</span><span class="comment">     * <span class="doctag">@param</span> newState 新状态</span><span class="comment">     */</span>    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">change</span><span class="params">(String newState)</span> &#123;        <span class="built_in">this</span>.state = newState;        System.out.println(<span class="string">&quot;主题状态为：&quot;</span> + state);        <span class="comment">//状态发生改变，通知各个观察者</span>        <span class="built_in">super</span>.notifyObservers(newState);    &#125;&#125;<span class="comment">/**</span><span class="comment"> * 抽象观察者</span><span class="comment"> */</span><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">Observer</span> &#123;    <span class="comment">/**</span><span class="comment">     * 观察者更新接口</span><span class="comment">     * <span class="doctag">@param</span> newState</span><span class="comment">     */</span>    <span class="keyword">void</span> <span class="title function_">update</span><span class="params">(String newState)</span>;&#125;<span class="comment">/**</span><span class="comment"> * 具体的观察者</span><span class="comment"> */</span><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ConcreteObserver</span> <span class="keyword">implements</span> <span class="title class_">Observer</span> &#123;    <span class="comment">// 观察者的状态</span>    <span class="keyword">private</span> String observerState;    <span class="meta">@Override</span>    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">update</span><span class="params">(String newState)</span> &#123;        <span class="built_in">this</span>.observerState = newState;        <span class="comment">/**</span><span class="comment">         * 更新观察者的状态，使其与目标的状态保持一致</span><span class="comment">         */</span>        System.out.println(<span class="string">&quot;观察者的状态更新为：&quot;</span> + <span class="built_in">this</span>.observerState);    &#125;&#125;<span class="comment">// 测试类</span><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Client</span> &#123;    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;        <span class="comment">// 创建观察者</span>        <span class="type">Observer</span> <span class="variable">observer1</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ConcreteObserver</span>();        <span class="type">Observer</span> <span class="variable">observer2</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ConcreteObserver</span>();        <span class="comment">// 创建具体的主题</span>        <span class="type">ConcreteSubject</span> <span class="variable">subject</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ConcreteSubject</span>();        <span class="comment">// 给主题注册观察者</span>        subject.attach(observer1);        subject.attach(observer2);        <span class="comment">// 更新主题状态</span>        subject.change(<span class="string">&quot;doWork&quot;</span>);        <span class="comment">// 主题移除观察者</span>        subject.detach(observer2);        <span class="comment">// 更新主题状态</span>        subject.change(<span class="string">&quot;sleep&quot;</span>);    &#125;&#125;</code></pre><blockquote><p>运行结果：</p><pre><code class="highlight shell">注册了一个观察者对象注册了一个观察者对象主题状态为：doWork观察者的状态更新为：doWork观察者的状态更新为：doWork主题状态为：sleep观察者的状态更新为：sleep</code></pre></blockquote><p>在运行时，这个客户端首先创建了具体主题类的实例，以及一个观察者对象。然后，它调用主题对象的attach()方法，将这个观察者对象向主题对象登记，也就是将它加入到主题对象的聚集中去。</p><p>这时，客户端调用主题的change()方法，改变了主题对象的内部状态。主题对象在状态发生变化时，调用超类的notifyObservers()方法，通知所有登记过的观察者对象。</p><h1 id="二、推模型和拉模型"><a href="#二、推模型和拉模型" class="headerlink" title="二、推模型和拉模型"></a>二、推模型和拉模型</h1><p>在观察者模式中，又分为推模型和拉模型两种方式。</p><ul><li><p><strong>推模型</strong></p><p>主题对象向观察者推送主题的详细信息，不管观察者是否需要，推送的信息通常是主题对象的全部或部分数据。</p></li><li><p><strong>拉模型</strong></p><p>主题对象在通知观察者的时候，只传递少量信息。如果观察者需要更具体的信息，由观察者主动到主题对象中获取，相当于是观察者从主题对象中拉数据。一般这种模型的实现中，会把主题对象自身通过update()方法传递给观察者，这样在观察者需要获取数据的时候，就可以通过这个引用来获取了。</p></li></ul><p>　根据上面的描述，发现前面的例子就是典型的推模型，下面给出一个拉模型的实例。</p><h2 id="1-拉模型的抽象观察者类"><a href="#1-拉模型的抽象观察者类" class="headerlink" title="1. 拉模型的抽象观察者类"></a>1. 拉模型的抽象观察者类</h2><p><strong>代码实现如下：</strong></p><pre><code class="highlight java"><span class="comment">// 拉模型通常都是把主题对象当做参数传递。</span><span class="comment">/**</span><span class="comment"> * 抽象观察者角色</span><span class="comment"> */</span><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">Observer</span> &#123;    <span class="comment">/**</span><span class="comment">     * 更新接口</span><span class="comment">     * <span class="doctag">@param</span> subject 传入主题对象，方面获取相应的主题对象的状态</span><span class="comment">     */</span>    <span class="keyword">void</span> <span class="title function_">update</span><span class="params">(Subject subject)</span>;&#125;<span class="comment">/**</span><span class="comment"> * 具体的观察者</span><span class="comment"> */</span><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ConcreteObserver</span> <span class="keyword">implements</span> <span class="title class_">Observer</span> &#123;    <span class="comment">// 观察者的状态</span>    <span class="keyword">private</span> String observerState;    <span class="meta">@Override</span>    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">update</span><span class="params">(Subject subject)</span> &#123;        <span class="built_in">this</span>.observerState = ((ConcreteSubject) subject).getState();        <span class="comment">/**</span><span class="comment">         * 更新观察者的状态，使其与目标的状态保持一致</span><span class="comment">         */</span>        System.out.println(<span class="string">&quot;观察者的状态更新为：&quot;</span> + <span class="built_in">this</span>.observerState);    &#125;&#125;<span class="comment">/**</span><span class="comment"> * 抽象主题角色</span><span class="comment"> */</span><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">class</span> <span class="title class_">Subject</span> &#123;    <span class="comment">/**</span><span class="comment">     * 保存注册的观察者对象</span><span class="comment">     */</span>    <span class="keyword">private</span> List&lt;Observer&gt; list = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();    <span class="comment">/**</span><span class="comment">     * 注册观察者</span><span class="comment">     * <span class="doctag">@param</span> observer</span><span class="comment">     */</span>    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">attach</span><span class="params">(Observer observer)</span> &#123;        list.add(observer);        System.out.println(<span class="string">&quot;注册了一个观察者对象&quot;</span>);    &#125;    <span class="comment">/**</span><span class="comment">     * 移除观察者</span><span class="comment">     * <span class="doctag">@param</span> observer</span><span class="comment">     */</span>    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">detach</span><span class="params">(Observer observer)</span> &#123;        list.remove(observer);    &#125;    <span class="comment">/**</span><span class="comment">     * 通知所有的观察者对象</span><span class="comment">     */</span>    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">notifyObservers</span><span class="params">()</span> &#123;        <span class="keyword">for</span> (Observer observer : list) &#123;            observer.update(<span class="built_in">this</span>);        &#125;    &#125;&#125;<span class="comment">/**</span><span class="comment"> * 具体的观察者对象</span><span class="comment"> */</span><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ConcreteSubject</span> <span class="keyword">extends</span> <span class="title class_">Subject</span> &#123;    <span class="keyword">private</span> String state;    <span class="keyword">public</span> String <span class="title function_">getState</span><span class="params">()</span> &#123;        <span class="keyword">return</span> state;    &#125;    <span class="comment">/**</span><span class="comment">     * 主题状态更新方法</span><span class="comment">     * <span class="doctag">@param</span> newState 新状态</span><span class="comment">     */</span>    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">change</span><span class="params">(String newState)</span> &#123;        <span class="built_in">this</span>.state = newState;        System.out.println(<span class="string">&quot;主题状态为：&quot;</span> + state);        <span class="comment">//状态发生改变，通知各个观察者</span>        <span class="built_in">super</span>.notifyObservers();    &#125;&#125;<span class="comment">// 测试类</span><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Client</span> &#123;    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;        <span class="comment">// 创建观察者</span>        <span class="type">Observer</span> <span class="variable">observer1</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ConcreteObserver</span>();        <span class="type">Observer</span> <span class="variable">observer2</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ConcreteObserver</span>();        <span class="comment">// 创建具体的主题</span>        <span class="type">ConcreteSubject</span> <span class="variable">subject</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ConcreteSubject</span>();        <span class="comment">// 给主题注册观察者</span>        subject.attach(observer1);        subject.attach(observer2);        <span class="comment">// 更新主题状态</span>        subject.change(<span class="string">&quot;doWork&quot;</span>);        <span class="comment">// 主题移除观察者</span>        subject.detach(observer2);        <span class="comment">// 更新主题状态</span>        subject.change(<span class="string">&quot;sleep&quot;</span>);    &#125;&#125;</code></pre><blockquote><p>运行结果：</p><pre><code class="highlight shell">注册了一个观察者对象注册了一个观察者对象主题状态为：doWork观察者的状态更新为：doWork观察者的状态更新为：doWork主题状态为：sleep观察者的状态更新为：sleep</code></pre></blockquote><h2 id="2-两种模式的比较"><a href="#2-两种模式的比较" class="headerlink" title="2. 两种模式的比较"></a>2. 两种模式的比较</h2><ul><li>推模型是假定主题对象知道观察者需要的数据；而拉模型是主题对象不知道观察者具体需要什么数据，没有办法的情况下，干脆把自身传递给观察者，让观察者自己去按需要取值。</li><li>推模型可能会使得观察者对象难以复用，因为观察者的 <code>update()</code> 方法是按需要定义的参数，可能无法兼顾没有考虑到的使用情况。这就意味着出现新情况的时候，就可能提供新的 <code>update()</code> 方法，或者是干脆重新实现观察者；而拉模型就不会造成这样的情况，因为拉模型下，<code>update()</code> 方法的参数是主题对象本身，这基本上是主题对象能传递的最大数据集合了，基本上可以适应各种情况的需要。</li></ul><h1 id="三、JAVA提供的对观察者模式的支持"><a href="#三、JAVA提供的对观察者模式的支持" class="headerlink" title="三、JAVA提供的对观察者模式的支持"></a>三、JAVA提供的对观察者模式的支持</h1><p>在JAVA语言的java.util库里面，提供了一个<code>Observable类</code> 以及一个 <code>Observer接口</code> ，构成JAVA语言对观察者模式的支持。</p><h2 id="1-Observer接口"><a href="#1-Observer接口" class="headerlink" title="1. Observer接口"></a>1. Observer接口</h2><p>这个接口只定义了一个方法，即 <code>update()</code> 方法，当被观察者对象的状态发生变化时，被观察者对象的notifyObservers()方法就会调用这一方法。</p><pre><code class="highlight java"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">Observer</span> &#123;    <span class="keyword">void</span> <span class="title function_">update</span><span class="params">(Observable o, Object arg)</span>;&#125;</code></pre><h2 id="2-Observable类"><a href="#2-Observable类" class="headerlink" title="2. Observable类"></a>2. Observable类</h2><p>被观察者类都是 <code>java.util.Observable</code> 类的子类。<code>java.util.Observable</code> 提供公开的方法支持观察者对象，这些方法中有两个对Observable的子类非常重要：一个是 <code>setChanged()</code>，另一个是 <code>notifyObservers()</code> 。第一方法 <code>setChanged()</code> 被调用之后会设置一个内部标记变量，代表被观察者对象的状态发生了变化。第二个是 <code>notifyObservers()</code>，这个方法被调用时，会调用所有登记过的观察者对象的update()方法，使这些观察者对象可以更新自己。</p><pre><code class="highlight java"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Observable</span> &#123;    <span class="keyword">private</span> <span class="type">boolean</span> <span class="variable">changed</span> <span class="operator">=</span> <span class="literal">false</span>;    <span class="keyword">private</span> Vector obs;       <span class="comment">/** Construct an Observable with zero Observers. */</span>    <span class="keyword">public</span> <span class="title function_">Observable</span><span class="params">()</span> &#123;    obs = <span class="keyword">new</span> <span class="title class_">Vector</span>();    &#125;    <span class="comment">/**</span><span class="comment">     * 将一个观察者添加到观察者聚集上面</span><span class="comment">     */</span>    <span class="keyword">public</span> <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title function_">addObserver</span><span class="params">(Observer o)</span> &#123;        <span class="keyword">if</span> (o == <span class="literal">null</span>)            <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">NullPointerException</span>();    <span class="keyword">if</span> (!obs.contains(o)) &#123;        obs.addElement(o);    &#125;    &#125;    <span class="comment">/**</span><span class="comment">     * 将一个观察者从观察者聚集上删除</span><span class="comment">     */</span>    <span class="keyword">public</span> <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title function_">deleteObserver</span><span class="params">(Observer o)</span> &#123;        obs.removeElement(o);    &#125;    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">notifyObservers</span><span class="params">()</span> &#123;    notifyObservers(<span class="literal">null</span>);    &#125;    <span class="comment">/**</span><span class="comment">     * 如果本对象有变化（那时hasChanged 方法会返回true）</span><span class="comment">     * 调用本方法通知所有登记的观察者，即调用它们的update()方法</span><span class="comment">     * 传入this和arg作为参数</span><span class="comment">     */</span>    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">notifyObservers</span><span class="params">(Object arg)</span> &#123;        Object[] arrLocal;    <span class="keyword">synchronized</span> (<span class="built_in">this</span>) &#123;        <span class="keyword">if</span> (!changed)                <span class="keyword">return</span>;            arrLocal = obs.toArray();            clearChanged();        &#125;        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> arrLocal.length-<span class="number">1</span>; i&gt;=<span class="number">0</span>; i--)            ((Observer)arrLocal[i]).update(<span class="built_in">this</span>, arg);    &#125;    <span class="comment">/**</span><span class="comment">     * 将观察者聚集清空</span><span class="comment">     */</span>    <span class="keyword">public</span> <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title function_">deleteObservers</span><span class="params">()</span> &#123;    obs.removeAllElements();    &#125;    <span class="comment">/**</span><span class="comment">     * 将“已变化”设置为true</span><span class="comment">     */</span>    <span class="keyword">protected</span> <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title function_">setChanged</span><span class="params">()</span> &#123;    changed = <span class="literal">true</span>;    &#125;    <span class="comment">/**</span><span class="comment">     * 将“已变化”重置为false</span><span class="comment">     */</span>    <span class="keyword">protected</span> <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title function_">clearChanged</span><span class="params">()</span> &#123;    changed = <span class="literal">false</span>;    &#125;    <span class="comment">/**</span><span class="comment">     * 检测本对象是否已变化</span><span class="comment">     */</span>    <span class="keyword">public</span> <span class="keyword">synchronized</span> <span class="type">boolean</span> <span class="title function_">hasChanged</span><span class="params">()</span> &#123;    <span class="keyword">return</span> changed;    &#125;    <span class="comment">/**</span><span class="comment">     * Returns the number of observers of this &lt;tt&gt;Observable&lt;/tt&gt; object.</span><span class="comment">     *</span><span class="comment">     * <span class="doctag">@return</span>  the number of observers of this object.</span><span class="comment">     */</span>    <span class="keyword">public</span> <span class="keyword">synchronized</span> <span class="type">int</span> <span class="title function_">countObservers</span><span class="params">()</span> &#123;    <span class="keyword">return</span> obs.size();    &#125;&#125;</code></pre><p>这个类代表一个被观察者对象，有时称之为主题对象。一个被观察者对象可以有数个观察者对象，每个观察者对象都是实现Observer接口的对象。在被观察者发生变化时，会调用Observable的 <code>notifyObservers()</code> 方法，此方法调用所有的具体观察者的update()方法，从而使所有的观察者都被通知更新自己。</p><h1 id="四、怎样使用JAVA对观察者模式的支持"><a href="#四、怎样使用JAVA对观察者模式的支持" class="headerlink" title="四、怎样使用JAVA对观察者模式的支持"></a>四、怎样使用JAVA对观察者模式的支持</h1><p>这里给出一个非常简单的例子，说明怎样使用JAVA所提供的对观察者模式的支持。在这个例子中，被观察对象叫做 <code>Watched</code>；而观察者对象叫做 <code>Watcher</code>。<code>Watched</code> 对象继承自 <code>java.util.Observable</code> 类；而<code>Watcher</code>对象实现了 <code>java.util.Observer</code> 接口。另外有一个Test类扮演客户端角色。</p><p><strong>代码实现如下：</strong></p><pre><code class="highlight java"><span class="comment">/**</span><span class="comment"> * 主题角色</span><span class="comment"> */</span><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Watched</span> <span class="keyword">extends</span> <span class="title class_">Observable</span> &#123;    <span class="keyword">private</span> String data;    <span class="keyword">public</span> String <span class="title function_">getData</span><span class="params">()</span> &#123;        <span class="keyword">return</span> data;    &#125;    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setData</span><span class="params">(String data)</span> &#123;        <span class="keyword">if</span> (!data.equals(<span class="built_in">this</span>.data)) &#123;            <span class="built_in">this</span>.data = data;            <span class="comment">// 调用父类方法，更新 changed标识</span>            setChanged();        &#125;        <span class="comment">// 调用父类方法， 更新观察者</span>        notifyObservers();    &#125;&#125;<span class="comment">// 观察者角色</span><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Watcher</span> <span class="keyword">implements</span> <span class="title class_">Observer</span> &#123;    <span class="keyword">public</span> <span class="title function_">Watcher</span><span class="params">(Observable observable)</span> &#123;        <span class="comment">// 添加观察者到主题中</span>        observable.addObserver(<span class="built_in">this</span>);    &#125;    <span class="meta">@Override</span>    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">update</span><span class="params">(Observable o, Object arg)</span> &#123;        System.out.println(<span class="string">&quot;主题状态发生改变：&quot;</span> + ((Watched)o).getData());    &#125;&#125;<span class="comment">// 测试类</span><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Test</span> &#123;    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;        <span class="comment">//创建被观察者对象</span>        <span class="type">Watched</span> <span class="variable">watched</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Watched</span>();        <span class="comment">//创建观察者对象，并将被观察者对象登记</span>        <span class="type">Observer</span> <span class="variable">watcher</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Watcher</span>(watched);        <span class="comment">//给被观察者状态赋值</span>        watched.setData(<span class="string">&quot;start&quot;</span>);        watched.setData(<span class="string">&quot;run&quot;</span>);        watched.setData(<span class="string">&quot;stop&quot;</span>);    &#125;&#125;</code></pre><blockquote><p>运行结果：</p><pre><code class="highlight shell">主题状态发生改变：start主题状态发生改变：run主题状态发生改变：stop</code></pre></blockquote><p>Test对象首先创建了Watched和Watcher对象。在创建Watcher对象时，将Watched对象作为参数传入；然后Test对象调用Watched对象的setData()方法，触发Watched对象的内部状态变化；Watched对象进而通知实现登记过的Watcher对象，也就是调用它的update()方法。</p><p>参考链接：<a href="https://www.cnblogs.com/java-my-life/archive/2012/05/16/2502279.html">https://www.cnblogs.com/java-my-life/archive/2012/05/16/2502279.html</a></p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;&lt;strong&gt;观察者模式是对象的行为模式，又叫发布-订阅(Publish&amp;#x2F;Subscribe)模式、模型-视图(Model&amp;#x2F;View)模式、源-监听器(Source&amp;#x2F;Listener)模式或从属者(Dependents)模式。&lt;/strong</summary>
      
    
    
    
    <category term="设计模式" scheme="https://georgechan95.github.io/categories/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"/>
    
    
    <category term="设计模式" scheme="https://georgechan95.github.io/tags/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"/>
    
  </entry>
  
  <entry>
    <title>18-迭代器模式</title>
    <link href="https://georgechan95.github.io/blog/7dbd9149.html"/>
    <id>https://georgechan95.github.io/blog/7dbd9149.html</id>
    <published>2024-11-23T16:02:00.000Z</published>
    <updated>2024-11-25T01:24:55.343Z</updated>
    
    <content type="html"><![CDATA[<p><strong>迭代器模式又叫游标(Cursor)模式，是对象的行为模式。迭代器模式可以顺序地访问一个聚集中的元素而不必暴露聚集的内部表象（<em>internal representation</em>）。</strong></p><h1 id="一、聚集和Java聚集"><a href="#一、聚集和Java聚集" class="headerlink" title="一、聚集和Java聚集"></a>一、聚集和Java聚集</h1><p>多个对象聚在一起形成的总体称之为聚集(Aggregate)，聚集对象是能够包容一组对象的容器对象。聚集依赖于聚集结构的抽象化，具有复杂化和多样性。数组就是最基本的聚集，也是其他的JAVA聚集对象的设计基础。</p><p>JAVA聚集对象是实现了共同的java.util.Collection接口的对象，是JAVA语言对聚集概念的直接支持。从1.2版开始，JAVA语言提供了很多种聚集，包括Vector、ArrayList、HashSet、HashMap、Hashtable等，这些都是JAVA聚集的例子。</p><h1 id="二、迭代器模式的结构"><a href="#二、迭代器模式的结构" class="headerlink" title="二、迭代器模式的结构"></a>二、迭代器模式的结构</h1><p>迭代器模式有两种实现方式，分别是<strong>白箱聚集与外禀迭代器</strong>和<strong>黑箱聚集于内禀迭代器。</strong></p><h2 id="1-白箱聚集与外禀迭代器"><a href="#1-白箱聚集与外禀迭代器" class="headerlink" title="1. 白箱聚集与外禀迭代器"></a>1. 白箱聚集与外禀迭代器</h2><h3 id="1-1-理论概述"><a href="#1-1-理论概述" class="headerlink" title="1.1 理论概述"></a>1.1 理论概述</h3><p>如果一个聚集的接口提供了可以用来修改聚集元素的方法，这个接口就是所谓的<strong>宽接口</strong>。</p><p>如果聚集对象为所有对象提供同一个接口，也就是宽接口的话，当然会满足迭代器模式对迭代器对象的要求。但是，这样会破坏对聚集对象的封装。这种提供宽接口的聚集叫做<strong>白箱聚集</strong>。聚集对象向外界提供同样的宽接口，如下图所示：</p><p><img src="https://raw.githubusercontent.com/GeorgeChan95/blogimg/master/img/2024/11/24/20241124-135235.png" alt="宽接口"></p><p>由于聚集自己实现迭代逻辑，并向外部提供适当的接口，使得迭代器可以从外部控制聚集元素的迭代过程。这样一来迭代器所控制的仅仅是一个游标而已，这种迭代器叫做<strong>游标迭代器（Cursor Iterator）</strong>。由于迭代器是在聚集结构之外的，因此这样的迭代器又叫做<strong>外禀迭代器（Extrinsic Iterator）</strong>。</p><p>现在看一看白箱聚集与外禀迭代器的实现。一个白箱聚集向外界提供访问自己内部元素的接口（称作遍历方法或者Traversing Method），从而使外禀迭代器可以通过聚集的遍历方法实现迭代功能。</p><p>因为迭代的逻辑是由聚集对象本身提供的，所以这样的外禀迭代器角色往往仅仅保持迭代的游标位置。</p><p>一个典型的由白箱聚集与外禀迭代器组成的系统如下图所示，在这个实现中具体迭代器角色是一个外部类，而具体聚集角色向外界提供遍历聚集元素的接口。</p><p><img src="https://raw.githubusercontent.com/GeorgeChan95/blogimg/master/img/2024/11/24/20241124-135617.png" alt="外禀迭代器"></p><p>迭代器模式涉及到以下几个角色：</p><ul><li>抽象迭代器器(Iterator)角色：此抽象角色定义出遍历元素所需的接口。</li><li>具体迭代器(ConcreteIterator)角色：此角色实现了Iterator接口，并保持迭代过程中的游标位置。</li><li>聚集(Aggregate)角色：此抽象角色给出创建迭代器(Iterator)对象的接口。</li><li>具体聚集(ConcreteAggregate)角色：实现了创建迭代器(Iterator)对象的接口，返回一个合适的具体迭代器实例。</li><li>客户端(Client)角色：持有对聚集及其迭代器对象的引用，调用迭代器对象的迭代接口，也有可能通过迭代器操作聚集元素的增加和删除。</li></ul><h3 id="1-2-代码实现"><a href="#1-2-代码实现" class="headerlink" title="1.2 代码实现"></a>1.2 代码实现</h3><blockquote><p>抽象聚集角色类，这个角色规定出所有的具体聚集必须实现的接口。迭代器模式要求聚集对象必须有一个工厂方法，也就是createIterator()方法，以向外界提供迭代器对象的实例。</p></blockquote><pre><code class="highlight java"><span class="comment">/**</span><span class="comment"> * 抽象聚集类</span><span class="comment"> */</span><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">class</span> <span class="title class_">Aggregate</span> &#123;    <span class="comment">/**</span><span class="comment">     * 工厂方法, 创建相应的迭代器对象接口</span><span class="comment">     * <span class="doctag">@return</span></span><span class="comment">     */</span>    <span class="keyword">public</span> <span class="keyword">abstract</span> Iterator <span class="title function_">createIterator</span><span class="params">()</span>;&#125;</code></pre><blockquote><p>具体聚集角色类，实现了抽象聚集角色类所要求的接口，也就是createIterator()方法。此外，还有方法getElement()向外界提供聚集元素，而方法size()向外界提供聚集的大小等。</p></blockquote><pre><code class="highlight java"><span class="comment">/**</span><span class="comment"> * 具体聚集类</span><span class="comment"> */</span><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ConcreteAggregate</span> <span class="keyword">extends</span> <span class="title class_">Aggregate</span> &#123;    <span class="keyword">private</span> Object[] objArray = <span class="literal">null</span>;    <span class="comment">/**</span><span class="comment">     * 构造方法传入聚集数据</span><span class="comment">     *</span><span class="comment">     * <span class="doctag">@param</span> objArray</span><span class="comment">     */</span>    <span class="keyword">public</span> <span class="title function_">ConcreteAggregate</span><span class="params">(Object[] objArray)</span> &#123;        <span class="built_in">this</span>.objArray = objArray;    &#125;    <span class="meta">@Override</span>    <span class="keyword">public</span> Iterator <span class="title function_">createIterator</span><span class="params">()</span> &#123;        <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">ConcreteIterator</span>(<span class="built_in">this</span>);    &#125;    <span class="comment">/**</span><span class="comment">     * 取值方法：向外界提供聚集元素</span><span class="comment">     */</span>    <span class="keyword">public</span> Object <span class="title function_">getElement</span><span class="params">(<span class="type">int</span> index)</span> &#123;        <span class="keyword">if</span> (index &lt; objArray.length) &#123;            <span class="keyword">return</span> objArray[index];        &#125; <span class="keyword">else</span> &#123;            <span class="keyword">return</span> <span class="literal">null</span>;        &#125;    &#125;    <span class="comment">/**</span><span class="comment">     * 取值方法：向外界提供聚集的大小</span><span class="comment">     */</span>    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">size</span><span class="params">()</span> &#123;        <span class="keyword">return</span> objArray.length;    &#125;&#125;</code></pre><blockquote><p>抽象迭代器角色类</p></blockquote><pre><code class="highlight java"><span class="comment">/**</span><span class="comment"> * 抽象迭代器角色类</span><span class="comment"> */</span><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">Iterator</span> &#123;    <span class="comment">/**</span><span class="comment">     * 迭代方法：移动到第一个元素</span><span class="comment">     */</span>    <span class="keyword">void</span> <span class="title function_">first</span><span class="params">()</span>;    <span class="comment">/**</span><span class="comment">     * 迭代方法：移动到下一个元素</span><span class="comment">     */</span>    <span class="keyword">void</span> <span class="title function_">next</span><span class="params">()</span>;    <span class="comment">/**</span><span class="comment">     * 迭代方法：是否为最后一个元素</span><span class="comment">     */</span>    <span class="type">boolean</span> <span class="title function_">isDone</span><span class="params">()</span>;    <span class="comment">/**</span><span class="comment">     * 迭代方法：返还当前元素</span><span class="comment">     */</span>    Object <span class="title function_">currentItem</span><span class="params">()</span>;&#125;</code></pre><blockquote><p>具体迭代器角色类</p></blockquote><pre><code class="highlight java"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ConcreteIterator</span> <span class="keyword">implements</span> <span class="title class_">Iterator</span> &#123;    <span class="comment">// 持有迭代的具体的聚合对象</span>    <span class="keyword">private</span> <span class="type">ConcreteAggregate</span> <span class="variable">aggregate</span> <span class="operator">=</span> <span class="literal">null</span>;    <span class="comment">// 内部索引，记录当前迭代到的索引位置</span>    <span class="keyword">private</span> <span class="type">int</span> <span class="variable">index</span> <span class="operator">=</span> <span class="number">0</span>;    <span class="comment">// 记录当前聚集对象的大小</span>    <span class="keyword">private</span> <span class="type">int</span> <span class="variable">size</span> <span class="operator">=</span> <span class="number">0</span>;    <span class="keyword">public</span> <span class="title function_">ConcreteIterator</span><span class="params">(ConcreteAggregate aggregate)</span> &#123;        <span class="built_in">this</span>.aggregate = aggregate;        <span class="built_in">this</span>.size = aggregate.size();        <span class="built_in">this</span>.index = <span class="number">0</span>;    &#125;    <span class="comment">/**</span><span class="comment">     * 迭代方法,移动到第一个元素</span><span class="comment">     */</span>    <span class="meta">@Override</span>    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">first</span><span class="params">()</span> &#123;        index = <span class="number">0</span>;    &#125;    <span class="comment">/**</span><span class="comment">     * 迭代方法,移动到下一个元素</span><span class="comment">     */</span>    <span class="meta">@Override</span>    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">next</span><span class="params">()</span> &#123;        <span class="keyword">if</span> (index &lt; size) &#123;            index++;        &#125;    &#125;    <span class="comment">/**</span><span class="comment">     * 迭代方法:是否为最后一个元素</span><span class="comment">     * <span class="doctag">@return</span></span><span class="comment">     */</span>    <span class="meta">@Override</span>    <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">isDone</span><span class="params">()</span> &#123;        <span class="keyword">return</span> index &gt;= size;    &#125;    <span class="comment">/**</span><span class="comment">     * 迭代方法：返还当前元素</span><span class="comment">     */</span>    <span class="meta">@Override</span>    <span class="keyword">public</span> Object <span class="title function_">currentItem</span><span class="params">()</span> &#123;        <span class="keyword">return</span> aggregate.getElement(index);    &#125;&#125;</code></pre><blockquote><p>客户端</p></blockquote><pre><code class="highlight java"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Client</span> &#123;    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;        String[] strings = <span class="keyword">new</span> <span class="title class_">String</span>[]&#123;<span class="string">&quot;Tom&quot;</span>, <span class="string">&quot;Jerry&quot;</span>, <span class="string">&quot;Jack&quot;</span>, <span class="string">&quot;Marray&quot;</span>, <span class="string">&quot;Green&quot;</span>&#125;;        <span class="comment">// 创建聚合角色</span>        <span class="type">Aggregate</span> <span class="variable">aggregate</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ConcreteAggregate</span>(strings);        <span class="comment">// 创建迭代器</span>        <span class="type">Iterator</span> <span class="variable">iterator</span> <span class="operator">=</span> aggregate.createIterator();        <span class="keyword">while</span> (!iterator.isDone()) &#123;            <span class="type">String</span> <span class="variable">name</span> <span class="operator">=</span> (String) iterator.currentItem();            System.out.println(name);            iterator.next();        &#125;    &#125;&#125;</code></pre><blockquote><p>运行结果</p><pre><code class="highlight shell">TomJerryJackMarrayGreen</code></pre></blockquote><p>这个例子首先创建了一个聚集类实例，然后调用聚集对象的工厂方法createIterator()以得到一个迭代器对象。在得到迭代器的实例后，客户端开始迭代过程，打印出所有的聚集元素。</p><h3 id="1-3-外禀迭代器的意义"><a href="#1-3-外禀迭代器的意义" class="headerlink" title="1.3 外禀迭代器的意义"></a>1.3 外禀迭代器的意义</h3><p>​        一个常常会问的问题是：既然白箱聚集已经向外界提供了遍历方法，客户端已经可以自行进行迭代了，为什么还要应用迭代器模式，并创建一个迭代器对象进行迭代呢？</p><p>　　客户端当然可以自行进行迭代，不一定非得需要一个迭代器对象。但是，迭代器对象和迭代模式会将迭代过程抽象化，将作为迭代消费者的客户端与迭代负责人的迭代器责任分隔开，使得两者可以独立的演化。在聚集对象的种类发生变化，或者迭代的方法发生改变时，迭代器作为一个中介层可以吸收变化的因素，而避免修改客户端或者聚集本身。</p><p>　　此外，如果系统需要同时针对几个不同的聚集对象进行迭代，而这些聚集对象所提供的遍历方法有所不同时，使用迭代器模式和一个外界的迭代器对象是有意义的。具有同一迭代接口的不同迭代器对象处理具有不同遍历接口的聚集对象，使得系统可以使用一个统一的迭代接口进行所有的迭代。</p><h2 id="2-黑箱聚集与内禀迭代器"><a href="#2-黑箱聚集与内禀迭代器" class="headerlink" title="2. 黑箱聚集与内禀迭代器"></a>2. 黑箱聚集与内禀迭代器</h2><h3 id="2-1-理论概述"><a href="#2-1-理论概述" class="headerlink" title="2.1 理论概述"></a>2.1 理论概述</h3><p>如果一个聚集的接口没有提供修改聚集元素的方法，这样的接口就是所谓的<strong>窄接口</strong>。</p><p>聚集对象为迭代器对象提供一个宽接口，而为其他对象提供一个窄接口。换言之，聚集对象的内部结构应当对迭代器对象适当公开，以便迭代器对象能够对聚集对象有足够的了解，从而可以进行迭代操作。但是，聚集对象应当避免向其他的对象提供这些方法，因为其他对象应当经过迭代器对象进行这些工作，而不是直接操控聚集对象。</p><p><img src="https://raw.githubusercontent.com/GeorgeChan95/blogimg/master/img/2024/11/24/20241124-143320.png" alt="内禀迭代器"></p><p>在JAVA语言中，实现双重接口的办法就是将迭代器类设计成聚集类的内部成员类。这样迭代器对象将可以像聚集对象的内部成员一样访问聚集对象的内部结构。下面给出一个示意性的实现，说明这种双重接口的结构时怎么样产生的，以及使用了双重接口结构之后迭代器模式的实现方案。这种同时保证聚集对象的封装和迭代器功能的实现的方案叫做<strong>黑箱实现方案</strong>。</p><p>由于迭代器是聚集的内部类，迭代器可以自由访问聚集的元素，所以迭代器可以自行实现迭代功能并控制对聚集元素的迭代逻辑。由于迭代器是在聚集的结构之内定义的，因此这样的迭代器又叫做<strong>内禀迭代器（Intrinsic Iterator）。</strong></p><p>为了说明黑箱方案的细节，这里给出一个示意性的黑箱实现。在这个实现里，聚集类ConcreteAggregate含有一个内部成员类ConcreteIterator，也就是实现了抽象迭代器接口的具体迭代器类，同时聚集并不向外界提供访问自己内部元素的方法。</p><p><img src="https://raw.githubusercontent.com/GeorgeChan95/blogimg/master/img/2024/11/24/20241124-143636.png" alt="内禀迭代器实现示例"></p><h3 id="2-2-代码实现"><a href="#2-2-代码实现" class="headerlink" title="2.2 代码实现"></a>2.2 代码实现</h3><pre><code class="highlight java"><span class="comment">/**</span><span class="comment"> * 抽象聚集类</span><span class="comment"> 这个角色规定出所有的具体聚集必须实现的接口。迭代器模式要求聚集对象必须有一个工厂方法，也就是createIterator()方法，以向外界提供迭代器对象的实例。</span><span class="comment"> */</span><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">class</span> <span class="title class_">Aggregate</span> &#123;    <span class="comment">/**</span><span class="comment">     * 工厂方法, 创建相应的迭代器对象接口</span><span class="comment">     *</span><span class="comment">     * <span class="doctag">@return</span></span><span class="comment">     */</span>    <span class="keyword">public</span> <span class="keyword">abstract</span> Iterator <span class="title function_">createIterator</span><span class="params">()</span>;&#125;<span class="comment">/**</span><span class="comment"> * 抽象迭代器角色类</span><span class="comment"> */</span><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">Iterator</span> &#123;    <span class="comment">/**</span><span class="comment">     * 迭代方法：移动到第一个元素</span><span class="comment">     */</span>    <span class="keyword">void</span> <span class="title function_">first</span><span class="params">()</span>;    <span class="comment">/**</span><span class="comment">     * 迭代方法：移动到下一个元素</span><span class="comment">     */</span>    <span class="keyword">void</span> <span class="title function_">next</span><span class="params">()</span>;    <span class="comment">/**</span><span class="comment">     * 迭代方法：是否为最后一个元素</span><span class="comment">     */</span>    <span class="type">boolean</span> <span class="title function_">isDone</span><span class="params">()</span>;    <span class="comment">/**</span><span class="comment">     * 迭代方法：返还当前元素</span><span class="comment">     */</span>    Object <span class="title function_">currentItem</span><span class="params">()</span>;&#125;<span class="comment">/**</span><span class="comment"> * 具体聚集类</span><span class="comment"> */</span><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ConcreteAggregate</span> <span class="keyword">extends</span> <span class="title class_">Aggregate</span> &#123;    <span class="keyword">private</span> Object[] objArray = <span class="literal">null</span>;    <span class="comment">/**</span><span class="comment">     * 构造方法传入聚集数据</span><span class="comment">     *</span><span class="comment">     * <span class="doctag">@param</span> objArray</span><span class="comment">     */</span>    <span class="keyword">public</span> <span class="title function_">ConcreteAggregate</span><span class="params">(Object[] objArray)</span> &#123;        <span class="built_in">this</span>.objArray = objArray;    &#125;    <span class="meta">@Override</span>    <span class="keyword">public</span> Iterator <span class="title function_">createIterator</span><span class="params">()</span> &#123;        <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">ConcreteIterator</span>();    &#125;    <span class="keyword">private</span> <span class="keyword">class</span> <span class="title class_">ConcreteIterator</span> <span class="keyword">implements</span> <span class="title class_">Iterator</span> &#123;        <span class="comment">// 内部索引，记录当前迭代到的索引位置</span>        <span class="keyword">private</span> <span class="type">int</span> <span class="variable">index</span> <span class="operator">=</span> <span class="number">0</span>;        <span class="comment">// 记录当前聚集对象的大小</span>        <span class="keyword">private</span> <span class="type">int</span> <span class="variable">size</span> <span class="operator">=</span> <span class="number">0</span>;        <span class="keyword">public</span> <span class="title function_">ConcreteIterator</span><span class="params">()</span> &#123;            <span class="built_in">this</span>.size = objArray.length;            <span class="built_in">this</span>.index = <span class="number">0</span>;        &#125;        <span class="comment">/**</span><span class="comment">         * 迭代方法,移动到第一个元素</span><span class="comment">         */</span>        <span class="meta">@Override</span>        <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">first</span><span class="params">()</span> &#123;            index = <span class="number">0</span>;        &#125;        <span class="comment">/**</span><span class="comment">         * 迭代方法,移动到下一个元素</span><span class="comment">         */</span>        <span class="meta">@Override</span>        <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">next</span><span class="params">()</span> &#123;            <span class="keyword">if</span> (index &lt; size) &#123;                index++;            &#125;        &#125;        <span class="comment">/**</span><span class="comment">         * 迭代方法:是否为最后一个元素</span><span class="comment">         * <span class="doctag">@return</span></span><span class="comment">         */</span>        <span class="meta">@Override</span>        <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">isDone</span><span class="params">()</span> &#123;            <span class="keyword">return</span> index &gt;= size;        &#125;        <span class="comment">/**</span><span class="comment">         * 迭代方法：返还当前元素</span><span class="comment">         */</span>        <span class="meta">@Override</span>        <span class="keyword">public</span> Object <span class="title function_">currentItem</span><span class="params">()</span> &#123;            <span class="keyword">return</span> objArray[index];        &#125;    &#125;&#125;<span class="comment">// 测试类</span><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Client</span> &#123;    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;        String[] strings = <span class="keyword">new</span> <span class="title class_">String</span>[]&#123;<span class="string">&quot;Tom&quot;</span>, <span class="string">&quot;Jerry&quot;</span>, <span class="string">&quot;Jack&quot;</span>, <span class="string">&quot;Marray&quot;</span>, <span class="string">&quot;Green&quot;</span>&#125;;        <span class="comment">// 创建集合对象,传入数据</span>        <span class="type">Aggregate</span> <span class="variable">aggregate</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ConcreteAggregate</span>(strings);        <span class="comment">// 创建迭代器</span>        <span class="type">Iterator</span> <span class="variable">iterator</span> <span class="operator">=</span> aggregate.createIterator();        <span class="comment">// 循环打印元素</span>        <span class="keyword">while</span> (!iterator.isDone()) &#123;            System.out.println(iterator.currentItem());            iterator.next();        &#125;    &#125;&#125;</code></pre><blockquote><p>运行结果:</p><pre><code class="highlight shell">TomJerryJackMarrayGreen</code></pre></blockquote><p>上面的例子首先创建了一个聚集类实例，然后调用聚集对象的工厂方法createIterator()以得到一个迭代器对象。在得到迭代器的实例后，客户端开始迭代过程，打印出所有的聚集元素。</p><h1 id="三、主动迭代器和被动迭代器"><a href="#三、主动迭代器和被动迭代器" class="headerlink" title="三、主动迭代器和被动迭代器"></a>三、主动迭代器和被动迭代器</h1><ul><li>主动迭代器和被动迭代器又称作外部迭代器和内部迭代器。</li><li>所谓主动（外部）迭代器，指的是由客户端来控制迭代下一个元素的步骤，客户端会明显调用迭代器的next()等迭代方法，在遍历过程中向前进行。</li><li>所谓被动（内部）迭代器，指的是由迭代器自己来控制迭代下一个元素的步骤。因此，如果想要在迭代的过程中完成工作的话，客户端就需要把操作传递给迭代器，迭代器在迭代的时候会在每个元素上执行这个操作，类似于JAVA的回调机制。</li><li>总体来说外部迭代器比内部迭代器要灵活一些，因此我们常见的实现多属于主动迭代器。</li></ul><h1 id="四、静态迭代器和动态迭代器"><a href="#四、静态迭代器和动态迭代器" class="headerlink" title="四、静态迭代器和动态迭代器"></a>四、静态迭代器和动态迭代器</h1><ul><li><p>静态迭代器由聚集对象创建，并持有聚集对象的一份快照(snapshot)，在产生后这个快照的内容就不再变化。客户端可以继续修改原聚集的内容，但是迭代器对象不会反映出聚集的新变化。</p><p>静态迭代器的好处是它的安全性和简易性，换言之，静态迭代器易于实现，不容易出现错误。但是由于静态迭代器将原聚集复制了一份，因此它的短处是对时间和内存资源的消耗。</p></li><li><p>动态迭代器则与静态迭代器完全相反，在迭代器被产生之后，迭代器保持着对聚集元素的引用，因此，任何对原聚集内容的修改都会在迭代器对象上反映出来。</p><p>完整的动态迭代器不容易实现，但是简化的动态迭代器并不难实现。大多数JAVA设计师遇到的迭代器都是这种简化的动态迭代器。为了说明什么是简化的动态迭代器，首先需要介绍一个新的概念：<strong>Fail Fast</strong>。</p></li></ul><h1 id="五、Fail-Fast"><a href="#五、Fail-Fast" class="headerlink" title="五、Fail Fast"></a>五、Fail Fast</h1><p>如果一个算法开始之后，它的运算环境发生变化，使得算法无法进行必需的调整时，这个算法就应当立即发出故障信号。这就是Fail Fast的含义。</p><p>如果聚集对象的元素在一个动态迭代器的迭代过程中发生变化时，迭代过程会受到影响而变得不能自恰。这时候，迭代器就应当立即抛出一个异常。这种迭代器就是实现了Fail Fast功能的迭代器。</p><h2 id="1-Fail-Fast在JAVA聚集中的使用"><a href="#1-Fail-Fast在JAVA聚集中的使用" class="headerlink" title="1. Fail Fast在JAVA聚集中的使用"></a>1. Fail Fast在JAVA聚集中的使用</h2><p>JAVA语言以接口 <code>java.util.Iterator</code> 的方式支持迭代器模式，Collection接口要求提供<code>iterator()</code>方法，此方法在调用时返还一个Iterator类型的对象。而作为 Collection 接口的子类型，AbstractList 类的内部成员类Itr便是实现 Iterator 接口的类。</p><blockquote><p>Itr类的源代码如下所示</p></blockquote><pre><code class="highlight java"><span class="keyword">private</span> <span class="keyword">class</span> <span class="title class_">Itr</span> <span class="keyword">implements</span> <span class="title class_">Iterator</span>&lt;E&gt; &#123;        <span class="comment">/**</span><span class="comment">         * Index of element to be returned by subsequent call to next.</span><span class="comment">         */</span>        <span class="type">int</span> <span class="variable">cursor</span> <span class="operator">=</span> <span class="number">0</span>;        <span class="comment">/**</span><span class="comment">         * Index of element returned by most recent call to next or</span><span class="comment">         * previous.  Reset to -1 if this element is deleted by a call</span><span class="comment">         * to remove.</span><span class="comment">         */</span>        <span class="type">int</span> <span class="variable">lastRet</span> <span class="operator">=</span> -<span class="number">1</span>;        <span class="comment">/**</span><span class="comment">         * The modCount value that the iterator believes that the backing</span><span class="comment">         * List should have.  If this expectation is violated, the iterator</span><span class="comment">         * has detected concurrent modification.</span><span class="comment">         */</span>        <span class="type">int</span> <span class="variable">expectedModCount</span> <span class="operator">=</span> modCount;        <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">hasNext</span><span class="params">()</span> &#123;                <span class="keyword">return</span> cursor != size();        &#125;        <span class="keyword">public</span> E <span class="title function_">next</span><span class="params">()</span> &#123;                checkForComodification();            <span class="keyword">try</span> &#123;            <span class="type">E</span> <span class="variable">next</span> <span class="operator">=</span> get(cursor);            lastRet = cursor++;            <span class="keyword">return</span> next;            &#125; <span class="keyword">catch</span> (IndexOutOfBoundsException e) &#123;            checkForComodification();            <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">NoSuchElementException</span>();            &#125;        &#125;        <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">remove</span><span class="params">()</span> &#123;            <span class="keyword">if</span> (lastRet == -<span class="number">1</span>)            <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">IllegalStateException</span>();                checkForComodification();            <span class="keyword">try</span> &#123;            AbstractList.<span class="built_in">this</span>.remove(lastRet);            <span class="keyword">if</span> (lastRet &lt; cursor)                cursor--;            lastRet = -<span class="number">1</span>;            expectedModCount = modCount;            &#125; <span class="keyword">catch</span> (IndexOutOfBoundsException e) &#123;            <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">ConcurrentModificationException</span>();            &#125;        &#125;        <span class="keyword">final</span> <span class="keyword">void</span> <span class="title function_">checkForComodification</span><span class="params">()</span> &#123;            <span class="keyword">if</span> (modCount != expectedModCount)            <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">ConcurrentModificationException</span>();        &#125;&#125;</code></pre><p>从Itr类的源代码中可以看到，方法 <code>checkForComodification()</code> 会检查聚集的内容是否刚刚被外界直接修改过(不是通过迭代器提供的方法修改的)。如果在迭代开始后，聚集的内容被外界绕过迭代器对象而直接修改的话，这个方法会立即抛出<code>ConcurrentModificationException()</code> 异常。</p><p>这就是说，<code>AbstractList.Itr</code> 迭代器是一个Fail Fast的迭代器。</p><h1 id="六、迭代器模式的优点"><a href="#六、迭代器模式的优点" class="headerlink" title="六、迭代器模式的优点"></a>六、迭代器模式的优点</h1><ul><li><p>迭代器模式简化了聚集的接口。迭代器具备了一个遍历接口，这样聚集的接口就不必具备遍历接口。</p></li><li><p>每一个聚集对象都可以有一个或多个迭代器对象，每一个迭代器的迭代状态可以是彼此独立的。因此，一个聚集对象可以同时有几个迭代在进行之中。</p></li><li><p>由于遍历算法被封装在迭代器角色里面，因此迭代的算法可以独立于聚集角色变化。</p></li></ul><p>  　　</p><p><strong>参考链接：</strong><a href="https://www.cnblogs.com/java-my-life/archive/2012/05/22/2511506.html">https://www.cnblogs.com/java-my-life/archive/2012/05/22/2511506.html</a></p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;&lt;strong&gt;迭代器模式又叫游标(Cursor)模式，是对象的行为模式。迭代器模式可以顺序地访问一个聚集中的元素而不必暴露聚集的内部表象（&lt;em&gt;internal representation&lt;/em&gt;）。&lt;/strong&gt;&lt;/p&gt;
&lt;h1 id=&quot;一、聚集和Java聚集</summary>
      
    
    
    
    <category term="设计模式" scheme="https://georgechan95.github.io/categories/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"/>
    
    
    <category term="设计模式" scheme="https://georgechan95.github.io/tags/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"/>
    
  </entry>
  
  <entry>
    <title>17-访问者模式</title>
    <link href="https://georgechan95.github.io/blog/4fdf6e52.html"/>
    <id>https://georgechan95.github.io/blog/4fdf6e52.html</id>
    <published>2024-11-23T13:55:00.000Z</published>
    <updated>2024-11-23T09:42:23.551Z</updated>
    
    <content type="html"><![CDATA[<p><strong>访问者模式是对象的行为模式。访问者模式的目的是封装一些施加于某种数据结构元素之上的操作。一旦这些操作需要修改的话，接受这个操作的数据结构则可以保持不变。</strong></p><h1 id="一、分派的概念"><a href="#一、分派的概念" class="headerlink" title="一、分派的概念"></a>一、分派的概念</h1><p>变量被声明时的类型叫做变量的静态类型(Static Type)，有些人又把静态类型叫做明显类型(Apparent Type)；而变量所引用的对象的真实类型又叫做变量的实际类型(Actual Type)。比如：</p><pre><code class="highlight java"><span class="type">List</span> <span class="variable">list</span> <span class="operator">=</span> <span class="literal">null</span>;list = <span class="keyword">new</span> <span class="title class_">ArrayList</span>();</code></pre><p>声明了一个变量list，它的静态类型（也叫明显类型）是List，而它的实际类型是ArrayList。</p><p>根据对象的类型而对方法进行的选择，就是分派(Dispatch)，分派(Dispatch)又分为两种，即<strong>静态分派</strong>和<strong>动态分派</strong>。</p><p>**静态分派(Static Dispatch)**发生在编译时期，分派根据静态类型信息发生。静态分派对于我们来说并不陌生，方法重载就是静态分派。</p><p>**动态分派(Dynamic Dispatch)**发生在运行时期，动态分派动态地置换掉某个方法。</p><h2 id="1-静态分派"><a href="#1-静态分派" class="headerlink" title="1. 静态分派"></a>1. 静态分派</h2><p>Java通过方法重载支持静态分派。用墨子骑马的故事作为例子，墨子可以骑白马或者黑马。墨子与白马、黑马和马的类图如下所示：</p><p><img src="https://raw.githubusercontent.com/GeorgeChan95/blogimg/master/img/2024/11/23/20241123-155058.png" alt="分派"></p><p>在这个系统中，墨子由Mozi类代表</p><pre><code class="highlight java"><span class="comment">/**</span><span class="comment"> * 静态分派：方法重载是根据静态类型进行的</span><span class="comment"> */</span><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Mozi</span> &#123;    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">ride</span><span class="params">(Horse h)</span>&#123;        System.out.println(<span class="string">&quot;骑马&quot;</span>);    &#125;    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">ride</span><span class="params">(WhiteHorse wh)</span>&#123;        System.out.println(<span class="string">&quot;骑白马&quot;</span>);    &#125;    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">ride</span><span class="params">(BlackHorse bh)</span>&#123;        System.out.println(<span class="string">&quot;骑黑马&quot;</span>);    &#125;    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;        <span class="type">Horse</span> <span class="variable">wh</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">WhiteHorse</span>();        <span class="type">Horse</span> <span class="variable">bh</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">BlackHorse</span>();        <span class="type">Mozi</span> <span class="variable">mozi</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Mozi</span>();        mozi.ride(wh);        mozi.ride(bh);    &#125;&#125;</code></pre><blockquote><p>运行结果：</p><pre><code class="highlight shell">骑马骑马</code></pre></blockquote><p>显然，Mozi类的ride()方法是由三个方法重载而成的。这三个方法分别接受马(Horse)、白马(WhiteHorse)、黑马(BlackHorse)等类型的参数。</p><p>那么在运行时，程序会打印出什么结果呢？结果是程序会打印出相同的两行“骑马”。换言之，墨子发现他所骑的都是马。</p><p>为什么呢？两次对ride()方法的调用传入的是不同的参数，也就是wh和bh。它们虽然具有不同的真实类型，但是它们的静态类型都是一样的，均是Horse类型。</p><p><strong>重载方法</strong>的分派是根据<strong>静态类型</strong>进行的，这个分派过程在编译时期就完成了。</p><h2 id="2-动态分派"><a href="#2-动态分派" class="headerlink" title="2. 动态分派"></a>2. 动态分派</h2><p>Java通过<strong>方法的重写</strong>支持动态分派。用马吃草的故事作为例子，代码如下所示：</p><pre><code class="highlight java"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Horse</span> &#123;    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">eat</span><span class="params">()</span>&#123;        System.out.println(<span class="string">&quot;马吃草&quot;</span>);    &#125;&#125;<span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">BlackHorse</span> <span class="keyword">extends</span> <span class="title class_">Horse</span> &#123;    <span class="meta">@Override</span>    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">eat</span><span class="params">()</span> &#123;        System.out.println(<span class="string">&quot;黑马吃草&quot;</span>);    &#125;&#125;<span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">WhiteHorse</span> <span class="keyword">extends</span> <span class="title class_">Horse</span> &#123;        <span class="meta">@Override</span>    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">eat</span><span class="params">()</span> &#123;        System.out.println(<span class="string">&quot;白马吃草&quot;</span>);    &#125;&#125;<span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Client</span> &#123;    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;        <span class="type">Horse</span> <span class="variable">h</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">BlackHorse</span>();        h.eat();    &#125;&#125;</code></pre><blockquote><p>运行结果：</p><pre><code class="highlight shell">黑马吃草</code></pre></blockquote><p>变量h的静态类型是Horse，而真实类型是BlackHorse。如果上面最后一行的eat()方法调用的是BlackHorse类的eat()方法，那么上面打印的就是“黑马吃草”；相反，如果上面的eat()方法调用的是Horse类的eat()方法，那么打印的就是“马吃草”。</p><p>所以，问题的核心就是Java编译器在编译时期并不总是知道哪些代码会被执行，因为编译器仅仅知道对象的静态类型，而不知道对象的真实类型；而方法的调用则是根据对象的真实类型，而不是静态类型。这样一来，上面最后一行的eat()方法调用的是BlackHorse类的eat()方法，打印的是“黑马吃草”。</p><h2 id="3-分派的类型"><a href="#3-分派的类型" class="headerlink" title="3. 分派的类型"></a>3. 分派的类型</h2><p>一个方法所属的对象叫做方法的接收者，方法的接收者与方法的参数统称做方法的宗量。比如下面例子中的Test类:</p><pre><code class="highlight java"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Test</span> &#123;    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">print</span><span class="params">(String str)</span>&#123;        System.out.println(str);    &#125;&#125;</code></pre><p>在上面的类中，print()方法属于Test对象，所以它的接收者也就是Test对象了。print()方法有一个参数是str,它的类型是String。</p><p>根据分派可以基于多少种宗量，可以将面向对象的语言划分为单分派语言(Uni-Dispatch)和多分派语言(Multi-Dispatch)。单分派语言根据一个宗量的类型进行对方法的选择，多分派语言根据多于一个的宗量的类型对方法进行选择。</p><p>C++和Java均是单分派语言，多分派语言的例子包括CLOS和Cecil。按照这样的区分，Java就是<strong>动态的单分派语言</strong>，因为这种语言的动态分派仅仅会考虑到方法的接收者的类型，同时又是<strong>静态的多分派语言</strong>，因为这种语言对重载方法的分派会考虑到方法的接收者的类型以及方法的所有参数的类型。</p><p>在一个支持动态单分派的语言里面，有两个条件决定了一个请求会调用哪一个操作：一是请求的名字，二是接收者的真实类型。单分派限制了方法的选择过程，使得只有一个宗量可以被考虑到，这个宗量通常就是方法的接收者。在Java语言里面，如果一个操作是作用于某个类型不明的对象上面，那么对这个对象的真实类型测试仅会发生一次，这就是动态的单分派的特征。</p><h2 id="4-双重分派"><a href="#4-双重分派" class="headerlink" title="4. 双重分派"></a>4. 双重分派</h2><p>一个方法根据两个宗量的类型来决定执行不同的代码，这就是“双重分派”。Java语言不支持动态的多分派，也就意味着Java不支持动态的双分派。但是通过使用设计模式，也可以在Java语言里实现动态的双重分派。</p><p>在Java中可以通过两次方法调用来达到两次分派的目的。类图如下所示：</p><p><img src="https://raw.githubusercontent.com/GeorgeChan95/blogimg/master/img/2024/11/23/20241123-161136.png" alt="双重分派"></p><p>在图中有两个对象，左边的叫做West，右边的叫做East。现在West对象首先调用East对象的 <code>goEast()</code> 方法，并将它自己传入。在East对象被调用时，立即根据传入的参数知道了调用者是谁，于是反过来调用“调用者”对象的 <code>goWest()</code> 方法。通过两次调用将程序控制权轮番交给两个对象，其时序图如下所示：</p><p><img src="https://raw.githubusercontent.com/GeorgeChan95/blogimg/master/img/2024/11/23/20241123-161216.png" alt="双重分派-时序图"></p><p>这样就出现了两次方法调用，程序控制权被两个对象像传球一样，首先由West对象传给了East对象，然后又被返传给了West对象。</p><p>但是仅仅返传了一下球，并不能解决双重分派的问题。关键是怎样利用这两次调用，以及Java语言的动态单分派功能，使得在这种传球的过程中，能够触发两次单分派。</p><p>动态单分派在Java语言中是在子类重写父类的方法时发生的。换言之，West和East都必须分别置身于自己的类型等级结构中，如下图所示：</p><p><img src="https://raw.githubusercontent.com/GeorgeChan95/blogimg/master/img/2024/11/23/20241123-161503.png" alt="双重分派实现"></p><p><strong>代码实现：</strong></p><pre><code class="highlight java"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">class</span> <span class="title class_">West</span> &#123;    <span class="comment">// 传入East子类作为参数</span>    <span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">void</span> <span class="title function_">goWest1</span><span class="params">(SubEast1 east)</span>;    <span class="comment">// 传入East子类作为参数</span>    <span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">void</span> <span class="title function_">goWest2</span><span class="params">(SubEast2 east)</span>;&#125; <span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">SubWest1</span> <span class="keyword">extends</span> <span class="title class_">West</span> &#123;    <span class="meta">@Override</span>    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">goWest1</span><span class="params">(SubEast1 east)</span> &#123;        System.out.println(<span class="string">&quot;SubWest1 + &quot;</span> + east.myName1());    &#125;    <span class="meta">@Override</span>    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">goWest2</span><span class="params">(SubEast2 east)</span> &#123;        System.out.println(<span class="string">&quot;SubWest1 + &quot;</span> + east.myName2());    &#125;&#125;<span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">SubWest2</span> <span class="keyword">extends</span> <span class="title class_">West</span> &#123;    <span class="meta">@Override</span>    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">goWest1</span><span class="params">(SubEast1 east)</span> &#123;        System.out.println(<span class="string">&quot;SubWest2 + &quot;</span> + east.myName1());    &#125;    <span class="meta">@Override</span>    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">goWest2</span><span class="params">(SubEast2 east)</span> &#123;        System.out.println(<span class="string">&quot;SubWest2 + &quot;</span> + east.myName2());    &#125;&#125;<span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">class</span> <span class="title class_">East</span> &#123;    <span class="comment">// 传入West接口作为参数</span>    <span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">void</span> <span class="title function_">goEast</span><span class="params">(West west)</span>;&#125;<span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">SubEast1</span> <span class="keyword">extends</span> <span class="title class_">East</span> &#123;    <span class="meta">@Override</span>    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">goEast</span><span class="params">(West west)</span> &#123;        west.goWest1(<span class="built_in">this</span>);    &#125;    <span class="keyword">public</span> String <span class="title function_">myName1</span><span class="params">()</span>&#123;        <span class="keyword">return</span> <span class="string">&quot;SubEast1&quot;</span>;    &#125;&#125;<span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">SubEast2</span> <span class="keyword">extends</span> <span class="title class_">East</span> &#123;    <span class="meta">@Override</span>    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">goEast</span><span class="params">(West west)</span> &#123;        west.goWest2(<span class="built_in">this</span>);    &#125;    <span class="keyword">public</span> String <span class="title function_">myName2</span><span class="params">()</span>&#123;        <span class="keyword">return</span> <span class="string">&quot;SubEast2&quot;</span>;    &#125;&#125;<span class="comment">// 测试类</span><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Client</span> &#123;    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;        <span class="comment">// 组合1</span>        <span class="type">East</span> <span class="variable">east</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">SubEast1</span>();        <span class="type">West</span> <span class="variable">west</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">SubWest1</span>();        east.goEast(west);        <span class="comment">// 组合2</span>        east = <span class="keyword">new</span> <span class="title class_">SubEast2</span>();        west = <span class="keyword">new</span> <span class="title class_">SubWest2</span>();        east.goEast(west);    &#125;&#125;</code></pre><blockquote><p>运行结果：</p><pre><code class="highlight shell">SubWest1 + SubEast1SubWest2 + SubEast2</code></pre></blockquote><p>系统运行时，会首先创建SubWest1和SubEast1对象，然后客户端调用SubEast1的goEast()方法，并将SubWest1对象传入。由于SubEast1对象重写了其超类East的goEast()方法，因此，这个时候就发生了一次动态的单分派。当SubEast1对象接到调用时，会从参数中得到SubWest1对象，所以它就立即调用这个对象的goWest1()方法，并将自己传入。由于SubEast1对象有权选择调用哪一个对象，因此，在此时又进行一次动态的方法分派。</p><p>这个时候SubWest1对象就得到了SubEast1对象。通过调用这个对象myName1()方法，就可以打印出自己的名字和SubEast对象的名字，其时序图如下所示：</p><p><img src="https://raw.githubusercontent.com/GeorgeChan95/blogimg/master/img/2024/11/23/20241123-165652.png" alt="动态双重分派时序图"></p><p>由于这两个名字一个来自East等级结构，另一个来自West等级结构中，因此，它们的组合式是动态决定的。这就是动态双重分派的实现机制。</p><h1 id="二、访问者模式的结构"><a href="#二、访问者模式的结构" class="headerlink" title="二、访问者模式的结构"></a>二、访问者模式的结构</h1><p>访问者模式适用于数据结构相对未定的系统，它把数据结构和作用于结构上的操作之间的耦合解脱开，使得操作集合可以相对自由地演化。访问者模式的简略图如下所示：</p><p><img src="https://raw.githubusercontent.com/GeorgeChan95/blogimg/master/img/2024/11/23/20241123-165944.png" alt="访问者模式结构示意"></p><h2 id="1-案例解析"><a href="#1-案例解析" class="headerlink" title="1. 案例解析"></a>1. 案例解析</h2><p>数据结构的每一个节点都可以接受一个访问者的调用，此节点向访问者对象传入节点对象，而访问者对象则反过来执行节点对象的操作。这样的过程叫做“双重分派”。节点调用访问者，将它自己传入，访问者则将某算法针对此节点执行。访问者模式的示意性类图如下所示：</p><p><img src="https://raw.githubusercontent.com/GeorgeChan95/blogimg/master/img/2024/11/23/20241123-170342.png" alt="访问者模式"></p><p>访问者模式涉及到的角色如下：</p><ul><li><strong>抽象访问者(Visitor)角色：</strong>声明了一个或者多个方法操作，形成所有的具体访问者角色必须实现的接口。</li><li><strong>具体访问者(ConcreteVisitor)角色：</strong>实现抽象访问者所声明的接口，也就是抽象访问者所声明的各个访问操作。</li><li><strong>抽象节点(Node)角色：</strong>声明一个接受操作，接受一个访问者对象作为一个参数。</li><li><strong>具体节点(ConcreteNode)角色：</strong>实现了抽象节点所规定的接受操作。</li><li><strong>结构对象(ObjectStructure)角色：</strong>有如下的责任，可以遍历结构中的所有元素；如果需要，提供一个高层次的接口让访问者对象可以访问每一个元素；如果需要，可以设计成一个复合对象或者一个聚集，如List或Set。</li></ul><p><strong>代码实现如下：</strong></p><p>可以看到，抽象访问者角色为每一个具体节点都准备了一个访问操作。由于有两个节点，因此，对应就有两个访问操作。</p><pre><code class="highlight java"><span class="comment">/**</span><span class="comment"> * 抽象访问者对象</span><span class="comment"> */</span><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">Visitor</span> &#123;    <span class="comment">/**</span><span class="comment">     * 对于具体节点NodeA的访问操作</span><span class="comment">     * <span class="doctag">@param</span> nodeA</span><span class="comment">     */</span>    <span class="keyword">void</span> <span class="title function_">visit</span><span class="params">(NodeA nodeA)</span>;    <span class="comment">/**</span><span class="comment">     * 对于具体节点NodeB的访问操作</span><span class="comment">     * <span class="doctag">@param</span> nodeB</span><span class="comment">     */</span>    <span class="keyword">void</span> <span class="title function_">visit</span><span class="params">(NodeB nodeB)</span>;&#125;<span class="comment">/**</span><span class="comment"> * 具体的访问者A类</span><span class="comment"> */</span><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">VisitorA</span> <span class="keyword">implements</span> <span class="title class_">Visitor</span> &#123;    <span class="meta">@Override</span>    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">visit</span><span class="params">(NodeA nodeA)</span> &#123;        System.out.println(nodeA.operationA());    &#125;    <span class="meta">@Override</span>    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">visit</span><span class="params">(NodeB nodeB)</span> &#123;        System.out.println(nodeB.operationB());    &#125;&#125;<span class="comment">/**</span><span class="comment"> * 具体的访问者B类</span><span class="comment"> */</span><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">VisitorB</span> <span class="keyword">implements</span> <span class="title class_">Visitor</span> &#123;    <span class="meta">@Override</span>    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">visit</span><span class="params">(NodeA nodeA)</span> &#123;        System.out.println(nodeA.operationA());    &#125;    <span class="meta">@Override</span>    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">visit</span><span class="params">(NodeB nodeB)</span> &#123;        System.out.println(nodeB.operationB());    &#125;&#125;<span class="comment">/**</span><span class="comment"> * 抽象节点类</span><span class="comment"> */</span><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">class</span> <span class="title class_">Node</span> &#123;    <span class="comment">/**</span><span class="comment">     * 接受操作</span><span class="comment">     */</span>    <span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">void</span> <span class="title function_">accept</span><span class="params">(Visitor visitor)</span>;&#125;<span class="comment">/**</span><span class="comment"> * 具体节点类A</span><span class="comment"> */</span><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">NodeA</span> <span class="keyword">extends</span> <span class="title class_">Node</span> &#123;    <span class="comment">/**</span><span class="comment">     * 接受操作</span><span class="comment">     * <span class="doctag">@param</span> visitor</span><span class="comment">     */</span>    <span class="meta">@Override</span>    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">accept</span><span class="params">(Visitor visitor)</span> &#123;        visitor.visit(<span class="built_in">this</span>);    &#125;    <span class="comment">/**</span><span class="comment">     * NodeA特有的方法</span><span class="comment">     */</span>    <span class="keyword">public</span> String <span class="title function_">operationA</span><span class="params">()</span>&#123;        <span class="keyword">return</span> <span class="string">&quot;NodeA&quot;</span>;    &#125;&#125;<span class="comment">/**</span><span class="comment"> * 具体节点类A</span><span class="comment"> */</span><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">NodeB</span> <span class="keyword">extends</span> <span class="title class_">Node</span> &#123;    <span class="comment">/**</span><span class="comment">     * 接受操作</span><span class="comment">     * <span class="doctag">@param</span> visitor</span><span class="comment">     */</span>    <span class="meta">@Override</span>    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">accept</span><span class="params">(Visitor visitor)</span> &#123;        visitor.visit(<span class="built_in">this</span>);    &#125;    <span class="comment">/**</span><span class="comment">     * NodeB特有的方法</span><span class="comment">     */</span>    <span class="keyword">public</span> String <span class="title function_">operationB</span><span class="params">()</span>&#123;        <span class="keyword">return</span> <span class="string">&quot;NodeB&quot;</span>;    &#125;&#125;<span class="comment">/**</span><span class="comment"> * 结构对象角色类，</span><span class="comment"> * 这个结构对象角色持有一个聚集，并向外界提供add()方法作为对聚集的管理操作。通过调用这个方法，可以动态地增加一个新的节点。</span><span class="comment"> */</span><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ObjectStructure</span> &#123;    <span class="keyword">private</span> List&lt;Node&gt; nodes = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();    <span class="comment">/**</span><span class="comment">     * 执行方法操作</span><span class="comment">     */</span>    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">action</span><span class="params">(Visitor visitor)</span> &#123;        <span class="keyword">for</span> (Node node : nodes) &#123;            node.accept(visitor);        &#125;    &#125;    <span class="comment">/**</span><span class="comment">     * 添加一个新元素</span><span class="comment">     */</span>    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">add</span><span class="params">(Node node)</span> &#123;        nodes.add(node);    &#125;&#125;<span class="comment">/**</span><span class="comment"> * 客户端类</span><span class="comment"> */</span><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Client</span> &#123;    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;        <span class="comment">// 创建一个结构对象</span>        <span class="type">ObjectStructure</span> <span class="variable">os</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ObjectStructure</span>();        <span class="comment">//给结构增加一个节点</span>        os.add(<span class="keyword">new</span> <span class="title class_">NodeA</span>());        <span class="comment">//给结构增加一个节点</span>        os.add(<span class="keyword">new</span> <span class="title class_">NodeB</span>());        <span class="type">Visitor</span> <span class="variable">visitor</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">VisitorA</span>();        os.action(visitor);    &#125;&#125;</code></pre><blockquote><p>运行结果：</p><pre><code class="highlight shell">NodeANodeB</code></pre></blockquote><p>虽然在这个示意性的实现里并没有出现一个复杂的具有多个树枝节点的对象树结构，但是，在实际系统中访问者模式通常是用来处理复杂的对象树结构的，而且访问者模式可以用来处理跨越多个等级结构的树结构问题。这正是访问者模式的功能强大之处。</p><h2 id="2-准备过程时序图"><a href="#2-准备过程时序图" class="headerlink" title="2. 准备过程时序图"></a>2. 准备过程时序图</h2><ul><li>首先，这个示意性的客户端创建了一个结构对象，然后将一个新的NodeA对象和一个新的NodeB对象传入。</li><li>其次，客户端创建了一个VisitorA对象，并将此对象传给结构对象。</li><li>然后，客户端调用结构对象聚集管理方法，将NodeA和NodeB节点加入到结构对象中去。</li><li>最后，客户端调用结构对象的行动方法action()，启动访问过程。</li></ul><p><img src="https://raw.githubusercontent.com/GeorgeChan95/blogimg/master/img/2024/11/23/20241123-173733.png" alt="准备过程时序图"></p><h2 id="3-访问过程时序图"><a href="#3-访问过程时序图" class="headerlink" title="3. 访问过程时序图"></a>3. 访问过程时序图</h2><p>结构对象会遍历它自己所保存的聚集中的所有节点，在本系统中就是节点NodeA和NodeB。首先NodeA会被访问到，这个访问是由以下的操作组成的：</p><ul><li>NodeA对象的接受方法accept()被调用，并将VisitorA对象本身传入；</li><li>NodeA对象反过来调用VisitorA对象的访问方法，并将NodeA对象本身传入；</li><li>VisitorA对象调用NodeA对象的特有方法operationA()。</li></ul><p>从而就完成了双重分派过程，接着，NodeB会被访问，这个访问的过程和NodeA被访问的过程是一样的，这里不再叙述。</p><p><img src="https://raw.githubusercontent.com/GeorgeChan95/blogimg/master/img/2024/11/23/20241123-173749.png" alt="访问过程时序图"></p><h1 id="三、访问者模式的优缺点"><a href="#三、访问者模式的优缺点" class="headerlink" title="三、访问者模式的优缺点"></a>三、访问者模式的优缺点</h1><p><strong>访问者模式的优点</strong></p><ul><li><p><strong>好的扩展性</strong></p><p>能够在不修改对象结构中的元素的情况下，为对象结构中的元素添加新的功能。</p></li><li><p><strong>好的复用性</strong></p><p>可以通过访问者来定义整个对象结构通用的功能，从而提高复用程度。</p></li><li><p><strong>分离无关行为</strong></p><p>可以通过访问者来分离无关的行为，把相关的行为封装在一起，构成一个访问者，这样每一个访问者的功能都比较单一。</p></li></ul><p><strong>访问者模式的缺点</strong></p><ul><li><p><strong>对象结构变化很困难</strong></p><p>不适用于对象结构中的类经常变化的情况，因为对象结构发生了改变，访问者的接口和访问者的实现都要发生相应的改变，代价太高。</p></li><li><p><strong>破坏封装</strong></p><p>访问者模式通常需要对象结构开放内部数据给访问者和 ObjectStructrue，这破坏了对象的封装性。</p></li></ul>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;&lt;strong&gt;访问者模式是对象的行为模式。访问者模式的目的是封装一些施加于某种数据结构元素之上的操作。一旦这些操作需要修改的话，接受这个操作的数据结构则可以保持不变。&lt;/strong&gt;&lt;/p&gt;
&lt;h1 id=&quot;一、分派的概念&quot;&gt;&lt;a href=&quot;#一、分派的概念&quot; cla</summary>
      
    
    
    
    <category term="设计模式" scheme="https://georgechan95.github.io/categories/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"/>
    
    
    <category term="设计模式" scheme="https://georgechan95.github.io/tags/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"/>
    
  </entry>
  
  <entry>
    <title>16-命令模式</title>
    <link href="https://georgechan95.github.io/blog/60fd53f.html"/>
    <id>https://georgechan95.github.io/blog/60fd53f.html</id>
    <published>2024-11-23T12:30:00.000Z</published>
    <updated>2024-11-23T07:05:24.708Z</updated>
    
    <content type="html"><![CDATA[<p><strong>命令模式属于对象的行为模式。命令模式又称为行动(Action)模式或交易(Transaction)模式。</strong></p><p><strong>命令模式把一个请求或者操作封装到一个对象中。命令模式允许系统使用不同的请求把客户端参数化，对请求排队或者记录请求日志，可以提供命令的撤销和恢复功能。</strong></p><h1 id="一、命令模式的结构"><a href="#一、命令模式的结构" class="headerlink" title="一、命令模式的结构"></a>一、命令模式的结构</h1><p>命令模式是对命令的封装。命令模式把发出命令的责任和执行命令的责任分割开，委派给不同的对象。</p><p>每一个命令都是一个操作：请求的一方发出请求要求执行一个操作；接收的一方收到请求，并执行操作。命令模式允许请求的一方和接收的一方独立开来，使得请求的一方不必知道接收请求的一方的接口，更不必知道请求是怎么被接收，以及操作是否被执行、何时被执行，以及是怎么被执行的。</p><p>命令允许请求的一方和接收请求的一方能够独立演化，从而具有以下的优点：</p><ul><li><p>命令模式使新的命令很容易地被加入到系统里。</p></li><li><p>允许接收请求的一方决定是否要否决请求。</p></li><li><p>能较容易地设计一个命令队列。</p></li><li><p>可以容易地实现对请求的撤销和恢复。</p></li><li><p>在需要的情况下，可以较容易地将命令记入日志。</p></li></ul><p>下面以一个示意性的系统，说明命令模式的结构。</p><p><img src="https://raw.githubusercontent.com/GeorgeChan95/blogimg/master/img/2024/11/23/20241123-140717.png" alt="命令模式UML"></p><p>命令模式涉及到五个角色，它们分别是：</p><ul><li><strong>客户端(Client)角色：</strong>创建一个具体命令(ConcreteCommand)对象并确定其接收者。</li><li><strong>命令(Command)角色：</strong>声明了一个给所有具体命令类的抽象接口。</li><li><strong>具体命令(ConcreteCommand)角色：</strong>定义一个接收者和行为之间的弱耦合；实现execute()方法，负责调用接收者的相应操作。execute()方法通常叫做执行方法。</li><li><strong>请求者(Invoker)角色：</strong>负责调用命令对象执行请求，相关的方法叫做行动方法。</li><li><strong>接收者(Receiver)角色：</strong>负责具体实施和执行一个请求。任何一个类都可以成为接收者，实施和执行请求的方法叫做行动方法。</li></ul><p><strong>代码示例</strong></p><pre><code class="highlight java"><span class="comment">/**</span><span class="comment"> * 命令接收者</span><span class="comment"> */</span><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Receiver</span> &#123;    <span class="comment">/**</span><span class="comment">     * 真正执行命令相应的操作</span><span class="comment">     */</span>    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">action</span><span class="params">()</span>&#123;        System.out.println(<span class="string">&quot;==命令接收者执行操作==&quot;</span>);    &#125;&#125;<span class="comment">/**</span><span class="comment"> * 抽象命令角色</span><span class="comment"> */</span><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">Command</span> &#123;    <span class="comment">/**</span><span class="comment">     * 执行方法</span><span class="comment">     */</span>    <span class="keyword">void</span> <span class="title function_">execute</span><span class="params">()</span>;&#125;<span class="comment">/**</span><span class="comment"> * 具体命令角色</span><span class="comment"> */</span><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ConcreteCommand</span> <span class="keyword">implements</span> <span class="title class_">Command</span> &#123;    <span class="comment">// 聚合命令接收者</span>    <span class="keyword">private</span> Receiver receiver;    <span class="keyword">public</span> <span class="title function_">ConcreteCommand</span><span class="params">(Receiver receiver)</span> &#123;        <span class="built_in">this</span>.receiver = receiver;    &#125;    <span class="meta">@Override</span>    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">execute</span><span class="params">()</span> &#123;        <span class="comment">// 调用接收者执行具体的方法</span>        receiver.action();    &#125;&#125;<span class="comment">/**</span><span class="comment"> * 请求者角色</span><span class="comment"> */</span><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Invoker</span> &#123;    <span class="comment">// 聚合抽象命令角色</span>    <span class="keyword">private</span> Command command;    <span class="keyword">public</span> <span class="title function_">Invoker</span><span class="params">(Command command)</span> &#123;        <span class="built_in">this</span>.command = command;    &#125;    <span class="comment">/**</span><span class="comment">     * 行动方法：调用命令对象执行请求</span><span class="comment">     */</span>    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">action</span><span class="params">()</span> &#123;        command.execute();    &#125;&#125;<span class="comment">/**</span><span class="comment"> * 测试类</span><span class="comment"> */</span><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Client</span> &#123;    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;        <span class="comment">// 命令接收者</span>        <span class="type">Receiver</span> <span class="variable">receiver</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Receiver</span>();        <span class="comment">// 创建命令对象，将命令接受者设置进去</span>        <span class="type">Command</span> <span class="variable">command</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ConcreteCommand</span>(receiver);        <span class="comment">// 创建请求执行者，并将命令对象设置进去</span>        <span class="type">Invoker</span> <span class="variable">invoker</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Invoker</span>(command);        <span class="comment">// 执行命令</span>        invoker.action();    &#125;&#125;</code></pre><blockquote><p>运行结果：</p><pre><code class="highlight shell">==命令接收者执行操作==</code></pre></blockquote><h1 id="二、案例：AudioPlayer系统"><a href="#二、案例：AudioPlayer系统" class="headerlink" title="二、案例：AudioPlayer系统"></a>二、案例：AudioPlayer系统</h1><p>小女孩茱丽(Julia)有一个盒式录音机，此录音机有播音(Play)、倒带(Rewind)和停止(Stop)功能，录音机的键盘便是请求者(Invoker)角色；茱丽(Julia)是客户端角色，而录音机便是接收者角色。Command类扮演抽象命令角色，而PlayCommand、StopCommand和RewindCommand便是具体命令类。茱丽(Julia)不需要知道播音(play)、倒带(rewind)和停止(stop)功能是怎么具体执行的，这些命令执行的细节全都由键盘(Keypad)具体实施。茱丽(Julia)只需要在键盘上按下相应的键便可以了。</p><p>录音机是典型的命令模式。录音机按键把客户端与录音机的操作细节分割开来。</p><p><strong>UML类图</strong></p><p><img src="https://raw.githubusercontent.com/GeorgeChan95/blogimg/master/img/2024/11/23/20241123-142909.png" alt="命令模式案例：AudioPlayer系统"></p><p><strong>代码如下：</strong></p><pre><code class="highlight java"><span class="comment">/**</span><span class="comment"> * 接收者角色：录音机</span><span class="comment"> */</span><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">AudioPlayer</span> &#123;    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">play</span><span class="params">()</span>&#123;        System.out.println(<span class="string">&quot;录音机播放...&quot;</span>);    &#125;    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">rewind</span><span class="params">()</span>&#123;        System.out.println(<span class="string">&quot;录音机倒带...&quot;</span>);    &#125;    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">stop</span><span class="params">()</span>&#123;        System.out.println(<span class="string">&quot;录音机停止...&quot;</span>);    &#125;&#125;<span class="comment">/**</span><span class="comment"> * 命令角色</span><span class="comment"> */</span><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">Command</span> &#123;    <span class="comment">/**</span><span class="comment">     * 执行方法</span><span class="comment">     */</span>    <span class="keyword">void</span> <span class="title function_">execute</span><span class="params">()</span>;&#125;<span class="comment">/**</span><span class="comment"> * 具体命令角色：播放命令</span><span class="comment"> */</span><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">PlayCommand</span> <span class="keyword">implements</span> <span class="title class_">Command</span> &#123;    <span class="comment">// 命令接收者</span>    <span class="keyword">private</span> AudioPlayer audioPlayer;    <span class="keyword">public</span> <span class="title function_">PlayCommand</span><span class="params">(AudioPlayer audioPlayer)</span> &#123;        <span class="built_in">this</span>.audioPlayer = audioPlayer;    &#125;    <span class="comment">/**</span><span class="comment">     * 执行方法</span><span class="comment">     */</span>    <span class="meta">@Override</span>    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">execute</span><span class="params">()</span> &#123;        audioPlayer.play();    &#125;&#125;<span class="comment">/**</span><span class="comment"> * 具体命令角色：倒带命令</span><span class="comment"> */</span><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">RewindCommand</span> <span class="keyword">implements</span> <span class="title class_">Command</span> &#123;    <span class="comment">// 命令接收者</span>    <span class="keyword">private</span> AudioPlayer audioPlayer;    <span class="keyword">public</span> <span class="title function_">RewindCommand</span><span class="params">(AudioPlayer audioPlayer)</span> &#123;        <span class="built_in">this</span>.audioPlayer = audioPlayer;    &#125;    <span class="comment">/**</span><span class="comment">     * 执行方法</span><span class="comment">     */</span>    <span class="meta">@Override</span>    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">execute</span><span class="params">()</span> &#123;        audioPlayer.rewind();    &#125;&#125;<span class="comment">/**</span><span class="comment"> * 具体命令角色：停止命令</span><span class="comment"> */</span><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">StopCommand</span> <span class="keyword">implements</span> <span class="title class_">Command</span> &#123;    <span class="comment">// 命令接收者</span>    <span class="keyword">private</span> AudioPlayer audioPlayer;    <span class="keyword">public</span> <span class="title function_">StopCommand</span><span class="params">(AudioPlayer audioPlayer)</span> &#123;        <span class="built_in">this</span>.audioPlayer = audioPlayer;    &#125;    <span class="comment">/**</span><span class="comment">     * 执行方法</span><span class="comment">     */</span>    <span class="meta">@Override</span>    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">execute</span><span class="params">()</span> &#123;        audioPlayer.stop();    &#125;&#125;<span class="comment">/**</span><span class="comment"> * 请求者角色：键盘</span><span class="comment"> */</span><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Keypad</span> &#123;    <span class="keyword">private</span> Command playCommand;    <span class="keyword">private</span> Command rewindCommand;    <span class="keyword">private</span> Command stopCommand;    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setPlayCommand</span><span class="params">(Command playCommand)</span> &#123;        <span class="built_in">this</span>.playCommand = playCommand;    &#125;    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setRewindCommand</span><span class="params">(Command rewindCommand)</span> &#123;        <span class="built_in">this</span>.rewindCommand = rewindCommand;    &#125;    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setStopCommand</span><span class="params">(Command stopCommand)</span> &#123;        <span class="built_in">this</span>.stopCommand = stopCommand;    &#125;    <span class="comment">/**</span><span class="comment">     * 执行播放方法</span><span class="comment">     */</span>    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">play</span><span class="params">()</span>&#123;        playCommand.execute();    &#125;    <span class="comment">/**</span><span class="comment">     * 执行倒带方法</span><span class="comment">     */</span>    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">rewind</span><span class="params">()</span>&#123;        rewindCommand.execute();    &#125;    <span class="comment">/**</span><span class="comment">     * 执行播放方法</span><span class="comment">     */</span>    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">stop</span><span class="params">()</span>&#123;        stopCommand.execute();    &#125;&#125;<span class="comment">/**</span><span class="comment"> * 测试类</span><span class="comment"> */</span><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Julia</span> &#123;    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;        <span class="comment">// 创建接收者对象</span>        <span class="type">AudioPlayer</span> <span class="variable">audioPlayer</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">AudioPlayer</span>();        <span class="comment">// 创建命令对象</span>        <span class="type">Command</span> <span class="variable">playCommand</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">PlayCommand</span>(audioPlayer);        <span class="type">Command</span> <span class="variable">rewindCommand</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">RewindCommand</span>(audioPlayer);        <span class="type">Command</span> <span class="variable">stopCommand</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">StopCommand</span>(audioPlayer);        <span class="comment">// 创建请求者对象</span>        <span class="type">Keypad</span> <span class="variable">keypad</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Keypad</span>();        keypad.setPlayCommand(playCommand);        keypad.setRewindCommand(rewindCommand);        keypad.setStopCommand(stopCommand);        <span class="comment">// 测试</span>        keypad.play();        keypad.stop();        keypad.rewind();        keypad.stop();        keypad.play();    &#125;&#125;</code></pre><blockquote><p>运行结果：</p><pre><code class="highlight shell">录音机播放...录音机停止...录音机倒带...录音机停止...录音机播放...</code></pre></blockquote><h1 id="三、宏命令"><a href="#三、宏命令" class="headerlink" title="三、宏命令"></a>三、宏命令</h1><p>所谓宏命令简单点说就是包含多个命令的命令，是一个命令的组合。</p><p>设想茱丽的录音机有一个记录功能，可以把一个一个的命令记录下来，再在任何需要的时候重新把这些记录下来的命令一次性执行，这就是所谓的宏命令集功能。因此，茱丽的录音机系统现在有四个键，分别为播音、倒带、停止和宏命令功能。此时系统的设计与前面的设计相比有所增强，主要体现在Julia类现在有了一个新方法，用以操作宏命令键。</p><p><img src="https://raw.githubusercontent.com/GeorgeChan95/blogimg/master/img/2024/11/23/20241123-144947.png" alt="宏命令"></p><p><strong>代码如下：</strong></p><p>系统需要一个代表宏命令的接口，以定义出具体宏命令所需要的接口。</p><pre><code class="highlight java"><span class="comment">/**</span><span class="comment"> * 系统需要一个代表宏命令的接口，以定义出具体宏命令所需要的接口。</span><span class="comment"> */</span><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">MacroCommand</span> <span class="keyword">extends</span> <span class="title class_">Command</span> &#123;    <span class="comment">/**</span><span class="comment">     * 宏命令聚集的管理方法，可以添加一个成员命令</span><span class="comment">     * <span class="doctag">@param</span> cmd</span><span class="comment">     */</span>    <span class="keyword">void</span> <span class="title function_">add</span><span class="params">(Command cmd)</span>;    <span class="comment">/**</span><span class="comment">     * 宏命令聚集的管理方法, 可以删除一个成员命令</span><span class="comment">     * <span class="doctag">@param</span> cmd</span><span class="comment">     */</span>    <span class="keyword">void</span> <span class="title function_">remove</span><span class="params">(Command cmd)</span>;&#125;<span class="comment">/**</span><span class="comment"> * 具体的宏命令MacroAudioCommand类负责把个别的命令合成宏命令。</span><span class="comment"> */</span><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">MacroAudioCommand</span> <span class="keyword">implements</span> <span class="title class_">MacroCommand</span> &#123;    List&lt;Command&gt; commandList = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();    <span class="meta">@Override</span>    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">add</span><span class="params">(Command cmd)</span> &#123;        commandList.add(cmd);    &#125;    <span class="meta">@Override</span>    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">remove</span><span class="params">(Command cmd)</span> &#123;        commandList.remove(cmd);    &#125;    <span class="comment">/**</span><span class="comment">     * 执行方法</span><span class="comment">     */</span>    <span class="meta">@Override</span>    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">execute</span><span class="params">()</span> &#123;        <span class="keyword">for</span> (Command command : commandList) &#123;            command.execute();        &#125;    &#125;&#125;<span class="comment">/**</span><span class="comment"> * 测试类</span><span class="comment"> */</span><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Julia</span> &#123;    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;        <span class="comment">// 创建接收者对象</span>        <span class="type">AudioPlayer</span> <span class="variable">audioPlayer</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">AudioPlayer</span>();        <span class="comment">//创建命令对象</span>        <span class="type">Command</span> <span class="variable">playCommand</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">PlayCommand</span>(audioPlayer);        <span class="type">Command</span> <span class="variable">rewindCommand</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">RewindCommand</span>(audioPlayer);        <span class="type">Command</span> <span class="variable">stopCommand</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">StopCommand</span>(audioPlayer);        <span class="type">MacroCommand</span> <span class="variable">marco</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">MacroAudioCommand</span>();        marco.add(playCommand);        marco.add(rewindCommand);        marco.add(stopCommand);        marco.execute();    &#125;&#125;</code></pre><blockquote><p>运行结果：</p><pre><code class="highlight shell">录音机播放...录音机倒带...录音机停止..</code></pre></blockquote><h1 id="四、命令模式的优点"><a href="#四、命令模式的优点" class="headerlink" title="四、命令模式的优点"></a>四、命令模式的优点</h1><ul><li><p><strong>更松散的耦合</strong></p><p>命令模式使得发起命令的对象——客户端，和具体实现命令的对象——接收者对象完全解耦，也就是说发起命令的对象完全不知道具体实现对象是谁，也不知道如何实现。</p></li><li><p><strong>更动态的控制</strong></p><p>命令模式把请求封装起来，可以动态地对它进行参数化、队列化和日志化等操作，从而使得系统更灵活。</p></li><li><p><strong>很自然的复合命令</strong></p><p>命令模式中的命令对象能够很容易地组合成复合命令，也就是宏命令，从而使系统操作更简单，功能更强大。</p></li><li><p><strong>更好的扩展性</strong></p><p>由于发起命令的对象和具体的实现完全解耦，因此扩展新的命令就很容易，只需要实现新的命令对象，然后在装配的时候，把具体的实现对象设置到命令对象中，然后就可以使用这个命令对象，已有的实现完全不用变化。</p></li></ul>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;&lt;strong&gt;命令模式属于对象的行为模式。命令模式又称为行动(Action)模式或交易(Transaction)模式。&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;命令模式把一个请求或者操作封装到一个对象中。命令模式允许系统使用不同的请求把客户端参数化，对请求排队或者</summary>
      
    
    
    
    <category term="设计模式" scheme="https://georgechan95.github.io/categories/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"/>
    
    
    <category term="设计模式" scheme="https://georgechan95.github.io/tags/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"/>
    
  </entry>
  
  <entry>
    <title>15-模板方法模式</title>
    <link href="https://georgechan95.github.io/blog/4930323d.html"/>
    <id>https://georgechan95.github.io/blog/4930323d.html</id>
    <published>2024-11-23T11:40:00.000Z</published>
    <updated>2024-11-23T05:12:39.298Z</updated>
    
    <content type="html"><![CDATA[<h1 id="一、什么是模板方法设计模式"><a href="#一、什么是模板方法设计模式" class="headerlink" title="一、什么是模板方法设计模式"></a>一、什么是模板方法设计模式</h1><p>从字面意义上理解, 模板方法就是定义出来一套方法, 作为模板, 也就是基础。 在这个基础上, 我们可以进行加工，实现个性化的实现。比如：一日餐三. 早餐, 中餐, 晚餐. 每个人都要吃三餐, 但每个人的三餐吃的可能都不一样. 一日三餐定义了模板–早中晚, 每个人的三餐就是模板的具体实现.</p><h2 id="1-模板方法的用途"><a href="#1-模板方法的用途" class="headerlink" title="1. 模板方法的用途"></a>1. 模板方法的用途</h2><ul><li>将不变的行为从子类搬到超类，去除了子类中的重复代码。</li><li>规范子类的结构</li></ul><h2 id="2-模板方法的定义"><a href="#2-模板方法的定义" class="headerlink" title="2. 模板方法的定义"></a>2. 模板方法的定义</h2><p>定义一个操作中的算法骨架，而将算法的一些步骤延迟到子类中，使得子类可以不改变该算法结构的情况下重定义该算法的某些特定步骤。它是一种类<strong>行为型模式</strong>。</p><h1 id="二、定义模板方法的步骤"><a href="#二、定义模板方法的步骤" class="headerlink" title="二、定义模板方法的步骤"></a>二、定义模板方法的步骤</h1><blockquote><p>第一步: 定义模板类 </p><p>第二步: 定义具体子类 </p><p>第三步: 客户端调用</p></blockquote><p>下面来了解每一个步骤：</p><h2 id="1-定义模板类"><a href="#1-定义模板类" class="headerlink" title="1. 定义模板类"></a>1. 定义模板类</h2><p>通常模板类是抽象类，负责给出算法的轮廓或者框架。他是有若干个<strong>模板方法</strong>和若干个<strong>基本方法</strong>构成。</p><h3 id="1-1-模板方法"><a href="#1-1-模板方法" class="headerlink" title="1.1 模板方法"></a>1.1 模板方法</h3><p>定义了算法的骨架， 定义了方法调用的顺序， 其中包含一个或者多个基本方法</p><h3 id="1-2-基本方法"><a href="#1-2-基本方法" class="headerlink" title="1.2 基本方法"></a>1.2 基本方法</h3><p>基本方法有三种类型：</p><ul><li>抽象方法：子类必须重写的方法。没有默认实现。</li><li>具体方法：父类定义的默认实现，有实现逻辑，可以被具体的子类继承或重写</li><li>钩子方法：判断的逻辑方法和需要子类重写的空方法两种。</li></ul><h2 id="2-定义具体子类"><a href="#2-定义具体子类" class="headerlink" title="2. 定义具体子类"></a>2. 定义具体子类</h2><p>具体子类，也就是具体的实现类， 实现抽象类中的抽象方法。他们是抽象的模板方法中一个组成部分。</p><h2 id="3-定义客户端调用"><a href="#3-定义客户端调用" class="headerlink" title="3. 定义客户端调用"></a>3. 定义客户端调用</h2><p>客户端调用抽象类， 实例化的时候实例化具体类， 只需要调用抽象类的模板方法就可以了。</p><h2 id="4-实例演示"><a href="#4-实例演示" class="headerlink" title="4. 实例演示"></a>4. 实例演示</h2><p>下面来看一下抽象类和子类之间的UML图和源码实现</p><p><strong>UML类图</strong></p><img src="https://raw.githubusercontent.com/GeorgeChan95/blogimg/master/img/2024/11/23/20241123-102632.png" alt="模板方法设计模式" style="zoom: 50%;" /><p>从图中可以看出抽象类的结构可以定义三类方法。 可以有一个也可以有多个。子类必须需要实现抽象类中的抽象方法，可以选择性重写父类的具体方法。子类实现接口的时候，要多思考设计模式的六大原则。</p><p><strong>代码实现</strong></p><ul><li><p>先定义抽象类， 也就是框架。</p><pre><code class="highlight java"><span class="comment">/**</span><span class="comment"> * 抽象类, 定义模板</span><span class="comment"> */</span><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">class</span> <span class="title class_">AbstractClass</span> &#123;    <span class="comment">/**</span><span class="comment">     * 模板方法</span><span class="comment">     * 规范了流程的框架</span><span class="comment">     */</span>    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">templateMethod</span><span class="params">()</span> &#123;        <span class="comment">// 先调用具体方法</span>        specificMethod();        <span class="comment">// 在调用抽象方法</span>        abstractMethod();    &#125;    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">specificMethod</span><span class="params">()</span> &#123;        <span class="comment">// 具体的公共逻辑, 父子类通用</span>        System.out.println(<span class="string">&quot;具体方法---父子类通用逻辑&quot;</span>);    &#125;    <span class="comment">/**</span><span class="comment">     * 抽象方法</span><span class="comment">     * 抽象方法, 子类必须重写</span><span class="comment">     */</span>    <span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">void</span> <span class="title function_">abstractMethod</span><span class="params">()</span>;&#125;</code></pre></li><li><p>定义具体的实现类， 实现父类的抽象方法</p><pre><code class="highlight java"><span class="comment">/**</span><span class="comment"> * 具体实现类</span><span class="comment"> */</span><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ConcreteClass</span> <span class="keyword">extends</span> <span class="title class_">AbstractClass</span> &#123;    <span class="comment">/**</span><span class="comment">     * 重写父类的抽象方法</span><span class="comment">     */</span>    <span class="meta">@Override</span>    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">abstractMethod</span><span class="params">()</span> &#123;        System.out.println(<span class="string">&quot;具体实现类--重写父类的抽象方法&quot;</span>);    &#125;&#125;</code></pre></li><li><p>最后定义客户端调用</p><pre><code class="highlight java"><span class="comment">/**</span><span class="comment"> * 模板方法客户端</span><span class="comment"> */</span><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">TemplateClient</span> &#123;    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;        <span class="type">AbstractClass</span> <span class="variable">abstractClass</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ConcreteClass</span>();        abstractClass.templateMethod();    &#125;&#125;</code></pre><blockquote><p>运行结果：</p><pre><code class="highlight shell">具体方法---父子类通用逻辑具体实现类--重写父类的抽象方法</code></pre></blockquote></li></ul><p>对照模板方法设计模式，我们来看一个具体的案例。</p><h1 id="三、案例解析"><a href="#三、案例解析" class="headerlink" title="三、案例解析"></a>三、案例解析</h1><h2 id="1-案例1：-一日规划"><a href="#1-案例1：-一日规划" class="headerlink" title="1. 案例1： 一日规划"></a>1. 案例1： 一日规划</h2><p>每个人的一日安排都有三餐， 早餐， 中餐，晚参。 但每个人的三餐食物不尽相同，我们来看看每个人的三餐变化， 以及三餐前后要做的事情。</p><pre><code class="highlight java"><span class="comment">/**</span><span class="comment"> * 一日三餐抽象类</span><span class="comment"> */</span><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">class</span> <span class="title class_">ArrangementAbstract</span> &#123;    <span class="comment">/**</span><span class="comment">     * 模板方法</span><span class="comment">     * 规定了一天的框架</span><span class="comment">     */</span>    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">templateMethod</span><span class="params">()</span> &#123;        System.out.println(<span class="string">&quot;一日安排如下: &quot;</span>);        getUp();        breakfast();        lunch();        dinner();        getDown();    &#125;    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">getUp</span><span class="params">()</span> &#123;        System.out.println(<span class="string">&quot;起床&quot;</span>);    &#125;    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">getDown</span><span class="params">()</span> &#123;        System.out.println(<span class="string">&quot;睡觉&quot;</span>);    &#125;    <span class="comment">/**</span><span class="comment">     * 早餐抽象类</span><span class="comment">     */</span>    <span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">void</span> <span class="title function_">breakfast</span><span class="params">()</span>;    <span class="comment">/**</span><span class="comment">     * 午餐抽象类</span><span class="comment">     */</span>    <span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">void</span> <span class="title function_">lunch</span><span class="params">()</span>;    <span class="comment">/**</span><span class="comment">     * 晚餐抽象类</span><span class="comment">     */</span>    <span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">void</span> <span class="title function_">dinner</span><span class="params">()</span>;&#125;</code></pre><p>定义一日三餐抽象类。每个人的日程安排都是，起床，早餐，中餐，晚餐，睡觉。 其中起床和睡觉是每个人都要做的事情，三餐也是，但三餐的食物不同，于是我们将三餐定义为抽象</p><p>一日安排实现类</p><pre><code class="highlight java"><span class="comment">/**</span><span class="comment"> * 张三的一日三餐安排</span><span class="comment"> */</span><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">PersonArrangement</span> <span class="keyword">extends</span> <span class="title class_">ArrangementAbstract</span> &#123;    <span class="keyword">private</span> String name;    <span class="keyword">public</span> <span class="title function_">PersonArrangement</span><span class="params">(String name)</span> &#123;        <span class="built_in">this</span>.name = name;    &#125;    <span class="comment">/**</span><span class="comment">     * 早餐抽象类</span><span class="comment">     */</span>    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">breakfast</span><span class="params">()</span> &#123;        System.out.println(name + <span class="string">&quot;--早餐吃牛奶面包&quot;</span>);    &#125;    <span class="comment">/**</span><span class="comment">     * 午餐抽象类</span><span class="comment">     */</span>    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">lunch</span><span class="params">()</span> &#123;        System.out.println(name + <span class="string">&quot;--中餐吃食堂&quot;</span>);    &#125;    <span class="comment">/**</span><span class="comment">     * 晚餐抽象类</span><span class="comment">     */</span>    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">dinner</span><span class="params">()</span> &#123;        System.out.println(name + <span class="string">&quot;--晚餐吃水果&quot;</span>);    &#125;&#125;</code></pre><p>客户端调用</p><pre><code class="highlight java"><span class="comment">/**</span><span class="comment"> * 测试类</span><span class="comment"> */</span><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Client</span> &#123;    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;        <span class="type">ArrangementAbstract</span> <span class="variable">arrangementAbstract</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">PersonArrangement</span>(<span class="string">&quot;张三&quot;</span>);        arrangementAbstract.templateMethod();    &#125;&#125;</code></pre><blockquote><p>运行结果：</p><pre><code class="highlight shell">一日安排如下: 起床张三--早餐吃牛奶面包张三--中餐吃食堂张三--晚餐吃水果睡觉</code></pre></blockquote><p>可以看出， 完全按照模板方法的步骤实现。</p><h2 id="2-案例2：-钩子方法"><a href="#2-案例2：-钩子方法" class="headerlink" title="2. 案例2： 钩子方法"></a>2. 案例2： 钩子方法</h2><p>我们上面说了, 模板方法设计模式中, 基本方法包括抽象方法,具体方法和钩子方法. 如果能够使用好钩子方法, 可以在程序中完美实现子类控制父类的行为. 我们来看下面的案例:</p><p>我们在抽象方法中定义一个钩子方法 <code>hookMethod()</code> , 在模板方法 <code>templateMethod()</code> 中,钩子方法控制了代码的流程.</p><p><strong>UML类图</strong></p><p><img src="https://raw.githubusercontent.com/GeorgeChan95/blogimg/master/img/2024/11/23/20241123-121856.png" alt="模板方法模式-钩子方法"></p><p><strong>代码实现如下：</strong></p><pre><code class="highlight java"><span class="comment">/**</span><span class="comment"> * 抽象类, 定义模板</span><span class="comment"> */</span><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">class</span> <span class="title class_">AbstractClass</span> &#123;    <span class="comment">/**</span><span class="comment">     * 定义模板方法</span><span class="comment">     * 规范了流程的框架</span><span class="comment">     */</span>    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">templateMethod</span><span class="params">()</span> &#123;        <span class="comment">// 调用具体方法</span>        specificMethod();        <span class="comment">// 钩子方法控制下一步骤</span>        <span class="keyword">if</span> (hookMethod()) &#123;            <span class="comment">// 调用抽象方法</span>            abstractMethod();        &#125;    &#125;    <span class="comment">/**</span><span class="comment">     * 具体方法</span><span class="comment">     */</span>    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">specificMethod</span><span class="params">()</span> &#123;        <span class="comment">// 具体的公共逻辑, 父子类通用</span>        System.out.println(<span class="string">&quot;具体方法---父子类通用逻辑&quot;</span>);    &#125;    <span class="comment">/**</span><span class="comment">     * 抽象方法</span><span class="comment">     *</span><span class="comment">     * 抽象方法, 子类必须重写</span><span class="comment">     */</span>    <span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">void</span> <span class="title function_">abstractMethod</span><span class="params">()</span>;    <span class="comment">/**</span><span class="comment">     * 钩子方法</span><span class="comment">     * 钩子方法是有具体实现的,</span><span class="comment">     */</span>    <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">hookMethod</span><span class="params">()</span> &#123;        <span class="keyword">return</span> <span class="literal">true</span>;    &#125;&#125;<span class="comment">/**</span><span class="comment"> * 具体实现类</span><span class="comment"> */</span><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ConcreteClass</span> <span class="keyword">extends</span> <span class="title class_">AbstractClass</span>&#123;    <span class="comment">/**</span><span class="comment">     * 重写父类的抽象方法</span><span class="comment">     */</span>    <span class="meta">@Override</span>    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">abstractMethod</span><span class="params">()</span> &#123;        System.out.println(<span class="string">&quot;具体实现类--重写父类的抽象方法&quot;</span>);    &#125;    <span class="comment">/**</span><span class="comment">     * 子类重写钩子方法，非必须</span><span class="comment">     * <span class="doctag">@return</span></span><span class="comment">     */</span>    <span class="meta">@Override</span>    <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">hookMethod</span><span class="params">()</span> &#123;        System.out.println(<span class="string">&quot;重写了父类的钩子方法, 反向控制父类的行为&quot;</span>);        <span class="keyword">return</span> <span class="literal">false</span>;    &#125;&#125;<span class="comment">/**</span><span class="comment"> * 测试类</span><span class="comment"> */</span><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">TemplateClient</span> &#123;    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;        <span class="type">AbstractClass</span> <span class="variable">abstractClass</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ConcreteClass</span>();        abstractClass.templateMethod();    &#125;&#125;</code></pre><blockquote><p>运行结果</p><pre><code class="highlight shell">具体方法---父子类通用逻辑重写了父类的钩子方法, 反向控制父类的行为</code></pre></blockquote><p>如果子类钩子方法 <code>HookMethod()</code> 的代码改变，则程序的运行结果也会发生改变。</p><h1 id="四、模板方法的优缺点"><a href="#四、模板方法的优缺点" class="headerlink" title="四、模板方法的优缺点"></a>四、模板方法的优缺点</h1><p><strong>优点</strong></p><ul><li>规范了框架, 封装了不变的部分, 扩展了可变的部分. 父类定义框架, 并抽象了公共不变的部分, 子类通过重写扩展完善了框架的实现.</li><li>使用了”开闭原则”, 对扩展开放, 对修改关闭. 子类可以通过重写父类的抽象方法来扩展父类的实现.</li><li>行为集中有父类控制, 规范流程。</li></ul><p><strong>缺点</strong></p><ul><li>每一种实现都需要定义一个具体实现类, 增加类的数量, 系统更加复杂</li><li>继承的缺点, 一旦父类增加一个抽象方法, 所有子类都需要增加. 这一点违背”开闭原则”.</li><li>父类中的抽象方法由子类实现, 子类的执行结果影响父类, 这种”反向控制”结构, 会增加代码的复杂性。</li></ul><h1 id="五、使用场景"><a href="#五、使用场景" class="headerlink" title="五、使用场景"></a>五、使用场景</h1><ul><li>算法的整体步骤是固定的，但个别部分容易发生变化时，可以考虑使用模板方法设计模式，将容易发生变化的部分抽象出来，提供给子类去实现。</li><li>当多个子类存在公共的行为时，可以将其提取出来并集中到一个公共父类中以避免代码重复。首先，要识别现有代码中的不同之处，并且将不同之处分离为新的操作。最后，用一个调用这些新的操作的模板方法来替换这些不同的代码。</li><li>当需要控制子类的扩展时，模板方法只在特定点调用钩子操作，这样就只允许在这些点进行扩展。</li><li>重构时，模板方法模式是一个经常使用到的模式，把相同的代码抽取到父类中，通过钩子函数约束其行为</li></ul><h1 id="六、对设计模式六大原则的应用思考"><a href="#六、对设计模式六大原则的应用思考" class="headerlink" title="六、对设计模式六大原则的应用思考"></a>六、对设计模式六大原则的应用思考</h1><ul><li>单一职责原则: 一个方法只有一个引起变化的原因, 这个不太好看出, 要看子类代码的具体实现</li><li>里式替换原则： 父类出现的地方都可以使用子类替换,并且结果保持一致. 子类重写了父类的方法。 模板方法设计模式可能违背里式替换原则, 不过，这正是能够“反向控制”的原理</li><li>接口隔离原则: 依赖于最小的单一接口, 而不是胖接口. 符合</li><li>依赖倒置原则: 依赖于抽象, 而不是依赖于具体. 符合</li><li>迪米特法则: 最少知识原则. 之和朋友沟通, 减少和朋友的沟通. 这个需要看子类具体实现是否符合</li><li>开闭原则: 违背开闭原则,  一旦父类增加一个抽象方法， 所有子类都需要对应增加</li></ul>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;一、什么是模板方法设计模式&quot;&gt;&lt;a href=&quot;#一、什么是模板方法设计模式&quot; class=&quot;headerlink&quot; title=&quot;一、什么是模板方法设计模式&quot;&gt;&lt;/a&gt;一、什么是模板方法设计模式&lt;/h1&gt;&lt;p&gt;从字面意义上理解, 模板方法就是定义出来一套方法, </summary>
      
    
    
    
    <category term="设计模式" scheme="https://georgechan95.github.io/categories/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"/>
    
    
    <category term="设计模式" scheme="https://georgechan95.github.io/tags/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"/>
    
  </entry>
  
  <entry>
    <title>14-代理模式</title>
    <link href="https://georgechan95.github.io/blog/e4235185.html"/>
    <id>https://georgechan95.github.io/blog/e4235185.html</id>
    <published>2024-11-21T15:16:00.000Z</published>
    <updated>2024-11-23T01:52:19.969Z</updated>
    
    <content type="html"><![CDATA[<h1 id="一、代理模式的基本介绍"><a href="#一、代理模式的基本介绍" class="headerlink" title="一、代理模式的基本介绍"></a>一、代理模式的基本介绍</h1><ul><li><p>代理模式：为一个对象提供一个替身，以控制对这个对象的访问。即通过代理对象访问目标对象.这样做的好处 是:可以在目标对象实现的基础上,增强额外的功能操作, 即扩展目标对象的功能。</p></li><li><p>被代理的对象可以是远程对象、创建开销大的对象或需要安全控制的对象.</p></li><li><p>代理模式有不同的形式,  主要有三种 <strong>静态代理</strong>、<strong>动态代理</strong> (JDK 代理、接口代理)和 <strong>Cglib 代理</strong> (可以在内存 动态的创建对象，而不需要实现接口， 他是属于动态代理的范畴)  。</p></li></ul><p>代理模式示意图</p><p><img src="https://raw.githubusercontent.com/GeorgeChan95/blogimg/master/img/2024/11/21/20241121-231932.png" alt="代理模式"></p><h1 id="二静态代理"><a href="#二静态代理" class="headerlink" title="二静态代理"></a>二静态代理</h1><h2 id="1-基本介绍"><a href="#1-基本介绍" class="headerlink" title="1. 基本介绍"></a>1. 基本介绍</h2><p>静态代理在使用时,需要定义接口或者父类,被代理对象(即目标对象)与代理对象一起实现相同的接口或者是继承相同父类</p><h2 id="2-应用实例"><a href="#2-应用实例" class="headerlink" title="2. 应用实例"></a>2. 应用实例</h2><p><strong>具体要求</strong></p><ul><li>定义一个接口: <code>ITeacherDao</code></li><li>目标对象 <code>TeacherDAO</code> 实现接口 <code>ITeacherDAO</code></li></ul><ol start="3"><li>使用静态代理方式,就需要在代理对象 <code>TeacherDAOProxy</code> 中也实现 <code>ITeacherDAO</code></li><li>调用的时候通过调用代理对象的方法来调用目标对象.</li><li>特别提醒：代理对象与目标对象要实现相同的接口,然后通过调用相同的方法来调用目标对象的方法</li></ol><p><strong>思路分析图解(类图)</strong></p><p><img src="https://raw.githubusercontent.com/GeorgeChan95/blogimg/master/img/2024/11/21/20241121-234014.png" alt="静态代理UML图"></p><p><strong>代码实现</strong></p><pre><code class="highlight java"><span class="comment">// 接口</span><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">ITeacherDao</span> &#123;    <span class="keyword">void</span> <span class="title function_">teach</span><span class="params">()</span>; <span class="comment">// 授课的方法</span>&#125;<span class="comment">// 被代理的类</span><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">TeacherDao</span> <span class="keyword">implements</span> <span class="title class_">ITeacherDao</span> &#123;    <span class="meta">@Override</span>    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">teach</span><span class="params">()</span> &#123;        System.out.println(<span class="string">&quot; 老师授课中  。。。。。&quot;</span>);    &#125;&#125;<span class="comment">//代理对象,静态代理</span><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">TeacherDaoProxy</span> <span class="keyword">implements</span> <span class="title class_">ITeacherDao</span> &#123;    <span class="keyword">private</span> ITeacherDao target; <span class="comment">// 目标对象，通过接口来聚合</span>    <span class="keyword">public</span> <span class="title function_">TeacherDaoProxy</span><span class="params">(ITeacherDao target)</span> &#123;        <span class="built_in">this</span>.target = target;    &#125;    <span class="meta">@Override</span>    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">teach</span><span class="params">()</span> &#123;        <span class="built_in">this</span>.before();        target.teach();        <span class="built_in">this</span>.after();    &#125;    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">before</span><span class="params">()</span> &#123;        System.out.println(<span class="string">&quot;准备课程&quot;</span>);    &#125;    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">after</span><span class="params">()</span> &#123;        System.out.println(<span class="string">&quot;结束课程&quot;</span>);    &#125;&#125;<span class="comment">// 测试类</span><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Client</span> &#123;    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;        <span class="comment">//创建目标对象(被代理对象)</span>        <span class="type">TeacherDao</span> <span class="variable">teacherDao</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">TeacherDao</span>();        <span class="comment">//创建代理对象, 同时将被代理对象传递给代理对象</span>        <span class="type">TeacherDaoProxy</span> <span class="variable">teacherDaoProxy</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">TeacherDaoProxy</span>(teacherDao);        <span class="comment">//通过代理对象，调用到被代理对象的方法</span>        <span class="comment">//即：执行的是代理对象的方法，代理对象再去调用目标对象的方法</span>        teacherDaoProxy.teach();    &#125;&#125;</code></pre><blockquote><p>运行结果:</p><pre><code class="highlight shell">准备课程 老师授课中  。。。。。结束课程</code></pre></blockquote><h2 id="3-静态代理优缺点"><a href="#3-静态代理优缺点" class="headerlink" title="3. 静态代理优缺点"></a>3. 静态代理优缺点</h2><ul><li>优点：在不修改目标对象的功能前提下,  能通过代理对象对目标功能扩展</li><li>缺点：因为代理对象需要与目标对象实现一样的接口,所以会有很多代理类</li><li>一旦接口增加方法, 目标对象与代理对象都要维护</li></ul><h1 id="三、动态代理"><a href="#三、动态代理" class="headerlink" title="三、动态代理"></a>三、动态代理</h1><h2 id="1-基本介绍-1"><a href="#1-基本介绍-1" class="headerlink" title="1. 基本介绍"></a>1. 基本介绍</h2><ul><li>代理对象,不需要实现接口，但是目标对象要实现接口，否则不能用动态代理</li><li>代理对象的生成，是利用 JDK 的 API ，动态的在内存中构建代理对象</li><li>动态代理也叫做：JDK 代理、接口代理</li></ul><h2 id="2-JDK-中生成代理对象的-API"><a href="#2-JDK-中生成代理对象的-API" class="headerlink" title="2. JDK 中生成代理对象的 API"></a>2. JDK 中生成代理对象的 API</h2><ul><li>代理类所在包: <code>java.lang.reflect.Proxy</code></li><li>JDK 实现代理只需要使用 <code>newProxyInstance</code> 方法,但是该方法需要接收三个参数,完整的写法是: <code>static Object newProxyInstance(ClassLoader loader, Class&lt;?&gt;[] interfaces,InvocationHandler h )</code></li></ul><h2 id="3-应用实例"><a href="#3-应用实例" class="headerlink" title="3. 应用实例"></a>3. 应用实例</h2><p><strong>应用实例要求</strong></p><p>将前面的静态代理改进成动态代理模式(即：JDK 代理模式)</p><p><strong>思路图解(类图)</strong></p><p><img src="https://raw.githubusercontent.com/GeorgeChan95/blogimg/master/img/2024/11/21/20241121-235947.png" alt="动态代理UML图"></p><p><strong>代码实现</strong></p><pre><code class="highlight java"><span class="comment">// 接口</span><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">ITeacherDao</span> &#123;    <span class="keyword">void</span> <span class="title function_">teach</span><span class="params">()</span>; <span class="comment">// 授课的方法</span>    <span class="keyword">void</span> <span class="title function_">sayHello</span><span class="params">(String name)</span>;&#125;<span class="comment">// 被代理的类</span><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">TeacherDao</span> <span class="keyword">implements</span> <span class="title class_">ITeacherDao</span> &#123;    <span class="meta">@Override</span>    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">teach</span><span class="params">()</span> &#123;        System.out.println(<span class="string">&quot; 老师授课中  。。。。。&quot;</span>);    &#125;    <span class="meta">@Override</span>    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">sayHello</span><span class="params">(String name)</span> &#123;        System.out.println(<span class="string">&quot;hello &quot;</span> + name);    &#125;&#125;<span class="comment">// JDK动态代理类</span><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ProxyFactory</span> &#123;    <span class="keyword">private</span> ITeacherDao target;    <span class="keyword">public</span> <span class="title function_">ProxyFactory</span><span class="params">(ITeacherDao target)</span> &#123;        <span class="built_in">this</span>.target = target;    &#125;    <span class="comment">//说明</span>    <span class="comment">/*</span><span class="comment">     *  public static Object newProxyInstance(ClassLoader loader,</span><span class="comment">                                      Class&lt;?&gt;[] interfaces,</span><span class="comment">                                      InvocationHandler h)</span><span class="comment"></span><span class="comment">        //1. ClassLoader loader ： 指定当前目标对象使用的类加载器, 获取加载器的方法固定</span><span class="comment">        //2. Class&lt;?&gt;[] interfaces: 目标对象实现的接口类型，使用泛型方法确认类型</span><span class="comment">        //3. InvocationHandler h : 事情处理，执行目标对象的方法时，会触发事情处理器方法, 会把当前执行的目标对象方法作为参数传入</span><span class="comment">     */</span>    <span class="keyword">public</span> Object <span class="title function_">getProxyInstance</span><span class="params">()</span> &#123;        <span class="keyword">return</span> Proxy.newProxyInstance(target.getClass().getClassLoader(), target.getClass().getInterfaces(), <span class="keyword">new</span> <span class="title class_">InvocationHandler</span>() &#123;            <span class="meta">@Override</span>            <span class="keyword">public</span> Object <span class="title function_">invoke</span><span class="params">(Object proxy, Method method, Object[] args)</span> <span class="keyword">throws</span> Throwable &#123;                System.out.println(<span class="string">&quot;JDK代理开始~&quot;</span>);                <span class="type">Object</span> <span class="variable">resultVal</span> <span class="operator">=</span> method.invoke(target, args);                System.out.println(<span class="string">&quot;JDK代理提交~&quot;</span>);                <span class="keyword">return</span> resultVal;            &#125;        &#125;);    &#125;&#125;<span class="comment">// 测试类</span><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Client</span> &#123;    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;        <span class="comment">// 创建目标对象</span>        <span class="type">ITeacherDao</span> <span class="variable">target</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">TeacherDao</span>();        <span class="comment">// 给目标对象，创建代理对象, 可以转成 ITeacherDao</span>        <span class="type">ITeacherDao</span> <span class="variable">proxyInstance</span> <span class="operator">=</span> (ITeacherDao) <span class="keyword">new</span> <span class="title class_">ProxyFactory</span>(target).getProxyInstance();        <span class="comment">// proxyInstance=class com.sun.proxy.$Proxy0 内存中动态生成了代理对象</span>        System.out.println(<span class="string">&quot;proxyInstance=&quot;</span> + proxyInstance.getClass());        <span class="comment">//通过代理对象，调用目标对象的方法</span>        proxyInstance.teach();        proxyInstance.sayHello(<span class="string">&quot;George&quot;</span>);    &#125;&#125;</code></pre><blockquote><p>运行结果:</p><pre><code class="highlight shell">proxyInstance=class com.sun.proxy.$Proxy0JDK代理开始~ 老师授课中  。。。。。JDK代理提交~JDK代理开始~hello GeorgeJDK代理提交~</code></pre></blockquote><h1 id="四、Cglib-代理"><a href="#四、Cglib-代理" class="headerlink" title="四、Cglib 代理"></a>四、Cglib 代理</h1><h2 id="1-基本介绍-2"><a href="#1-基本介绍-2" class="headerlink" title="1. 基本介绍"></a>1. 基本介绍</h2><ul><li>静态代理和 JDK 代理模式都要求目标对象是实现一个接口,但是有时候目标对象只是一个单独的对象,并没有实 现任何的接口,这个时候可使用目标对象子类来实现代理-这就是 <strong>Cglib 代理</strong></li><li>Cglib代理也叫作子类代理,它是在内存中构建一个子类对象从而实现对目标对象功能扩展,  有些书也将Cglib代 理归属到动态代理。</li><li>Cglib 是一个强大的高性能的代码生成包,它可以在运行期扩展java 类与实现java 接口.它广泛的被许多 AOP 的 框架使用,例如 Spring AOP ，实现方法拦截</li><li>在 AOP 编程中如何选择代理模式：<ul><li>目标对象需要实现接口，用 JDK 代理</li><li>目标对象不需要实现接口，用 Cglib 代理</li></ul></li><li>Cglib 包的底层是通过使用字节码处理框架 ASM 来转换字节码并生成新的类</li></ul><h2 id="2-Cglib-代理模式实现步骤"><a href="#2-Cglib-代理模式实现步骤" class="headerlink" title="2. Cglib 代理模式实现步骤"></a>2. Cglib 代理模式实现步骤</h2><ul><li>需要引入 cglib 的jar 文件<ul><li>asm.jar</li><li>asm-commons.jar</li><li>asm-tree.jar</li><li>cglib-2.2.jar</li></ul></li><li>在内存中动态构建子类，注意<strong>代理的类不能为final</strong> ，否则报错 : java.lang.IllegalArgumentException:</li><li>目标对象的方法<strong>如果为 final&#x2F;static,那么就不会被拦截</strong>, 即不会执行目标对象额外的业务方法.</li></ul><h2 id="3-Cglib-代理模式应用实例"><a href="#3-Cglib-代理模式应用实例" class="headerlink" title="3. Cglib 代理模式应用实例"></a>3. Cglib 代理模式应用实例</h2><p><strong>应用实例要求</strong></p><p>将前面的案例用 Cglib 代理模式实现</p><p><strong>思路图解(类图)</strong></p><p><img src="https://raw.githubusercontent.com/GeorgeChan95/blogimg/master/img/2024/11/22/20241122-002025.png" alt="Cglib 代理UML图"></p><p><strong>代码实现</strong></p><pre><code class="highlight java"><span class="comment">// 目标代理的对象</span><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">TeacherDao</span> &#123;    <span class="keyword">public</span> String <span class="title function_">teach</span><span class="params">()</span> &#123;        System.out.println(<span class="string">&quot; 老师授课中  ， 我是cglib代理，不需要实现接口 &quot;</span>);        <span class="keyword">return</span> <span class="string">&quot;hello&quot;</span>;    &#125;&#125;<span class="comment">// Cglib代理类</span><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ProxyFactory</span> <span class="keyword">implements</span> <span class="title class_">MethodInterceptor</span> &#123;    <span class="keyword">private</span> TeacherDao target;    <span class="keyword">public</span> <span class="title function_">ProxyFactory</span><span class="params">(TeacherDao target)</span> &#123;        <span class="built_in">this</span>.target = target;    &#125;    <span class="comment">//返回一个代理对象:  是 target 对象的代理对象</span>    <span class="keyword">public</span> Object <span class="title function_">getProxyInstance</span><span class="params">()</span> &#123;        <span class="comment">// 创建一个工具类</span>        <span class="type">Enhancer</span> <span class="variable">enhancer</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Enhancer</span>();        <span class="comment">// 设置父类</span>        enhancer.setSuperclass(target.getClass());        <span class="comment">// 设置回调函数</span>        enhancer.setCallback(<span class="built_in">this</span>);        <span class="comment">//4. 创建子类对象，即代理对象</span>        <span class="keyword">return</span> enhancer.create();    &#125;    <span class="comment">//重写  intercept 方法，会调用目标对象的方法</span>    <span class="meta">@Override</span>    <span class="keyword">public</span> Object <span class="title function_">intercept</span><span class="params">(Object o, Method method, Object[] args, MethodProxy methodProxy)</span> <span class="keyword">throws</span> Throwable &#123;        System.out.println(<span class="string">&quot;Cglib代理模式 ~~ 开始&quot;</span>);        <span class="type">Object</span> <span class="variable">resultVal</span> <span class="operator">=</span> method.invoke(target, args);        System.out.println(<span class="string">&quot;Cglib代理模式 ~~ 提交&quot;</span>);        <span class="keyword">return</span> resultVal;    &#125;&#125;<span class="comment">// 测试类</span><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Client</span> &#123;    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;        <span class="type">TeacherDao</span> <span class="variable">target</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">TeacherDao</span>();        <span class="type">TeacherDao</span> <span class="variable">proxyInstance</span> <span class="operator">=</span> (TeacherDao) <span class="keyword">new</span> <span class="title class_">ProxyFactory</span>(target).getProxyInstance();        proxyInstance.teach();    &#125;&#125;</code></pre><blockquote><p>运行结果:</p><pre><code class="highlight shell">Cglib代理模式 ~~ 开始 老师授课中  ， 我是cglib代理，不需要实现接口 Cglib代理模式 ~~ 提交</code></pre></blockquote><h1 id="五、几种常见的代理模式介绍—-几种变体"><a href="#五、几种常见的代理模式介绍—-几种变体" class="headerlink" title="五、几种常见的代理模式介绍— 几种变体"></a>五、几种常见的代理模式介绍— 几种变体</h1><ul><li><p>防火墙代理</p><p>内网通过代理穿透防火墙，实现对公网的访问。</p></li><li><p>缓存代理</p><p>比如：当请求图片文件等资源时，先到缓存代理取，如果取到资源则 ok,如果取不到资源，再到公网或者数据 库取，然后缓存.</p></li><li><p>远程代理</p><p>远程对象的本地代表，通过它可以把远程对象当本地对象来调用。远程代理通过网络和真正的远程对象沟通信息。</p></li><li><p>同步代理</p><p>主要使用在多线程编程中，完成多线程间同步工作.</p></li></ul>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;一、代理模式的基本介绍&quot;&gt;&lt;a href=&quot;#一、代理模式的基本介绍&quot; class=&quot;headerlink&quot; title=&quot;一、代理模式的基本介绍&quot;&gt;&lt;/a&gt;一、代理模式的基本介绍&lt;/h1&gt;&lt;ul&gt;
&lt;li&gt;&lt;p&gt;代理模式：为一个对象提供一个替身，以控制对这个对象</summary>
      
    
    
    
    <category term="设计模式" scheme="https://georgechan95.github.io/categories/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"/>
    
    
    <category term="设计模式" scheme="https://georgechan95.github.io/tags/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"/>
    
  </entry>
  
  <entry>
    <title>13-享元模式</title>
    <link href="https://georgechan95.github.io/blog/1b225c1f.html"/>
    <id>https://georgechan95.github.io/blog/1b225c1f.html</id>
    <published>2024-11-20T15:10:00.000Z</published>
    <updated>2024-11-20T13:28:40.844Z</updated>
    
    <content type="html"><![CDATA[<h1 id="一、展示网站项目需求"><a href="#一、展示网站项目需求" class="headerlink" title="一、展示网站项目需求"></a>一、展示网站项目需求</h1><p>当前假设有一个项目，给客户 A 做一个产品展示网站，客户 A 的朋友感觉效果不错，也希望做这样的产品展示网站，但是要求都有些不同：</p><ul><li>有客户要求以新闻的形式发布</li><li>有客户人要求以博客的形式发布</li><li>有客户希望以微信公众号的形式发布</li></ul><p><strong>传统方案解决网站展现项目</strong></p><ul><li>直接复制粘贴一份，然后根据客户不同要求，进行定制修改</li><li>给每个网站租用一个空间</li><li>方案设计示意图</li></ul><p><img src="https://raw.githubusercontent.com/GeorgeChan95/blogimg/master/img/2024/11/20/20241120-205250.png" alt="传统方式"></p><p>传统方案解决网站展现项目存在以下问题：</p><ul><li>需要的网站结构相似度很高，而且都不是高问量网站，如果分成多个虚拟空间来处理，相当于一个相同网站的实例对象很多，造成服务器的资源浪费。</li><li>解决思路：整合到一个网站中，共享其相关的代码和数据，对于硬盘、内存、CPU、数据库空间等服务器资源都可以达成共享，减少服务器资源。</li><li>对于代码来说，由于是一份实例，维护和扩展都更加容易。</li><li>上面的解决思路就可以使用 <strong>享元模式</strong> 来解决。</li></ul><h1 id="二、享元模式基本介绍"><a href="#二、享元模式基本介绍" class="headerlink" title="二、享元模式基本介绍"></a>二、享元模式基本介绍</h1><ul><li>享元模式（Flyweight Pattern）也叫蝇量模式：运用共享技术有效地支持大量细粒度的对象。</li><li>常用于系统底层开发，解决系统的性能问题。像数据库连接池，里面都是创建好的连接对象，在这些连接对象 中有我们需要的则直接拿来用，避免重新创建，如果没有我们需要的，则创建一个。</li><li>享元模式能够解决重复对象的内存浪费的问题，当系统中有大量相似对象，需要缓冲池时。不需总是创建新对 象，可以从缓冲池里拿。这样可以降低系统内存，同时提高效率。</li><li>享元模式经典的应用场景就是池技术了，String 常量池、数据库连接池、缓冲池等等都是享元模式的应用，享元模式是池技术的重要实现方式。</li></ul><h1 id="三、享元模式的原理类图"><a href="#三、享元模式的原理类图" class="headerlink" title="三、享元模式的原理类图"></a>三、享元模式的原理类图</h1><p><img src="https://raw.githubusercontent.com/GeorgeChan95/blogimg/master/img/2024/11/20/20241120-205914.png" alt="享元模式原理图"></p><p><strong>对类图的说明</strong></p><p>对原理图的说明-即(模式的角色及职责)</p><ul><li>FlyWeight：是抽象的享元角色,  他是产品的抽象类,   同时定义出对象的<strong>外部状态</strong>和<strong>内部状态</strong>(后面介绍)   的接口或实现</li><li>ConcreteFlyweight：具体的享元角色，是具体的产品类，实现抽象角色定义的相关业务.</li><li>UnsharedConcreteFlyweight：不可共享的角色，一般不会出现在享元工厂中.</li><li>FlyweightFactory：享元工厂类，用于构建一个池容器（集合），同时提供从池中获取对象的方法</li></ul><h1 id="四、内部状态和外部状态"><a href="#四、内部状态和外部状态" class="headerlink" title="四、内部状态和外部状态"></a>四、内部状态和外部状态</h1><p>比如围棋、五子棋、跳棋，它们都有大量的棋子对象，围棋和五子棋只有黑白两色，跳棋颜色多一点。所以棋子颜色就是棋子的内部状态；而各个棋子之间的差别就是位置的不同。当我们落子后，落子颜色是定的，但位置是变化的，所以棋子坐标就是棋子的外部状态</p><ul><li>享元模式提出了两个要求：<strong>细粒度</strong> 和 <strong>共享对象</strong>。即将对象的信息分为两个部分：<strong>内部状态</strong> 和 <strong>外部状态</strong></li><li><strong>内部状态</strong>：指对象共享出来的信息，存储在享元对象内部且不会随环境的改变而改变。</li><li><strong>外部状态</strong>：指对象得以依赖的一个标记，是随环境改变而改变的、不可共享的状态。</li></ul><p>举个例子：围模理论上有 361 个空位可以放棋子，每盘棋都有可能有两三百个棋子对象产生。因为内存空间有限，一台服务器很难支持更多的玩家玩围模游戏。如果用享元模式来处理棋子，那么棋子对象就可以减少到只有两个实例，这样就很好的解决了对象的开销问题</p><h1 id="五、享元模式解决网站展现项目"><a href="#五、享元模式解决网站展现项目" class="headerlink" title="五、享元模式解决网站展现项目"></a>五、享元模式解决网站展现项目</h1><p><strong>原理类图</strong></p><p><img src="https://raw.githubusercontent.com/GeorgeChan95/blogimg/master/img/2024/11/20/20241120-210641.png" alt="享元模式"></p><p><strong>UML 类图</strong></p><p><img src="https://raw.githubusercontent.com/GeorgeChan95/blogimg/master/img/2024/11/20/20241120-210648.png" alt="img"></p><p><strong>代码如下：</strong></p><pre><code class="highlight java"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">User</span> &#123;    <span class="keyword">private</span> String name;    <span class="comment">// 省略 get/set 构造方法</span>&#125;<span class="comment">// 抽象的享元对象</span><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">class</span> <span class="title class_">WebSite</span> &#123;    <span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">void</span> <span class="title function_">use</span><span class="params">(User user)</span>;&#125;<span class="comment">// 具体的享元角色</span><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ConcreteWebSite</span> <span class="keyword">extends</span> <span class="title class_">WebSite</span> &#123;    <span class="comment">// 网站类型，享元模式中的内部状态</span>    <span class="keyword">private</span> String type;    <span class="keyword">public</span> <span class="title function_">ConcreteWebSite</span><span class="params">(String type)</span> &#123;        <span class="built_in">this</span>.type = type;    &#125;    <span class="meta">@Override</span>    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">use</span><span class="params">(User user)</span> &#123;        System.out.println(<span class="string">&quot;网站的发布形式为:&quot;</span> + type + <span class="string">&quot; 在使用中 .. 使用者是&quot;</span> + user.getName());    &#125;&#125;<span class="comment">// 享元工厂</span><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">WebSiteFactory</span> &#123;    <span class="comment">// 共享数据池</span>    <span class="keyword">private</span> Map&lt;String, WebSite&gt; pool = <span class="keyword">new</span> <span class="title class_">HashMap</span>&lt;&gt;();    <span class="comment">// 根据网站的类型，返回一个网站, 如果没有就创建一个网站，并放入到池中,并返回</span>    <span class="keyword">public</span> WebSite <span class="title function_">getWebSiteCategory</span><span class="params">(String type)</span> &#123;        <span class="keyword">if</span> (!pool.containsKey(type)) &#123;            <span class="comment">// 创建一个网站，并放入到池中</span>            pool.put(type, <span class="keyword">new</span> <span class="title class_">ConcreteWebSite</span>(type));        &#125;        <span class="keyword">return</span> pool.get(type);    &#125;    <span class="comment">// 获取网站分类的总数 (池中有多少个网站类型)</span>    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">getWebSiteCount</span><span class="params">()</span> &#123;        <span class="keyword">return</span> pool.size();    &#125;&#125;<span class="comment">// 测试类</span><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Client</span> &#123;    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;        <span class="type">WebSiteFactory</span> <span class="variable">factory</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">WebSiteFactory</span>();        <span class="comment">// 新闻形式的网站</span>        <span class="type">WebSite</span> <span class="variable">webSite1</span> <span class="operator">=</span> factory.getWebSiteCategory(<span class="string">&quot;新闻&quot;</span>);        webSite1.use(<span class="keyword">new</span> <span class="title class_">User</span>(<span class="string">&quot;Tom&quot;</span>));        <span class="comment">// 博客形式的网站</span>        <span class="type">WebSite</span> <span class="variable">webSite2</span> <span class="operator">=</span> factory.getWebSiteCategory(<span class="string">&quot;博客&quot;</span>);        webSite2.use(<span class="keyword">new</span> <span class="title class_">User</span>(<span class="string">&quot;Jack&quot;</span>));        <span class="type">int</span> <span class="variable">webSiteCount</span> <span class="operator">=</span> factory.getWebSiteCount();        System.out.println(<span class="string">&quot;网站分类数：&quot;</span> + webSiteCount);    &#125;&#125;</code></pre><blockquote><p>运行结果：</p><pre><code class="highlight shell">网站的发布形式为:新闻 在使用中 .. 使用者是Tom网站的发布形式为:博客 在使用中 .. 使用者是Jack网站分类数：2</code></pre></blockquote><h1 id="六、享元模式在JDK源码中的应用-Integer类"><a href="#六、享元模式在JDK源码中的应用-Integer类" class="headerlink" title="六、享元模式在JDK源码中的应用-Integer类"></a>六、享元模式在JDK源码中的应用-Integer类</h1><p>首先先看一段代码测试</p><pre><code class="highlight java"><span class="type">Integer</span> <span class="variable">x</span> <span class="operator">=</span> Integer.valueOf(<span class="number">127</span>);<span class="type">Integer</span> <span class="variable">y</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Integer</span>(<span class="number">127</span>);<span class="type">Integer</span> <span class="variable">z</span> <span class="operator">=</span> Integer.valueOf(<span class="number">127</span>);<span class="type">Integer</span> <span class="variable">w</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Integer</span>(<span class="number">127</span>);System.out.println(x.equals(y)); <span class="comment">// true</span>System.out.println(x == y);      <span class="comment">// false</span>System.out.println(x == z);      <span class="comment">// true</span>System.out.println(w == x);      <span class="comment">// false</span>System.out.println(w == y);      <span class="comment">// false</span></code></pre><p>我们知道：<code>equals</code>比较的是对象的内容，<code>==</code>比较的是对象的实例</p><ul><li><p><code>x.equals(y)</code>结果为<code>true</code>：比较的是大小，所以结果为<code>true</code></p></li><li><p><code>x == y</code>、<code>w == x</code>、<code>w == y</code>结果为<code>false</code>：由于 y 是 new 出来的，所以结果为<code>false</code></p></li><li><p><code>x == z</code>结果为<code>true</code>：<strong>这是为什么呢？？？</strong></p></li></ul><p>我们追踪一下<code>Integer</code>对象的<code>valueOf</code>方法，看一下源码</p><pre><code class="highlight java"><span class="keyword">public</span> <span class="keyword">static</span> Integer <span class="title function_">valueOf</span><span class="params">(<span class="type">int</span> i)</span> &#123;    <span class="keyword">if</span> (i &gt;= IntegerCache.low &amp;&amp; i &lt;= IntegerCache.high)        <span class="keyword">return</span> IntegerCache.cache[i + (-IntegerCache.low)];    <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">Integer</span>(i);&#125;</code></pre><p>这里的<code>low</code>和<code>high</code>是多少呢？</p><pre><code class="highlight java"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">class</span> <span class="title class_">IntegerCache</span> &#123;    <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">int</span> <span class="variable">low</span> <span class="operator">=</span> -<span class="number">128</span>;    <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">int</span> high;    <span class="keyword">static</span> <span class="keyword">final</span> Integer cache[];    <span class="keyword">static</span> &#123;        <span class="comment">// high value may be configured by property</span>        <span class="type">int</span> <span class="variable">h</span> <span class="operator">=</span> <span class="number">127</span>;        <span class="type">String</span> <span class="variable">integerCacheHighPropValue</span> <span class="operator">=</span>            sun.misc.VM.getSavedProperty(<span class="string">&quot;java.lang.Integer.IntegerCache.high&quot;</span>);        <span class="keyword">if</span> (integerCacheHighPropValue != <span class="literal">null</span>) &#123;            <span class="keyword">try</span> &#123;                <span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> parseInt(integerCacheHighPropValue);                i = Math.max(i, <span class="number">127</span>);                <span class="comment">// Maximum array size is Integer.MAX_VALUE</span>                h = Math.min(i, Integer.MAX_VALUE - (-low) -<span class="number">1</span>);            &#125; <span class="keyword">catch</span>( NumberFormatException nfe) &#123;                <span class="comment">// If the property cannot be parsed into an int, ignore it.</span>            &#125;        &#125;        high = h;        cache = <span class="keyword">new</span> <span class="title class_">Integer</span>[(high - low) + <span class="number">1</span>];        <span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> low;        <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">k</span> <span class="operator">=</span> <span class="number">0</span>; k &lt; cache.length; k++)            cache[k] = <span class="keyword">new</span> <span class="title class_">Integer</span>(j++);        <span class="comment">// range [-128, 127] must be interned (JLS7 5.1.7)</span>        <span class="keyword">assert</span> IntegerCache.high &gt;= <span class="number">127</span>;    &#125;    <span class="keyword">private</span> <span class="title function_">IntegerCache</span><span class="params">()</span> &#123;&#125;&#125;</code></pre><p>我们通过<code>IntegerCache</code>中源码大概基本分析出</p><ul><li><p><code>low</code>为<code>-128</code></p></li><li><p><code>high</code>为<code>127</code></p></li></ul><p>所以当<code>Integer</code>在<code>[-128, 127]</code>时，会返回<code>IntegerCache</code>的<code>cache[]</code>数组内容；否则，<code>valueOf</code>方法相当于<code>new Integer</code>了。也就是说，<code>Integer.valueOf(x)</code>方法使用的就是<strong>享元模式</strong>。</p><p>另外，我们也可以分析出：</p><ul><li>当数值范围在<code>[-128, 127]</code>时，使用<code>valueOf</code>方法执行速度比<code>new</code>更快</li></ul><h1 id="七、享元模式的注意事项和细节"><a href="#七、享元模式的注意事项和细节" class="headerlink" title="七、享元模式的注意事项和细节"></a>七、享元模式的注意事项和细节</h1><ul><li>在享元模式这样理解，“享”就表示共享，“元”表示对象</li><li>系统中有大量对象，这些对象消耗大量内存，并且对象的状态大部分可以外部化时，我们就可以考虑选用享元模式</li><li>用唯一标识码判断，如果在内存中有，则返回这个唯一标识码所标识的对象，用 HashMap&#x2F;HashTable 存储</li><li>享元模式大大减少了对象的创建，降低了程序内存的占用，提高效率</li><li>享元模式提高了系统的复杂度，需要分离出内部状态和外部状态。而内部状态具有固化特性，不应该随着外部状态的改变而改变，这是我们使用享元模式需要注意的地方</li><li>使用享元模式时，注意划分内部状态和外部状态，并且需要有一个工厂类加以控制</li><li>享元模式经典的应用场景是需要缓冲池的场景，比如 String 常量池、数据库连接池</li></ul>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;一、展示网站项目需求&quot;&gt;&lt;a href=&quot;#一、展示网站项目需求&quot; class=&quot;headerlink&quot; title=&quot;一、展示网站项目需求&quot;&gt;&lt;/a&gt;一、展示网站项目需求&lt;/h1&gt;&lt;p&gt;当前假设有一个项目，给客户 A 做一个产品展示网站，客户 A 的朋友感觉效果</summary>
      
    
    
    
    <category term="设计模式" scheme="https://georgechan95.github.io/categories/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"/>
    
    
    <category term="设计模式" scheme="https://georgechan95.github.io/tags/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"/>
    
  </entry>
  
  <entry>
    <title>12-外观模式</title>
    <link href="https://georgechan95.github.io/blog/906e9e8b.html"/>
    <id>https://georgechan95.github.io/blog/906e9e8b.html</id>
    <published>2024-11-20T14:09:00.000Z</published>
    <updated>2024-11-20T12:34:56.315Z</updated>
    
    <content type="html"><![CDATA[<h1 id="一、外观模式的定义"><a href="#一、外观模式的定义" class="headerlink" title="一、外观模式的定义"></a>一、外观模式的定义</h1><p>外观（Facade）模式的定义：又叫门面模式，是一种通过为多个复杂的子系统提供一个一致的接口，而使这些子系统更加容易被访问的模式。该模式对外有一个统一接口，外部应用程序不用关心内部子系统的具体的细节，这样会大大降低应用程序的复杂度，提高了程序的可维护性。</p><h1 id="二、外观模式优缺点"><a href="#二、外观模式优缺点" class="headerlink" title="二、外观模式优缺点"></a>二、外观模式优缺点</h1><p><strong>优点：</strong></p><ul><li>简化了调用过程，无需了解深入子系统，防止带来风险</li><li>减少系统依赖、松散耦合</li><li>更好的划分访问层次</li><li>符合迪米特法则，即最少知道原则</li></ul><p><strong>缺点：</strong></p><ul><li>增加子系统、扩展子系统行为容易引入风险</li><li>不符合开闭原则</li></ul><h1 id="三、外观模式的实现"><a href="#三、外观模式的实现" class="headerlink" title="三、外观模式的实现"></a>三、外观模式的实现</h1><p>外观（Facade）模式的结构比较简单，主要是定义了一个高层接口。它包含了对各个子系统的引用，客户端可以通过它访问各个子系统的功能。现在来分析其基本结构和实现方法。</p><p>外观（Facade）模式包含以下主要角色。</p><ul><li>外观（Facade）角色：为多个子系统对外提供一个共同的接口。</li><li>子系统（Sub System）角色：实现系统的部分功能，客户可以通过外观角色访问它。</li><li>客户（Client）角色：通过一个外观角色访问各个子系统的功能。</li></ul><p>其结构图如图所示:</p><img src="https://raw.githubusercontent.com/GeorgeChan95/blogimg/master/img/2024/11/20/20241120-195658.png" alt="外观模式结构图" style="zoom:50%;" /><p>代码常见有两种情况都是属于外观模式，如下代码：</p><p><strong>所有子系统实现统一接口</strong></p><pre><code class="highlight java"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">MySystem</span> &#123;    <span class="keyword">void</span> <span class="title function_">dosomething</span><span class="params">()</span>;&#125;<span class="comment">// 子系统A</span><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">SubSystemA</span> <span class="keyword">implements</span> <span class="title class_">MySystem</span> &#123;    <span class="meta">@Override</span>    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">dosomething</span><span class="params">()</span> &#123;        System.out.println(<span class="string">&quot;子系统方法A&quot;</span>);    &#125;&#125;<span class="comment">// 子系统B</span><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">SubSystemB</span> <span class="keyword">implements</span> <span class="title class_">MySystem</span> &#123;    <span class="meta">@Override</span>    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">dosomething</span><span class="params">()</span> &#123;        System.out.println(<span class="string">&quot;子系统方法B &quot;</span>);    &#125;&#125;<span class="comment">// 外观类</span><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Facade</span> &#123;    <span class="keyword">private</span> SubSystemA systemA;    <span class="keyword">private</span> SubSystemB systemB;    <span class="keyword">public</span> <span class="title function_">Facade</span><span class="params">()</span> &#123;        <span class="built_in">this</span>.systemA = <span class="keyword">new</span> <span class="title class_">SubSystemA</span>();        <span class="built_in">this</span>.systemB = <span class="keyword">new</span> <span class="title class_">SubSystemB</span>();    &#125;    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">methodA</span><span class="params">()</span> &#123;        systemA.dosomething();    &#125;    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">methodB</span><span class="params">()</span> &#123;        systemB.dosomething();    &#125;&#125;<span class="comment">// 测试类</span><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Client</span> &#123;    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;        <span class="type">Facade</span> <span class="variable">facade</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Facade</span>();        facade.methodA();        facade.methodB();    &#125;&#125;</code></pre><blockquote><p>运行结果：</p><pre><code class="highlight shell">子系统方法A子系统方法B</code></pre></blockquote><p><strong>所有子系统未实现统一接口</strong></p><pre><code class="highlight java"><span class="comment">// 子系统A</span><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">SubSystemA</span> &#123;    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">dosomething</span><span class="params">()</span> &#123;        System.out.println(<span class="string">&quot;子系统方法AA&quot;</span>);    &#125;&#125;<span class="comment">// 子系统B</span><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">SubSystemB</span> &#123;    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">dosomething</span><span class="params">()</span> &#123;        System.out.println(<span class="string">&quot;子系统方法BB &quot;</span>);    &#125;&#125;<span class="comment">// 外观类</span><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Facade</span> &#123;    <span class="keyword">private</span> SubSystemA systemA;    <span class="keyword">private</span> SubSystemB systemB;    <span class="keyword">public</span> <span class="title function_">Facade</span><span class="params">()</span> &#123;        <span class="built_in">this</span>.systemA = <span class="keyword">new</span> <span class="title class_">SubSystemA</span>();        <span class="built_in">this</span>.systemB = <span class="keyword">new</span> <span class="title class_">SubSystemB</span>();    &#125;    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">methodA</span><span class="params">()</span> &#123;        <span class="built_in">this</span>.systemA.dosomething();    &#125;    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">methodB</span><span class="params">()</span> &#123;        <span class="built_in">this</span>.systemB.dosomething();    &#125;&#125;<span class="comment">// 测试类</span><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Client</span> &#123;    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;        <span class="type">Facade</span> <span class="variable">facade</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Facade</span>();        facade.methodA();        facade.methodB();    &#125;&#125;</code></pre><blockquote><p>运行结果：</p><pre><code class="highlight shell">子系统方法AA子系统方法BB</code></pre></blockquote><h1 id="四、外观模式的应用场景"><a href="#四、外观模式的应用场景" class="headerlink" title="四、外观模式的应用场景"></a>四、外观模式的应用场景</h1><p>通常在以下情况下可以考虑使用外观模式。</p><ul><li>子系统越来越复杂，增加外观模式提供简单接口调用</li><li>构建多层系统结构，利用外观对象作为每层的入口，简化层间调用</li></ul><h1 id="五、外观模式的扩展"><a href="#五、外观模式的扩展" class="headerlink" title="五、外观模式的扩展"></a>五、外观模式的扩展</h1><p>在外观模式中，当增加或移除子系统时需要修改外观类，这违背了“开闭原则”。如果引入抽象外观类，则在一定程度上解决了该问题，其结构图如图所示：</p><img src="https://raw.githubusercontent.com/GeorgeChan95/blogimg/master/img/2024/11/20/20241120-201927.png" alt="引入抽象外观类" style="zoom:50%;" /><p>代码如下：</p><pre><code class="highlight java"><span class="comment">// 抽象外观类</span><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">Facade</span> &#123;    <span class="keyword">void</span> <span class="title function_">method</span><span class="params">()</span>;&#125;<span class="comment">// 具体外观类A</span><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">FacadeImplA</span> <span class="keyword">implements</span> <span class="title class_">Facade</span> &#123;    <span class="type">SubSystem1</span> <span class="variable">subSystem1</span> <span class="operator">=</span> <span class="literal">null</span>;    <span class="type">SubSystem2</span> <span class="variable">subSystem2</span> <span class="operator">=</span> <span class="literal">null</span>;    <span class="type">SubSystem3</span> <span class="variable">subSystem3</span> <span class="operator">=</span> <span class="literal">null</span>;    <span class="keyword">public</span> <span class="title function_">FacadeImplA</span><span class="params">()</span> &#123;        subSystem1 = <span class="keyword">new</span> <span class="title class_">SubSystem1</span>();        subSystem2 = <span class="keyword">new</span> <span class="title class_">SubSystem2</span>();        subSystem3 = <span class="keyword">new</span> <span class="title class_">SubSystem3</span>();    &#125;    <span class="meta">@Override</span>    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">method</span><span class="params">()</span> &#123;        subSystem1.method1();        subSystem2.method2();        subSystem3.method3();    &#125;&#125;<span class="comment">// 具体外观类B</span><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">FacadeImplB</span> <span class="keyword">implements</span> <span class="title class_">Facade</span> &#123;    <span class="type">SubSystem2</span> <span class="variable">subSystem2</span> <span class="operator">=</span> <span class="literal">null</span>;    <span class="type">SubSystem3</span> <span class="variable">subSystem3</span> <span class="operator">=</span> <span class="literal">null</span>;    <span class="type">SubSystem4</span> <span class="variable">subSystem4</span> <span class="operator">=</span> <span class="literal">null</span>;    <span class="keyword">public</span> <span class="title function_">FacadeImplB</span><span class="params">()</span> &#123;        subSystem2 = <span class="keyword">new</span> <span class="title class_">SubSystem2</span>();        subSystem3 = <span class="keyword">new</span> <span class="title class_">SubSystem3</span>();        subSystem4 = <span class="keyword">new</span> <span class="title class_">SubSystem4</span>();    &#125;    <span class="meta">@Override</span>    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">method</span><span class="params">()</span> &#123;        subSystem2.method2();        subSystem3.method3();        subSystem4.method4();    &#125;&#125;<span class="comment">// 子系统类1</span><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">SubSystem1</span> &#123;    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">method1</span><span class="params">()</span> &#123;        System.out.println(<span class="string">&quot;子系统1的method1()被调用！&quot;</span>);    &#125;&#125;<span class="comment">// 子系统类2</span><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">SubSystem2</span> &#123;    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">method2</span><span class="params">()</span> &#123;        System.out.println(<span class="string">&quot;子系统2的method2()被调用！&quot;</span>);    &#125;&#125;<span class="comment">// 子系统类3</span><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">SubSystem3</span> &#123;    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">method3</span><span class="params">()</span> &#123;        System.out.println(<span class="string">&quot;子系统3的method3()被调用！&quot;</span>);    &#125;&#125;<span class="comment">// 子系统类4</span><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">SubSystem4</span> &#123;    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">method4</span><span class="params">()</span> &#123;        System.out.println(<span class="string">&quot;子系统4的method4()被调用！&quot;</span>);    &#125;&#125;<span class="comment">// 测试类</span><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Client</span> &#123;    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;        <span class="type">Facade</span> <span class="variable">facade1</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">FacadeImplA</span>();        facade1.method();        <span class="type">Facade</span> <span class="variable">facade2</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">FacadeImplB</span>();        facade2.method();    &#125;&#125;</code></pre><blockquote><p>运行结果：</p><pre><code class="highlight shell">子系统1的method1()被调用！子系统2的method2()被调用！子系统3的method3()被调用！子系统2的method2()被调用！子系统3的method3()被调用！子系统4的method4()被调用！</code></pre></blockquote><h1 id="六、外观模式的注意事项和细节"><a href="#六、外观模式的注意事项和细节" class="headerlink" title="六、外观模式的注意事项和细节"></a>六、外观模式的注意事项和细节</h1><ul><li>外观模式对外屏蔽了子系统的细节，因此外观模式降低了客户端对子系统使用的复杂性</li><li>外观模式对客户端与子系统的耦合关系 -  解耦，让子系统内部的模块更易维护和扩展</li><li>通过合理的使用外观模式，可以帮我们更好的划分访问的层次</li><li>当系统需要进行分层设计时，可以考虑使用Facade 模式</li><li>在维护一个遗留的大型系统时，可能这个系统已经变得非常难以维护和扩展，此时可以考虑为新系统开发一个 Facade 类，来提供遗留系统的比较清晰简单的接口，让新系统与 Facade 类交互，提高复用性。</li><li>不能过多的或者不合理的使用外观模式，使用外观模式好，还是直接调用模块好。要以让系统有层次，利于维 护为目的。</li></ul>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;一、外观模式的定义&quot;&gt;&lt;a href=&quot;#一、外观模式的定义&quot; class=&quot;headerlink&quot; title=&quot;一、外观模式的定义&quot;&gt;&lt;/a&gt;一、外观模式的定义&lt;/h1&gt;&lt;p&gt;外观（Facade）模式的定义：又叫门面模式，是一种通过为多个复杂的子系统提供一个一</summary>
      
    
    
    
    <category term="设计模式" scheme="https://georgechan95.github.io/categories/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"/>
    
    
    <category term="设计模式" scheme="https://georgechan95.github.io/tags/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"/>
    
  </entry>
  
  <entry>
    <title>11-组合模式</title>
    <link href="https://georgechan95.github.io/blog/c456a66a.html"/>
    <id>https://georgechan95.github.io/blog/c456a66a.html</id>
    <published>2024-11-16T09:00:00.000Z</published>
    <updated>2024-11-20T12:35:57.137Z</updated>
    
    <content type="html"><![CDATA[<h1 id="一、什么是组合模式"><a href="#一、什么是组合模式" class="headerlink" title="一、什么是组合模式?"></a>一、什么是组合模式?</h1><p>组合模式定义了如何将容器对象和叶子对象进行递归组合，使得客户在使用的过程中无须进行区分到底是容器对象还是叶子对象，可以对他们进行一致的处理。</p><p>组合模式通过组合多个对象形成树形结构来表示“整体-部分”的结构层次。</p><p>组合模式对单个对象(叶子对象)和组合对象(组合对象)具有一致性，它将对象组织到树结构中，可以用来描述整体与部分的关系。同时它也模糊了**简单元素(叶子对象)和复杂元素(容器对象)**的概念，使得客户能够像处理简单元素一样来处理复杂元素，从而使客户程序能够与复杂元素的内部结构解耦。</p><p>到底是什么意思呢? 来看看下面的图片:</p><p><img src="https://raw.githubusercontent.com/GeorgeChan95/blogimg/master/img/2024/11/19/20241119-225338.png" alt="组合模式的示例"></p><p>现在有文件夹, 文件夹下可以有文件和文件夹. 这种递归调用, 我们拆分来看, 文件可以看做是叶子节点, 文件夹可以看做是容器. 文件夹容器下还有文件和文件夹. 使用组合模式来实现他们之间的关系.</p><p><strong>组合模式的关键是: 设计一个抽象的组合类, 让它可以代表组合对象和叶子对象。这样的好处是，客户端不需要区分到底是组合对象还是叶子对象了，只需要全部当成组合对象来处理即可。</strong></p><h1 id="二、组合模式的结构和案例"><a href="#二、组合模式的结构和案例" class="headerlink" title="二、组合模式的结构和案例"></a>二、组合模式的结构和案例</h1><h2 id="1-案例一-文件结构"><a href="#1-案例一-文件结构" class="headerlink" title="1. 案例一: 文件结构"></a>1. 案例一: 文件结构</h2><p>下面就来看看如何实现文件结构. 先来看看UML图:</p><p><img src="https://raw.githubusercontent.com/GeorgeChan95/blogimg/master/img/2024/11/19/20241119-201713.png" alt="组合模式-文件结构"></p><p>首先定义一个抽象类 <code>File</code>, 然后单个的具体文件和文件夹都实现了抽象文件接口, 在文件夹接口里面还有一个存放抽象文件的集合. 实现了文件和文件夹的组合.</p><p><strong>代码实现:</strong></p><pre><code class="highlight java"><span class="comment">// 抽象类</span><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">class</span> <span class="title class_">File</span> &#123;    <span class="keyword">public</span> String name;    <span class="keyword">public</span> <span class="title function_">File</span><span class="params">(String name)</span> &#123;        <span class="built_in">this</span>.name = name;    &#125;    <span class="comment">/**</span><span class="comment">     * 文件打印</span><span class="comment">     */</span>    <span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">void</span> <span class="title function_">show</span><span class="params">()</span>;&#125;<span class="comment">// 文本文件</span><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">TextFile</span> <span class="keyword">extends</span> <span class="title class_">File</span> &#123; <span class="comment">// 继承File</span>    <span class="keyword">public</span> <span class="title function_">TextFile</span><span class="params">(String name)</span> &#123;        <span class="built_in">super</span>(name);    &#125;    <span class="meta">@Override</span>    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">show</span><span class="params">()</span> &#123;        System.out.println(<span class="string">&quot;文本文件展示-----------&quot;</span>);    &#125;&#125;<span class="comment">// 图像文件</span><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ImageFile</span> <span class="keyword">extends</span> <span class="title class_">File</span> &#123; <span class="comment">// 继承File</span>    <span class="keyword">public</span> <span class="title function_">ImageFile</span><span class="params">(String name)</span> &#123;        <span class="built_in">super</span>(name);    &#125;    <span class="meta">@Override</span>    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">show</span><span class="params">()</span> &#123;        System.out.println(<span class="string">&quot;图片文件展示-----------&quot;</span>);    &#125;&#125;<span class="comment">// 音频文件</span><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">AudioFile</span> <span class="keyword">extends</span> <span class="title class_">File</span> &#123; <span class="comment">// 继承File</span>    <span class="keyword">public</span> <span class="title function_">AudioFile</span><span class="params">(String name)</span> &#123;        <span class="built_in">super</span>(name);    &#125;    <span class="meta">@Override</span>    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">show</span><span class="params">()</span> &#123;        System.out.println(<span class="string">&quot;图片文件展示-----------&quot;</span>);    &#125;&#125;<span class="comment">// 视频文件</span><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">VideoFile</span> <span class="keyword">extends</span> <span class="title class_">File</span> &#123; <span class="comment">// 继承File</span>    <span class="keyword">public</span> <span class="title function_">VideoFile</span><span class="params">(String name)</span> &#123;        <span class="built_in">super</span>(name);    &#125;    <span class="meta">@Override</span>    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">show</span><span class="params">()</span> &#123;        System.out.println(<span class="string">&quot;视频文件展示-----------&quot;</span>);    &#125;&#125;<span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Folder</span> <span class="keyword">extends</span> <span class="title class_">File</span> &#123; <span class="comment">// 继承File</span>    <span class="comment">// 组合File</span>    <span class="keyword">private</span> List&lt;File&gt; files = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();    <span class="keyword">public</span> <span class="title function_">Folder</span><span class="params">(String name)</span> &#123;        <span class="built_in">super</span>(name);    &#125;    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">add</span><span class="params">(File file)</span> &#123;        files.add(file);    &#125;    <span class="meta">@Override</span>    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">show</span><span class="params">()</span> &#123; <span class="comment">// 递归调用 show() 方法</span>        System.out.println(<span class="string">&quot;这是 &quot;</span> + <span class="built_in">this</span>.name + <span class="string">&quot; 的show方法&quot;</span>);        <span class="keyword">for</span> (File file : files) &#123;            file.show();        &#125;    &#125;&#125;<span class="comment">// 测试类</span><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">FileClient</span> &#123;    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;        <span class="type">File</span> <span class="variable">textFile1</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">TextFile</span>(<span class="string">&quot;text1文件&quot;</span>);        <span class="type">File</span> <span class="variable">imageFile1</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ImageFile</span>(<span class="string">&quot;image1文件&quot;</span>);        <span class="type">File</span> <span class="variable">audioFile1</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">AudioFile</span>(<span class="string">&quot;audio1文件&quot;</span>);        <span class="type">File</span> <span class="variable">videoFile1</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">VideoFile</span>(<span class="string">&quot;video1文件&quot;</span>);        <span class="type">Folder</span> <span class="variable">folder1</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Folder</span>(<span class="string">&quot;folder1&quot;</span>);        folder1.add(textFile1);        folder1.add(imageFile1);        folder1.add(audioFile1);        folder1.add(videoFile1);        <span class="type">File</span> <span class="variable">textFile2</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">TextFile</span>(<span class="string">&quot;text2文件&quot;</span>);        <span class="type">File</span> <span class="variable">imageFile2</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ImageFile</span>(<span class="string">&quot;image2文件&quot;</span>);        <span class="type">Folder</span> <span class="variable">folder2</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Folder</span>(<span class="string">&quot;folder2&quot;</span>);        folder2.add(textFile2);        folder2.add(imageFile2);        <span class="comment">// 将文件夹2 添加到文件夹1中</span>        folder1.add(folder2);        folder1.show();    &#125;&#125;</code></pre><blockquote><p>运行结果：</p><pre><code class="highlight shell">这是 folder1 的show方法文本文件展示-----------图片文件展示-----------图片文件展示-----------视频文件展示-----------这是 folder2 的show方法文本文件展示-----------图片文件展示-----------</code></pre></blockquote><p>最终展示的文件效果如下：</p><p><img src="https://raw.githubusercontent.com/GeorgeChan95/blogimg/master/img/2024/11/19/20241119-203431.png" alt="文件组合结果示意"></p><h2 id="2-案例二-公司组织架构"><a href="#2-案例二-公司组织架构" class="headerlink" title="2. 案例二: 公司组织架构"></a>2. 案例二: 公司组织架构</h2><p>先来看uml图: </p><p><img src="https://raw.githubusercontent.com/GeorgeChan95/blogimg/master/img/2024/11/19/20241119-203859.png" alt="组合模式-部门"></p><p>这里面通常公司下面会下设很多部门, 部门下面在设置子部门, 其组织架构如下图:</p><p><img src="https://raw.githubusercontent.com/GeorgeChan95/blogimg/master/img/2024/11/19/20241119-204031.png" alt="组织架构图"></p><p><strong>代码实现</strong> </p><pre><code class="highlight java"><span class="comment">// 第一步: 部门抽象接口</span><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">Department</span> &#123;    <span class="comment">// 打印部门信息</span>    <span class="keyword">void</span> <span class="title function_">show</span><span class="params">()</span>;&#125;<span class="comment">// 第二步: 叶子部门, 下面没有其他任何部门</span><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">LeafDepartment</span> <span class="keyword">implements</span> <span class="title class_">Department</span> &#123;    <span class="comment">// 部门名称</span>    <span class="keyword">public</span> String name;    <span class="keyword">public</span> <span class="title function_">LeafDepartment</span><span class="params">(String name)</span> &#123;        <span class="built_in">this</span>.name = name;    &#125;    <span class="meta">@Override</span>    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">show</span><span class="params">()</span> &#123;        System.out.println(<span class="built_in">this</span>.name);    &#125;&#125;<span class="comment">// 第三步: 聚合部门, 也就是下面还有子部门</span><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">AggregateDepartment</span> <span class="keyword">implements</span> <span class="title class_">Department</span> &#123;    <span class="keyword">private</span> String name;    <span class="comment">// 聚合下属部门</span>    List&lt;Department&gt; departmentList = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();    <span class="keyword">public</span> <span class="title function_">AggregateDepartment</span><span class="params">(String name)</span> &#123;        <span class="built_in">this</span>.name = name;    &#125;    <span class="comment">// 添加部门</span>    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">addDepartment</span><span class="params">(Department department)</span> &#123;        departmentList.add(department);    &#125;    <span class="meta">@Override</span>    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">show</span><span class="params">()</span> &#123;        System.out.println(<span class="string">&quot;当前部门为：&quot;</span> + <span class="built_in">this</span>.name + <span class="string">&quot; 下属部门为：&quot;</span>);        <span class="keyword">for</span> (Department department : departmentList) &#123;            department.show();        &#125;    &#125;&#125;<span class="comment">// 第四步: 客户端调用</span><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">DepartmentClient</span> &#123;    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;        <span class="type">AggregateDepartment</span> <span class="variable">company</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">AggregateDepartment</span>(<span class="string">&quot;公司&quot;</span>);        <span class="type">Department</span> <span class="variable">fawu</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">LeafDepartment</span>(<span class="string">&quot;法务部&quot;</span>);        <span class="type">Department</span> <span class="variable">xingzheng</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">LeafDepartment</span>(<span class="string">&quot;行政部&quot;</span>);        <span class="type">Department</span> <span class="variable">renshi</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">LeafDepartment</span>(<span class="string">&quot;人事部&quot;</span>);        <span class="type">AggregateDepartment</span> <span class="variable">jishu</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">AggregateDepartment</span>(<span class="string">&quot;技术部&quot;</span>);        <span class="type">Department</span> <span class="variable">java</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">LeafDepartment</span>(<span class="string">&quot;Java事业部&quot;</span>);        <span class="type">Department</span> <span class="variable">c</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">LeafDepartment</span>(<span class="string">&quot;C++事业部&quot;</span>);        <span class="type">Department</span> <span class="variable">go</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">LeafDepartment</span>(<span class="string">&quot;GO事业部&quot;</span>);        <span class="type">Department</span> <span class="variable">front</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">LeafDepartment</span>(<span class="string">&quot;大前端事业部&quot;</span>);        company.addDepartment(fawu);        company.addDepartment(xingzheng);        company.addDepartment(renshi);        company.addDepartment(jishu);        jishu.addDepartment(java);        jishu.addDepartment(c);        jishu.addDepartment(go);        jishu.addDepartment(front);        company.show();    &#125;&#125;</code></pre><blockquote><p>运行结果：</p><pre><code class="highlight shell">当前部门为：公司 下属部门为：法务部行政部人事部当前部门为：技术部 下属部门为：Java事业部C++事业部GO事业部大前端事业部</code></pre></blockquote><p>通过组合模式, 我们就将一个公司的组织架构画出来了, 即使是更复杂的架构, 使用这种方式也可实现.</p><h1 id="三、组合模式的使用场景"><a href="#三、组合模式的使用场景" class="headerlink" title="三、组合模式的使用场景"></a>三、组合模式的使用场景</h1><p>组合模式在我们日常生活中非常常见, 比如: 公司组织架构中架构关系. 总公司和分公司的关系, 下面分析它适用的以下应用场景。</p><ul><li>在需要表示一个对象整体与部分的层次结构的场合。</li><li>要求对用户隐藏组合对象与单个对象的不同，用户可以用统一的接口使用组合结构中的所有对象的场合。</li></ul><h1 id="四、组合模式的总结"><a href="#四、组合模式的总结" class="headerlink" title="四、组合模式的总结"></a>四、组合模式的总结</h1><ul><li>简化客户端操作。客户端只需要面对一致的对象而不用考虑整体部分或者节点叶子的问题。</li><li>具有较强的扩展性。当我们要更改组合对象时，我们只需要调整内部的层次关系，客户端不用做出任何改动.</li><li>方便创建出复杂的层次结构。客户端不用理会组合里面的组成细节，容易添加节点或者叶子从而创建出复杂的 树形结构</li><li><strong>方便创建出复杂的层次结构。客户端不用理会组合里面的组成细节，容易添加节点或者叶子从而创建出复杂的 树形结构</strong></li><li>要求较高的抽象性，如果节点和叶子有很多差异性的话，比如很多方法和属性都不一样，不适合使用组合模式</li></ul><h1 id="五、组合模式对设计模式六大原则的运用"><a href="#五、组合模式对设计模式六大原则的运用" class="headerlink" title="五、组合模式对设计模式六大原则的运用"></a>五、组合模式对设计模式六大原则的运用</h1><ul><li>单一职责原则: 一个接口只做一件事</li><li>里式替换原则: 父类出现的地方都可以使用子类替换, 这里父类方法都是接口</li><li>接口隔离原则: 最小接口, 不要出现胖接口</li><li>依赖倒置原则: 面向接口编程,而不是面向具体编程</li><li>迪米特法则: 和最少的对象产生关联</li><li>开闭原则: 对修改开放, 对扩展关闭</li></ul>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;一、什么是组合模式&quot;&gt;&lt;a href=&quot;#一、什么是组合模式&quot; class=&quot;headerlink&quot; title=&quot;一、什么是组合模式?&quot;&gt;&lt;/a&gt;一、什么是组合模式?&lt;/h1&gt;&lt;p&gt;组合模式定义了如何将容器对象和叶子对象进行递归组合，使得客户在使用的过程中无须进</summary>
      
    
    
    
    <category term="设计模式" scheme="https://georgechan95.github.io/categories/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"/>
    
    
    <category term="设计模式" scheme="https://georgechan95.github.io/tags/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"/>
    
  </entry>
  
  <entry>
    <title>10-装饰器模式</title>
    <link href="https://georgechan95.github.io/blog/90213fc6.html"/>
    <id>https://georgechan95.github.io/blog/90213fc6.html</id>
    <published>2024-11-16T06:06:00.000Z</published>
    <updated>2024-11-16T08:47:25.665Z</updated>
    
    <content type="html"><![CDATA[<h1 id="一、什么是装饰器模式"><a href="#一、什么是装饰器模式" class="headerlink" title="一、什么是装饰器模式?"></a>一、什么是装饰器模式?</h1><p>我们都知道装饰, 元旦, 圣诞节, 我们都需要装饰, 渲染节日气氛. . 所谓装饰, 就是在原来的基础上加东西.</p><p>装饰器模式（Decorator Pattern）允许向一个现有的对象添加新的功能，同时又不改变其结构。这种类型的设计模式属于结构型模式，它是对现有类的包装。</p><p>这种模式创建了一个装饰类，用来包装原有的类，并在保持类方法签名完整性的前提下，提供了额外的功能。 我们通过下面的实例来演示装饰器模式的用法。其中，我们将把圣诞节的房间在原来的基础上装饰上了气球。</p><p>我们来看看UML图: 最开始有房子, 房子有平房, 楼房, 别墅, 我们会打扫房间.</p><p><img src="https://raw.githubusercontent.com/GeorgeChan95/blogimg/master/img/2024/11/16/20241116-153413.png" alt="装饰者模式-基础类"></p><p>这时, 遇到节假日, 比如:圣诞节, 元旦, 我们会装饰房间, 给房间布置气球等. 我们可以采用装饰器设计模式. 这时, 装饰的主体依然房子. 装饰就像是一个壳子, 套在房子的外面.</p><p><img src="https://raw.githubusercontent.com/GeorgeChan95/blogimg/master/img/2024/11/16/20241116-153654.png" alt="添加装饰"></p><p><strong>代码实现如下：</strong></p><pre><code class="highlight java"><span class="comment">/**</span><span class="comment"> * 房子抽象类</span><span class="comment"> */</span><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">IHouse</span> &#123;    <span class="keyword">void</span> <span class="title function_">clean</span><span class="params">()</span>;&#125;<span class="comment">/**</span><span class="comment"> * 平房</span><span class="comment"> */</span><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Bungalow</span> <span class="keyword">implements</span> <span class="title class_">IHouse</span>&#123;    <span class="meta">@Override</span>    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">clean</span><span class="params">()</span> &#123;        System.out.println(<span class="string">&quot;平房打扫卫生&quot;</span>);    &#125;&#125;<span class="comment">/**</span><span class="comment"> * 楼房</span><span class="comment"> */</span><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">HighRiseBuilding</span> <span class="keyword">implements</span> <span class="title class_">IHouse</span>&#123;    <span class="meta">@Override</span>    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">clean</span><span class="params">()</span> &#123;        System.out.println(<span class="string">&quot;楼房打扫卫生&quot;</span>);    &#125;&#125;<span class="comment">/**</span><span class="comment"> * 别墅</span><span class="comment"> */</span><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Villa</span> <span class="keyword">implements</span> <span class="title class_">IHouse</span> &#123;    <span class="meta">@Override</span>    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">clean</span><span class="params">()</span> &#123;        System.out.println(<span class="string">&quot;别墅打扫卫生&quot;</span>);    &#125;&#125;<span class="comment">/**</span><span class="comment"> * 房间装饰器</span><span class="comment"> */</span><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">class</span> <span class="title class_">DecoratorHouse</span> <span class="keyword">implements</span> <span class="title class_">IHouse</span> &#123;    <span class="keyword">public</span> IHouse decoratedHouse;    <span class="keyword">public</span> <span class="title function_">DecoratorHouse</span><span class="params">(IHouse decoratedHouse)</span> &#123;        <span class="built_in">this</span>.decoratedHouse = decoratedHouse;    &#125;&#125;<span class="comment">/**</span><span class="comment"> * 具体的装饰：气球</span><span class="comment"> */</span><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">BalloonDecoratorHouse</span> <span class="keyword">extends</span> <span class="title class_">DecoratorHouse</span> &#123;    <span class="keyword">public</span> <span class="title function_">BalloonDecoratorHouse</span><span class="params">(IHouse decoratedHouse)</span> &#123;        <span class="built_in">super</span>(decoratedHouse);    &#125;    <span class="meta">@Override</span>    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">clean</span><span class="params">()</span> &#123;        <span class="built_in">super</span>.decoratedHouse.clean();    &#125;    <span class="comment">/**</span><span class="comment">     * 自定义装饰方法</span><span class="comment">     */</span>    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">ballonDecorate</span><span class="params">()</span> &#123;        <span class="comment">// 用气球装饰房间</span>        System.out.println(<span class="string">&quot;用气球装饰房间, 好漂亮&quot;</span>);    &#125;&#125;<span class="comment">/**</span><span class="comment"> * 具体的装饰：圣诞树</span><span class="comment"> */</span><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">TreeDecoratorHouse</span> <span class="keyword">extends</span> <span class="title class_">DecoratorHouse</span>&#123;    <span class="keyword">public</span> <span class="title function_">TreeDecoratorHouse</span><span class="params">(IHouse decoratedHouse)</span> &#123;        <span class="built_in">super</span>(decoratedHouse);    &#125;    <span class="meta">@Override</span>    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">clean</span><span class="params">()</span> &#123;        <span class="built_in">super</span>.decoratedHouse.clean();    &#125;    <span class="comment">/**</span><span class="comment">     * 自定义装饰方法</span><span class="comment">     */</span>    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">treeDecorate</span><span class="params">()</span> &#123;        <span class="comment">// 用圣诞树装饰房间</span>        System.out.println(<span class="string">&quot;用圣诞树装饰房间&quot;</span>);    &#125;&#125;<span class="comment">/**</span><span class="comment"> * 测试类</span><span class="comment"> */</span><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">DecoratorPatternTest</span> &#123;    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;        <span class="comment">// 不使用装饰</span>        <span class="type">IHouse</span> <span class="variable">house</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Villa</span>();        house.clean();        System.out.println(<span class="string">&quot;========================&quot;</span>);        <span class="comment">// 使用装饰: 气球</span>        <span class="type">BalloonDecoratorHouse</span> <span class="variable">decoratorHouse</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">BalloonDecoratorHouse</span>(<span class="keyword">new</span> <span class="title class_">Villa</span>());        decoratorHouse.clean();        decoratorHouse.ballonDecorate();        <span class="comment">// 使用装饰: 圣诞树</span>        <span class="type">TreeDecoratorHouse</span> <span class="variable">treeDecorator</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">TreeDecoratorHouse</span>(<span class="keyword">new</span> <span class="title class_">Villa</span>());        treeDecorator.treeDecorate();    &#125;&#125;</code></pre><blockquote><p>运行结果：</p><pre><code class="highlight shell">别墅打扫卫生========================别墅打扫卫生用气球装饰房间, 好漂亮用圣诞树装饰房间</code></pre></blockquote><p>使用装饰器模式以后, 我们在不改变原有房子的基础上进行了扩展. 节假日, 就可以使用装饰类装饰房间, 如果节日过去了, 我们就继续使用原来的房子.</p><p>接下来, 我们来总结一些上面的案例. </p><ul><li><p>首先, 我们有一个组件Component, 在这个组件里有一些自定义的功能. 通常这个组件Component是抽象的(接口或者抽象类) 然后, 抽象类会有一个具体的实现 ConcreteComponent, 除了实现组件 Component 的方法, 还可自定义方法</p></li><li><p>我们现在想要对具体实现 ConcreteComponent 进行包装, 定义一个包装类 DecoratorComponent. 通常这个包装类是抽象的。</p></li><li><p>包装类也实现组件 Component 接口, 然后引入一个 Component 的具体的成员变量. 为什么要引入成员变量呢? 这个也很好理解, 我们的目标是包装的具体类. </p></li><li><p>定义一个具体的装饰器 DecoratorComponent, 再具体的装饰器中, 可以增加额外的方法. 比如在之前后者之后增加一些逻辑. 具体关系图如下:</p><p><img src="https://raw.githubusercontent.com/GeorgeChan95/blogimg/master/img/2024/11/16/20241116-162312.png" alt="总结"></p></li></ul><p>代码实现如下:</p><pre><code class="highlight java"><span class="comment">/**</span><span class="comment"> * 抽象功能</span><span class="comment"> */</span><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">Component</span> &#123;    <span class="keyword">void</span> <span class="title function_">operate</span><span class="params">()</span>;&#125;<span class="comment">/**</span><span class="comment"> * 具体功能实现</span><span class="comment"> */</span><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ConcreteComponent</span> <span class="keyword">implements</span> <span class="title class_">Component</span>&#123;    <span class="meta">@Override</span>    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">operate</span><span class="params">()</span> &#123;        <span class="comment">// 实现具体的逻辑</span>        System.out.println(<span class="string">&quot;具体实现的逻辑&quot;</span>);    &#125;&#125;<span class="comment">/**</span><span class="comment"> * 用来装饰Component对象的类</span><span class="comment"> */</span><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">class</span> <span class="title class_">DeceratorComponent</span> <span class="keyword">implements</span> <span class="title class_">Component</span> &#123;    <span class="comment">// 指定装饰的对象</span>    <span class="keyword">protected</span> Component deceratedComponent;    <span class="keyword">public</span> <span class="title function_">DeceratorComponent</span><span class="params">(Component deceratedComponent)</span> &#123;        <span class="built_in">this</span>.deceratedComponent = deceratedComponent;    &#125;&#125;<span class="comment">/**</span><span class="comment"> * 具体的装饰类</span><span class="comment"> */</span><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ConcreteDeceratorComponent</span> <span class="keyword">extends</span> <span class="title class_">DeceratorComponent</span> &#123;    <span class="keyword">public</span> <span class="title function_">ConcreteDeceratorComponent</span><span class="params">(Component deceratedComponent)</span> &#123;        <span class="built_in">super</span>(deceratedComponent);    &#125;    <span class="meta">@Override</span>    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">operate</span><span class="params">()</span> &#123;        before();        <span class="built_in">super</span>.deceratedComponent.operate();        after();    &#125;    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">before</span><span class="params">()</span>&#123;        System.out.println(<span class="string">&quot;在原逻辑之前增加了逻辑&quot;</span>);    &#125;    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">after</span><span class="params">()</span>&#123;        System.out.println(<span class="string">&quot;在原逻辑之后增加了逻辑&quot;</span>);    &#125;&#125;<span class="comment">/**</span><span class="comment"> * 测试类</span><span class="comment"> */</span><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">DeceratorTest</span> &#123;    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;        <span class="type">Component</span> <span class="variable">concreteCom</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ConcreteComponent</span>();        concreteCom.operate();        System.out.println(<span class="string">&quot;============&quot;</span>);        <span class="type">DeceratorComponent</span> <span class="variable">decerator</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ConcreteDeceratorComponent</span>(<span class="keyword">new</span> <span class="title class_">ConcreteComponent</span>());        decerator.operate();    &#125;&#125;</code></pre><blockquote><p>运行结果：</p><pre><code class="highlight shell">具体实现的逻辑============在原逻辑之前增加了逻辑具体实现的逻辑在原逻辑之后增加了逻辑</code></pre></blockquote><p>设计模式的灵活应用. 假如当前具体类就只有一个. 我们就不需要定义抽象的Component了. 如何实现装饰模式呢? 那就让装饰器直接继承自原来的类就可以了。</p><p><img src="https://raw.githubusercontent.com/GeorgeChan95/blogimg/master/img/2024/11/16/20241116-163339.png" alt="装饰器模式"></p><h1 id="二、装饰器模式的特点"><a href="#二、装饰器模式的特点" class="headerlink" title="二、装饰器模式的特点"></a>二、装饰器模式的特点</h1><ul><li>装饰对象和真实对象有相同的接口。这样客户端对象就能以和真实对象相同的方式和装饰对象交互。</li><li>装饰对象包含一个真实对象的引用（reference）</li><li>装饰对象接受所有来自客户端的请求。它把这些请求转发给真实的对象。</li><li>装饰对象可以在转发这些请求以前或以后增加一些附加功能。这样就确保了在运行时，不用修改给定对象的结构就可以在外部增加附加的功能。在面向对象的设计中，通常是通过继承来实现对给定类的功能扩展。</li></ul><h1 id="三、装饰器模式的使用场景"><a href="#三、装饰器模式的使用场景" class="headerlink" title="三、装饰器模式的使用场景"></a>三、装饰器模式的使用场景</h1><p>以下情况可以考虑使用装饰器模式</p><ul><li>需要扩展一个类的功能，或给一个类添加附加职责。</li><li>需要动态的给一个对象添加功能，这些功能可以再动态的撤销。</li><li>需要增加由一些基本功能的排列组合而产生的非常大量的功能，从而使继承关系变的不现实。</li><li>当不能采用生成子类的方法进行扩充时。一种情况是，可能有大量独立的扩展，为支持每一种组合将产生大量的子类，使得子类数目呈爆炸性增长。另一种情况可能是因为类定义被隐藏，或类定义不能用于生成子类。</li></ul><h1 id="四、装饰器模式的优点"><a href="#四、装饰器模式的优点" class="headerlink" title="四、装饰器模式的优点"></a>四、装饰器模式的优点</h1><ul><li>Decorator模式与继承关系的目的都是要扩展对象的功能，但是Decorator可以提供比继承更多的灵活性。</li><li>通过使用不同的具体装饰类以及这些装饰类的排列组合，设计师可以创造出很多不同行为的组合。</li></ul><h1 id="五、装饰器模式的缺点"><a href="#五、装饰器模式的缺点" class="headerlink" title="五、装饰器模式的缺点"></a>五、装饰器模式的缺点</h1><ul><li>这种比继承更加灵活机动的特性，也同时意味着更加多的复杂性。</li><li>装饰模式会导致设计中出现许多小类，如果过度使用，会使程序变得很复杂。</li><li>装饰模式是针对抽象组件（Component）类型编程。但是，如果你要针对具体组件编程时，就应该重新思考你的应用架构，以及装饰者是否合适。当然也可以改变Component接口，增加新的公开的行为，实现“半透明”的装饰者模式。在实际项目中要做出最佳选择。</li></ul><h1 id="六、装饰器模式使用了哪些设计模式的原则？"><a href="#六、装饰器模式使用了哪些设计模式的原则？" class="headerlink" title="六、装饰器模式使用了哪些设计模式的原则？"></a>六、装饰器模式使用了哪些设计模式的原则？</h1><ul><li>最明显的体现就是开闭原则—对扩展开发, 对修改关闭. 当新的需求到达, 在不改变原来功能的基础上进行扩展.</li><li>依赖倒置原则—依赖于抽象, 而非具体. 方便扩展, 再来一种新房子, 不用修改房子装饰类.</li><li>单一职责原则: 一个类只负责一件事</li></ul>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;一、什么是装饰器模式&quot;&gt;&lt;a href=&quot;#一、什么是装饰器模式&quot; class=&quot;headerlink&quot; title=&quot;一、什么是装饰器模式?&quot;&gt;&lt;/a&gt;一、什么是装饰器模式?&lt;/h1&gt;&lt;p&gt;我们都知道装饰, 元旦, 圣诞节, 我们都需要装饰, 渲染节日气氛. .</summary>
      
    
    
    
    <category term="设计模式" scheme="https://georgechan95.github.io/categories/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"/>
    
    
    <category term="设计模式" scheme="https://georgechan95.github.io/tags/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"/>
    
  </entry>
  
  <entry>
    <title>09-桥接模式</title>
    <link href="https://georgechan95.github.io/blog/c7419cfa.html"/>
    <id>https://georgechan95.github.io/blog/c7419cfa.html</id>
    <published>2024-11-14T12:51:00.000Z</published>
    <updated>2024-11-16T06:03:46.011Z</updated>
    
    <content type="html"><![CDATA[<h1 id="一、传统方式解决手机操作问题"><a href="#一、传统方式解决手机操作问题" class="headerlink" title="一、传统方式解决手机操作问题"></a>一、传统方式解决手机操作问题</h1><p>现在对不同手机类型的不同品牌实现操作编程（比如：开机、关机、上网，打电话等），如图：</p><p><img src="https://raw.githubusercontent.com/GeorgeChan95/blogimg/master/img/2024/11/16/20241116-120934.png" alt="桥接模式-手机型号"></p><p><strong>UML类图</strong></p><p><img src="https://raw.githubusercontent.com/GeorgeChan95/blogimg/master/img/2024/11/16/20241116-121006.png" alt="桥接模式-UML类图"></p><p><strong>问题分析</strong></p><ul><li><strong>扩展性问题（类爆炸）</strong>：如果我们再增加手机的样式（旋转式），就需要增加各个品牌手机的类；同样如果我们增加一个手机品牌，也要在各个手机样式类下增加</li><li><strong>违反了单一职责原则</strong>，当我们增加手机样式时，要同时增加所有品牌的手机，这样增加了代码维护成本</li></ul><p><strong>解决方案-使用桥接模式</strong></p><h1 id="二、桥接模式-Bridge-基本介绍"><a href="#二、桥接模式-Bridge-基本介绍" class="headerlink" title="二、桥接模式(Bridge)-基本介绍"></a>二、桥接模式(Bridge)-基本介绍</h1><h2 id="1-基本介绍"><a href="#1-基本介绍" class="headerlink" title="1. 基本介绍"></a>1. 基本介绍</h2><ul><li><strong>桥接模式(Bridge 模式)是指</strong>：将实现与抽象放在两个不同的类层次中，使两个层次可以独立改变。</li><li>是一种结构型设计模式</li><li>Bridge 模式基于类的最小设计原则，通过使用封装、聚合及继承等行为让不同的类承担不同的职责。它的主要 特点是把抽象(Abstraction)与行为实现(Implementation)分离开来，从而可以保持各部分的独立性以及应对他们的 功能扩展</li></ul><h2 id="2-桥接模式-Bridge-原理类图"><a href="#2-桥接模式-Bridge-原理类图" class="headerlink" title="2. 桥接模式(Bridge)-原理类图"></a>2. 桥接模式(Bridge)-原理类图</h2><p><img src="https://raw.githubusercontent.com/GeorgeChan95/blogimg/master/img/2024/11/16/20241116-121618.png" alt="桥接模式-原理类图"></p><p><strong>类图说明</strong></p><ul><li>Client 类：桥接模式的调用者</li><li>抽象类(Abstraction) :维护了 Implementor &#x2F;  即它的实现类 ConcreteImplementorA.., 二者是聚合关系, Abstraction 充当桥接类</li><li>RefinedAbstraction :  是 Abstraction 抽象类的子类</li><li>Implementor :  行为实现类的接口</li><li>ConcreteImplementorA&#x2F;B  ：行为的具体实现类</li><li>从 UML 图：这里的抽象类和接口是聚合的关系，其实调用和被调用关系</li></ul><h1 id="三、桥接模式解决手机操作问题"><a href="#三、桥接模式解决手机操作问题" class="headerlink" title="三、桥接模式解决手机操作问题"></a>三、桥接模式解决手机操作问题</h1><p>使用桥接模式改进传统方式，让程序具有搞好的扩展性，利用程序维护</p><h2 id="1-设计UML类图"><a href="#1-设计UML类图" class="headerlink" title="1. 设计UML类图"></a>1. 设计UML类图</h2><p><img src="https://raw.githubusercontent.com/GeorgeChan95/blogimg/master/img/2024/11/16/20241116-133618.png" alt="image-20241116133617754"></p><h2 id="2-代码实现"><a href="#2-代码实现" class="headerlink" title="2. 代码实现"></a>2. 代码实现</h2><pre><code class="highlight java"><span class="comment">// 定义实现，对应 UML中的 Implementation</span><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">Brand</span> &#123;    <span class="comment">// 开机</span>    <span class="keyword">void</span> <span class="title function_">open</span><span class="params">()</span>;    <span class="comment">// 关机</span>    <span class="keyword">void</span> <span class="title function_">close</span><span class="params">()</span>;    <span class="comment">// 打电话</span>    <span class="keyword">void</span> <span class="title function_">call</span><span class="params">()</span>;    <span class="comment">// 设置手机款式</span>    <span class="keyword">void</span> <span class="title function_">setStype</span><span class="params">(String stype)</span>;&#125;<span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Vivo</span> <span class="keyword">implements</span> <span class="title class_">Brand</span>&#123;    <span class="comment">// 款式</span>    <span class="keyword">private</span> String style;    <span class="meta">@Override</span>    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">open</span><span class="params">()</span> &#123;        System.out.println(<span class="built_in">this</span>.style + <span class="string">&quot; Vivo手机开机 &quot;</span>);    &#125;    <span class="meta">@Override</span>    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">close</span><span class="params">()</span> &#123;        System.out.println(<span class="built_in">this</span>.style + <span class="string">&quot; Vivo手机关机 &quot;</span>);    &#125;    <span class="meta">@Override</span>    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">call</span><span class="params">()</span> &#123;        System.out.println(<span class="built_in">this</span>.style + <span class="string">&quot; Vivo手机打电话 &quot;</span>);    &#125;    <span class="meta">@Override</span>    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setStype</span><span class="params">(String stype)</span> &#123;        <span class="built_in">this</span>.style = stype;    &#125;&#125;<span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">XiaoMi</span> <span class="keyword">implements</span> <span class="title class_">Brand</span> &#123;<span class="comment">// 款式</span><span class="keyword">private</span> String style;<span class="meta">@Override</span><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">open</span><span class="params">()</span> &#123;System.out.println(<span class="built_in">this</span>.style + <span class="string">&quot; 小米手机开机&quot;</span>);&#125;<span class="meta">@Override</span><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">close</span><span class="params">()</span> &#123;System.out.println(<span class="built_in">this</span>.style + <span class="string">&quot; 小米手机关机 &quot;</span>);&#125;<span class="meta">@Override</span><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">call</span><span class="params">()</span> &#123;System.out.println(<span class="built_in">this</span>.style + <span class="string">&quot; 小米手机打电话&quot;</span>);&#125;<span class="meta">@Override</span><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setStype</span><span class="params">(String stype)</span> &#123;<span class="built_in">this</span>.style = stype;&#125;&#125;<span class="comment">// 定时抽象类，对应UML中的 Abstraction</span><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">class</span> <span class="title class_">Phone</span> &#123;    <span class="comment">// 聚合实现</span>    <span class="keyword">private</span> Brand brand;    <span class="keyword">public</span> <span class="title function_">Phone</span><span class="params">(Brand brand, String style)</span> &#123;        <span class="built_in">this</span>.brand = brand;        <span class="built_in">this</span>.brand.setStype(style);    &#125;    <span class="comment">// 通过聚合，让抽象类具有 Implementation 的功能</span>    <span class="keyword">protected</span> <span class="keyword">void</span> <span class="title function_">open</span><span class="params">()</span> &#123;        <span class="built_in">this</span>.brand.open();    &#125;    <span class="keyword">protected</span> <span class="keyword">void</span> <span class="title function_">close</span><span class="params">()</span> &#123;        brand.close();    &#125;    <span class="keyword">protected</span> <span class="keyword">void</span> <span class="title function_">call</span><span class="params">()</span> &#123;        brand.call();    &#125;&#125;<span class="comment">// 折叠手机</span><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">FoldedPhone</span> <span class="keyword">extends</span> <span class="title class_">Phone</span> &#123;    <span class="keyword">public</span> <span class="title function_">FoldedPhone</span><span class="params">(Brand brand)</span> &#123;        <span class="built_in">super</span>(brand, <span class="string">&quot;折叠式&quot;</span>);    &#125;    <span class="meta">@Override</span>    <span class="keyword">protected</span> <span class="keyword">void</span> <span class="title function_">open</span><span class="params">()</span> &#123;        <span class="built_in">super</span>.open();    &#125;    <span class="meta">@Override</span>    <span class="keyword">protected</span> <span class="keyword">void</span> <span class="title function_">close</span><span class="params">()</span> &#123;        <span class="built_in">super</span>.close();    &#125;    <span class="meta">@Override</span>    <span class="keyword">protected</span> <span class="keyword">void</span> <span class="title function_">call</span><span class="params">()</span> &#123;        <span class="built_in">super</span>.call();    &#125;&#125;<span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">UpRightPhone</span> <span class="keyword">extends</span> <span class="title class_">Phone</span>&#123;    <span class="keyword">public</span> <span class="title function_">UpRightPhone</span><span class="params">(Brand brand)</span> &#123;        <span class="built_in">super</span>(brand, <span class="string">&quot;直板式&quot;</span>);    &#125;    <span class="meta">@Override</span>    <span class="keyword">protected</span> <span class="keyword">void</span> <span class="title function_">open</span><span class="params">()</span> &#123;        <span class="built_in">super</span>.open();    &#125;    <span class="meta">@Override</span>    <span class="keyword">protected</span> <span class="keyword">void</span> <span class="title function_">close</span><span class="params">()</span> &#123;        <span class="built_in">super</span>.close();    &#125;    <span class="meta">@Override</span>    <span class="keyword">protected</span> <span class="keyword">void</span> <span class="title function_">call</span><span class="params">()</span> &#123;        <span class="built_in">super</span>.call();    &#125;&#125;<span class="comment">// 测试类</span><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Client</span> &#123;    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;        <span class="type">FoldedPhone</span> <span class="variable">foldedXiaomi</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">FoldedPhone</span>(<span class="keyword">new</span> <span class="title class_">XiaoMi</span>());        foldedXiaomi.open();        foldedXiaomi.call();        foldedXiaomi.close();        System.out.println(<span class="string">&quot;========================&quot;</span>);        <span class="type">FoldedPhone</span> <span class="variable">foldedVivo</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">FoldedPhone</span>(<span class="keyword">new</span> <span class="title class_">Vivo</span>());        foldedVivo.open();        foldedVivo.call();        foldedVivo.close();        System.out.println(<span class="string">&quot;========================&quot;</span>);        <span class="type">UpRightPhone</span> <span class="variable">upXiaomi</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">UpRightPhone</span>(<span class="keyword">new</span> <span class="title class_">XiaoMi</span>());        upXiaomi.open();        upXiaomi.call();        upXiaomi.close();        System.out.println(<span class="string">&quot;========================&quot;</span>);        <span class="type">UpRightPhone</span> <span class="variable">upVivo</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">UpRightPhone</span>(<span class="keyword">new</span> <span class="title class_">XiaoMi</span>());        upVivo.open();        upVivo.call();        upVivo.close();        System.out.println(<span class="string">&quot;========================&quot;</span>);    &#125;&#125;</code></pre><blockquote><p>运行结果：</p><pre><code class="highlight shell">折叠式 小米手机开机折叠式 小米手机打电话折叠式 小米手机关机 ========================折叠式 Vivo手机开机 折叠式 Vivo手机打电话 折叠式 Vivo手机关机 ========================直板式 小米手机开机直板式 小米手机打电话直板式 小米手机关机 ========================直板式 小米手机开机直板式 小米手机打电话直板式 小米手机关机 ========================</code></pre></blockquote><h1 id="四、JDK-源码分析"><a href="#四、JDK-源码分析" class="headerlink" title="四、JDK 源码分析"></a>四、JDK 源码分析</h1><p>JDBC 的 Driver 接口：如果从桥接模式来看，Driver 就是一个接口，下面可以有 MySQL 的 Driver、Oracle 的 Driver，这些就可以当做实现接口类</p><p><img src="https://raw.githubusercontent.com/GeorgeChan95/blogimg/master/img/2024/11/16/20241116-135126.png" alt="jdk-Connection继承体系"></p><p><strong>Connection 继承体系</strong></p><p><img src="https://raw.githubusercontent.com/GeorgeChan95/blogimg/master/img/2024/11/16/20241116-135208.png" alt="Connection 继承体系"></p><p><strong>Driver源码</strong></p><pre><code class="highlight java"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Driver</span> <span class="keyword">extends</span> <span class="title class_">NonRegisteringDriver</span> <span class="keyword">implements</span> <span class="title class_">java</span>.sql.Driver &#123;    <span class="keyword">static</span> &#123;        <span class="keyword">try</span> &#123;            java.sql.DriverManager.registerDriver(<span class="keyword">new</span> <span class="title class_">Driver</span>());        &#125; <span class="keyword">catch</span> (SQLException E) &#123;            <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">RuntimeException</span>(<span class="string">&quot;Can&#x27;t register driver!&quot;</span>);        &#125;    &#125;    <span class="keyword">public</span> <span class="title function_">Driver</span><span class="params">()</span> <span class="keyword">throws</span> SQLException &#123;        <span class="comment">// Required for Class.forName().newInstance()</span>    &#125;&#125;</code></pre><p><strong>DriverManager 结构</strong></p><p><img src="https://raw.githubusercontent.com/GeorgeChan95/blogimg/master/img/2024/11/16/20241116-135432.png" alt="DriverManager 结构"></p><p><strong>说明</strong></p><ul><li>MySQL 有自己的 Connectionlmpl 类，同样 Oracle 也有对应的实现类</li><li>Driver 和 Connection 之间是通过 DriverManager 类进行桥连接的</li></ul><h1 id="五、注意事项和细节"><a href="#五、注意事项和细节" class="headerlink" title="五、注意事项和细节"></a>五、注意事项和细节</h1><ul><li>实现了抽象和实现部分的分离，从而极大的提供了系统的灵活性，让抽象部分和实现部分独立开来。这有助于系统进行分层设计，从而产生更好的结构化系统</li></ul><ol start="2"><li>对于系统的高层部分，只需要知道抽象部分和实现部分的接口就可以了，其它的部分由具体业务来完成</li><li>桥接模式替代多层继承方案，可以减少子类的个数，降低系统的管理和维护成本</li><li>桥接模式的引入增加了系统的理解和设计难度，由于聚合关联关系建立在抽象层，要求开发者针对抽象进行设计和编程</li><li>桥接模式要求正确识别出系统中两个独立变化的维度，因此其使用范围有一定的后限性，即需要有这样的应用场景</li></ol>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;一、传统方式解决手机操作问题&quot;&gt;&lt;a href=&quot;#一、传统方式解决手机操作问题&quot; class=&quot;headerlink&quot; title=&quot;一、传统方式解决手机操作问题&quot;&gt;&lt;/a&gt;一、传统方式解决手机操作问题&lt;/h1&gt;&lt;p&gt;现在对不同手机类型的不同品牌实现操作编程（比</summary>
      
    
    
    
    <category term="设计模式" scheme="https://georgechan95.github.io/categories/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"/>
    
    
    <category term="设计模式" scheme="https://georgechan95.github.io/tags/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"/>
    
  </entry>
  
  <entry>
    <title>08-适配器模式</title>
    <link href="https://georgechan95.github.io/blog/f77fc055.html"/>
    <id>https://georgechan95.github.io/blog/f77fc055.html</id>
    <published>2024-11-12T14:55:00.000Z</published>
    <updated>2024-11-12T13:00:03.561Z</updated>
    
    <content type="html"><![CDATA[<h1 id="一、概述"><a href="#一、概述" class="headerlink" title="一、概述"></a>一、概述</h1><h2 id="1-基本介绍"><a href="#1-基本介绍" class="headerlink" title="1. 基本介绍"></a>1. 基本介绍</h2><ul><li>适配器模式(Adapter Pattern)将某个类的接口转换成客户端期望的另一个接口表示，主的目的是兼容性，让原本 因接口不匹配不能一起工作的两个类可以协同工作。其别名为包装器(Wrapper)</li><li>适配器模式属于结构型模式</li><li>主要分为三类：<strong>类适配器模式</strong>、<strong>对象适配器模式</strong>、<strong>接口适配器模式</strong></li></ul><h2 id="2-工作原理"><a href="#2-工作原理" class="headerlink" title="2. 工作原理"></a>2. 工作原理</h2><ul><li>适配器模式：将一个类的接口转换成另一种接口.让原本接口不兼容的类可以兼容</li><li>从用户的角度看不到被适配者，是解耦的</li><li>用户调用适配器转化出来的目标接口方法，适配器再调用被适配者的相关接口方法</li><li>用户收到反馈结果，感觉只是和目标接口交互，如图</li></ul><p><img src="https://raw.githubusercontent.com/GeorgeChan95/blogimg/master/img/2024/11/12/20241112-194016.png" alt="适配器模式"></p><h1 id="二、类适配器模式"><a href="#二、类适配器模式" class="headerlink" title="二、类适配器模式"></a>二、类适配器模式</h1><h2 id="1-类适配器模式介绍"><a href="#1-类适配器模式介绍" class="headerlink" title="1. 类适配器模式介绍"></a>1. 类适配器模式介绍</h2><p>基本介绍：Adapter 类，通过继承 src 类，实现 dst  类接口，完成 src -&gt; dst 的适配。</p><h2 id="2-类适配器模式应用实例"><a href="#2-类适配器模式应用实例" class="headerlink" title="2. 类适配器模式应用实例"></a>2. 类适配器模式应用实例</h2><h3 id="2-1-应用实例说明"><a href="#2-1-应用实例说明" class="headerlink" title="2.1 应用实例说明"></a>2.1 应用实例说明</h3><p>以生活中充电器的例子来讲解适配器，充电器本身相当于 Adapter，220V 交流电相当于 src (即被适配者)，dst (即 目标)是 5V 直流电</p><h3 id="2-2-思路分析-类图"><a href="#2-2-思路分析-类图" class="headerlink" title="2.2 思路分析(类图)"></a>2.2 思路分析(类图)</h3><p><img src="https://raw.githubusercontent.com/GeorgeChan95/blogimg/master/img/2024/11/12/20241112-200303.png" alt="类适配器模式应用实例"></p><h3 id="2-3-代码实现"><a href="#2-3-代码实现" class="headerlink" title="2.3 代码实现"></a>2.3 代码实现</h3><pre><code class="highlight java"><span class="comment">// 被适配的类</span><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Voltage220V</span> &#123;    <span class="comment">/**</span><span class="comment">     * 输出220V电压</span><span class="comment">     * <span class="doctag">@return</span></span><span class="comment">     */</span>    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">output220V</span><span class="params">()</span> &#123;        <span class="type">int</span> <span class="variable">src</span> <span class="operator">=</span> <span class="number">220</span>;        System.out.println(<span class="string">&quot;输出电压 &quot;</span> + src + <span class="string">&quot; V&quot;</span>);        <span class="keyword">return</span> src;    &#125;&#125;<span class="comment">// 适配接口</span><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">IVoltage5V</span> &#123;    <span class="comment">// 输出5V电压</span>    <span class="type">int</span> <span class="title function_">output5V</span><span class="params">()</span>;&#125;<span class="comment">// 适配器类</span><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">VoltageAdapter</span> <span class="keyword">extends</span> <span class="title class_">Voltage220V</span> <span class="keyword">implements</span> <span class="title class_">IVoltage5V</span>&#123;    <span class="meta">@Override</span>    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">output5V</span><span class="params">()</span> &#123;        <span class="comment">// 父类方法输出的结果</span>        <span class="type">int</span> <span class="variable">srcV</span> <span class="operator">=</span> output220V();        <span class="type">int</span> <span class="variable">out</span> <span class="operator">=</span> srcV / <span class="number">44</span>; <span class="comment">// 对父类输出结果进行适配</span>        <span class="comment">// 将适配后的接口返回</span>        <span class="keyword">return</span> out;    &#125;&#125;<span class="comment">// 使用适配器</span><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Phone</span> &#123;    <span class="comment">// 充电方法</span>    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">charging</span><span class="params">(IVoltage5V iVoltage5V)</span> &#123;        <span class="type">int</span> <span class="variable">data</span> <span class="operator">=</span> iVoltage5V.output5V();        <span class="keyword">if</span> (data == <span class="number">5</span>) &#123;            System.out.println(<span class="string">&quot;电压为5V，可以充电&quot;</span>);        &#125; <span class="keyword">else</span> &#123;            System.out.println(<span class="string">&quot;电压不符合使用标准&quot;</span>);        &#125;    &#125;&#125;<span class="comment">// 测试类</span><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Client</span> &#123;    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;        System.out.println(<span class="string">&quot; === 类适配器模式 ====&quot;</span>);        <span class="type">Phone</span> <span class="variable">phone</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Phone</span>();        phone.charging(<span class="keyword">new</span> <span class="title class_">VoltageAdapter</span>());    &#125;&#125;</code></pre><blockquote><p>运行结果：</p><pre><code class="highlight shell"> === 类适配器模式 ====输出电压 220 V电压为5V，可以充电</code></pre></blockquote><h3 id="2-4-类适配器模式注意事项和细节"><a href="#2-4-类适配器模式注意事项和细节" class="headerlink" title="2.4 类适配器模式注意事项和细节"></a>2.4 类适配器模式注意事项和细节</h3><ul><li>Java 是单继承机制，所以类适配器需要继承 src 类这一点算是一个缺点, 因为这要求 dst 必须是接口，有一定局限性;</li><li>src 类的方法在 Adapter 中都会暴露出来，也增加了使用的成本.</li><li>由于其继承了 src 类，所以它可以根据需求重写 src 类的方法，使得 Adapter 的灵活性增强了。</li></ul><h1 id="三、对象适配器模式"><a href="#三、对象适配器模式" class="headerlink" title="三、对象适配器模式"></a>三、对象适配器模式</h1><h2 id="1-对象适配器模式介绍"><a href="#1-对象适配器模式介绍" class="headerlink" title="1. 对象适配器模式介绍"></a>1. 对象适配器模式介绍</h2><ul><li>基本思路和类的适配器模式相同，只是将 Adapter 类作修改，不是继承 src 类，而是持有 src 类的实例，以解决兼容性的问题。 即：持有 src 类，实现 dst  类接口，完成 src-&gt;dst 的适配</li><li>根据“合成复用原则 ”，在系统中<strong>尽量使用关联关系（聚合）来替代继承关系</strong>。</li><li>对象适配器模式是适配器模式常用的一种</li></ul><h2 id="2-对象适配器模式应用实例"><a href="#2-对象适配器模式应用实例" class="headerlink" title="2. 对象适配器模式应用实例"></a>2. 对象适配器模式应用实例</h2><h3 id="2-1-应用实例说明-1"><a href="#2-1-应用实例说明-1" class="headerlink" title="2.1 应用实例说明"></a>2.1 应用实例说明</h3><p>以生活中充电器的例子来讲解适配器，充电器本身相当于 Adapter，220V 交流电相当于 src (即被适配者)，dst (即 目标)是 5V 直流电</p><h3 id="2-2-思路分析-类图-1"><a href="#2-2-思路分析-类图-1" class="headerlink" title="2.2 思路分析(类图)"></a>2.2 思路分析(类图)</h3><p><img src="https://raw.githubusercontent.com/GeorgeChan95/blogimg/master/img/2024/11/12/20241112-202023.png" alt="对象适配器模式应用实例"></p><h3 id="2-3-代码实现-1"><a href="#2-3-代码实现-1" class="headerlink" title="2.3 代码实现"></a>2.3 代码实现</h3><pre><code class="highlight java"><span class="comment">// 适配接口</span><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">IVoltage5V</span> &#123;    <span class="comment">// 输出5V电压</span>    <span class="type">int</span> <span class="title function_">output5V</span><span class="params">()</span>;&#125;<span class="comment">// 被适配的类</span><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Voltage220V</span> &#123;    <span class="comment">/**</span><span class="comment">     * 输出220V电压</span><span class="comment">     * <span class="doctag">@return</span></span><span class="comment">     */</span>    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">output220V</span><span class="params">()</span> &#123;        <span class="type">int</span> <span class="variable">src</span> <span class="operator">=</span> <span class="number">220</span>;        System.out.println(<span class="string">&quot;输出电压 &quot;</span> + src + <span class="string">&quot; V&quot;</span>);        <span class="keyword">return</span> src;    &#125;&#125;<span class="comment">// 适配器类</span><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">VoltageAdapter</span> <span class="keyword">implements</span> <span class="title class_">IVoltage5V</span> &#123;    <span class="keyword">private</span> Voltage220V voltage220V;    <span class="keyword">public</span> <span class="title function_">VoltageAdapter</span><span class="params">(Voltage220V voltage220V)</span> &#123;        <span class="built_in">this</span>.voltage220V = voltage220V;    &#125;    <span class="meta">@Override</span>    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">output5V</span><span class="params">()</span> &#123;        <span class="keyword">if</span> (voltage220V == <span class="literal">null</span>) <span class="keyword">return</span> <span class="number">0</span>;        <span class="comment">// 被适配类方法调用</span>        <span class="type">int</span> <span class="variable">srcV</span> <span class="operator">=</span> voltage220V.output220V();        <span class="type">int</span> <span class="variable">out</span> <span class="operator">=</span> srcV / <span class="number">44</span>; <span class="comment">// 对被适配输出结果进行适配</span>        <span class="comment">// 将适配后的结果返回</span>        <span class="keyword">return</span> out;    &#125;&#125;<span class="comment">// 使用适配器</span><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Phone</span> &#123;    <span class="comment">// 充电方法</span>    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">charging</span><span class="params">(IVoltage5V iVoltage5V)</span> &#123;        <span class="type">int</span> <span class="variable">data</span> <span class="operator">=</span> iVoltage5V.output5V();        <span class="keyword">if</span> (data == <span class="number">5</span>) &#123;            System.out.println(<span class="string">&quot;电压为5V，可以充电&quot;</span>);        &#125; <span class="keyword">else</span> &#123;            System.out.println(<span class="string">&quot;电压不符合使用标准&quot;</span>);        &#125;    &#125;&#125;<span class="comment">// 测试类</span><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Client</span> &#123;    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;        System.out.println(<span class="string">&quot; === 对象适配器模式 ====&quot;</span>);        <span class="type">Phone</span> <span class="variable">phone</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Phone</span>();        phone.charging(<span class="keyword">new</span> <span class="title class_">VoltageAdapter</span>(<span class="keyword">new</span> <span class="title class_">Voltage220V</span>()));    &#125;&#125;</code></pre><blockquote><p>运行结果：</p><pre><code class="highlight shell"> === 对象适配器模式 ====输出电压 220 V电压为5V，可以充电</code></pre></blockquote><h3 id="2-4-对象适配器模式注意事项和细节"><a href="#2-4-对象适配器模式注意事项和细节" class="headerlink" title="2.4 对象适配器模式注意事项和细节"></a>2.4 对象适配器模式注意事项和细节</h3><ul><li><p>对象适配器和类适配器其实算是同一种思想，只不过实现方式不同。</p><p>根据合成复用原则，使用组合替代继承， 所以它解决了类适配器必须继承 src 的局限性问题，也不再要求dst 必须是接口。</p></li><li><p>使用成本更低，更灵活。</p></li></ul><h1 id="四、接口适配器模式"><a href="#四、接口适配器模式" class="headerlink" title="四、接口适配器模式"></a>四、接口适配器模式</h1><h2 id="1-接口适配器模式介绍"><a href="#1-接口适配器模式介绍" class="headerlink" title="1. 接口适配器模式介绍"></a>1. 接口适配器模式介绍</h2><ul><li>接口适配器模式 也叫 缺省适配器模式</li><li>核心思路：当不需要全部实现接口提供的方法时，可先设计一个抽象类实现接口，并为该接口中每个方法提供 一个默认实现（空方法），那么该抽象类的子类可有选择地覆盖父类的某些方法来实现需求。</li><li>适用于一个接口不想使用其所有的方法的情况。</li></ul><h2 id="2-接口适配器模式应用实例"><a href="#2-接口适配器模式应用实例" class="headerlink" title="2. 接口适配器模式应用实例"></a>2. 接口适配器模式应用实例</h2><h3 id="2-1-思路分析-类图"><a href="#2-1-思路分析-类图" class="headerlink" title="2.1 思路分析(类图)"></a>2.1 思路分析(类图)</h3><p><img src="https://raw.githubusercontent.com/GeorgeChan95/blogimg/master/img/2024/11/12/20241112-203806.png" alt="接口适配器模式应用实例"></p><h3 id="2-2-代码实现"><a href="#2-2-代码实现" class="headerlink" title="2.2 代码实现"></a>2.2 代码实现</h3><pre><code class="highlight java"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">MyInterface</span> &#123;    <span class="keyword">void</span> <span class="title function_">m1</span><span class="params">()</span>;    <span class="keyword">void</span> <span class="title function_">m2</span><span class="params">()</span>;    <span class="keyword">void</span> <span class="title function_">m3</span><span class="params">()</span>;    <span class="keyword">void</span> <span class="title function_">m4</span><span class="params">()</span>;&#125;<span class="comment">// 在AbsAdapter 我们将 MyInterface 的方法进行默认实现</span><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">AbsAdapter</span> <span class="keyword">implements</span> <span class="title class_">MyInterface</span> &#123;    <span class="meta">@Override</span>    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">m1</span><span class="params">()</span> &#123;    &#125;    <span class="meta">@Override</span>    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">m2</span><span class="params">()</span> &#123;    &#125;    <span class="meta">@Override</span>    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">m3</span><span class="params">()</span> &#123;    &#125;    <span class="meta">@Override</span>    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">m4</span><span class="params">()</span> &#123;    &#125;&#125;<span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Client</span> &#123;    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;        System.out.println(<span class="string">&quot; === 接口适配器模式 ====&quot;</span>);        <span class="type">AbsAdapter</span> <span class="variable">absAdapter</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">AbsAdapter</span>() &#123;            <span class="meta">@Override</span>            <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">m1</span><span class="params">()</span> &#123;                System.out.println(<span class="string">&quot;使用了m1方法&quot;</span>);            &#125;        &#125;;        absAdapter.m1();    &#125;&#125;</code></pre><blockquote><p>运行结果：</p><pre><code class="highlight shell"> === 接口适配器模式 ====使用了m1方法</code></pre></blockquote><h1 id="五、适配器模式在-SpringMVC-框架应用的源码剖析"><a href="#五、适配器模式在-SpringMVC-框架应用的源码剖析" class="headerlink" title="五、适配器模式在 SpringMVC 框架应用的源码剖析"></a>五、适配器模式在 SpringMVC 框架应用的源码剖析</h1><p><strong>SpringMvc 中的 HandlerAdapter,  就使用了适配器模式</strong></p><p><img src="https://raw.githubusercontent.com/GeorgeChan95/blogimg/master/img/2024/11/12/20241112-204926.png" alt="SpringMVC 处理请求的流程"></p><p><strong>使用 HandlerAdapter 的原因分析：</strong></p><p>在 DispatcherServlet 中，有一个 doDispatch 方法，其中便使用到了 HandlerAdapter 适配器</p><p>org.springframework.web.servlet.DispatcherServlet#doDispatch</p><p><img src="https://raw.githubusercontent.com/GeorgeChan95/blogimg/master/img/2024/11/12/20241112-205310.png" alt="DispatcherServlet#doDispatch"></p><p>通过 request 可以获得一个 Handler，再根据这个 Handler 获得不同的 HandlerAdapter 进行处理</p><p><img src="https://raw.githubusercontent.com/GeorgeChan95/blogimg/master/img/2024/11/12/20241112-205418.png" alt="getHandlerAdapter"></p><p>HandlerAdapter 本质上是一个适配器接口，具体的适配器实现类有多种，其中有我们较为熟悉的 HttpRequestHandlerAdapter 和 RequestMappingHandlerAdapter</p><p><img src="https://raw.githubusercontent.com/GeorgeChan95/blogimg/master/img/2024/11/12/20241112-205500.png" alt="HandlerAdapter"></p><p>HandlerAdapter 的实现子类是的每一种 Controller 有一种对应的适配器实现类，每种 Controller 有不同的实现方式.</p><p>拿到 HandlerAdapter 适配器之后，便会调用其中的 handle 方法， 此方法便是具体的适配器实现类需要实现的方法.</p><p><img src="https://raw.githubusercontent.com/GeorgeChan95/blogimg/master/img/2024/11/12/20241112-205730.png" alt="handle 方法"></p><p>可以看到处理器的类型不同，有多重实现方式，那么调用方式就不是确定的。如果需要直接调用 Controller 方法，需要调用的时候就得不断使用<code>if-else</code>来进行判断是哪一种子类然后执行。那么如果后面要扩展 Controller，就得修改原来的代码，这样违背了 OCP 原则.</p><h1 id="六、注意事项和细节"><a href="#六、注意事项和细节" class="headerlink" title="六、注意事项和细节"></a>六、注意事项和细节</h1><ul><li>三种命名方式，是根据 src 是以怎样的形式给到 Adapter（在 Adapter 里的形式）来命名的。</li><li>三种适配器模式：<ul><li>类适配器：以类给到，在 Adapter 里，就是将 src 当做类，继承</li><li>对象适配器：以对象给到，在 Adapter 里，将 src 作为一个对象，持有</li><li>接口适配器：以接口给到，在 Adapter 里，将 src 作为一个接口，实现</li></ul></li><li>Adapter 模式最大的作用还是将原本不兼容的接口融合在一起工作。</li></ul>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;一、概述&quot;&gt;&lt;a href=&quot;#一、概述&quot; class=&quot;headerlink&quot; title=&quot;一、概述&quot;&gt;&lt;/a&gt;一、概述&lt;/h1&gt;&lt;h2 id=&quot;1-基本介绍&quot;&gt;&lt;a href=&quot;#1-基本介绍&quot; class=&quot;headerlink&quot; title=&quot;1. 基本</summary>
      
    
    
    
    <category term="设计模式" scheme="https://georgechan95.github.io/categories/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"/>
    
    
    <category term="设计模式" scheme="https://georgechan95.github.io/tags/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"/>
    
  </entry>
  
</feed>
