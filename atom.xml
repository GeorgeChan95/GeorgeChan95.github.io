<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>George&#39;s Blog</title>
  
  <subtitle>个人邮箱：george_95@126.com</subtitle>
  <link href="https://georgechan95.github.io/atom.xml" rel="self"/>
  
  <link href="https://georgechan95.github.io/"/>
  <updated>2024-10-19T08:51:04.226Z</updated>
  <id>https://georgechan95.github.io/</id>
  
  <author>
    <name>George</name>
    
  </author>
  
  <generator uri="https://hexo.io/">Hexo</generator>
  
  <entry>
    <title>13-JUC进阶-ReentrantReadWriteLock与StampedLock</title>
    <link href="https://georgechan95.github.io/blog/1a649f4c.html"/>
    <id>https://georgechan95.github.io/blog/1a649f4c.html</id>
    <published>2024-10-19T01:26:00.000Z</published>
    <updated>2024-10-19T08:51:04.226Z</updated>
    
    <content type="html"><![CDATA[<h1 id="一、锁的演变"><a href="#一、锁的演变" class="headerlink" title="一、锁的演变"></a>一、锁的演变</h1><p>无锁  –&gt; 独占锁  –&gt; 读写锁  –&gt; 邮戳锁</p><ul><li><p>无锁：存在线程安全问题</p></li><li><p>独占锁（synchronized，ReentrantLock）</p><p>同一时刻只能有一个线程访问，在读多写少的场景下，效率并不高。</p></li><li><p>读写锁（ReentrantReadWriteLock）</p><p> 适应在多读写少的场景下，读锁可以被线程共享(<strong>共享锁</strong>)，写锁只能有一个线程获取(<strong>排它锁</strong>)。读的时候不允许写，写的时候不允许读。</p><ul><li>读写锁的缺点<ul><li>写锁饥饿问题</li><li>锁降级问题</li></ul></li></ul></li><li><p>邮戳锁（StampedLock）</p><p>是对ReentrantReadWriteLock读写锁的一种改进，主要的改进为：在没有写只有读的场景下，StampedLock支持不用加读锁而是直接进行读操作，最大程度提升读的效率，只有在发生过写操作之后，再加读锁才能进行读操作</p></li></ul><h1 id="二、ReentrantReadWriteLock"><a href="#二、ReentrantReadWriteLock" class="headerlink" title="二、ReentrantReadWriteLock"></a>二、ReentrantReadWriteLock</h1><p>关于读写锁的原理和锁降级，参考博客：<a href="https://georgechan95.github.io/blog/850dac3c.html">https://georgechan95.github.io/blog/850dac3c.html</a></p><h1 id="三、邮戳锁"><a href="#三、邮戳锁" class="headerlink" title="三、邮戳锁"></a>三、邮戳锁</h1><h2 id="1-StampedLock简介"><a href="#1-StampedLock简介" class="headerlink" title="1. StampedLock简介"></a>1. StampedLock简介</h2><p><code>StampedLock</code> 是JUC并发包里面 JDK8 版本新增的一个锁，是读写锁的一种具体实现，和 <code>ReentrantReadWriteLock</code> 不同的是其不提供可重入性，不基于某个类似<code>Lock</code> 或者 <code>ReadWriteLock</code> 接口实现,而是基于CLH锁思想实现这点这AQS有些类似，并且 <code>StampedLock</code> 不支持条件变量 <code>Condition</code> 。</p><h3 id="1-1-StampedLock-三个主要的锁模式"><a href="#1-1-StampedLock-三个主要的锁模式" class="headerlink" title="1.1 StampedLock 三个主要的锁模式"></a>1.1 StampedLock 三个主要的锁模式</h3><ul><li><p><strong>写锁模式（writeLock()）</strong></p><p>用于排他性地写操作。在写锁模式下，其他线程既无法获取读锁，也无法获取写锁。</p></li><li><p><strong>乐观读锁模式（tryOptimisticRead()）</strong></p><p>允许线程进行读操作而不获取读锁，这种模式假设在读操作过程中数据不会被其他线程修改。如果发现数据被修改，可以重新获取悲观读锁以保证数据一致性。</p></li><li><p><strong>悲观读锁模式（readLock()）</strong></p><p>类似于 ReadWriteLock 的读锁，允许多个线程同时获取读锁，但无法与写锁共存。</p></li></ul><h3 id="1-2-戳记"><a href="#1-2-戳记" class="headerlink" title="1.2 戳记"></a>1.2 戳记</h3><p>戳记（stamp） 是 StampedLock 的关键，表示当前锁的状态。获取锁时返回的戳记值在后续的锁操作中用于验证锁的有效性，确保在锁的释放或转换操作中锁的状态是正确的。使用戳记有助于减少锁的争用和开销， StampedLock 通过提供乐观读锁在多线程多读的情况下提供了更好的性能，这是因为获取乐观读锁时不需要进行 CAS 操作设置锁的状态，而只是简单地测试状态。</p><h3 id="1-3-获取锁和释放锁的方法"><a href="#1-3-获取锁和释放锁的方法" class="headerlink" title="1.3 获取锁和释放锁的方法"></a>1.3 获取锁和释放锁的方法</h3><ul><li>获取锁：<ul><li><code>tryOptimisticRead()</code>: 获取乐观读锁，返回戳记。</li><li><code>readLock()</code>: 获取悲观读锁，返回戳记</li><li><code>writeLock()</code>: 获取写锁，返回戳记。</li></ul></li><li>释放锁：<ul><li><code>unlockRead(stamp)</code>: 释放读锁（悲观读锁或乐观读锁）。</li><li><code>unlockWrite(stamp)</code>: 释放写锁。</li></ul></li><li>转换锁：<ul><li><code>tryConvertToWriteLock(long stamp)</code>：尝试将当前持有的锁转换为写锁</li><li><code>tryConvertToReadLock(long stamp)</code>：尝试将当前持有的写锁转换为读锁</li><li><code>tryConvertToOptimisticRead(long stamp)</code>：尝试将当前持有的悲观读锁转换为乐观读锁</li></ul></li></ul><p>可以看出<code>tryConvertToWriteLock</code> 方法表明 <code>StampedLock</code> 支持锁升级，这也是和<code>ReentrantReadWriteLock</code> 不同的点</p><h3 id="1-4-并发度比较"><a href="#1-4-并发度比较" class="headerlink" title="1.4 并发度比较"></a>1.4 并发度比较</h3><table><thead><tr><th align="left">锁</th><th align="left">并发度</th></tr></thead><tbody><tr><td align="left">ReentrantLock</td><td align="left">读读互斥，读写互斥，写写互斥</td></tr><tr><td align="left">ReentrantReadWriteLock</td><td align="left">读读不互斥、读写互斥、写写互斥</td></tr><tr><td align="left">StampedLock</td><td align="left">读读不互斥、读写不互斥、写写互斥</td></tr></tbody></table><p>上面对于StampedLock 的读写不互斥是指 乐观读和写，而不是悲观读和写。</p><p>乐观读的思想和数据库中MVCC（Multi-Version Concurrency Control，多版本并发控制）有点类似。</p><h2 id="2-StampedLock简单使用示例"><a href="#2-StampedLock简单使用示例" class="headerlink" title="2. StampedLock简单使用示例"></a>2. StampedLock简单使用示例</h2><h3 id="2-1-示例代码"><a href="#2-1-示例代码" class="headerlink" title="2.1 示例代码"></a>2.1 示例代码</h3><pre><code class="highlight java"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">TestStampedLock</span> &#123;    <span class="comment">// 声明邮戳锁</span>    <span class="keyword">private</span> <span class="type">StampedLock</span> <span class="variable">lock</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">StampedLock</span>();    <span class="keyword">private</span> <span class="keyword">volatile</span> <span class="type">int</span> <span class="variable">num</span> <span class="operator">=</span> <span class="number">10</span>;    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> InterruptedException &#123;        <span class="type">TestStampedLock</span> <span class="variable">test</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">TestStampedLock</span>();        <span class="type">Runnable</span> <span class="variable">readRun</span> <span class="operator">=</span> () -&gt; test.read();        <span class="type">Runnable</span> <span class="variable">writeRun</span> <span class="operator">=</span> () -&gt; test.write(<span class="number">5</span>);        <span class="comment">// 读数据线程</span>        <span class="type">Thread</span> <span class="variable">thread1</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Thread</span>(readRun, <span class="string">&quot;thread1&quot;</span>);        <span class="comment">// 写数据线程</span>        <span class="type">Thread</span> <span class="variable">thread2</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Thread</span>(writeRun, <span class="string">&quot;thread2&quot;</span>);        <span class="comment">// 读数据线程</span>        <span class="type">Thread</span> <span class="variable">thread3</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Thread</span>(readRun, <span class="string">&quot;thread3&quot;</span>);        thread1.start();        thread2.start();        thread3.start();        <span class="keyword">try</span> &#123;            thread1.join();            thread1.join();            thread1.join();        &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;            Thread.currentThread().interrupt();        &#125;    &#125;    <span class="comment">/**</span><span class="comment">     * 读数据</span><span class="comment">     */</span>    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">read</span><span class="params">()</span> &#123;        <span class="type">long</span> <span class="variable">stamp</span> <span class="operator">=</span> lock.tryOptimisticRead();        <span class="keyword">try</span> &#123;            System.out.println(Thread.currentThread().getName() + <span class="string">&quot;开始读数据&quot;</span>);            <span class="comment">// 初次尝试乐观读</span>            <span class="type">int</span> <span class="variable">currentNum</span> <span class="operator">=</span> num;            <span class="comment">// 模拟读取时间延迟</span>            TimeUnit.MILLISECONDS.sleep(<span class="number">300</span>);            <span class="keyword">if</span> (!lock.validate(stamp)) &#123;                <span class="comment">// 乐观读失败，开始悲观读</span>                stamp = lock.readLock();                <span class="keyword">try</span> &#123;                    <span class="comment">// 再次读取内容</span>                    currentNum = num;                &#125; <span class="keyword">finally</span> &#123;                    <span class="comment">// 释放悲观读</span>                    lock.unlockRead(stamp);                &#125;            &#125;            System.out.println(Thread.currentThread().getName() + <span class="string">&quot;读取到的数值：&quot;</span> + currentNum);        &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;            System.out.println(Thread.currentThread().getName() + <span class="string">&quot; 发生异常，异常消息：&quot;</span> + e.getMessage());            <span class="comment">// 终端线程执行</span>            Thread.currentThread().interrupt();        &#125;    &#125;    <span class="comment">/**</span><span class="comment">     * 写数据</span><span class="comment">     * <span class="doctag">@param</span> number</span><span class="comment">     */</span>    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">write</span><span class="params">(<span class="type">int</span> number)</span> &#123;        <span class="type">long</span> <span class="variable">stamp</span> <span class="operator">=</span> lock.writeLock();        <span class="keyword">try</span> &#123;            System.out.println(Thread.currentThread().getName() + <span class="string">&quot;开始写数据&quot;</span>);            num += number;            System.out.println(Thread.currentThread().getName() + <span class="string">&quot;将数据写为：&quot;</span> + num);        &#125; <span class="keyword">finally</span> &#123;            lock.unlockWrite(stamp);        &#125;    &#125;&#125;</code></pre><blockquote><p>运行结果</p></blockquote><pre><code class="highlight shell">thread1开始读数据thread3开始读数据thread2开始写数据thread2将数据写为：15thread3读取到的数值：15thread1读取到的数值：15</code></pre><p>需要注意的点就是，<code>lock.tryOptimisticRead();</code> 获取悲观锁方法并不真正获取锁，而是假设在读操作期间数据不会被修改。使用戳记来验证数据是否在读操作期间被修改，必要时需要升级为悲观读锁来保证数据一致性。</p><h3 id="2-2-使用乐观读锁需要遵循一定的规则："><a href="#2-2-使用乐观读锁需要遵循一定的规则：" class="headerlink" title="2.2 使用乐观读锁需要遵循一定的规则："></a>2.2 使用乐观读锁需要遵循一定的规则：</h3><p>比如 <code>read()</code> 方法中获取 <code>num</code> 的时候需要遵循下面几个步骤：<br>并且一定要按照下面几个步骤顺序处理。</p><ul><li><p><strong>乐观读操作：</strong></p><p>先尝试使用 <code>tryOptimisticRead()</code> 获取乐观读锁。此时不持有实际的读锁，仅仅假设数据在读取期间不会被修改。进行乐观读操作，相当于把共享变量读取到线程的栈内存，这一步很重要需要在验证之前执行。</p></li><li><p><strong>验证和转换：</strong></p><p>使用 <code>validate(stamp)</code> 检查在乐观读期间数据是否被修改。如果数据未被修改，读取的结果就是可靠的。如果数据被修改，需要使用 <code>readLock()</code> 获取悲观读锁，再进行一遍悲观读取操作来确保数据的一致性。</p></li><li><p><strong>释放锁：</strong></p><p>如果获取了悲观读锁，必须在读操作完成后使用 <code>unlockRead(stamp)</code> 释放锁。</p></li></ul><pre><code class="highlight java"><span class="comment">/**</span><span class="comment"> * 读数据</span><span class="comment"> */</span><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">read</span><span class="params">()</span> &#123;    <span class="type">long</span> <span class="variable">stamp</span> <span class="operator">=</span> lock.tryOptimisticRead();    <span class="keyword">try</span> &#123;        System.out.println(Thread.currentThread().getName() + <span class="string">&quot;开始读数据&quot;</span>);        <span class="comment">// 初次尝试乐观读</span>        <span class="type">int</span> <span class="variable">currentNum</span> <span class="operator">=</span> num;        <span class="comment">// 模拟读取时间延迟</span>        TimeUnit.MILLISECONDS.sleep(<span class="number">300</span>);        <span class="keyword">if</span> (!lock.validate(stamp)) &#123;            <span class="comment">// 乐观读失败，开始悲观读</span>            stamp = lock.readLock();            <span class="keyword">try</span> &#123;                <span class="comment">// 再次读取内容</span>                currentNum = num;            &#125; <span class="keyword">finally</span> &#123;                <span class="comment">// 释放悲观读</span>                lock.unlockRead(stamp);            &#125;        &#125;        System.out.println(Thread.currentThread().getName() + <span class="string">&quot;读取到的数值：&quot;</span> + currentNum);    &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;        System.out.println(Thread.currentThread().getName() + <span class="string">&quot; 发生异常，异常消息：&quot;</span> + e.getMessage());        <span class="comment">// 终端线程执行</span>        Thread.currentThread().interrupt();    &#125;&#125;</code></pre><p>使用乐观锁、悲观锁思想也是 <code>StampedLock</code> 提升读取性能的一个方式。因为<code>tryOptimisticRead</code> 和 <code>validate</code> 这两个方法都比悲观读锁的CAS操作要快。</p><h3 id="2-3-validate方法的注意点"><a href="#2-3-validate方法的注意点" class="headerlink" title="2.3 validate方法的注意点"></a>2.3 <code>validate</code>方法的注意点</h3><p>由于乐观读操作对顺序要求很严格，并且乐观读返回的是普通long类型变量，所以为了防止重排序，在validate方法中使用了读屏障（ <code>U.loadFence();</code>） 确保在屏障之前的所有读操作在屏障之后的读操作之前完成。这意味着，<code>U.loadFence(</code>) 保证了在它之前的内存读取操作不会被重新排序到它之后。</p><p><code>StampedLock</code> 中的 <code>state</code> 变量是<code>volatile</code>修饰的，但是<code>validate</code>方法的入参<code>stamp</code>并不能保证是 <code>volatile</code> 变量，所以需要加个读屏障，确保 <code>stamp</code> 和 <code>state</code> 的读取操作不会被重排序，从而保证 <code>stamp</code> 的有效性检查是准确的。如果不使用读屏障，可能会出现 <code>stamp</code> 和 <code>state</code> 的读取操作被重排序的情况，这可能导致 <code>validate</code> 方法返回不正确的结果。</p><pre><code class="highlight java"><span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">validate</span><span class="params">(<span class="type">long</span> stamp)</span> &#123;    U.loadFence();    <span class="keyword">return</span> (stamp &amp; SBITS) == (state &amp; SBITS);&#125;</code></pre><h2 id="3-StampedLock获取释放锁详解"><a href="#3-StampedLock获取释放锁详解" class="headerlink" title="3. StampedLock获取释放锁详解"></a>3. StampedLock获取释放锁详解</h2><h3 id="3-1-类继承结构"><a href="#3-1-类继承结构" class="headerlink" title="3.1 类继承结构"></a>3.1 类继承结构</h3><p><img src="https://raw.githubusercontent.com/GeorgeChan95/blogimg/master/img/2024/10/19/20241019-154603.png" alt="类继承结构"></p><pre><code class="highlight java"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">StampedLock</span> <span class="keyword">implements</span> <span class="title class_">java</span>.io.Serializable</code></pre><h3 id="3-2-类属性"><a href="#3-2-类属性" class="headerlink" title="3.2 类属性"></a>3.2 类属性</h3><pre><code class="highlight java"><span class="comment">/** CPU 核心数，用于自旋控制 */</span><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">int</span> <span class="variable">NCPU</span> <span class="operator">=</span> Runtime.getRuntime().availableProcessors();<span class="comment">/** 尝试获取锁时的最大自旋次数。自旋是指在短时间内反复检查锁状态，而不是立即阻塞线程。 */</span><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">int</span> <span class="variable">SPINS</span> <span class="operator">=</span> (NCPU &gt; <span class="number">1</span>) ? <span class="number">1</span> &lt;&lt; <span class="number">6</span> : <span class="number">0</span>;<span class="comment">/** 尝试获取锁时，最大自旋次数，超出此值后会尝试阻塞在队列的头部。 */</span><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">int</span> <span class="variable">HEAD_SPINS</span> <span class="operator">=</span> (NCPU &gt; <span class="number">1</span>) ? <span class="number">1</span> &lt;&lt; <span class="number">10</span> : <span class="number">0</span>;<span class="comment">/** 自旋时的最大重试次数，超出此值后会重新尝试阻塞。 */</span><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">int</span> <span class="variable">MAX_HEAD_SPINS</span> <span class="operator">=</span> (NCPU &gt; <span class="number">1</span>) ? <span class="number">1</span> &lt;&lt; <span class="number">16</span> : <span class="number">0</span>;<span class="comment">/** 等待溢出自旋锁时的放弃 CPU 使用的周期。这是一个幂次 2 - 1 的值。 */</span><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">int</span> <span class="variable">OVERFLOW_YIELD_RATE</span> <span class="operator">=</span> <span class="number">7</span>; <span class="comment">// 必须是 2 的幂次 - 1</span><span class="comment">/** 用于表示读锁计数的位数，超出此范围会发生溢出。  范围是1~126  */</span><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">int</span> <span class="variable">LG_READERS</span> <span class="operator">=</span> <span class="number">7</span>;<span class="comment">/** 锁状态和印章操作的相关常量值 */</span><span class="comment">// 单位读操作的位掩码</span><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">long</span> <span class="variable">RUNIT</span> <span class="operator">=</span> <span class="number">1L</span>;<span class="comment">// 写操作的位掩码（位移了 LG_READERS 位）</span><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">long</span> <span class="variable">WBIT</span>  <span class="operator">=</span> <span class="number">1L</span> &lt;&lt; LG_READERS;<span class="comment">// 读操作的位掩码范围</span><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">long</span> <span class="variable">RBITS</span> <span class="operator">=</span> WBIT - <span class="number">1L</span>;<span class="comment">// 读操作的满位掩码</span><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">long</span> <span class="variable">RFULL</span> <span class="operator">=</span> RBITS - <span class="number">1L</span>;<span class="comment">// 所有锁的位掩码（包括读和写）</span><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">long</span> <span class="variable">ABITS</span> <span class="operator">=</span> RBITS | WBIT;<span class="comment">// 只有写锁的位掩码 ( ~ 是按位取反操作符)</span><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">long</span> <span class="variable">SBITS</span> <span class="operator">=</span> ~RBITS; <span class="comment">// 注意与 ABITS 的重叠</span><span class="comment">// 锁状态的初始值; 避免零值作为失败值</span><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">long</span> <span class="variable">ORIGIN</span> <span class="operator">=</span> WBIT &lt;&lt; <span class="number">1</span>;<span class="comment">/** 从被取消的获取方法返回的特殊值，用于抛出中断异常。 */</span><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">long</span> <span class="variable">INTERRUPTED</span> <span class="operator">=</span> <span class="number">1L</span>;<span class="comment">/** 节点状态的相关常量值，顺序很重要 */</span><span class="comment">// 等待状态</span><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">int</span> <span class="variable">WAITING</span>   <span class="operator">=</span> -<span class="number">1</span>;<span class="comment">// 取消状态</span><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">int</span> <span class="variable">CANCELLED</span> <span class="operator">=</span>  <span class="number">1</span>;<span class="comment">/** 节点模式; 用整数而不是布尔值，以允许进行算术操作 */</span><span class="comment">// 读模式</span><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">int</span> <span class="variable">RMODE</span> <span class="operator">=</span> <span class="number">0</span>;<span class="comment">// 写模式</span><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">int</span> <span class="variable">WMODE</span> <span class="operator">=</span> <span class="number">1</span>;<span class="comment">/** 等待节点的内部类，用于管理队列中的节点 */</span><span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">class</span> <span class="title class_">WNode</span> &#123;    <span class="keyword">volatile</span> WNode prev;    <span class="comment">// 上一个节点</span>    <span class="keyword">volatile</span> WNode next;    <span class="comment">// 下一个节点</span>    <span class="keyword">volatile</span> WNode cowait;  <span class="comment">// 链接的读线程列表</span>    <span class="keyword">volatile</span> Thread thread; <span class="comment">// 线程对象; 如果非空，则线程可能被挂起</span>    <span class="keyword">volatile</span> <span class="type">int</span> status;    <span class="comment">// 节点状态; 0, WAITING 或 CANCELLED</span>    <span class="keyword">final</span> <span class="type">int</span> mode;         <span class="comment">// 节点模式; RMODE 或 WMODE</span>    WNode(<span class="type">int</span> m, WNode p) &#123; mode = m; prev = p; &#125;&#125;<span class="comment">/** CLH 队列的头部节点 */</span><span class="keyword">private</span> <span class="keyword">transient</span> <span class="keyword">volatile</span> WNode whead;<span class="comment">/** CLH 队列的尾部节点 */</span><span class="keyword">private</span> <span class="keyword">transient</span> <span class="keyword">volatile</span> WNode wtail;<span class="comment">/** 锁视图，用于提供不同类型的锁视图 */</span><span class="keyword">transient</span> ReadLockView readLockView;<span class="keyword">transient</span> WriteLockView writeLockView;<span class="keyword">transient</span> ReadWriteLockView readWriteLockView;<span class="comment">/** 锁的状态*/</span><span class="keyword">private</span> <span class="keyword">transient</span> <span class="keyword">volatile</span> <span class="type">long</span> state;<span class="comment">/** 当状态的读计数饱和时，所使用的额外读锁计数 */</span><span class="keyword">private</span> <span class="keyword">transient</span> <span class="type">int</span> readerOverflow;</code></pre><p>可以看出<code>StampedLock</code>是通过内部类 <code>WNode</code> 来管理队列中的节点(队列属于双向链表结构，利用了CLH锁思想)。并且用了大量的标志位和位运算来处理锁的逻辑。</p><h3 id="3-3-StampedLock对于state变量的设计"><a href="#3-3-StampedLock对于state变量的设计" class="headerlink" title="3.3 StampedLock对于state变量的设计"></a>3.3 StampedLock对于state变量的设计</h3><pre><code class="highlight java"><span class="comment">/** 用于表示读锁计数的位数，超出此范围会发生溢出。  范围是1~126  */</span><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">int</span> <span class="variable">LG_READERS</span> <span class="operator">=</span> <span class="number">7</span>;<span class="comment">// 写操作的位掩码（位移了 LG_READERS 位）</span><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">long</span> <span class="variable">WBIT</span>  <span class="operator">=</span> <span class="number">1L</span> &lt;&lt; LG_READERS;<span class="comment">// 锁状态的初始值; 避免零值作为失败值</span><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">long</span> <span class="variable">ORIGIN</span> <span class="operator">=</span> WBIT &lt;&lt; <span class="number">1</span>;<span class="comment">/** 锁的状态*/</span><span class="keyword">private</span> <span class="keyword">transient</span> <span class="keyword">volatile</span> <span class="type">long</span> state;</code></pre><p>由于只有一个<code>state</code>变量，又需要表示读写锁，所以<code>StampedLock</code>也把state变量拆成了读和写的部分，但是不同于 <code>ReentrantReadWriteLock</code>的int类型的state变量把高16位表示读锁计数，低16位表示写锁计数。</p><p><code>StampedLock</code>中 锁状态的初始值是 <code>ORIGIN</code> 也就是 1&lt;&lt;7,也就是 <code>1000 0000</code>（前面的0省略）用最低的8位表示读和写的状态，其中最低的7位表示读锁的状态(版本)，第8位表示写锁的状态。因为写锁是互斥的且不可重入，用一位就够了。</p><h3 id="3-4-StampedLock乐观锁实现原理"><a href="#3-4-StampedLock乐观锁实现原理" class="headerlink" title="3.4 StampedLock乐观锁实现原理"></a>3.4 StampedLock乐观锁实现原理</h3><p>结合<code>tryOptimisticRead</code>和<code>validate</code>方法分析：</p><pre><code class="highlight java"><span class="keyword">public</span> <span class="type">long</span> <span class="title function_">tryOptimisticRead</span><span class="params">()</span> &#123;    <span class="type">long</span> s;    <span class="keyword">return</span> (((s = state) &amp; WBIT) == <span class="number">0L</span>) ? (s &amp; SBITS) : <span class="number">0L</span>;&#125;</code></pre><pre><code class="highlight java"><span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">validate</span><span class="params">(<span class="type">long</span> stamp)</span> &#123;    U.loadFence();    <span class="keyword">return</span> (stamp &amp; SBITS) == (state &amp; SBITS);&#125;</code></pre><p><code>tryOptimisticRead</code> 方法中 <code>state&amp;WBIT！=0</code>，说明 <code>state</code> 变量表示写锁的第八位为1，也就是有线程持有写锁，那么 <code>tryOptimisticRead</code> 方法就会返回0。表示获取乐观读锁失败。然后我们再调用 <code>validate(0)</code> 一定会得到false，也就是校验失败。这个符合当有线程持有写锁时与其他锁互斥的逻辑。</p><p>为什么<code>validate</code>方法，比较的是<code>(stamp &amp; SBITS) == (state &amp; SBITS);</code>？<br>因为需要支持读读不互斥，即使修改了state的低7位也就是读锁的部分，<code>(stamp &amp; SBITS) == (state &amp; SBITS);</code>依然会返回true。</p><h3 id="3-5-StampedLock的构造方法"><a href="#3-5-StampedLock的构造方法" class="headerlink" title="3.5 StampedLock的构造方法"></a>3.5 StampedLock的构造方法</h3><pre><code class="highlight java"><span class="comment">/** 用于表示读锁状态的位数，超出此范围会发生溢出。  范围是1~126  */</span><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">int</span> <span class="variable">LG_READERS</span> <span class="operator">=</span> <span class="number">7</span>;<span class="comment">/** 写操作的位掩码（位移了 LG_READERS 位） */</span><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">long</span> <span class="variable">WBIT</span>  <span class="operator">=</span> <span class="number">1L</span> &lt;&lt; LG_READERS;<span class="comment">/** 锁状态的初始值; 避免零值作为失败值 */</span><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">long</span> <span class="variable">ORIGIN</span> <span class="operator">=</span> WBIT &lt;&lt; <span class="number">1</span>;<span class="comment">/** 锁的状态*/</span><span class="keyword">private</span> <span class="keyword">transient</span> <span class="keyword">volatile</span> <span class="type">long</span> state;<span class="comment">/**</span><span class="comment"> * 默认构造方法。</span><span class="comment"> * 初始化 `StampedLock` 对象，将锁状态设置为初始值。</span><span class="comment"> */</span><span class="keyword">public</span> <span class="title function_">StampedLock</span><span class="params">()</span> &#123;    <span class="comment">// 初始化锁状态为初始值 ORIGIN，避免状态为零作为失败值。</span>    state = ORIGIN;&#125;</code></pre><h3 id="3-6-tryOptimisticRead方法"><a href="#3-6-tryOptimisticRead方法" class="headerlink" title="3.6 tryOptimisticRead方法"></a>3.6 tryOptimisticRead方法</h3><pre><code class="highlight java"><span class="comment">/** 用于表示读锁状态的位数 */</span><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">int</span> <span class="variable">LG_READERS</span> <span class="operator">=</span> <span class="number">7</span>;<span class="comment">/** 写操作的位掩码（位移了 LG_READERS 位） */</span><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">long</span> <span class="variable">WBIT</span>  <span class="operator">=</span> <span class="number">1L</span> &lt;&lt; LG_READERS;<span class="comment">/** 只有写锁的位掩码 */</span><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">long</span> <span class="variable">SBITS</span> <span class="operator">=</span> ~RBITS;<span class="comment">/** 读操作的位掩码范围 */</span><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">long</span> <span class="variable">RBITS</span> <span class="operator">=</span> WBIT - <span class="number">1L</span>;<span class="comment">/**</span><span class="comment"> * 尝试以乐观读模式获取锁。</span><span class="comment"> * </span><span class="comment"> * 这个方法检查当前锁状态以确定是否可以进行乐观读操作。</span><span class="comment"> * 如果没有写锁持有者（即锁的写位没有被设置），方法返回当前的读者计数（即锁的状态）。</span><span class="comment"> * 否则，返回 0 表示无法进行乐观读操作。</span><span class="comment"> * </span><span class="comment"> * <span class="doctag">@return</span> 如果可以进行乐观读，则返回当前的读者计数；否则返回 0。</span><span class="comment"> */</span><span class="keyword">public</span> <span class="type">long</span> <span class="title function_">tryOptimisticRead</span><span class="params">()</span> &#123;    <span class="type">long</span> s;    <span class="comment">// 读取当前锁状态</span>    s = state;    <span class="comment">// 检查写锁位是否被设置。如果没有写锁持有者（写位为 0），则返回当前读者计数（即去除写锁位后的状态值）。</span>    <span class="keyword">return</span> (((s &amp; WBIT) == <span class="number">0L</span>) ? (s &amp; SBITS) : <span class="number">0L</span>);&#125;</code></pre><p>这个方法允许线程在没有写锁持有者的情况下进行乐观读操作，这可以提高并发性能，因为乐观读操作不需要获取实际的读锁。</p><h3 id="3-7-readLock-方法"><a href="#3-7-readLock-方法" class="headerlink" title="3.7 readLock 方法"></a>3.7 readLock 方法</h3><pre><code class="highlight java"><span class="comment">/**</span><span class="comment"> * 尝试获取读锁。</span><span class="comment"> * </span><span class="comment"> * 在常见的无竞争情况下，这个方法会直接返回一个读锁的印章。</span><span class="comment"> * 如果当前队列为空（即 `whead` 等于 `wtail`），并且没有写锁持有者（即当前状态的读位小于 RFULL），</span><span class="comment"> * 则通过 CAS 操作将状态值加上 `RUNIT` 以尝试获取读锁。</span><span class="comment"> * 否则，调用 `acquireRead` 方法来实际获取读锁。</span><span class="comment"> * </span><span class="comment"> * <span class="doctag">@return</span> 成功获取读锁时的印章值。如果无法获取，则调用 `acquireRead` 方法来处理。</span><span class="comment"> */</span><span class="keyword">public</span> <span class="type">long</span> <span class="title function_">readLock</span><span class="params">()</span> &#123;    <span class="type">long</span> <span class="variable">s</span> <span class="operator">=</span> state, next;  <span class="comment">// 读取当前锁状态，并为下一个状态准备变量</span>    <span class="comment">// 如果当前队列为空且状态值允许新的读操作，则尝试通过 CAS 操作增加读锁计数</span>    <span class="keyword">return</span> ((whead == wtail &amp;&amp; (s &amp; ABITS) &lt; RFULL &amp;&amp;             U.compareAndSwapLong(<span class="built_in">this</span>, STATE, s, next = s + RUNIT)) ?            next : acquireRead(<span class="literal">false</span>, <span class="number">0L</span>));  <span class="comment">// 否则调用 acquireRead 方法来获取读锁</span>&#125;</code></pre><p><strong><code>readLock</code> 方法总结：</strong></p><ul><li><p><strong>目标：</strong> 尝试在无竞争情况下快速获取读锁。如果直接获取失败，则调用 <code>acquireRead</code> 处理复杂情况。</p></li><li><p><strong>具体步骤：</strong></p><ul><li><p><strong>检查队列状态：</strong></p><p>如果队列为空（whead &#x3D;&#x3D; wtail）且状态允许增加读锁计数（(s &amp; ABITS) &lt; RFULL），即没有达到读锁计数上限：尝试通过 CAS 操作将 state 增加 RUNIT，即增加读锁计数。如果 CAS 操作成功，返回新的状态 next。</p></li><li><p><strong>调用 acquireRead：</strong></p><p>如果队列不为空，或者 CAS 操作失败，则调用 acquireRead 方法来处理更复杂的情况，实际获取读锁。</p></li></ul></li></ul><h3 id="3-8-acquireRead方法"><a href="#3-8-acquireRead方法" class="headerlink" title="3.8 acquireRead方法"></a>3.8 acquireRead方法</h3><pre><code class="highlight java"><span class="comment">/**</span><span class="comment"> * 实际获取读锁的方法。</span><span class="comment"> * </span><span class="comment"> * 这个方法会尝试获取读锁。如果直接获取失败，它会通过自旋、队列管理和线程等待来确保获取读锁。</span><span class="comment"> * </span><span class="comment"> * <span class="doctag">@param</span> interruptible 是否可中断。</span><span class="comment"> * <span class="doctag">@param</span> deadline 线程等待的截止时间（纳秒）。</span><span class="comment"> * <span class="doctag">@return</span> 成功获取读锁时的印章值。如果超时或中断，则可能会取消等待。</span><span class="comment"> */</span><span class="keyword">private</span> <span class="type">long</span> <span class="title function_">acquireRead</span><span class="params">(<span class="type">boolean</span> interruptible, <span class="type">long</span> deadline)</span> &#123;    <span class="type">WNode</span> <span class="variable">node</span> <span class="operator">=</span> <span class="literal">null</span>, p;    <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">spins</span> <span class="operator">=</span> -<span class="number">1</span>;;) &#123;        WNode h;        <span class="keyword">if</span> ((h = whead) == (p = wtail)) &#123;  <span class="comment">// 检查队列是否为空</span>            <span class="keyword">for</span> (<span class="type">long</span> m, s, ns;;) &#123;                <span class="comment">// 检查当前状态是否允许增加读锁计数</span>                <span class="keyword">if</span> ((m = (s = state) &amp; ABITS) &lt; RFULL ?                    U.compareAndSwapLong(<span class="built_in">this</span>, STATE, s, ns = s + RUNIT) :                    (m &lt; WBIT &amp;&amp; (ns = tryIncReaderOverflow(s)) != <span class="number">0L</span>))                    <span class="keyword">return</span> ns;  <span class="comment">// 成功获取读锁</span>                <span class="keyword">else</span> <span class="keyword">if</span> (m &gt;= WBIT) &#123;                    <span class="keyword">if</span> (spins &gt; <span class="number">0</span>) &#123;                        <span class="keyword">if</span> (LockSupport.nextSecondarySeed() &gt;= <span class="number">0</span>)                            --spins;                    &#125;                    <span class="keyword">else</span> &#123;                        <span class="keyword">if</span> (spins == <span class="number">0</span>) &#123;                            <span class="type">WNode</span> <span class="variable">nh</span> <span class="operator">=</span> whead, np = wtail;                            <span class="keyword">if</span> ((nh == h &amp;&amp; np == p) || (h = nh) != (p = np))                                <span class="keyword">break</span>;                        &#125;                        spins = SPINS;  <span class="comment">// 重置自旋次数</span>                    &#125;                &#125;            &#125;        &#125;        <span class="keyword">if</span> (p == <span class="literal">null</span>) &#123; <span class="comment">// 如果队列为空，初始化队列</span>            <span class="type">WNode</span> <span class="variable">hd</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">WNode</span>(WMODE, <span class="literal">null</span>);            <span class="keyword">if</span> (U.compareAndSwapObject(<span class="built_in">this</span>, WHEAD, <span class="literal">null</span>, hd))                wtail = hd;        &#125;        <span class="keyword">else</span> <span class="keyword">if</span> (node == <span class="literal">null</span>)            node = <span class="keyword">new</span> <span class="title class_">WNode</span>(RMODE, p);  <span class="comment">// 创建新的读节点</span>        <span class="keyword">else</span> <span class="keyword">if</span> (h == p || p.mode != RMODE) &#123;  <span class="comment">// 如果队列中的前驱节点不是读节点，尝试加入队列</span>            <span class="keyword">if</span> (node.prev != p)                node.prev = p;            <span class="keyword">else</span> <span class="keyword">if</span> (U.compareAndSwapObject(<span class="built_in">this</span>, WTAIL, p, node)) &#123;                p.next = node;                <span class="keyword">break</span>;            &#125;        &#125;        <span class="keyword">else</span> <span class="keyword">if</span> (!U.compareAndSwapObject(p, WCOWAIT,                                         node.cowait = p.cowait, node))            node.cowait = <span class="literal">null</span>;  <span class="comment">// 更新前驱节点的等待列表</span>        <span class="keyword">else</span> &#123;            <span class="keyword">for</span> (;;) &#123;                WNode pp, c; Thread w;                <span class="keyword">if</span> ((h = whead) != <span class="literal">null</span> &amp;&amp; (c = h.cowait) != <span class="literal">null</span> &amp;&amp;                    U.compareAndSwapObject(h, WCOWAIT, c, c.cowait) &amp;&amp;                    (w = c.thread) != <span class="literal">null</span>) <span class="comment">// 唤醒等待线程</span>                    U.unpark(w);                <span class="keyword">if</span> (h == (pp = p.prev) || h == p || pp == <span class="literal">null</span>) &#123;                    <span class="type">long</span> m, s, ns;                    <span class="keyword">do</span> &#123;                        <span class="comment">// 检查状态是否允许增加读锁计数</span>                        <span class="keyword">if</span> ((m = (s = state) &amp; ABITS) &lt; RFULL ?                            U.compareAndSwapLong(<span class="built_in">this</span>, STATE, s,                                                 ns = s + RUNIT) :                            (m &lt; WBIT &amp;&amp;                             (ns = tryIncReaderOverflow(s)) != <span class="number">0L</span>))                            <span class="keyword">return</span> ns;  <span class="comment">// 成功获取读锁</span>                    &#125; <span class="keyword">while</span> (m &lt; WBIT);                &#125;                <span class="keyword">if</span> (whead == h &amp;&amp; p.prev == pp) &#123;                    <span class="type">long</span> time;                    <span class="keyword">if</span> (pp == <span class="literal">null</span> || h == p || p.status &gt; <span class="number">0</span>) &#123;                        node = <span class="literal">null</span>; <span class="comment">// 丢弃节点</span>                        <span class="keyword">break</span>;                    &#125;                    <span class="keyword">if</span> (deadline == <span class="number">0L</span>)                        time = <span class="number">0L</span>;                    <span class="keyword">else</span> <span class="keyword">if</span> ((time = deadline - System.nanoTime()) &lt;= <span class="number">0L</span>)                        <span class="keyword">return</span> cancelWaiter(node, p, <span class="literal">false</span>);  <span class="comment">// 超时取消等待</span>                    <span class="type">Thread</span> <span class="variable">wt</span> <span class="operator">=</span> Thread.currentThread();                    U.putObject(wt, PARKBLOCKER, <span class="built_in">this</span>);                    node.thread = wt;                    <span class="keyword">if</span> ((h != pp || (state &amp; ABITS) == WBIT) &amp;&amp;                        whead == h &amp;&amp; p.prev == pp)                        U.park(<span class="literal">false</span>, time);  <span class="comment">// 线程等待</span>                    node.thread = <span class="literal">null</span>;                    U.putObject(wt, PARKBLOCKER, <span class="literal">null</span>);                    <span class="keyword">if</span> (interruptible &amp;&amp; Thread.interrupted())                        <span class="keyword">return</span> cancelWaiter(node, p, <span class="literal">true</span>);  <span class="comment">// 处理中断</span>                &#125;            &#125;        &#125;    &#125;    <span class="comment">// 在队列头部自旋等待</span>    <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">spins</span> <span class="operator">=</span> -<span class="number">1</span>;;) &#123;        WNode h, np, pp; <span class="type">int</span> ps;        <span class="keyword">if</span> ((h = whead) == p) &#123;            <span class="keyword">if</span> (spins &lt; <span class="number">0</span>)                spins = HEAD_SPINS;  <span class="comment">// 初始化自旋次数</span>            <span class="keyword">else</span> <span class="keyword">if</span> (spins &lt; MAX_HEAD_SPINS)                spins &lt;&lt;= <span class="number">1</span>;  <span class="comment">// 增加自旋次数</span>            <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">k</span> <span class="operator">=</span> spins;;) &#123; <span class="comment">// 在队列头部自旋</span>                <span class="type">long</span> m, s, ns;                <span class="keyword">if</span> ((m = (s = state) &amp; ABITS) &lt; RFULL ?                    U.compareAndSwapLong(<span class="built_in">this</span>, STATE, s, ns = s + RUNIT) :                    (m &lt; WBIT &amp;&amp; (ns = tryIncReaderOverflow(s)) != <span class="number">0L</span>)) &#123;                    WNode c; Thread w;                    whead = node;  <span class="comment">// 更新队列头部</span>                    node.prev = <span class="literal">null</span>;                    <span class="keyword">while</span> ((c = node.cowait) != <span class="literal">null</span>) &#123;                        <span class="keyword">if</span> (U.compareAndSwapObject(node, WCOWAIT,                                                   c, c.cowait) &amp;&amp;                            (w = c.thread) != <span class="literal">null</span>)                            U.unpark(w);  <span class="comment">// 唤醒等待线程</span>                    &#125;                    <span class="keyword">return</span> ns;  <span class="comment">// 成功获取读锁</span>                &#125;                <span class="keyword">else</span> <span class="keyword">if</span> (m &gt;= WBIT &amp;&amp;                         LockSupport.nextSecondarySeed() &gt;= <span class="number">0</span> &amp;&amp; --k &lt;= <span class="number">0</span>)                    <span class="keyword">break</span>;  <span class="comment">// 超过自旋次数，退出自旋</span>            &#125;        &#125;        <span class="keyword">else</span> <span class="keyword">if</span> (h != <span class="literal">null</span>) &#123;            WNode c; Thread w;            <span class="keyword">while</span> ((c = h.cowait) != <span class="literal">null</span>) &#123;                <span class="keyword">if</span> (U.compareAndSwapObject(h, WCOWAIT, c, c.cowait) &amp;&amp;                    (w = c.thread) != <span class="literal">null</span>)                    U.unpark(w);  <span class="comment">// 唤醒等待线程</span>            &#125;        &#125;        <span class="keyword">if</span> (whead == h) &#123;            <span class="keyword">if</span> ((np = node.prev) != p) &#123;                <span class="keyword">if</span> (np != <span class="literal">null</span>)                    (p = np).next = node;   <span class="comment">// 更新前驱节点的 next 指针</span>            &#125;            <span class="keyword">else</span> <span class="keyword">if</span> ((ps = p.status) == <span class="number">0</span>)                U.compareAndSwapInt(p, WSTATUS, <span class="number">0</span>, WAITING);  <span class="comment">// 设置节点状态为等待</span>            <span class="keyword">else</span> <span class="keyword">if</span> (ps == CANCELLED) &#123;                <span class="keyword">if</span> ((pp = p.prev) != <span class="literal">null</span>) &#123;                    node.prev = pp;                    pp.next = node;  <span class="comment">// 更新前驱节点的 next 指针</span>                &#125;            &#125;            <span class="keyword">else</span> &#123;                <span class="type">long</span> time;                <span class="keyword">if</span> (deadline == <span class="number">0L</span>)                    time = <span class="number">0L</span>;                <span class="keyword">else</span> <span class="keyword">if</span> ((time = deadline - System.nanoTime()) &lt;= <span class="number">0L</span>)                    <span class="keyword">return</span> cancelWaiter(node, node, <span class="literal">false</span>);  <span class="comment">// 超时取消等待</span>                <span class="type">Thread</span> <span class="variable">wt</span> <span class="operator">=</span> Thread.currentThread();                U.putObject(wt, PARKBLOCKER, <span class="built_in">this</span>);                node.thread = wt;                <span class="keyword">if</span> (p.status &lt; <span class="number">0</span> &amp;&amp;                    (p != h || (state &amp; ABITS) == WBIT) &amp;&amp;                    whead == h &amp;&amp; node.prev == p)                    U.park(<span class="literal">false</span>, time);  <span class="comment">// 线程等待</span>                node.thread = <span class="literal">null</span>;                U.putObject(wt, PARKBLOCKER, <span class="literal">null</span>);                <span class="keyword">if</span> (interruptible &amp;&amp;</code></pre><p><strong>acquireRead 方法总结：</strong></p><ul><li><p><strong>目标：</strong> 在有竞争的情况下获取读锁，包括处理线程等待、队列管理、自旋等。</p></li><li><p><strong>acquireRead 的详细步骤：</strong></p><ul><li><p><strong>检查队列状态</strong></p><p>如果队列为空（whead &#x3D;&#x3D; wtail），尝试直接增加读锁计数（state）。如果成功，返回新的状态 ns。否则，进行自旋尝试。</p></li><li><p><strong>创建或管理节点</strong></p><p>如果队列为空，初始化一个新的头节点。如果节点 node 为空，则创建一个新的读节点。尝试将新的读节点添加到队列中，处理节点前驱和队列管理。</p></li><li><p><strong>处理自旋等待</strong></p><p>如果直接获取读锁失败，通过自旋等待的方式尝试获取读锁。</p></li><li><p><strong>处理线程等待</strong></p><p>如果自旋仍然失败，将线程放入等待队列中，处理中断和超时。</p></li><li><p><strong>唤醒等待线程</strong></p><p>当读锁被成功获取后，唤醒等待的线程。</p></li></ul></li></ul><h3 id="3-9-unlockRead方法"><a href="#3-9-unlockRead方法" class="headerlink" title="3.9 unlockRead方法"></a>3.9 unlockRead方法</h3><pre><code class="highlight java"><span class="comment">/**</span><span class="comment"> * 解锁读锁。</span><span class="comment"> * </span><span class="comment"> * 这个方法会验证提供的印章（`stamp`）是否与当前锁状态一致。如果印章无效或锁状态不匹配，会抛出 `IllegalMonitorStateException`。</span><span class="comment"> * 如果锁的读计数低于 `RFULL`，尝试通过 CAS 操作减少读计数。如果读计数减少到 0，则释放队列中可能被阻塞的线程。</span><span class="comment"> * 如果读计数达到了 `RFULL`，则调用 `tryDecReaderOverflow` 方法来处理溢出读线程计数。</span><span class="comment"> * </span><span class="comment"> * <span class="doctag">@param</span> stamp 读锁的印章值。</span><span class="comment"> * <span class="doctag">@throws</span> IllegalMonitorStateException 如果印章无效或状态不匹配。</span><span class="comment"> */</span><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">unlockRead</span><span class="params">(<span class="type">long</span> stamp)</span> &#123;    <span class="type">long</span> s, m; WNode h;    <span class="keyword">for</span> (;;) &#123;  <span class="comment">// 自旋</span>        <span class="comment">// 获取当前锁状态</span>        s = state;        <span class="comment">// 检查印章是否与当前状态匹配，或者印章是否有效</span>        <span class="keyword">if</span> (((s &amp; SBITS) != (stamp &amp; SBITS)) ||            (stamp &amp; ABITS) == <span class="number">0L</span> || (m = s &amp; ABITS) == <span class="number">0L</span> || m == WBIT)            <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">IllegalMonitorStateException</span>();  <span class="comment">// 印章无效，抛出异常</span>        <span class="keyword">if</span> (m &lt; RFULL) &#123;            <span class="comment">// 如果读计数小于 RFULL，尝试减少读计数</span>            <span class="keyword">if</span> (U.compareAndSwapLong(<span class="built_in">this</span>, STATE, s, s - RUNIT)) &#123;                <span class="comment">// 如果减少后读计数为 RUNIT 且队列头部节点状态不为 0，释放队列中的线程</span>                <span class="keyword">if</span> (m == RUNIT &amp;&amp; (h = whead) != <span class="literal">null</span> &amp;&amp; h.status != <span class="number">0</span>)                    release(h);                <span class="keyword">break</span>;            &#125;        &#125;        <span class="keyword">else</span> <span class="keyword">if</span> (tryDecReaderOverflow(s) != <span class="number">0L</span>)            <span class="keyword">break</span>;  <span class="comment">// 处理溢出的读者计数</span>    &#125;&#125;</code></pre><p><strong><code>unlockRead</code> 方法总结：</strong></p><ul><li><p><code>目标：</code>释放读锁，验证印章的有效性，并根据读锁计数的状态更新锁状态。</p></li><li><p><strong>步骤：</strong></p><ul><li><p>自旋检查印章有效性</p><p>进入自旋循环，获取当前锁状态 s。<br>检查传入的印章 stamp 是否与当前状态一致（通过比较 SBITS），以及印章是否有效（(stamp &amp; ABITS) &#x3D;&#x3D; 0L），或者当前状态是否无效（m &#x3D;&#x3D; WBIT）。<br>如果印章无效，抛出 IllegalMonitorStateException。</p></li><li><p>处理读计数</p><p>如果读计数小于 RFULL：<br>尝试通过 CAS 操作将状态 s 减少 RUNIT，即减少读锁计数。<br>如果读计数减少后为 RUNIT，并且队列头部节点状态不为 0，调用 release(h) 释放队列中的线程。<br>跳出循环，完成解锁。</p><p>如果读计数达到 RFULL：<br>调用 tryDecReaderOverflow 方法处理读计数溢出情况。</p></li><li><p>处理读计数溢出</p><p><code>tryDecReaderOverflow</code> 方法用于减少在 RFULL 状态下的溢出读线程计数。</p></li></ul></li></ul><h3 id="3-10-tryDecReaderOverflow方法"><a href="#3-10-tryDecReaderOverflow方法" class="headerlink" title="3.10 tryDecReaderOverflow方法"></a>3.10 tryDecReaderOverflow方法</h3><pre><code class="highlight java"><span class="comment">/**</span><span class="comment"> * 尝试减少溢出的读计数。</span><span class="comment"> * </span><span class="comment"> * 这个方法会处理在读锁计数达到 `RFULL` 后的溢出情况。如果当前状态的读计数已经达到 `RFULL`，</span><span class="comment"> * 通过 CAS 操作将状态更新为包含读位的值，并减少 `readerOverflow` 计数器。</span><span class="comment"> * 如果 `readerOverflow` 计数器为 0，则直接减少读计数。</span><span class="comment"> * </span><span class="comment"> * <span class="doctag">@param</span> s 当前锁状态。</span><span class="comment"> * <span class="doctag">@return</span> 更新后的状态值。如果无法减少读者计数，则返回 0L。</span><span class="comment"> */</span><span class="keyword">private</span> <span class="type">long</span> <span class="title function_">tryDecReaderOverflow</span><span class="params">(<span class="type">long</span> s)</span> &#123;    <span class="comment">// 确保当前状态的读位计数达到了 RFULL</span>    <span class="keyword">if</span> ((s &amp; ABITS) == RFULL) &#123;        <span class="comment">// 通过 CAS 操作将状态值更新为包含读位的状态</span>        <span class="keyword">if</span> (U.compareAndSwapLong(<span class="built_in">this</span>, STATE, s, s | RBITS)) &#123;            <span class="type">int</span> r; <span class="type">long</span> next;            <span class="keyword">if</span> ((r = readerOverflow) &gt; <span class="number">0</span>) &#123;                <span class="comment">// 如果溢出计数器大于 0，减少计数器并保持状态</span>                readerOverflow = r - <span class="number">1</span>;                next = s;            &#125;            <span class="keyword">else</span>                <span class="comment">// 否则，减少读锁计数</span>                next = s - RUNIT;            state = next;  <span class="comment">// 更新锁状态</span>            <span class="keyword">return</span> next;  <span class="comment">// 返回更新后的状态值</span>        &#125;    &#125;    <span class="keyword">else</span> <span class="keyword">if</span> ((LockSupport.nextSecondarySeed() &amp; OVERFLOW_YIELD_RATE) == <span class="number">0</span>)        Thread.<span class="keyword">yield</span>();  <span class="comment">// 在不能处理溢出时，让线程让步</span>    <span class="keyword">return</span> <span class="number">0L</span>;  <span class="comment">// 无法减少读者计数时返回 0L</span>&#125;</code></pre><p><strong>tryDecReaderOverflow方法总结：</strong></p><ul><li><p>目标： 处理在读锁计数达到上限时的溢出情况，确保锁状态的正确性。</p></li><li><p>步骤：</p><ul><li><p>检查读计数是否达到 RFULL：如果当前状态的读位计数等于 RFULL，则尝试更新状态以处理溢出情况。</p></li><li><p>更新状态：</p><p>通过 CAS 操作将状态更新为包含读位的状态<code>（s | RBITS）</code>。<br>如果 readerOverflow 计数器大于 0，减少计数器并保持状态。<br>如果 readerOverflow 为 0，减少读锁计数。<br>更新 state 变量，并返回更新后的状态值。</p></li><li><p>处理无法减少计数的情况：</p><p>如果无法处理溢出情况，让线程让步（Thread.yield()），并返回 0L。</p></li></ul></li></ul><h3 id="3-11-writeLock-方法"><a href="#3-11-writeLock-方法" class="headerlink" title="3.11 writeLock 方法"></a>3.11 writeLock 方法</h3><pre><code class="highlight java"><span class="comment">/**</span><span class="comment"> * 尝试获取写锁。</span><span class="comment"> * </span><span class="comment"> * 这个方法首先检查当前锁状态，如果当前没有读锁或写锁（`ABITS` 中没有任何标志位），</span><span class="comment"> * 直接通过 CAS 操作将状态更新为加上写锁位 `WBIT` 的新状态。如果更新成功，返回新的状态值。</span><span class="comment"> * 如果锁已被其他线程持有，或者队列中存在等待写锁的线程，则调用 `acquireWrite` 方法，</span><span class="comment"> * 通过排队的方式来获取写锁。</span><span class="comment"> * </span><span class="comment"> * <span class="doctag">@return</span> 成功获取的写锁印章。</span><span class="comment"> */</span><span class="keyword">public</span> <span class="type">long</span> <span class="title function_">writeLock</span><span class="params">()</span> &#123;    <span class="type">long</span> s, next;  <span class="comment">// 当前锁状态和新的状态</span>    <span class="comment">// 检查当前锁状态是否为完全解锁状态</span>    <span class="keyword">return</span> ((((s = state) &amp; ABITS) == <span class="number">0L</span> &amp;&amp;             U.compareAndSwapLong(<span class="built_in">this</span>, STATE, s, next = s + WBIT)) ?            next : acquireWrite(<span class="literal">false</span>, <span class="number">0L</span>));&#125;</code></pre><p><strong>writeLock 方法总结：</strong></p><ul><li><p>目标： writeLock 方法尝试直接获取写锁，如果失败则调用 acquireWrite 方法通过排队的方式获取写锁。</p></li><li><p>步骤：</p><ul><li><p>检查当前锁状态：</p><p>获取当前锁状态 s。<br>如果当前状态没有任何读锁或写锁（即 ABITS 中没有任何标志位），尝试通过 CAS 操作将状态更新为加上写锁位 WBIT 的新状态 next。</p></li><li><p>更新锁状态：</p><p>如果 CAS 操作成功，则返回新的状态值 next。</p></li><li><p>调用 acquireWrite：</p><p>如果状态更新失败（锁已被其他线程持有或队列中存在等待写锁的线程），调用 acquireWrite 方法来通过排队的方式获取写锁。</p></li></ul></li></ul><h3 id="3-12-acquireWrite方法"><a href="#3-12-acquireWrite方法" class="headerlink" title="3.12 acquireWrite方法"></a>3.12 acquireWrite方法</h3><pre><code class="highlight java"><span class="comment">/**</span><span class="comment"> * 尝试获取写锁。</span><span class="comment"> * </span><span class="comment"> * 这个方法通过自旋和排队的方式获取写锁。如果直接获取写锁失败，则将当前线程排入等待队列，</span><span class="comment"> * 并在队列中等待直到能够获取写锁。</span><span class="comment"> * </span><span class="comment"> * <span class="doctag">@param</span> interruptible 是否可中断。</span><span class="comment"> * <span class="doctag">@param</span> deadline 等待的最大时间（以纳秒为单位），0 表示不超时。</span><span class="comment"> * <span class="doctag">@return</span> 成功获取的写锁印章。</span><span class="comment"> */</span><span class="keyword">private</span> <span class="type">long</span> <span class="title function_">acquireWrite</span><span class="params">(<span class="type">boolean</span> interruptible, <span class="type">long</span> deadline)</span> &#123;    <span class="type">WNode</span> <span class="variable">node</span> <span class="operator">=</span> <span class="literal">null</span>, p;    <span class="comment">// 自旋尝试将当前线程排入等待队列</span>    <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">spins</span> <span class="operator">=</span> -<span class="number">1</span>;;) &#123; <span class="comment">// 自旋，直到将节点加入队列</span>        <span class="type">long</span> m, s, ns;        <span class="comment">// 获取当前锁状态</span>        <span class="keyword">if</span> ((m = (s = state) &amp; ABITS) == <span class="number">0L</span>) &#123;            <span class="comment">// 如果当前没有读锁或写锁，通过 CAS 操作将状态更新为加上写锁位 WBIT</span>            <span class="keyword">if</span> (U.compareAndSwapLong(<span class="built_in">this</span>, STATE, s, ns = s + WBIT))                <span class="keyword">return</span> ns;  <span class="comment">// 返回更新后的状态值</span>        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (spins &lt; <span class="number">0</span>)            <span class="comment">// 如果当前状态为写锁且队列为空，设置自旋次数</span>            spins = (m == WBIT &amp;&amp; wtail == whead) ? SPINS : <span class="number">0</span>;        <span class="keyword">else</span> <span class="keyword">if</span> (spins &gt; <span class="number">0</span>) &#123;            <span class="comment">// 自旋，减少自旋次数</span>            <span class="keyword">if</span> (LockSupport.nextSecondarySeed() &gt;= <span class="number">0</span>)                --spins;        &#125; <span class="keyword">else</span> <span class="keyword">if</span> ((p = wtail) == <span class="literal">null</span>) &#123; <span class="comment">// 初始化队列</span>            <span class="type">WNode</span> <span class="variable">hd</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">WNode</span>(WMODE, <span class="literal">null</span>);            <span class="keyword">if</span> (U.compareAndSwapObject(<span class="built_in">this</span>, WHEAD, <span class="literal">null</span>, hd))                wtail = hd;        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (node == <span class="literal">null</span>)            <span class="comment">// 创建新的等待节点</span>            node = <span class="keyword">new</span> <span class="title class_">WNode</span>(WMODE, p);        <span class="keyword">else</span> <span class="keyword">if</span> (node.prev != p)            <span class="comment">// 确保节点的前驱节点正确</span>            node.prev = p;        <span class="keyword">else</span> <span class="keyword">if</span> (U.compareAndSwapObject(<span class="built_in">this</span>, WTAIL, p, node)) &#123;            <span class="comment">// 将当前节点加入队列</span>            p.next = node;            <span class="keyword">break</span>;  <span class="comment">// 成功将节点加入队列，退出自旋循环</span>        &#125;    &#125;    <span class="comment">// 自旋等待，直到获取写锁</span>    <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">spins</span> <span class="operator">=</span> -<span class="number">1</span>;;) &#123;        WNode h, np, pp;        <span class="type">int</span> ps;        <span class="comment">// 检查当前队列头节点</span>        <span class="keyword">if</span> ((h = whead) == p) &#123;            <span class="comment">// 如果当前节点是队列头节点，自旋等待写锁</span>            <span class="keyword">if</span> (spins &lt; <span class="number">0</span>)                spins = HEAD_SPINS;            <span class="keyword">else</span> <span class="keyword">if</span> (spins &lt; MAX_HEAD_SPINS)                spins &lt;&lt;= <span class="number">1</span>;            <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">k</span> <span class="operator">=</span> spins;;) &#123;                <span class="type">long</span> s, ns;                <span class="comment">// 获取当前锁状态</span>                <span class="keyword">if</span> (((s = state) &amp; ABITS) == <span class="number">0L</span>) &#123;                    <span class="comment">// 如果当前没有读锁或写锁，通过 CAS 操作更新状态</span>                    <span class="keyword">if</span> (U.compareAndSwapLong(<span class="built_in">this</span>, STATE, s, ns = s + WBIT)) &#123;                        <span class="comment">// 更新队列头部为当前节点</span>                        whead = node;                        node.prev = <span class="literal">null</span>;                        <span class="keyword">return</span> ns;  <span class="comment">// 返回新的状态值</span>                    &#125;                &#125; <span class="keyword">else</span> <span class="keyword">if</span> (LockSupport.nextSecondarySeed() &gt;= <span class="number">0</span> &amp;&amp;                         --k &lt;= <span class="number">0</span>)                    <span class="keyword">break</span>;  <span class="comment">// 超过自旋次数，退出循环</span>            &#125;        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (h != <span class="literal">null</span>) &#123; <span class="comment">// 帮助释放过时的等待节点</span>            WNode c;            Thread w;            <span class="keyword">while</span> ((c = h.cowait) != <span class="literal">null</span>) &#123;                <span class="keyword">if</span> (U.compareAndSwapObject(h, WCOWAIT, c, c.cowait) &amp;&amp;                    (w = c.thread) != <span class="literal">null</span>)                    U.unpark(w);            &#125;        &#125;        <span class="keyword">if</span> (whead == h) &#123;            <span class="keyword">if</span> ((np = node.prev) != p) &#123;                <span class="comment">// 更新链表，将当前节点插入到正确的位置</span>                <span class="keyword">if</span> (np != <span class="literal">null</span>)                    (p = np).next = node;   <span class="comment">// 处理过时的节点</span>            &#125; <span class="keyword">else</span> <span class="keyword">if</span> ((ps = p.status) == <span class="number">0</span>)                <span class="comment">// 如果节点状态为 0，设置为 WAITING</span>                U.compareAndSwapInt(p, WSTATUS, <span class="number">0</span>, WAITING);            <span class="keyword">else</span> <span class="keyword">if</span> (ps == CANCELLED) &#123;                <span class="comment">// 如果节点状态为 CANCELLED，处理取消的节点</span>                <span class="keyword">if</span> ((pp = p.prev) != <span class="literal">null</span>) &#123;                    node.prev = pp;                    pp.next = node;                &#125;            &#125; <span class="keyword">else</span> &#123;                <span class="comment">// 等待获取写锁</span>                <span class="type">long</span> time; <span class="comment">// 0 参数表示无超时</span>                <span class="keyword">if</span> (deadline == <span class="number">0L</span>)                    time = <span class="number">0L</span>;                <span class="keyword">else</span> <span class="keyword">if</span> ((time = deadline - System.nanoTime()) &lt;= <span class="number">0L</span>)                    <span class="comment">// 超过等待时间，取消等待</span>                    <span class="keyword">return</span> cancelWaiter(node, node, <span class="literal">false</span>);                <span class="type">Thread</span> <span class="variable">wt</span> <span class="operator">=</span> Thread.currentThread();                U.putObject(wt, PARKBLOCKER, <span class="built_in">this</span>);                node.thread = wt;                <span class="keyword">if</span> (p.status &lt; <span class="number">0</span> &amp;&amp; (p != h || (state &amp; ABITS) != <span class="number">0L</span>) &amp;&amp;                    whead == h &amp;&amp; node.prev == p)                    <span class="comment">// 如果条件满足，则使当前线程进入等待状态</span>                    U.park(<span class="literal">false</span>, time);  <span class="comment">// 模拟 LockSupport.park</span>                node.thread = <span class="literal">null</span>;                U.putObject(wt, PARKBLOCKER, <span class="literal">null</span>);                <span class="keyword">if</span> (interruptible &amp;&amp; Thread.interrupted())                    <span class="comment">// 如果线程被中断，取消等待</span>                    <span class="keyword">return</span> cancelWaiter(node, node, <span class="literal">true</span>);            &#125;        &#125;    &#125;&#125;</code></pre><p><strong>acquireWrite 方法总结：</strong></p><ul><li><p>目标： 负责处理排队、等待和自旋等复杂逻辑，确保在竞争条件下正确地获取写锁。</p></li><li><p>步骤：</p><ul><li><p>自旋排队:</p><p>方法开始时，尝试通过自旋的方式将当前线程排入等待队列。如果当前没有读锁或写锁，尝试直接获取写锁。如果无法直接获取写锁，初始化队列或创建新的等待节点，将其添加到队列中。</p></li><li><p>等待队列初始化:</p><p>如果队列为空，创建队列头节点，并将尾节点指向该头节点。若节点已经存在，则创建新的节点并将其加入队列。</p></li><li><p>自旋等待写锁:</p><p>在自旋阶段，尝试检查队列头节点并自旋等待写锁。更新队列头节点为当前节点，确保其他线程能够正确地获取写锁。</p></li><li><p>处理过时的等待节点:</p><p>在等待期间，帮助释放已经过时的等待节点，并唤醒那些被阻塞的线程。</p></li><li><p>等待获取写锁:</p><p>如果条件允许，将当前线程进入等待状态，直到写锁可用。支持中断处理，如果线程被中断则取消等待。</p></li></ul></li></ul><h3 id="3-13-unlockWrite方法"><a href="#3-13-unlockWrite方法" class="headerlink" title="3.13 unlockWrite方法"></a>3.13 unlockWrite方法</h3><pre><code class="highlight java"><span class="comment">/**</span><span class="comment"> * 解锁写锁。</span><span class="comment"> * </span><span class="comment"> * 这个方法会验证提供的印章（`stamp`）是否为当前锁的写锁印章。如果印章无效或不是写锁印章，会抛出 `IllegalMonitorStateException`。</span><span class="comment"> * 成功解锁后，将状态重置为原始值 `ORIGIN`（如果 `stamp` 变为 0L），或者恢复为提供的印章加上写锁位 `WBIT`。</span><span class="comment"> * 如果队列头部节点（`whead`）不为空且状态不为 0，则调用 `release` 方法释放队列中可能被阻塞的线程。</span><span class="comment"> * </span><span class="comment"> * <span class="doctag">@param</span> stamp 写锁的印章值。</span><span class="comment"> * <span class="doctag">@throws</span> IllegalMonitorStateException 如果印章无效或不是写锁印章。</span><span class="comment"> */</span><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">unlockWrite</span><span class="params">(<span class="type">long</span> stamp)</span> &#123;    WNode h;    <span class="comment">// 验证提供的印章是否与当前锁状态匹配，并且是写锁印章</span>    <span class="keyword">if</span> (state != stamp || (stamp &amp; WBIT) == <span class="number">0L</span>)        <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">IllegalMonitorStateException</span>();  <span class="comment">// 印章无效，抛出异常</span>    <span class="comment">// 更新锁状态。如果解锁后状态为 0L，重置为原始值 ORIGIN</span>    state = (stamp += WBIT) == <span class="number">0L</span> ? ORIGIN : stamp;        <span class="comment">// 如果队列头部节点不为空且状态不为 0，释放队列中的线程</span>    <span class="keyword">if</span> ((h = whead) != <span class="literal">null</span> &amp;&amp; h.status != <span class="number">0</span>)        release(h);&#125;</code></pre><p><strong>unlockWrite方法总结：</strong></p><ul><li><p>目标： 安全地释放持有的写锁，并确保相关线程被正确唤醒。</p></li><li><p>步骤：</p><ul><li><p>验证印章:</p><p>首先，方法会检查提供的印章是否与当前锁状态匹配，且印章是否包含写锁位 (WBIT)。如果不匹配或不包含写锁位，抛出 IllegalMonitorStateException。</p></li><li><p>更新锁状态:</p><p>如果印章有效，解锁后将状态重置为原始值 ORIGIN（如果 stamp 加上 WBIT 结果为 0L），否则将状态更新为印章加上 WBIT。这个操作确保锁的状态正确反映当前的锁持有情况。</p></li><li><p>释放阻塞线程:</p><p>检查队列头部节点 (whead) 是否存在且状态不为 0。如果存在，则调用 release 方法尝试释放队列中的线程。</p></li></ul></li></ul><h3 id="3-14-release方法"><a href="#3-14-release方法" class="headerlink" title="3.14 release方法"></a>3.14 release方法</h3><pre><code class="highlight java"><span class="comment">/**</span><span class="comment"> * 释放队列中阻塞的线程。</span><span class="comment"> * </span><span class="comment"> * 这个方法会尝试从队列中找到下一个需要被唤醒的节点（`WNode`）。</span><span class="comment"> * 将队列头部节点的状态从 `WAITING` 更新为 0（表示节点不再等待）。</span><span class="comment"> * 如果队列中的下一个节点（`q`）存在且状态不为 `CANCELLED`，唤醒线程。</span><span class="comment"> * </span><span class="comment"> * <span class="doctag">@param</span> h 队列中的头部节点。</span><span class="comment"> */</span><span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">release</span><span class="params">(WNode h)</span> &#123;    <span class="keyword">if</span> (h != <span class="literal">null</span>) &#123;        WNode q; Thread w;        <span class="comment">// 更新队列头部节点的状态为 0</span>        U.compareAndSwapInt(h, WSTATUS, WAITING, <span class="number">0</span>);                <span class="comment">// 查找下一个需要被唤醒的节点（如果下一个节点为空或者状态为 CANCELLED）</span>        <span class="keyword">if</span> ((q = h.next) == <span class="literal">null</span> || q.status == CANCELLED) &#123;            <span class="keyword">for</span> (<span class="type">WNode</span> <span class="variable">t</span> <span class="operator">=</span> wtail; t != <span class="literal">null</span> &amp;&amp; t != h; t = t.prev)                <span class="keyword">if</span> (t.status &lt;= <span class="number">0</span>)                    q = t;        &#125;                <span class="comment">// 如果找到的节点存在且线程不为空，唤醒线程</span>        <span class="keyword">if</span> (q != <span class="literal">null</span> &amp;&amp; (w = q.thread) != <span class="literal">null</span>)            U.unpark(w);    &#125;&#125;</code></pre><p><strong>release方法总结：</strong></p><ul><li><p>目标： 从队列中释放阻塞的线程，并确保下一个等待的线程被正确唤醒。</p></li><li><p>步骤：</p><ul><li><p>更新节点状态:</p><p>将队列头部节点的状态从 WAITING 更新为 0，表示该节点不再需要等待。此操作标志着头部节点已处理完毕，准备释放或处理下一个节点。</p></li><li><p>查找并设置下一个待唤醒的节点:</p><p>如果头部节点的下一个节点为空或状态为 CANCELLED，从队列尾部向前查找有效的待唤醒节点。这样可以确保唤醒操作的正确性，并避免唤醒已取消或不再需要的线程。</p></li><li><p>唤醒线程:</p><p>如果找到有效的待唤醒节点，并且该节点关联的线程不为空，则唤醒该线程。通过调用 U.unpark(w)，可以确保线程能够继续执行，减少系统中的线程阻塞时间。</p></li></ul></li></ul><h2 id="4-StampedLock管理线程的队列"><a href="#4-StampedLock管理线程的队列" class="headerlink" title="4. StampedLock管理线程的队列"></a>4. StampedLock管理线程的队列</h2><p>StampedLock内部基于<code>WNode</code>实现的阻塞队列和AQS实现的阻塞队列类似。<br>初始化时，新建个空节点，<code>whead=wtail=NULL</code> 。</p><p><img src="https://raw.githubusercontent.com/GeorgeChan95/blogimg/master/img/2024/10/19/20241019-164228.png" alt="队列初始化"></p><p>之后再往里面加入一个个读线程或写线程节点。</p><p>但是上面<code>acquireRead</code>和<code>acquireWrite</code>方法对于自旋的操作就和AQS有很大不同了。</p><p>在AQS里面，当一个线程CAS state失败之后，会立即加入阻塞队列，并且进入阻塞状态。但在StampedLock中，CAS state失败之后，会不断自旋，自旋足够多的次数之后，如果还拿不到锁，才进入阻塞状态。为此，根据CPU的核数，定义了自旋次数的常量值。如果是单核的CPU，肯定不能自旋，在多核情况下，才采用自旋策略。</p><p>还有个比较特殊的地方在于，每个WNode里面有一个cowait指针，用于串联起所有的读线程。<br>例如，队列尾部阻塞的是一个读线程 1，现在又来了读线程 2、3，那么会通过cowait指针，把1、2、3串联起来。1被唤醒之后，2、3也随之一起被唤醒，因为读和读之间不互斥。</p><p>也就是当入队一个线程时，如果队尾是写结点，则直接链接到队尾。<br>当入队一个读线程时，如果队尾是读节点，则直接链接到该读结点的cowait链中。</p><p><img src="https://raw.githubusercontent.com/GeorgeChan95/blogimg/master/img/2024/10/19/20241019-164402.png" alt="节点进入队列"></p><h1 id="四、StampedLock和ReentrantReadWriteLock对比"><a href="#四、StampedLock和ReentrantReadWriteLock对比" class="headerlink" title="四、StampedLock和ReentrantReadWriteLock对比"></a>四、StampedLock和ReentrantReadWriteLock对比</h1><table><thead><tr><th>特性</th><th><code>StampedLock</code></th><th><code>ReentrantReadWriteLock</code></th></tr></thead><tbody><tr><td><strong>引入版本</strong></td><td>JDK 8</td><td>JDK 5</td></tr><tr><td><strong>锁类型</strong></td><td>提供乐观读锁、悲观读锁和写锁</td><td>提供悲观读锁和写锁</td></tr><tr><td><strong>乐观读锁</strong></td><td>支持（<code>tryOptimisticRead()</code>）</td><td>不支持</td></tr><tr><td><strong>悲观读锁</strong></td><td>支持（<code>readLock()</code>）</td><td>支持（<code>readLock()</code>）</td></tr><tr><td><strong>写锁</strong></td><td>支持（<code>writeLock()</code>）</td><td>支持（<code>writeLock()</code>）</td></tr><tr><td><strong>锁升级</strong></td><td>支持从乐观读锁升级到悲观读锁或写锁（<code>tryConvertToWriteLock()</code>等）</td><td>不支持</td></tr><tr><td><strong>锁降级</strong></td><td>支持从写锁降级为读锁（<code>tryConvertToReadLock()</code>）</td><td>支持从写锁降级为读锁</td></tr><tr><td><strong>锁管理复杂度</strong></td><td>复杂，需要管理戳记，确保在转换锁时一致性</td><td>相对简单，直接使用 <code>readLock()</code> 和 <code>writeLock()</code></td></tr><tr><td><strong>性能优化</strong></td><td>乐观读锁减少了锁竞争，提高了读取性能</td><td>读写锁性能依赖于锁的竞争情况(大量并发读可能会导致写线程饥饿)</td></tr><tr><td><strong>公平性</strong></td><td>不提供公平性（锁的获取是非公平的）</td><td>可以选择公平性（通过构造函数 <code>ReentrantReadWriteLock(true)</code>）</td></tr><tr><td><strong>条件变量<code>Condition</code></strong></td><td>不支持</td><td>支持</td></tr></tbody></table><p><strong>总结</strong></p><p><strong><code>StampedLock</code></strong> 适用于需要高效读取性能的场景，通过乐观读锁减少锁竞争，同时支持锁的升级和降级，但锁的管理相对复杂，不支持重入，并且使用乐观读锁时需要遵循一定的顺序，所以使用时一定要谨慎。</p><p><strong>参考链接：</strong></p><blockquote><p><a href="https://blog.csdn.net/qq_37883866/article/details/140664358">https://blog.csdn.net/qq_37883866/article/details/140664358</a></p></blockquote>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;一、锁的演变&quot;&gt;&lt;a href=&quot;#一、锁的演变&quot; class=&quot;headerlink&quot; title=&quot;一、锁的演变&quot;&gt;&lt;/a&gt;一、锁的演变&lt;/h1&gt;&lt;p&gt;无锁  –&amp;gt; 独占锁  –&amp;gt; 读写锁  –&amp;gt; 邮戳锁&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;p&gt;无锁</summary>
      
    
    
    
    <category term="JUC" scheme="https://georgechan95.github.io/categories/JUC/"/>
    
    
    <category term="juc" scheme="https://georgechan95.github.io/tags/juc/"/>
    
    <category term="java" scheme="https://georgechan95.github.io/tags/java/"/>
    
  </entry>
  
  <entry>
    <title>Docker部署Neo4j并导入CSV数据</title>
    <link href="https://georgechan95.github.io/blog/5c93903a.html"/>
    <id>https://georgechan95.github.io/blog/5c93903a.html</id>
    <published>2024-10-17T07:00:30.000Z</published>
    <updated>2024-10-18T09:09:53.466Z</updated>
    
    <content type="html"><![CDATA[<p><strong>系统环境</strong></p><blockquote><p>操作系统：Ubuntu18.04.6</p><p>Docker：24.0.2</p><p>Neo4j: 3.5.35(社区版)</p></blockquote><h1 id="一、下载并启动Neo4j"><a href="#一、下载并启动Neo4j" class="headerlink" title="一、下载并启动Neo4j"></a>一、下载并启动Neo4j</h1><h2 id="1-修改Docker配置文件"><a href="#1-修改Docker配置文件" class="headerlink" title="1. 修改Docker配置文件"></a>1. 修改Docker配置文件</h2><p>neo4j镜像在国外服务器，国内直接pull会超时失败，这里需要配置一下代理。</p><pre><code class="highlight shell"><span class="meta prompt_"># </span><span class="language-bash">创建docker默认的配置文件路径</span>mkdir -p /etc/docker<span class="meta prompt_"></span><span class="meta prompt_"># </span><span class="language-bash">内容如下：直接拷贝粘贴</span>tee /etc/docker/daemon.json &lt;&lt;-&#x27;EOF&#x27;&#123;&quot;registry-mirrors&quot;: [&quot;https://docker-proxy.741001.xyz&quot;,&quot;https://registry.docker-cn.com&quot;]&#125;EOF<span class="meta prompt_"></span><span class="meta prompt_"># </span><span class="language-bash">重启docker服务</span>systemctl daemon-reloadsystemctl restart docker</code></pre><h2 id="2-启动neo4j"><a href="#2-启动neo4j" class="headerlink" title="2. 启动neo4j"></a>2. 启动neo4j</h2><ul><li><p>拉取镜像</p><pre><code class="highlight shell"><span class="meta prompt_"># </span><span class="language-bash">拉取镜像</span>docker pull neo4j:3.5.35<span class="meta prompt_"></span><span class="meta prompt_"># </span><span class="language-bash">查看本地镜像，检验是否拉取成功</span>docker images</code></pre></li><li><p>创建挂载目录</p><pre><code class="highlight shell">mkdir -p /opt/module /opt/softwaremkdir -p /opt/module/neo4jcd /opt/module/neo4j/mkdir -p data logs conf import plugins</code></pre></li><li><p>启动容器</p><pre><code class="highlight shell">docker run -itd \    --name neo4j \    -p 7474:7474 -p 7687:7687 \    -v /opt/module/neo4j/data:/data \    -v /opt/module/neo4j/logs:/logs \    -v /opt/module/neo4j/conf:/var/lib/neo4j/conf \    -v /opt/module/neo4j/import:/var/lib/neo4j/import \    -v /opt/module/neo4j/plugins:/var/lib/neo4j/plugins \    --env NEO4J_AUTH=neo4j/123456 \    --restart=always \    neo4j:3.5.35</code></pre><ul><li><p>命令解析</p><pre><code class="highlight shell">docker run -itd --name container_name \  //-d表示容器后台运行 --name指定容器名字-p 7474:7474 -p 7687:7687 \  //映射容器的端口号到宿主机的端口号-v /opt/module/neo4j/data:/data \  //把容器内的数据目录挂载到宿主机的对应目录下-v /opt/module/neo4j/logs:/logs \  //挂载日志目录-v /opt/module/neo4j/conf:/var/lib/neo4j/conf   //挂载配置目录-v /opt/module/neo4j/import:/var/lib/neo4j/import \  //挂载数据导入目录-v /opt/module/neo4j/plugins:/var/lib/neo4j/plugins \ // neo4j插件安装目录--env NEO4J_AUTH=neo4j/123456 \  //设定数据库的名字的访问密码--restart=always \ // 设置开机自启neo4j:3.5.35 //指定使用的镜像</code></pre></li></ul><p>挂载目录可根据实际情况替换，neo4j密码不设置，默认为：<code>neo4j</code>,  这里设置成：<code>123456</code> 。如果希望neo4j没有密码，</p><p>可以使用命令：<code>--env NEO4J_AUTH=none</code></p></li></ul><h2 id="3-浏览器访问测试"><a href="#3-浏览器访问测试" class="headerlink" title="3. 浏览器访问测试"></a>3. 浏览器访问测试</h2><p>浏览器访问地址：<a href="http://neo4j服务地址:7474/">http://Neo4j服务地址:7474</a></p><ul><li>数据库默认用户名：neo4j</li><li>密码：启动命令设置的密码</li></ul><p><img src="https://raw.githubusercontent.com/GeorgeChan95/blogimg/master/img/2024/10/17/20241017-162812.png" alt="登录Neo4j"></p><h2 id="4-Neo4j配置文件解读"><a href="#4-Neo4j配置文件解读" class="headerlink" title="4. Neo4j配置文件解读"></a>4. Neo4j配置文件解读</h2><p>宿主机目录：<code>/opt/module/neo4j/conf/neo4j.conf</code></p><p>启动后，配置文件会自动创建到挂在目录，默认内容如下：</p><pre><code class="highlight shell"><span class="meta prompt_"># </span><span class="language-bash">事务保留策略，超过100MB会进行轮换</span>dbms.tx_log.rotation.retention_policy=100M size<span class="meta prompt_"># </span><span class="language-bash">设置了 Neo4j 的页面缓存大小为 512MB，页面缓存用于存储从磁盘加载到内存中的节点和关系数据，以提高数据库查询的性能。</span>dbms.memory.pagecache.size=512M<span class="meta prompt_"></span><span class="meta prompt_"># </span><span class="language-bash">允许任何ip连接到数据库</span>dbms.connectors.default_listen_address=0.0.0.0<span class="meta prompt_"># </span><span class="language-bash">https请求的监听 地址:端口</span>dbms.connector.https.listen_address=0.0.0.0:7473<span class="meta prompt_"></span><span class="meta prompt_"># </span><span class="language-bash">http请求的监听 地址:端口</span>dbms.connector.http.listen_address=0.0.0.0:7474<span class="meta prompt_"># </span><span class="language-bash">bolt请求的监听 地址:端口</span>dbms.connector.bolt.listen_address=0.0.0.0:7687<span class="meta prompt_"># </span><span class="language-bash">这是一个 Java 运行时参数，表明 Neo4j 是运行在 Docker 环境下的</span>wrapper.java.additional=-Dneo4j.ext.udc.source=docker<span class="meta prompt_"># </span><span class="language-bash">指定了 Neo4j 日志文件的存储目录为 /logs</span>dbms.directories.logs=/logs</code></pre><h1 id="二、CSV数据的导入导出"><a href="#二、CSV数据的导入导出" class="headerlink" title="二、CSV数据的导入导出"></a>二、CSV数据的导入导出</h1><h2 id="1-数据准备"><a href="#1-数据准备" class="headerlink" title="1. 数据准备"></a>1. 数据准备</h2><p>上面只是通过docker启动了一个Neo4j数据库实例，此时还没有数据，在演示neo4j数据的导入、导出之前，需要先模拟一些数据到Neo4j中。</p><pre><code class="highlight shell"><span class="meta prompt_"># </span><span class="language-bash">删除所有的节点和关系</span> MATCH(n) OPTIONAL MATCH (n)-[r]-() DELETE n,r;<span class="meta prompt_">  </span><span class="meta prompt_"># </span><span class="language-bash">创建Person 的节点</span> CREATE (person:Person &#123;cid:1,name:&quot;范闲&quot;,age:24,gender:0,character:&quot;A&quot;,money:1000,description:&quot;范闲，是猫腻小说《庆余年》主人公，穿越人士，庆国数十年风雨画卷的见证者。其容貌俊美无双，尤胜于女子，生性淡薄刚毅，善良而腹黑，城府极深，重视恩情。最终隐居江南&quot;&#125;);CREATE (person:Person &#123;cid:2,name:&quot;林婉儿&quot;,age:20,gender:1,character:&quot;B&quot;,money:800,description:&quot;林婉儿是庆国宰相和长公主的私生女，电视剧《庆余年》里的女主人公，由李沁饰演&quot;&#125;);CREATE (person:Person &#123;cid:3,name:&quot;庆帝&quot;,age:49,gender:0,character:&quot;A&quot;,money:8900,description:&quot;庆帝，网文作家猫腻所著的权谋小说《庆余年》的角色之一，南庆国的皇帝，心中装有天下统一&quot;&#125;);CREATE (person:Person &#123;cid:4,name:&quot;长公主&quot;,age:46,gender:1,character:&quot;B&quot;,money:3700,description:&quot;《庆余年》中,长公主这个人不仅人设很复杂,就连她的感情生活还是挺复杂。长公主所处的身份就是庆国的公主,皇帝的妹妹,太子的姑姑,国家重要财权的掌管,林婉儿的母亲&quot;&#125;);CREATE (person:Person &#123;cid:5,name:&quot;宰相林若甫&quot;,age:47,gender:0,character:&quot;A&quot;,money:1600,description:&quot;林若甫，是电视剧《庆余年》登场的虚拟人物之一，南庆当朝宰相，林婉儿的亲生父亲。&quot;&#125;);CREATE (person:Person &#123;cid:6,name:&quot;叶灵儿&quot;,age:20,gender:1,character:&quot;C&quot;,money:700,description:&quot;叶灵儿，网文作家猫腻所著的权谋小说《庆余年》的角色之一，林婉儿的好友，最后嫁给了二皇子&quot;&#125;);CREATE (person:Person &#123;cid:7,name:&quot;九品射手燕小乙&quot;,age:47,gender:0,character:&quot;C&quot;,money:900,description:&quot;一品最低,九品最高。庆帝身边的燕小乙便是九品,而且是庆国独一无二的神射手,臂力、眼力、听力惊人&quot;&#125;);CREATE (person:Person &#123;cid:8,name:&quot;二皇子&quot;,age:26,gender:0,character:&quot;B&quot;,money:1700,description:&quot;《庆余年》中,二皇子结局自杀身亡。二皇子对庆帝也是意见很大,但以他的实力还掀不起什么水花,所以只能慢慢等待时机&quot;&#125;);CREATE (person:Person &#123;cid:9,name:&quot;靖王世子&quot;,age:25,gender:0,character:&quot;A&quot;,money:1600,description:&quot;在《庆余年》中,此靖王非彼靖王,但是同音之美也会让人会对靖王世子李弘成这个角色产生好感,而靖王世子李弘成的出场的确是帮助了范闲逃脱太子势力的纠缠&quot;&#125;);CREATE (person:Person &#123;cid:10,name:&quot;王启年&quot;,age:46,gender:0,character:&quot;C&quot;,money:1700,description:&quot;王启年，网文作家猫腻所著的权谋小说《庆余年》的角色之一，庆国监察院一处的文书，擅长追踪之术。&quot;&#125;);CREATE (person:Person &#123;cid:11,name:&quot;北齐圣女海棠朵朵&quot;,age:21,gender:1,character:&quot;A&quot;,money:2600,description:&quot;海棠朵朵是北齐国的才女,被人尊称为圣女,而且是北齐大宗师苦荷的关门弟子,在北齐国也算是举足轻重的人物&quot;&#125;);CREATE (person:Person &#123;cid:12,name:&quot;北齐小皇帝战豆豆&quot;,age:20,gender:0,character:&quot;A&quot;,money:4600,description:&quot;很多人想知道剧中的北齐小皇帝是谁呢?让小编告诉你们吧。 战豆豆是北齐第二任皇帝,乃前北魏一代大将战清风之孙,大宗师苦荷的叔侄女兼徒孙&quot;&#125;);<span class="meta prompt_"></span><span class="meta prompt_"># </span><span class="language-bash">创建关系</span> match(person:Person &#123;name:&quot;范闲&quot;&#125;),(person2:Person &#123;name:&quot;林婉儿&quot;&#125;) create(person)-[r:Couple]-&gt;(person2);match(person:Person &#123;name:&quot;范闲&quot;&#125;),(person2:Person &#123;name:&quot;王启年&quot;&#125;) create(person)-[r:Friends]-&gt;(person2);match(person:Person &#123;name:&quot;范闲&quot;&#125;),(person2:Person &#123;name:&quot;北齐圣女海棠朵朵&quot;&#125;) create(person)-[r:Friends]-&gt;(person2);match(person:Person &#123;name:&quot;范闲&quot;&#125;),(person2:Person &#123;name:&quot;庆帝&quot;&#125;) create(person)-[r:Father]-&gt;(person2);match(person:Person &#123;name:&quot;范闲&quot;&#125;),(person2:Person &#123;name:&quot;长公主&quot;&#125;) create(person)-[r:Wife_Mother]-&gt;(person2);match(person:Person &#123;name:&quot;庆帝&quot;&#125;),(person2:Person &#123;name:&quot;二皇子&quot;&#125;) create(person)-[r:Son]-&gt;(person2);match(person:Person &#123;name:&quot;庆帝&quot;&#125;),(person2:Person &#123;name:&quot;长公主&quot;&#125;) create(person)-[r:BrotherSister]-&gt;(person2);match(person:Person &#123;name:&quot;二皇子&quot;&#125;),(person2:Person &#123;name:&quot;靖王世子&quot;&#125;) create(person)-[r:Friends]-&gt;(person2);match(person:Person &#123;name:&quot;北齐圣女海棠朵朵&quot;&#125;),(person2:Person &#123;name:&quot;北齐小皇帝战豆豆&quot;&#125;) create(person)-[r:Friends]-&gt;(person2);match(person:Person &#123;name:&quot;林婉儿&quot;&#125;),(person2:Person &#123;name:&quot;叶灵儿&quot;&#125;) create(person)-[r:Friends]-&gt;(person2);match(person:Person &#123;name:&quot;林婉儿&quot;&#125;),(person2:Person &#123;name:&quot;宰相林若甫&quot;&#125;) create(person)-[r:Father]-&gt;(person2);match(person:Person &#123;name:&quot;林婉儿&quot;&#125;),(person2:Person &#123;name:&quot;长公主&quot;&#125;) create(person)-[r:Mother]-&gt;(person2);match(person:Person &#123;name:&quot;长公主&quot;&#125;),(person2:Person &#123;name:&quot;九品射手燕小乙&quot;&#125;) create(person)-[r:Friends]-&gt;(person2);</code></pre><p>将上面的CQL语句，复制到Neo4j执行语句输入框中，注意：不能有注释内容。</p><p><img src="https://raw.githubusercontent.com/GeorgeChan95/blogimg/master/img/2024/10/17/20241017-184620.png" alt="Neo4j数据初始化"></p><h2 id="2-安装-apoc-插件"><a href="#2-安装-apoc-插件" class="headerlink" title="2. 安装 apoc 插件"></a>2. 安装 apoc 插件</h2><p>APOC（Awesome Procedures on Cypher）是Neo4j图数据库的一个插件，它提供了一组强大的过程和函数，扩展了Cypher查询语言的功能。APOC可以帮助你进行更高级的数据处理和操作，例如导入和导出数据、动态创建节点和关系、执行事务操作等。</p><p>使用APOC插件需要先下载并安装它，然后在Neo4j的配置文件中启用它。一旦启用，你就可以在Cypher查询中使用APOC提供的各种过程和函数了。</p><h3 id="2-1-下载插件"><a href="#2-1-下载插件" class="headerlink" title="2.1  下载插件"></a>2.1  下载插件</h3><p>neo4j这里使用的是 3.5社区版，所以 apoc 插件也选择3.5版本的。</p><p>下载地址：<a href="https://github.com/neo4j-contrib/neo4j-apoc-procedures/releases">https://github.com/neo4j-contrib/neo4j-apoc-procedures/releases</a></p><p>找到对应的版本后，下载到服务器的 plugins 文件夹中</p><p><img src="https://raw.githubusercontent.com/GeorgeChan95/blogimg/master/img/2024/10/17/20241017-190711.png" alt="apoc插件下载"></p><p>Neo4j的插件安装目录在 <code>plugins</code> 路径下，Docker部署Neo4j时，将宿主机 <code>/opt/module/neo4j/plugins</code> 目录映射到了neo4j的插件安装目录： <code>/var/lib/neo4j/plugins</code>， 因此需要将 apoc 插件下载到此目录中，无需解压。</p><pre><code class="highlight shell">root@csg-pc1:/opt/module/neo4j/plugins# pwd/opt/module/neo4j/pluginsroot@csg-pc1:/opt/module/neo4j/plugins# lsapoc-3.5.0.21-all.jar<span class="meta prompt_"></span><span class="meta prompt_"># </span><span class="language-bash">修改插件jar包的权限(添加执行权限)</span>chmod 755 apoc-3.5.0.21-all.jar</code></pre><h3 id="2-2-修改配置文件"><a href="#2-2-修改配置文件" class="headerlink" title="2.2 修改配置文件"></a>2.2 修改配置文件</h3><p>修改neo4j配置文件 <code>neo4j.conf</code> , 修改内容如下：</p><pre><code class="highlight shell"><span class="meta prompt_"># </span><span class="language-bash">neo4j插件安装路径</span>dbms.directories.plugins=plugins<span class="meta prompt_"># </span><span class="language-bash">配置安全白名单，指定允许所有apoc开头的存储过程</span>dbms.security.procedures.whitelist=apoc.coll.*,apoc.load.*,apoc.*,gds.*<span class="meta prompt_"># </span><span class="language-bash">放宽apoc权限</span>dbms.security.procedures.unrestricted=apoc.*,algo.*<span class="meta prompt_"># </span><span class="language-bash">指定了 Neo4j 的数据导入目录</span>dbms.directories.import=import<span class="meta prompt_"># </span><span class="language-bash">开启文件导出功能</span>apoc.export.file.enabled=true<span class="meta prompt_"># </span><span class="language-bash">开启文件导入功能</span>apoc.import.file.enabled=true</code></pre><h3 id="2-3-测试apoc插件是否安装-成功"><a href="#2-3-测试apoc插件是否安装-成功" class="headerlink" title="2.3  测试apoc插件是否安装 成功"></a>2.3  测试apoc插件是否安装 成功</h3><p>在浏览器中，执行 cypher-shell：</p><pre><code class="highlight cypher">return apoc.version();</code></pre><p><img src="https://raw.githubusercontent.com/GeorgeChan95/blogimg/master/img/2024/10/17/20241017-192551.png" alt="验证插件安装"></p><h2 id="3-导出CSV数据"><a href="#3-导出CSV数据" class="headerlink" title="3. 导出CSV数据"></a>3. 导出CSV数据</h2><h3 id="3-1-开始导出"><a href="#3-1-开始导出" class="headerlink" title="3.1 开始导出"></a>3.1 开始导出</h3><p>neo4j 官方文档有说明，使用 neo4j-admin restore &#x2F; dump 导出和恢复数据库的时候需要停掉数据，否则会报数据库正在使用的错误：</p><blockquote><p>command failed: the database is in use — stop Neo4j and try again</p></blockquote><p>但问题是docker容器中是没办法停止neo4j进程的，现在进入容器shudown的话，neo4j容器会停掉（docker-run）或者重启数据库（docker-compose），所以这里采用的迂回的方法：</p><ul><li><p>首先停掉neo4j容器</p><pre><code class="highlight shell">docker stop neo4j</code></pre></li><li><p>启动一个带有TTY新的容器，使用-v参数挂载data目录</p><pre><code class="highlight shell">docker run -it \    --name neo4j-tmp \    -p 7474:7474 -p 7687:7687 \    -v /opt/module/neo4j/data:/data \    -v /opt/module/neo4j/conf:/var/lib/neo4j/conf \    -v /opt/module/neo4j/import:/var/lib/neo4j/import \    -v /opt/module/neo4j/plugins:/var/lib/neo4j/plugins \    --restart=always \    neo4j:3.5.35 /bin/bash</code></pre></li><li><p>以console方式启动neo4j容器</p><p>这里有个坑，如果不用 <code>console</code> 启动容器， 而是使用 <code>bin/neo4j start</code> 启动临时neo4j容器，导出的csv文件格式有问题，会导入不了。</p><pre><code class="highlight shell">bin/neo4j console</code></pre></li><li><p>导出CSV文件</p><p>在浏览器 Neo4j 的 <code>cypher-shell</code> 输入框中执行语句</p><ul><li><p>方式一：批量导出全部数据到一个csv文件中, 【强烈不建议】</p><pre><code class="highlight cypher">// 导出全部数据（包括了节点和关系）[这个不常用，了解就行]CALL apoc.export.csv.all(&quot;database-all-data.csv&quot;, &#123;&#125;);</code></pre></li><li><p>方式二：批量导出全部数据，但是会自动将 <code>节点数据</code> 和 <code>关系数据 </code> 自动分到不同到文件中 【本文采用的就是这种方式】</p></li></ul><pre><code class="highlight cypher">// 批量导出【建议用这个，亲测可行】CALL apoc.export.csv.all(  &quot;all.csv&quot;, // 文件名和类型，也可以是txt格式   &#123;     quotes:&#x27;none&#x27;, // 导出的文件中没有引号    useTypes:true, //  useTypes参数表明输出时是否表明type类型是node还是relationship    bulkImport:true, // 导出的数据，就按照nodes和relationships分开    delim: &quot;$&quot; // 指定导出数据分割符号   &#125;)</code></pre><ul><li><p>方式三：手动导出节点数据和关系数据</p><pre><code class="highlight cypher">// 导出所有节点数据，忽略关系MATCH (person:Person)WITH collect(person) AS peopleCALL apoc.export.csv.query(    &quot;MATCH (p:Person) RETURN id(p) AS `:ID`, p.name AS `name`, p.age AS `age:long`, p.cid AS `cid:long`, p.character AS `character`, p.money AS `money:long`, p.gender AS `gender:long`, p.description AS `description`, head(labels(p)) AS `:LABEL`&quot;,     &quot;all_nodes.csv&quot;, // 导出的文件&#123;    quotes:&#x27;none&#x27;, // 文件中没有引号    delim: &quot;$&quot;, // 指定导出数据的分割符号        useTypes:true, //  useTypes参数表明输出时是否表明type类型是node还是relationship        arrayDelim: &quot;;&quot;&#125;)YIELD file, source, format, nodes, relationships, properties, time, rows, batchSize, batches, done, dataRETURN file, source, format, nodes, relationships, properties, time, rows, batchSize, batches, done, data// 导出特定的关系数据，忽略节点MATCH (start)-[r:BrotherSister]-&gt;(end)WITH start, end, rCALL apoc.export.csv.query(    &quot;MATCH (start:Person)-[r:BrotherSister]-&gt;(end:Person) RETURN id(start) AS `:START_ID`, id(end) AS `:END_ID`, type(r) AS `:TYPE`&quot;,     &quot;BrotherSister.csv&quot;,&#123;    quotes:&#x27;none&#x27;, // 导出的文件中没有引号    useTypes:true, //  useTypes参数表明输出时是否表明type类型是node还是relationship    delim: &quot;$&quot; // 指定导出数据分割符号    &#125;)YIELD file, source, format, nodes, relationships, properties, time, rows, batchSize, batches, done, dataRETURN file, source, format, nodes, relationships, properties, time, rows, batchSize, batches, done, data</code></pre></li></ul></li></ul><p><img src="https://raw.githubusercontent.com/GeorgeChan95/blogimg/master/img/2024/10/17/20241017-192845.png" alt="导出所有数据"></p><p><img src="https://raw.githubusercontent.com/GeorgeChan95/blogimg/master/img/2024/10/18/20241018-141228.png" alt="导出全部数据，自动分割CSV文件"></p><h3 id="3-2-查看导出文件"><a href="#3-2-查看导出文件" class="headerlink" title="3.2 查看导出文件"></a>3.2 查看导出文件</h3><ul><li><p>导出文件在neo4j的 <code>import</code> 文件夹中，映射到宿主机：<code>/opt/module/neo4j/import</code> 路径，查看该路径：</p><pre><code class="highlight shell">root@csg-pc1:/opt/module/neo4j/import# pwd/opt/module/neo4j/importroot@csg-pc1:/opt/module/neo4j/import# lsall.nodes.Person.csvall.relationships.BrotherSister.csvall.relationships.Couple.csvall.relationships.Father.csvall.relationships.Friends.csvall.relationships.Mother.csvall.relationships.Son.csvall.relationships.Wife_Mother.csv</code></pre></li><li><p>查看CSV文件</p><p>虽然CSV文件可以用wps、office等工具查看和修改，但是还是如果需要修改的话，用 nodepad++、vsCode等相对简单的文本编辑工具，如果不小心修改了文件编码，或者wps等工具在保存时修改了格式，CSV文件导入就会报错。</p><p>文件要使用UTF-8编码，这也是默认的编码格式。</p><p><img src="https://raw.githubusercontent.com/GeorgeChan95/blogimg/master/img/2024/10/18/20241018-142107.png" alt="节点数据"></p><p><img src="https://raw.githubusercontent.com/GeorgeChan95/blogimg/master/img/2024/10/18/20241018-142132.png" alt="关系数据"></p></li></ul><h2 id="4-导入CSV数据"><a href="#4-导入CSV数据" class="headerlink" title="4. 导入CSV数据"></a>4. 导入CSV数据</h2><p>前面已经将neo4j数据导出到一个个 CSV 文件中了，导入数据也使用 APOC 插件，但是不需要在 <code>bin/neo4j console</code> 启动环境中导入。可以退出并删除临时容器，启动原有的 ne4j 容器。</p><ul><li><p>删除临时容器</p><pre><code class="highlight shell"><span class="meta prompt_"># </span><span class="language-bash">删除临时容器</span>docker rm -f neo4j-tmp</code></pre></li><li><p>启动原neo4j容器</p><pre><code class="highlight shell">docker start neo4j</code></pre></li><li><p>清空数据库</p><p>在浏览器 Neo4j 的 <code>cypher-shell</code> 输入框中执行语句</p><pre><code class="highlight cypher">MATCH(n) OPTIONAL MATCH (n)-[r]-() DELETE n,r;</code></pre></li><li><p>将导出的csv文件拷贝到neo4j的 import 文件夹中</p></li><li><p>使用 APOC 插件导入CSV文件</p><p>在浏览器 Neo4j 的 <code>cypher-shell</code> 输入框中执行语句</p><pre><code class="highlight shell"><span class="meta prompt_"># </span><span class="language-bash">方式一：批量导入节点和节点的关系【本文使用的导入方式】</span>CALL apoc.import.csv(  [  &#123;fileName: &#x27;file:/all.nodes.Person.csv&#x27;, labels: [&#x27;Person&#x27;]&#125;  ],  [  &#123;fileName: &#x27;file:/all.relationships.Mother.csv&#x27;, type: &#x27;relationships&#x27;&#125;,  &#123;fileName: &#x27;file:/all.relationships.BrotherSister.csv&#x27;, type: &#x27;relationships&#x27;&#125;,  &#123;fileName: &#x27;file:/all.relationships.Couple.csv&#x27;, type: &#x27;relationships&#x27;&#125;,  &#123;fileName: &#x27;file:/all.relationships.Father.csv&#x27;, type: &#x27;relationships&#x27;&#125;,  &#123;fileName: &#x27;file:/all.relationships.Friends.csv&#x27;, type: &#x27;relationships&#x27;&#125;,  &#123;fileName: &#x27;file:/all.relationships.Son.csv&#x27;, type: &#x27;relationships&#x27;&#125;,  &#123;fileName: &#x27;file:/all.relationships.Wife_Mother.csv&#x27;, type: &#x27;relationships&#x27;&#125;  ],  &#123;  delimiter: &#x27;$&#x27;, // 指定数据分隔符，导出时用的是$符号，导入也得用它  arrayDelimiter: &#x27;;&#x27;,  // 指定数组元素分隔符，默认：;  stringIds: false  &#125;)</code></pre><p><img src="https://raw.githubusercontent.com/GeorgeChan95/blogimg/master/img/2024/10/18/20241018-142912.png" alt="批量导入节点和节点的关系"></p><ul><li>方式二，单独导入节点和关系</li></ul><pre><code class="highlight cypher">// 只导入节点，不导入关系CALL apoc.import.csv(  [  &#123;fileName: &#x27;file:/all_nodes.csv&#x27;, labels: [&#x27;Person&#x27;]&#125;  ],  [],  // 没有关系要在这个步骤中导入  &#123;  delimiter: &#x27;$&#x27;, // 指定数据分隔符，导出时用的是$符号，导入也得用它  arrayDelimiter: &#x27;;&#x27;,  // 指定数组元素分隔符，默认：;  stringIds: false  &#125;)// 只导入关系，不导入节点（我试了，不行，报空指针）CALL apoc.import.csv(  [],  [  &#123;fileName: &#x27;file:/BrotherSister.csv&#x27;, type: &#x27;BrotherSister&#x27;&#125;  ],  &#123;  delimiter: &#x27;$&#x27;, // 指定数据分隔符，导出时用的是$符号，导入也得用它  arrayDelimiter: &#x27;;&#x27;,  // 指定数组元素分隔符，默认：;  stringIds: false  &#125;)// 同时导入节点和关系（可以）CALL apoc.import.csv(  [  &#123;fileName: &#x27;file:/all_nodes.csv&#x27;, labels: [&#x27;Person&#x27;]&#125;  ],  [&#123;fileName: &#x27;file:/BrotherSister.csv&#x27;, type: &#x27;BrotherSister&#x27;&#125;],  // 没有关系要在这个步骤中导入  &#123;  delimiter: &#x27;$&#x27;, // 指定数据分隔符，导出时用的是$符号，导入也得用它  arrayDelimiter: &#x27;;&#x27;,  // 指定数组元素分隔符，默认：;  stringIds: false  &#125;)</code></pre></li></ul><p><strong>总结</strong></p><p>neo4j数据的导出、导入坑很多，相对资料又比较少，以上都是亲自测试的可行方案。</p><p>如今neo4j已经出到 5.x 版本了，这篇还是使用的 3.5 版本，主要是因为算法部门他们训练和测试使用的是这个版本，与他们保持一致，后续有时间的话再研究一下新版本。</p><p><strong>参考链接</strong></p><blockquote><p><a href="https://blog.naughtyfox.top/neo4j%E7%9A%84%E5%AF%BC%E5%85%A5%E4%B8%8E%E5%AF%BC%E5%87%BA/#3-4-import-csv%E6%96%87%E4%BB%B6">https://blog.naughtyfox.top/neo4j%E7%9A%84%E5%AF%BC%E5%85%A5%E4%B8%8E%E5%AF%BC%E5%87%BA/#3-4-import-csv%E6%96%87%E4%BB%B6</a></p><p><a href="https://www.cnblogs.com/caoyusang/p/13610408.html">https://www.cnblogs.com/caoyusang/p/13610408.html</a></p><p><a href="https://www.cnblogs.com/Iven-L/p/17978724">https://www.cnblogs.com/Iven-L/p/17978724</a></p></blockquote>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;&lt;strong&gt;系统环境&lt;/strong&gt;&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;操作系统：Ubuntu18.04.6&lt;/p&gt;
&lt;p&gt;Docker：24.0.2&lt;/p&gt;
&lt;p&gt;Neo4j: 3.5.35(社区版)&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h1 id=&quot;一、下</summary>
      
    
    
    
    <category term="neo4j" scheme="https://georgechan95.github.io/categories/neo4j/"/>
    
    
    <category term="linux" scheme="https://georgechan95.github.io/tags/linux/"/>
    
    <category term="neo4j" scheme="https://georgechan95.github.io/tags/neo4j/"/>
    
  </entry>
  
  <entry>
    <title>Ubuntu18.04离线源环境搭建</title>
    <link href="https://georgechan95.github.io/blog/ad38e6b1.html"/>
    <id>https://georgechan95.github.io/blog/ad38e6b1.html</id>
    <published>2024-10-17T01:47:33.000Z</published>
    <updated>2024-10-17T05:46:20.411Z</updated>
    
    <content type="html"><![CDATA[<p><strong>系统环境</strong></p><blockquote><p>系统发行版：Ubuntu 18.04.6 LTS</p><p>内核版本：5.4.0-150-generic</p></blockquote><p><strong>注意事项</strong></p><p>使用此方式制作的离线源只能在相同的系统版本下用于离线的环境安装，即：Ubuntu18.04系统环境下制作的离线源，不能用于Ubuntu20.04系统的离线环境安装，如果环境不同可能导致在离线电脑上安装时会缺少部分依赖导致安装失败。</p><h1 id="一、制作离线源（可连外网）"><a href="#一、制作离线源（可连外网）" class="headerlink" title="一、制作离线源（可连外网）"></a>一、制作离线源（可连外网）</h1><p>先在一台可以连接外网的Ubuntu18.04服务器制作离线源环境。</p><ul><li><p>创建离线源目录</p><pre><code class="highlight shell">mkdir -p /opt/offline<span class="meta prompt_"></span><span class="meta prompt_"># </span><span class="language-bash">修改权限</span>chmod 777 -R /opt/offline/</code></pre><p>后面所有的安装包都会放到此目录，及子目录下。</p></li><li><p>安装 dpkg-dev 工具</p><pre><code class="highlight shell">apt-get install -y dpkg-dev</code></pre></li><li><p>备份系统目录的安装包</p><pre><code class="highlight shell"><span class="meta prompt_"># </span><span class="language-bash">创建安装包备份目录</span>mkdir -p /opt/offline/default/archives<span class="meta prompt_"></span><span class="meta prompt_"># </span><span class="language-bash">文件迁移</span>mv /var/cache/apt/archives/* /opt/offline/default/archives/<span class="meta prompt_"></span><span class="meta prompt_"># </span><span class="language-bash">删除源安装包</span>rm -rf /var/cache/apt/archives/*</code></pre></li></ul><p>下面演示常用软件离线源制作</p><h2 id="1-ssh"><a href="#1-ssh" class="headerlink" title="1. ssh"></a>1. ssh</h2><pre><code class="highlight shell">mkdir -p /opt/offline/ssh/archives/cd /opt/offline/ssh/archives/sudo apt-get download $(apt-cache depends --recurse --no-recommends --no-suggests --no-conflicts --no-breaks --no-replaces --no-enhances openssh-client openssh-server openssh-sftp-server | grep &quot;^\w&quot; | sort -u)cd ..<span class="meta prompt_"></span><span class="meta prompt_">#</span><span class="language-bash">带上-m，会将所有包全部建立依赖关系到 Packages.gz中，如此会有重复，但无需剔除重复的包</span>sudo dpkg-scanpackages -m . /dev/null | gzip -9c &gt; Packages.gz<span class="meta prompt_"></span><span class="meta prompt_"># </span><span class="language-bash">复制依赖关系文件到archives中</span>cp Packages.gz ./archives<span class="meta prompt_"></span><span class="meta prompt_"># </span><span class="language-bash">删除外部的依赖关系文件</span>rm -rf /opt/offline/ssh/Packages.gz</code></pre><h2 id="2-vim"><a href="#2-vim" class="headerlink" title="2. vim"></a>2. vim</h2><pre><code class="highlight shell">mkdir -p /opt/offline/vim/archives/cd /opt/offline/vim/archives/sudo apt-get download $(apt-cache depends --recurse --no-recommends --no-suggests --no-conflicts --no-breaks --no-replaces --no-enhances vim | grep &quot;^\w&quot; | sort -u)cd ..<span class="meta prompt_"></span><span class="meta prompt_">#</span><span class="language-bash">带上-m，会将所有包全部建立依赖关系到 Packages.gz中，如此会有重复，但无需剔除重复的包</span>sudo dpkg-scanpackages -m . /dev/null | gzip -9c &gt; Packages.gz<span class="meta prompt_"> </span><span class="meta prompt_"># </span><span class="language-bash">复制依赖关系文件到archives中,并删除无用的依赖关系文件</span>cp Packages.gz ./archives &amp;&amp; rm -rf /opt/offline/vim/Packages.gz</code></pre><h2 id="3-curl"><a href="#3-curl" class="headerlink" title="3. curl"></a>3. curl</h2><pre><code class="highlight shell">mkdir -p /opt/offline/curl/archives/cd /opt/offline/curl/archives/sudo apt-get download $(apt-cache depends --recurse --no-recommends --no-suggests --no-conflicts --no-breaks --no-replaces --no-enhances curl | grep &quot;^\w&quot; | sort -u)cd ..<span class="meta prompt_"></span><span class="meta prompt_">#</span><span class="language-bash">带上-m，会将所有包全部建立依赖关系到 Packages.gz中，如此会有重复，但无需剔除重复的包</span>sudo dpkg-scanpackages -m . /dev/null | gzip -9c &gt; Packages.gz<span class="meta prompt_"> </span><span class="meta prompt_"># </span><span class="language-bash">复制依赖关系文件到archives中,并删除无用的依赖关系文件</span>cp Packages.gz ./archives &amp;&amp; rm -rf /opt/offline/curl/Packages.gz</code></pre><h2 id="4-wget"><a href="#4-wget" class="headerlink" title="4. wget"></a>4. wget</h2><pre><code class="highlight shell">mkdir -p /opt/offline/wget/archives/cd /opt/offline/wget/archives/sudo apt-get download $(apt-cache depends --recurse --no-recommends --no-suggests --no-conflicts --no-breaks --no-replaces --no-enhances wget | grep &quot;^\w&quot; | sort -u)cd ..<span class="meta prompt_"></span><span class="meta prompt_">#</span><span class="language-bash">带上-m，会将所有包全部建立依赖关系到 Packages.gz中，如此会有重复，但无需剔除重复的包</span>sudo dpkg-scanpackages -m . /dev/null | gzip -9c &gt; Packages.gz<span class="meta prompt_"> </span><span class="meta prompt_"># </span><span class="language-bash">复制依赖关系文件到archives中,并删除无用的依赖关系文件</span>cp Packages.gz ./archives &amp;&amp; rm -rf /opt/offline/wget/Packages.gz</code></pre><h2 id="5-unzip"><a href="#5-unzip" class="headerlink" title="5. unzip"></a>5. unzip</h2><pre><code class="highlight shell">mkdir -p /opt/offline/unzip/archives/cd /opt/offline/unzip/archives/sudo apt-get download $(apt-cache depends --recurse --no-recommends --no-suggests --no-conflicts --no-breaks --no-replaces --no-enhances unzip | grep &quot;^\w&quot; | sort -u)cd ..<span class="meta prompt_"></span><span class="meta prompt_">#</span><span class="language-bash">带上-m，会将所有包全部建立依赖关系到 Packages.gz中，如此会有重复，但无需剔除重复的包</span>sudo dpkg-scanpackages -m . /dev/null | gzip -9c &gt; Packages.gz<span class="meta prompt_"> </span><span class="meta prompt_"># </span><span class="language-bash">复制依赖关系文件到archives中,并删除无用的依赖关系文件</span>cp Packages.gz ./archives &amp;&amp; rm -rf /opt/offline/unzip/Packages.gz</code></pre><h2 id="6-net-tools"><a href="#6-net-tools" class="headerlink" title="6. net-tools"></a>6. net-tools</h2><pre><code class="highlight shell">mkdir -p /opt/offline/net-tools/archives/cd /opt/offline/net-tools/archives/sudo apt-get download $(apt-cache depends --recurse --no-recommends --no-suggests --no-conflicts --no-breaks --no-replaces --no-enhances net-tools | grep &quot;^\w&quot; | sort -u)cd ..<span class="meta prompt_"></span><span class="meta prompt_">#</span><span class="language-bash">带上-m，会将所有包全部建立依赖关系到 Packages.gz中，如此会有重复，但无需剔除重复的包</span>sudo dpkg-scanpackages -m . /dev/null | gzip -9c &gt; Packages.gz<span class="meta prompt_"> </span><span class="meta prompt_"># </span><span class="language-bash">复制依赖关系文件到archives中,并删除无用的依赖关系文件</span>cp Packages.gz ./archives &amp;&amp; rm -rf /opt/offline/net-tools/Packages.gz</code></pre><h2 id="7-ffmpeg"><a href="#7-ffmpeg" class="headerlink" title="7. ffmpeg"></a>7. ffmpeg</h2><pre><code class="highlight shell">mkdir -p /opt/offline/ffmpeg/archives/cd /opt/offline/ffmpeg/archives/sudo apt-get download $(apt-cache depends --recurse --no-recommends --no-suggests --no-conflicts --no-breaks --no-replaces --no-enhances ffmpeg | grep &quot;^\w&quot; | sort -u)cd ..<span class="meta prompt_"></span><span class="meta prompt_">#</span><span class="language-bash">带上-m，会将所有包全部建立依赖关系到 Packages.gz中，如此会有重复，但无需剔除重复的包</span>sudo dpkg-scanpackages -m . /dev/null | gzip -9c &gt; Packages.gz<span class="meta prompt_"> </span><span class="meta prompt_"># </span><span class="language-bash">复制依赖关系文件到archives中,并删除无用的依赖关系文件</span>cp Packages.gz ./archives &amp;&amp; rm -rf /opt/offline/ffmpeg/Packages.gz</code></pre><h2 id="8-ntp"><a href="#8-ntp" class="headerlink" title="8. ntp"></a>8. ntp</h2><pre><code class="highlight shell">mkdir -p /opt/offline/ntp/archives/cd /opt/offline/ntp/archives/sudo apt-get download $(apt-cache depends --recurse --no-recommends --no-suggests --no-conflicts --no-breaks --no-replaces --no-enhances ntp ntpdate | grep &quot;^\w&quot; | sort -u)cd ..<span class="meta prompt_"></span><span class="meta prompt_">#</span><span class="language-bash">带上-m，会将所有包全部建立依赖关系到 Packages.gz中，如此会有重复，但无需剔除重复的包</span>sudo dpkg-scanpackages -m . /dev/null | gzip -9c &gt; Packages.gz<span class="meta prompt_"> </span><span class="meta prompt_"># </span><span class="language-bash">复制依赖关系文件到archives中,并删除无用的依赖关系文件</span>cp Packages.gz ./archives &amp;&amp; rm -rf /opt/offline/ntp/Packages.gz</code></pre><h2 id="9-apt-transport-https"><a href="#9-apt-transport-https" class="headerlink" title="9. apt-transport-https"></a>9. apt-transport-https</h2><pre><code class="highlight shell">mkdir -p /opt/offline/apt-transport-https/archives/cd /opt/offline/apt-transport-https/archives/sudo apt-get download $(apt-cache depends --recurse --no-recommends --no-suggests --no-conflicts --no-breaks --no-replaces --no-enhances apt-transport-https | grep &quot;^\w&quot; | sort -u)cd ..<span class="meta prompt_"></span><span class="meta prompt_">#</span><span class="language-bash">带上-m，会将所有包全部建立依赖关系到 Packages.gz中，如此会有重复，但无需剔除重复的包</span>sudo dpkg-scanpackages -m . /dev/null | gzip -9c &gt; Packages.gz<span class="meta prompt_"> </span><span class="meta prompt_"># </span><span class="language-bash">复制依赖关系文件到archives中,并删除无用的依赖关系文件</span>cp Packages.gz ./archives &amp;&amp; rm -rf /opt/offline/apt-transport-https/Packages.gz</code></pre><h2 id="10-ca-certificates"><a href="#10-ca-certificates" class="headerlink" title="10. ca-certificates"></a>10. ca-certificates</h2><pre><code class="highlight shell">mkdir -p /opt/offline/ca-certificates/archives/cd /opt/offline/ca-certificates/archives/sudo apt-get download $(apt-cache depends --recurse --no-recommends --no-suggests --no-conflicts --no-breaks --no-replaces --no-enhances ca-certificates | grep &quot;^\w&quot; | sort -u)cd ..<span class="meta prompt_"></span><span class="meta prompt_">#</span><span class="language-bash">带上-m，会将所有包全部建立依赖关系到 Packages.gz中，如此会有重复，但无需剔除重复的包</span>sudo dpkg-scanpackages -m . /dev/null | gzip -9c &gt; Packages.gz<span class="meta prompt_"> </span><span class="meta prompt_"># </span><span class="language-bash">复制依赖关系文件到archives中,并删除无用的依赖关系文件</span>cp Packages.gz ./archives &amp;&amp; rm -rf /opt/offline/ca-certificates/Packages.gz</code></pre><h2 id="11-software-properties-common"><a href="#11-software-properties-common" class="headerlink" title="11. software-properties-common"></a>11. software-properties-common</h2><pre><code class="highlight shell">mkdir -p /opt/offline/software-properties-common/archives/cd /opt/offline/software-properties-common/archives/sudo apt-get download $(apt-cache depends --recurse --no-recommends --no-suggests --no-conflicts --no-breaks --no-replaces --no-enhances software-properties-common | grep &quot;^\w&quot; | sort -u)cd ..<span class="meta prompt_"></span><span class="meta prompt_">#</span><span class="language-bash">带上-m，会将所有包全部建立依赖关系到 Packages.gz中，如此会有重复，但无需剔除重复的包</span>sudo dpkg-scanpackages -m . /dev/null | gzip -9c &gt; Packages.gz<span class="meta prompt_"> </span><span class="meta prompt_"># </span><span class="language-bash">复制依赖关系文件到archives中,并删除无用的依赖关系文件</span>cp Packages.gz ./archives &amp;&amp; rm -rf /opt/offline/software-properties-common/Packages.gz</code></pre><h2 id="12-docker"><a href="#12-docker" class="headerlink" title="12. docker"></a>12. docker</h2><p>docker的离线源制作稍稍复杂，需要GPG密钥，这里从阿里云下载Docker的GPG密钥，配置APT以从阿里云的Docker镜像仓库安装Docker.</p><ul><li><p>参考资料</p><blockquote><p><a href="https://help.aliyun.com/zh/ecs/use-cases/install-and-use-docker-on-a-linux-ecs-instance#33f11a5f1800n">安装Docker并使用</a></p></blockquote></li></ul><pre><code class="highlight shell">sudo apt-get update -y<span class="meta prompt_"></span><span class="meta prompt_"># </span><span class="language-bash">安装必要的包，包括证书、curl（用于数据传输）和gnupg（用于GPG密钥管理）。</span>sudo apt-get install -y ca-certificates curl gnupg<span class="meta prompt_"></span><span class="meta prompt_"># </span><span class="language-bash">创建一个目录/etc/apt/keyrings，并设置其权限为755。</span>sudo install -m 0755 -d /etc/apt/keyrings<span class="meta prompt_"></span><span class="meta prompt_"># </span><span class="language-bash">下载Docker的GPG密钥，并将其转换为适合APT使用的格式，保存到指定目录。</span>sudo curl -fsSL http://mirrors.aliyun.com/docker-ce/linux/ubuntu/gpg -o /etc/apt/keyrings/docker.asc<span class="meta prompt_"></span><span class="meta prompt_"># </span><span class="language-bash">为docker.gpg文件添加可读权限，以便所有用户都可以读取它。</span>sudo chmod a+r /etc/apt/keyrings/docker.asc<span class="meta prompt_"></span><span class="meta prompt_"># </span><span class="language-bash">将Docker的APT源添加到新的列表文件中，使用当前系统架构和版本代号。</span>echo \  &quot;deb [arch=$(dpkg --print-architecture) signed-by=/etc/apt/keyrings/docker.asc] http://mirrors.aliyun.com/docker-ce/linux/ubuntu \<span class="meta prompt_">  $</span><span class="language-bash">(. /etc/os-release &amp;&amp; <span class="built_in">echo</span> <span class="string">&quot;<span class="variable">$VERSION_CODENAME</span>&quot;</span>) stable<span class="string">&quot; | \</span></span><span class="string"><span class="language-bash">  sudo tee /etc/apt/sources.list.d/docker.list &gt; /dev/null</span></span><span class="meta prompt_">  </span><span class="meta prompt_"># </span><span class="language-bash"><span class="string">再次更新包索引，以包括刚添加的Docker源。</span></span>sudo apt-get update -y<span class="meta prompt_"></span><span class="meta prompt_"># </span><span class="language-bash"><span class="string">安装docker</span></span> sudo apt-get install -y docker-ce docker-ce-cli containerd.io<span class="meta prompt_"></span><span class="meta prompt_"># </span><span class="language-bash"><span class="string">查看docker版本信息</span></span>docker --version<span class="meta prompt_"></span><span class="meta prompt_"># </span><span class="language-bash"><span class="string">创建docker离线源安装包目录</span></span>mkdir -p /opt/offline/docker/archives/<span class="meta prompt_"></span><span class="meta prompt_"># </span><span class="language-bash"><span class="string">将docker安装时下载的缓存包，移动到离线源安装包路径中</span></span>mv /var/cache/apt/archives/* /opt/offline/docker/archives/cd /opt/offline/docker/<span class="meta prompt_"></span><span class="meta prompt_">#</span><span class="language-bash"><span class="string">带上-m，会将所有包全部建立依赖关系到 Packages.gz中，如此会有重复，但无需剔除重复的包</span></span>sudo dpkg-scanpackages -m . /dev/null | gzip -9c &gt; Packages.gz<span class="meta prompt_"> </span><span class="meta prompt_"># </span><span class="language-bash"><span class="string">复制依赖关系文件到archives中,并删除无用的依赖关系文件</span></span>cp Packages.gz ./archives &amp;&amp; rm -rf /opt/offline/docker/Packages.gz</code></pre><h2 id="13-nfs"><a href="#13-nfs" class="headerlink" title="13. nfs"></a>13. nfs</h2><p><a href="https://www.cnblogs.com/mrld/articles/14149708.html">https://www.cnblogs.com/mrld/articles/14149708.html</a></p><pre><code class="highlight shell">mkdir -p /opt/offline/nfs/archives/cd /opt/offline/nfs/archives/sudo apt-get download $(apt-cache depends --recurse --no-recommends --no-suggests --no-conflicts --no-breaks --no-replaces --no-enhances nfs-kernel-server nfs-common | grep &quot;^\w&quot; | sort -u)cd ..<span class="meta prompt_"></span><span class="meta prompt_">#</span><span class="language-bash">带上-m，会将所有包全部建立依赖关系到 Packages.gz中，如此会有重复，但无需剔除重复的包</span>sudo dpkg-scanpackages -m . /dev/null | gzip -9c &gt; Packages.gz<span class="meta prompt_"> </span><span class="meta prompt_"># </span><span class="language-bash">复制依赖关系文件到archives中,并删除无用的依赖关系文件</span>cp Packages.gz ./archives &amp;&amp; rm -rf /opt/offline/nfs/Packages.gz</code></pre><h2 id="14-sftp"><a href="#14-sftp" class="headerlink" title="14. sftp"></a>14. sftp</h2><p><a href="https://www.cnblogs.com/zhumengke/articles/11225040.html">https://www.cnblogs.com/zhumengke/articles/11225040.html</a></p><pre><code class="highlight shell">mkdir -p /opt/offline/sftp/archives/cd /opt/offline/sftp/archives/sudo apt-get download $(apt-cache depends --recurse --no-recommends --no-suggests --no-conflicts --no-breaks --no-replaces --no-enhances vsftpd | grep &quot;^\w&quot; | sort -u)cd ..<span class="meta prompt_"></span><span class="meta prompt_">#</span><span class="language-bash">带上-m，会将所有包全部建立依赖关系到 Packages.gz中，如此会有重复，但无需剔除重复的包</span>sudo dpkg-scanpackages -m . /dev/null | gzip -9c &gt; Packages.gz<span class="meta prompt_"> </span><span class="meta prompt_"># </span><span class="language-bash">复制依赖关系文件到archives中,并删除无用的依赖关系文件</span>cp Packages.gz ./archives &amp;&amp; rm -rf /opt/offline/sftp/Packages.gz</code></pre><h2 id="15-dos2unix"><a href="#15-dos2unix" class="headerlink" title="15. dos2unix"></a>15. dos2unix</h2><pre><code class="highlight shell">mkdir -p /opt/offline/dos2unix/archives/cd /opt/offline/dos2unix/archives/sudo apt-get download $(apt-cache depends --recurse --no-recommends --no-suggests --no-conflicts --no-breaks --no-replaces --no-enhances dos2unix | grep &quot;^\w&quot; | sort -u)cd ..<span class="meta prompt_"></span><span class="meta prompt_">#</span><span class="language-bash">带上-m，会将所有包全部建立依赖关系到 Packages.gz中，如此会有重复，但无需剔除重复的包</span>sudo dpkg-scanpackages -m . /dev/null | gzip -9c &gt; Packages.gz<span class="meta prompt_"> </span><span class="meta prompt_"># </span><span class="language-bash">复制依赖关系文件到archives中,并删除无用的依赖关系文件</span>cp Packages.gz ./archives &amp;&amp; rm -rf /opt/offline/dos2unix/Packages.gz</code></pre><h2 id="16-离线源打包"><a href="#16-离线源打包" class="headerlink" title="16. 离线源打包"></a>16. 离线源打包</h2><p>将上面制作好的连线源安装包，打包</p><pre><code class="highlight shell">cd /opt/offlinetar -zcf offline-source.tar.gz ./*</code></pre><p><code>offline-source.tar.gz</code> 就是制作好的离线包</p><h1 id="二、使用离线源安装服务器"><a href="#二、使用离线源安装服务器" class="headerlink" title="二、使用离线源安装服务器"></a>二、使用离线源安装服务器</h1><p>上面基于可连外网的服务器制作了离线源，并将离线源打成了一个tar包 ：<code>offline-source.tar.gz</code> ，现在就使用这个打包好的离线源，在断网的服务器上安装环境。</p><h2 id="1-上传离线安装包"><a href="#1-上传离线安装包" class="headerlink" title="1. 上传离线安装包"></a>1. 上传离线安装包</h2><p>将 <code>offline-source.tar.gz</code> 上传到服务器上，可以通过U盘拷贝的方式，或者内网文件服务器下载。</p><h2 id="2-配置离线源"><a href="#2-配置离线源" class="headerlink" title="2. 配置离线源"></a>2. 配置离线源</h2><pre><code class="highlight shell"><span class="meta prompt_"># </span><span class="language-bash">创建离线文件存放目录</span>mkdir -p /opt/offline<span class="meta prompt_"></span><span class="meta prompt_"># </span><span class="language-bash">解压离线文件</span>tar -zxvf offline-source.tar.gz -C /opt/offline/<span class="meta prompt_"></span><span class="meta prompt_"># </span><span class="language-bash">备份源文件</span>mv /etc/apt/sources.list /etc/apt/sources.list.bak<span class="meta prompt_"></span><span class="meta prompt_"># </span><span class="language-bash">映射本地源，这里可以使用vi</span>cat &gt;&gt;/etc/apt/sources.list &lt;&lt;EOFdeb [trusted=yes] file:///opt/offline/apt-transport-https/ archives/deb [trusted=yes] file:///opt/offline/ca-certificates/ archives/deb [trusted=yes] file:///opt/offline/curl/ archives/deb [trusted=yes] file:///opt/offline/docker/ archives/deb [trusted=yes] file:///opt/offline/ffmpeg/ archives/deb [trusted=yes] file:///opt/offline/net-tools/ archives/deb [trusted=yes] file:///opt/offline/nfs/ archives/deb [trusted=yes] file:///opt/offline/ntp/ archives/deb [trusted=yes] file:///opt/offline/sftp/ archives/deb [trusted=yes] file:///opt/offline/software-properties-common/ archives/deb [trusted=yes] file:///opt/offline/ssh/ archives/deb [trusted=yes] file:///opt/offline/unzip/ archives/deb [trusted=yes] file:///opt/offline/vim/ archives/deb [trusted=yes] file:///opt/offline/wget/ archives/deb [trusted=yes] file:///opt/offline/dos2unix/ archives/EOF<span class="meta prompt_"></span><span class="meta prompt_"># </span><span class="language-bash">更新</span>apt-get update -y</code></pre><h2 id="3-测试安装"><a href="#3-测试安装" class="headerlink" title="3. 测试安装"></a>3. 测试安装</h2><pre><code class="highlight shell">//根据自己需求进行安装，例如：apt-get install -y wget</code></pre><h2 id="4-使用离线源安装docker"><a href="#4-使用离线源安装docker" class="headerlink" title="4. 使用离线源安装docker"></a>4. 使用离线源安装docker</h2><pre><code class="highlight shell">sudo apt-get install -y docker-ce docker-ce-cli containerd.io</code></pre><p><strong>参考文档</strong></p><blockquote><p><a href="https://always200.com/ubuntu-offline-sources/">ubuntu制作离线源</a></p></blockquote>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;&lt;strong&gt;系统环境&lt;/strong&gt;&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;系统发行版：Ubuntu 18.04.6 LTS&lt;/p&gt;
&lt;p&gt;内核版本：5.4.0-150-generic&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;&lt;strong&gt;注意事项&lt;/stron</summary>
      
    
    
    
    <category term="linux" scheme="https://georgechan95.github.io/categories/linux/"/>
    
    
    <category term="linux" scheme="https://georgechan95.github.io/tags/linux/"/>
    
    <category term="ubuntu18" scheme="https://georgechan95.github.io/tags/ubuntu18/"/>
    
  </entry>
  
  <entry>
    <title>12-JUC进阶-从ReentrantLock到AQS源码详解</title>
    <link href="https://georgechan95.github.io/blog/3fdbf0f6.html"/>
    <id>https://georgechan95.github.io/blog/3fdbf0f6.html</id>
    <published>2024-10-15T11:42:07.000Z</published>
    <updated>2024-10-16T11:27:35.626Z</updated>
    
    <content type="html"><![CDATA[<h1 id="一、前置知识"><a href="#一、前置知识" class="headerlink" title="一、前置知识"></a>一、前置知识</h1><ul><li><p><strong>公平锁和非公平锁</strong></p><ul><li>公平锁：锁被释放以后，先申请的线程先得到锁。性能较差一些，因为公平锁为了保证时间上的绝对顺序，上下文切换更频繁</li><li>非公平锁：锁被释放以后，后申请的线程可能会先获取到锁，是随机或者按照其他优先级排序的。性能更好，但可能会导致某些线程永远无法获取到锁</li></ul></li><li><p><strong>可重入锁</strong></p><p>也叫做递归锁，指的是线程可以再次获取自己的内部锁，比如一个线程获取到了对象锁，此时这个对象锁还没有释放，当其想再次获取这个对象锁的时候还是可以获取的，如果不可重入的话，会导致阻塞。</p></li><li><p><strong>自旋思想</strong></p><p>当线程请求锁时，如果锁已经被其他线程持有，那么该线程会不断地重试获取锁，而不是被挂起等待，这种不断尝试获取锁的行为称为自旋</p></li><li><p><strong>LockSupport</strong></p><ul><li>一个工具类，用于线程的阻塞和唤醒操作，类似于wait()和notify()方法，但是更加灵活和可控</li><li>提供了 <code>park()</code> 和 <code>unpark()</code> 两个静态方法用于线程阻塞和唤醒操作。</li><li>优点在于可以在任意时刻阻塞和唤醒线程而不需要事先获取锁或监视器对象。</li></ul></li><li><p><strong>数据结构之双向链表</strong></p><p>双向链表（Doubly Linked List）是一种常见的数据结构，它是由一系列结点（Node）组成的，每个结点包含三个部分：数据域、前驱指针和后继指针。其中，数据域存储结点的数据，前驱指针指向前一个结点，后继指针指向后一个结点。通过这种方式，双向链表可以实现双向遍历和插入、删除操作。</p></li><li><p><strong>设计模式之模板设计模式</strong></p><ul><li>模板设计模式是一种行为型设计模式，定义了一种算法的框架，并将某些步骤延迟到子类中事先，这种设计模式的主要目的是允许子类在不改变算法结构的情况下重新定义算法中的某些步骤。</li><li>优点是能够提高代码复用性和可维护性。</li></ul></li></ul><h1 id="二、概述"><a href="#二、概述" class="headerlink" title="二、概述"></a>二、概述</h1><p>Java中的大部分同步类（<code>Lock</code>、<code>Semaphore</code>、<code>ReentrantLock</code> 等）都是基于 <code>AbstractQueuedSynchronizer</code>（简称为AQS）实现的。AQS是一种提供了原子式管理同步状态、阻塞和唤醒线程功能以及队列模型的简单框架。本文会从应用层逐渐深入到原理层，并通过 <code>ReentrantLock</code> 的基本特性和 <code>ReentrantLock</code> 与AQS的关联，来深入解读AQS相关独占锁的知识点。</p><h1 id="三、ReentrantLock"><a href="#三、ReentrantLock" class="headerlink" title="三、ReentrantLock"></a>三、ReentrantLock</h1><h2 id="1-ReentrantLock特性概览"><a href="#1-ReentrantLock特性概览" class="headerlink" title="1. ReentrantLock特性概览"></a>1. ReentrantLock特性概览</h2><p>ReentrantLock意思为可重入锁，指的是一个线程能够对一个临界资源重复加锁。为了帮助大家更好地理解ReentrantLock的特性，我们先将ReentrantLock跟常用的Synchronized进行比较，其特性如下</p><table><thead><tr><th></th><th>ReentrantLock</th><th>Synchronized</th></tr></thead><tbody><tr><td>锁实现机制</td><td>依赖AQS</td><td>监视器模式</td></tr><tr><td>灵活性</td><td>支持响应中断、超时、尝试获取锁</td><td>不灵活</td></tr><tr><td>释放形式</td><td>必须显示调用unlock0释放锁</td><td>自动释放监视器</td></tr><tr><td>锁类型</td><td>公平锁&amp;非公平锁</td><td>非公平锁</td></tr><tr><td>条件队列</td><td>可关联多个条件队列</td><td>关联一个条件队列</td></tr><tr><td>可重入性</td><td>可重入</td><td>可重入</td></tr></tbody></table><p>下面通过伪代码，进行更加直观的比较：</p><pre><code class="highlight java"><span class="comment">// **************************Synchronized的使用方式**************************</span><span class="comment">// 1.用于代码块</span><span class="keyword">synchronized</span> (<span class="built_in">this</span>) &#123;&#125;<span class="comment">// 2.用于对象</span><span class="keyword">synchronized</span> (object) &#123;&#125;<span class="comment">// 3.用于方法</span><span class="keyword">public</span> <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title function_">test</span> <span class="params">()</span> &#123;&#125;<span class="comment">// 4.可重入</span><span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; <span class="number">100</span>; i++) &#123;<span class="keyword">synchronized</span> (<span class="built_in">this</span>) &#123;&#125;&#125;<span class="comment">// **************************ReentrantLock的使用方式**************************</span><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">test</span> <span class="params">()</span> <span class="keyword">throw</span> Exception &#123;<span class="comment">// 1.初始化选择公平锁、非公平锁</span><span class="type">ReentrantLock</span> <span class="variable">lock</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ReentrantLock</span>(<span class="literal">true</span>);<span class="comment">// 2.可用于代码块</span>lock.lock();<span class="keyword">try</span> &#123;<span class="keyword">try</span> &#123;<span class="comment">// 3.支持多种加锁方式，比较灵活; 具有可重入特性</span><span class="keyword">if</span>(lock.tryLock(<span class="number">100</span>, TimeUnit.MILLISECONDS))&#123; &#125;&#125; <span class="keyword">finally</span> &#123;<span class="comment">// 4.手动释放锁</span>lock.unlock()&#125;&#125; <span class="keyword">finally</span> &#123;lock.unlock();&#125;&#125;</code></pre><h2 id="2-ReentrantLock与AQS的关联"><a href="#2-ReentrantLock与AQS的关联" class="headerlink" title="2. ReentrantLock与AQS的关联"></a>2. ReentrantLock与AQS的关联</h2><p>通过上文我们已经了解，ReentrantLock支持公平锁和非公平锁（关于公平锁和非公平锁的原理分析，可参考《<a href="https://mp.weixin.qq.com/s?__biz=MjM5NjQ5MTI5OA==&mid=2651749434&idx=3&sn=5ffa63ad47fe166f2f1a9f604ed10091&chksm=bd12a5778a652c61509d9e718ab086ff27ad8768586ea9b38c3dcf9e017a8e49bcae3df9bcc8&scene=38#wechat_redirect">不可不说的Java“锁”事</a>》），并且ReentrantLock的底层就是由AQS来实现的。那么ReentrantLock是如何通过公平锁和非公平锁与AQS关联起来呢？ 我们着重从这两者的加锁过程来理解一下它们与AQS之间的关系（加锁过程中与AQS的关联比较明显，解锁流程后续会介绍）。</p><p>非公平锁源码中的加锁流程如下：</p><pre><code class="highlight java"><span class="comment">// java.util.concurrent.locks.ReentrantLock#NonfairSync</span><span class="comment">// 非公平锁</span><span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">class</span> <span class="title class_">NonfairSync</span> <span class="keyword">extends</span> <span class="title class_">Sync</span> &#123;...<span class="keyword">final</span> <span class="keyword">void</span> <span class="title function_">lock</span><span class="params">()</span> &#123;<span class="keyword">if</span> (compareAndSetState(<span class="number">0</span>, <span class="number">1</span>))setExclusiveOwnerThread(Thread.currentThread());<span class="keyword">else</span>acquire(<span class="number">1</span>);&#125;  ...&#125;</code></pre><p>上述代码解析如下：</p><ul><li>首先通过CAS的方式，将 state（同步状态）从0 设置成 1， 如果成功，则将当前线程设置成独占线程</li><li>如果state（同步状态）修改失败，程序走else逻辑，通过 <code>acquire()</code> 方法进行后续处理。</li></ul><p><code>acquire()</code> 是CAS的核心方法，有 <code>FairSync</code> 和 <code>UnfairSync</code> 两个子类实现它，它们的逻辑基本类似，目的都是通过将争抢锁的线程组成队列，基于 state（同步状态）的变化，阻塞和唤醒线程，从而实现锁的获取和释放。</p><h1 id="四、AQS原理"><a href="#四、AQS原理" class="headerlink" title="四、AQS原理"></a>四、AQS原理</h1><h2 id="1-AQS整体框架"><a href="#1-AQS整体框架" class="headerlink" title="1. AQS整体框架"></a>1. AQS整体框架</h2><p>首先，我们通过下面的架构图来整体了解一下AQS框架：</p><p><img src="https://raw.githubusercontent.com/GeorgeChan95/blogimg/master/img/2024/10/15/20241015-184824.png" alt="AQS的整体框架"></p><ul><li>上图中有颜色的为Method，无颜色的为Attribution。</li><li>总的来说，AQS框架共分为五层，自上而下由浅入深，从AQS对外暴露的API到底层基础数据。</li><li>当有自定义同步器接入时，只需重写第一层所需要的部分方法即可，不需要关注底层具体的实现流程。当自定义同步器进行加锁或者解锁操作时，先经过第一层的API进入AQS内部方法，然后经过第二层进行锁的获取，接着对于获取锁失败的流程，进入第三层和第四层的等待队列处理，而这些处理方式均依赖于第五层的基础数据提供层。</li></ul><h2 id="2-AQS原理概览"><a href="#2-AQS原理概览" class="headerlink" title="2. AQS原理概览"></a>2. AQS原理概览</h2><p>AQS核心思想是，如果被请求的共享资源空闲，那么就将当前请求资源的线程设置为有效的工作线程，将共享资源设置为锁定状态；如果共享资源被占用，就需要一定的阻塞等待唤醒机制来保证锁分配。这个机制主要用的是CLH队列的变体实现的，将暂时获取不到锁的线程加入到队列中。</p><p>CLH：Craig、Landin and Hagersten队列，是单向链表，AQS中的队列是CLH变体的虚拟双向队列（FIFO），AQS是通过将每条请求共享资源的线程封装成一个节点来实现锁的分配。</p><p>主要原理图如下：</p><p><img src="https://raw.githubusercontent.com/GeorgeChan95/blogimg/master/img/2024/10/15/20241015-185444.png" alt="CLH队列"></p><h3 id="2-1-AQS数据结构"><a href="#2-1-AQS数据结构" class="headerlink" title="2.1 AQS数据结构"></a>2.1 AQS数据结构</h3><p>先来看下AQS中最基本的数据结构——Node，Node即为上面CLH变体队列中的节点。</p><p><img src="https://raw.githubusercontent.com/GeorgeChan95/blogimg/master/img/2024/10/15/20241015-185548.png" alt="AQS数据结构"></p><p><strong>Node源码如下（重要）：</strong></p><pre><code class="highlight java"><span class="comment">/**</span><span class="comment"> * Wait queue node class.</span><span class="comment"> *</span><span class="comment"> * &lt;p&gt;To enqueue into a CLH lock, you atomically splice it in as new</span><span class="comment"> * tail. To dequeue, you just set the head field.</span><span class="comment"> * &lt;pre&gt;</span><span class="comment"> *      +------+  prev +-----+       +-----+</span><span class="comment"> * head |      | &lt;---- |     | &lt;---- |     |  tail</span><span class="comment"> *      +------+       +-----+       +-----+</span><span class="comment"> * &lt;/pre&gt;</span><span class="comment"> *</span><span class="comment"> */</span><span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">class</span> <span class="title class_">Node</span> &#123;    <span class="comment">/** 共享模式下的节点 */</span>    <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">Node</span> <span class="variable">SHARED</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Node</span>();    <span class="comment">/** 独占模式下的节点 */</span>    <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">Node</span> <span class="variable">EXCLUSIVE</span> <span class="operator">=</span> <span class="literal">null</span>;    <span class="comment">/** 线程取消执行状态：1 */</span>    <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">int</span> <span class="variable">CANCELLED</span> <span class="operator">=</span>  <span class="number">1</span>;    <span class="comment">/** 线程准备就绪，等待资源释放后执行 */</span>    <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">int</span> <span class="variable">SIGNAL</span>    <span class="operator">=</span> -<span class="number">1</span>;    <span class="comment">/** 线程等待执行条件触发 */</span>    <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">int</span> <span class="variable">CONDITION</span> <span class="operator">=</span> -<span class="number">2</span>;    <span class="comment">/**</span><span class="comment">     * 此状态在共享模式下才会用到</span><span class="comment">     */</span>    <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">int</span> <span class="variable">PROPAGATE</span> <span class="operator">=</span> -<span class="number">3</span>;    <span class="comment">/**</span><span class="comment">     * Status field, taking on only the values:</span><span class="comment">     *   SIGNAL: 为-1，表示线程已经准备好了，就等资源释放了</span><span class="comment">     *   CANCELLED: 为 1，表示线程获取锁的请求已经取消了</span><span class="comment">     *   CONDITION: 为-2，表示节点在等待队列中，节点线程等待唤醒</span><span class="comment">     *   PROPAGATE: 为-3，当前线程处在SHARED情况下，该字段才会使用</span><span class="comment">     *   0:         当一个Node被初始化的时候的默认值</span><span class="comment">     */</span>    <span class="keyword">volatile</span> <span class="type">int</span> waitStatus;    <span class="comment">/**</span><span class="comment">     * node节点的前节点</span><span class="comment">     */</span>    <span class="keyword">volatile</span> Node prev;    <span class="comment">/**</span><span class="comment">     * node节点的后节点</span><span class="comment">     */</span>    <span class="keyword">volatile</span> Node next;    <span class="comment">/**</span><span class="comment">     * 当前节点运行的线程</span><span class="comment">     */</span>    <span class="keyword">volatile</span> Thread thread;    <span class="comment">/**</span><span class="comment">     * Link to next node waiting on condition, or the special value SHARED.</span><span class="comment">     */</span>    Node nextWaiter;    <span class="comment">/**</span><span class="comment">     * 共享模式下返回true</span><span class="comment">     */</span>    <span class="keyword">final</span> <span class="type">boolean</span> <span class="title function_">isShared</span><span class="params">()</span> &#123;        <span class="keyword">return</span> nextWaiter == SHARED;    &#125;    <span class="comment">/**</span><span class="comment">     * 返回当前节点的前节点</span><span class="comment">     */</span>    <span class="keyword">final</span> Node <span class="title function_">predecessor</span><span class="params">()</span> <span class="keyword">throws</span> NullPointerException &#123;        <span class="type">Node</span> <span class="variable">p</span> <span class="operator">=</span> prev;        <span class="keyword">if</span> (p == <span class="literal">null</span>)            <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">NullPointerException</span>();        <span class="keyword">else</span>            <span class="keyword">return</span> p;    &#125;    Node() &#123;    <span class="comment">// Used to establish initial head or SHARED marker</span>    &#125;    Node(Thread thread, Node mode) &#123;     <span class="comment">// Used by addWaiter</span>        <span class="built_in">this</span>.nextWaiter = mode;        <span class="built_in">this</span>.thread = thread;    &#125;    Node(Thread thread, <span class="type">int</span> waitStatus) &#123; <span class="comment">// Used by Condition</span>        <span class="built_in">this</span>.waitStatus = waitStatus;        <span class="built_in">this</span>.thread = thread;    &#125;&#125;</code></pre><p><strong>解释一下几个方法和属性值的含义：</strong></p><table><thead><tr><th align="left">方法和属性值</th><th align="left">含义</th></tr></thead><tbody><tr><td align="left">waitStatus</td><td align="left">当前节点在队列中的状态</td></tr><tr><td align="left">thread</td><td align="left">表示处于该节点的线程</td></tr><tr><td align="left">prev</td><td align="left">前驱指针</td></tr><tr><td align="left">predecessor</td><td align="left">返回前驱节点，没有的话抛出npe</td></tr><tr><td align="left">nextWaiter</td><td align="left">指向下一个处于CONDITION状态的节点（由于本篇文章不讲述Condition Queue队列，这个指针不多介绍）</td></tr><tr><td align="left">next</td><td align="left">后继指针</td></tr></tbody></table><p>线程两种锁的模式：</p><table><thead><tr><th align="left">模式</th><th align="left">含义</th></tr></thead><tbody><tr><td align="left">SHARED</td><td align="left">表示线程以共享的模式等待锁</td></tr><tr><td align="left">EXCLUSIVE</td><td align="left">表示线程正在以独占的方式等待锁</td></tr></tbody></table><p><code>waitStatus</code> 有下面几个枚举值：</p><table><thead><tr><th align="left">枚举</th><th align="left">含义</th></tr></thead><tbody><tr><td align="left">0</td><td align="left">当一个Node被初始化的时候的默认值</td></tr><tr><td align="left">CANCELLED</td><td align="left">为1，表示线程获取锁的请求已经取消了</td></tr><tr><td align="left">CONDITION</td><td align="left">为-2，表示节点在等待队列中，节点线程等待唤醒</td></tr><tr><td align="left">PROPAGATE</td><td align="left">为-3，当前线程处在SHARED情况下，该字段才会使用</td></tr><tr><td align="left">SIGNAL</td><td align="left">为-1，表示线程已经准备好了，就等资源释放了</td></tr></tbody></table><h3 id="2-2-同步状态State"><a href="#2-2-同步状态State" class="headerlink" title="2.2 同步状态State"></a>2.2 同步状态State</h3><p>在了解数据结构后，接下来了解一下AQS的同步状态——State。AQS中维护了一个名为state的字段，意为同步状态，是由Volatile修饰的，用于展示当前临界资源的获锁情况。</p><pre><code class="highlight java"><span class="comment">// java.util.concurrent.locks.AbstractQueuedSynchronizer</span><span class="comment">/**</span><span class="comment"> * The synchronization state.</span><span class="comment"> */</span><span class="keyword">private</span> <span class="keyword">volatile</span> <span class="type">int</span> state;</code></pre><p>下面提供了几个访问这个字段的方法：</p><table><thead><tr><th align="left">方法名</th><th align="left">描述</th></tr></thead><tbody><tr><td align="left">protected final int getState()</td><td align="left">获取State的值</td></tr><tr><td align="left">protected final void setState(int newState)</td><td align="left">设置State的值</td></tr><tr><td align="left">protected final boolean compareAndSetState(int expect, int update)</td><td align="left">使用CAS方式更新State</td></tr></tbody></table><p>这几个方法都是Final修饰的，说明子类中无法重写它们。我们可以通过修改State字段表示的同步状态来实现多线程的独占模式和共享模式（加锁过程）。</p><p><img src="https://p0.meituan.net/travelcube/27605d483e8935da683a93be015713f331378.png" alt="独占模式"><img src="https://raw.githubusercontent.com/GeorgeChan95/blogimg/master/img/2024/10/15/20241015-190158.png" alt="共享模式"></p><p><em>对于我们自定义的同步工具，需要自定义获取同步状态和释放状态的方式，也就是AQS架构图中的第一层：API层。</em></p><h3 id="2-3-AQS其它关键属性"><a href="#2-3-AQS其它关键属性" class="headerlink" title="2.3 AQS其它关键属性"></a>2.3 AQS其它关键属性</h3><ul><li><p>head ： 表示CLH队列中的头节点</p><pre><code class="highlight java"><span class="keyword">private</span> <span class="keyword">transient</span> <span class="keyword">volatile</span> Node head;</code></pre></li><li><p>tail ：表示CLH队列中的尾节点</p><pre><code class="highlight java"><span class="keyword">private</span> <span class="keyword">transient</span> <span class="keyword">volatile</span> Node tail;</code></pre></li></ul><h2 id="3-AQS重要方法与ReentrantLock的关联"><a href="#3-AQS重要方法与ReentrantLock的关联" class="headerlink" title="3. AQS重要方法与ReentrantLock的关联"></a>3. AQS重要方法与ReentrantLock的关联</h2><p>从架构图中可以得知，AQS提供了大量用于自定义同步器实现的Protected方法。自定义同步器实现的相关方法也只是为了通过修改State字段来实现多线程的独占模式或者共享模式。自定义同步器需要实现以下方法（ReentrantLock需要实现的方法如下，并不是全部）：</p><table><thead><tr><th align="left">方法名</th><th align="left">描述</th></tr></thead><tbody><tr><td align="left">protected boolean isHeldExclusively()</td><td align="left">该线程是否正在独占资源。只有用到Condition才需要去实现它。</td></tr><tr><td align="left">protected boolean tryAcquire(int arg)</td><td align="left">独占方式。arg为获取锁的次数，尝试获取资源，成功则返回True，失败则返回False。</td></tr><tr><td align="left">protected boolean tryRelease(int arg)</td><td align="left">独占方式。arg为释放锁的次数，尝试释放资源，成功则返回True，失败则返回False。</td></tr><tr><td align="left">protected int tryAcquireShared(int arg)</td><td align="left">共享方式。arg为获取锁的次数，尝试获取资源。负数表示失败；0表示成功，但没有剩余可用资源；正数表示成功，且有剩余资源。</td></tr><tr><td align="left">protected boolean tryReleaseShared(int arg)</td><td align="left">共享方式。arg为释放锁的次数，尝试释放资源，如果释放后允许唤醒后续等待结点返回True，否则返回False。</td></tr></tbody></table><p>一般来说，自定义同步器要么是独占方式，要么是共享方式，它们也只需实现<code>tryAcquire-tryRelease</code>、<code>tryAcquireShared-tryReleaseShared</code>中的一种即可。AQS也支持自定义同步器同时实现独占和共享两种方式，如<code>ReentrantReadWriteLock</code>。<code>ReentrantLock</code>是独占锁，所以实现了<code>tryAcquire-tryRelease</code>。</p><p>为了帮助大家理解ReentrantLock和AQS之间方法的交互过程，以非公平锁为例，我们将加锁和解锁的交互流程单独拎出来强调一下，以便于对后续内容的理解。</p><p><img src="https://raw.githubusercontent.com/GeorgeChan95/blogimg/master/img/2024/10/15/20241015-191329.png" alt="ReentrantLock加锁和解锁的调用流程"></p><p><strong>加锁：</strong></p><ul><li><p>通过<code>ReentrantLock</code>的加锁方法<code>Lock</code>进行加锁操作。</p></li><li><p>会调用到内部类<code>Sync</code>的<code>Lock</code>方法，由于<code>Sync#lock</code>是抽象方法，根据<code>ReentrantLock</code>初始化选择的公平锁和非公平锁，执行相关内部类的<code>Lock</code>方法，本质上都会执行AQS的<code>Acquire</code>方法。（以非公平锁 <code>NonfairSync</code> 为例）</p><p><code>java.util.concurrent.locks.ReentrantLock#lock</code>  &#x3D;&gt;  <code>java.util.concurrent.locks.ReentrantLock.Sync#lock</code>  &#x3D;&gt;  <code>java.util.concurrent.locks.ReentrantLock.NonfairSync#lock</code>  &#x3D;&gt;  <code>java.util.concurrent.locks.AbstractQueuedSynchronizer#acquire</code></p></li><li><p>AQS的<code>Acquire</code>方法会执行<code>tryAcquire</code>方法，但是由于<code>tryAcquire</code>需要自定义同步器实现，因此执行了<code>ReentrantLock</code>中的<code>tryAcquire</code>方法，由于<code>ReentrantLock</code>是通过公平锁和非公平锁内部类实现的<code>tryAcquire</code>方法，因此会根据锁类型不同，执行不同的<code>tryAcquire</code>。(这里再次以非公平锁为例)</p><p><code>java.util.concurrent.locks.AbstractQueuedSynchronizer#tryAcquire</code>  &#x3D;&gt;  <code>java.util.concurrent.locks.ReentrantLock.NonfairSync#tryAcquire</code>  &#x3D;&gt;  <code>java.util.concurrent.locks.ReentrantLock.Sync#nonfairTryAcquire</code></p></li><li><p><code>tryAcquire</code>是获取锁逻辑，获取失败后，会执行框架AQS的后续逻辑，跟<code>ReentrantLock</code>自定义同步器无关。</p><ul><li><code>java.util.concurrent.locks.AbstractQueuedSynchronizer#addWaiter</code>  &#x3D;&gt;  <code>java.util.concurrent.locks.AbstractQueuedSynchronizer#enq</code> </li><li><code>java.util.concurrent.locks.AbstractQueuedSynchronizer#acquireQueued</code> &#x3D;&gt; <code>java.util.concurrent.locks.AbstractQueuedSynchronizer#shouldParkAfterFailedAcquire</code>  &#x3D;&gt;  <code>java.util.concurrent.locks.AbstractQueuedSynchronizer#parkAndCheckInterrupt</code></li></ul></li></ul><p>以上为AQS加锁过程的核心逻辑和核心方法。</p><p><strong>解锁：</strong></p><ul><li><p>通过<code>ReentrantLock</code>的解锁方法<code>Unlock</code>进行解锁。</p></li><li><p><code>Unlock</code>会调用内部类<code>Sync</code>的<code>Release</code>方法，该方法继承于AQS。</p><p><code>java.util.concurrent.locks.ReentrantLock#unlock</code>  &#x3D;&gt;  <code>java.util.concurrent.locks.AbstractQueuedSynchronizer#release</code></p></li><li><p>Release中会调用<code>tryRelease</code>方法，<code>tryRelease</code>需要自定义同步器实现，<code>tryRelease</code>只在<code>ReentrantLock</code>中的<code>Sync</code>实现，因此可以看出，释放锁的过程，并不区分是否为公平锁。</p><p><code>java.util.concurrent.locks.AbstractQueuedSynchronizer#tryRelease</code>  &#x3D;&gt;  <code>java.util.concurrent.locks.ReentrantLock.Sync#tryRelease</code></p></li><li><p>释放成功后，所有处理由AQS框架完成，与自定义同步器无关。</p></li></ul><p>通过上面的描述，大概可以总结出<code>ReentrantLock</code>加锁解锁时API层核心方法的映射关系。</p><p><img src="https://raw.githubusercontent.com/GeorgeChan95/blogimg/master/img/2024/10/15/20241015-192902.png" alt="加锁/解锁方法映射"></p><h1 id="五、AQS加锁-解锁源码解析"><a href="#五、AQS加锁-解锁源码解析" class="headerlink" title="五、AQS加锁&#x2F;解锁源码解析"></a>五、AQS加锁&#x2F;解锁源码解析</h1><p>下面以 <code>ReentrantLock</code> 的实现为例，通过一个具体的案例，详细解释AQS是如何实现线程的抢占、创建队列(FIFO)、入队、以及获取到锁后出队的过程。</p><h2 id="1-模拟场景"><a href="#1-模拟场景" class="headerlink" title="1. 模拟场景"></a>1. 模拟场景</h2><p>假设有5个线程，分别是 <code>线程A</code>、<code>线程B</code>、<code>线程C</code>、<code>线程D</code>、<code>线程E</code> 同时去争抢一个资源，然后执行相应的逻辑，线程A先抢到锁，其它线程只能 <code>等待A</code> 执行结束后再抢锁。这里使用 ReentrantLock非公平锁实现。</p><p>模拟代码如下：</p><pre><code class="highlight java"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">AQSDemo</span> &#123;    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;        <span class="type">ReentrantLock</span> <span class="variable">reentrantLock</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ReentrantLock</span>();<span class="comment">//非公平锁</span>        <span class="comment">// A线程先抢到锁，执行业务</span>        <span class="keyword">new</span> <span class="title class_">Thread</span>(() -&gt; &#123;            reentrantLock.lock();            <span class="keyword">try</span> &#123;                System.out.println(<span class="string">&quot;----come in A&quot;</span>);                <span class="comment">//暂停1分钟线程</span>                <span class="keyword">try</span> &#123;                    TimeUnit.MILLISECONDS.sleep(<span class="number">1000</span> * <span class="number">60</span>);                &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;                    e.printStackTrace();                &#125;            &#125; <span class="keyword">finally</span> &#123;                reentrantLock.unlock();            &#125;        &#125;, <span class="string">&quot;A&quot;</span>).start();        <span class="comment">// B线程等待，进入AQS队列(FIFO)，等待着A运行结束，尝试去抢占锁。</span>        <span class="keyword">new</span> <span class="title class_">Thread</span>(() -&gt; &#123;            reentrantLock.lock();            <span class="keyword">try</span> &#123;                System.out.println(<span class="string">&quot;----come in B&quot;</span>);            &#125; <span class="keyword">finally</span> &#123;                reentrantLock.unlock();            &#125;        &#125;, <span class="string">&quot;B&quot;</span>).start();        <span class="comment">// C线程等待，进入AQS队列(FIFO)，等待着A运行结束，此时前面是B线程</span>        <span class="keyword">new</span> <span class="title class_">Thread</span>(() -&gt; &#123;            reentrantLock.lock();            <span class="keyword">try</span> &#123;                System.out.println(<span class="string">&quot;----come in C&quot;</span>);            &#125; <span class="keyword">finally</span> &#123;                reentrantLock.unlock();            &#125;        &#125;, <span class="string">&quot;C&quot;</span>).start();        <span class="comment">// D线程等待，进入AQS队列(FIFO)，等待着A运行结束，此时前面是C线程</span>        <span class="keyword">new</span> <span class="title class_">Thread</span>(() -&gt; &#123;            reentrantLock.lock();            <span class="keyword">try</span> &#123;                System.out.println(<span class="string">&quot;----come in C&quot;</span>);            &#125; <span class="keyword">finally</span> &#123;                reentrantLock.unlock();            &#125;        &#125;, <span class="string">&quot;D&quot;</span>).start();        <span class="comment">// E线程等待，进入AQS队列(FIFO)，等待着A运行结束，此时前面是D线程</span>        <span class="keyword">new</span> <span class="title class_">Thread</span>(() -&gt; &#123;            reentrantLock.lock();            <span class="keyword">try</span> &#123;                System.out.println(<span class="string">&quot;----come in C&quot;</span>);            &#125; <span class="keyword">finally</span> &#123;                reentrantLock.unlock();            &#125;        &#125;, <span class="string">&quot;E&quot;</span>).start();    &#125;&#125;</code></pre><h2 id="2-资源初始化"><a href="#2-资源初始化" class="headerlink" title="2. 资源初始化"></a>2. 资源初始化</h2><p>最开始，没有线程争抢锁时，如下图，此时 同步状态为0（表示资源空闲），所没有被线程抢占。</p><p><img src="https://raw.githubusercontent.com/GeorgeChan95/blogimg/master/img/2024/10/15/20241015-203250.png" alt="无线程抢占资源"></p><h2 id="3-无竞争获取资源"><a href="#3-无竞争获取资源" class="headerlink" title="3. 无竞争获取资源"></a>3. 无竞争获取资源</h2><p>此时 线程A 调用了 lock() 方法抢占了锁，得到了资源，如下图：</p><p><img src="https://raw.githubusercontent.com/GeorgeChan95/blogimg/master/img/2024/10/15/20241015-203510.png" alt="线程A抢占锁"></p><p>此时，同步状态被修改为1，表示资源已被占用。由于此时还有其它线程来争抢资源，所以CLH队列依然是空的。</p><p>线程A的代码执行如下图：</p><pre><code class="highlight java"><span class="comment">// java.util.concurrent.locks.ReentrantLock.NonfairSync#lock</span>    <span class="keyword">final</span> <span class="keyword">void</span> <span class="title function_">lock</span><span class="params">()</span> &#123;    <span class="comment">// 使用CAS将同步状态从0修改为1，如果成功表示成功抢占了锁</span>    <span class="keyword">if</span> (compareAndSetState(<span class="number">0</span>, <span class="number">1</span>))        <span class="comment">// 抢占锁成功，设置当前线程为独占线程</span>        setExclusiveOwnerThread(Thread.currentThread());    <span class="keyword">else</span>        <span class="comment">// 以独占模式争抢锁，成功则返回，失败则线程进入CLH队列</span>        acquire(<span class="number">1</span>);&#125;</code></pre><h2 id="4-线程加入等待队列"><a href="#4-线程加入等待队列" class="headerlink" title="4. 线程加入等待队列"></a>4. 线程加入等待队列</h2><h3 id="4-1-加入队列的时机"><a href="#4-1-加入队列的时机" class="headerlink" title="4.1 加入队列的时机"></a>4.1 加入队列的时机</h3><p>此时 <code>线程B</code> 也调用了 <code>lock()</code> 方法争抢锁，但由于 <code>线程A</code> 没有退出执行，依然占有的着锁，此时 state(同步状态)为1，所以 线程B 使用CAS修改state 操作是失败的，只能走 else 分支，进入 acquire(1) 方法。</p><pre><code class="highlight java"><span class="comment">// java.util.concurrent.locks.AbstractQueuedSynchronizer#acquire</span><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">void</span> <span class="title function_">acquire</span><span class="params">(<span class="type">int</span> arg)</span> &#123;    <span class="keyword">if</span> (!tryAcquire(arg) &amp;&amp; acquireQueued(addWaiter(Node.EXCLUSIVE), arg))        selfInterrupt();&#125;</code></pre><ul><li><p>tryAcquire(arg)</p><p>获取锁逻辑, 获取成功则直接返回，获取失败后，会执行框架AQS的后续逻辑</p></li><li><p>addWaiter(Node mode)</p><p>当<code>tryAcquire(arg)</code>获取锁失败，就会调用 <code>addWaiter</code> 加入到等待队列中去，并返回Node对象（Node为执行线程经过封装后的对象）</p></li><li><p>acquireQueued(final Node node, int arg)</p><p>把放入队列中的线程不断去获取锁，直到获取成功或者不再需要获取（中断）</p></li></ul><p>下面基于非公平锁实现，详细解读这三个方法 <code>tryAcquire(arg)</code>、<code>addWaiter(Node mode)</code>、<code>acquireQueued(final Node node, int arg)</code></p><h4 id="4-1-1-tryAcquire"><a href="#4-1-1-tryAcquire" class="headerlink" title="4.1.1 tryAcquire"></a>4.1.1 tryAcquire</h4><pre><code class="highlight java"><span class="comment">// java.util.concurrent.locks.AbstractQueuedSynchronizer#tryAcquire</span>    <span class="keyword">protected</span> <span class="type">boolean</span> <span class="title function_">tryAcquire</span><span class="params">(<span class="type">int</span> arg)</span> &#123;    <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">UnsupportedOperationException</span>();&#125;</code></pre><p>这是AQS父类的默认实现，当子类没有重新实现它时，抛出 UnsupportedOperationException，tryAcquire 有公平锁、非公平锁等不同的实现逻辑，这里我们先看 <code>ReentrantLock</code> 内部类 <code>NonfairSync</code> 的实现</p><pre><code class="highlight java"><span class="comment">// java.util.concurrent.locks.ReentrantLock.NonfairSync#tryAcquire</span><span class="keyword">protected</span> <span class="keyword">final</span> <span class="type">boolean</span> <span class="title function_">tryAcquire</span><span class="params">(<span class="type">int</span> acquires)</span> &#123;    <span class="keyword">return</span> nonfairTryAcquire(acquires);&#125;继续往下<span class="comment">// java.util.concurrent.locks.ReentrantLock.Sync#nonfairTryAcquire</span>    <span class="keyword">final</span> <span class="type">boolean</span> <span class="title function_">nonfairTryAcquire</span><span class="params">(<span class="type">int</span> acquires)</span> &#123;    <span class="comment">// 获取当前线程</span>    <span class="keyword">final</span> <span class="type">Thread</span> <span class="variable">current</span> <span class="operator">=</span> Thread.currentThread();    <span class="comment">// 获取同步状态</span>    <span class="type">int</span> <span class="variable">c</span> <span class="operator">=</span> getState();    <span class="keyword">if</span> (c == <span class="number">0</span>) &#123; <span class="comment">// 如果同步状态为0，表示资源空闲，没有被其它线程占用</span>        <span class="comment">// CAS修改同步状态，成功的话则设置当前线程为独占线程，并返回true</span>        <span class="keyword">if</span> (compareAndSetState(<span class="number">0</span>, acquires)) &#123;            setExclusiveOwnerThread(current);            <span class="keyword">return</span> <span class="literal">true</span>;        &#125;    &#125;    <span class="comment">// 如果同步状态不是0，但是当前线程就是资源的独占线程，这就是表示锁重入，此时更新同步状态，并返回true</span>    <span class="keyword">else</span> <span class="keyword">if</span> (current == getExclusiveOwnerThread()) &#123;        <span class="type">int</span> <span class="variable">nextc</span> <span class="operator">=</span> c + acquires;        <span class="keyword">if</span> (nextc &lt; <span class="number">0</span>) <span class="comment">// overflow</span>            <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">Error</span>(<span class="string">&quot;Maximum lock count exceeded&quot;</span>);        setState(nextc);        <span class="keyword">return</span> <span class="literal">true</span>;    &#125;    <span class="comment">// 同步状态既不是空闲（0），当前线程也不是资源的独占线程，表示当前线程此次抢占锁失败，返回false。</span>    <span class="keyword">return</span> <span class="literal">false</span>;&#125;</code></pre><p>由于此时锁被 <code>线程A</code> 占用，<code>线程B</code> 执行到 nonfairTryAcquire 方法时，同步状态即不是0，<code>线程B</code> 也不是独占线程，所以这里返回 <code>false</code> 。</p><h3 id="4-2-如何加入队列"><a href="#4-2-如何加入队列" class="headerlink" title="4.2 如何加入队列"></a>4.2 如何加入队列</h3><p>在 <code>线程B</code> 执行 <code>tryAcquire</code> 获取锁失败后，会执行 <code>addWaiter(Node.EXCLUSIVE)</code> 加入等待队列，具体实现方法如下：</p><pre><code class="highlight java"><span class="comment">// java.util.concurrent.locks.AbstractQueuedSynchronizer#addWaiter</span><span class="keyword">private</span> Node <span class="title function_">addWaiter</span><span class="params">(Node mode)</span> &#123;    <span class="comment">// 通过当前的线程和锁模式新建一个节点</span>    <span class="type">Node</span> <span class="variable">node</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Node</span>(Thread.currentThread(), mode);    <span class="comment">// Pred指针指向尾节点Tail</span>    <span class="type">Node</span> <span class="variable">pred</span> <span class="operator">=</span> tail;    <span class="keyword">if</span> (pred != <span class="literal">null</span>) &#123;        <span class="comment">// 将New中Node的Prev指针指向Pred</span>        node.prev = pred;        <span class="comment">// CAS设置Tail节点为新建的节点</span>        <span class="keyword">if</span> (compareAndSetTail(pred, node)) &#123;            <span class="comment">// pred节点的next指针指向新的node节点</span>            pred.next = node;            <span class="comment">// 返回新建的node节点</span>            <span class="keyword">return</span> node;        &#125;    &#125;    <span class="comment">// node节点加入CLH队列</span>    enq(node);    <span class="comment">// 返回node节点</span>    <span class="keyword">return</span> node;&#125;</code></pre><p>由于 <code>线程B</code> 在争抢锁时，此时 CLH队列为空，即 head、tail 都为 null，那么上面代码中的 pred 也为null，此时需要创建CLH队列，并将 <code>线程B</code> 加入到队列中，这时就要进入 enq(node) 方法</p><pre><code class="highlight java"><span class="comment">// java.util.concurrent.locks.AbstractQueuedSynchronizer#enq</span><span class="keyword">private</span> Node <span class="title function_">enq</span><span class="params">(<span class="keyword">final</span> Node node)</span> &#123;    <span class="comment">// 自旋操作</span>    <span class="keyword">for</span> (;;) &#123;        <span class="type">Node</span> <span class="variable">t</span> <span class="operator">=</span> tail;        <span class="comment">// 如果队列没有被初始化过，则先初始化一个虚拟节点（new Node()）</span>        <span class="keyword">if</span> (t == <span class="literal">null</span>) &#123; <span class="comment">// Must initialize</span>            <span class="comment">// 初始化虚节点，并将它设置成头节点</span>            <span class="keyword">if</span> (compareAndSetHead(<span class="keyword">new</span> <span class="title class_">Node</span>()))                tail = head;        &#125; <span class="keyword">else</span> &#123;            <span class="comment">// 队列不为空时，当前线程所在节点node的prev指针指向尾节点</span>            node.prev = t;            <span class="comment">// CAS设置当前节点为尾节点</span>            <span class="keyword">if</span> (compareAndSetTail(t, node)) &#123;                <span class="comment">// 之前的尾节点的next指针指向当前节点node</span>                t.next = node;                <span class="comment">// 返回之前的尾节点</span>                <span class="keyword">return</span> t;            &#125;        &#125;    &#125;&#125;</code></pre><p>如果队列没有被初始化，需要进行初始化一个头结点出来。但请注意，初始化的头结点并不是当前线程节点，而是调用了无参构造函数的节点（虚节点）。如果经历了初始化或者并发导致队列中有元素，则与之前的方法相同。其实，<code>addWaiter</code> 就是一个在双端链表添加尾节点的操作，需要注意的是，双端链表的头结点是一个无参构造函数的头结点。</p><p><em>另外也需要注意，enq() 方法返回的 node对象(t) 并不是 addWaiter 方法返回的node对象。</em></p><p>此时 <code>线程B</code> 在经过 enq方法的自旋处理后，进入了CLH队列，如下图：<br><img src="https://raw.githubusercontent.com/GeorgeChan95/blogimg/master/img/2024/10/16/20241016-091107.png" alt="线程B自旋入队"></p><p>这时 线程B 就入队了，作为尾节点插入到队列中，头节点是一个虚节点。如果再有线程要获取锁，依次在队列中往后排队即可。</p><p>如果线程争抢锁是一个公平锁，那么还会增加下面一段逻辑代码：<code>hasQueuedPredecessors()</code> 方法</p><p><code>hasQueuedPredecessors</code> 是公平锁加锁时判断等待队列中是否存在有效节点的方法。如果返回False，说明当前线程可以争取共享资源；如果返回True，说明队列中存在有效节点，当前线程必须加入到等待队列中。</p><pre><code class="highlight java"><span class="comment">//java.util.concurrent.locks.AbstractQueuedSynchronizer#hasQueuedPredecessors</span>    <span class="keyword">public</span> <span class="keyword">final</span> <span class="type">boolean</span> <span class="title function_">hasQueuedPredecessors</span><span class="params">()</span> &#123;    <span class="comment">// 尾节点</span>    <span class="type">Node</span> <span class="variable">t</span> <span class="operator">=</span> tail; <span class="comment">// Read fields in reverse initialization order</span>    <span class="comment">// 头节点</span>    <span class="type">Node</span> <span class="variable">h</span> <span class="operator">=</span> head;    <span class="comment">// 指向头节点的下一个节点</span>    Node s;    <span class="keyword">return</span> h != t &amp;&amp;            ((s = h.next) == <span class="literal">null</span> || s.thread != Thread.currentThread());&#125;</code></pre><p>看到这里，我们理解一下 <code>h != t &amp;&amp; ((s = h.next) == null || s.thread != Thread.currentThread());</code> 为什么要判断的头结点的下一个节点？第一个节点储存的数据是什么？</p><blockquote><p>双向链表中，第一个节点为虚节点，其实并不存储任何信息，只是占位。真正的第一个有数据的节点，是在第二个节点开始的。当<code>h != t</code> 时： 如果<code>(s = h.next) == null</code>，等待队列正在有线程进行初始化，但只是进行到了Tail指向Head，没有将Head指向Tail，此时队列中有元素，需要返回True（这块具体见下边代码分析）。 如果(s &#x3D; h.next) !&#x3D; null，说明此时队列中至少有一个有效节点。如果此时s.thread &#x3D;&#x3D; Thread.currentThread()，说明等待队列的第一个有效节点中的线程与当前线程相同，那么当前线程是可以获取资源的；如果s.thread !&#x3D; Thread.currentThread()，说明等待队列的第一个有效节点线程与当前线程不同，当前线程必须加入进等待队列。</p></blockquote><p>这时，我们再回顾一下节点的入队操作，<code>enq()</code> 方法</p><pre><code class="highlight java"><span class="comment">// java.util.concurrent.locks.AbstractQueuedSynchronizer#enq</span><span class="keyword">private</span> Node <span class="title function_">enq</span><span class="params">(<span class="keyword">final</span> Node node)</span> &#123;    <span class="comment">// 自旋操作</span>    <span class="keyword">for</span> (;;) &#123;        <span class="type">Node</span> <span class="variable">t</span> <span class="operator">=</span> tail;        <span class="comment">// 如果队列没有被初始化过，则先初始化一个虚拟节点（new Node()）</span>        <span class="keyword">if</span> (t == <span class="literal">null</span>) &#123; <span class="comment">// Must initialize</span>            <span class="comment">// 初始化虚节点，并将它设置成头节点</span>            <span class="keyword">if</span> (compareAndSetHead(<span class="keyword">new</span> <span class="title class_">Node</span>()))                tail = head;        &#125; <span class="keyword">else</span> &#123;            <span class="comment">// 队列不为空时，当前线程所在节点node的prev指针指向尾节点</span>            node.prev = t;            <span class="comment">// CAS设置当前节点为尾节点</span>            <span class="keyword">if</span> (compareAndSetTail(t, node)) &#123;                <span class="comment">// 之前的尾节点的next指针指向当前节点node</span>                t.next = node;                <span class="comment">// 返回之前的尾节点</span>                <span class="keyword">return</span> t;            &#125;        &#125;    &#125;&#125;</code></pre><p>节点入队不是原子操作，所以会出现短暂的 <code>head != tail</code>，此时Tail指向 <code>null</code>，而Head指向<code>虚节点</code>。这种情况下也需要将相关线程加入队列中。所以这块代码是为了解决极端情况下的并发问题。</p><h3 id="4-3-等待队列中线程出队列时机"><a href="#4-3-等待队列中线程出队列时机" class="headerlink" title="4.3 等待队列中线程出队列时机"></a>4.3 等待队列中线程出队列时机</h3><p>回到最初的源码：</p><pre><code class="highlight java"><span class="comment">// java.util.concurrent.locks.AbstractQueuedSynchronizer#acquire</span><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">void</span> <span class="title function_">acquire</span><span class="params">(<span class="type">int</span> arg)</span> &#123;    <span class="keyword">if</span> (!tryAcquire(arg) &amp;&amp; acquireQueued(addWaiter(Node.EXCLUSIVE), arg))        selfInterrupt();&#125;</code></pre><p>上文解释了<code>addWaiter</code>方法，这个方法其实就是把对应的线程以Node的数据结构形式加入到双端队列里，返回的是一个包含该线程的Node。而这个Node会作为参数，进入到<code>acquireQueued</code>方法中。<code>acquireQueued</code>方法可以对排队中的线程进行“获锁”操作。</p><p>总的来说，一个线程获取锁失败了，被放入等待队列，<code>acquireQueued</code>会把放入队列中的线程不断去获取锁，直到获取成功或者不再需要获取（中断）。</p><p>下面我们从“何时出队列？”和“如何出队列？”两个方向来分析一下acquireQueued源码：</p><pre><code class="highlight java"><span class="comment">// java.util.concurrent.locks.AbstractQueuedSynchronizer</span><span class="keyword">final</span> <span class="type">boolean</span> <span class="title function_">acquireQueued</span><span class="params">(<span class="keyword">final</span> Node node, <span class="type">int</span> arg)</span> &#123;<span class="comment">// 标记是否成功拿到资源</span><span class="type">boolean</span> <span class="variable">failed</span> <span class="operator">=</span> <span class="literal">true</span>;<span class="keyword">try</span> &#123;<span class="comment">// 标记等待过程中是否中断过</span><span class="type">boolean</span> <span class="variable">interrupted</span> <span class="operator">=</span> <span class="literal">false</span>;<span class="comment">// 开始自旋，要么获取锁，要么中断</span><span class="keyword">for</span> (;;) &#123;<span class="comment">// 获取当前节点的前驱节点</span><span class="keyword">final</span> <span class="type">Node</span> <span class="variable">p</span> <span class="operator">=</span> node.predecessor();<span class="comment">// 如果p是头结点，说明当前节点在真实数据队列的首部，就尝试获取锁（别忘了头结点是虚节点）</span><span class="keyword">if</span> (p == head &amp;&amp; tryAcquire(arg)) &#123;<span class="comment">// 获取锁成功，头指针移动到当前node</span>setHead(node);p.next = <span class="literal">null</span>; <span class="comment">// help GC</span>failed = <span class="literal">false</span>;<span class="keyword">return</span> interrupted;&#125;<span class="comment">// 说明p为头节点且当前没有获取到锁（可能是非公平锁被抢占了）或者是p不为头结点，这个时候就要判断当前node是否要被阻塞（被阻塞条件：前驱节点的waitStatus为-1），防止无限循环浪费资源。具体两个方法下面细细分析</span><span class="keyword">if</span> (shouldParkAfterFailedAcquire(p, node) &amp;&amp; parkAndCheckInterrupt())interrupted = <span class="literal">true</span>;&#125;&#125; <span class="keyword">finally</span> &#123;<span class="keyword">if</span> (failed)cancelAcquire(node);&#125;&#125;</code></pre><p>注：setHead方法是把当前节点置为虚节点，但并没有修改 <code>waitStatus</code>，因为它是一直需要用的数据。</p><pre><code class="highlight java"><span class="comment">// java.util.concurrent.locks.AbstractQueuedSynchronizer</span><span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">setHead</span><span class="params">(Node node)</span> &#123;head = node;node.thread = <span class="literal">null</span>;node.prev = <span class="literal">null</span>;&#125;<span class="comment">// java.util.concurrent.locks.AbstractQueuedSynchronizer</span><span class="comment">// 靠前驱节点判断当前线程是否应该被阻塞</span><span class="keyword">private</span> <span class="keyword">static</span> <span class="type">boolean</span> <span class="title function_">shouldParkAfterFailedAcquire</span><span class="params">(Node pred, Node node)</span> &#123;<span class="comment">// 获取头结点的节点状态</span><span class="type">int</span> <span class="variable">ws</span> <span class="operator">=</span> pred.waitStatus;<span class="comment">// 说明头结点处于唤醒状态</span><span class="keyword">if</span> (ws == Node.SIGNAL)<span class="keyword">return</span> <span class="literal">true</span>; <span class="comment">// 通过枚举值我们知道waitStatus&gt;0是取消状态</span><span class="keyword">if</span> (ws &gt; <span class="number">0</span>) &#123;<span class="keyword">do</span> &#123;<span class="comment">// 循环向前查找取消节点，把取消节点从队列中剔除</span>node.prev = pred = pred.prev;&#125; <span class="keyword">while</span> (pred.waitStatus &gt; <span class="number">0</span>);pred.next = node;&#125; <span class="keyword">else</span> &#123;<span class="comment">// 设置前任节点等待状态为SIGNAL</span>compareAndSetWaitStatus(pred, ws, Node.SIGNAL);&#125;<span class="keyword">return</span> <span class="literal">false</span>;&#125;</code></pre><p><code>shouldParkAfterFailedAcquire</code>方法实现业务：</p><ul><li>判断前节点（pred）waitStatus 是否为 SIGNAL(待唤醒)状态，如果是，直接返回true</li><li>如果前节点 <code>waitStatus &gt; 0</code> (已取消状态)，则从前节点开始一直往前找，找到一个<code>waitStatus</code>不大于0的节点，作为当前节点的前节点</li><li>如果前节点 <code>waitStatus = 0</code> (默认状态)，则将前节点的<code>waitStatus</code>设置成SIGNAL</li></ul><p><code>parkAndCheckInterrupt</code> 主要用于挂起当前线程，阻塞调用栈，返回当前线程的中断状态。</p><pre><code class="highlight java"><span class="comment">// java.util.concurrent.locks.AbstractQueuedSynchronizer</span><span class="keyword">private</span> <span class="keyword">final</span> <span class="type">boolean</span> <span class="title function_">parkAndCheckInterrupt</span><span class="params">()</span> &#123;    <span class="comment">// 挂起当前线程</span>    LockSupport.park(<span class="built_in">this</span>);    <span class="comment">// 当前线程重新执行后，判断线程是否被中断过，返回中断标记，并清除中断标记（如果返回为true，表示线程被中断过，由于interrupted 方法会清除中断标识，后面会通过 selfInterrupt()补充还原中断标识）</span>    <span class="keyword">return</span> Thread.interrupted();&#125;</code></pre><p>上述方法的流程图如下：</p><p><img src="https://raw.githubusercontent.com/GeorgeChan95/blogimg/master/img/2024/10/16/20241016-112025.png" alt="acquireQueued 调用流程"></p><p>从上图可以看出，跳出当前循环的条件是当“前置节点是头结点，且当前线程获取锁成功”。为了防止因死循环导致CPU资源被浪费，我们会判断前置节点的状态来决定是否要将当前线程挂起，具体挂起流程用流程图表示如下（shouldParkAfterFailedAcquire流程）：</p><p><img src="https://raw.githubusercontent.com/GeorgeChan95/blogimg/master/img/2024/10/16/20241016-131149.png" alt="shouldParkAfterFailedAcquire 流程"></p><p>由上述我们可以知道，此时经过 acquireQueued 方法的自旋处理后，头节点(虚节点) 的waitStatus设置成 SIGNAL(-1), 而 线程B 被挂起，等待唤醒。</p><p>此时队列如下：<br><img src="https://raw.githubusercontent.com/GeorgeChan95/blogimg/master/img/2024/10/16/20241016-112946.png" alt="线程B被挂起"></p><p>如果此时还有其它线程来争抢锁，例如：<code>线程C</code>、<code>线程D</code>、<code>线程E</code>、<code>线程F</code> ，也加入到队列中，如图下：</p><p><img src="https://raw.githubusercontent.com/GeorgeChan95/blogimg/master/img/2024/10/16/20241016-140123.png" alt="CLH队列"></p><p>尾节点 (NodeE) 的前节点waitStatus 都为 -1。</p><h3 id="4-4-CANCELLED状态节点生成"><a href="#4-4-CANCELLED状态节点生成" class="headerlink" title="4.4 CANCELLED状态节点生成"></a>4.4 CANCELLED状态节点生成</h3><p>如果线程在抢锁的过程中出现异常，或者线程被中断，此时 <code>acquireQueued</code> 方法会走到 <code>finally</code> 分支<code>，failed</code> 标识依然为 false</p><pre><code class="highlight java"><span class="comment">// java.util.concurrent.locks.AbstractQueuedSynchronizer</span><span class="keyword">final</span> <span class="type">boolean</span> <span class="title function_">acquireQueued</span><span class="params">(<span class="keyword">final</span> Node node, <span class="type">int</span> arg)</span> &#123;<span class="comment">// 标记是否成功拿到资源</span><span class="type">boolean</span> <span class="variable">failed</span> <span class="operator">=</span> <span class="literal">true</span>;<span class="keyword">try</span> &#123;<span class="comment">// 标记等待过程中是否中断过</span><span class="type">boolean</span> <span class="variable">interrupted</span> <span class="operator">=</span> <span class="literal">false</span>;<span class="comment">// 开始自旋，要么获取锁，要么中断</span><span class="keyword">for</span> (;;) &#123;<span class="comment">// 获取当前节点的前驱节点</span><span class="keyword">final</span> <span class="type">Node</span> <span class="variable">p</span> <span class="operator">=</span> node.predecessor();<span class="comment">// 如果p是头结点，说明当前节点在真实数据队列的首部，就尝试获取锁（别忘了头结点是虚节点）</span><span class="keyword">if</span> (p == head &amp;&amp; tryAcquire(arg)) &#123;...&#125;...&#125;&#125; <span class="keyword">finally</span> &#123;<span class="keyword">if</span> (failed) <span class="comment">// failed为false</span>             <span class="comment">// 执行线程的取消操作，从队列中出队</span>cancelAcquire(node);&#125;&#125;</code></pre><p>通过<code>cancelAcquire</code> 方法，将Node的状态标记为<code>CANCELLED</code>。接下来，我们逐行来分析这个方法的原理：</p><pre><code class="highlight java"><span class="comment">// java.util.concurrent.locks.AbstractQueuedSynchronizer</span><span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">cancelAcquire</span><span class="params">(Node node)</span> &#123;  <span class="comment">// 将无效节点过滤</span><span class="keyword">if</span> (node == <span class="literal">null</span>)<span class="keyword">return</span>;  <span class="comment">// 设置该节点不关联任何线程，也就是虚节点</span>node.thread = <span class="literal">null</span>;<span class="type">Node</span> <span class="variable">pred</span> <span class="operator">=</span> node.prev;  <span class="comment">// 通过前驱节点，跳过取消状态的node</span><span class="keyword">while</span> (pred.waitStatus &gt; <span class="number">0</span>)node.prev = pred = pred.prev;  <span class="comment">// 获取过滤后的前驱节点的后继节点</span><span class="type">Node</span> <span class="variable">predNext</span> <span class="operator">=</span> pred.next;  <span class="comment">// 把当前node的状态设置为CANCELLED</span>node.waitStatus = Node.CANCELLED;  <span class="comment">// 如果当前节点是尾节点，将从后往前的第一个非取消状态的节点设置为尾节点</span>  <span class="comment">// 更新失败的话，则进入else，如果更新成功，将tail的后继节点设置为null</span><span class="keyword">if</span> (node == tail &amp;&amp; compareAndSetTail(node, pred)) &#123;compareAndSetNext(pred, predNext, <span class="literal">null</span>);&#125; <span class="keyword">else</span> &#123;<span class="type">int</span> ws;    <span class="comment">// 如果当前节点不是head的后继节点，1:判断当前节点前驱节点的是否为SIGNAL，2:如果不是，则把前驱节点设置为SINGAL看是否成功</span>    <span class="comment">// 如果1和2中有一个为true，再判断前驱节点的线程是否为null</span>    <span class="comment">// 如果上述条件都满足，把当前节点的前驱节点的后继指针指向当前节点的后继节点</span><span class="keyword">if</span> (pred != head &amp;&amp; ((ws = pred.waitStatus) == Node.SIGNAL || (ws &lt;= <span class="number">0</span> &amp;&amp; compareAndSetWaitStatus(pred, ws, Node.SIGNAL))) &amp;&amp; pred.thread != <span class="literal">null</span>) &#123;<span class="type">Node</span> <span class="variable">next</span> <span class="operator">=</span> node.next;<span class="keyword">if</span> (next != <span class="literal">null</span> &amp;&amp; next.waitStatus &lt;= <span class="number">0</span>)compareAndSetNext(pred, predNext, next);&#125; <span class="keyword">else</span> &#123;      <span class="comment">// 如果当前节点是head的后继节点，或者上述条件不满足，那就唤醒当前节点的后继节点</span>unparkSuccessor(node);&#125;node.next = node; <span class="comment">// help GC</span>&#125;&#125;</code></pre><p>当前的流程：</p><ul><li>获取当前节点的前驱节点，如果前驱节点的状态是CANCELLED，那就一直往前遍历，找到第一个waitStatus &lt;&#x3D; 0的节点，将找到的Pred节点和当前Node关联，将当前Node设置为CANCELLED。</li><li>根据当前节点的位置，考虑以下三种情况：<ul><li>当前节点是尾节点。</li><li>当前节点是Head的后继节点。</li><li>当前节点不是Head的后继节点，也不是尾节点。</li></ul></li></ul><p>这里看一下<code>unparkSuccessor</code>方法：</p><pre><code class="highlight java"><span class="comment">// java.util.concurrent.locks.AbstractQueuedSynchronizer</span><span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">unparkSuccessor</span><span class="params">(Node node)</span> &#123;<span class="comment">// 获取头结点waitStatus</span><span class="type">int</span> <span class="variable">ws</span> <span class="operator">=</span> node.waitStatus;<span class="keyword">if</span> (ws &lt; <span class="number">0</span>)compareAndSetWaitStatus(node, ws, <span class="number">0</span>);<span class="comment">// 获取当前节点的下一个节点</span><span class="type">Node</span> <span class="variable">s</span> <span class="operator">=</span> node.next;<span class="comment">// 如果下个节点是null或者下个节点被cancelled，就找到队列最开始的非cancelled的节点</span><span class="keyword">if</span> (s == <span class="literal">null</span> || s.waitStatus &gt; <span class="number">0</span>) &#123;s = <span class="literal">null</span>;<span class="comment">// 就从尾部节点开始找，到队首，找到队列第一个waitStatus&lt;0的节点。</span><span class="keyword">for</span> (<span class="type">Node</span> <span class="variable">t</span> <span class="operator">=</span> tail; t != <span class="literal">null</span> &amp;&amp; t != node; t = t.prev)<span class="keyword">if</span> (t.waitStatus &lt;= <span class="number">0</span>)s = t;&#125;<span class="comment">// 如果当前节点的下个节点不为空，而且状态&lt;=0，就把下一个节点unpark</span><span class="keyword">if</span> (s != <span class="literal">null</span>)LockSupport.unpark(s.thread);&#125;</code></pre><p>根据上述第二条，我们来分析每一种情况的流程。</p><ul><li>当前节点是尾节点。</li></ul><p><img src="https://raw.githubusercontent.com/GeorgeChan95/blogimg/master/img/2024/10/16/20241016-152013.png" alt="当前节点是尾节点"></p><ul><li><p>当前节点是Head的后继节点。</p><p><img src="https://raw.githubusercontent.com/GeorgeChan95/blogimg/master/img/2024/10/16/20241016-152048.png" alt="当前节点是Head的后继节点"></p></li><li><p>当前节点不是Head的后继节点，也不是尾节点</p><p><img src="https://raw.githubusercontent.com/GeorgeChan95/blogimg/master/img/2024/10/16/20241016-152128.png" alt="即不是Head的后继节点，也不是尾节点"></p></li></ul><blockquote><p>以前面的线程队列为例，画流程示意图</p></blockquote><p>当前队列中的线程如下：<br><img src="https://raw.githubusercontent.com/GeorgeChan95/blogimg/master/img/2024/10/16/20241016-140123.png" alt="CLH队列"></p><p>此时 线程D 被中断执行，需要退出队列，退出后队列如下：<br><img src="https://raw.githubusercontent.com/GeorgeChan95/blogimg/master/img/2024/10/16/20241016-151241.png" alt="线程D被中断执行"></p><p>通过上面的流程，我们对于CANCELLED节点状态的产生和变化已经有了大致的了解，但是为什么所有的变化都是对Next指针进行了操作，而没有对Prev指针进行操作呢？什么情况下会对Prev指针进行操作？</p><blockquote><p>执行cancelAcquire的时候，当前节点的前置节点可能已经从队列中出去了（已经执行过Try代码块中的shouldParkAfterFailedAcquire方法了），如果此时修改Prev指针，有可能会导致Prev指向另一个已经移除队列的Node，因此这块变化Prev指针不安全。 shouldParkAfterFailedAcquire方法中，会执行下面的代码，其实就是在处理Prev指针。shouldParkAfterFailedAcquire是获取锁失败的情况下才会执行，进入该方法后，说明共享资源已被获取，当前节点之前的节点都不会出现变化，因此这个时候变更Prev指针比较安全。</p></blockquote><pre><code class="highlight java"><span class="keyword">do</span> &#123;    node.prev = pred = pred.prev;&#125; <span class="keyword">while</span> (pred.waitStatus &gt; <span class="number">0</span>);</code></pre><h2 id="5-如何解锁"><a href="#5-如何解锁" class="headerlink" title="5. 如何解锁"></a>5. 如何解锁</h2><p>前面我们说了，多个线程抢占资源，<code>线程A</code> 抢到了锁，<code>线程B</code>、<code>线程C</code>、<code>线程D</code>、<code>线程E</code> 没有抢到锁，进入CLH队列中的加锁情况，也说了 <code>线程D</code> 中断执行，退出队列的情况。</p><p>现在我们来说，<code>线程A</code> 执行结束，对AQS释放锁流程进行分析。由于ReentrantLock在解锁的时候，并不区分公平锁和非公平锁，所以我们直接看解锁的源码：</p><pre><code class="highlight java"><span class="comment">// java.util.concurrent.locks.ReentrantLock</span><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">unlock</span><span class="params">()</span> &#123;sync.release(<span class="number">1</span>);&#125;</code></pre><p>可以看到，本质释放锁的地方，是通过框架来完成的。</p><pre><code class="highlight java"><span class="comment">// java.util.concurrent.locks.AbstractQueuedSynchronizer</span><span class="keyword">public</span> <span class="keyword">final</span> <span class="type">boolean</span> <span class="title function_">release</span><span class="params">(<span class="type">int</span> arg)</span> &#123;    <span class="comment">// 尝试释放锁，成功返回true，失败则返回false</span>    <span class="keyword">if</span> (tryRelease(arg)) &#123;        <span class="comment">// 队列头节点</span>        <span class="type">Node</span> <span class="variable">h</span> <span class="operator">=</span> head;        <span class="keyword">if</span> (h != <span class="literal">null</span> &amp;&amp; h.waitStatus != <span class="number">0</span>)            <span class="comment">// 更新头节点的waitStatus，并唤醒头节点的后继节点</span>            unparkSuccessor(h);        <span class="keyword">return</span> <span class="literal">true</span>;    &#125;    <span class="keyword">return</span> <span class="literal">false</span>;&#125;</code></pre><p>在ReentrantLock里面的公平锁和非公平锁的父类Sync定义了可重入锁的释放锁机制。</p><pre><code class="highlight java"><span class="comment">// java.util.concurrent.locks.ReentrantLock.Sync</span><span class="comment">// 方法返回当前锁是不是没有被线程持有</span><span class="keyword">protected</span> <span class="keyword">final</span> <span class="type">boolean</span> <span class="title function_">tryRelease</span><span class="params">(<span class="type">int</span> releases)</span> &#123;<span class="comment">// 减少可重入次数</span><span class="type">int</span> <span class="variable">c</span> <span class="operator">=</span> getState() - releases;<span class="comment">// 当前线程不是持有锁的线程，抛出异常</span><span class="keyword">if</span> (Thread.currentThread() != getExclusiveOwnerThread())<span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">IllegalMonitorStateException</span>();<span class="type">boolean</span> <span class="variable">free</span> <span class="operator">=</span> <span class="literal">false</span>;<span class="comment">// 如果持有线程全部释放，将当前独占锁所有线程设置为null，并更新state</span><span class="keyword">if</span> (c == <span class="number">0</span>) &#123;free = <span class="literal">true</span>;setExclusiveOwnerThread(<span class="literal">null</span>);&#125;setState(c);<span class="keyword">return</span> free;&#125;</code></pre><p>这里反过来再看一下 java.util.concurrent.locks.AbstractQueuedSynchronizer#release 释放锁的代码</p><pre><code class="highlight java"><span class="comment">// java.util.concurrent.locks.AbstractQueuedSynchronizer</span><span class="keyword">public</span> <span class="keyword">final</span> <span class="type">boolean</span> <span class="title function_">release</span><span class="params">(<span class="type">int</span> arg)</span> &#123;<span class="comment">// 上边自定义的tryRelease如果返回true，说明该锁没有被任何线程持有</span><span class="keyword">if</span> (tryRelease(arg)) &#123;<span class="comment">// 获取头结点</span><span class="type">Node</span> <span class="variable">h</span> <span class="operator">=</span> head;<span class="comment">// 头结点不为空并且头结点的waitStatus不是初始化节点情况，解除线程挂起状态</span><span class="keyword">if</span> (h != <span class="literal">null</span> &amp;&amp; h.waitStatus != <span class="number">0</span>)unparkSuccessor(h);<span class="keyword">return</span> <span class="literal">true</span>;&#125;<span class="keyword">return</span> <span class="literal">false</span>;&#125;</code></pre><p>这里的判断条件为什么是h !&#x3D; null &amp;&amp; h.waitStatus !&#x3D; 0？</p><ul><li><code>h == null</code> Head还没初始化。初始情况下，<code>head == null</code>，第一个节点入队，Head会被初始化一个虚拟节点。所以说，这里如果还没来得及入队，就会出现head &#x3D;&#x3D; null 的情况。<ul><li>如：<code>线程A</code>执行结束，其它线程还没有争抢锁的情况</li></ul></li><li><code>h != null &amp;&amp; waitStatus == 0</code> 表明后继节点对应的线程仍在运行中，不需要唤醒。<ul><li>如：<code>线程A</code> 执行结束，其它线程刚刚开始争抢锁，CLH队列正在初始化</li></ul></li><li><code>h != null &amp;&amp; waitStatus &lt; 0</code> 表明后继节点可能被阻塞了，需要唤醒。<ul><li>如：线程A 执行结束，此时CLH队列已经有多个线程排队等待唤醒</li></ul></li></ul><p>再看一下unparkSuccessor方法：</p><pre><code class="highlight java"><span class="comment">// java.util.concurrent.locks.AbstractQueuedSynchronizer</span><span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">unparkSuccessor</span><span class="params">(Node node)</span> &#123;<span class="comment">// 获取头结点waitStatus</span><span class="type">int</span> <span class="variable">ws</span> <span class="operator">=</span> node.waitStatus;<span class="keyword">if</span> (ws &lt; <span class="number">0</span>)compareAndSetWaitStatus(node, ws, <span class="number">0</span>);<span class="comment">// 获取当前节点的下一个节点</span><span class="type">Node</span> <span class="variable">s</span> <span class="operator">=</span> node.next;<span class="comment">// 如果下个节点是null或者下个节点被cancelled，就找到队列最开始的非cancelled的节点</span><span class="keyword">if</span> (s == <span class="literal">null</span> || s.waitStatus &gt; <span class="number">0</span>) &#123;s = <span class="literal">null</span>;<span class="comment">// 就从尾部节点开始找，到队首，找到队列第一个waitStatus&lt;0的节点。</span><span class="keyword">for</span> (<span class="type">Node</span> <span class="variable">t</span> <span class="operator">=</span> tail; t != <span class="literal">null</span> &amp;&amp; t != node; t = t.prev)<span class="keyword">if</span> (t.waitStatus &lt;= <span class="number">0</span>)s = t;&#125;<span class="comment">// 如果当前节点的下个节点不为空，而且状态&lt;=0，就把下一个节点unpark</span><span class="keyword">if</span> (s != <span class="literal">null</span>)LockSupport.unpark(s.thread);&#125;</code></pre><p>对应到我们的CLH队列示例图，就是 <code>虚节点</code> 的 <code>waitStatus</code> 设置成了0，然后将 <code>线程B</code> unpark。</p><p><img src="https://raw.githubusercontent.com/GeorgeChan95/blogimg/master/img/2024/10/16/20241016-160950.png" alt="线程B解锁"></p><p>为什么要从后往前找第一个非Cancelled的节点呢？原因如下。</p><p>之前的 <code>addWaiter</code> 方法：</p><pre><code class="highlight java"><span class="comment">// java.util.concurrent.locks.AbstractQueuedSynchronizer#addWaiter</span><span class="keyword">private</span> Node <span class="title function_">addWaiter</span><span class="params">(Node mode)</span> &#123;    <span class="comment">// 通过当前的线程和锁模式新建一个节点</span>    <span class="type">Node</span> <span class="variable">node</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Node</span>(Thread.currentThread(), mode);    <span class="comment">// Pred指针指向尾节点Tail</span>    <span class="type">Node</span> <span class="variable">pred</span> <span class="operator">=</span> tail;    <span class="keyword">if</span> (pred != <span class="literal">null</span>) &#123;        <span class="comment">// 将New中Node的Prev指针指向Pred</span>        node.prev = pred;        <span class="comment">// CAS设置Tail节点为新建的节点</span>        <span class="keyword">if</span> (compareAndSetTail(pred, node)) &#123;            <span class="comment">// pred节点的next指针指向新的node节点</span>            pred.next = node;            <span class="comment">// 返回新建的node节点</span>            <span class="keyword">return</span> node;        &#125;    &#125;    <span class="comment">// node节点加入CLH队列</span>    enq(node);    <span class="comment">// 返回node节点</span>    <span class="keyword">return</span> node;&#125;</code></pre><p>我们从这里可以看到，节点入队并不是原子操作，也就是说，<code>node.prev = pred;</code> <code>compareAndSetTail(pred, node)</code>  这两个地方可以看作Tail入队的原子操作，但是此时 <code>pred.next = node;</code> 还没执行，如果这个时候执行了unparkSuccessor方法，就没办法从前往后找了，所以需要从后往前找。还有一点原因，在产生CANCELLED状态节点的时候，先断开的是Next指针，Prev指针并未断开，因此也是必须要从后往前遍历才能够遍历完全部的Node。</p><p>综上所述，如果是从前往后找，由于极端情况下入队的非原子操作和CANCELLED节点产生过程中断开Next指针的操作，可能会导致无法遍历所有的节点。所以，唤醒对应的线程后，对应的线程就会继续往下执行。</p><pre><code class="highlight java"></code></pre><h2 id="6-中断恢复后的执行流程"><a href="#6-中断恢复后的执行流程" class="headerlink" title="6. 中断恢复后的执行流程"></a>6. 中断恢复后的执行流程</h2><p><code>线程B</code> 被唤醒后，会执行<code>return Thread.interrupted();</code>，这个函数返回的是当前执行线程的中断状态，并清除。</p><pre><code class="highlight java"><span class="comment">// java.util.concurrent.locks.AbstractQueuedSynchronizer</span><span class="keyword">private</span> <span class="keyword">final</span> <span class="type">boolean</span> <span class="title function_">parkAndCheckInterrupt</span><span class="params">()</span> &#123;LockSupport.park(<span class="built_in">this</span>);<span class="keyword">return</span> Thread.interrupted();&#125;</code></pre><p>再回到 <code>acquireQueued</code> 代码，当 <code>parkAndCheckInterrupt</code> 返回True或者False的时候，interrupted的值不同，但都会执行下次循环。如果这个时候获取锁成功，就会把当前interrupted返回。</p><pre><code class="highlight java"><span class="comment">// java.util.concurrent.locks.AbstractQueuedSynchronizer</span><span class="keyword">final</span> <span class="type">boolean</span> <span class="title function_">acquireQueued</span><span class="params">(<span class="keyword">final</span> Node node, <span class="type">int</span> arg)</span> &#123;<span class="comment">// 标记是否成功拿到资源</span><span class="type">boolean</span> <span class="variable">failed</span> <span class="operator">=</span> <span class="literal">true</span>;<span class="keyword">try</span> &#123;<span class="comment">// 标记等待过程中是否中断过</span><span class="type">boolean</span> <span class="variable">interrupted</span> <span class="operator">=</span> <span class="literal">false</span>;<span class="comment">// 开始自旋，要么获取锁，要么中断</span><span class="keyword">for</span> (;;) &#123;<span class="comment">// 获取当前节点的前驱节点</span><span class="keyword">final</span> <span class="type">Node</span> <span class="variable">p</span> <span class="operator">=</span> node.predecessor();<span class="comment">// 如果p是头结点，说明当前节点在真实数据队列的首部，就尝试获取锁（别忘了头结点是虚节点）</span><span class="keyword">if</span> (p == head &amp;&amp; tryAcquire(arg)) &#123;<span class="comment">// 获取锁成功，头指针移动到当前node</span>setHead(node);p.next = <span class="literal">null</span>; <span class="comment">// help GC</span>failed = <span class="literal">false</span>;                 <span class="comment">// 返回线程的中断标识</span><span class="keyword">return</span> interrupted;&#125;<span class="comment">// 说明p为头节点且当前没有获取到锁（可能是非公平锁被抢占了）或者是p不为头结点，这个时候就要判断当前node是否要被阻塞（被阻塞条件：前驱节点的waitStatus为-1），防止无限循环浪费资源。具体两个方法下面细细分析</span><span class="keyword">if</span> (shouldParkAfterFailedAcquire(p, node) &amp;&amp; parkAndCheckInterrupt())                 <span class="comment">// 中断标识设置为true</span>interrupted = <span class="literal">true</span>;&#125;&#125; <span class="keyword">finally</span> &#123;<span class="keyword">if</span> (failed)             <span class="comment">// 取消线程执行</span>cancelAcquire(node);&#125;&#125;</code></pre><p>如果acquireQueued为True，就会执行selfInterrupt方法。</p><pre><code class="highlight java"><span class="comment">// java.util.concurrent.locks.AbstractQueuedSynchronizer</span><span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">selfInterrupt</span><span class="params">()</span> &#123;Thread.currentThread().interrupt();&#125;</code></pre><ul><li>当中断线程被唤醒时，并不知道被唤醒的原因，可能是当前线程在等待中被中断，也可能是释放了锁以后被唤醒。因此我们通过Thread.interrupted()方法检查中断标记（该方法返回了当前线程的中断状态，并将当前线程的中断标识设置为False），并记录下来，如果发现该线程被中断过，就再中断一次（重新恢复线程的中断标识）。</li><li>线程在等待资源的过程中被唤醒，唤醒后还是会不断地去尝试获取锁，直到抢到锁为止。也就是说，在整个流程中，并不响应中断，只是记录中断记录。最后抢到锁返回了，那么如果被中断过的话，就需要补充一次中断。</li></ul><h1 id="六、AQS应用"><a href="#六、AQS应用" class="headerlink" title="六、AQS应用"></a>六、AQS应用</h1><h2 id="1-ReentrantLock的可重入应用"><a href="#1-ReentrantLock的可重入应用" class="headerlink" title="1. ReentrantLock的可重入应用"></a>1. ReentrantLock的可重入应用</h2><p>ReentrantLock的可重入性是AQS很好的应用之一，在了解完上述知识点以后，我们很容易得知ReentrantLock实现可重入的方法。在ReentrantLock里面，不管是公平锁还是非公平锁，都有一段逻辑。</p><ul><li><p>公平锁：</p><pre><code class="highlight java"><span class="comment">// java.util.concurrent.locks.ReentrantLock.FairSync#tryAcquire</span><span class="keyword">if</span> (c == <span class="number">0</span>) &#123;<span class="keyword">if</span> (!hasQueuedPredecessors() &amp;&amp; compareAndSetState(<span class="number">0</span>, acquires)) &#123;setExclusiveOwnerThread(current);<span class="keyword">return</span> <span class="literal">true</span>;&#125;&#125;<span class="keyword">else</span> <span class="keyword">if</span> (current == getExclusiveOwnerThread()) &#123;<span class="type">int</span> <span class="variable">nextc</span> <span class="operator">=</span> c + acquires;<span class="keyword">if</span> (nextc &lt; <span class="number">0</span>)<span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">Error</span>(<span class="string">&quot;Maximum lock count exceeded&quot;</span>);setState(nextc);<span class="keyword">return</span> <span class="literal">true</span>;&#125;</code></pre></li><li><p>非公平锁：</p><pre><code class="highlight java"><span class="comment">// java.util.concurrent.locks.ReentrantLock.Sync#nonfairTryAcquire</span><span class="keyword">if</span> (c == <span class="number">0</span>) &#123;<span class="keyword">if</span> (compareAndSetState(<span class="number">0</span>, acquires))&#123;setExclusiveOwnerThread(current);<span class="keyword">return</span> <span class="literal">true</span>;&#125;&#125;<span class="keyword">else</span> <span class="keyword">if</span> (current == getExclusiveOwnerThread()) &#123;<span class="type">int</span> <span class="variable">nextc</span> <span class="operator">=</span> c + acquires;<span class="keyword">if</span> (nextc &lt; <span class="number">0</span>) <span class="comment">// overflow</span><span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">Error</span>(<span class="string">&quot;Maximum lock count exceeded&quot;</span>);setState(nextc);<span class="keyword">return</span> <span class="literal">true</span>;&#125;</code></pre></li></ul><p>从上面这两段都可以看到，有一个 <code>同步状态State</code> 来控制整体可重入的情况。<code>State</code>是<code>Volatile</code>修饰的，用于保证一定的可见性和有序性。</p><pre><code class="highlight java"><span class="comment">// java.util.concurrent.locks.AbstractQueuedSynchronizer</span><span class="keyword">private</span> <span class="keyword">volatile</span> <span class="type">int</span> state;</code></pre><p>接下来看State这个字段主要的过程：</p><ul><li>State初始化的时候为0，表示没有任何线程持有锁。</li><li>当有线程持有该锁时，值就会在原来的基础上+1，同一个线程多次获得锁是，就会多次+1，这里就是可重入的概念。</li><li>解锁也是对这个字段-1，一直到0，此线程对锁释放。</li></ul><h2 id="2-JUC中的应用场景"><a href="#2-JUC中的应用场景" class="headerlink" title="2. JUC中的应用场景"></a>2. JUC中的应用场景</h2><p>除了上边ReentrantLock的可重入性的应用，AQS作为并发编程的框架，为很多其他同步工具提供了良好的解决方案。下面列出了JUC中的几种同步工具，大体介绍一下AQS的应用场景：</p><table><thead><tr><th align="left">同步工具</th><th align="left">同步工具与AQS的关联</th></tr></thead><tbody><tr><td align="left">ReentrantLock</td><td align="left">使用AQS保存锁重复持有的次数。当一个线程获取锁时，ReentrantLock记录当前获得锁的线程标识，用于检测是否重复获取，以及错误线程试图解锁操作时异常情况的处理。</td></tr><tr><td align="left">Semaphore</td><td align="left">使用AQS同步状态来保存信号量的当前计数。tryRelease会增加计数，acquireShared会减少计数。</td></tr><tr><td align="left">CountDownLatch</td><td align="left">使用AQS同步状态来表示计数。计数为0时，所有的Acquire操作（CountDownLatch的await方法）才可以通过。</td></tr><tr><td align="left">ReentrantReadWriteLock</td><td align="left">使用AQS同步状态中的16位保存写锁持有的次数，剩下的16位用于保存读锁的持有次数。</td></tr><tr><td align="left">ThreadPoolExecutor</td><td align="left">Worker利用AQS同步状态实现对独占线程变量的设置（tryAcquire和tryRelease）。</td></tr></tbody></table><h2 id="3-自定义同步工具"><a href="#3-自定义同步工具" class="headerlink" title="3. 自定义同步工具"></a>3. 自定义同步工具</h2><p>了解AQS基本原理以后，按照上面所说的AQS知识点，自己实现一个同步工具。</p><pre><code class="highlight java"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">MyLock</span> &#123;    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">class</span> <span class="title class_">Sync</span> <span class="keyword">extends</span> <span class="title class_">AbstractQueuedSynchronizer</span> &#123;        <span class="meta">@Override</span>        <span class="keyword">protected</span> <span class="type">boolean</span> <span class="title function_">tryAcquire</span><span class="params">(<span class="type">int</span> arg)</span> &#123;            <span class="keyword">return</span> compareAndSetState(<span class="number">0</span>, <span class="number">1</span>);        &#125;        <span class="meta">@Override</span>        <span class="keyword">protected</span> <span class="type">boolean</span> <span class="title function_">tryRelease</span><span class="params">(<span class="type">int</span> arg)</span> &#123;            <span class="keyword">return</span> compareAndSetState(<span class="number">1</span>, <span class="number">0</span>);        &#125;        <span class="meta">@Override</span>        <span class="keyword">protected</span> <span class="type">boolean</span> <span class="title function_">isHeldExclusively</span><span class="params">()</span> &#123;            <span class="keyword">return</span> getState() == <span class="number">1</span>;        &#125;    &#125;    <span class="keyword">private</span> <span class="type">Sync</span> <span class="variable">sync</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Sync</span>();    <span class="comment">/**</span><span class="comment">     * 加锁</span><span class="comment">     */</span>    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">lock</span><span class="params">()</span> &#123;        sync.acquire(<span class="number">1</span>);    &#125;    <span class="comment">/**</span><span class="comment">     * 解锁</span><span class="comment">     */</span>    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">unlock</span><span class="params">()</span> &#123;        sync.release(<span class="number">1</span>);    &#125;&#125;</code></pre><p>测试代码：</p><pre><code class="highlight java"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">TestMyLock</span> &#123;    <span class="keyword">static</span> <span class="type">int</span> <span class="variable">count</span> <span class="operator">=</span> <span class="number">0</span>;    <span class="keyword">static</span> <span class="type">MyLock</span> <span class="variable">myLock</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">MyLock</span>();    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span> <span class="params">(String[] args)</span> <span class="keyword">throws</span> InterruptedException &#123;        <span class="type">Runnable</span> <span class="variable">runnable</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Runnable</span>() &#123;            <span class="meta">@Override</span>            <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span> <span class="params">()</span> &#123;                <span class="keyword">try</span> &#123;                    myLock.lock();                    <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; <span class="number">10000</span>; i++) &#123;                        count++;                    &#125;                &#125; <span class="keyword">catch</span> (Exception e) &#123;                    e.printStackTrace();                &#125; <span class="keyword">finally</span> &#123;                    myLock.unlock();                &#125;            &#125;        &#125;;        <span class="type">Thread</span> <span class="variable">thread1</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Thread</span>(runnable);        <span class="type">Thread</span> <span class="variable">thread2</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Thread</span>(runnable);        thread1.start();        thread2.start();        thread1.join();        thread2.join();        System.out.println(count);    &#125;&#125;</code></pre><p>运行结果：</p><pre><code class="highlight shell">20000</code></pre><p>上述代码每次运行结果都会是20000。通过简单的几行代码就能实现同步功能，这就是AQS的强大之处。</p><p>本文主要参考以下链接</p><blockquote><p><a href="https://tech.meituan.com/2019/12/05/aqs-theory-and-apply.html">从ReentrantLock的实现看AQS的原理及应用</a></p></blockquote>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;一、前置知识&quot;&gt;&lt;a href=&quot;#一、前置知识&quot; class=&quot;headerlink&quot; title=&quot;一、前置知识&quot;&gt;&lt;/a&gt;一、前置知识&lt;/h1&gt;&lt;ul&gt;
&lt;li&gt;&lt;p&gt;&lt;strong&gt;公平锁和非公平锁&lt;/strong&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;公平锁：锁被</summary>
      
    
    
    
    <category term="JUC" scheme="https://georgechan95.github.io/categories/JUC/"/>
    
    
    <category term="juc" scheme="https://georgechan95.github.io/tags/juc/"/>
    
    <category term="java" scheme="https://georgechan95.github.io/tags/java/"/>
    
  </entry>
  
  <entry>
    <title>11-JUC进阶-Synchronized与锁升级</title>
    <link href="https://georgechan95.github.io/blog/3e0d7592.html"/>
    <id>https://georgechan95.github.io/blog/3e0d7592.html</id>
    <published>2024-10-06T01:28:00.000Z</published>
    <updated>2024-10-08T04:46:24.744Z</updated>
    
    <content type="html"><![CDATA[<h1 id="一、Synchronized的性能变化"><a href="#一、Synchronized的性能变化" class="headerlink" title="一、Synchronized的性能变化"></a>一、Synchronized的性能变化</h1><h2 id="1-用户态与内核态切换"><a href="#1-用户态与内核态切换" class="headerlink" title="1. 用户态与内核态切换"></a>1. 用户态与内核态切换</h2><p>java5以前，只有 <code>Synchronized</code>，这个是操作系统级别的重量级操作.</p><p>重量级锁，假如锁的竞争比较激烈的话，性能会下降. 因为重量级锁需要在用户态和内核态之间反复切换,消耗大量的资源.</p><p><strong>Java5之前，用户态和内核态之间的切换</strong></p><p><img src="https://raw.githubusercontent.com/GeorgeChan95/blogimg/master/img/2024/10/06/20241006-105654.png" alt="用户态和内核态之间的切换"></p><p> java的线程是映射到操作系统原生线程之上的，如果要阻塞或唤醒一个线程就需要操作系统介入，需要在用户态与核心态之间切换，这种切换会消耗大量的系统资源，因为用户态与内核态都有各自专用的内存空间，专用的寄存器等，用户态切换至内核态需要传递给许多变量、参数给内核，内核也需要保护好用户态在切换时的一些寄存器值、变量等，以便内核态调用结束后切换回用户态继续工作。</p><p>在Java早期版本中，synchronized属于重量级锁，效率低下，因为监视器锁（monitor）是依赖于底层的操作系统的Mutex Lock来实现的，挂起线程和恢复线程都需要转入内核态去完成，阻塞或唤醒一个Java线程需要操作系统切换CPU状态来完成，这种状态切换需要耗费处理器时间，如果同步代码块中内容过于简单，这种切换的时间可能比用户代码执行的时间还长”，时间成本相对较高，这也是为什么早期的synchronized效率低的原因.</p><p>Java 6之后，为了减少获得锁和释放锁所带来的性能消耗，引入了轻量级锁和偏向锁</p><h2 id="2-为什么每一个对象都可以成为锁"><a href="#2-为什么每一个对象都可以成为锁" class="headerlink" title="2. 为什么每一个对象都可以成为锁?"></a>2. 为什么每一个对象都可以成为锁?</h2><p><strong>Java对象头</strong></p><p>在Hotspot虚拟机中，对象在内存中的布局分为三块区域：对象头、实例数据和对齐填充；Java对象头是实现synchronized的锁对象的基础，一般而言，synchronized使用的锁对象是存储在Java对象头里。它是轻量级锁和偏向锁的关键</p><p><strong>Mawrk Word</strong></p><p>Mark Word用于存储对象自身的运行时数据，如哈希码（HashCode）、GC分代年龄、锁状态标志、线程持有的锁、偏向线程 ID、偏向时间戳等等。</p><p>在64位系统中，Mark Word占了8个字节，类型指针占了8个字节，一共是16个字节</p><p><img src="https://raw.githubusercontent.com/GeorgeChan95/blogimg/master/img/2024/10/04/20241004-110133.png" alt="Mark Word 的存储结构"></p><p><strong>在源码中的体现：</strong></p><p>如果想更深入了解对象头在JVM源码中的定义，需要关心几个文件，<code>oop.hpp/markOop.hpp</code> 。</p><p><code>oop.hpp</code>，每个 Java Object 在 JVM 内部都有一个 native 的 C++ 对象 oop&#x2F;oopDesc 与之对应。先在<code>oop.hpp</code>中看<code>oopDesc</code>的定义：</p><pre><code class="highlight cpp"><span class="keyword">class</span> <span class="title class_">oopDesc</span> &#123;  <span class="keyword">friend</span> <span class="keyword">class</span> <span class="title class_">VMStructs</span>; <span class="keyword">private</span>:  <span class="keyword">volatile</span> markOop  _mark;<span class="comment">//理解为对象头</span>  <span class="keyword">union</span> <span class="title class_">_metadata</span> &#123;    Klass*      _klass;<span class="comment">//理解为类型指针</span>    narrowKlass _compressed_klass; <span class="comment">//默认开启压缩</span>  &#125; _metadata;......</code></pre><p><code>_mark</code> 被声明在 oopDesc 类的顶部，所以这个 <code>_mark</code> 可以认为是一个 头部, 也就是上面那个图种提到的头部保存了一些重要的状态和标识信息，在<code>markOop.hpp</code>文件中有一些注释说明markOop的内存布局：</p><p>官网: <a href="https://hg.openjdk.org/jdk8u/jdk8u/hotspot/file/89fb452b3688/src/share/vm/oops/markOop.hpp">https://hg.openjdk.org/jdk8u/jdk8u/hotspot/file/89fb452b3688/src/share/vm/oops/markOop.hpp</a></p><pre><code class="highlight cpp"><span class="comment">//  64 bits:</span><span class="comment">//  --------</span><span class="comment">//  unused:25 hash:31 --&gt;| unused:1   age:4    biased_lock:1 lock:2 (normal object) // 普通无锁对象</span><span class="comment">//  JavaThread*:54 epoch:2 unused:1   age:4    biased_lock:1 lock:2 (biased object) // 偏向锁对象</span><span class="comment">//  PromotedObject*:61 ---------------------&gt;| promo_bits:3 -----&gt;| (CMS promoted object) // CMS垃圾回收器中的提升对象</span><span class="comment">//  size:64 -----------------------------------------------------&gt;| (CMS free block) // CMS垃圾回收器中的空闲块</span><span class="comment">//</span></code></pre><h4 id="Monitor"><a href="#Monitor" class="headerlink" title="Monitor"></a><strong>Monitor</strong></h4><p>什么是Monitor？我们可以把它理解为一个同步工具，也可以描述为一种同步机制。所有的Java对象是天生的Monitor，每个object的对象里 markOop-&gt;monitor() 里可以保存ObjectMonitor的对象。从源码层面看一下monitor对象.</p><ul><li>oop.hpp下的oopDesc类是JVM对象的顶级基类，所以每个object对象都包含markOop</li></ul><pre><code class="highlight cpp"><span class="keyword">class</span> <span class="title class_">oopDesc</span> &#123;<span class="comment">//顶层基类</span>  <span class="keyword">friend</span> <span class="keyword">class</span> <span class="title class_">VMStructs</span>; <span class="keyword">private</span>:  <span class="keyword">volatile</span> markOop  _mark;<span class="comment">//这也就是每个对象的mark头</span>  <span class="keyword">union</span> <span class="title class_">_metadata</span> &#123;    Klass*      _klass;    narrowKlass _compressed_klass;  &#125; _metadata;</code></pre><ul><li><p>markOop.hpp 中 <code>markOopDesc</code> 继承自oopDesc</p><p><img src="https://raw.githubusercontent.com/GeorgeChan95/blogimg/master/img/2024/10/06/20241006-120755.png" alt="markOopDesc"></p><p>并扩展了自己的monitor方法，这个方法返回一个ObjectMonitor指针对象：这个ObjectMonitor 其实就是对象监视器</p><p><img src="https://raw.githubusercontent.com/GeorgeChan95/blogimg/master/img/2024/10/06/20241006-120858.png" alt="img"></p></li><li><p><code>objectMonitor.hpp</code> , 在hotspot虚拟机中，采用 <code>ObjectMonitor</code> 类来实现 monitor：</p><p><img src="https://raw.githubusercontent.com/GeorgeChan95/blogimg/master/img/2024/10/06/20241006-121021.png" alt="objectMonitor.hpp"></p></li></ul><p>到目前位置，对于锁存在哪个位置，我们已经清楚了，<strong>锁存在于每个对象的 markOop 对象头中</strong>.对于为什么每个对象都可以成为锁呢？ 因为每个 Java Object 在 JVM 内部都有一个 native 的 C++ 对象 oop&#x2F;oopDesc 与之对应，而对应的 oop&#x2F;oopDesc 都会存在一个markOop 对象头，而这个对象头是存储锁的位置，<strong>里面还有对象监视器，即ObjectMonitor</strong>，所以这也是为什么每个对象都能成为锁的原因之一。</p><h2 id="3-Java6的优化提升"><a href="#3-Java6的优化提升" class="headerlink" title="3. Java6的优化提升"></a>3. Java6的优化提升</h2><p>java6开始，优化Synchronized, Java6之后，为了减少获得锁和释放锁所带来的性能消耗，引入了<strong>轻量级锁</strong>和<strong>偏向锁</strong></p><p>​</p><h1 id="二、synchronized锁种类及升级步骤"><a href="#二、synchronized锁种类及升级步骤" class="headerlink" title="二、synchronized锁种类及升级步骤"></a>二、synchronized锁种类及升级步骤</h1><h2 id="1-多线程访问的3种情况"><a href="#1-多线程访问的3种情况" class="headerlink" title="1. 多线程访问的3种情况"></a>1. 多线程访问的3种情况</h2><ul><li>只有一个线程来访问</li><li>有2个线程交替访问</li><li>竞争激烈，多个线程同时来访问</li></ul><h2 id="2-升级流程"><a href="#2-升级流程" class="headerlink" title="2. 升级流程"></a>2. 升级流程</h2><p>synchronized 用的锁是存在Java对象头里的Mark Word中, 锁升级功能主要依赖 MarkWord 中锁标志位和释放偏向锁标志位.</p><p><img src="https://raw.githubusercontent.com/GeorgeChan95/blogimg/master/img/2024/10/06/20241006-122447.png" alt="64位系统,对象内存布局"></p><p><strong>锁指向</strong></p><ul><li>偏向锁：MarkWord存储的是<strong>偏向的线程ID</strong>；</li><li>轻量锁：MarkWord存储的是<strong>指向线程栈中Lock Record的指针</strong>；</li><li>重量锁：MarkWord存储的是<strong>指向堆中的monitor对象的指针</strong>；</li></ul><h2 id="3-无锁"><a href="#3-无锁" class="headerlink" title="3. 无锁"></a>3. 无锁</h2><p><strong>引入依赖</strong></p><pre><code class="highlight xml"><span class="comment">&lt;!--</span><span class="comment">   官网：http://openjdk.java.net/projects/code-tools/jol/</span><span class="comment">   定位：分析对象在JVM的大小和分布</span><span class="comment">--&gt;</span><span class="tag">&lt;<span class="name">dependency</span>&gt;</span>    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.openjdk.jol<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span>    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>jol-core<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span>    <span class="tag">&lt;<span class="name">version</span>&gt;</span>0.9<span class="tag">&lt;/<span class="name">version</span>&gt;</span><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></code></pre><p><strong>实例代码</strong></p><pre><code class="highlight java"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">MyObject</span> &#123;    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;        <span class="type">Object</span> <span class="variable">o</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Object</span>();        System.out.println(<span class="string">&quot;10进制hash码：&quot;</span> + o.hashCode());        System.out.println(<span class="string">&quot;16进制hash码：&quot;</span> + Integer.toHexString(o.hashCode()));        System.out.println(<span class="string">&quot;2进制hash码：&quot;</span> + Integer.toBinaryString(o.hashCode()));        System.out.println(ClassLayout.parseInstance(o).toPrintable());    &#125;&#125;</code></pre><p>打印如下:</p><p><img src="https://raw.githubusercontent.com/GeorgeChan95/blogimg/master/img/2024/10/06/20241006-123233.png" alt="image-20241006123232465"></p><p><strong>001</strong> 表示无锁.</p><p><strong>注意, 对象头打印内容为 大端序.</strong></p><p><strong>大端序（Big-Endian）</strong>将数据的低位字节存放在内存的高位地址，高位字节存放在低位地址。这种排列方式与数据用字节表示时的书写顺序一致，符合人类的阅读习惯。</p><p><strong>小端序（Little-Endian）</strong>，将一个多位数的低位放在较小的地址处，高位放在较大的地址处，则称小端序。小端序与人类的阅读习惯相反，但更符合计算机读取内存的方式，因为CPU读取内存中的数据时，是从低地址向高地址方向进行读取的。</p><p>对象头大端序打印如下(前8子节):</p><pre><code class="highlight plaintext">00000001 01000001 00111010 00101011 01000101 00000000 00000000 00000000</code></pre><p>转为小端序如下:</p><pre><code class="highlight plaintext">00000000 00000000 00000000 01000101 00101011 00111010 01000001 00000001</code></pre><p>前25位没有用到, 中间31位即为hashCode: 1000101 00101011 00111010 01000001, 与print语句打印的 2进制hash码一致.</p><p><img src="https://raw.githubusercontent.com/GeorgeChan95/blogimg/master/img/2024/10/06/20241006-124320.png" alt="无锁态"></p><h2 id="4-偏锁"><a href="#4-偏锁" class="headerlink" title="4. 偏锁"></a>4. 偏锁</h2><h3 id="4-1-主要作用"><a href="#4-1-主要作用" class="headerlink" title="4.1 主要作用"></a>4.1 主要作用</h3><ul><li>当一段同步代码一直被同一个线程多次访问，由于只有一个线程那么该线程在后续访问时便会自动获得锁</li></ul><p>Hotspot 的作者经过研究发现，大多数情况下：</p><p>多线程的情况下，锁不仅不存在多线程竞争，还存在锁由同一线程多次获得的情况，偏向锁就是在这种情况下出现的，它的出现是为了解决只有在一个线程执行同步时提高性能。</p><h3 id="4-2-偏向锁的持有"><a href="#4-2-偏向锁的持有" class="headerlink" title="4.2 偏向锁的持有"></a>4.2 偏向锁的持有</h3><h4 id="4-2-1-理论"><a href="#4-2-1-理论" class="headerlink" title="4.2.1 理论"></a>4.2.1 理论</h4><p><strong>理论解析</strong></p><p>在实际应用运行过程中发现，“锁总是同一个线程持有，很少发生竞争”，也就是说锁总是被第一个占用他的线程拥有，这个线程就是锁的偏向线程。</p><p>那么只需要**在锁第一次被拥有的时候，记录下偏向线程ID。这样偏向线程就一直持有着锁(后续这个线程进入和退出这段加了同步锁的代码块时，不需要再次加锁和释放锁。而是直接比较对象头里面是否存储了指向当前线程的偏向锁)**。<br>如果相等表示偏向锁是偏向于当前线程的，就不需要再尝试获得锁了，直到竞争发生才释放锁。以后每次同步，检查锁的偏向线程ID与当前线程ID是否一致，如果一致直接进入同步。无需每次加锁解锁都去CAS更新对象头。如果自始至终使用锁的线程只有一个，很明显偏向锁几乎没有额外开销，性能极高。</p><p> 假如不一致意味着发生了竞争，锁已经不是总是偏向于同一个线程了，这时候可能需要升级变为轻量级锁，才能保证线程间公平竞争锁。偏向锁只有遇到其他线程尝试竞争偏向锁时，持有偏向锁的线程才会释放锁，线程是不会主动释放偏向锁的。</p><p><strong>技术实现</strong></p><p>一个synchronized方法被一个线程抢到了锁时，那这个方法所在的对象就会修改Mark Word 的偏向锁状态位，同时还会占用前54位来存储线程指针作为标识。若该线程再次访问同一个synchronized方法时，该线程只需去对象头的Mark Word 中去判断一下是否有偏向锁指向当前线程的ID，无需再进入 Monitor 去竞争对象了。</p><p><img src="https://raw.githubusercontent.com/GeorgeChan95/blogimg/master/img/2024/10/06/20241006-144737.png" alt="64位锁标识"></p><h4 id="4-2-2-案例说明"><a href="#4-2-2-案例说明" class="headerlink" title="4.2.2 案例说明"></a>4.2.2 案例说明</h4><p>偏向锁的操作不用涉及操作系统，不涉及用户到内核转换，我们以一个account对象的“对象头”为例.</p><p><img src="https://raw.githubusercontent.com/GeorgeChan95/blogimg/master/img/2024/10/06/20241006-144929.png" alt="Account对象"></p><p>假如有一个线程执行到synchronized代码块的时候，JVM使用CAS操作把线程指针ID记录到Mark Word当中，并修改标偏向标识，表示当前线程就获得该锁。锁对象变成偏向锁（通过CAS修改对象头里的锁标志位），字面意思是“偏向于第一个获得它的线程”的锁。<strong>执行完同步代码块后，线程并不会主动释放偏向锁。</strong></p><p><img src="https://raw.githubusercontent.com/GeorgeChan95/blogimg/master/img/2024/10/06/20241006-145047.png" alt="对象头"></p><p>这时线程获得了锁，可以执行同步代码块。当该线程第二次到达同步代码块时会判断此时持有锁的线程是否还是自己（持有锁的线程ID也在对象头里），JVM通过account对象的Mark Word判断：当前线程ID还在，说明还持有着这个对象的锁，就可以继续进入临界区工作。由于之前没有释放锁，这里也就不需要重新加锁。 如果自始至终使用锁的线程只有一个，很明显偏向锁几乎没有额外开销，性能极高。</p><p>结论：JVM不用和操作系统协商设置Mutex(争取内核)，它只需要记录下线程ID就表示自己获得了当前锁，不用操作系统介入。<br>上述就是偏向锁：<strong>在没有其他线程竞争的时候，一直偏向偏心当前线程，当前线程可以一直执行。</strong></p><h3 id="4-3-偏向锁JVM命令"><a href="#4-3-偏向锁JVM命令" class="headerlink" title="4.3 偏向锁JVM命令"></a>4.3 偏向锁JVM命令</h3><p><code>java -XX:+PrintFlagsInitial |grep BiasedLock*</code></p><p><img src="https://raw.githubusercontent.com/GeorgeChan95/blogimg/master/img/2024/10/06/20241006-145555.png" alt="偏向锁命令"></p><p><strong>参数说明</strong></p><p><img src="https://raw.githubusercontent.com/GeorgeChan95/blogimg/master/img/2024/10/06/20241006-145638.png" alt="image-20241006145637339"></p><p>实际上偏向锁在JDK1.6之后是默认开启的，但是启动时间有延迟，所以需要添加参数 <code>-XX:BiasedLockingStartupDelay=0</code>，让其在程序启动时立刻启动。</p><ul><li><p>开启偏向锁</p><p><code>-XX:+UseBiasedLocking -XX:BiasedLockingStartupDelay=0</code></p></li><li><p>关闭偏向锁：关闭之后程序默认会直接进入 &#x3D;&gt; 轻量级锁状态。</p><p><code>-XX:-UseBiasedLocking</code></p></li></ul><h3 id="4-4-代码验证"><a href="#4-4-代码验证" class="headerlink" title="4.4 代码验证"></a>4.4 代码验证</h3><pre><code class="highlight java"><span class="comment">/**</span><span class="comment"> * <span class="doctag">@author</span> George Chan</span><span class="comment"> * <span class="doctag">@date</span> 2024/10/6 14:58</span><span class="comment"> * &lt;p&gt;</span><span class="comment"> *     验证Jdk1.8 默认开启偏向锁</span><span class="comment"> *     设置 VM option : -XX:BiasedLockingStartupDelay=0</span><span class="comment"> * &lt;/p&gt;</span><span class="comment"> */</span><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">BiasedLockDemo</span> &#123;    <span class="keyword">private</span> <span class="keyword">static</span> <span class="type">Object</span> <span class="variable">objectLock</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Object</span>();    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;        <span class="keyword">new</span> <span class="title class_">Thread</span>(() -&gt; &#123;            <span class="keyword">synchronized</span> (objectLock) &#123;                System.out.println(ClassLayout.parseInstance(objectLock).toPrintable());            &#125;        &#125;).start();    &#125;&#125;</code></pre><p>打印如下:</p><p><img src="https://raw.githubusercontent.com/GeorgeChan95/blogimg/master/img/2024/10/06/20241006-150251.png" alt="默认开启偏向锁"></p><p>注意: 偏向锁默认程序启动4秒后开启,如果不设置启动参数: <code>-XX:BiasedLockingStartupDelay=0</code>, 则程序启动打印显示为 轻量级锁.</p><h3 id="4-5-偏向锁的撤销"><a href="#4-5-偏向锁的撤销" class="headerlink" title="4.5 偏向锁的撤销"></a>4.5 偏向锁的撤销</h3><p>当有另外线程逐步来竞争锁的时候，就不能再使用偏向锁了，要升级为轻量级锁.</p><p><strong>竞争线程尝试CAS更新对象头失败，会等待到全局安全点（此时不会执行任何代码）撤销偏向锁。</strong></p><p><strong>偏向锁的撤销</strong></p><p>偏向锁使用一种等到竞争出现才释放锁的机制，只有当其他线程竞争锁时，持有偏向锁的原来线程才会被撤销。<br>撤销需要等待全局安全点(该时间点上没有字节码正在执行)，同时检查持有偏向锁的线程是否还在执行： </p><ul><li>第一个线程正在执行synchronized方法(处于同步块)，它还没有执行完，其它线程来抢夺，该偏向锁会被取消掉并出现锁升级。<br>此时轻量级锁由原持有偏向锁的线程持有，继续执行其同步代码，而正在竞争的线程会进入自旋等待获得该轻量级锁。</li><li>第一个线程执行完成synchronized方法(退出同步块)，则将对象头设置成无锁状态并撤销偏向锁，重新偏向 。</li></ul><p><img src="https://raw.githubusercontent.com/GeorgeChan95/blogimg/master/img/2024/10/06/20241006-151632.png" alt="撤销偏向锁的过程"></p><h3 id="4-6-总体步骤流程图示"><a href="#4-6-总体步骤流程图示" class="headerlink" title="4.6 总体步骤流程图示"></a>4.6 总体步骤流程图示</h3><p><strong>图示1</strong></p><p><a href="https://www.processon.com/view/61cb1799f346fb2161a3ecfc">https://www.processon.com/view/61cb1799f346fb2161a3ecfc</a></p><p><img src="https://raw.githubusercontent.com/GeorgeChan95/blogimg/master/img/2024/10/06/20241006-152712.png" alt="锁的升级流程图"></p><p><strong>图示2</strong></p><p><img src="https://raw.githubusercontent.com/GeorgeChan95/blogimg/master/img/2024/10/06/20241006-153339.png" alt="image-20241006153337711"></p><h2 id="5-轻锁"><a href="#5-轻锁" class="headerlink" title="5. 轻锁"></a>5. 轻锁</h2><h3 id="5-1-主要作用"><a href="#5-1-主要作用" class="headerlink" title="5.1 主要作用"></a>5.1 主要作用</h3><p>有线程来参与锁的竞争，但是获取锁的冲突时间极短.</p><p>本质就是自旋锁.</p><p><strong>锁标识位: 00</strong></p><h3 id="5-2-轻量级锁的获取"><a href="#5-2-轻量级锁的获取" class="headerlink" title="5.2 轻量级锁的获取"></a>5.2 轻量级锁的获取</h3><p>轻量级锁是为了在线程近乎交替执行同步块时提高性能。</p><p><strong>主要目的</strong>： 在没有多线程竞争的前提下，通过CAS减少重量级锁使用操作系统互斥量产生的性能消耗，即:先自旋再阻塞。</p><p><strong>升级时机：</strong> 当关闭偏向锁功能或多线程竞争偏向锁会导致偏向锁升级为轻量级锁</p><p>假如线程A已经拿到锁，这时线程B又来抢该对象的锁，由于该对象的锁已经被线程A拿到，当前该锁已是偏向锁了。而线程B在争抢时发现对象头Mark Word中的线程ID不是线程B自己的线程ID(而是线程A)，那线程B就会进行CAS操作希望能获得锁。</p><p>此时线程B操作中有两种情况：</p><ul><li><p>如果锁获取成功，直接替换Mark Word中的线程ID为B自己的ID(A → B)，重新偏向于其他线程(即将偏向锁交给其他线程，相当于当前线程”被”释放了锁)，该锁会保持偏向锁状态，A线程Over，B线程上位；</p><p><img src="https://raw.githubusercontent.com/GeorgeChan95/blogimg/master/img/2024/10/06/20241006-162752.png" alt="偏向锁"></p></li><li><p>如果锁获取失败，则偏向锁升级为轻量级锁，此时轻量级锁由原持有偏向锁的线程持有，继续执行其同步代码，而正在竞争的线程B会进入自旋等待获得该轻量级锁。</p><p><img src="https://raw.githubusercontent.com/GeorgeChan95/blogimg/master/img/2024/10/06/20241006-162745.png" alt="轻量级锁"></p></li></ul><h3 id="5-3-代码验证"><a href="#5-3-代码验证" class="headerlink" title="5.3 代码验证"></a>5.3 代码验证</h3><p>程序启动参数设置: <code>-XX:-UseBiasedLocking</code> , 关闭偏向锁, 则默认为轻量级锁.</p><pre><code class="highlight java"><span class="comment">/**</span><span class="comment"> * <span class="doctag">@author</span> George Chan</span><span class="comment"> * <span class="doctag">@date</span> 2024/10/6 14:58</span><span class="comment"> * &lt;p&gt;</span><span class="comment"> *     验证轻量级锁:</span><span class="comment"> *     设置VM option : -XX:-UseBiasedLocking</span><span class="comment"> * &lt;/p&gt;</span><span class="comment"> */</span><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">BiasedLockDemo</span> &#123;    <span class="keyword">private</span> <span class="keyword">static</span> <span class="type">Object</span> <span class="variable">objectLock</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Object</span>();    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;        <span class="keyword">new</span> <span class="title class_">Thread</span>(() -&gt; &#123;            <span class="keyword">synchronized</span> (objectLock) &#123;                System.out.println(ClassLayout.parseInstance(objectLock).toPrintable());            &#125;        &#125;).start();    &#125;&#125;</code></pre><p>打印如下:</p><p><img src="https://raw.githubusercontent.com/GeorgeChan95/blogimg/master/img/2024/10/06/20241006-163122.png" alt="轻量级锁的标识位"></p><p><strong>000 表示 轻量级锁</strong></p><h3 id="5-4-图示"><a href="#5-4-图示" class="headerlink" title="5.4 图示"></a>5.4 图示</h3><p>见 4.6 </p><h3 id="5-5-自旋达到一定次数和程度"><a href="#5-5-自旋达到一定次数和程度" class="headerlink" title="5.5 自旋达到一定次数和程度"></a>5.5 自旋达到一定次数和程度</h3><h4 id="5-5-1-java6之前"><a href="#5-5-1-java6之前" class="headerlink" title="5.5.1 java6之前"></a>5.5.1 java6之前</h4><ul><li><p>默认启用，默认情况下自旋的次数是 10 次</p><p><code>-XX:PreBlockSpin=10</code> 来修改</p></li><li><p>或者自旋线程数超过cpu核数一半</p></li></ul><h4 id="5-5-2-Java6之后"><a href="#5-5-2-Java6之后" class="headerlink" title="5.5.2 Java6之后"></a>5.5.2 Java6之后</h4><p>采用自适应调整自旋次数. 自适应意味着自旋的次数不是固定不变的,而是根据： </p><ul><li>同一个锁上一次自旋的时间。</li><li>拥有锁线程的状态来决定。</li></ul><h3 id="5-6-轻量锁与偏向锁的区别和不同"><a href="#5-6-轻量锁与偏向锁的区别和不同" class="headerlink" title="5.6 轻量锁与偏向锁的区别和不同"></a>5.6 轻量锁与偏向锁的区别和不同</h3><ul><li>争夺轻量级锁失败时，自旋尝试抢占锁</li><li>轻量级锁每次退出同步块都需要释放锁，而偏向锁是在竞争发生时才释放锁</li></ul><h2 id="6-重锁"><a href="#6-重锁" class="headerlink" title="6. 重锁"></a>6. 重锁</h2><p>重锁发生在有大量的线程参与锁的竞争，冲突性很高的场景中.</p><h4 id="6-1-锁标志位"><a href="#6-1-锁标志位" class="headerlink" title="6.1 锁标志位"></a>6.1 锁标志位</h4><p><img src="https://raw.githubusercontent.com/GeorgeChan95/blogimg/master/img/2024/10/06/20241006-165212.png" alt="重锁"></p><h3 id="6-2-代码验证"><a href="#6-2-代码验证" class="headerlink" title="6.2 代码验证"></a>6.2 代码验证</h3><pre><code class="highlight java"><span class="comment">/**</span><span class="comment"> * <span class="doctag">@author</span> George Chan</span><span class="comment"> * <span class="doctag">@date</span> 2024/10/6 14:58</span><span class="comment"> * &lt;p&gt;</span><span class="comment"> *     关闭偏向锁:</span><span class="comment"> *     设置VM option : -XX:-UseBiasedLocking</span><span class="comment"> * &lt;/p&gt;</span><span class="comment"> */</span><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">BiasedLockDemo</span> &#123;    <span class="keyword">private</span> <span class="keyword">static</span> <span class="type">Object</span> <span class="variable">objectLock</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Object</span>();    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;        <span class="keyword">new</span> <span class="title class_">Thread</span>(() -&gt; &#123;            <span class="keyword">synchronized</span> (objectLock) &#123;                System.out.println(ClassLayout.parseInstance(objectLock).toPrintable());            &#125;        &#125;).start();        <span class="keyword">new</span> <span class="title class_">Thread</span>(() -&gt; &#123;            <span class="keyword">synchronized</span> (objectLock) &#123;                System.out.println(ClassLayout.parseInstance(objectLock).toPrintable());            &#125;        &#125;).start();        <span class="keyword">new</span> <span class="title class_">Thread</span>(() -&gt; &#123;            <span class="keyword">synchronized</span> (objectLock) &#123;                System.out.println(ClassLayout.parseInstance(objectLock).toPrintable());            &#125;        &#125;).start();    &#125;&#125;</code></pre><p>打印如下:</p><p><img src="https://raw.githubusercontent.com/GeorgeChan95/blogimg/master/img/2024/10/06/20241006-165452.png" alt="重锁的锁标志位"></p><h1 id="三、各种锁的总结"><a href="#三、各种锁的总结" class="headerlink" title="三、各种锁的总结"></a>三、各种锁的总结</h1><p>各种锁优缺点、synchronized锁升级和实现原理</p><p><img src="https://raw.githubusercontent.com/GeorgeChan95/blogimg/master/img/2024/10/06/20241006-165615.png" alt="锁的优缺点对比"></p><p>synchronized锁升级过程总结：就是先自旋，不行再阻塞。</p><p>实际上是把之前的悲观锁(重量级锁)变成在一定条件下使用偏向锁以及使用轻量级(自旋锁CAS)的形式</p><p>synchronized在修饰方法和代码块在字节码上实现方式有很大差异，但是内部实现还是基于对象头的MarkWord来实现的。</p><p>JDK1.6之前synchronized使用的是重量级锁，JDK1.6之后进行了优化，拥有了<strong>无锁-&gt;偏向锁-&gt;轻量级锁-&gt;重量级锁</strong>的升级过程，而不是无论什么情况都使用重量级锁。</p><ul><li>偏向锁:适用于单线程适用的情况，在不存在锁竞争的时候进入同步方法&#x2F;代码块则使用偏向锁。</li><li>轻量级锁：适用于竞争较不激烈的情况(这和乐观锁的使用范围类似)， 存在竞争时升级为轻量级锁，轻量级锁采用的是自旋锁，如果同步方法&#x2F;代码块执行时间很短的话，采用轻量级锁虽然会占用cpu资源但是相对比使用重量级锁还是更高效。</li><li>重量级锁：适用于竞争激烈的情况，如果同步方法&#x2F;代码块执行时间很长，那么使用轻量级锁自旋带来的性能消耗就比使用重量级锁更严重，这时候就需要升级为重量级锁。</li></ul><h1 id="四、JIT编译器对锁的优化"><a href="#四、JIT编译器对锁的优化" class="headerlink" title="四、JIT编译器对锁的优化"></a>四、JIT编译器对锁的优化</h1><p>JIT (Just In Time Compiler)，一般翻译为即时编译器. 在代码编译阶段会根据代码的实际运行情况 , 使用 锁消除, 锁粗话 的方式,对同步方法或或同步代码块进行优化处理.</p><h2 id="1-锁消除"><a href="#1-锁消除" class="headerlink" title="1. 锁消除"></a>1. 锁消除</h2><p>从JIT角度看相当于无视它，synchronized (o)不存在了,这个锁对象并没有被共用扩散到其它线程使用，极端的说就是根本没有加这个锁对象的底层机器码，消除了锁的使用</p><pre><code class="highlight java"><span class="comment">/**</span><span class="comment"> * 锁消除</span><span class="comment"> * 从JIT角度看相当于无视它，synchronized (o)不存在了,这个锁对象并没有被共用扩散到其它线程使用，</span><span class="comment"> * 极端的说就是根本没有加这个锁对象的底层机器码，消除了锁的使用</span><span class="comment"> */</span><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">LockClearUPDemo</span> &#123;    <span class="keyword">static</span> <span class="type">Object</span> <span class="variable">objectLock</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Object</span>();<span class="comment">//正常的,有且仅有同一把锁</span>        <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">m1</span><span class="params">()</span> &#123;        <span class="type">Object</span> <span class="variable">objectLock</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Object</span>();<span class="comment">//锁消除</span>        <span class="keyword">synchronized</span> (objectLock) &#123;            System.out.println(<span class="string">&quot;----hello lock&quot;</span>);        &#125;    &#125;    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;        <span class="type">LockClearUPDemo</span> <span class="variable">demo</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">LockClearUPDemo</span>();        demo.m1();    &#125;&#125;</code></pre><p>由于锁对象 objectLock  定义在 方法 m1 内部,对于每一次方法调用,都会重新创建一把新的锁,各线程拿到的锁都不是同一把锁,这是没有意义的锁, JIT 编译器在编译过程中对锁进行了消除.</p><h2 id="2-锁粗化"><a href="#2-锁粗化" class="headerlink" title="2. 锁粗化"></a>2. 锁粗化</h2><p>假如方法中首尾相接，前后相邻的都是同一个锁对象，那JIT编译器就会把这几个synchronized块合并成一个大块，加粗加大范围，一次申请锁使用即可，避免次次的申请和释放锁，提升了性能.</p><pre><code class="highlight java"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">LockBigDemo</span> &#123;    <span class="keyword">static</span> <span class="type">Object</span> <span class="variable">objectLock</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Object</span>();    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;        <span class="keyword">new</span> <span class="title class_">Thread</span>(() -&gt; &#123;            <span class="keyword">synchronized</span> (objectLock) &#123;                System.out.println(<span class="string">&quot;11111&quot;</span>);            &#125;            <span class="keyword">synchronized</span> (objectLock) &#123;                System.out.println(<span class="string">&quot;22222&quot;</span>);            &#125;            <span class="keyword">synchronized</span> (objectLock) &#123;                System.out.println(<span class="string">&quot;33333&quot;</span>);            &#125;        &#125;, <span class="string">&quot;a&quot;</span>).start();        <span class="keyword">new</span> <span class="title class_">Thread</span>(() -&gt; &#123;            <span class="keyword">synchronized</span> (objectLock) &#123;                System.out.println(<span class="string">&quot;44444&quot;</span>);            &#125;            <span class="keyword">synchronized</span> (objectLock) &#123;                System.out.println(<span class="string">&quot;55555&quot;</span>);            &#125;            <span class="keyword">synchronized</span> (objectLock) &#123;                System.out.println(<span class="string">&quot;66666&quot;</span>);            &#125;        &#125;, <span class="string">&quot;b&quot;</span>).start();    &#125;&#125;<span class="comment">// 上述代码经过JIT锁粗话后变为:</span><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">LockBigDemo</span> &#123;    <span class="keyword">static</span> <span class="type">Object</span> <span class="variable">objectLock</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Object</span>();    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;        <span class="keyword">new</span> <span class="title class_">Thread</span>(() -&gt; &#123;            <span class="keyword">synchronized</span> (objectLock) &#123;                System.out.println(<span class="string">&quot;11111&quot;</span>);                System.out.println(<span class="string">&quot;22222&quot;</span>);                System.out.println(<span class="string">&quot;33333&quot;</span>);            &#125;        &#125;, <span class="string">&quot;a&quot;</span>).start();        <span class="keyword">new</span> <span class="title class_">Thread</span>(() -&gt; &#123;            <span class="keyword">synchronized</span> (objectLock) &#123;                System.out.println(<span class="string">&quot;44444&quot;</span>);                System.out.println(<span class="string">&quot;55555&quot;</span>);                System.out.println(<span class="string">&quot;66666&quot;</span>);            &#125;        &#125;, <span class="string">&quot;b&quot;</span>).start();    &#125;&#125;</code></pre>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;一、Synchronized的性能变化&quot;&gt;&lt;a href=&quot;#一、Synchronized的性能变化&quot; class=&quot;headerlink&quot; title=&quot;一、Synchronized的性能变化&quot;&gt;&lt;/a&gt;一、Synchronized的性能变化&lt;/h1&gt;&lt;h2 i</summary>
      
    
    
    
    <category term="JUC" scheme="https://georgechan95.github.io/categories/JUC/"/>
    
    
    <category term="juc" scheme="https://georgechan95.github.io/tags/juc/"/>
    
    <category term="java" scheme="https://georgechan95.github.io/tags/java/"/>
    
  </entry>
  
  <entry>
    <title>10-JUC进阶-Java对象内存布局和对象头</title>
    <link href="https://georgechan95.github.io/blog/4502cffa.html"/>
    <id>https://georgechan95.github.io/blog/4502cffa.html</id>
    <published>2024-10-04T01:54:40.000Z</published>
    <updated>2024-10-08T04:46:24.744Z</updated>
    
    <content type="html"><![CDATA[<h1 id="一、对象在堆内存中布局"><a href="#一、对象在堆内存中布局" class="headerlink" title="一、对象在堆内存中布局"></a>一、对象在堆内存中布局</h1><h2 id="1-官方定义"><a href="#1-官方定义" class="headerlink" title="1. 官方定义"></a>1. 官方定义</h2><p>在HotSpot虚拟机里,对象在堆内存中的存储布局可以划分为三个部分: 对象头(Header), 实例数据(Instance Data), 对齐填充(Padding).</p><p><img src="https://raw.githubusercontent.com/GeorgeChan95/blogimg/master/img/2024/10/04/20241004-104806.png" alt="对象内存存储布局"></p><h2 id="2-对象在堆内存中的存储布局"><a href="#2-对象在堆内存中的存储布局" class="headerlink" title="2. 对象在堆内存中的存储布局"></a>2. 对象在堆内存中的存储布局</h2><h3 id="2-1-对象头"><a href="#2-1-对象头" class="headerlink" title="2.1 对象头"></a>2.1 对象头</h3><h4 id="2-1-1-对象标记Mark-Word"><a href="#2-1-1-对象标记Mark-Word" class="headerlink" title="2.1.1 对象标记Mark Word"></a>2.1.1 对象标记Mark Word</h4><p><strong>Mark Word保存什么?</strong></p><p>默认存储对象的HashCode、分代年龄和锁标志位等信息。<br>这些信息都是与对象自身定义无关的数据，所以MarkWord被设计成一个非固定的数据结构以便在极小的空间内存存储尽量多的数据。<br>它会根据对象的状态复用自己的存储空间，也就是说在运行期间MarkWord里存储的数据会随着锁标志位的变化而变化。</p><p><img src="https://raw.githubusercontent.com/GeorgeChan95/blogimg/master/img/2024/10/04/20241004-105323.png" alt="对象内部结构图"></p><p><img src="https://raw.githubusercontent.com/GeorgeChan95/blogimg/master/img/2024/10/04/20241004-105333.png" alt="mark word"></p><p>在64位系统中，Mark Word占了8个字节，类型指针占了8个字节，一共是16个字节</p><p><img src="https://raw.githubusercontent.com/GeorgeChan95/blogimg/master/img/2024/10/04/20241004-110133.png" alt="Mark Word 的存储结构"></p><h4 id="2-1-2-类元信息-又叫类型指针"><a href="#2-1-2-类元信息-又叫类型指针" class="headerlink" title="2.1.2 类元信息(又叫类型指针)"></a>2.1.2 类元信息(又叫类型指针)</h4><p>类型指针指向方法区中类的元数据.</p><p>对象指向它的类元数据的指针，虚拟机通过这个指针来确定这个对象是哪个类的实例。</p><p><img src="https://raw.githubusercontent.com/GeorgeChan95/blogimg/master/img/2024/10/04/20241004-110248.png" alt="类型指针"></p><h4 id="2-1-3-对象头多大"><a href="#2-1-3-对象头多大" class="headerlink" title="2.1.3 对象头多大"></a>2.1.3 对象头多大</h4><p>在64位系统中，Mark Word占了8个字节，类型指针占了8个字节，一共是16个字节。</p><p>(在实际运行的过程中,JVM会默认开启压缩指针,压缩后对象头没有16个子节这么大.)</p><h3 id="2-2-实例数据"><a href="#2-2-实例数据" class="headerlink" title="2.2 实例数据"></a>2.2 实例数据</h3><p>存放类的属性(Field)数据信息，包括父类的属性信息，<br>如果是<strong>数组</strong>的实例部分还包括<strong>数组的长度</strong>，这部分内存按4字节对齐。</p><h3 id="2-3-对齐填充"><a href="#2-3-对齐填充" class="headerlink" title="2.3 对齐填充"></a>2.3 对齐填充</h3><p>虚拟机要求对象起始地址必须是8字节的整数倍。填充数据不是必须存在的，仅仅是为了字节对齐, 这部分内存按8字节补充对齐。</p><h2 id="3-官网理论"><a href="#3-官网理论" class="headerlink" title="3. 官网理论"></a>3. 官网理论</h2><ul><li><p>Hotspot术语表官网</p><p><a href="http://openjdk.java.net/groups/hotspot/docs/HotSpotGlossary.html">http://openjdk.java.net/groups/hotspot/docs/HotSpotGlossary.html</a></p><p><img src="https://raw.githubusercontent.com/GeorgeChan95/blogimg/master/img/2024/10/04/20241004-111833.png" alt="Hotspot术语表官网"></p></li><li><p>底层源码理论证明</p><p><a href="http://hg.openjdk.java.net/jdk8u/jdk8u/hotspot/file/89fb452b3688/src/share/vm/oops/oop.hpp">http://hg.openjdk.java.net/jdk8u/jdk8u/hotspot/file/89fb452b3688/src/share/vm/oops/oop.hpp</a></p><p><img src="https://raw.githubusercontent.com/GeorgeChan95/blogimg/master/img/2024/10/04/20241004-111932.png" alt="hotspot源码"></p></li></ul><p><code>_mark</code>字段是 mark word，<code>_metadata</code> 是类指针 klass pointer，<br>对象头（object header）即是由这两个字段组成，这些术语可以参考Hotspot术语表，</p><p><img src="https://raw.githubusercontent.com/GeorgeChan95/blogimg/master/img/2024/10/04/20241004-112042.png" alt="说明"></p><h1 id="二、再说对象头的MarkWord"><a href="#二、再说对象头的MarkWord" class="headerlink" title="二、再说对象头的MarkWord"></a>二、再说对象头的MarkWord</h1><h2 id="1-32位虚拟机-了解"><a href="#1-32位虚拟机-了解" class="headerlink" title="1. 32位虚拟机(了解)"></a>1. 32位虚拟机(了解)</h2><p><img src="https://raw.githubusercontent.com/GeorgeChan95/blogimg/master/img/2024/10/04/20241004-112158.png" alt="32位虚拟机"></p><h2 id="2-64位虚拟机-重要"><a href="#2-64位虚拟机-重要" class="headerlink" title="2. 64位虚拟机(重要)"></a>2. 64位虚拟机(重要)</h2><p><img src="https://raw.githubusercontent.com/GeorgeChan95/blogimg/master/img/2024/10/04/20241004-112508.png" alt="64位虚拟机"></p><p><img src="https://raw.githubusercontent.com/GeorgeChan95/blogimg/master/img/2024/10/04/20241004-112836.png" alt="对象内部结构图"></p><p><img src="https://raw.githubusercontent.com/GeorgeChan95/blogimg/master/img/2024/10/04/20241004-112923.png" alt="HotSpot的实现"></p><p>对象布局、GC回收和后面的锁升级就是对象标记MarkWord里面标志位的变化</p><h1 id="三、分析Object-obj-new-Object"><a href="#三、分析Object-obj-new-Object" class="headerlink" title="三、分析Object obj &#x3D; new Object()"></a>三、分析Object obj &#x3D; new Object()</h1><h2 id="1-JOL证明"><a href="#1-JOL证明" class="headerlink" title="1. JOL证明"></a>1. JOL证明</h2><h3 id="1-1-JOL官网"><a href="#1-1-JOL官网" class="headerlink" title="1.1 JOL官网"></a>1.1 JOL官网</h3><p><a href="http://openjdk.java.net/projects/code-tools/jol/">http://openjdk.java.net/projects/code-tools/jol/</a></p><p><strong>pom</strong></p><pre><code class="highlight xml"><span class="comment">&lt;!--</span><span class="comment">官网：http://openjdk.java.net/projects/code-tools/jol/</span><span class="comment">定位：分析对象在JVM的大小和分布</span><span class="comment">--&gt;</span><span class="tag">&lt;<span class="name">dependency</span>&gt;</span>    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.openjdk.jol<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span>    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>jol-core<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span>    <span class="tag">&lt;<span class="name">version</span>&gt;</span>0.9<span class="tag">&lt;/<span class="name">version</span>&gt;</span><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></code></pre><h3 id="1-2-测试案例"><a href="#1-2-测试案例" class="headerlink" title="1.2 测试案例"></a>1.2 测试案例</h3><pre><code class="highlight java"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">MyObject</span> &#123;    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span>&#123;        <span class="comment">//VM的细节详细情况</span>        System.out.println(VM.current().details());        <span class="comment">//所有的对象分配的字节都是8的整数倍。</span>        System.out.println(VM.current().objectAlignment());    &#125;&#125;</code></pre><p>打印如下:</p><pre><code class="highlight shell"><span class="meta prompt_"># </span><span class="language-bash">WARNING: Unable to get Instrumentation. Dynamic Attach failed. You may add this JAR as -javaagent manually, or supply -Djdk.attach.allowAttachSelf</span><span class="meta prompt_"># </span><span class="language-bash">Running 64-bit HotSpot VM.</span><span class="meta prompt_"># </span><span class="language-bash">Using compressed oop with 3-bit <span class="built_in">shift</span>.</span><span class="meta prompt_"># </span><span class="language-bash">Using compressed klass with 0x0000000800000000 base address and 0-bit <span class="built_in">shift</span>.</span><span class="meta prompt_"># </span><span class="language-bash">Objects are 8 bytes aligned.</span><span class="meta prompt_"># </span><span class="language-bash">Field sizes by <span class="built_in">type</span>: 4, 1, 1, 2, 2, 4, 4, 8, 8 [bytes]</span><span class="meta prompt_"># </span><span class="language-bash">Array element sizes: 4, 1, 1, 2, 2, 4, 4, 8, 8 [bytes]</span>8</code></pre><p>从日志可以看出,对象是 8 子节对齐的.</p><h2 id="2-案例2"><a href="#2-案例2" class="headerlink" title="2. 案例2"></a>2. 案例2</h2><pre><code class="highlight java"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">MyObject</span> &#123;    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span>&#123;        <span class="type">Object</span> <span class="variable">o</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Object</span>();        System.out.println( ClassLayout.parseInstance(o).toPrintable());    &#125;&#125;</code></pre><p>打印如下:</p><p><img src="https://raw.githubusercontent.com/GeorgeChan95/blogimg/master/img/2024/10/04/20241004-115343.png" alt="jdk8"></p><p><img src="https://raw.githubusercontent.com/GeorgeChan95/blogimg/master/img/2024/10/04/20241004-114547.png" alt="image-20241004114546567"></p><table><thead><tr><th>属性</th><th>描述</th></tr></thead><tbody><tr><td>OFFSET</td><td>偏移量，也就是到这个字段位置所占用的byte数</td></tr><tr><td>SIZE</td><td>后面类型的字节大小</td></tr><tr><td>TYPE</td><td>是Class中定义的类型</td></tr><tr><td>DESCRIPTION</td><td>DESCRIPTION是类型的描述</td></tr><tr><td>VALUE</td><td>VALUE是TYPE在内存中的值</td></tr></tbody></table><h2 id="3-分代年龄"><a href="#3-分代年龄" class="headerlink" title="3. 分代年龄"></a>3. 分代年龄</h2><p>GC年龄采用4位bit存储，最大为15，例如 <code>-XX:MaxTenuringThreshold=15</code> 参数默认值就是15</p><p>如果设置参数超过15则会报错:</p><pre><code class="highlight shell">Error: Could not create the Java Virtual Machine.Error: A fatal exception has occurred. Program will exit.MaxTenuringThreshold of 16 is invalid; must be between 0 and 15</code></pre><h2 id="4-参数说明"><a href="#4-参数说明" class="headerlink" title="4. 参数说明"></a>4. 参数说明</h2><ul><li><p>查看默认的参数</p><p><code>java -XX:+PrintCommandLineFlags -version</code></p><pre><code class="highlight plaintext">-XX:InitialHeapSize=532618688 -XX:MaxHeapSize=8521899008 -XX:+PrintCommandLineFlags -XX:+UseCompressedClassPointers -XX:+UseCompressedOops -XX:-UseLargePagesIndividualAllocation -XX:+UseParallelGCjava version &quot;1.8.0_241&quot;Java(TM) SE Runtime Environment (build 1.8.0_241-b07)Java HotSpot(TM) 64-Bit Server VM (build 25.241-b07, mixed mode)</code></pre><p><code>-XX:+UseCompressedClassPointers</code> 表示默认开启了压缩指针, 因此对象头打印结果,类型指针不是理论上的8子节,变成了4子节.</p><p><img src="https://raw.githubusercontent.com/GeorgeChan95/blogimg/master/img/2024/10/04/20241004-115751.png" alt="自动对齐"></p></li><li><p>手动关闭压缩</p><p><code>-XX:-UseCompressedClassPointers</code></p><p><img src="https://raw.githubusercontent.com/GeorgeChan95/blogimg/master/img/2024/10/04/20241004-120017.png" alt="关闭了自动压缩"></p></li></ul>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;一、对象在堆内存中布局&quot;&gt;&lt;a href=&quot;#一、对象在堆内存中布局&quot; class=&quot;headerlink&quot; title=&quot;一、对象在堆内存中布局&quot;&gt;&lt;/a&gt;一、对象在堆内存中布局&lt;/h1&gt;&lt;h2 id=&quot;1-官方定义&quot;&gt;&lt;a href=&quot;#1-官方定义&quot; cla</summary>
      
    
    
    
    <category term="JUC" scheme="https://georgechan95.github.io/categories/JUC/"/>
    
    
    <category term="juc" scheme="https://georgechan95.github.io/tags/juc/"/>
    
    <category term="java" scheme="https://georgechan95.github.io/tags/java/"/>
    
  </entry>
  
  <entry>
    <title>09-JUC进阶-ThreadLocal</title>
    <link href="https://georgechan95.github.io/blog/4de6a39b.html"/>
    <id>https://georgechan95.github.io/blog/4de6a39b.html</id>
    <published>2024-10-01T12:39:10.000Z</published>
    <updated>2024-10-08T04:46:24.744Z</updated>
    
    <content type="html"><![CDATA[<h1 id="一、ThreadLocal简介"><a href="#一、ThreadLocal简介" class="headerlink" title="一、ThreadLocal简介"></a>一、ThreadLocal简介</h1><p>官方文档: <a href="https://www.runoob.com/manual/jdk11api/java.base/java/lang/ThreadLocal.html">https://www.runoob.com/manual/jdk11api/java.base/java/lang/ThreadLocal.html</a></p><h2 id="1-简介"><a href="#1-简介" class="headerlink" title="1. 简介"></a>1. 简介</h2><p>ThreadLocal提供线程局部变量。这些变量与正常的变量不同，因为每一个线程在访问ThreadLocal实例的时候（通过其get或set方法）都有自己的、独立初始化的变量副本。ThreadLocal实例通常是类中的私有静态字段，使用它的目的是希望将状态（例如，用户ID或事务ID）与线程关联起来。</p><h2 id="2-作用"><a href="#2-作用" class="headerlink" title="2. 作用"></a>2. 作用</h2><p>实现每一个线程都有自己专属的本地变量副本(不和其它线程共享)，主要解决了让每个线程绑定自己的值，通过使用get()和set()方法，获取默认值或将其值更改为当前线程所存的副本的值从而避免了线程安全问题。</p><p><img src="https://raw.githubusercontent.com/GeorgeChan95/blogimg/master/img/2024/10/02/20241002-062934.png" alt="ThreadLocal"></p><h2 id="3-常用API介绍"><a href="#3-常用API介绍" class="headerlink" title="3. 常用API介绍"></a>3. 常用API介绍</h2><ul><li><p><code>get()</code></p><p>返回当前线程的此线程局部变量副本中的值。 如果变量没有当前线程的值，则首先将其初始化为调用initialValue()方法返回的值。</p></li><li><p><code>initialValue()</code></p><p>返回此线程局部变量的当前线程的“初始值”。 当第一次一个线程访问get()方法,该方法将被调用的.除非线程先调用的set(T)方法，在这种情况下initialValue方法将不被调用的线程。 通常，每个线程最多调用一次此方法，但如果后续调用remove()后跟get() ，则可以再次调用此方法。</p><p>这个实现只返回<code>null</code> ; 如果程序员希望线程局部变量具有除<code>null</code>之外的初始值， <code>ThreadLocal</code>必须对<code>ThreadLocal</code>进行子类化，并且重写此方法。 通常，将使用匿名内部类。</p></li><li><p><code>remove()</code></p><p>删除此线程局部变量的当前线程值。 如果当前线程的此线程局部变量随后是read ，则其值将通过调用其initialValue()方法重新初始化。 这可能导致在当前线程中多次调用initialValue方法。</p></li><li><p>set(T value)</p><p>将此线程局部变量的当前线程副本设置为指定值。 大多数子类都不需要重写此方法，仅依靠initialValue()方法来设置线程局部的值。</p></li><li><p>withInitial(Supplier&lt;? extends S&gt; supplier)</p><p>创建一个线程局部变量。 通过调用<code>get</code>上的<code>Supplier</code>方法确定变量的初始值。</p></li></ul><p><img src="https://raw.githubusercontent.com/GeorgeChan95/blogimg/master/img/2024/10/02/20241002-064534.png" alt="常用API"></p><h2 id="4-入门案例"><a href="#4-入门案例" class="headerlink" title="4. 入门案例"></a>4. 入门案例</h2><h3 id="4-1-案例代码"><a href="#4-1-案例代码" class="headerlink" title="4.1 案例代码"></a>4.1 案例代码</h3><p>公司各个销售人员, 按照出单数各自统计, 使用ThreadLocal实现.</p><pre><code class="highlight java"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ThreadLocalTest</span> &#123;    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> InterruptedException &#123;        <span class="type">MyHouse</span> <span class="variable">house</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">MyHouse</span>();        <span class="keyword">new</span> <span class="title class_">Thread</span>(() -&gt; &#123;            <span class="keyword">try</span> &#123;                <span class="type">int</span> <span class="variable">num</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Random</span>().nextInt(<span class="number">10</span>);                <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; num; i++) &#123;                    house.saleHouse();                &#125;                System.out.println(Thread.currentThread().getName() + <span class="string">&quot;卖出了:&quot;</span> + house.threadLocal.get() + <span class="string">&quot;套房子&quot;</span>);            &#125; <span class="keyword">finally</span> &#123;                house.threadLocal.remove();            &#125;        &#125;, <span class="string">&quot;销售1&quot;</span>).start();        <span class="keyword">new</span> <span class="title class_">Thread</span>(() -&gt; &#123;            <span class="keyword">try</span> &#123;                <span class="type">int</span> <span class="variable">num</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Random</span>().nextInt(<span class="number">10</span>);                <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; num; i++) &#123;                    house.saleHouse();                &#125;                System.out.println(Thread.currentThread().getName() + <span class="string">&quot;卖出了:&quot;</span> + house.threadLocal.get() + <span class="string">&quot;套房子&quot;</span>);            &#125; <span class="keyword">finally</span> &#123;                house.threadLocal.remove();            &#125;        &#125;, <span class="string">&quot;销售2&quot;</span>).start();        <span class="keyword">new</span> <span class="title class_">Thread</span>(() -&gt; &#123;            <span class="keyword">try</span> &#123;                <span class="type">int</span> <span class="variable">num</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Random</span>().nextInt(<span class="number">10</span>);                <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; num; i++) &#123;                    house.saleHouse();                &#125;                System.out.println(Thread.currentThread().getName() + <span class="string">&quot;卖出了:&quot;</span> + house.threadLocal.get() + <span class="string">&quot;套房子&quot;</span>);            &#125; <span class="keyword">finally</span> &#123;                house.threadLocal.remove();            &#125;        &#125;, <span class="string">&quot;销售3&quot;</span>).start();        TimeUnit.SECONDS.sleep(<span class="number">1</span>);    &#125;&#125;<span class="keyword">class</span> <span class="title class_">MyHouse</span> &#123;    <span class="comment">// 初始化ThreadLocal,设置初始值为:0</span>    ThreadLocal&lt;Integer&gt; threadLocal = ThreadLocal.withInitial(() -&gt; <span class="number">0</span>);    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">saleHouse</span><span class="params">()</span> &#123;        <span class="type">Integer</span> <span class="variable">value</span> <span class="operator">=</span> threadLocal.get();        value++;        threadLocal.set(value);    &#125;&#125;</code></pre><p>运行结果:</p><pre><code class="highlight shell">销售1卖出了:8套房子销售2卖出了:3套房子销售3卖出了:1套房子</code></pre><h3 id="4-2-总结"><a href="#4-2-总结" class="headerlink" title="4.2 总结"></a>4.2 总结</h3><ul><li>因为每个 Thread 内有自己的实例副本且该副本只由当前线程自己使用</li><li>既然其它 Thread 不可访问，那就不存在多线程间共享的问题。</li><li>统一设置初始值，但是每个线程对这个值的修改都是各自线程互相独立的</li></ul><p>多线程如何才能不争抢</p><ol><li>加入synchronized或者Lock控制资源的访问顺序</li><li>使用ThreadLocal</li></ol><h1 id="二、ThreadLocal实际使用"><a href="#二、ThreadLocal实际使用" class="headerlink" title="二、ThreadLocal实际使用"></a>二、ThreadLocal实际使用</h1><h2 id="1-阿里ThreadLocal规范"><a href="#1-阿里ThreadLocal规范" class="headerlink" title="1. 阿里ThreadLocal规范"></a>1. 阿里ThreadLocal规范</h2><p><img src="https://raw.githubusercontent.com/GeorgeChan95/blogimg/master/img/2024/10/02/20241002-072742.png" alt="阿里ThreadLocal规范"></p><h2 id="2-非线程安全的SimpleDateFormat"><a href="#2-非线程安全的SimpleDateFormat" class="headerlink" title="2. 非线程安全的SimpleDateFormat"></a>2. 非线程安全的SimpleDateFormat</h2><h3 id="2-1-官网文档"><a href="#2-1-官网文档" class="headerlink" title="2.1 官网文档"></a>2.1 官网文档</h3><p><img src="https://raw.githubusercontent.com/GeorgeChan95/blogimg/master/img/2024/10/02/20241002-072823.png" alt="image-20241002072822670"></p><p>上述翻译：SimpleDateFormat中的日期格式不是同步的。推荐（建议）为每个线程创建独立的格式实例。如果多个线程同时访问一个格式，则它必须保持外部同步。</p><p>写时间工具类，一般写成静态的成员变量，但此种写法在多线程下是不安全的！</p><h3 id="2-2-错误示例代码"><a href="#2-2-错误示例代码" class="headerlink" title="2.2 错误示例代码"></a>2.2 错误示例代码</h3><pre><code class="highlight java"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">DateUtils</span> &#123;    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">SimpleDateFormat</span> <span class="variable">sdf</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">SimpleDateFormat</span>(<span class="string">&quot;yyyy-MM-dd HH:mm:ss&quot;</span>);    <span class="comment">/**</span><span class="comment">     * 模拟并发环境下使用SimpleDateFormat的parse方法将字符串转换成Date对象</span><span class="comment">     *</span><span class="comment">     * <span class="doctag">@param</span> stringDate</span><span class="comment">     * <span class="doctag">@return</span></span><span class="comment">     * <span class="doctag">@throws</span> Exception</span><span class="comment">     */</span>    <span class="keyword">public</span> <span class="keyword">static</span> Date <span class="title function_">parseDate</span><span class="params">(String stringDate)</span> <span class="keyword">throws</span> Exception &#123;        <span class="keyword">return</span> sdf.parse(stringDate);    &#125;    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception &#123;        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">1</span>; i &lt;= <span class="number">30</span>; i++) &#123;            <span class="keyword">new</span> <span class="title class_">Thread</span>(() -&gt; &#123;                <span class="keyword">try</span> &#123;                    System.out.println(DateUtils.parseDate(<span class="string">&quot;2020-11-11 11:11:11&quot;</span>));                &#125; <span class="keyword">catch</span> (Exception e) &#123;                    e.printStackTrace();                &#125;            &#125;, String.valueOf(i)).start();        &#125;    &#125;&#125;</code></pre><p>报错如下:</p><pre><code class="highlight shell">java.lang.NumberFormatException: For input string: &quot;..11111111EE22&quot;at java.base/java.lang.NumberFormatException.forInputString(NumberFormatException.java:65)at java.base/java.lang.Long.parseLong(Long.java:678)at java.base/java.lang.Long.parseLong(Long.java:817)at java.base/java.text.DigitList.getLong(DigitList.java:195)at java.base/java.text.DecimalFormat.parse(DecimalFormat.java:2121)at java.base/java.text.SimpleDateFormat.subParse(SimpleDateFormat.java:1933)at java.base/java.text.SimpleDateFormat.parse(SimpleDateFormat.java:1541)at java.base/java.text.DateFormat.parse(DateFormat.java:393)at com.atguigu.juc.tl.DateUtils.parseDate(DateUtils.java:22)at com.atguigu.juc.tl.DateUtils.lambda$main$0(DateUtils.java:29)at java.base/java.lang.Thread.run(Thread.java:834)java.lang.NumberFormatException: multiple pointsat java.base/jdk.internal.math.FloatingDecimal.readJavaFormatString(FloatingDecimal.java:1890)at java.base/jdk.internal.math.FloatingDecimal.parseDouble(FloatingDecimal.java:110)at java.base/java.lang.Double.parseDouble(Double.java:543)at java.base/java.text.DigitList.getDouble(DigitList.java:169)at java.base/java.text.DecimalFormat.parse(DecimalFormat.java:2126)at java.base/java.text.SimpleDateFormat.subParse(SimpleDateFormat.java:2240)at java.base/java.text.SimpleDateFormat.parse(SimpleDateFormat.java:1541)at java.base/java.text.DateFormat.parse(DateFormat.java:393)at com.atguigu.juc.tl.DateUtils.parseDate(DateUtils.java:22)at com.atguigu.juc.tl.DateUtils.lambda$main$0(DateUtils.java:29)at java.base/java.lang.Thread.run(Thread.java:834)java.lang.NumberFormatException: For input string: &quot;.2022020E&quot;at java.base/java.lang.NumberFormatException.forInputString(NumberFormatException.java:65)at java.base/java.lang.Long.parseLong(Long.java:678)at java.base/java.lang.Long.parseLong(Long.java:817)at java.base/java.text.DigitList.getLong(DigitList.java:195)at java.base/java.text.DecimalFormat.parse(DecimalFormat.java:2121)at java.base/java.text.SimpleDateFormat.subParse(SimpleDateFormat.java:1933)at java.base/java.text.SimpleDateFormat.parse(SimpleDateFormat.java:1541)at java.base/java.text.DateFormat.parse(DateFormat.java:393)at com.atguigu.juc.tl.DateUtils.parseDate(DateUtils.java:22)at com.atguigu.juc.tl.DateUtils.lambda$main$0(DateUtils.java:29)at java.base/java.lang.Thread.run(Thread.java:834)java.lang.NumberFormatException: For input string: &quot;.2220E0.202E4&quot;at java.base/jdk.internal.math.FloatingDecimal.readJavaFormatString(FloatingDecimal.java:2054)at java.base/jdk.internal.math.FloatingDecimal.parseDouble(FloatingDecimal.java:110)at java.base/java.lang.Double.parseDouble(Double.java:543)at java.base/java.text.DigitList.getDouble(DigitList.java:169)at java.base/java.text.DecimalFormat.parse(DecimalFormat.java:2126)at java.base/java.text.SimpleDateFormat.subParse(SimpleDateFormat.java:1933)at java.base/java.text.SimpleDateFormat.parse(SimpleDateFormat.java:1541)at java.base/java.text.DateFormat.parse(DateFormat.java:393)at com.atguigu.juc.tl.DateUtils.parseDate(DateUtils.java:22)at com.atguigu.juc.tl.DateUtils.lambda$main$0(DateUtils.java:29)at java.base/java.lang.Thread.run(Thread.java:834)java.lang.NumberFormatException: multiple pointsat java.base/jdk.internal.math.FloatingDecimal.readJavaFormatString(FloatingDecimal.java:1890)at java.base/jdk.internal.math.FloatingDecimal.parseDouble(FloatingDecimal.java:110)at java.base/java.lang.Double.parseDouble(Double.java:543)at java.base/java.text.DigitList.getDouble(DigitList.java:169)at java.base/java.text.DecimalFormat.parse(DecimalFormat.java:2126)at java.base/java.text.SimpleDateFormat.subParse(SimpleDateFormat.java:2240)at java.base/java.text.SimpleDateFormat.parse(SimpleDateFormat.java:1541)at java.base/java.text.DateFormat.parse(DateFormat.java:393)at com.atguigu.juc.tl.DateUtils.parseDate(DateUtils.java:22)at com.atguigu.juc.tl.DateUtils.lambda$main$0(DateUtils.java:29)</code></pre><h3 id="2-3-源码分析结论"><a href="#2-3-源码分析结论" class="headerlink" title="2.3 源码分析结论"></a>2.3 源码分析结论</h3><p>SimpleDateFormat类内部有一个Calendar对象引用,它用来储存和这个SimpleDateFormat相关的日期信息,例如 <code>sdf.parse(dateStr)</code> , <code>sdf.format(date)</code> 诸如此类的方法参数传入的日期相关String,Date等等, 都是交由Calendar引用来储存的.这样就会导致一个问题如果你的SimpleDateFormat是个static的, 那么多个thread 之间就会共享这个SimpleDateFormat, 同时也是共享这个Calendar引用。</p><ul><li>java.text.SimpleDateFormat#parse</li></ul><p><img src="https://raw.githubusercontent.com/GeorgeChan95/blogimg/master/img/2024/10/02/20241002-074144.png" alt="java.text.SimpleDateFormat#parse "></p><ul><li><p>java.text.CalendarBuilder#establish</p><p><img src="https://raw.githubusercontent.com/GeorgeChan95/blogimg/master/img/2024/10/02/20241002-074238.png" alt="image-20241002074237666"></p></li></ul><h2 id="3-解决方式1"><a href="#3-解决方式1" class="headerlink" title="3. 解决方式1"></a>3. 解决方式1</h2><p>将SimpleDateFormat定义成局部变量。</p><p>缺点：每调用一次方法就会创建一个SimpleDateFormat对象，方法结束又要作为垃圾回收。</p><pre><code class="highlight java"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">DateUtils</span> &#123;    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception &#123;        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">1</span>; i &lt;= <span class="number">30</span>; i++) &#123;            <span class="keyword">new</span> <span class="title class_">Thread</span>(() -&gt; &#123;                <span class="keyword">final</span> <span class="type">SimpleDateFormat</span> <span class="variable">sdf</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">SimpleDateFormat</span>(<span class="string">&quot;yyyy-MM-dd HH:mm:ss&quot;</span>);                <span class="keyword">try</span> &#123;                    System.out.println(sdf.parse(<span class="string">&quot;2020-11-11 11:11:11&quot;</span>));                &#125; <span class="keyword">catch</span> (Exception e) &#123;                    e.printStackTrace();                &#125;            &#125;, String.valueOf(i)).start();        &#125;    &#125;&#125;</code></pre><h2 id="4-解决方式2"><a href="#4-解决方式2" class="headerlink" title="4. 解决方式2"></a>4. 解决方式2</h2><p>使用ThreadLocal</p><pre><code class="highlight java"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">DateUtils</span> &#123;    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> ThreadLocal&lt;SimpleDateFormat&gt; threadLocal = ThreadLocal.withInitial(() -&gt; <span class="keyword">new</span> <span class="title class_">SimpleDateFormat</span>(<span class="string">&quot;yyyy-mm-dd HH:mm:ss&quot;</span>));    <span class="comment">/**</span><span class="comment">     * 模拟并发环境下使用SimpleDateFormat的parse方法将字符串转换成Date对象</span><span class="comment">     *</span><span class="comment">     * <span class="doctag">@param</span> stringDate</span><span class="comment">     * <span class="doctag">@return</span></span><span class="comment">     * <span class="doctag">@throws</span> Exception</span><span class="comment">     */</span>    <span class="keyword">public</span> <span class="keyword">static</span> Date <span class="title function_">parseDate</span><span class="params">(String stringDate)</span> <span class="keyword">throws</span> Exception &#123;        <span class="type">SimpleDateFormat</span> <span class="variable">sdf</span> <span class="operator">=</span> threadLocal.get();<span class="comment">//        System.out.println(&quot;执行线程:&quot; + Thread.currentThread().getName());</span>        <span class="keyword">return</span> sdf.parse(stringDate);    &#125;    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception &#123;        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">1</span>; i &lt;= <span class="number">30</span>; i++) &#123;            <span class="keyword">new</span> <span class="title class_">Thread</span>(() -&gt; &#123;                <span class="keyword">try</span> &#123;                    System.out.println(parseDate(<span class="string">&quot;2020-11-11 11:11:11&quot;</span>));                &#125; <span class="keyword">catch</span> (Exception e) &#123;                    e.printStackTrace();                &#125;            &#125;, String.valueOf(i)).start();        &#125;    &#125;&#125;</code></pre><p><strong>其它方案</strong></p><ul><li>加锁</li><li>第3方时间库</li></ul><h1 id="三、ThreadLocal源码分析"><a href="#三、ThreadLocal源码分析" class="headerlink" title="三、ThreadLocal源码分析"></a>三、ThreadLocal源码分析</h1><h2 id="1-Thread，ThreadLocal，ThreadLocalMap-关系"><a href="#1-Thread，ThreadLocal，ThreadLocalMap-关系" class="headerlink" title="1. Thread，ThreadLocal，ThreadLocalMap 关系"></a>1. Thread，ThreadLocal，ThreadLocalMap 关系</h2><p>根据官方API，Thread是程序中执行的线程；ThreadLocal类提供线程局部变量。</p><h3 id="1-1-Thread和ThreadLocal"><a href="#1-1-Thread和ThreadLocal" class="headerlink" title="1.1 Thread和ThreadLocal"></a>1.1 Thread和ThreadLocal</h3><p>先打开<code>Thread.java</code>类，发现每个Thread类里面有一个<code>ThreadLocal</code>类</p><p><img src="https://raw.githubusercontent.com/GeorgeChan95/blogimg/master/img/2024/10/02/20241002-102349.png" alt="ThreadLocal"></p><h3 id="1-2-ThreadLocal和ThreadLocalMap"><a href="#1-2-ThreadLocal和ThreadLocalMap" class="headerlink" title="1.2 ThreadLocal和ThreadLocalMap"></a>1.2 ThreadLocal和ThreadLocalMap</h3><p>而 <code>ThreadLocalMap</code> 是 <code>ThreadLocal</code> 的一个静态内部类</p><p><img src="https://raw.githubusercontent.com/GeorgeChan95/blogimg/master/img/2024/10/02/20241002-102550.png" alt="ThreadLocalMap"></p><h3 id="1-3-三者总概括"><a href="#1-3-三者总概括" class="headerlink" title="1.3 三者总概括"></a>1.3 三者总概括</h3><p><code>threadLocalMap </code>实际上就是一个以 <code>threadLocal</code> 实例为<strong>key</strong>，任意对象为<strong>value</strong>的 <code>Entry对象</code> 。<br>当我们为threadLocal变量赋值，实际上就是以当前threadLocal实例为key，值为value的Entry往这个threadLocalMap中存放</p><p><img src="https://raw.githubusercontent.com/GeorgeChan95/blogimg/master/img/2024/10/02/20241002-102628.png" alt="Thread，ThreadLocal，ThreadLocalMap"></p><p><img src="https://raw.githubusercontent.com/GeorgeChan95/blogimg/master/img/2024/10/02/20241002-103626.png" alt="ThreadLocal set"></p><h2 id="2-总结"><a href="#2-总结" class="headerlink" title="2. 总结"></a>2. 总结</h2><p>近似的可以理解为:<br><code>ThreadLocalMap</code> 从字面上就可以看出这是一个保存ThreadLocal对象的map(其实是以ThreadLocal为Key)，不过是经过了两层包装的ThreadLocal 对象：</p><p><img src="https://raw.githubusercontent.com/GeorgeChan95/blogimg/master/img/2024/10/02/20241002-104134.png" alt="ThreadLocalMap"></p><p>JVM内部维护了一个线程版的 <code>Map&lt;Thread,T&gt;</code> (通过 <code>ThreadLocal</code> 对象的 <code>set</code> 方法，结果把 <code>ThreadLocal</code> 对象自己当做key，放进了<code>ThreadLoalMap</code>中),每个线程要用到这个T的时候，用当前的线程去Map里面获取，通过这样让每个线程都拥有了自己独立的变量，<br>人手一份，竞争条件被彻底消除，在并发模式下是绝对安全的变量。</p><h1 id="四、ThreadLocal内存泄露问题"><a href="#四、ThreadLocal内存泄露问题" class="headerlink" title="四、ThreadLocal内存泄露问题"></a>四、ThreadLocal内存泄露问题</h1><h2 id="1-阿里代码规范"><a href="#1-阿里代码规范" class="headerlink" title="1. 阿里代码规范"></a>1. 阿里代码规范</h2><p><img src="https://raw.githubusercontent.com/GeorgeChan95/blogimg/master/img/2024/10/02/20241002-104235.png" alt="阿里代码规范"></p><h2 id="2-什么是内存泄漏"><a href="#2-什么是内存泄漏" class="headerlink" title="2. 什么是内存泄漏"></a>2. 什么是内存泄漏</h2><p>内存泄露为程序在申请内存后，无法释放已申请的内存空间，一次内存泄露危害可以忽略，但内存泄露堆积后果很严重，无论多少内存,迟早会被占光.</p><p>广义并通俗的说，就是：不再会被使用的对象或者变量占用的内存不能被回收，就是内存泄露。</p><h2 id="3-ThreadLocal的内存泄露分析"><a href="#3-ThreadLocal的内存泄露分析" class="headerlink" title="3. ThreadLocal的内存泄露分析"></a>3. ThreadLocal的内存泄露分析</h2><h3 id="3-1-实现原理"><a href="#3-1-实现原理" class="headerlink" title="3.1 实现原理"></a>3.1 实现原理</h3><pre><code class="highlight java"><span class="keyword">static</span> <span class="keyword">class</span> <span class="title class_">ThreadLocalMap</span> &#123;    <span class="keyword">static</span> <span class="keyword">class</span> <span class="title class_">Entry</span> <span class="keyword">extends</span> <span class="title class_">WeakReference</span>&lt;ThreadLocal&lt;?&gt;&gt; &#123;        <span class="comment">/** The value associated with this ThreadLocal. */</span>        Object value;        Entry(ThreadLocal&lt;?&gt; k, Object v) &#123;            <span class="built_in">super</span>(k);            value = v;        &#125;    &#125;    ...   &#125;</code></pre><p>ThreadLocal的实现原理，每一个Thread维护一个ThreadLocalMap，key为使用弱引用的ThreadLocal实例，value为线程变量的副本。这些对象之间的引用关系如下,</p><p><img src="https://raw.githubusercontent.com/GeorgeChan95/blogimg/master/img/2024/10/02/20241002-105317.png" alt="img"></p><blockquote><p>实心箭头表示强引用，空心箭头表示弱引用</p></blockquote><h3 id="3-2-ThreadLocal-内存泄漏的原因"><a href="#3-2-ThreadLocal-内存泄漏的原因" class="headerlink" title="3.2 ThreadLocal 内存泄漏的原因"></a>3.2 ThreadLocal 内存泄漏的原因</h3><p>从上图中可以看出，ThreadLocalMap 使用 ThreadLocal 的弱引用作为key，如果一个ThreadLocal不存在外部强引用时，Key(ThreadLocal)势必会被GC回收，这样就会导致 ThreadLocalMap 中key为 null， 而value还存在着强引用，只有thead线程退出以后,value的强引用链条才会断掉。</p><p>但如果当前线程再迟迟不结束的话，这些key为null的Entry的value就会一直存在一条强引用链：</p><blockquote><p>Thread Ref -&gt; Thread -&gt; ThreaLocalMap -&gt; Entry -&gt; value</p></blockquote><p>永远无法回收，造成内存泄漏。</p><h3 id="3-3-那为什么使用弱引用而不是强引用？"><a href="#3-3-那为什么使用弱引用而不是强引用？" class="headerlink" title="3.3 那为什么使用弱引用而不是强引用？"></a>3.3 那为什么使用弱引用而不是强引用？</h3><h4 id="3-3-1-key-使用强引用"><a href="#3-3-1-key-使用强引用" class="headerlink" title="3.3.1 key 使用强引用"></a>3.3.1 key 使用强引用</h4><p>当 <code>ThreadLocalMap</code> 的key为强引用回收 ThreadLocal 时，因为 ThreadLocalMap 还持有ThreadLocal的强引用，如果没有手动删除，ThreadLocal不会被回收，导致Entry内存泄漏。</p><h4 id="3-3-2-key使用弱引用"><a href="#3-3-2-key使用弱引用" class="headerlink" title="3.3.2 key使用弱引用"></a>3.3.2 key使用弱引用</h4><p>由于ThreadLocal对象是弱引用，如果外部没有强引用指向它，它就会被GC回收，导致Entry的Key为空(null)，如果这时Value外部也没有强引用指向它，那么Value就永远也访问不到了，按理也应该被GC回收，但是由于Entry对象还在强引用Value，导致Value无法被回收，这时「内存泄漏」就发生了，Value成了一个永远也无法被访问，但是又无法被回收的对象。</p><p>Entry对象属于ThreadLocalMap，ThreadLocalMap又属于Thread，如果线程本身的生命周期很短，短时间内就会被销毁，那么「内存泄漏」立刻就会得到解决，只要线程被销毁，Value也会随之被回收。</p><p>问题是，线程本身是非常珍贵的计算机资源，很少会去频繁的创建和销毁，一般都是通过线程池来使用，这就将线程的生命周期大大拉长，「内存泄漏」的影响也会越来越大。</p><p><strong>内存泄漏的代码示例</strong></p><p>线程池大小是3,但启动了6个线程,导致后面的线程直接复用了前面线程的 ThreadLocal数据.</p><pre><code class="highlight plaintext">public class ThreadLocalPoolTest &#123;    public static void main(String[] args) throws InterruptedException &#123;        MyCar car = new MyCar();        ExecutorService executorService = Executors.newFixedThreadPool(3);        for (int i = 0; i &lt; 6; i++) &#123;            executorService.submit(() -&gt; &#123;                int num = new Random().nextInt(10);                for (int j = 0; j &lt; num; j++) &#123;                    car.saleCar();                &#125;                System.out.println(Thread.currentThread().getName() + &quot;卖出了:&quot; + car.threadLocal.get() + &quot;辆车&quot;);            &#125;);        &#125;        executorService.shutdown();    &#125;&#125;class MyCar &#123;    // 初始化ThreadLocal,设置初始值为:0    ThreadLocal&lt;Integer&gt; threadLocal = ThreadLocal.withInitial(() -&gt; 0);    public void saleCar() &#123;        Integer value = threadLocal.get();        value++;        threadLocal.set(value);        System.out.println(Thread.currentThread().getName() + &quot;卖了:&quot; + threadLocal.get() + &quot;辆车&quot;);    &#125;&#125;</code></pre><p>运行结果:</p><pre><code class="highlight shell">pool-1-thread-1卖了:1辆车pool-1-thread-1卖了:2辆车pool-1-thread-2卖了:1辆车pool-1-thread-2卖了:2辆车pool-1-thread-3卖了:1辆车pool-1-thread-3卖了:2辆车pool-1-thread-2卖了:3辆车pool-1-thread-2卖了:4辆车pool-1-thread-1卖了:3辆车pool-1-thread-1卖了:4辆车pool-1-thread-2卖了:5辆车pool-1-thread-2卖出了:5辆车pool-1-thread-3卖了:3辆车pool-1-thread-1卖了:5辆车pool-1-thread-3卖了:4辆车pool-1-thread-2卖出了:5辆车pool-1-thread-1卖了:6辆车pool-1-thread-1卖了:7辆车pool-1-thread-1卖了:8辆车pool-1-thread-1卖了:9辆车pool-1-thread-1卖出了:9辆车pool-1-thread-3卖了:5辆车pool-1-thread-2卖了:6辆车pool-1-thread-2卖出了:6辆车pool-1-thread-1卖了:10辆车pool-1-thread-3卖出了:5辆车pool-1-thread-1卖出了:10辆车</code></pre><p><strong>方案: 手动回收自定义的 ThreadLocal变量</strong></p><pre><code class="highlight plaintext">public class ThreadLocalPoolTest &#123;    public static void main(String[] args) throws InterruptedException &#123;        MyCar car = new MyCar();        ExecutorService executorService = Executors.newFixedThreadPool(3);        for (int i = 0; i &lt; 6; i++) &#123;            executorService.submit(() -&gt; &#123;                try &#123;                    int num = new Random().nextInt(10);                    for (int j = 0; j &lt; num; j++) &#123;                        car.saleCar();                    &#125;                    System.out.println(Thread.currentThread().getName() + &quot;卖出了:&quot; + car.threadLocal.get() + &quot;辆车&quot;);                &#125; finally &#123;                    car.threadLocal.remove();                &#125;            &#125;);        &#125;        executorService.shutdown();    &#125;&#125;class MyCar &#123;    // 初始化ThreadLocal,设置初始值为:0    ThreadLocal&lt;Integer&gt; threadLocal = ThreadLocal.withInitial(() -&gt; 0);    public void saleCar() &#123;        Integer value = threadLocal.get();        value++;        threadLocal.set(value);        System.out.println(Thread.currentThread().getName() + &quot;卖了:&quot; + threadLocal.get() + &quot;辆车&quot;);    &#125;&#125;</code></pre><h2 id="4-强引用、软引用、弱引用、虚引用"><a href="#4-强引用、软引用、弱引用、虚引用" class="headerlink" title="4. 强引用、软引用、弱引用、虚引用"></a>4. 强引用、软引用、弱引用、虚引用</h2><h3 id="4-1-整体架构"><a href="#4-1-整体架构" class="headerlink" title="4.1 整体架构"></a>4.1 整体架构</h3><p><img src="https://raw.githubusercontent.com/GeorgeChan95/blogimg/master/img/2024/10/02/20241002-142730.png" alt="引用架构"></p><p>Java 技术允许使用 <code>finalize()</code> 方法在垃圾收集器将对象从内存中清除出去之前做必要的清理工作。</p><p><img src="https://raw.githubusercontent.com/GeorgeChan95/blogimg/master/img/2024/10/02/20241002-142848.png" alt="finalize()"></p><p>finalize() 方法定义在Object类中,每个类都可以重写此方法(不建议重写)</p><pre><code class="highlight java"><span class="keyword">class</span> <span class="title class_">MyObject</span> &#123;    <span class="comment">//一般这个方法工作中不用</span>    <span class="meta">@Override</span>    <span class="keyword">protected</span> <span class="keyword">void</span> <span class="title function_">finalize</span><span class="params">()</span> <span class="keyword">throws</span> Throwable &#123;        System.out.println(<span class="string">&quot;------------- gc ,finalize() invoked&quot;</span>);    &#125;&#125;</code></pre><h3 id="4-2-强引用-默认支持模式"><a href="#4-2-强引用-默认支持模式" class="headerlink" title="4.2 强引用(默认支持模式)"></a>4.2 强引用(默认支持模式)</h3><p>当内存不足，JVM开始垃圾回收，对于强引用的对象，就算是出现了OOM也不会对该对象进行回收.</p><p>强引用是我们最常见的普通对象引用，只要还有强引用指向一个对象，就能表明对象还“活着”，垃圾收集器不会碰这种对象。在 Java 中最常见的就是强引用，把一个对象赋给一个引用变量，这个引用变量就是一个强引用。当一个对象被强引用变量引用时，它处于可达状态，它是不可能被垃圾回收机制回收的，即使该对象以后永远都不会被用到JVM也不会回收。因此强引用是造成Java内存泄漏的主要原因之一。</p><pre><code class="highlight java"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">strongReference</span><span class="params">()</span> &#123;    <span class="type">MyObject</span> <span class="variable">myObject</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">MyObject</span>();<span class="comment">//默认，强引用,死了都不放手</span>    System.out.println(<span class="string">&quot;gc before: &quot;</span> + myObject);    myObject = <span class="literal">null</span>;    System.gc();<span class="comment">//手动挡的方式开启Gc回收。</span>    <span class="keyword">try</span> &#123;        TimeUnit.SECONDS.sleep(<span class="number">1</span>);    &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;        e.printStackTrace();    &#125;    System.out.println(<span class="string">&quot;gc after: &quot;</span> + myObject);&#125;</code></pre><h3 id="4-3-软引用"><a href="#4-3-软引用" class="headerlink" title="4.3 软引用"></a>4.3 软引用</h3><p>软引用是一种相对强引用弱化了一些的引用，需要用 <code>java.lang.ref.SoftReference</code> 类来实现，可以让对象豁免一些垃圾收集。</p><p>对于只有软引用的对象来说，</p><ul><li>当系统<strong>内存充足</strong>时它<strong>不会</strong>被回收，</li><li>当系统<strong>内存不足</strong>时它<strong>会</strong>被回收。</li></ul><h4 id="4-3-1-测试代码"><a href="#4-3-1-测试代码" class="headerlink" title="4.3.1 测试代码"></a>4.3.1 测试代码</h4><p>软引用通常用在对内存敏感的程序中，比如高速缓存就有用到软引用，内存够用的时候就保留，不够用就回收！</p><pre><code class="highlight java"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ReferenceTest</span> &#123;    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;        <span class="comment">//当我们内存不够用的时候，soft会被回收的情况，设置我们的内存大小：-Xms10m -Xmx10m</span>        SoftReference&lt;MyObject&gt; softReference = <span class="keyword">new</span> <span class="title class_">SoftReference</span>&lt;&gt;(<span class="keyword">new</span> <span class="title class_">MyObject</span>());        System.gc();        <span class="keyword">try</span> &#123;            TimeUnit.SECONDS.sleep(<span class="number">1</span>);        &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;            e.printStackTrace();        &#125;        System.out.println(<span class="string">&quot;-----gc after内存够用: &quot;</span> + softReference.get());        <span class="keyword">try</span> &#123;            <span class="type">byte</span>[] bytes = <span class="keyword">new</span> <span class="title class_">byte</span>[<span class="number">9</span> * <span class="number">1024</span> * <span class="number">1024</span>];        &#125; <span class="keyword">catch</span> (Exception e) &#123;            e.printStackTrace();        &#125; <span class="keyword">finally</span> &#123;            System.out.println(<span class="string">&quot;-----gc after内存不够: &quot;</span> + softReference.get());        &#125;    &#125;&#125;<span class="keyword">class</span> <span class="title class_">MyObject2</span> &#123;    <span class="comment">//一般这个方法工作中不用，此处为了讲解gc，给学生们演示</span>    <span class="meta">@Override</span>    <span class="keyword">protected</span> <span class="keyword">void</span> <span class="title function_">finalize</span><span class="params">()</span> <span class="keyword">throws</span> Throwable &#123;        System.out.println(<span class="string">&quot;------------- gc ,finalize() invoked&quot;</span>);    &#125;&#125;</code></pre><p>打印结果:</p><pre><code class="highlight shell">-----gc after内存够用: com.atguigu.juc.tl.MyObject@64616ca2-----gc after内存不够: null------------- gc ,finalize() invokedException in thread &quot;main&quot; java.lang.OutOfMemoryError: Java heap spaceat com.atguigu.juc.tl.ReferenceTest.main(ReferenceTest.java:25)</code></pre><h4 id="4-3-2-适用场景"><a href="#4-3-2-适用场景" class="headerlink" title="4.3.2 适用场景"></a>4.3.2 适用场景</h4><p>假如有一个应用需要读取大量的本地图片:</p><ul><li>如果每次读取图片都从硬盘读取则会严重影响性能,</li><li>如果一次性全部加载到内存中又可能造成内存溢出。</li></ul><p>如果每次读取图片都从硬盘读取则会严重影响性能,</p><p><strong>设计思路是</strong>：用一个HashMap来保存图片的路径和相应图片对象关联的软引用之间的映射关系，在内存不足时，JVM会自动回收这些缓存图片对象所占用的空间，从而有效地避免了OOM的问题。</p><pre><code class="highlight java">Map&lt;String, SoftReference&lt;Bitmap&gt;&gt; imageCache = <span class="keyword">new</span> <span class="title class_">HashMap</span>&lt;String, SoftReference&lt;Bitmap&gt;&gt;();</code></pre><h3 id="4-4-弱引用"><a href="#4-4-弱引用" class="headerlink" title="4.4 弱引用"></a>4.4 弱引用</h3><p>弱引用需要用java.lang.ref.WeakReference类来实现，它比软引用的生存期更短，对于只有弱引用的对象来说，只要垃圾回收机制一运行，不管JVM的内存空间是否足够，都会回收该对象占用的内存。 </p><pre><code class="highlight java"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ReferenceTest</span> &#123;    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;        WeakReference&lt;MyObject&gt; weakReference = <span class="keyword">new</span> <span class="title class_">WeakReference</span>&lt;&gt;(<span class="keyword">new</span> <span class="title class_">MyObject</span>());        System.out.println(<span class="string">&quot;-----gc before内存够用: &quot;</span>+weakReference.get());        System.gc();        <span class="keyword">try</span> &#123; TimeUnit.SECONDS.sleep(<span class="number">1</span>); &#125; <span class="keyword">catch</span> (InterruptedException e) &#123; e.printStackTrace(); &#125;        System.out.println(<span class="string">&quot;-----gc after内存够用: &quot;</span>+weakReference.get());    &#125;&#125;</code></pre><p>打印结果:</p><pre><code class="highlight shell">-----gc before内存够用: com.atguigu.juc.tl.MyObject@64616ca2------------- gc ,finalize() invoked-----gc after内存够用: null</code></pre><h3 id="4-5-虚引用"><a href="#4-5-虚引用" class="headerlink" title="4.5 虚引用"></a>4.5 虚引用</h3><p>虚引用需要 <code>java.lang.ref.PhantomReference</code> 类来实现。</p><p>顾名思义，就是形同虚设，与其他几种引用都不同，虚引用并不会决定对象的生命周期。如果一个对象仅持有虚引用，那么它就和没有任何引用一样，在任何时候都可能被垃圾回收器回收，它不能单独使用也不能通过它访问对象，虚引用必须和引用队列 (<code>ReferenceQueue</code>)联合使用。</p><p>虚引用的主要作用是跟踪对象被垃圾回收的状态。 <strong>仅仅是提供了一种确保对象被 finalize以后，做某些事情的机制。</strong> <strong>PhantomReference的get方法总是返回null</strong>，因此无法访问对应的引用对象。</p><p>其意义在于：说明一个对象已经进入finalization阶段，可以被gc回收，用来实现比finalization机制更灵活的回收操作。</p><p>换句话说，设置虚引用关联的唯一目的，就是在这个对象被收集器回收的时候收到一个系统通知或者后续添加进一步的处理。</p><h4 id="4-5-1-构造方法"><a href="#4-5-1-构造方法" class="headerlink" title="4.5.1 构造方法"></a>4.5.1 构造方法</h4><p><img src="https://raw.githubusercontent.com/GeorgeChan95/blogimg/master/img/2024/10/02/20241002-145624.png" alt="构造方法"></p><h4 id="4-5-2-引用队列"><a href="#4-5-2-引用队列" class="headerlink" title="4.5.2 引用队列"></a>4.5.2 引用队列</h4><p><img src="https://raw.githubusercontent.com/GeorgeChan95/blogimg/master/img/2024/10/02/20241002-145651.png" alt="引用队列"></p><p>被回收前需要被引用队列保存下。</p><pre><code class="highlight java"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ReferenceTest</span> &#123;    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;        <span class="comment">// 设置内存: -Xms10m -Xmx10m</span>        ReferenceQueue&lt;MyObject2&gt; referenceQueue = <span class="keyword">new</span> <span class="title class_">ReferenceQueue</span>();        PhantomReference&lt;MyObject2&gt; phantomReference = <span class="keyword">new</span> <span class="title class_">PhantomReference</span>&lt;&gt;(<span class="keyword">new</span> <span class="title class_">MyObject2</span>(), referenceQueue);        <span class="comment">//System.out.println(phantomReference.get());</span>        List&lt;<span class="type">byte</span>[]&gt; list = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();        <span class="keyword">new</span> <span class="title class_">Thread</span>(() -&gt; &#123;            <span class="keyword">while</span> (<span class="literal">true</span>) &#123;                list.add(<span class="keyword">new</span> <span class="title class_">byte</span>[<span class="number">1</span> * <span class="number">1024</span> * <span class="number">1024</span>]);                <span class="keyword">try</span> &#123;                    TimeUnit.MILLISECONDS.sleep(<span class="number">600</span>);                &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;                    e.printStackTrace();                &#125;                System.out.println(phantomReference.get()); <span class="comment">// null</span>            &#125;        &#125;, <span class="string">&quot;t1&quot;</span>).start();        <span class="keyword">new</span> <span class="title class_">Thread</span>(() -&gt; &#123;            <span class="keyword">while</span> (<span class="literal">true</span>) &#123;                Reference&lt;? <span class="keyword">extends</span> <span class="title class_">MyObject2</span>&gt; reference = referenceQueue.poll();                <span class="keyword">if</span> (reference != <span class="literal">null</span>) &#123;                    System.out.println(<span class="string">&quot;***********有虚对象加入队列了&quot;</span>);                &#125;            &#125;        &#125;, <span class="string">&quot;t2&quot;</span>).start();        <span class="comment">//暂停几秒钟线程</span>        <span class="keyword">try</span> &#123;            TimeUnit.SECONDS.sleep(<span class="number">5</span>);        &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;            e.printStackTrace();        &#125;    &#125;&#125;<span class="keyword">class</span> <span class="title class_">MyObject2</span> &#123;    <span class="comment">//一般这个方法工作中不用</span>    <span class="meta">@Override</span>    <span class="keyword">protected</span> <span class="keyword">void</span> <span class="title function_">finalize</span><span class="params">()</span> <span class="keyword">throws</span> Throwable &#123;        System.out.println(<span class="string">&quot;------------- gc ,finalize() invoked&quot;</span>);    &#125;&#125;</code></pre><p>打印结果:</p><pre><code class="highlight shell">null------------- gc ,finalize() invokednull***********有虚对象加入队列了nullException in thread &quot;t1&quot; java.lang.OutOfMemoryError: Java heap spaceat com.atguigu.juc.tl.ReferenceTest.lambda$main$0(ReferenceTest.java:26)at com.atguigu.juc.tl.ReferenceTest$$Lambda$14/0x0000000100066840.run(Unknown Source)at java.base/java.lang.Thread.run(Thread.java:834)</code></pre><h2 id="5-GCRoots和四大引用总结"><a href="#5-GCRoots和四大引用总结" class="headerlink" title="5. GCRoots和四大引用总结"></a>5. GCRoots和四大引用总结</h2><p><img src="https://raw.githubusercontent.com/GeorgeChan95/blogimg/master/img/2024/10/02/20241002-150258.png" alt="GCRoots和四大引用"></p><h1 id="五、总结"><a href="#五、总结" class="headerlink" title="五、总结"></a>五、总结</h1><ul><li>ThreadLocal 并不解决线程间共享数据的问题</li><li>ThreadLocal 适用于变量在线程间隔离且在方法间共享的场景</li><li>ThreadLocal 通过隐式的在不同线程内创建独立实例副本避免了实例线程安全的问题</li><li>每个线程持有一个只属于自己的专属Map并维护了ThreadLocal对象与具体实例的映射，该Map由于只被持有它的线程访问，故不存在线程安全以及锁的问题</li><li>ThreadLocalMap的Entry对ThreadLocal的引用为弱引用，避免了ThreadLocal对象无法被回收的问题</li><li>ThreadLocal 会通过expungeStaleEntry，cleanSomeSlots,replaceStaleEntry这三个方法回收键为 null 的 Entry 对象的值（即为具体实例）以及 Entry 对象本身从而防止内存泄漏，属于安全加固的方法</li></ul>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;一、ThreadLocal简介&quot;&gt;&lt;a href=&quot;#一、ThreadLocal简介&quot; class=&quot;headerlink&quot; title=&quot;一、ThreadLocal简介&quot;&gt;&lt;/a&gt;一、ThreadLocal简介&lt;/h1&gt;&lt;p&gt;官方文档: &lt;a href=&quot;htt</summary>
      
    
    
    
    <category term="JUC" scheme="https://georgechan95.github.io/categories/JUC/"/>
    
    
    <category term="juc" scheme="https://georgechan95.github.io/tags/juc/"/>
    
    <category term="java" scheme="https://georgechan95.github.io/tags/java/"/>
    
  </entry>
  
  <entry>
    <title>08-JUC进阶-常用的原子操作类(18个)</title>
    <link href="https://georgechan95.github.io/blog/72329cf5.html"/>
    <id>https://georgechan95.github.io/blog/72329cf5.html</id>
    <published>2024-09-28T05:37:09.000Z</published>
    <updated>2024-10-08T04:46:24.743Z</updated>
    
    <content type="html"><![CDATA[<h1 id="一、常用原子操作类"><a href="#一、常用原子操作类" class="headerlink" title="一、常用原子操作类"></a>一、常用原子操作类</h1><p>JDK文档：<a href="https://www.runoob.com/manual/jdk11api/java.base/java/util/concurrent/atomic/package-summary.html">https://www.runoob.com/manual/jdk11api/java.base/java/util/concurrent/atomic/package-summary.html</a></p><h2 id="1-为什么需要原子操作类"><a href="#1-为什么需要原子操作类" class="headerlink" title="1. 为什么需要原子操作类"></a>1. 为什么需要原子操作类</h2><p>对于多线程，在此之前已经了解到了一个关键字 <code>volatile</code>， volatile 解决多线程内存不可见问题。对于一写多读，是可以解决变量同步问题，但是如果多写，同样无法解决线程安全问题。</p><p>说明:如果是 count++操作,使用如下类实现: </p><pre><code class="highlight java"><span class="type">AtomicInteger</span> <span class="variable">count</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">AtomicInteger</span>(<span class="number">0</span>);count.addAndGet(<span class="number">1</span>);</code></pre><p>如果是 JDK8，推荐使用 <code>LongAdder</code> 对象，比 <code>AtomicLong</code> 性能更好(减少乐观锁的重试次数)。</p><h2 id="2-有哪些原子操作类"><a href="#2-有哪些原子操作类" class="headerlink" title="2. 有哪些原子操作类"></a>2. 有哪些原子操作类</h2><p><img src="https://raw.githubusercontent.com/GeorgeChan95/blogimg/master/img/2024/09/28/20240928-134643.png" alt="原子操作类"></p><ol><li>AtomicBoolean</li><li>AtomicInteger</li><li>AtomicIntegerArray</li><li>AtomicIntegerFieldUpdater</li><li>AtomicLong</li><li>AtomicLongArray</li><li>AtomicLongFieldUpdater</li><li>AtomicMarkableReference</li><li>AtomicReference</li><li>AtomicReferenceArray</li><li>AtomicReferenceFieldUpdater</li><li>AtomicStampedReference</li><li>DoubleAccumulator</li><li>DoubleAdder</li><li>LongAccumulator</li><li>LongAdder</li></ol><h1 id="二、分类学习"><a href="#二、分类学习" class="headerlink" title="二、分类学习"></a>二、分类学习</h1><h2 id="1-基本类型原子类"><a href="#1-基本类型原子类" class="headerlink" title="1. 基本类型原子类"></a>1. 基本类型原子类</h2><ul><li>AtomicInteger</li><li>AtomicBoolean</li><li>AtomicLong</li></ul><h3 id="1-1-常用API简介"><a href="#1-1-常用API简介" class="headerlink" title="1.1 常用API简介"></a>1.1 常用API简介</h3><ul><li>public final int get()  &#x2F;&#x2F;获取当前的值</li><li>public final int getAndSet(int newValue) &#x2F;&#x2F; 获取当前的值，并设置新的值</li><li>public final int getAndIncrement() &#x2F;&#x2F; 获取当前的值，并自增</li><li>public final int getAndDecrement() &#x2F;&#x2F; 获取当前的值，并自减</li><li>public final int getAndAdd(int delta) &#x2F;&#x2F; 获取当前的值，并加上预期的值</li><li>boolean compareAndSet(int expect, int update) &#x2F;&#x2F; 如果输入的数值等于预期值，则以原子方式将该值设置为输入值（update）</li></ul><h3 id="1-2-测试案例"><a href="#1-2-测试案例" class="headerlink" title="1.2 测试案例"></a>1.2 测试案例</h3><h4 id="1-2-1-错误案例"><a href="#1-2-1-错误案例" class="headerlink" title="1.2.1 错误案例"></a>1.2.1 错误案例</h4><p>开启50个线程，对一个原子类变量进行操作</p><pre><code class="highlight java"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">AtomicIntegerTest</span> &#123;    <span class="keyword">private</span> <span class="keyword">static</span> <span class="type">int</span> <span class="variable">size</span> <span class="operator">=</span> <span class="number">50</span>; <span class="comment">// 50个线程</span>    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;        <span class="type">AtomicInteger</span> <span class="variable">atomicInteger</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">AtomicInteger</span>(<span class="number">0</span>);        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; size; i++) &#123;            <span class="keyword">new</span> <span class="title class_">Thread</span>(() -&gt; &#123;                <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> <span class="number">0</span>; j &lt; <span class="number">1000</span>; j++) &#123;                    atomicInteger.getAndIncrement();                &#125;            &#125;, <span class="string">&quot;t&quot;</span> + i).start();        &#125;        System.out.println(<span class="string">&quot;运行结果：&quot;</span> + atomicInteger.get());    &#125;&#125;</code></pre><p>运行结果：</p><pre><code class="highlight plaintext">运行结果：31056</code></pre><p>AtomicInteger 是一个线程安全的原子操作类，但是执行结果却跟预期的不一致，这是为什么？</p><p>原因：在打印结果的时候，50个线程并没有完全运行结束，导致最后获得的结果跟预期不一致。</p><h4 id="1-2-2-解决方式"><a href="#1-2-2-解决方式" class="headerlink" title="1.2.2 解决方式"></a>1.2.2 解决方式</h4><ul><li>方式一：在代码中添加 sleep，等待其它线程结束后再打印主线程<ul><li>此方式并不推荐，因为在实际开发中并不确定要等待多久，sleep操作影响系统的执行效率</li></ul></li><li>方式二：使用 <code>CountDownLatch</code></li></ul><pre><code class="highlight java"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">AtomicIntegerTest</span> &#123;    <span class="keyword">private</span> <span class="keyword">static</span> <span class="type">int</span> <span class="variable">size</span> <span class="operator">=</span> <span class="number">50</span>; <span class="comment">// 50个线程</span>    <span class="keyword">private</span> <span class="keyword">static</span> <span class="type">CountDownLatch</span> <span class="variable">countDownLatch</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">CountDownLatch</span>(<span class="number">50</span>);    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> InterruptedException &#123;        <span class="type">AtomicInteger</span> <span class="variable">atomicInteger</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">AtomicInteger</span>(<span class="number">0</span>);        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; size; i++) &#123;            <span class="keyword">new</span> <span class="title class_">Thread</span>(() -&gt; &#123;                <span class="keyword">try</span> &#123;                    <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> <span class="number">0</span>; j &lt; <span class="number">1000</span>; j++) &#123;                        atomicInteger.getAndIncrement();                    &#125;                &#125; <span class="keyword">finally</span> &#123;                    countDownLatch.countDown();                &#125;            &#125;, <span class="string">&quot;t&quot;</span> + i).start();        &#125;        <span class="comment">// 方式一：等待线程运行结果后，再打印</span><span class="comment">//        TimeUnit.SECONDS.sleep(2);</span>        <span class="comment">// 方式二：使用 countDownLatch</span>        countDownLatch.await();        System.out.println(<span class="string">&quot;运行结果：&quot;</span> + atomicInteger.get());    &#125;&#125;</code></pre><h2 id="2-数组类型原子类"><a href="#2-数组类型原子类" class="headerlink" title="2. 数组类型原子类"></a>2. 数组类型原子类</h2><ul><li>AtomicIntegerArray</li><li>AtomicLongArray</li><li>AtomicReferenceArray</li></ul><h3 id="2-1-使用案例"><a href="#2-1-使用案例" class="headerlink" title="2.1 使用案例"></a>2.1 使用案例</h3><pre><code class="highlight java"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">AtomicIntegerArrayDemo</span> &#123;    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;        <span class="comment">// 方式一：指定数组长度</span>        <span class="type">AtomicIntegerArray</span> <span class="variable">atomicIntegerArray</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">AtomicIntegerArray</span>(<span class="keyword">new</span> <span class="title class_">int</span>[<span class="number">5</span>]);        <span class="comment">// 方式二：指定数组长度</span>        <span class="comment">//AtomicIntegerArray atomicIntegerArray = new AtomicIntegerArray(5);</span>        <span class="comment">// 方式三：指定数组长度并初始化内容</span>        <span class="comment">//AtomicIntegerArray atomicIntegerArray = new AtomicIntegerArray(new int[]&#123;1,2,3,4,5&#125;);</span>        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; atomicIntegerArray.length(); i++) &#123;            System.out.println(atomicIntegerArray.get(i));        &#125;        System.out.println();        System.out.println();        System.out.println();        <span class="type">int</span> <span class="variable">tmpInt</span> <span class="operator">=</span> <span class="number">0</span>;        <span class="comment">// 指定下标设置内容</span>        tmpInt = atomicIntegerArray.getAndSet(<span class="number">0</span>, <span class="number">1122</span>);        System.out.println(tmpInt + <span class="string">&quot;\t&quot;</span> + atomicIntegerArray.get(<span class="number">0</span>)); <span class="comment">// 0 1122</span>        <span class="comment">// 指定下标元素自增</span>        atomicIntegerArray.getAndIncrement(<span class="number">1</span>);        atomicIntegerArray.getAndIncrement(<span class="number">1</span>);        tmpInt = atomicIntegerArray.getAndIncrement(<span class="number">1</span>);        <span class="comment">// 打印下标元素</span>        System.out.println(tmpInt + <span class="string">&quot;\t&quot;</span> + atomicIntegerArray.get(<span class="number">1</span>)); <span class="comment">// 2 3</span>    &#125;&#125;</code></pre><p>打印结果：</p><pre><code class="highlight shell">000000112223</code></pre><h2 id="3-引用类型原子类"><a href="#3-引用类型原子类" class="headerlink" title="3. 引用类型原子类"></a>3. 引用类型原子类</h2><ul><li>AtomicReference</li><li>AtomicStampedReference</li><li>AtomicMarkableReference</li></ul><h3 id="3-1-AtomicReference"><a href="#3-1-AtomicReference" class="headerlink" title="3.1 AtomicReference"></a>3.1 AtomicReference</h3><p><strong>基础使用案例</strong></p><pre><code class="highlight java"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">AtomicReferenceTest</span> &#123;    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;        <span class="type">User1</span> <span class="variable">user1</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">User1</span>(<span class="string">&quot;张三&quot;</span>, <span class="number">20</span>);        <span class="type">User1</span> <span class="variable">user2</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">User1</span>(<span class="string">&quot;george&quot;</span>, <span class="number">22</span>);        AtomicReference&lt;User1&gt; atomicUser1 = <span class="keyword">new</span> <span class="title class_">AtomicReference</span>&lt;&gt;();        atomicUser1.set(user1);        System.out.println(<span class="string">&quot;当前人员：&quot;</span> + atomicUser1.get());        <span class="comment">// 第一次比较替换，张三 换成 george， 结果成功</span>        System.out.println(atomicUser1.compareAndSet(user1, user2) + <span class="string">&quot;\t&quot;</span> + atomicUser1.get());        <span class="comment">// 第二次比较替换，张三 换成 george， 结果失败</span>        System.out.println(atomicUser1.compareAndSet(user1, user2) + <span class="string">&quot;\t&quot;</span> + atomicUser1.get());    &#125;&#125;<span class="meta">@Data</span><span class="meta">@ToString</span><span class="meta">@NoArgsConstructor</span><span class="meta">@AllArgsConstructor</span><span class="keyword">class</span> <span class="title class_">User1</span> &#123;    <span class="keyword">private</span> String name;    <span class="keyword">private</span> Integer age;&#125;</code></pre><p><strong>实现自旋锁</strong></p><pre><code class="highlight java"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">MySpinLock</span> &#123;    AtomicReference&lt;Thread&gt; atomicReference = <span class="keyword">new</span> <span class="title class_">AtomicReference</span>&lt;&gt;();    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">lock</span><span class="params">()</span> &#123;        <span class="comment">// 当没有替换成当前线程，则表示获取锁失败，线程自旋</span>        <span class="keyword">while</span> (!atomicReference.compareAndSet(<span class="literal">null</span>, Thread.currentThread())) &#123;        &#125;        System.out.println(Thread.currentThread().getName() + <span class="string">&quot;获取锁成功&quot;</span>);    &#125;    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">unlock</span><span class="params">()</span> &#123;        <span class="keyword">while</span> (atomicReference.compareAndSet(Thread.currentThread(), <span class="literal">null</span>)) &#123;            System.out.println(Thread.currentThread().getName() + <span class="string">&quot;解锁成功&quot;</span>);        &#125;    &#125;    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> InterruptedException &#123;        <span class="type">MySpinLock</span> <span class="variable">lock</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">MySpinLock</span>();        <span class="keyword">new</span> <span class="title class_">Thread</span>(() -&gt; &#123;            <span class="comment">// 获取锁</span>            lock.lock();            <span class="keyword">try</span> &#123;                <span class="comment">// 阻塞3秒</span>                TimeUnit.SECONDS.sleep(<span class="number">3</span>);            &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;                <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">RuntimeException</span>(e);            &#125;            <span class="comment">// 解锁</span>            lock.unlock();        &#125;, <span class="string">&quot;t1&quot;</span>).start();        <span class="comment">// 程序暂停1秒， 保证t1先拿到锁</span>        TimeUnit.SECONDS.sleep(<span class="number">1</span>);        <span class="keyword">new</span> <span class="title class_">Thread</span>(() -&gt; &#123;            lock.lock();            lock.unlock();        &#125;, <span class="string">&quot;t2&quot;</span>).start();    &#125;&#125;</code></pre><h3 id="3-2-AtomicStampedReference"><a href="#3-2-AtomicStampedReference" class="headerlink" title="3.2 AtomicStampedReference"></a>3.2 AtomicStampedReference</h3><p>携带版本号的引用类型原子类，可以解决ABA问题</p><p><strong>使用案例：</strong></p><pre><code class="highlight java"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ABATest</span> &#123;    <span class="comment">// 初始值：100   初始版本号：1</span>    <span class="keyword">static</span> AtomicStampedReference&lt;Integer&gt; stampedReference = <span class="keyword">new</span> <span class="title class_">AtomicStampedReference</span>&lt;&gt;(<span class="number">100</span>, <span class="number">1</span>);    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;        <span class="keyword">new</span> <span class="title class_">Thread</span>(() -&gt; &#123;            <span class="type">int</span> <span class="variable">stamp</span> <span class="operator">=</span> stampedReference.getStamp();            System.out.println(Thread.currentThread().getName() + <span class="string">&quot; 默认获取到的值：&quot;</span> + stampedReference.getReference() + <span class="string">&quot;\t默认版本号：&quot;</span> + stamp);            <span class="keyword">try</span> &#123;                TimeUnit.SECONDS.sleep(<span class="number">1</span>);            &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;                <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">RuntimeException</span>(e);            &#125;            <span class="comment">// 修改值，将版本号加1</span>            <span class="type">boolean</span> <span class="variable">flag1</span> <span class="operator">=</span> stampedReference.compareAndSet(<span class="number">100</span>, <span class="number">101</span>, stampedReference.getStamp(), stampedReference.getStamp() + <span class="number">1</span>);            System.out.println(Thread.currentThread().getName() + <span class="string">&quot;第一次修改：&quot;</span> + flag1);            <span class="comment">// 修改值，将版本号加1</span>            <span class="type">boolean</span> <span class="variable">flag2</span> <span class="operator">=</span> stampedReference.compareAndSet(<span class="number">101</span>, <span class="number">100</span>, stampedReference.getStamp(), stampedReference.getStamp() + <span class="number">1</span>);            System.out.println(Thread.currentThread().getName() + <span class="string">&quot;第二次修改：&quot;</span> + flag2);            System.out.println(<span class="string">&quot;修改后的值：&quot;</span> + stampedReference.getReference() + <span class="string">&quot;\t版本号：&quot;</span> + stampedReference.getStamp());        &#125;, <span class="string">&quot;t1&quot;</span>).start();        <span class="keyword">new</span> <span class="title class_">Thread</span>(() -&gt; &#123;            <span class="type">int</span> <span class="variable">stamp</span> <span class="operator">=</span> stampedReference.getStamp();            System.out.println(Thread.currentThread().getName() + <span class="string">&quot; 默认获取到的值：&quot;</span> + stampedReference.getReference() + <span class="string">&quot;\t默认版本号：&quot;</span> + stamp);            <span class="keyword">try</span> &#123;                TimeUnit.SECONDS.sleep(<span class="number">3</span>);            &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;                <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">RuntimeException</span>(e);            &#125;            <span class="comment">// 修改值，将版本号加1</span>            <span class="type">boolean</span> <span class="variable">flag</span> <span class="operator">=</span> stampedReference.compareAndSet(<span class="number">100</span>, <span class="number">2024</span>, stamp, stampedReference.getStamp() + <span class="number">1</span>);            System.out.println(Thread.currentThread().getName() + <span class="string">&quot;修改：&quot;</span> + flag);            System.out.println(<span class="string">&quot;修改后的值：&quot;</span> + stampedReference.getReference() + <span class="string">&quot;\t版本号：&quot;</span> + stampedReference.getStamp());        &#125;, <span class="string">&quot;t2&quot;</span>).start();    &#125;&#125;</code></pre><h3 id="3-3-AtomicMarkableReference"><a href="#3-3-AtomicMarkableReference" class="headerlink" title="3.3 AtomicMarkableReference"></a>3.3 AtomicMarkableReference</h3><p>原子更新带有标记位的引用类型对象.</p><p>解决对象是否修改过的问题，它的定义就是将状态戳简化为 true|false。</p><pre><code class="highlight java"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">AtomicMarkableReferenceDemo</span> &#123;    <span class="keyword">static</span> <span class="type">AtomicMarkableReference</span> <span class="variable">atomicMarkableReference</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">AtomicMarkableReference</span>(<span class="number">100</span>, <span class="literal">false</span>);    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;        <span class="keyword">new</span> <span class="title class_">Thread</span>(() -&gt; &#123;            <span class="type">boolean</span> <span class="variable">marked</span> <span class="operator">=</span> atomicMarkableReference.isMarked();            System.out.println(Thread.currentThread().getName() + <span class="string">&quot;\t&quot;</span> + <span class="string">&quot;---默认修改标识：&quot;</span> + marked);            <span class="keyword">try</span> &#123;                TimeUnit.SECONDS.sleep(<span class="number">1</span>);            &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;                e.printStackTrace();            &#125;            atomicMarkableReference.compareAndSet(<span class="number">100</span>, <span class="number">101</span>, marked, !marked);        &#125;, <span class="string">&quot;t1&quot;</span>).start();        <span class="keyword">new</span> <span class="title class_">Thread</span>(() -&gt; &#123;            <span class="type">boolean</span> <span class="variable">marked</span> <span class="operator">=</span> atomicMarkableReference.isMarked();            System.out.println(Thread.currentThread().getName() + <span class="string">&quot;\t&quot;</span> + <span class="string">&quot;---默认修改标识：&quot;</span> + marked);            <span class="keyword">try</span> &#123;                TimeUnit.SECONDS.sleep(<span class="number">2</span>);            &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;                e.printStackTrace();            &#125;            <span class="type">boolean</span> <span class="variable">b</span> <span class="operator">=</span> atomicMarkableReference.compareAndSet(<span class="number">100</span>, <span class="number">20210308</span>, marked, !marked);            System.out.println(Thread.currentThread().getName() + <span class="string">&quot;\t&quot;</span> + <span class="string">&quot;---操作是否成功:&quot;</span> + b);            System.out.println(Thread.currentThread().getName() + <span class="string">&quot;\t&quot;</span> + atomicMarkableReference.getReference());            System.out.println(Thread.currentThread().getName() + <span class="string">&quot;\t&quot;</span> + atomicMarkableReference.isMarked());        &#125;, <span class="string">&quot;t2&quot;</span>).start();    &#125;&#125;</code></pre><p>运行结果：</p><pre><code class="highlight shell">t1---默认修改标识：falset2---默认修改标识：falset2---操作是否成功:falset2101t2true</code></pre><h2 id="4-对象的属性修改原子类"><a href="#4-对象的属性修改原子类" class="headerlink" title="4. 对象的属性修改原子类"></a>4. 对象的属性修改原子类</h2><h3 id="4-1-原子类"><a href="#4-1-原子类" class="headerlink" title="4.1 原子类"></a>4.1 原子类</h3><ul><li><p>AtomicIntegerFieldUpdater</p><p>原子更新对象中<strong>int类型</strong>字段的值</p></li><li><p>AtomicLongFieldUpdater</p><p>原子更新对象中<strong>Long类型</strong>字段的值</p></li><li><p>AtomicReferenceFieldUpdater</p><p>原子更新<strong>引用类型</strong>字段的值</p></li></ul><h3 id="4-2-使用目的"><a href="#4-2-使用目的" class="headerlink" title="4.2 使用目的"></a>4.2 使用目的</h3><p>以一种线程安全的方式操作非线程安全对象内的某些字段</p><h3 id="4-3-使用要求"><a href="#4-3-使用要求" class="headerlink" title="4.3 使用要求"></a>4.3 使用要求</h3><p>更新的对象属性必须使用 public volatile 修饰符。</p><p>因为对象的属性修改类型原子类都是抽象类，所以每次使用都必须使用静态方法newUpdater()创建一个更新器，并且需要设置想要更新的类和属性。</p><h3 id="4-4-使用案例"><a href="#4-4-使用案例" class="headerlink" title="4.4 使用案例"></a>4.4 使用案例</h3><p><strong>AtomicIntegerFieldUpdater</strong> : Integer 类型字段的原子修改</p><pre><code class="highlight java"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">AtomicIntegerFieldUpdaterTest</span> &#123;    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> InterruptedException &#123;        <span class="type">Bank</span> <span class="variable">bank</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Bank</span>();        <span class="comment">// 创建10个线程，每个线程操作1000次</span>        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; <span class="number">10</span>; i++) &#123;            <span class="keyword">new</span> <span class="title class_">Thread</span>(() -&gt; &#123;                <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> <span class="number">0</span>; j &lt; <span class="number">1000</span>; j++) &#123;                    bank.add(bank);                &#125;            &#125;).start();        &#125;        <span class="comment">// 主线程等待其它线程运行结束</span>        TimeUnit.SECONDS.sleep(<span class="number">3</span>);        System.out.println(<span class="string">&quot;账户还剩：&quot;</span> + bank.money);    &#125;&#125;<span class="keyword">class</span> <span class="title class_">Bank</span> &#123;    <span class="comment">//以一种线程安全的方式操作非线程安全对象内的某些字段</span>    <span class="comment">//1 更新的对象属性必须使用 public volatile 修饰符。</span>    <span class="keyword">public</span> <span class="keyword">volatile</span> <span class="type">int</span> <span class="variable">money</span> <span class="operator">=</span> <span class="number">0</span>;    <span class="keyword">public</span> String name;    <span class="comment">//2 因为对象的属性修改类型原子类都是抽象类，所以每次使用都必须</span>    <span class="comment">// 使用静态方法newUpdater()创建一个更新器，并且需要设置想要更新的类和属性。</span>    AtomicIntegerFieldUpdater&lt;Bank&gt; fieldUpdater = AtomicIntegerFieldUpdater.newUpdater(Bank.class, <span class="string">&quot;money&quot;</span>);    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">add</span><span class="params">(Bank bank)</span> &#123;        <span class="comment">// 每次增加10</span>        fieldUpdater.getAndAdd(bank, <span class="number">10</span>);    &#125;&#125;</code></pre><p>运行结果：</p><pre><code class="highlight shell">账户还剩：100000</code></pre><p><strong>AtomicReferenceFieldUpdater</strong>： 引用类型字段的原子修改</p><pre><code class="highlight java"><span class="keyword">class</span> <span class="title class_">MyVar</span> &#123;    <span class="keyword">public</span> <span class="keyword">volatile</span> <span class="type">MyVar</span> <span class="variable">var</span> <span class="operator">=</span> <span class="literal">null</span>;    AtomicReferenceFieldUpdater&lt;MyVar, MyVar&gt; updater = AtomicReferenceFieldUpdater.newUpdater(MyVar.class, MyVar.class, <span class="string">&quot;var&quot;</span>);    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">init</span><span class="params">(MyVar myVar)</span> &#123;        <span class="keyword">if</span> (updater.compareAndSet(myVar, <span class="literal">null</span>, <span class="keyword">new</span> <span class="title class_">MyVar</span>())) &#123;            System.out.println(Thread.currentThread().getName() + <span class="string">&quot;\t&quot;</span> + <span class="string">&quot;---start init&quot;</span>);            <span class="keyword">try</span> &#123;                TimeUnit.SECONDS.sleep(<span class="number">3</span>);            &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;                e.printStackTrace();            &#125;            System.out.println(Thread.currentThread().getName() + <span class="string">&quot;\t&quot;</span> + <span class="string">&quot;---end init&quot;</span>);        &#125; <span class="keyword">else</span> &#123;            System.out.println(Thread.currentThread().getName() + <span class="string">&quot;\t&quot;</span> + <span class="string">&quot;---抢夺失败，已经有线程在修改中&quot;</span>);        &#125;    &#125;&#125;<span class="comment">/**</span><span class="comment"> * <span class="doctag">@auther</span> zzyy</span><span class="comment"> * <span class="doctag">@create</span> 2021-03-22 15:20</span><span class="comment"> * 多线程并发调用一个类的初始化方法，如果未被初始化过，将执行初始化工作，要求只能初始化一次</span><span class="comment"> */</span><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">AtomicReferenceFieldUpdaterDemo</span> &#123;    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;        <span class="type">MyVar</span> <span class="variable">myVar</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">MyVar</span>();        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">1</span>; i &lt;= <span class="number">5</span>; i++) &#123;            <span class="keyword">new</span> <span class="title class_">Thread</span>(() -&gt; &#123;                myVar.init(myVar);            &#125;, String.valueOf(i)).start();        &#125;    &#125;&#125;</code></pre><p>运行结果：</p><pre><code class="highlight shell">1---start init4---抢夺失败，已经有线程在修改中3---抢夺失败，已经有线程在修改中2---抢夺失败，已经有线程在修改中5---抢夺失败，已经有线程在修改中1---end init</code></pre><h1 id="三、JDK8新增的原子操作类"><a href="#三、JDK8新增的原子操作类" class="headerlink" title="三、JDK8新增的原子操作类"></a>三、JDK8新增的原子操作类</h1><h2 id="1-原子类"><a href="#1-原子类" class="headerlink" title="1. 原子类"></a>1. 原子类</h2><ul><li>DoubleAccumulator</li><li>DoubleAdder</li><li>LongAccumulator</li><li>LongAdder</li></ul><h2 id="2-常用API"><a href="#2-常用API" class="headerlink" title="2. 常用API"></a>2. 常用API</h2><ul><li><p>void add(long x) 将当前的value加x</p></li><li><p>void increment() 将当前的value加1</p></li><li><p>void decrement() 将当前的value减1</p></li><li><p>long sum() </p><p>返回当前值。特别注意，在没有并发更新value的情况下，sum会返回一个精确值，在存在并发的情况下，sum不保证返回精确值。</p></li><li><p>void reset()</p><p>将value重置为0，可用于替代重新new一个 LongAdder，但此方法只可以在没有并发更新的情况下使用。</p></li><li><p>long sumThenReset() </p><p>获取当前value，并将value重置为0</p></li></ul><h2 id="3-入门讲解"><a href="#3-入门讲解" class="headerlink" title="3. 入门讲解"></a>3. 入门讲解</h2><p>LongAdder 只能用来计算加法，且从零开始计算.</p><p><strong>LongAccumulator</strong> 提供了自定义的函数操作.</p><pre><code class="highlight java"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">LongAccumulatorDemo</span> &#123;    <span class="comment">//LongAccumulator longAccumulator = new LongAccumulator((x, y) -&gt; x + y,0);</span>    <span class="comment">// 初始值为10，每次调用，将传进来的参数与10相减</span>    <span class="type">LongAccumulator</span> <span class="variable">longAccumulator</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">LongAccumulator</span>(<span class="keyword">new</span> <span class="title class_">LongBinaryOperator</span>() &#123;        <span class="meta">@Override</span>        <span class="keyword">public</span> <span class="type">long</span> <span class="title function_">applyAsLong</span><span class="params">(<span class="type">long</span> left, <span class="type">long</span> right)</span> &#123;            <span class="keyword">return</span> left - right;        &#125;    &#125;, <span class="number">10</span>); <span class="comment">// 10 是初始值</span>    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">add_LongAccumulator</span><span class="params">()</span> &#123;        <span class="comment">// 每次减1</span>        longAccumulator.accumulate(<span class="number">1</span>);    &#125;    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;        <span class="type">LongAccumulatorDemo</span> <span class="variable">demo</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">LongAccumulatorDemo</span>();        <span class="comment">// 第一次操作</span>        demo.add_LongAccumulator();        <span class="comment">// 第二次操作</span>        demo.add_LongAccumulator();        <span class="comment">// 打印结果</span>        System.out.println(<span class="string">&quot;执行结果：&quot;</span> + demo.longAccumulator.longValue()); <span class="comment">// 结果：8</span>    &#125;&#125;</code></pre><p><strong>LongAdder 使用案例</strong></p><pre><code class="highlight java"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">LongAdderAPIDemo</span> &#123;    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;        <span class="type">LongAdder</span> <span class="variable">longAdder</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">LongAdder</span>();<span class="comment">//只能做加法</span>        longAdder.increment();        longAdder.increment();        longAdder.increment();        System.out.println(longAdder.longValue()); <span class="comment">// 3</span>    &#125;&#125;</code></pre><h2 id="4-LongAdder-高性能对比"><a href="#4-LongAdder-高性能对比" class="headerlink" title="4. LongAdder 高性能对比"></a>4. LongAdder 高性能对比</h2><p>对比在原子操作中，使用 synchronized、AtomicInteger、AtomicLong、LongAdder、LongAccumulator的性能差距</p><h3 id="4-1-测试代码："><a href="#4-1-测试代码：" class="headerlink" title="4.1 测试代码："></a>4.1 测试代码：</h3><pre><code class="highlight java"><span class="keyword">class</span> <span class="title class_">ClickNumber</span> &#123;    <span class="type">int</span> <span class="variable">number</span> <span class="operator">=</span> <span class="number">0</span>;    <span class="comment">/**</span><span class="comment">     * 对比1：使用 synchronized</span><span class="comment">     */</span>    <span class="keyword">public</span> <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title function_">add_Synchronized</span><span class="params">()</span> &#123;        number++;    &#125;    <span class="type">AtomicInteger</span> <span class="variable">atomicInteger</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">AtomicInteger</span>();    <span class="comment">/**</span><span class="comment">     * 对比2: AtomicInteger</span><span class="comment">     */</span>    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">add_AtomicInteger</span><span class="params">()</span> &#123;        atomicInteger.incrementAndGet();    &#125;    <span class="type">AtomicLong</span> <span class="variable">atomicLong</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">AtomicLong</span>();    <span class="comment">/**</span><span class="comment">     * 对比3：AtomicLong</span><span class="comment">     */</span>    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">add_AtomicLong</span><span class="params">()</span> &#123;        atomicLong.incrementAndGet();    &#125;    <span class="type">LongAdder</span> <span class="variable">longAdder</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">LongAdder</span>();    <span class="comment">/**</span><span class="comment">     * 对比4：LongAdder</span><span class="comment">     */</span>    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">add_LongAdder</span><span class="params">()</span> &#123;        longAdder.increment();        <span class="comment">//longAdder.sum();</span>    &#125;    <span class="type">LongAccumulator</span> <span class="variable">longAccumulator</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">LongAccumulator</span>((x, y) -&gt; x + y, <span class="number">0</span>);    <span class="comment">/**</span><span class="comment">     * 对比5：LongAccumulator</span><span class="comment">     */</span>    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">add_LongAccumulator</span><span class="params">()</span> &#123;        longAccumulator.accumulate(<span class="number">1</span>);    &#125;&#125;<span class="comment">/**</span><span class="comment"> * 50个线程，每个线程100W次，总点赞数出来</span><span class="comment"> */</span><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">LongAdderCalcDemo</span> &#123;    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">int</span> <span class="variable">SIZE_THREAD</span> <span class="operator">=</span> <span class="number">50</span>;    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">int</span> <span class="variable">_1W</span> <span class="operator">=</span> <span class="number">10000</span>;    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> InterruptedException &#123;        <span class="type">ClickNumber</span> <span class="variable">clickNumber</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ClickNumber</span>();        <span class="type">long</span> startTime;        <span class="type">long</span> endTime;        <span class="type">CountDownLatch</span> <span class="variable">countDownLatch1</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">CountDownLatch</span>(SIZE_THREAD);        <span class="type">CountDownLatch</span> <span class="variable">countDownLatch2</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">CountDownLatch</span>(SIZE_THREAD);        <span class="type">CountDownLatch</span> <span class="variable">countDownLatch3</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">CountDownLatch</span>(SIZE_THREAD);        <span class="type">CountDownLatch</span> <span class="variable">countDownLatch4</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">CountDownLatch</span>(SIZE_THREAD);        <span class="type">CountDownLatch</span> <span class="variable">countDownLatch5</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">CountDownLatch</span>(SIZE_THREAD);        <span class="comment">//========================</span>        <span class="comment">/****************** synchronized *******************/</span>        startTime = System.currentTimeMillis();        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">1</span>; i &lt;= SIZE_THREAD; i++) &#123;            <span class="keyword">new</span> <span class="title class_">Thread</span>(() -&gt; &#123;                <span class="keyword">try</span> &#123;                    <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> <span class="number">1</span>; j &lt;= <span class="number">100</span> * _1W; j++) &#123;                        clickNumber.add_Synchronized();                    &#125;                &#125; <span class="keyword">catch</span> (Exception e) &#123;                    e.printStackTrace();                &#125; <span class="keyword">finally</span> &#123;                    countDownLatch1.countDown();                &#125;            &#125;, String.valueOf(i)).start();        &#125;        countDownLatch1.await();        endTime = System.currentTimeMillis();        System.out.println(<span class="string">&quot;----costTime: &quot;</span> + (endTime - startTime) + <span class="string">&quot; 毫秒&quot;</span> + <span class="string">&quot;\t add_Synchronized&quot;</span> + <span class="string">&quot;\t&quot;</span> + clickNumber.number);        <span class="comment">/****************** AtomicInteger *******************/</span>        startTime = System.currentTimeMillis();        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">1</span>; i &lt;= SIZE_THREAD; i++) &#123;            <span class="keyword">new</span> <span class="title class_">Thread</span>(() -&gt; &#123;                <span class="keyword">try</span> &#123;                    <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> <span class="number">1</span>; j &lt;= <span class="number">100</span> * _1W; j++) &#123;                        clickNumber.add_AtomicInteger();                    &#125;                &#125; <span class="keyword">catch</span> (Exception e) &#123;                    e.printStackTrace();                &#125; <span class="keyword">finally</span> &#123;                    countDownLatch2.countDown();                &#125;            &#125;, String.valueOf(i)).start();        &#125;        countDownLatch2.await();        endTime = System.currentTimeMillis();        System.out.println(<span class="string">&quot;----costTime: &quot;</span> + (endTime - startTime) + <span class="string">&quot; 毫秒&quot;</span> + <span class="string">&quot;\t add_AtomicInteger&quot;</span> + <span class="string">&quot;\t&quot;</span> + clickNumber.atomicInteger.get());        <span class="comment">/****************** AtomicLong *******************/</span>        startTime = System.currentTimeMillis();        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">1</span>; i &lt;= SIZE_THREAD; i++) &#123;            <span class="keyword">new</span> <span class="title class_">Thread</span>(() -&gt; &#123;                <span class="keyword">try</span> &#123;                    <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> <span class="number">1</span>; j &lt;= <span class="number">100</span> * _1W; j++) &#123;                        clickNumber.add_AtomicLong();                    &#125;                &#125; <span class="keyword">catch</span> (Exception e) &#123;                    e.printStackTrace();                &#125; <span class="keyword">finally</span> &#123;                    countDownLatch3.countDown();                &#125;            &#125;, String.valueOf(i)).start();        &#125;        countDownLatch3.await();        endTime = System.currentTimeMillis();        System.out.println(<span class="string">&quot;----costTime: &quot;</span> + (endTime - startTime) + <span class="string">&quot; 毫秒&quot;</span> + <span class="string">&quot;\t add_AtomicLong&quot;</span> + <span class="string">&quot;\t&quot;</span> + clickNumber.atomicLong.get());        <span class="comment">/****************** LongAdder *******************/</span>        startTime = System.currentTimeMillis();        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">1</span>; i &lt;= SIZE_THREAD; i++) &#123;            <span class="keyword">new</span> <span class="title class_">Thread</span>(() -&gt; &#123;                <span class="keyword">try</span> &#123;                    <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> <span class="number">1</span>; j &lt;= <span class="number">100</span> * _1W; j++) &#123;                        clickNumber.add_LongAdder();                    &#125;                &#125; <span class="keyword">catch</span> (Exception e) &#123;                    e.printStackTrace();                &#125; <span class="keyword">finally</span> &#123;                    countDownLatch4.countDown();                &#125;            &#125;, String.valueOf(i)).start();        &#125;        countDownLatch4.await();        endTime = System.currentTimeMillis();        System.out.println(<span class="string">&quot;----costTime: &quot;</span> + (endTime - startTime) + <span class="string">&quot; 毫秒&quot;</span> + <span class="string">&quot;\t add_LongAdder&quot;</span> + <span class="string">&quot;\t&quot;</span> + clickNumber.longAdder.longValue());        <span class="comment">/****************** LongAccumulator *******************/</span>        startTime = System.currentTimeMillis();        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">1</span>; i &lt;= SIZE_THREAD; i++) &#123;            <span class="keyword">new</span> <span class="title class_">Thread</span>(() -&gt; &#123;                <span class="keyword">try</span> &#123;                    <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> <span class="number">1</span>; j &lt;= <span class="number">100</span> * _1W; j++) &#123;                        clickNumber.add_LongAccumulator();                    &#125;                &#125; <span class="keyword">catch</span> (Exception e) &#123;                    e.printStackTrace();                &#125; <span class="keyword">finally</span> &#123;                    countDownLatch5.countDown();                &#125;            &#125;, String.valueOf(i)).start();        &#125;        countDownLatch5.await();        endTime = System.currentTimeMillis();        System.out.println(<span class="string">&quot;----costTime: &quot;</span> + (endTime - startTime) + <span class="string">&quot; 毫秒&quot;</span> + <span class="string">&quot;\t add_LongAccumulator&quot;</span> + <span class="string">&quot;\t&quot;</span> + clickNumber.longAccumulator.longValue());    &#125;&#125;</code></pre><p>打印结果：</p><pre><code class="highlight shell">----costTime: 2591 毫秒 add_Synchronized50000000----costTime: 702 毫秒 add_AtomicInteger50000000----costTime: 622 毫秒 add_AtomicLong50000000----costTime: 89 毫秒     add_LongAdder50000000----costTime: 137 毫秒 add_LongAccumulator50000000</code></pre><h3 id="4-2-结论"><a href="#4-2-结论" class="headerlink" title="4.2 结论"></a>4.2 结论</h3><p>LongAdder、LongAccumulator 在高并发程序中的性能表现要远好于其它原子操作。</p><h1 id="四、源码、原理分析"><a href="#四、源码、原理分析" class="headerlink" title="四、源码、原理分析"></a>四、源码、原理分析</h1><p><strong>解释：原理(LongAdder为什么这么快)?</strong></p><h2 id="1-原理解析"><a href="#1-原理解析" class="headerlink" title="1. 原理解析"></a>1. 原理解析</h2><h3 id="1-1-原理概述"><a href="#1-1-原理概述" class="headerlink" title="1.1 原理概述"></a>1.1 原理概述</h3><p>LongAdder的基本思路就是分散热点，将value值分散到一个Cell数组中，不同线程会命中到数组的不同槽中，各个线程只对自己槽中的那个值进行CAS操作，这样热点就被分散了，冲突的概率就小很多。如果要获取真正的long值，只要将各个槽中的变量值累加返回。</p><p>sum()会将所有Cell数组中的value和base累加作为返回值，核心的思想就是将之前AtomicLong一个value的更新压力分散到多个value中去，从而降级更新热点。</p><h3 id="1-2-图示"><a href="#1-2-图示" class="headerlink" title="1.2 图示"></a>1.2 图示</h3><p>实现原理如图:</p><p><img src="https://raw.githubusercontent.com/GeorgeChan95/blogimg/master/img/2024/10/01/20241001-161418.png" alt="分散热点"></p><h3 id="1-3-数学表达"><a href="#1-3-数学表达" class="headerlink" title="1.3 数学表达"></a>1.3 数学表达</h3><p>$$<br>value &#x3D; base + \sum_{i&#x3D;0}^n Cell[i]<br>$$</p><p>内部有一个base变量，一个Cell[]数组。</p><ul><li>base变量：非竞态条件下，直接累加到该变量上</li><li>Cell[]数组：竞态条件下，累加个各个线程自己的槽Cell[i]中</li></ul><h2 id="2-LongAdder-架构"><a href="#2-LongAdder-架构" class="headerlink" title="2. LongAdder 架构"></a>2. LongAdder 架构</h2><p><img src="https://raw.githubusercontent.com/GeorgeChan95/blogimg/master/img/2024/09/30/20240930-081127.png" alt="image-20240930081126088"></p><p><strong>LongAdder是Striped64的子类</strong></p><p><img src="https://raw.githubusercontent.com/GeorgeChan95/blogimg/master/img/2024/10/01/20241001-162819.png" alt="LongAdder"></p><h2 id="3-Striped64"><a href="#3-Striped64" class="headerlink" title="3. Striped64"></a>3. Striped64</h2><h3 id="3-1-成员变量"><a href="#3-1-成员变量" class="headerlink" title="3.1 成员变量"></a>3.1 成员变量</h3><p>Striped64有几个比较重要的成员变量</p><pre><code class="highlight java"><span class="comment">/** 计算当前CPU数量,Cell[] 扩容时会用到 */</span><span class="keyword">static</span> <span class="keyword">final</span> <span class="type">int</span> <span class="variable">NCPU</span> <span class="operator">=</span> Runtime.getRuntime().availableProcessors();<span class="comment">/**</span><span class="comment"> * Table of cells. When non-null, size is a power of 2.</span><span class="comment"> */</span><span class="keyword">transient</span> <span class="keyword">volatile</span> Cell[] cells;<span class="comment">/**</span><span class="comment"> * 类似于AtomicLong中全局的value值。在没有竞争情况下数据直接累加到base上，或者cells扩容时，也需要将数据写入到base上</span><span class="comment"> */</span><span class="keyword">transient</span> <span class="keyword">volatile</span> <span class="type">long</span> base;<span class="comment">/**</span><span class="comment"> * 初始化cells或者扩容cells需要获取锁，0:表示无锁状态 1:表示其他线程已经持有了锁</span><span class="comment"> */</span><span class="keyword">transient</span> <span class="keyword">volatile</span> <span class="type">int</span> cellsBusy;</code></pre><h3 id="3-2-成员方法"><a href="#3-2-成员方法" class="headerlink" title="3.2 成员方法"></a>3.2 成员方法</h3><p>Striped64有几个比较重要的成员方法</p><pre><code class="highlight java"><span class="comment">/**</span><span class="comment"> * 通过CAS操作修改 cellsBusy 的值，CAS成功代表获取锁，返回true</span><span class="comment"> */</span><span class="keyword">final</span> <span class="type">boolean</span> <span class="title function_">casCellsBusy</span><span class="params">()</span> &#123;    <span class="keyword">return</span> CELLSBUSY.compareAndSet(<span class="built_in">this</span>, <span class="number">0</span>, <span class="number">1</span>);&#125;<span class="comment">/**</span><span class="comment"> * 获取当前线程的hash值</span><span class="comment"> */</span><span class="keyword">static</span> <span class="keyword">final</span> <span class="type">int</span> <span class="title function_">getProbe</span><span class="params">()</span> &#123;    <span class="keyword">return</span> (<span class="type">int</span>) THREAD_PROBE.get(Thread.currentThread());&#125;<span class="comment">/**</span><span class="comment"> * 重置当前线程的hash值</span><span class="comment"> */</span><span class="keyword">static</span> <span class="keyword">final</span> <span class="type">int</span> <span class="title function_">advanceProbe</span><span class="params">(<span class="type">int</span> probe)</span> &#123;    probe ^= probe &lt;&lt; <span class="number">13</span>;   <span class="comment">// xorshift</span>    probe ^= probe &gt;&gt;&gt; <span class="number">17</span>;    probe ^= probe &lt;&lt; <span class="number">5</span>;    THREAD_PROBE.set(Thread.currentThread(), probe);    <span class="keyword">return</span> probe;&#125;</code></pre><h2 id="4-Cell"><a href="#4-Cell" class="headerlink" title="4. Cell"></a>4. Cell</h2><p>是 java.util.concurrent.atomic 下 Striped64 的一个内部类, 它是LongAdder分散热点实现的具体载体</p><p><img src="https://raw.githubusercontent.com/GeorgeChan95/blogimg/master/img/2024/10/01/20241001-163654.png" alt="Cell内部类"></p><h1 id="五、LongAdder源码解读深度分析"><a href="#五、LongAdder源码解读深度分析" class="headerlink" title="五、LongAdder源码解读深度分析"></a>五、LongAdder源码解读深度分析</h1><h2 id="1-源码解读概述"><a href="#1-源码解读概述" class="headerlink" title="1. 源码解读概述"></a>1. 源码解读概述</h2><p>LongAdder在无竞争的情况，跟 AtomicLong 一样，对同一个base 进行操作，当出现竞争关系时则是采用化整为零的做法，从空间换时间，用一个数组cells，将一个value拆分进这个数组cells。多个线程需要同时对value进行操作时候，可以对线程id进行hash得到hash值，再根据hash值映射到这个数组cells的某个下标，再对该下标所对应的值进行自增操作。当所有线程操作完毕，将数组cells的所有值和无竞争值base都加起来作为最终结果。</p><p><img src="https://raw.githubusercontent.com/GeorgeChan95/blogimg/master/img/2024/10/01/20241001-164412.png" alt="LongAdder并发处理"></p><p><strong>数学表达</strong><br>$$<br>value &#x3D; base + \sum_{i&#x3D;0}^n Cell[i]<br>$$</p><h2 id="2-longAdder-increment-方法解析"><a href="#2-longAdder-increment-方法解析" class="headerlink" title="2. longAdder.increment() 方法解析"></a>2. longAdder.increment() 方法解析</h2><h3 id="2-1-调用流程"><a href="#2-1-调用流程" class="headerlink" title="2.1 调用流程"></a>2.1 调用流程</h3><p><code>java.util.concurrent.atomic.LongAdder#increment</code> —&gt; <code>java.util.concurrent.atomic.LongAdder#add</code> —&gt; <code>java.util.concurrent.atomic.Striped64#longAccumulate</code></p><h3 id="2-2-add-方法"><a href="#2-2-add-方法" class="headerlink" title="2.2 add() 方法"></a>2.2 add() 方法</h3><pre><code class="highlight java"><span class="comment">/**</span><span class="comment"> * Adds the given value.</span><span class="comment"> *</span><span class="comment"> * <span class="doctag">@param</span> x the value to add</span><span class="comment"> */</span><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">add</span><span class="params">(<span class="type">long</span> x)</span> &#123;    Cell[] cs; <span class="comment">// cells 的引用</span>    <span class="type">long</span> b; <span class="comment">// 获取的base值</span>    <span class="type">long</span> v; <span class="comment">// 期望值</span>    <span class="type">int</span> m; <span class="comment">// cell数组的长度</span>    Cell c; <span class="comment">// 当前线程命中的cell单元格</span>    <span class="comment">// 首次首线程 (cs = cells) != null 一定是false，此时走casBase方法，以CAS的方式更新base值，且只有当cas失败时，才会走到if中</span>    <span class="comment">// 条件1: cells不为室，说明出现过竞争，cell[]己创建</span>    <span class="comment">// 条件2:cas操作base失败，说明其它线程先一步修改了base正在出现竞争</span>    <span class="keyword">if</span> ((cs = cells) != <span class="literal">null</span> || !casBase(b = base, b + x)) &#123;        <span class="type">boolean</span> <span class="variable">uncontended</span> <span class="operator">=</span> <span class="literal">true</span>; <span class="comment">// true表示当前线程cas更新成功, false表示cas更新失败,线程处于竞争中</span>        <span class="comment">// 条件1: 表示cells为空,且线程处于竞争状态中,因为经过casBase方法返回false</span>        <span class="comment">// 条件2: cells数组长度小于0,这个应该不会出现</span>        <span class="comment">// 条件3: 当前线程所在的cell为空，说明当前线程还没有更新过cell，应初始化一个cell</span>        <span class="comment">// 条件4: 更新当前线程所在的cell失败，说明现在竞争很激烈，多个线程hash到了同一个cell，应扩容</span>        <span class="comment">// getProbe()方法返回的是线程中的threadLocalRandomProbe字段,它是通过随机数生成的一个值，对于一个确定的线程这个值是固定的(除非刻意修改它)</span>        <span class="keyword">if</span> (cs == <span class="literal">null</span> || (m = cs.length - <span class="number">1</span>) &lt; <span class="number">0</span> ||                (c = cs[getProbe() &amp; m]) == <span class="literal">null</span> ||                !(uncontended = c.cas(v = c.value, v + x)))            <span class="comment">// 调用striped64中的方法处理</span>            longAccumulate(x, <span class="literal">null</span>, uncontended);    &#125;&#125;</code></pre><p><img src="https://raw.githubusercontent.com/GeorgeChan95/blogimg/master/img/2024/10/01/20241001-165106.png" alt="add方法调用流程"></p><ol><li>最初无竞争时只更新base；</li><li>如果更新base失败后，首次新建一个Cell[]数组</li><li>当多个线程竞争同一个Cell比较激烈时，可能就要对Cell[]扩容</li></ol><h3 id="2-3-longAccumulate-方法"><a href="#2-3-longAccumulate-方法" class="headerlink" title="2.3 longAccumulate() 方法"></a>2.3 longAccumulate() 方法</h3><h4 id="2-3-1-longAccumulate入参说明"><a href="#2-3-1-longAccumulate入参说明" class="headerlink" title="2.3.1 longAccumulate入参说明"></a>2.3.1 longAccumulate入参说明</h4><ul><li>long x : 需要增加的值，一般默认都是1</li><li>LongBinaryOperatorfn : 默认传递的是null</li><li>wasUncontended : 竞争标识，如果是false则代表有竞争。只有cels初始化之后，并且当前线程CAS竞争修改失败，才会是false</li></ul><h4 id="2-3-2-Striped64中一些变量或者方法的定义"><a href="#2-3-2-Striped64中一些变量或者方法的定义" class="headerlink" title="2.3.2 Striped64中一些变量或者方法的定义"></a>2.3.2 Striped64中一些变量或者方法的定义</h4><ul><li>base : 类似于AtomicLong中全局的value值。在没有竞争情况下数据直接累加到base上，或者cells扩容时，也需要将数据写入到base上</li><li>collide : 表示扩容意向，false一定不会扩容，true可能会扩容。cellsBusy:初始化cells或者扩容cells需要获取锁，0:表示无锁状态 1:表示其他线程已经持有了锁</li><li>casCellsBusy() : 通过CAS操作修改cellsBusy的值，CAS成功代表获取锁，返回true</li><li>NCPU : 当前计算机CPU数量，Cell数组扩容时会使用到</li><li>getProbe() : 获取当前线程的hash值</li><li>advanceProbe() : 重置当前线程的hash值</li></ul><h4 id="2-3-3-线程hash值：probe"><a href="#2-3-3-线程hash值：probe" class="headerlink" title="2.3.3 线程hash值：probe"></a>2.3.3 线程hash值：probe</h4><p><img src="https://raw.githubusercontent.com/GeorgeChan95/blogimg/master/img/2024/10/01/20241001-170318.png" alt="调用getProbe"></p><p><img src="https://raw.githubusercontent.com/GeorgeChan95/blogimg/master/img/2024/10/01/20241001-170444.png" alt="定义和初始化"></p><p><img src="https://raw.githubusercontent.com/GeorgeChan95/blogimg/master/img/2024/10/01/20241001-170357.png" alt="getProbe"></p><h4 id="2-3-4-longAccumulate-源码总体概览"><a href="#2-3-4-longAccumulate-源码总体概览" class="headerlink" title="2.3.4 longAccumulate 源码总体概览"></a>2.3.4 longAccumulate 源码总体概览</h4><p><img src="https://raw.githubusercontent.com/GeorgeChan95/blogimg/master/img/2024/10/01/20241001-170910.png" alt="longAccumulate 源码总体概览"></p><ul><li>CASE1：Cell[]数组已经初始化</li><li>CASE2：Cell[]数组未初始化(首次新建)</li><li>CASE3：Cell[]数组正在初始化中</li></ul><h4 id="2-3-5-详细解读"><a href="#2-3-5-详细解读" class="headerlink" title="2.3.5 详细解读"></a>2.3.5 详细解读</h4><pre><code class="highlight java"><span class="comment">/**</span><span class="comment"> * long型数据原子方式增长</span><span class="comment"> * <span class="doctag">@param</span> x 需要增加的值, 一般默认都是1</span><span class="comment"> * <span class="doctag">@param</span> fn 默认传递是null</span><span class="comment"> * <span class="doctag">@param</span> wasUncontended 竞争标识,如果是false表示有竞争,只有cells初始化之后,并且当前线程CAS竞争修改失败,才会是false</span><span class="comment"> */</span><span class="keyword">final</span> <span class="keyword">void</span> <span class="title function_">longAccumulate</span><span class="params">(<span class="type">long</span> x, LongBinaryOperator fn,</span><span class="params">                          <span class="type">boolean</span> wasUncontended)</span> &#123;    <span class="comment">// 存储线程的probe值</span>    <span class="type">int</span> h;    <span class="comment">// 如果getProbe()方法返回0，说明随机数未初始化</span>    <span class="keyword">if</span> ((h = getProbe()) == <span class="number">0</span>) &#123;        <span class="comment">// 使用ThreadLocalRandom为当前线程重新计算一个hash值,强制初始化</span>        ThreadLocalRandom.current(); <span class="comment">// force initialization</span>        <span class="comment">// 重新获取probe值,hash值被重置就好比一个全新的线程一样，所以设置了wasuncontended竞争状态为true。</span>        h = getProbe();        <span class="comment">// 重新计算了当前线程的hash后认为此次不算是一次竞争，都未初始化，肯定还不存在竞争激烈wasuncontended竞争状态为true</span>        wasUncontended = <span class="literal">true</span>;    &#125;    <span class="type">boolean</span> <span class="variable">collide</span> <span class="operator">=</span> <span class="literal">false</span>; <span class="comment">// 用于标识是否发生碰撞</span>    done: <span class="keyword">for</span> (;;) &#123;        Cell[] cs; <span class="comment">// cell数组</span>        Cell c; <span class="comment">// 单个cell</span>        <span class="type">int</span> n; <span class="comment">// cell数组长度</span>        <span class="type">long</span> v; <span class="comment">// cell中存储的值</span>        <span class="comment">// CASE1: cells已经被初始化(cell数组不为空,且长度&gt;0)</span>        <span class="keyword">if</span> ((cs = cells) != <span class="literal">null</span> &amp;&amp; (n = cs.length) &gt; <span class="number">0</span>) &#123;            <span class="keyword">if</span> ((c = cs[(n - <span class="number">1</span>) &amp; h]) == <span class="literal">null</span>) &#123; <span class="comment">// 当前线程的hash值运算后映射得到的Cell单元为null，说明该Cell没有被使用</span>                <span class="keyword">if</span> (cellsBusy == <span class="number">0</span>) &#123;       <span class="comment">// Cell[]数组没有正在扩容, 尝试创建一个新的cell</span>                    <span class="type">Cell</span> <span class="variable">r</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Cell</span>(x);   <span class="comment">// 创建一个Cell单元,值为x</span>                    <span class="keyword">if</span> (cellsBusy == <span class="number">0</span> &amp;&amp; casCellsBusy()) &#123; <span class="comment">// 尝试加锁,成功后cellsBusy == 1</span>                        <span class="keyword">try</span> &#123;               <span class="comment">// Recheck under lock</span>                            Cell[] rs; <span class="comment">// 新的cell数组</span>                            <span class="type">int</span> m; <span class="comment">// 新cell数组的长度</span>                            <span class="type">int</span> j; <span class="comment">// 新的cell在cell数组中的索引下标</span>                            <span class="comment">// rs = cells 避免了对全局变量的直接引用, 提高安全性和效率,同时rs 和 cells指向同一个数组,rs变化,cells也会同步</span>                            <span class="keyword">if</span> ((rs = cells) != <span class="literal">null</span> &amp;&amp;                                    (m = rs.length) &gt; <span class="number">0</span> &amp;&amp;                                    rs[j = (m - <span class="number">1</span>) &amp; h] == <span class="literal">null</span>) &#123;                                rs[j] = r; <span class="comment">// 将新创建的cell r 放入cell数组的计算位置</span>                                <span class="keyword">break</span> done;                            &#125;                        &#125; <span class="keyword">finally</span> &#123;                            cellsBusy = <span class="number">0</span>; <span class="comment">// cell创建完成后,重新将cellsBusy置为0,非竞争状态</span>                        &#125;                        <span class="keyword">continue</span>;           <span class="comment">// Slot is now non-empty</span>                    &#125;                &#125;                collide = <span class="literal">false</span>;            &#125;            <span class="keyword">else</span> <span class="keyword">if</span> (!wasUncontended)       <span class="comment">// 如果前一次CAS更新Cell单元失败了</span>                wasUncontended = <span class="literal">true</span>;      <span class="comment">// 重新置为true，后面会重新计算线程的hash值</span>            <span class="keyword">else</span> <span class="keyword">if</span> (c.cas(v = c.value,                    (fn == <span class="literal">null</span>) ? v + x : fn.applyAsLong(v, x))) <span class="comment">// 试CAS更新Cell单元值</span>                <span class="keyword">break</span>;            <span class="keyword">else</span> <span class="keyword">if</span> (n &gt;= NCPU || cells != cs) <span class="comment">// 当Cell数组的大小超过CPU核数后，不再进行扩容</span>                collide = <span class="literal">false</span>;            <span class="comment">// At max size or stale</span>            <span class="keyword">else</span> <span class="keyword">if</span> (!collide)                collide = <span class="literal">true</span>;            <span class="keyword">else</span> <span class="keyword">if</span> (cellsBusy == <span class="number">0</span> &amp;&amp; casCellsBusy()) &#123; <span class="comment">// 尝试加锁进行扩容</span>                <span class="keyword">try</span> &#123;                    <span class="keyword">if</span> (cells == cs) <span class="comment">// cells和局部变量cs相同,表示没有其他线程扩容过</span>                        cells = Arrays.copyOf(cs, n &lt;&lt; <span class="number">1</span>); <span class="comment">// 扩容后的大小==当前容量*2</span>                &#125; <span class="keyword">finally</span> &#123;                    cellsBusy = <span class="number">0</span>;                &#125;                collide = <span class="literal">false</span>;                <span class="keyword">continue</span>;                   <span class="comment">// Retry with expanded table</span>            &#125;            h = advanceProbe(h); <span class="comment">// 计算线程新的hash值,重新参与下一轮竞争中</span>        &#125;        <span class="comment">// CASE2: cells没有加锁且没有初始化,则尝试对它进行加锁,并初始化</span>        <span class="keyword">else</span> <span class="keyword">if</span> (cellsBusy == <span class="number">0</span> &amp;&amp; cells == cs &amp;&amp; casCellsBusy()) &#123;            <span class="keyword">try</span> &#123;                           <span class="comment">// Initialize table</span>                <span class="keyword">if</span> (cells == cs) &#123; <span class="comment">// 进行两次校验, 由于cells是共有的对象,可能出现多线程并发修改导致对象状态发生变化,两次校验确保数据状态一致</span>                    Cell[] rs = <span class="keyword">new</span> <span class="title class_">Cell</span>[<span class="number">2</span>]; <span class="comment">// 新建一个容量为2的cell数组</span>                    rs[h &amp; <span class="number">1</span>] = <span class="keyword">new</span> <span class="title class_">Cell</span>(x); <span class="comment">// 找到当前线程hash到数组中的位置,并创建对应的cell</span>                    cells = rs;                    <span class="keyword">break</span> done;                &#125;            &#125; <span class="keyword">finally</span> &#123;                cellsBusy = <span class="number">0</span>;            &#125;        &#125;        <span class="comment">//  // CASE3: cells正在进行初始化,则尝试直接在base上进行累加操作</span>        <span class="keyword">else</span> <span class="keyword">if</span> (casBase(v = base,                (fn == <span class="literal">null</span>) ? v + x : fn.applyAsLong(v, x)))            <span class="keyword">break</span> done;    &#125;&#125;</code></pre><p><img src="https://raw.githubusercontent.com/GeorgeChan95/blogimg/master/img/2024/10/01/20241001-171450.png" alt="代码流程"></p><h2 id="3-sum-方法"><a href="#3-sum-方法" class="headerlink" title="3. sum() 方法"></a>3. sum() 方法</h2><p>sum()会将所有Cell数组中的value和base累加作为返回值。<br>核心的思想就是将之前AtomicLong一个value的更新压力分散到多个value中去，从而降级更新热点。</p><h3 id="为什么在并发情况下sum的值不精确"><a href="#为什么在并发情况下sum的值不精确" class="headerlink" title="为什么在并发情况下sum的值不精确"></a>为什么在并发情况下sum的值不精确</h3><p><strong>sum执行时，并没有限制对base和cells的更新(关键点)。所以LongAdder不是强一致性的，它是最终一致性的。</strong></p><ul><li>sum执行时，并没有限制对base和cells的更新(一句要命的话)。所以LongAdder不是强一致性的，它是最终一致性的。</li><li>sum执行时，并没有限制对base和cells的更新(一句要命的话)。所以LongAdder不是强一致性的，它是最终一致性的。</li></ul><p><img src="C:/Users/George/AppData/Roaming/Typora/typora-user-images/image-20241001171643897.png" alt="sum方法"></p><h1 id="六、总结"><a href="#六、总结" class="headerlink" title="六、总结"></a>六、总结</h1><h2 id="1-AtomicLong与LongAdder对比"><a href="#1-AtomicLong与LongAdder对比" class="headerlink" title="1. AtomicLong与LongAdder对比"></a>1. AtomicLong与LongAdder对比</h2><p><strong>AtomicLong</strong></p><ul><li>线程安全，可允许一些性能损耗，要求高精度时可使用</li><li>保证精度，性能代价</li><li>AtomicLong是多个线程针对单个热点值value进行原子操作</li></ul><p><strong>LongAdder</strong></p><ul><li>当需要在高并发下有较好的性能表现，且对值的精确度要求不高时，可以使用</li><li>保证性能，精度代价</li><li>LongAdder是每个线程拥有自己的槽，各个线程一般只对自己槽中的那个值进行CAS操作</li></ul><h2 id="2-AtomicLong"><a href="#2-AtomicLong" class="headerlink" title="2. AtomicLong"></a>2. AtomicLong</h2><p><strong>原理</strong></p><ul><li>CAS+自旋</li><li>incrementAndGet</li></ul><p><strong>场景</strong></p><ul><li>低并发下的全局计算</li><li>AtomicLong能保证并发情况下计数的准确性，其内部通过CAS来解决并发安全性的问题。</li></ul><p><strong>缺陷</strong></p><ul><li><p>高并发后性能急剧下降,AtomicLong的自旋会成为瓶颈</p><p>N个线程CAS操作修改线程的值，每次只有一个成功过，其它N - 1失败，失败的不停的自旋直到成功，这样大量失败自旋的情况，一下子cpu就打高了。</p></li></ul><h2 id="3-LongAdder"><a href="#3-LongAdder" class="headerlink" title="3. LongAdder"></a>3. LongAdder</h2><p><strong>原理</strong></p><ul><li>CAS+Base+Cell数组分散</li><li>空间换时间并分散了热点数据</li></ul><p><strong>场景</strong></p><p>高并发下的全局计算</p><p><strong>缺陷</strong></p><p>sum求和后还有计算线程修改结果的话，最后结果不够准确</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;一、常用原子操作类&quot;&gt;&lt;a href=&quot;#一、常用原子操作类&quot; class=&quot;headerlink&quot; title=&quot;一、常用原子操作类&quot;&gt;&lt;/a&gt;一、常用原子操作类&lt;/h1&gt;&lt;p&gt;JDK文档：&lt;a href=&quot;https://www.runoob.com/manu</summary>
      
    
    
    
    <category term="JUC" scheme="https://georgechan95.github.io/categories/JUC/"/>
    
    
    <category term="juc" scheme="https://georgechan95.github.io/tags/juc/"/>
    
    <category term="java" scheme="https://georgechan95.github.io/tags/java/"/>
    
  </entry>
  
  <entry>
    <title>07-JUC进阶-CAS</title>
    <link href="https://georgechan95.github.io/blog/5e3757c1.html"/>
    <id>https://georgechan95.github.io/blog/5e3757c1.html</id>
    <published>2024-09-26T11:37:00.000Z</published>
    <updated>2024-09-27T11:59:54.524Z</updated>
    
    <content type="html"><![CDATA[<h1 id="一、没有CAS之前"><a href="#一、没有CAS之前" class="headerlink" title="一、没有CAS之前"></a>一、没有CAS之前</h1><ul><li><p>多线程环境不使用原子类保证线程安全（基本数据类型）</p><pre><code class="highlight java"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">T1</span> &#123;    <span class="keyword">volatile</span> <span class="type">int</span> <span class="variable">number</span> <span class="operator">=</span> <span class="number">0</span>;    <span class="comment">//读取</span>    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">getNumber</span><span class="params">()</span> &#123;        <span class="keyword">return</span> number;    &#125;    <span class="comment">//写入加锁保证原子性</span>    <span class="keyword">public</span> <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title function_">setNumber</span><span class="params">()</span> &#123;        number++;    &#125;&#125;</code></pre></li><li><p>多线程环境使用原子类保证线程安全（基本数据类型）</p><pre><code class="highlight java"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">T2</span> &#123;    <span class="type">AtomicInteger</span> <span class="variable">atomicInteger</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">AtomicInteger</span>();    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">getAtomicInteger</span><span class="params">()</span> &#123;        <span class="keyword">return</span> atomicInteger.get();    &#125;    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setAtomicInteger</span><span class="params">()</span> &#123;        atomicInteger.getAndIncrement();    &#125;&#125;</code></pre></li></ul><h1 id="二、什么是CAS"><a href="#二、什么是CAS" class="headerlink" title="二、什么是CAS"></a>二、什么是CAS</h1><h2 id="1-概念"><a href="#1-概念" class="headerlink" title="1. 概念"></a>1. 概念</h2><p>CAS 即： compare and swap的缩写，中文翻译成比较并交换,实现并发算法时常用到的一种技术。它包含三个操作数——内存位置、预期原值及更新值。</p><p>执行CAS操作的时候，将内存位置的值与预期原值比较：</p><ul><li>如果相匹配，那么处理器会自动将该位置值更新为新值，</li><li>如果不匹配，处理器不做任何操作，多个线程同时执行CAS操作只有一个会成功。</li></ul><h2 id="2-原理"><a href="#2-原理" class="headerlink" title="2. 原理"></a>2. 原理</h2><h3 id="2-1-概述"><a href="#2-1-概述" class="headerlink" title="2.1 概述"></a>2.1 概述</h3><p>CAS有3个操作数，位置内存值V，旧的预期值A，要修改的更新值B。</p><p>当且仅当旧的预期值A和内存值V相同时，将内存值V修改为B，否则什么都不做或重来</p><p><img src="https://raw.githubusercontent.com/GeorgeChan95/blogimg/master/img/2024/09/26/20240926-200317.png" alt="CAS原理"></p><h3 id="2-2-硬件级别保证"><a href="#2-2-硬件级别保证" class="headerlink" title="2.2 硬件级别保证"></a>2.2 硬件级别保证</h3><p>CAS是JDK提供的非阻塞原子性操作，它通过硬件保证了比较-更新的原子性。</p><p>它是非阻塞的且自身原子性，也就是说它效率更高且通过硬件保证，更可靠。</p><p>CAS是一条CPU的原子指令（cmpxchg指令），不会造成所谓的数据不一致问题，Unsafe提供的CAS方法（如 compareAndSwapXXX ）底层实现即为CPU指令<code>cmpxchg</code>。</p><p>执行 <code>cmpxchg</code> 指令的时候，会判断当前系统是否为多核系统，如果是就给总线加锁，只有一个线程会对总线加锁成功，加锁成功之后会执行cas操作，也就是说CAS的原子性实际上是CPU实现的， 其实在这一点上还是有排他锁的，只是比起用 <code>synchronized</code>， 这里的排他时间要短的多， 所以在多线程情况下性能会比较好</p><h2 id="3-CAS代码示例"><a href="#3-CAS代码示例" class="headerlink" title="3. CAS代码示例"></a>3. CAS代码示例</h2><pre><code class="highlight java"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">CASDemo</span> &#123;    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;        <span class="type">AtomicInteger</span> <span class="variable">atomicInteger</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">AtomicInteger</span>(<span class="number">5</span>);        System.out.println(atomicInteger.get());                System.out.println(atomicInteger.compareAndSet(<span class="number">5</span>, <span class="number">308</span>) + <span class="string">&quot;\t&quot;</span> + atomicInteger.get());        System.out.println(atomicInteger.compareAndSet(<span class="number">5</span>, <span class="number">3333</span>) + <span class="string">&quot;\t&quot;</span> + atomicInteger.get());    &#125;&#125;</code></pre><p>执行结果：</p><pre><code class="highlight shell">5true308false308</code></pre><h2 id="4-源码解析"><a href="#4-源码解析" class="headerlink" title="4. 源码解析"></a>4. 源码解析</h2><ul><li><p>compareAndSet(int expect, int update)</p><pre><code class="highlight java"><span class="comment">/**</span><span class="comment"> * Atomically sets the value to the given updated value</span><span class="comment"> * if the current value &#123;<span class="doctag">@code</span> ==&#125; the expected value.</span><span class="comment"> *</span><span class="comment"> * <span class="doctag">@param</span> expect the expected value</span><span class="comment"> * <span class="doctag">@param</span> update the new value</span><span class="comment"> * <span class="doctag">@return</span> &#123;<span class="doctag">@code</span> true&#125; if successful. False return indicates that</span><span class="comment"> * the actual value was not equal to the expected value.</span><span class="comment"> */</span><span class="keyword">public</span> <span class="keyword">final</span> <span class="type">boolean</span> <span class="title function_">compareAndSet</span><span class="params">(<span class="type">int</span> expect, <span class="type">int</span> update)</span> &#123;    <span class="keyword">return</span> unsafe.compareAndSwapInt(<span class="built_in">this</span>, valueOffset, expect, update);&#125;</code></pre><ul><li><p>unsafe.compareAndSwapInt(this, valueOffset, expect, update)</p><pre><code class="highlight java"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">native</span> <span class="type">boolean</span> <span class="title function_">compareAndSwapObject</span><span class="params">(Object var1, <span class="type">long</span> var2, Object var4, Object var5)</span>;<span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">native</span> <span class="type">boolean</span> <span class="title function_">compareAndSwapInt</span><span class="params">(Object var1, <span class="type">long</span> var2, <span class="type">int</span> var4, <span class="type">int</span> var5)</span>;<span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">native</span> <span class="type">boolean</span> <span class="title function_">compareAndSwapLong</span><span class="params">(Object var1, <span class="type">long</span> var2, <span class="type">long</span> var4, <span class="type">long</span> var6)</span>;</code></pre></li></ul><p>上面三个方法都是类似的，主要对4个参数做一下说明。</p><ul><li>var1：表示要操作的对象</li><li>var2：表示要操作对象中属性地址的偏移量</li><li>var4：表示需要修改数据的期望的值</li><li>var5&#x2F;var6：表示需要修改为的新值</li></ul></li></ul><p>那么什么是 <code>unsafe</code> 呢？</p><h1 id="三、关于-UnSafe-的理解"><a href="#三、关于-UnSafe-的理解" class="headerlink" title="三、关于 UnSafe 的理解"></a>三、关于 UnSafe 的理解</h1><h2 id="1-UnSafe"><a href="#1-UnSafe" class="headerlink" title="1. UnSafe"></a>1. UnSafe</h2><p><strong>UnSafe</strong></p><p><code>Unsafe</code> 是CAS的核心类，由于Java方法无法直接访问底层系统，需要通过本地（native）方法来访问，<code>Unsafe</code> 相当于一个后门，基于该类可以直接操作特定内存的数据。<code>Unsafe</code> 类存在于 <code>sun.misc</code> 包中，其内部方法操作可以像C的指针一样直接操作内存，因为Java中CAS操作的执行依赖于<code>Unsafe</code>类的方法。</p><p><strong>注意Unsafe类中的所有方法都是native修饰的，也就是说Unsafe类中的方法都直接调用操作系统底层资源执行相应任务</strong> </p><p><img src="https://raw.githubusercontent.com/GeorgeChan95/blogimg/master/img/2024/09/26/20240926-202221.png" alt="AtomicInteger"></p><p><strong>变量valueOffset</strong></p><p>变量 valueOffset，表示该变量值在内存中的偏移地址，因为 <code>Unsafe</code> 就是根据内存偏移地址获取数据的。</p><pre><code class="highlight java"><span class="comment">/**</span><span class="comment"> * Atomically increments by one the current value.</span><span class="comment"> *</span><span class="comment"> * <span class="doctag">@return</span> the previous value</span><span class="comment"> */</span><span class="keyword">public</span> <span class="keyword">final</span> <span class="type">int</span> <span class="title function_">getAndIncrement</span><span class="params">()</span> &#123;    <span class="keyword">return</span> unsafe.getAndAddInt(<span class="built_in">this</span>, valueOffset, <span class="number">1</span>);&#125;</code></pre><p><strong>用volatile修饰</strong>，保证了多线程之间的内存可见性。</p><p><img src="C:/Users/kd/AppData/Roaming/Typora/typora-user-images/image-20240926202653288.png" alt="变量value"></p><h2 id="2-CPU并发原语"><a href="#2-CPU并发原语" class="headerlink" title="2. CPU并发原语"></a>2. CPU并发原语</h2><p>我们知道i++线程不安全的，那 <code>atomicInteger.getAndIncrement()</code> 是如何保证线程安全的呢？</p><p>CAS的全称为Compare-And-Swap，它是一条CPU并发原语。它的功能是判断内存某个位置的值是否为预期值，如果是则更改为新的值，这个过程是原子的。<br>AtomicInteger 类主要利用 CAS (compare and swap) + volatile 和 native 方法来保证原子操作，从而避免 synchronized 的高开销，执行效率大为提升。</p><p><img src="https://raw.githubusercontent.com/GeorgeChan95/blogimg/master/img/2024/09/26/20240926-203001.png" alt="Compare-And-Swap"></p><p>CAS并发原语体现在JAVA语言中就是 <code>sun.misc.Unsafe</code> 类中的各个方法。调用 UnSafe 类中的CAS方法，JVM会帮我们实现出CAS汇编指令。这是一种完全依赖于硬件的功能，通过它实现了原子操作。再次强调，由于CAS是一种系统原语，原语属于操作系统用语范畴，是由若干条指令组成的，用于完成某个功能的一个过程，并且原语的执行必须是连续的，在执行过程中不允许被中断，也就是说CAS是一条CPU的原子指令，不会造成所谓的数据不一致问题。</p><h2 id="3-底层汇编"><a href="#3-底层汇编" class="headerlink" title="3. 底层汇编"></a>3. 底层汇编</h2><ul><li><p>native修饰的方法代表是底层方法</p><p>Unsafe类中的compareAndSwapInt，是一个本地方法，该方法的实现位于unsafe.cpp中</p><pre><code class="highlight cpp"><span class="built_in">UNSAFE_ENTRY</span>(jboolean, <span class="built_in">Unsafe_CompareAndSwapInt</span>(JNIEnv *env, jobject unsafe, jobject obj, jlong offset, jint e, jint x))  <span class="built_in">UnsafeWrapper</span>(<span class="string">&quot;Unsafe_CompareAndSwapInt&quot;</span>);  oop p = JNIHandles::<span class="built_in">resolve</span>(obj);<span class="comment">// 先想办法拿到变量value在内存中的地址，根据偏移量valueOffset，计算 value 的地址</span>  jint* addr = (jint *) <span class="built_in">index_oop_from_field_offset_long</span>(p, offset);<span class="comment">// 调用 Atomic 中的函数 cmpxchg来进行比较交换，其中参数x是即将更新的值，参数e是原内存的值</span>  <span class="keyword">return</span> (jint)(Atomic::<span class="built_in">cmpxchg</span>(x, addr, e)) == e;UNSAFE_END</code></pre><p>(Atomic::cmpxchg(x, addr, e)) &#x3D;&#x3D; e;</p></li><li><p>cmpxchg</p><p>&#x2F;&#x2F; 调用 Atomic 中的函数 cmpxchg来进行比较交换，其中参数x是即将更新的值，参数e是原内存的值<br>  return (jint)(Atomic::cmpxchg(x, addr, e)) &#x3D;&#x3D; e;</p><pre><code class="highlight cpp"><span class="function"><span class="type">unsigned</span> <span class="title">Atomic::cmpxchg</span><span class="params">(<span class="type">unsigned</span> <span class="type">int</span> exchange_value,<span class="keyword">volatile</span> <span class="type">unsigned</span> <span class="type">int</span>* dest, <span class="type">unsigned</span> <span class="type">int</span> compare_value)</span> </span>&#123;    <span class="built_in">assert</span>(<span class="built_in">sizeof</span>(<span class="type">unsigned</span> <span class="type">int</span>) == <span class="built_in">sizeof</span>(jint), <span class="string">&quot;more work to do&quot;</span>);  <span class="comment">/*</span><span class="comment">   * 根据操作系统类型调用不同平台下的重载函数，这个在预编译期间编译器会决定调用哪个平台下的重载函数*/</span>    <span class="keyword">return</span> (<span class="type">unsigned</span> <span class="type">int</span>)Atomic::<span class="built_in">cmpxchg</span>((jint)exchange_value, (<span class="keyword">volatile</span> jint*)dest, (jint)compare_value);&#125;</code></pre></li><li><p>在不同的操作系统下会调用不同的cmpxchg重载函数，本次用的是win10系统</p><pre><code class="highlight cpp"><span class="function"><span class="keyword">inline</span> jint <span class="title">Atomic::cmpxchg</span> <span class="params">(jint exchange_value, <span class="keyword">volatile</span> jint* dest, jint compare_value)</span> </span>&#123;  <span class="comment">//判断是否是多核CPU</span>  <span class="type">int</span> mp = os::<span class="built_in">is_MP</span>();  __asm &#123;    <span class="comment">//三个move指令表示的是将后面的值移动到前面的寄存器上</span>    mov edx, dest    mov ecx, exchange_value    mov eax, compare_value    <span class="comment">//CPU原语级别，CPU触发</span>    <span class="built_in">LOCK_IF_MP</span>(mp)    <span class="comment">//比较并交换指令</span>    <span class="comment">//cmpxchg: 即“比较并交换”指令</span>    <span class="comment">//dword: 全称是 double word 表示两个字，一共四个字节</span>    <span class="comment">//ptr: 全称是 pointer，与前面的 dword 连起来使用，表明访问的内存单元是一个双字单元 </span>    <span class="comment">//将 eax 寄存器中的值（compare_value）与 [edx] 双字内存单元中的值进行对比，</span>    <span class="comment">//如果相同，则将 ecx 寄存器中的值（exchange_value）存入 [edx] 内存单元中</span>    cmpxchg dword ptr [edx], ecx  &#125;&#125;</code></pre><p>到这里我们应该理解了CAS真正实现的机制了，它最终是由操作系统的汇编指令完成的。</p></li></ul><p><strong>总结：</strong></p><p>你只需要记住：CAS是靠硬件实现的从而在硬件层面提升效率，最底层还是交给硬件来保证原子性和可见性。实现方式是基于硬件平台的汇编指令，在intel的CPU中(X86机器上)，使用的是汇编指令<code>cmpxchg</code>指令。 </p><p>核心思想就是：比较要更新变量的值V和预期值E（compare），相等才会将V的值设为新值N（swap）如果不相等自旋再来。</p><h1 id="四、原子引用"><a href="#四、原子引用" class="headerlink" title="四、原子引用"></a>四、原子引用</h1><p>除了 AtomicInteger 原子整型，可否有其它原子类型？比如 AtomicBook 、AtomicOrder。</p><p>JDK 除了提供了原子整型之外，还提供了原子引用类：<code>AtomicReference</code></p><p><img src="https://raw.githubusercontent.com/GeorgeChan95/blogimg/master/img/2024/09/27/20240927-192203.png" alt="原子引用"></p><pre><code class="highlight java"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">AtomicReferenceTest</span> &#123;    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;        <span class="type">User1</span> <span class="variable">user1</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">User1</span>(<span class="string">&quot;张三&quot;</span>, <span class="number">20</span>);        <span class="type">User1</span> <span class="variable">user2</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">User1</span>(<span class="string">&quot;george&quot;</span>, <span class="number">22</span>);        AtomicReference&lt;User1&gt; atomicUser1 = <span class="keyword">new</span> <span class="title class_">AtomicReference</span>&lt;&gt;();        atomicUser1.set(user1);        System.out.println(<span class="string">&quot;当前人员：&quot;</span> + atomicUser1.get());        <span class="comment">// 第一次比较替换，张三 换成 george， 结果成功</span>        System.out.println(atomicUser1.compareAndSet(user1, user2) + <span class="string">&quot;\t&quot;</span> + atomicUser1.get());        <span class="comment">// 第二次比较替换，张三 换成 george， 结果失败</span>        System.out.println(atomicUser1.compareAndSet(user1, user2) + <span class="string">&quot;\t&quot;</span> + atomicUser1.get());    &#125;&#125;<span class="meta">@Data</span><span class="meta">@ToString</span><span class="meta">@NoArgsConstructor</span><span class="meta">@AllArgsConstructor</span><span class="keyword">class</span> <span class="title class_">User1</span> &#123;    <span class="keyword">private</span> String name;    <span class="keyword">private</span> Integer age;&#125;</code></pre><p>运行结果：</p><pre><code class="highlight shell">当前人员：User1(name=张三, age=20)trueUser1(name=george, age=22)falseUser1(name=george, age=22)</code></pre><h1 id="五、自旋锁"><a href="#五、自旋锁" class="headerlink" title="五、自旋锁"></a>五、自旋锁</h1><h2 id="1-自旋锁概念"><a href="#1-自旋锁概念" class="headerlink" title="1. 自旋锁概念"></a>1. 自旋锁概念</h2><p><strong>自旋锁（spinlock）</strong>是指尝试获取锁的线程不会立即阻塞，而是采用循环的方式去尝试获取锁，当线程发现锁被占用时，会不断循环判断锁的状态，直到获取。这样的好处是减少线程上下文切换的消耗，缺点是循环会消耗CPU</p><p>OpenJDK源码里面查看下 </p><p><img src="https://raw.githubusercontent.com/GeorgeChan95/blogimg/master/img/2024/09/27/20240927-192926.png" alt="Unsafe.java"></p><h2 id="2-实现一个自旋锁"><a href="#2-实现一个自旋锁" class="headerlink" title="2. 实现一个自旋锁"></a>2. 实现一个自旋锁</h2><pre><code class="highlight java"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">MySpinLock</span> &#123;    AtomicReference&lt;Thread&gt; atomicReference = <span class="keyword">new</span> <span class="title class_">AtomicReference</span>&lt;&gt;();    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">lock</span><span class="params">()</span> &#123;        <span class="comment">// 当没有替换成当前线程，则表示获取锁失败，线程自旋</span>        <span class="keyword">while</span> (!atomicReference.compareAndSet(<span class="literal">null</span>, Thread.currentThread())) &#123;        &#125;        System.out.println(Thread.currentThread().getName() + <span class="string">&quot;获取锁成功&quot;</span>);    &#125;    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">unlock</span><span class="params">()</span> &#123;        <span class="keyword">while</span> (atomicReference.compareAndSet(Thread.currentThread(), <span class="literal">null</span>)) &#123;            System.out.println(Thread.currentThread().getName() + <span class="string">&quot;解锁成功&quot;</span>);        &#125;    &#125;    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> InterruptedException &#123;        <span class="type">MySpinLock</span> <span class="variable">lock</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">MySpinLock</span>();        <span class="keyword">new</span> <span class="title class_">Thread</span>(() -&gt; &#123;            <span class="comment">// 获取锁</span>            lock.lock();            <span class="keyword">try</span> &#123;                <span class="comment">// 阻塞3秒</span>                TimeUnit.SECONDS.sleep(<span class="number">3</span>);            &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;                <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">RuntimeException</span>(e);            &#125;            <span class="comment">// 解锁</span>            lock.unlock();        &#125;, <span class="string">&quot;t1&quot;</span>).start();        <span class="comment">// 程序暂停1秒， 保证t1先拿到锁</span>        TimeUnit.SECONDS.sleep(<span class="number">1</span>);        <span class="keyword">new</span> <span class="title class_">Thread</span>(() -&gt; &#123;            lock.lock();            lock.unlock();        &#125;, <span class="string">&quot;t2&quot;</span>).start();    &#125;&#125;</code></pre><p>运行结果：</p><pre><code class="highlight shell">t1获取锁成功t1解锁成功t2获取锁成功t2解锁成功</code></pre><p>结果：t1先拿到了锁，将 atomicReference 设置成自己，t2 再去获取锁的时候就会获取失败，然后在 while 中自旋， 等待 t1 释放锁后，t2才能获取到锁继续执行。</p><h1 id="六、CAS缺点"><a href="#六、CAS缺点" class="headerlink" title="六、CAS缺点"></a>六、CAS缺点</h1><h2 id="1-时间开销大"><a href="#1-时间开销大" class="headerlink" title="1. 时间开销大"></a>1. 时间开销大</h2><p>循环时间长开销很大。</p><p>我们可以看到 <code>getAndAddInt</code> 方法执行时，有个 <code>do while</code></p><p><img src="https://raw.githubusercontent.com/GeorgeChan95/blogimg/master/img/2024/09/27/20240927-194243.png" alt="do while"></p><p>如果CAS失败，会一直进行尝试。如果CAS长时间一直不成功，可能会给CPU带来很大的开销。</p><h2 id="2-ABA问题"><a href="#2-ABA问题" class="headerlink" title="2. ABA问题"></a>2. ABA问题</h2><p>CAS会导致“ABA问题”。</p><p>CAS算法实现一个重要前提需要取出内存中某时刻的数据并在当下时刻比较并替换，那么在这个时间差类会导致数据的变化。</p><p>比如说一个<strong>线程t1</strong>从内存位置V中取出A，这时候另一个<strong>线程t2</strong>也从内存中取出A，并且<strong>线程t2</strong>进行了一些操作将值变成了B，<br>然后<strong>线程t2</strong>又将V位置的数据变成A，这时候<strong>线程t1</strong>进行CAS操作发现内存中仍然是A，然后<strong>线程t1</strong>操作成功。</p><pre><code class="highlight java"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">abaProblem</span><span class="params">()</span> &#123;    <span class="keyword">new</span> <span class="title class_">Thread</span>(() -&gt; &#123;        atomicInteger.compareAndSet(<span class="number">100</span>, <span class="number">101</span>);        atomicInteger.compareAndSet(<span class="number">101</span>, <span class="number">100</span>);    &#125;, <span class="string">&quot;t1&quot;</span>).start();    <span class="comment">//暂停毫秒</span>    <span class="keyword">try</span> &#123;        TimeUnit.MILLISECONDS.sleep(<span class="number">10</span>);    &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;        e.printStackTrace();    &#125;    <span class="keyword">new</span> <span class="title class_">Thread</span>(() -&gt; &#123;        <span class="type">boolean</span> <span class="variable">b</span> <span class="operator">=</span> atomicInteger.compareAndSet(<span class="number">100</span>, <span class="number">20210308</span>);        System.out.println(Thread.currentThread().getName() + <span class="string">&quot;\t&quot;</span> + <span class="string">&quot;修改成功否：&quot;</span> + b + <span class="string">&quot;\t&quot;</span> + atomicInteger.get());    &#125;, <span class="string">&quot;t2&quot;</span>).start();&#125;</code></pre><p>尽管<strong>线程t1</strong>的CAS操作成功，但是不代表这个过程就是没有问题的。</p><p><strong>解决方式：</strong>使用 <code>AtomicStampedReference</code>， 带有版本号的原子操作类。</p><pre><code class="highlight java"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ABATest</span> &#123;    <span class="comment">// 初始值：100   初始版本号：1</span>    <span class="keyword">static</span> AtomicStampedReference&lt;Integer&gt; stampedReference = <span class="keyword">new</span> <span class="title class_">AtomicStampedReference</span>&lt;&gt;(<span class="number">100</span>, <span class="number">1</span>);    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;        <span class="keyword">new</span> <span class="title class_">Thread</span>(() -&gt; &#123;            <span class="type">int</span> <span class="variable">stamp</span> <span class="operator">=</span> stampedReference.getStamp();            System.out.println(Thread.currentThread().getName() + <span class="string">&quot; 默认获取到的值：&quot;</span> + stampedReference.getReference() + <span class="string">&quot;\t默认版本号：&quot;</span> + stamp);            <span class="keyword">try</span> &#123;                TimeUnit.SECONDS.sleep(<span class="number">1</span>);            &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;                <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">RuntimeException</span>(e);            &#125;            <span class="comment">// 修改值，将版本号加1</span>            <span class="type">boolean</span> <span class="variable">flag1</span> <span class="operator">=</span> stampedReference.compareAndSet(<span class="number">100</span>, <span class="number">101</span>, stampedReference.getStamp(), stampedReference.getStamp() + <span class="number">1</span>);            System.out.println(Thread.currentThread().getName() + <span class="string">&quot;第一次修改：&quot;</span> + flag1);            <span class="comment">// 修改值，将版本号加1</span>            <span class="type">boolean</span> <span class="variable">flag2</span> <span class="operator">=</span> stampedReference.compareAndSet(<span class="number">101</span>, <span class="number">100</span>, stampedReference.getStamp(), stampedReference.getStamp() + <span class="number">1</span>);            System.out.println(Thread.currentThread().getName() + <span class="string">&quot;第二次修改：&quot;</span> + flag2);            System.out.println(<span class="string">&quot;修改后的值：&quot;</span> + stampedReference.getReference() + <span class="string">&quot;\t版本号：&quot;</span> + stampedReference.getStamp());        &#125;, <span class="string">&quot;t1&quot;</span>).start();        <span class="keyword">new</span> <span class="title class_">Thread</span>(() -&gt; &#123;            <span class="type">int</span> <span class="variable">stamp</span> <span class="operator">=</span> stampedReference.getStamp();            System.out.println(Thread.currentThread().getName() + <span class="string">&quot; 默认获取到的值：&quot;</span> + stampedReference.getReference() + <span class="string">&quot;\t默认版本号：&quot;</span> + stamp);            <span class="keyword">try</span> &#123;                TimeUnit.SECONDS.sleep(<span class="number">3</span>);            &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;                <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">RuntimeException</span>(e);            &#125;            <span class="comment">// 修改值，将版本号加1</span>            <span class="type">boolean</span> <span class="variable">flag</span> <span class="operator">=</span> stampedReference.compareAndSet(<span class="number">100</span>, <span class="number">2024</span>, stamp, stampedReference.getStamp() + <span class="number">1</span>);            System.out.println(Thread.currentThread().getName() + <span class="string">&quot;修改：&quot;</span> + flag);            System.out.println(<span class="string">&quot;修改后的值：&quot;</span> + stampedReference.getReference() + <span class="string">&quot;\t版本号：&quot;</span> + stampedReference.getStamp());        &#125;, <span class="string">&quot;t2&quot;</span>).start();    &#125;&#125;</code></pre><p>运行结果</p><pre><code class="highlight shell">t1 默认获取到的值：100默认版本号：1t2 默认获取到的值：100默认版本号：1t1第一次修改：truet1第二次修改：true修改后的值：100版本号：3t2修改：false修改后的值：100版本号：3</code></pre>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;一、没有CAS之前&quot;&gt;&lt;a href=&quot;#一、没有CAS之前&quot; class=&quot;headerlink&quot; title=&quot;一、没有CAS之前&quot;&gt;&lt;/a&gt;一、没有CAS之前&lt;/h1&gt;&lt;ul&gt;
&lt;li&gt;&lt;p&gt;多线程环境不使用原子类保证线程安全（基本数据类型）&lt;/p&gt;
&lt;pr</summary>
      
    
    
    
    <category term="JUC" scheme="https://georgechan95.github.io/categories/JUC/"/>
    
    
    <category term="juc" scheme="https://georgechan95.github.io/tags/juc/"/>
    
    <category term="java" scheme="https://georgechan95.github.io/tags/java/"/>
    
  </entry>
  
  <entry>
    <title>06-JUC进阶-Volatile与Java内存模型</title>
    <link href="https://georgechan95.github.io/blog/546d628d.html"/>
    <id>https://georgechan95.github.io/blog/546d628d.html</id>
    <published>2024-09-25T11:01:01.000Z</published>
    <updated>2024-09-26T11:36:37.257Z</updated>
    
    <content type="html"><![CDATA[<h1 id="一、被Volatile修改的变量有2大特点"><a href="#一、被Volatile修改的变量有2大特点" class="headerlink" title="一、被Volatile修改的变量有2大特点"></a>一、被Volatile修改的变量有2大特点</h1><h2 id="1-特点"><a href="#1-特点" class="headerlink" title="1. 特点"></a>1. 特点</h2><ul><li><p>可见性</p><p>写完后立即刷新回主内存并及时发出通知，其它线程可以去主内存拿到最新的数据，前面的修改对后面所有线程可见</p></li><li><p>有序性</p><p>重排序是指编译器和处理器为了优化程序性能而对指令序列进行重新排序的一种手段，有时候会改变程序语句的先后顺序，若不存在数据依赖关系，可以重排序；存在数据依赖关系，禁止重排序；但重排后的指令绝对不能改变原有的串行语义！这点在并发设计中必须要重点考虑！</p></li></ul><p><strong>注意：volatile 修饰的字段，没有原子性</strong></p><h2 id="2-volatile的内存语义"><a href="#2-volatile的内存语义" class="headerlink" title="2. volatile的内存语义"></a>2. volatile的内存语义</h2><ul><li>当写一个volatile变量时，JMM会把该线程对应的本地内存中的共享变量值立即刷新回主内存中</li><li>当读一个volatile变量时，JMM会把该线程对应的本地内存设置为无效，重新回到主内存中读取最新共享变量的值</li><li>所以volatile的写内存语义是直接刷新到主内存中，读的内存语义是直接从主内存中读取</li></ul><p><strong>volatile凭什么可以保证可见性和有序性？</strong></p><p>  内存屏障Memory Barrier</p><h1 id="二、内存屏障"><a href="#二、内存屏障" class="headerlink" title="二、内存屏障"></a>二、内存屏障</h1><h2 id="1-什么是内存屏障"><a href="#1-什么是内存屏障" class="headerlink" title="1. 什么是内存屏障"></a>1. 什么是内存屏障</h2><p>内存屏障（也称内存栅栏，内存栅障，屏障指令等，是一类同步屏障指令，是CPU或编译器在对内存随机访问的操作中的一个同步点，使得此点之前的所有读写操作都执行后才可以开始执行此点之后的操作），避免代码重排序。内存屏障其实就是一种JVM指令，Java内存模型的重排规则会要求Java编译器在生成JVM指令时插入特定的内存屏障指令，通过这些内存屏障指令，volatile实现了Java内存模型中的可见性和有序性，但volatile无法保证原子性。</p><p>内存屏障之前的所有写操作都要回写到主内存，<br>内存屏障之后的所有读操作都能获得内存屏障之前的所有写操作的最新结果(实现了可见性)。</p><p><img src="https://raw.githubusercontent.com/GeorgeChan95/blogimg/master/img/2024/09/25/20240925-191447.png" alt="内存屏障"></p><p>因此重排序时，不允许把内存屏障之后的指令重排序到内存屏障之前。</p><p>一句话：<strong>对一个 volatile 域的写, happens-before 于任意后续对这个 volatile 域的读，也叫写后读。</strong></p><h2 id="2-内存屏障分类"><a href="#2-内存屏障分类" class="headerlink" title="2. 内存屏障分类"></a>2. 内存屏障分类</h2><h3 id="2-1-分类解析"><a href="#2-1-分类解析" class="headerlink" title="2.1 分类解析"></a>2.1 分类解析</h3><p><strong>内存屏障粗分为两种</strong></p><ul><li>读屏障（Load Barrier）：在读指令之前插入读屏障，让工作内存或CPU高速缓存 当中的缓存数据失效，重新回到主内存中获取最新数据。</li><li>写屏障（Store Barrier）：在写指令之后插入写屏障，强制把缓冲区的数据刷回到主内存中。</li></ul><p><strong>内存屏障细分四种：</strong></p><table><thead><tr><th><strong>屏障类型</strong></th><th><strong>指令示例</strong></th><th><strong>说明</strong></th></tr></thead><tbody><tr><td>LoadLoad</td><td>Load1;LoadLoad;Load2</td><td>保证Load1的读取操作在Load2及后续读取操作之前执行</td></tr><tr><td>StoreStore</td><td>Store1;StoreStore;Store2</td><td>在store2及其后的写操作执行前，保证Store1的写操作已经刷新到主内存</td></tr><tr><td>LoadStore</td><td>Load1;LoadStore;Store2</td><td>在Store2及其后的写操作执行前，保证Load1的读操作已经结束</td></tr><tr><td>StoreLoad</td><td>Store1;StoreLoad;Load2</td><td>保证Store1的写操作已经刷新到主内存后，Load2及其后的读操作才能执行</td></tr></tbody></table><h3 id="2-2-源码分析"><a href="#2-2-源码分析" class="headerlink" title="2.2 源码分析"></a>2.2 源码分析</h3><p>IDEA工具里面找 <code>Unsafe.class</code> –&gt; <code>Unsafe.java</code> –&gt; <code>Unsafe.cpp</code> –&gt; <code>OrderAccess.hpp</code> –&gt; <code>orderAccess_linux_x86.inline.hpp</code></p><ul><li>Unsafe.class</li></ul><p><img src="https://raw.githubusercontent.com/GeorgeChan95/blogimg/master/img/2024/09/25/20240925-193844.png" alt="Unsafe.class"></p><ul><li>Unsafe.java</li></ul><p><img src="https://raw.githubusercontent.com/GeorgeChan95/blogimg/master/img/2024/09/25/20240925-193745.png" alt="Unsafe.java"></p><ul><li>Unsafe.cpp</li></ul><p><img src="https://raw.githubusercontent.com/GeorgeChan95/blogimg/master/img/2024/09/25/20240925-194019.png" alt="Unsafe.cpp"></p><ul><li>OrderAccess.hpp</li></ul><p><img src="https://raw.githubusercontent.com/GeorgeChan95/blogimg/master/img/2024/09/25/20240925-194034.png" alt="OrderAccess.hpp"></p><ul><li>orderAccess_linux_x86.inline.hpp</li></ul><p><img src="https://raw.githubusercontent.com/GeorgeChan95/blogimg/master/img/2024/09/25/20240925-194058.png" alt="orderAccess_linux_x86.inline.hpp"></p><h2 id="3-volatile-变量规则与插入策略"><a href="#3-volatile-变量规则与插入策略" class="headerlink" title="3. volatile 变量规则与插入策略"></a>3. volatile 变量规则与插入策略</h2><h3 id="3-1-如何保证有序性？"><a href="#3-1-如何保证有序性？" class="headerlink" title="3.1 如何保证有序性？"></a>3.1 如何保证有序性？</h3><p><strong>通过内存屏障禁重排</strong></p><ul><li>重排序有可能影响程序的执行和实现，因此，我们有时候希望JVM不要自动重排序。</li><li>对于编译器的重排序，JMM会根据重排序的规则，禁止特定类型的编译器重排序</li><li>对于处理器的重排序，Java编译器在生成指令序列的适当位置，插入内存屏障指令，来禁止特定类型的处理器排序。</li></ul><h3 id="3-2-happens-before-之-volatile-变量规则"><a href="#3-2-happens-before-之-volatile-变量规则" class="headerlink" title="3.2 happens-before 之 volatile 变量规则"></a>3.2 happens-before 之 volatile 变量规则</h3><p><img src="https://raw.githubusercontent.com/GeorgeChan95/blogimg/master/img/2024/09/25/20240925-192602.png" alt="volatile变量规则"></p><ul><li>当第一个操作为volatile读时，不论第二个操作是什么，都不能重排序。这个操作保证了volatile读之后的操作不会被重排到volatile读之前。</li><li>当第二个操作为volatile写时，不论第一个操作是什么，都不能重排序。这个操作保证了volatile写之前的操作不会被重排到volatile写之后。</li><li>当第一个操作为volatile写时，第二个操作为volatile读时，不能重排。</li></ul><h3 id="3-3-内存屏障插⼊策略"><a href="#3-3-内存屏障插⼊策略" class="headerlink" title="3.3 内存屏障插⼊策略"></a>3.3 内存屏障插⼊策略</h3><p>JMM 就将内存屏障插⼊策略分为 4 种</p><p><strong>读屏障</strong></p><ul><li><p>在每个 volatile 读操作的后⾯插⼊⼀个 LoadLoad 屏障</p><p>LoadLoad屏障用来禁止处理器把上面的volatile读与下面的普通读重排序。</p></li><li><p>在每个 volatile 读操作的后⾯插⼊⼀个 LoadStore 屏障</p><p>LoadStore屏障用来禁止处理器把上面的volatile读与下面的普通写重排序。</p><p><img src="https://raw.githubusercontent.com/GeorgeChan95/blogimg/master/img/2024/09/25/20240925-195529.png" alt="读屏障"></p></li></ul><p><strong>写屏障</strong></p><ul><li><p>在每个 volatile 写操作的前⾯插⼊⼀个 StoreStore 屏障</p><p>StoreStore屏障可以保证在volatile写之前，其前面的所有普通写操作都已经刷新到主内存中。</p></li><li><p>在每个 volatile 写操作的后⾯插⼊⼀个 StoreLoad 屏障</p><p>StoreLoad屏障的作用是避免volatile写与后面可能有的volatile读&#x2F;写操作重排序</p><p><img src="https://raw.githubusercontent.com/GeorgeChan95/blogimg/master/img/2024/09/25/20240925-195658.png" alt="写屏障"></p></li></ul><h1 id="三、volatile特性"><a href="#三、volatile特性" class="headerlink" title="三、volatile特性"></a>三、volatile特性</h1><h2 id="1-保证可见性"><a href="#1-保证可见性" class="headerlink" title="1. 保证可见性"></a>1. 保证可见性</h2><p>保证不同线程对某个变量完成操作后结果及时可见，即该共享变量一旦改变所有线程立即可见</p><h3 id="1-1-代码示例："><a href="#1-1-代码示例：" class="headerlink" title="1.1 代码示例："></a>1.1 代码示例：</h3><pre><code class="highlight java"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">VolatileSeeDemo</span> &#123;<span class="comment">//    static boolean flag = true;       //不加volatile，没有可见性</span>    <span class="keyword">static</span> <span class="keyword">volatile</span> <span class="type">boolean</span> <span class="variable">flag</span> <span class="operator">=</span> <span class="literal">true</span>;       <span class="comment">//加了volatile，保证可见性</span>    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;        <span class="keyword">new</span> <span class="title class_">Thread</span>(() -&gt; &#123;            System.out.println(Thread.currentThread().getName() + <span class="string">&quot;\t&quot;</span> + <span class="string">&quot;---come in&quot;</span>);            <span class="keyword">while</span> (flag) &#123;                <span class="keyword">new</span> <span class="title class_">Integer</span>(<span class="number">308</span>);            &#125;            System.out.println(<span class="string">&quot;t1 over&quot;</span>);        &#125;, <span class="string">&quot;t1&quot;</span>).start();        <span class="keyword">try</span> &#123;            TimeUnit.SECONDS.sleep(<span class="number">1</span>);        &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;            e.printStackTrace();        &#125;        <span class="keyword">new</span> <span class="title class_">Thread</span>(() -&gt; &#123;            flag = <span class="literal">false</span>;        &#125;, <span class="string">&quot;t2&quot;</span>).start();    &#125;&#125;</code></pre><ul><li>不加volatile，没有可见性，程序无法停止</li><li>加了volatile，保证可见性，程序可以停止</li></ul><h3 id="1-2-原理解析"><a href="#1-2-原理解析" class="headerlink" title="1.2 原理解析"></a>1.2 原理解析</h3><p><strong>线程t1中为何看不到被主线程main修改为false的flag的值？</strong></p><p>猜测：</p><ol><li>主线程修改了flag之后没有将其刷新到主内存，所以t1线程看不到。</li><li>主线程将flag刷新到了主内存，但是t1一直读取的是自己工作内存中flag的值，没有去主内存中更新获取flag最新的值。</li></ol><p>诉求：</p><ol><li>线程中修改了工作内存中的副本之后，立即将其刷新到主内存</li><li>工作内存中每次读取共享变量时，都去主内存中重新读取，然后拷贝到工作内存</li></ol><p>使用 <code>volatile</code> 修饰共享变量，就可以达到上面的效果，被 <code>volatile</code> 修改的变量有以下特点：</p><ul><li>线程中读取的时候，每次读取都会去主内存中读取共享变量最新的值，然后将其复制到工作内存</li><li>线程中修改了工作内存中变量的副本，修改之后会立即刷新到主内存</li></ul><h3 id="1-3-volatile变量的读写过程"><a href="#1-3-volatile变量的读写过程" class="headerlink" title="1.3 volatile变量的读写过程"></a>1.3 volatile变量的读写过程</h3><p>Java内存模型中定义的8种工作内存与主内存之间的原子操作</p><p>read(读取)→load(加载)→use(使用)→assign(赋值)→store(存储)→write(写入)→lock(锁定)→unlock(解锁)</p><p><img src="https://raw.githubusercontent.com/GeorgeChan95/blogimg/master/img/2024/09/25/20240925-202607.png" alt="image-20240925202607271"></p><ul><li><p>read: 作用于主内存，将变量的值从主内存传输到工作内存，主内存到工作内存</p></li><li><p>load: 作用于工作内存，将read从主内存传输的变量值放入工作内存变量副本中，即数据加载</p></li><li><p>use: 作用于工作内存，将工作内存变量副本的值传递给执行引擎，每当JVM遇到需要该变量的字节码指令时会执行该操作</p></li><li><p>assign: 作用于工作内存，将从执行引擎接收到的值赋值给工作内存变量，每当JVM遇到一个给变量赋值字节码指令时会执行该操作</p></li><li><p>store: 作用于工作内存，将赋值完毕的工作变量的值写回给主内存</p></li><li><p>write: 作用于主内存，将store传输过来的变量值赋值给主内存中的变量</p><p>由于上述只能保证单条指令的原子性，针对多条指令的组合性原子保证，没有大面积加锁，所以，JVM提供了另外两个原子指令：</p></li><li><p>lock: 作用于主内存，将一个变量标记为一个线程独占的状态，只是写时候加锁，就只是锁了写变量的过程。</p></li><li><p>unlock: 作用于主内存，把一个处于锁定状态的变量释放，然后才能被其他线程占用</p></li></ul><h2 id="2-没有原子性"><a href="#2-没有原子性" class="headerlink" title="2. 没有原子性"></a>2. 没有原子性</h2><p>volatile变量的符合操作不具有原子性</p><ul><li><p>对于voaltile变量具备可见性，<strong>JVM只是保证从主内存加载到线程工作内存的值是最新的</strong>，也仅仅是数据加载时是最新的。但是多线程环境下，“数据计算”和“数据赋值”操作可能多次出现，若数据在加载之后，若主内存volatile修饰变量发生修改之后，线程工作内存的操作将会<strong>作废</strong>去读主内存最新值，<strong>操作出现写丢失问题</strong>。<strong>即各线程私有内存和主内存公共内存中变量不同步</strong>，进而导致数据不一致。由此可见volatile解决的是变量读时的可见性问题，但<strong>无法保证原子性，对于多线程修改主内存共享变量的场景必须加锁同步</strong>。</p><p><img src="https://raw.githubusercontent.com/GeorgeChan95/blogimg/master/img/2024/09/26/20240926-103838.png" alt="image-20240926103741047"></p></li><li><p>至于怎么去理解这个写丢失的问题，就是再将数据读取到本地内存到写回主内存中有三个步骤：数据加载—-&gt;数据计算—-&gt;数据赋值，如果第二个线程在第一个线程读取旧值与写回新值期间读取共享变量的值，那么第二个线程将会与第一个线程一起看到同一个值，并执行自己的操作，<strong>一旦其中一个线程对volatile修饰的变量先行完成操作刷回主内存后，另一个线程会作废自己的操作，然后重新去读取最新的值再进行操作，这样的话，它自身的那一次操作就丢失了</strong>，这就造成了 线程安全失败，因此，这个问题<strong>需要使用synchronized修饰以保证线程安全性</strong>。</p></li></ul><p><strong>读取赋值一个volatile变量的情况</strong></p><p><img src="https://raw.githubusercontent.com/GeorgeChan95/blogimg/master/img/2024/09/26/20240926-104126.png" alt="读取赋值一个volatile变量"></p><p>read-load-use 和 assign-store-write 成为了两个不可分割的原子操作，但是在use和assign之间依然有极小的一段真空期，有可能变量会被其他线程读取，导致写丢失一次。无论在哪一个时间点主内存的变量和任一工作内存的变量的值都是相等的。这个特性就导致了volatile变量不适合参与到依赖当前值的运算，如i &#x3D; i + 1; i++;之类的那么依靠可见性的特点volatile可以用在哪些地方呢？ 通常volatile用做保存某个状态的boolean值or int值。</p><p><strong>结论：volatile变量不适合参与到依赖当前值的运算</strong>，如i++，i&#x3D;i+1之类的，<strong>通常用来保存某个状态的boolean值或者int值</strong>，也正是由于volatile变量只能保证可见性，在不符合以下规则的运算场景中，我们仍然要通过加锁来保证原子性：</p><ul><li><p>运算结果并不依赖变量的当前值，或者能够确保只有单一的线程修改变量的值</p></li><li><p>变量不需要与其他的状态变量共同参与不变约束</p></li></ul><p><strong>volatile不具备原子性的代码示例</strong></p><pre><code class="highlight java"><span class="keyword">class</span> <span class="title class_">MyNumber1</span> &#123;    <span class="keyword">public</span> <span class="keyword">volatile</span> <span class="type">int</span> <span class="variable">num</span> <span class="operator">=</span> <span class="number">0</span>;    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">addNum</span><span class="params">()</span> &#123;        num++;    &#125;&#125;<span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">VolatileDemo</span> &#123;    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> InterruptedException &#123;        <span class="type">MyNumber1</span> <span class="variable">myNumber1</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">MyNumber1</span>();        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; <span class="number">10</span>; i++) &#123;            <span class="keyword">new</span> <span class="title class_">Thread</span>(() -&gt; &#123;                <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> <span class="number">0</span>; j &lt; <span class="number">1000</span>; j++) &#123;                    myNumber1.addNum();                &#125;            &#125;, <span class="string">&quot;t&quot;</span> + i).start();        &#125;        TimeUnit.SECONDS.sleep(<span class="number">3</span>);        System.out.println(<span class="string">&quot;执行结束，num值为：&quot;</span> + myNumber1.num);    &#125;&#125;</code></pre><p>执行结果：</p><pre><code class="highlight shell">执行结束，num值为：9913</code></pre><p>多次执行，结果都接近10000，但是到不了10000，原因在于上面说的，volatile修饰的变量，在多线程并发修改情况下会出现写丢失。</p><p><strong>解决方式：</strong> 给 addNum() 添加 synchronized</p><pre><code class="highlight java"><span class="keyword">public</span> <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title function_">addNum</span><span class="params">()</span> &#123;    num++;&#125;</code></pre><h2 id="3-指令禁重排"><a href="#3-指令禁重排" class="headerlink" title="3. 指令禁重排"></a>3. 指令禁重排</h2><h3 id="3-1-重排序"><a href="#3-1-重排序" class="headerlink" title="3.1 重排序"></a>3.1 重排序</h3><p>重排序是指编译器和处理器为了优化程序性能而对指令序列进行重新排序的一种手段，有时候会改变程序语句的先后顺序</p><ul><li>不存在数据依赖关系，可以重排序；</li><li><strong>存在数据依赖关系，禁止重排序</strong></li></ul><p>但重排后的指令绝对不能改变原有的串行语义！这点在并发设计中必须要重点考虑！</p><h3 id="3-2-重排序的分类和执行流程"><a href="#3-2-重排序的分类和执行流程" class="headerlink" title="3.2 重排序的分类和执行流程"></a>3.2 重排序的分类和执行流程</h3><p><img src="https://raw.githubusercontent.com/GeorgeChan95/blogimg/master/img/2024/09/26/20240926-161621.png" alt="重排序的分类和执行流程"></p><ul><li>编译器优化的重排序：编译器在不改变单线程串行语义的前提下，可以重新调整指令的执行顺序</li><li>指令级并行的重排序：处理器使用指令级并行技术来讲多条指令重叠执行，若不存在数据依赖性，处理器可以改变语句对应机器指令的执行顺序</li><li>内存系统的重排序：由于处理器使用缓存和读&#x2F;写缓冲区，这使得加载和存储操作看上去可能是乱序执行</li></ul><h3 id="3-3-数据依赖性"><a href="#3-3-数据依赖性" class="headerlink" title="3.3 数据依赖性"></a>3.3 数据依赖性</h3><p>若两个操作访问同一变量，且这两个操作中有一个为写操作，此时两操作间就存在数据依赖性。</p><p><strong>案例说明</strong></p><ul><li><p>不存在数据依赖关系，可以重排序</p><table><thead><tr><th>重排前</th><th>重排后</th></tr></thead><tbody><tr><td>int a &#x3D; 1;  &#x2F;&#x2F;1<br/>int b &#x3D; 20; &#x2F;&#x2F;2<br/>int c &#x3D; a + b; &#x2F;&#x2F;3</td><td>int b &#x3D; 20;  &#x2F;&#x2F;1<br/>int a &#x3D; 1; &#x2F;&#x2F;2<br/>int c &#x3D; a + b; &#x2F;&#x2F;3</td></tr><tr><td>结论：编译器调整了语句的顺序，但是不影响程序的最终结果。</td><td><strong>可以重排序</strong></td></tr></tbody></table></li><li><p><strong>存在数据依赖关系，禁止重排序</strong></p><p>重排序发生，会导致程序运行结果不同。编译器和处理器在重排序时，会遵守数据依赖性，不会改变存在依赖关系的两个操作的执行,但不同处理器和不同线程之间的数据性不会被编译器和处理器考虑，其只会作用于单处理器和单线程环境，下面三种情况，只要重排序两个操作的执行顺序，程序的执行结果就会被改变。</p><p><img src="https://raw.githubusercontent.com/GeorgeChan95/blogimg/master/img/2024/09/26/20240926-162829.png" alt="数据依赖"></p></li></ul><h1 id="四、如何正确使用volatile"><a href="#四、如何正确使用volatile" class="headerlink" title="四、如何正确使用volatile"></a>四、如何正确使用volatile</h1><h2 id="1-单一赋值"><a href="#1-单一赋值" class="headerlink" title="1. 单一赋值"></a>1. 单一赋值</h2><p>单一赋值可以，但是含复合运算赋值不可以(i++之类)</p><pre><code class="highlight java"><span class="keyword">volatile</span> <span class="type">int</span> <span class="variable">a</span> <span class="operator">=</span> <span class="number">10</span><span class="keyword">volatile</span> <span class="type">boolean</span> <span class="variable">flag</span> <span class="operator">=</span> <span class="literal">false</span></code></pre><h2 id="2-状态标志"><a href="#2-状态标志" class="headerlink" title="2. 状态标志"></a>2. 状态标志</h2><p>判断业务是否结束</p><pre><code class="highlight java"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">VolatileSeeDemo</span> &#123;<span class="comment">//    static boolean flag = true;       //不加volatile，没有可见性</span>    <span class="keyword">static</span> <span class="keyword">volatile</span> <span class="type">boolean</span> <span class="variable">flag</span> <span class="operator">=</span> <span class="literal">true</span>;       <span class="comment">//加了volatile，保证可见性</span>    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;        <span class="keyword">new</span> <span class="title class_">Thread</span>(() -&gt; &#123;            System.out.println(Thread.currentThread().getName() + <span class="string">&quot;\t&quot;</span> + <span class="string">&quot;---come in&quot;</span>);            <span class="keyword">while</span> (flag) &#123;                <span class="keyword">new</span> <span class="title class_">Integer</span>(<span class="number">308</span>);            &#125;            System.out.println(<span class="string">&quot;t1 over&quot;</span>);        &#125;, <span class="string">&quot;t1&quot;</span>).start();        <span class="keyword">try</span> &#123;            TimeUnit.SECONDS.sleep(<span class="number">1</span>);        &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;            e.printStackTrace();        &#125;        <span class="keyword">new</span> <span class="title class_">Thread</span>(() -&gt; &#123;            flag = <span class="literal">false</span>;        &#125;, <span class="string">&quot;t2&quot;</span>).start();    &#125;&#125;</code></pre><h2 id="3-开销较低的读，写锁策略"><a href="#3-开销较低的读，写锁策略" class="headerlink" title="3. 开销较低的读，写锁策略"></a>3. 开销较低的读，写锁策略</h2><pre><code class="highlight java"><span class="keyword">class</span> <span class="title class_">MyNumber1</span> &#123;    <span class="keyword">public</span> <span class="keyword">volatile</span> <span class="type">int</span> <span class="variable">num</span> <span class="operator">=</span> <span class="number">0</span>;    <span class="keyword">public</span> <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title function_">addNum</span><span class="params">()</span> &#123;        num++;    &#125;&#125;<span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">VolatileDemo</span> &#123;    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> InterruptedException &#123;        <span class="type">MyNumber1</span> <span class="variable">myNumber1</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">MyNumber1</span>();        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; <span class="number">10</span>; i++) &#123;            <span class="keyword">new</span> <span class="title class_">Thread</span>(() -&gt; &#123;                <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> <span class="number">0</span>; j &lt; <span class="number">1000</span>; j++) &#123;                    myNumber1.addNum();                &#125;            &#125;, <span class="string">&quot;t&quot;</span> + i).start();        &#125;        TimeUnit.SECONDS.sleep(<span class="number">3</span>);        System.out.println(<span class="string">&quot;执行结束，num值为：&quot;</span> + myNumber1.num);    &#125;&#125;</code></pre><h2 id="4-DCL双端锁的发布"><a href="#4-DCL双端锁的发布" class="headerlink" title="4. DCL双端锁的发布"></a>4. DCL双端锁的发布</h2><h3 id="4-1-问题代码示例"><a href="#4-1-问题代码示例" class="headerlink" title="4.1 问题代码示例"></a>4.1 问题代码示例</h3><pre><code class="highlight java"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">SafeDoubleCheckSingleton</span> &#123;    <span class="comment">// 加 volatile 保证了对象的可见性</span>    <span class="comment">//    private volatile static SafeDoubleCheckSingleton singleton = null;</span>    <span class="comment">// 不加 volatile 在多线程环境下可能导致获取到的对象是null</span>    <span class="keyword">private</span> <span class="keyword">static</span> <span class="type">SafeDoubleCheckSingleton</span> <span class="variable">singleton</span> <span class="operator">=</span> <span class="literal">null</span>;    <span class="comment">//私有化构造方法</span>    <span class="keyword">private</span> <span class="title function_">SafeDoubleCheckSingleton</span><span class="params">()</span> &#123;    &#125;    <span class="comment">//双重锁设计</span>    <span class="keyword">public</span> <span class="keyword">static</span> SafeDoubleCheckSingleton <span class="title function_">getInstance</span><span class="params">()</span> &#123;        <span class="keyword">if</span> (singleton == <span class="literal">null</span>) &#123;            <span class="comment">//1.多线程并发创建对象时，会通过加锁保证只有一个线程能创建对象</span>            <span class="keyword">synchronized</span> (SafeDoubleCheckSingleton.class) &#123;                <span class="keyword">if</span> (singleton == <span class="literal">null</span>) &#123;                    <span class="comment">//隐患：多线程环境下，由于重排序，该对象可能还未完成初始化就被其他线程读取</span>                    singleton = <span class="keyword">new</span> <span class="title class_">SafeDoubleCheckSingleton</span>();                &#125;            &#125;        &#125;        <span class="comment">//2.对象创建完毕，执行getInstance()将不需要获取锁，直接返回创建对象</span>        <span class="keyword">return</span> singleton;    &#125;    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;        <span class="type">SafeDoubleCheckSingleton</span> <span class="variable">instance</span> <span class="operator">=</span> SafeDoubleCheckSingleton.getInstance();    &#125;&#125;</code></pre><h3 id="4-2-问题如下"><a href="#4-2-问题如下" class="headerlink" title="4.2 问题如下"></a>4.2 问题如下</h3><ul><li><p>单线程环境下：(或者说正常情况下)，在”问题代码处”，会执行如下操作，保证能获取到已完成初始化的实例</p><p><img src="https://raw.githubusercontent.com/GeorgeChan95/blogimg/master/img/2024/09/26/20240926-172219.png" alt="单线程环境下指令执行逻辑"></p><p>由于代码从编译到执行的过程中，可能会出现指令重排，2、3 两处的指令执行顺序可能会颠倒，这就有可能导致返回的对象，还未执行初始化。</p></li><li><p>多线程环境下：在”问题代码处”，会执行如下操作，由于重排序导致2,3乱序，后果就是其他线程得到的是null而不是完成初始化的对象</p><p>正确的执行顺序</p><p><img src="https://raw.githubusercontent.com/GeorgeChan95/blogimg/master/img/2024/09/26/20240926-172545.png" alt="指令顺序-正确"></p><p>异常的执行顺序</p><p><img src="https://raw.githubusercontent.com/GeorgeChan95/blogimg/master/img/2024/09/26/20240926-172531.png" alt="指令顺序-异常"></p></li></ul><h3 id="4-3-问题解决"><a href="#4-3-问题解决" class="headerlink" title="4.3 问题解决"></a>4.3 问题解决</h3><h4 id="4-3-1-方式一：加volatile修饰"><a href="#4-3-1-方式一：加volatile修饰" class="headerlink" title="4.3.1 方式一：加volatile修饰"></a>4.3.1 方式一：加volatile修饰</h4><p><strong>原理:利用volatile，禁止 “初始化对象”(2) 和 “设置singleton指向内存空间”(3) 的重排序</strong></p><pre><code class="highlight java"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">SafeDoubleCheckSingleton</span> &#123;    <span class="comment">// 加 volatile 保证了对象的可见性，实现线程安全的延迟初始化。</span>    <span class="keyword">private</span> <span class="keyword">volatile</span> <span class="keyword">static</span> <span class="type">SafeDoubleCheckSingleton</span> <span class="variable">singleton</span> <span class="operator">=</span> <span class="literal">null</span>;    <span class="comment">//私有化构造方法</span>    <span class="keyword">private</span> <span class="title function_">SafeDoubleCheckSingleton</span><span class="params">()</span> &#123;    &#125;    <span class="comment">//双重锁设计</span>    <span class="keyword">public</span> <span class="keyword">static</span> SafeDoubleCheckSingleton <span class="title function_">getInstance</span><span class="params">()</span> &#123;        <span class="keyword">if</span> (singleton == <span class="literal">null</span>) &#123;            <span class="comment">//1.多线程并发创建对象时，会通过加锁保证只有一个线程能创建对象</span>            <span class="keyword">synchronized</span> (SafeDoubleCheckSingleton.class) &#123;                <span class="keyword">if</span> (singleton == <span class="literal">null</span>) &#123;                    <span class="comment">//隐患：多线程环境下，由于重排序，该对象可能还未完成初始化就被其他线程读取</span>                    singleton = <span class="keyword">new</span> <span class="title class_">SafeDoubleCheckSingleton</span>();                &#125;            &#125;        &#125;        <span class="comment">//2.对象创建完毕，执行getInstance()将不需要获取锁，直接返回创建对象</span>        <span class="keyword">return</span> singleton;    &#125;    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;        <span class="type">SafeDoubleCheckSingleton</span> <span class="variable">instance</span> <span class="operator">=</span> SafeDoubleCheckSingleton.getInstance();    &#125;&#125;</code></pre><h4 id="4-3-2-方式二：采用静态内部类的方式实现"><a href="#4-3-2-方式二：采用静态内部类的方式实现" class="headerlink" title="4.3.2 方式二：采用静态内部类的方式实现"></a>4.3.2 方式二：采用静态内部类的方式实现</h4><pre><code class="highlight java"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">SingletonDemo</span> &#123;    <span class="keyword">private</span> <span class="title function_">SingletonDemo</span><span class="params">()</span> &#123;    &#125;    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">class</span> <span class="title class_">SingletonDemoHandler</span> &#123;        <span class="keyword">private</span> <span class="keyword">static</span> <span class="type">SingletonDemo</span> <span class="variable">instance</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">SingletonDemo</span>();    &#125;    <span class="keyword">public</span> <span class="keyword">static</span> SingletonDemo <span class="title function_">getInstance</span><span class="params">()</span> &#123;        <span class="keyword">return</span> SingletonDemoHandler.instance;    &#125;&#125;</code></pre><h1 id="五、总结"><a href="#五、总结" class="headerlink" title="五、总结"></a>五、总结</h1><p>凭什么我们java写了一个volatile关键字系统底层加入内存屏障？两者关系怎么勾搭上的?</p><ul><li><p>字节码层面</p><p>它其实给 volatile 修饰的字段添加了一个 <code>ACC_VOLATILE</code> 标识</p><p>查看命令：<code>javap -v -p SafeDoubleCheckSingleton.class</code></p><p><img src="https://raw.githubusercontent.com/GeorgeChan95/blogimg/master/img/2024/09/26/20240926-180150.png" alt="image-20240926180150159"></p></li></ul><p>JVM 在把字节码 生成 为 机器码 的时候，发现操作是 volatile 的变量的话，就会根据 JMM 要求，在相应的位置去插入 内存屏障指令</p><p><strong>对比 java.util.concurrent.locks.Lock 来理解</strong></p><p>cpu执行机器码指令的时候，是使用lock前缀指令 来实现 volatile 的功能的。</p><p>Lock 指令，相当于内存屏障，功能也类似内存屏障的功能:</p><ul><li>首先对总线&#x2F;缓存加锁，然后去执行后面的指令，最后，释放锁，同时把高速缓存的数据刷新回到主内存</li><li>在 lock 锁住总线&#x2F;缓存的时候，其它 cpu 的读写请求就会被阻塞，直到锁释放。Lock过后的写操作,会让其它cpu的高速缓存中相应的数据失效这样后续这些 cpu 在读取数据的时候，就会从主内存去加载最新的数据</li></ul><p>加了 Lock 指令过后的具体表现，就跟 JMM 添加内存屏障后一样。</p><p><strong>一句话总结</strong></p><ul><li>volatile写之前的的操作，都禁止重排到volatile之后</li><li>volatile读之后的操作，都禁止重排到volatile之前</li><li>volatile写之后volatile读，禁止重排序</li></ul>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;一、被Volatile修改的变量有2大特点&quot;&gt;&lt;a href=&quot;#一、被Volatile修改的变量有2大特点&quot; class=&quot;headerlink&quot; title=&quot;一、被Volatile修改的变量有2大特点&quot;&gt;&lt;/a&gt;一、被Volatile修改的变量有2大特点&lt;/</summary>
      
    
    
    
    <category term="JUC" scheme="https://georgechan95.github.io/categories/JUC/"/>
    
    
    <category term="juc" scheme="https://georgechan95.github.io/tags/juc/"/>
    
    <category term="java" scheme="https://georgechan95.github.io/tags/java/"/>
    
  </entry>
  
  <entry>
    <title>05-JUC进阶-Java内存模型-JMM</title>
    <link href="https://georgechan95.github.io/blog/1f2e0014.html"/>
    <id>https://georgechan95.github.io/blog/1f2e0014.html</id>
    <published>2024-09-23T15:01:07.000Z</published>
    <updated>2024-09-25T05:09:23.536Z</updated>
    
    <content type="html"><![CDATA[<h1 id="一、计算机硬件存储体系"><a href="#一、计算机硬件存储体系" class="headerlink" title="一、计算机硬件存储体系"></a>一、计算机硬件存储体系</h1><p> 计算机存储结构，从本地磁盘 到 主内存 到 CPU缓存，也就是从硬盘 -&gt; 内存 -&gt; CPU。</p><p>一般对应的程序的操作就是从数据库查数据到内存然后到CPU进行计算</p><p><img src="https://raw.githubusercontent.com/GeorgeChan95/blogimg/master/img/2024/09/23/20240923-162409.png" alt="计算机硬件存储体系"></p><p>由于CPU和物理主内存的速度不一致（CPU速度远快于主内存），因此CPU和主内存之间需要多级缓存。</p><p>CPU的运行并不是直接操作内存而是先把内存里边的数据读到缓存，而内存的读和写操作的时候就会造成不一致的问题。</p><p><img src="https://raw.githubusercontent.com/GeorgeChan95/blogimg/master/img/2024/09/23/20240923-162728.png" alt="CPU-缓存-内存"></p><p>Java虚拟机规范中试图定义一种Java内存模型（java Memory Model，简称JMM) 来屏蔽掉各种硬件和操作系统的内存访问差异，以实现让Java程序在各种平台下都能达到一致的内存访问效果。</p><h1 id="二、Java内存模型-JMM"><a href="#二、Java内存模型-JMM" class="headerlink" title="二、Java内存模型-JMM"></a>二、Java内存模型-JMM</h1><h2 id="1-JMM概述"><a href="#1-JMM概述" class="headerlink" title="1. JMM概述"></a>1. JMM概述</h2><p>JMM(Java内存模型Java Memory Model，简称JMM)本身是一种抽象的概念并不真实存在<strong>它仅仅描述的是一组约定或规范</strong>，通过这组规范定义了程序中(尤其是多线程)各个变量的读写访问方式并决定一个线程对共享变量的写入何时以及如何变成对另一个线程可见，<strong>关键技术点都是围绕多线程的原子性、可见性和有序性展开的</strong>。</p><h2 id="2-JMM的作用"><a href="#2-JMM的作用" class="headerlink" title="2. JMM的作用"></a>2. JMM的作用</h2><ul><li>通过JMM来实现线程和主内存之间的抽象关系</li><li>屏蔽各个硬件平台和操作系统的内存访问差异以实现让Java程序在各种平台下都能达到一致的内存访问效果。</li></ul><h2 id="3-JMM规范下，三大特性"><a href="#3-JMM规范下，三大特性" class="headerlink" title="3. JMM规范下，三大特性"></a>3. JMM规范下，三大特性</h2><ul><li><p>可见性</p></li><li><p>原子性</p></li><li><p>有序性</p></li></ul><h3 id="3-1-可见性"><a href="#3-1-可见性" class="headerlink" title="3.1 可见性"></a>3.1 可见性</h3><p>是指当一个线程修改了某一个共享变量的值，其他线程是否能够立即知道该变更 ，JMM规定了所有的变量都存储在主内存中。</p><p><img src="https://raw.githubusercontent.com/GeorgeChan95/blogimg/master/img/2024/09/23/20240923-165016.png" alt="CPU-缓存-主存"></p><p><img src="https://raw.githubusercontent.com/GeorgeChan95/blogimg/master/img/2024/09/23/20240923-165023.png" alt="多线程修改同一个变量"></p><p><strong>Java中普通的共享变量不保证可见性</strong>，因为数据修改被写入内存的时机是不确定的，多线程并发下很可能出现**”脏读”<strong>，所以每个线程都有自己的</strong>工作内存<strong>，线程自己的工作内存中保存了该线程使用到的变量的</strong>主内存副本拷贝**，线程对变量的所有操作（读取，赋值等 ）都必需在线程自己的工作内存中进行，而不能够直接读写主内存中的变量。不同线程之间也无法直接访问对方工作内存中的变量，线程间变量值的传递均需要通过主内存来完成</p><p><img src="https://raw.githubusercontent.com/GeorgeChan95/blogimg/master/img/2024/09/23/20240923-164824.png" alt="线程-主存-工作内存的关系"></p><p> <strong>线程脏读：如果没有可见性保证</strong></p><ul><li>主内存中有变量 x，初始值为 0</li><li>线程 A 要将 x 加 1，先将 x&#x3D;0 拷贝到自己的私有内存中，然后更新 x 的值</li><li>线程 A 将更新后的 x 值回刷到主内存的时间是不固定的</li><li>刚好在线程 A 没有回刷 x 到主内存时，线程 B 同样从主内存中读取 x，此时为 0，和线程 A 一样的操作，最后期盼的 x&#x3D;2 就会变成 x&#x3D;1</li></ul><p><img src="https://raw.githubusercontent.com/GeorgeChan95/blogimg/master/img/2024/09/23/20240923-170757.png" alt="线程脏读"></p><h3 id="3-2-原子性"><a href="#3-2-原子性" class="headerlink" title="3.2 原子性"></a>3.2 原子性</h3><p>指一个操作是不可被打断的，即多线程环境下，操作不能被其他线程干扰</p><h3 id="3-3-有序性"><a href="#3-3-有序性" class="headerlink" title="3.3. 有序性"></a>3.3. 有序性</h3><p>对于一个线程的执行代码而言，我们总是习惯性地认为代码的执行总是从上到下，有序执行。但为了提升性能，编译器和处理器通常会对指令序列进行重新排序。Java规范规定JVM线程内部维持顺序化语义，即只要程序的最终结果与它顺序化执行的结果相等，那么指令的执行顺序可以与代码顺序不一致，此过程叫指令的重排序。</p><p>  <strong>优缺点：</strong></p><ul><li>JVM能根据处理器特性（CPU多级缓存系统、多核处理器等）适当的对机器指令进行重排序，使机器指令更符合CPU的执行特性，最大限度的发挥机器性能</li><li>​    但是指令重排可以保证串行语义一致，<strong>但没有义务保证多线程的语义也一致（即可能产生“脏读”）</strong>，简单而言就是两行以上不相干的代码在执行的时候有可能先执行的不是第一条，不见得是从上到下顺序执行，执行顺序会被优化。</li></ul><p>从源码到最终执行示例图</p><p><img src="https://raw.githubusercontent.com/GeorgeChan95/blogimg/master/img/2024/09/23/20240923-171944.png" alt="原码编译到执行"></p><ul><li><p>单线程环境里面确保程序最终执行结果和代码顺序执行的结果一致。处理器在进行重排序时必须要考虑指令之间的数据依赖性。</p></li><li><p>多线程环境中线程交替执行,由于编译器优化重排的存在，两个线程中使用的变量能否保证一致性是无法确定的,结果无法预测</p></li></ul><h1 id="三、JMM规范下，多线程对变量的读写过程"><a href="#三、JMM规范下，多线程对变量的读写过程" class="headerlink" title="三、JMM规范下，多线程对变量的读写过程"></a>三、JMM规范下，多线程对变量的读写过程</h1><p><strong>读取过程</strong></p><p>由于JVM运行程序的实体是线程，而每个线程创建时JVM都会为其创建一个工作内存(有些地方称为栈空间)，工作内存是每个线程的私有数据区域，而Java内存模型中规定所有变量都存储在<strong>主内存</strong>，主内存是共享内存区域，所有线程都可以访问，但<strong>线程对变量的操作(读取赋值等)必须在工作内存中进行，首先要将变量从主内存拷贝到的线程自己的工作内存空间，然后对变量进行操作，操作完成后再将变量写回主内存</strong>，不能直接操作主内存中的变量，各个线程中的工作内存中存储着主内存中的变量副本拷贝，因此不同的线程间无法访问对方的工作内存，线程间的通信(传值)必须通过主内存来完成，其简要访问过程如下图:</p><p><img src="https://raw.githubusercontent.com/GeorgeChan95/blogimg/master/img/2024/09/23/20240923-172630.png" alt="多线程操作主内存变量"></p><p><strong>JMM定义了线程和主内存之间的抽象关系：</strong></p><ul><li>线程之间的共享变量存储在主内存中（从硬件角度讲就是内存条）</li><li>每个线程都有一个自己的本地工作内存，本地工作内存中存储了该线程用来读写共享变量的副本（从硬件角度来说就是CPU的缓存）</li></ul><p><strong>总结</strong></p><ul><li>我们定义的所有共享变量都储存在<strong>物理主内存中</strong></li><li>每个线程都有自己独立的工作内存，里面保证该线程使用到的共享变量的副本（主内存中该变量的一份拷贝）</li><li>线程对共享变量所有的操作都必须先在线程自己的工作内存中进行后写回主内存，不能直接从主内存在读写（不能越级）</li><li>不同线程之间也无法直接访问其他线程的工作内存中的变量，线程间变量值的传递需要通过主内存来进行（同级不能互相访问）。</li></ul><h1 id="四、JMM规范下，多线程先行发生原则之happens-before"><a href="#四、JMM规范下，多线程先行发生原则之happens-before" class="headerlink" title="四、JMM规范下，多线程先行发生原则之happens-before"></a>四、JMM规范下，多线程先行发生原则之happens-before</h1><p>在JVM中，如果一个操作执行的结果需要对另一个操作可见或者代码重排序，那么这两个操作之间必须存在 happens-before（先行发生）原则，逻辑上的先后关系。</p><h2 id="1-x-、y案例说明"><a href="#1-x-、y案例说明" class="headerlink" title="1. x 、y案例说明"></a>1. x 、y案例说明</h2><ul><li>x&#x3D;5;线程A执行</li><li>y&#x3D;x;线程B执行</li><li>问：y一定等于5吗？</li></ul><p><strong>答案：不一定</strong></p><p>如果线程A的操作（x&#x3D; 5）happens-before(先行发生)线程B的操作（y &#x3D; x）,那么可以确定线程B执行后y &#x3D; 5 一定成立;</p><p>如果他们不存在happens-before原则，那么y &#x3D; 5 不一定成立。</p><p><strong>这就是happens-before原则的为例———–&gt;包含可见性和有序性的约束</strong></p><h2 id="2-先行并发原则说明"><a href="#2-先行并发原则说明" class="headerlink" title="2. 先行并发原则说明"></a>2. 先行并发原则说明</h2><p>如果Java内存模型中所有的有序性都仅靠 <code>volatile</code> 和 <code>synchronized</code> 来完成，那么有很多操作都将变得非常罗嗦，但是我们在编写Java并发代码的时候并没有察觉到这一点。</p><p>我们没有时时、处处、次次，添加volatile和synchronized来完成程序，这是因为Java语言中JMM原则下，有一个“先行发生”（happens-before）的原则限制和规矩，给你理好了规矩！</p><p>这个原则非常重要：它是判断数据是否存在竞争，线程是否安全的非常有用的手段。依赖这个原则，我们可以通过几条简单规则解决并发环境下两个操作之间是否可能存在冲突的所有问题，而不需要陷入Java内存模型晦涩难懂的底层编译原理之中。</p><h2 id="3-happens-before总原则"><a href="#3-happens-before总原则" class="headerlink" title="3. happens-before总原则"></a>3. happens-before总原则</h2><ul><li>如果一个操作happens-before另一个操作，那么第一个操作的执行结果将对第二个操作可见，而且第一个操作的执行顺序排在第二个操作之前</li><li>如果两个操作之间存在happens-before关系，并不意味着一定要按照happens-before原则制定的顺序来执行。如果重排之后的执行结果与按照happens-before关系来执行的结果一致，那么这种重排序并不非法。</li></ul><h2 id="4-happens-before之8条规则"><a href="#4-happens-before之8条规则" class="headerlink" title="4. happens-before之8条规则"></a>4. happens-before之8条规则</h2><p>从JDK 5开始，Java使用新的JSR-133内存模型，提供了 happens-before 原则来辅助保证程序执行的原子性、可见性以及有序性的问题，它是判断数据是否存在竞争、线程是否安全的依据，happens-before 原则内容如下：</p><ol><li><p>次序规则：一个线程内，按照代码的顺序，写在前面的操作先行发生于写在后面的操作，也就是说前一个操作的结果可以被后续的操作获取（保证语义串行性，按照代码顺序执行）。比如前一个操作把变量x赋值为1，那后面一个操作肯定能知道x已经变成了1</p></li><li><p>锁定规则：一个 <code>unLock</code> 操作先行发生于后面对同一个锁的<code>lock</code>操作（后面指时间上的先后）</p><p>​解释：A线程的 unlock 操作，先行发生于 B线程的 lock 操作。</p></li><li><p>volatile变量规则：对一个volatile变量的写操作先行发生于后面对这个变量的读操作，前面的写对后面的读是可见的，这里的后面同样指时间上的先后</p></li><li><p>传递规则：如果操作A先行发生于操作B，而操作B又先行发生于操作C，则可以得出操作A先行发生于操作C。</p></li><li><p>线程启动规则（Thread start Rule）：Thread对象的start()方法先行发生于此线程的每一个动作</p></li><li><p>线程中断规则（Thread Interruption Rule）：</p><ol><li>对线程interrupt()方法的调用先行发生于被中断线程的代码检测到中断事件的发生</li><li>可以通过Thread.interrupted()检测到是否发生中断</li><li>也就是说你要先调用interrupt()方法设置过中断标志位，我才能检测到中断发生</li></ol><p>解释：这里其实都是重排序问题，如果没有的此规则就变成了你写的前面设置终止状态，判断结果理应是true，但指令重排序有可能给你改成先判断结果就是false了</p></li><li><p>线程终止规则（Thread Termination Rule）：线程中的所有操作都优先发生于对此线程的终止检测，我们可以通过isAlive()等手段检测线程是否已经终止执行。</p></li><li><p>对象终结规则（Finalizer Rule）：一个对象的初始化完成（构造函数执行结束）先行发生于它的finalize(）方法的开始——-&gt;对象没有完成初始化之前，是不能调用finalized()方法的</p></li></ol><h2 id="5-happens-before-总结"><a href="#5-happens-before-总结" class="headerlink" title="5. happens-before 总结"></a>5. happens-before 总结</h2><ul><li>在Java语言里面，Happens-before 的语义本质上是一种可见性</li><li>A happens-before B ,意味着A发生过的事情对B而言是可见的，无论A事件和B事件是否发生在同一线程里</li><li>JVM的设计分为两部分：<ul><li>一部分是面向我们程序员提供的，也就是happens-before规则，它通俗易懂的向我们程序员阐述了一个强内存模型，我们只要理解happens-before规则，就可以编写并发安全的程序了</li><li>另一部分是针对JVM实现的，为了尽可能少的对编译器和处理器做约束从而提升性能，JMM在不影响程序执行结果的前提下对其不做要求，即允许优化重排序，我们只要关注前者就好了，也就是理解happens-before规则即可，其他繁杂的内容由JMM规范结合操作系统给我们搞定，我们只写好代码即可。</li></ul></li></ul><h2 id="6-案例说明"><a href="#6-案例说明" class="headerlink" title="6. 案例说明"></a>6. 案例说明</h2><pre><code class="highlight java"><span class="keyword">private</span> <span class="type">int</span> <span class="variable">value</span> <span class="operator">=</span><span class="number">0</span>;<span class="keyword">public</span> <span class="type">int</span> <span class="title function_">getValue</span><span class="params">()</span>&#123;    <span class="keyword">return</span> value;&#125;<span class="keyword">public</span> <span class="type">int</span> <span class="title function_">setValue</span><span class="params">()</span>&#123;    <span class="keyword">return</span> ++value;&#125;</code></pre><p>问题描述：假设存在线程A和B，线程A先（时间上的先后）调用了setValue()方法，然后线程B调用了同一个对象的getValue()方法，那么线程B收到的返回值是什么？</p><p><strong>答案：不一定</strong></p><p><strong>分析如下：</strong></p><p>分析happens-before规则（规则5，6，7，8可以忽略，和代码无关）</p><ul><li>由于两个方法由不同线程调用，不满足一个线程的条件，不满足程序次序规则</li><li>两个方法都没有用锁，不满足锁定规则</li><li>变量没有使用volatile修饰，所以不满足volatile变量规则</li><li>传递规则肯定不满足</li></ul><p>综上：无法通过happens-before原则推导出线程A happens-before 线程B，虽然可以确定时间上线程A优于线程B，但就是无法确定线程B获得的结果是什么，所以这段代码不是线程安全的</p><p>注意：如果两个操作的执行次序无法从happens-before原则推导出来，那么就不能保证他们的有序性，虚拟机可以随意对他们进行重排序</p><p><strong>解决方案：</strong></p><ul><li><p>方案一：</p><ul><li><p>把getter&#x2F;setter方法都定义为synchronized方法——-&gt;<strong>不好，重量锁，并发性下降</strong></p><pre><code class="highlight java"><span class="keyword">private</span> <span class="type">int</span> <span class="variable">value</span> <span class="operator">=</span><span class="number">0</span>;<span class="keyword">public</span> <span class="keyword">synchronized</span> <span class="type">int</span> <span class="title function_">getValue</span><span class="params">()</span>&#123;    <span class="keyword">return</span> value;&#125;<span class="keyword">public</span> <span class="keyword">synchronized</span> <span class="type">int</span> <span class="title function_">setValue</span><span class="params">()</span>&#123;    <span class="keyword">return</span> ++value;&#125;</code></pre></li><li><p>把 value 定义为 volatile 变量，由于setter方法对value的修改不依赖value的原值，满足volatile关键字使用场景</p><pre><code class="highlight java"><span class="comment">/**</span><span class="comment">* 利用volatile保证读取操作的可见性，</span><span class="comment">* 利用synchronized保证符合操作的原子性结合使用锁和volatile变量来减少同步的开销</span><span class="comment">*/</span><span class="keyword">private</span> <span class="keyword">volatile</span> <span class="type">int</span> <span class="variable">value</span> <span class="operator">=</span><span class="number">0</span>;<span class="keyword">public</span> <span class="type">int</span> <span class="title function_">getValue</span><span class="params">()</span>&#123;    <span class="keyword">return</span> value;&#125;<span class="keyword">public</span> <span class="keyword">synchronized</span> <span class="type">int</span> <span class="title function_">setValue</span><span class="params">()</span>&#123;    <span class="keyword">return</span> ++value;&#125;</code></pre></li></ul></li></ul>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;一、计算机硬件存储体系&quot;&gt;&lt;a href=&quot;#一、计算机硬件存储体系&quot; class=&quot;headerlink&quot; title=&quot;一、计算机硬件存储体系&quot;&gt;&lt;/a&gt;一、计算机硬件存储体系&lt;/h1&gt;&lt;p&gt; 计算机存储结构，从本地磁盘 到 主内存 到 CPU缓存，也就是从硬</summary>
      
    
    
    
    <category term="JUC" scheme="https://georgechan95.github.io/categories/JUC/"/>
    
    
    <category term="juc" scheme="https://georgechan95.github.io/tags/juc/"/>
    
    <category term="java" scheme="https://georgechan95.github.io/tags/java/"/>
    
  </entry>
  
  <entry>
    <title>04-JUC进阶-LockSupport与线程中断</title>
    <link href="https://georgechan95.github.io/blog/19653fb9.html"/>
    <id>https://georgechan95.github.io/blog/19653fb9.html</id>
    <published>2024-09-23T12:51:50.000Z</published>
    <updated>2024-09-23T08:11:09.507Z</updated>
    
    <content type="html"><![CDATA[<h1 id="一、线程中断机制"><a href="#一、线程中断机制" class="headerlink" title="一、线程中断机制"></a>一、线程中断机制</h1><h2 id="1-什么是中断机制-？"><a href="#1-什么是中断机制-？" class="headerlink" title="1. 什么是中断机制 ？"></a>1. 什么是中断机制 ？</h2><p>首先一个线程不应该由其他线程来强制中断或停止，而是应该由线程自己自行停止。所以，<code>Thread.stop</code> , <code>Thread.suspend</code> , <code>Thread.resume</code> 都已经被废弃了。</p><p>其次在Java中没有办法立即停止一条线程，然而停止线程却显得尤为重要，如取消一个耗时操作。因此，Java提供了一种用于停止线程的机制——中断。</p><p><strong>中断只是一种协作机制，Java没有给中断增加任何语法，中断的过程完全需要程序员自己实现。</strong></p><ul><li>若要中断一个线程，你需要手动调用该线程的interrupt方法，<strong>该方法也仅仅是将线程对象的中断标识设成true</strong>；</li><li>接着你需要自己写代码不断地检测当前线程的标识位，如果为true，表示别的线程要求这条线程中断，</li><li>此时究竟该做什么需要你自己写代码实现。</li><li>每个线程对象中都有一个标识，用于表示线程是否被中断；该标识位为true表示中断，为false表示未中断；</li><li>通过调用线程对象的 <code>interrupt</code> 方法将该线程的标识位设为 true ；可以在别的线程中调用，也可以在自己的线程中调用。</li></ul><h2 id="2-中断的相关API方法"><a href="#2-中断的相关API方法" class="headerlink" title="2. 中断的相关API方法"></a>2. 中断的相关API方法</h2><p><img src="https://raw.githubusercontent.com/GeorgeChan95/blogimg/master/img/2024/09/23/20240923-094444.png" alt="线程中断API"></p><table><thead><tr><th>API</th><th>描述</th></tr></thead><tbody><tr><td>public void interrupt()</td><td>实例方法，<br/>实例方法 <code>interrupt()</code> 仅仅是设置线程的中断状态为true，不会停止线程</td></tr><tr><td><strong>public static boolean interrupted()</strong></td><td><strong>静态方法</strong>，<code>Thread.interrupted();</code>  <br/>判断线程是否被中断，并清除当前中断状态<br/>这个方法做了两件事：<br/>1 返回当前线程的中断状态<br/>2 将当前线程的中断状态设为false<br/> <br/>这个方法有点不好理解，因为连续调用两次的结果可能不一样。</td></tr><tr><td>public boolean isInterrupted()</td><td>实例方法，<br/>判断当前线程是否被中断（通过检查中断标志位）</td></tr></tbody></table><h3 id="2-1-通过一个-volatile-变量实现"><a href="#2-1-通过一个-volatile-变量实现" class="headerlink" title="2.1 通过一个 volatile 变量实现"></a>2.1 通过一个 volatile 变量实现</h3><ul><li>volatile保证了可见性，t2修改了标志位后能马上被t1看到</li></ul><pre><code class="highlight java"><span class="comment">/**</span><span class="comment"> * volatile变量实现线程中断</span><span class="comment"> *</span><span class="comment"> * <span class="doctag">@throws</span> InterruptedException</span><span class="comment"> */</span><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">volatileStopThread</span><span class="params">()</span> <span class="keyword">throws</span> InterruptedException &#123;    <span class="keyword">new</span> <span class="title class_">Thread</span>(() -&gt; &#123;        <span class="keyword">while</span> (!isStop) &#123;            System.out.println(<span class="string">&quot;------- t1 run&quot;</span>);        &#125;        System.out.println(<span class="string">&quot;===== t1 is stop =====&quot;</span>);    &#125;, <span class="string">&quot;t1&quot;</span>).start();    <span class="comment">// 让线程t1运行50毫秒后，中断线程运行</span>    Thread.sleep(<span class="number">10</span>);    <span class="keyword">new</span> <span class="title class_">Thread</span>(() -&gt; &#123;        isStop = <span class="literal">true</span>;        System.out.println(<span class="string">&quot;------- t2 stop: &quot;</span> + isStop);    &#125;, <span class="string">&quot;t2&quot;</span>).start();&#125;</code></pre><h3 id="2-2-通过-AtomicBoolean（原子布尔型）"><a href="#2-2-通过-AtomicBoolean（原子布尔型）" class="headerlink" title="2.2 通过 AtomicBoolean（原子布尔型）"></a>2.2 通过 AtomicBoolean（原子布尔型）</h3><pre><code class="highlight java"><span class="comment">/**</span><span class="comment"> * 通过AtomicBoolean变量实现线程中断</span><span class="comment"> *</span><span class="comment"> * <span class="doctag">@throws</span> InterruptedException</span><span class="comment"> */</span><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">atomicBooleanStopThread</span><span class="params">()</span> <span class="keyword">throws</span> InterruptedException &#123;    <span class="keyword">new</span> <span class="title class_">Thread</span>(() -&gt; &#123;        <span class="keyword">while</span> (!flag.get()) &#123;            System.out.println(<span class="string">&quot;------- t1 run&quot;</span>);        &#125;        System.out.println(<span class="string">&quot;===== t1 is stop =====&quot;</span>);    &#125;, <span class="string">&quot;t1&quot;</span>).start();    <span class="comment">// 让线程t1运行50毫秒后，中断线程运行</span>    Thread.sleep(<span class="number">50</span>);    <span class="keyword">new</span> <span class="title class_">Thread</span>(() -&gt; &#123;        flag.set(<span class="literal">true</span>);        System.out.println(<span class="string">&quot;------- t2 stop: &quot;</span> + flag.get());    &#125;, <span class="string">&quot;t2&quot;</span>).start();&#125;</code></pre><h3 id="2-3-通过Thread类自带的中断api方法实现"><a href="#2-3-通过Thread类自带的中断api方法实现" class="headerlink" title="2.3 通过Thread类自带的中断api方法实现"></a>2.3 通过Thread类自带的中断api方法实现</h3><pre><code class="highlight java"><span class="comment">/**</span><span class="comment"> * 通过Thread类自带的中断api方法实现</span><span class="comment"> *</span><span class="comment"> * <span class="doctag">@throws</span> InterruptedException</span><span class="comment"> */</span><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">threadApiInterruptThread</span><span class="params">()</span> <span class="keyword">throws</span> InterruptedException &#123;    <span class="type">Thread</span> <span class="variable">t1</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Thread</span>(() -&gt; &#123;        <span class="keyword">while</span> (!Thread.currentThread().isInterrupted()) &#123;            System.out.println(<span class="string">&quot;------- t1 run&quot;</span>);        &#125;        System.out.println(<span class="string">&quot;===== t1 is stop =====&quot;</span>);    &#125;, <span class="string">&quot;t1&quot;</span>);    t1.start();    <span class="comment">// 让线程t1运行50毫秒后，中断线程运行</span>    Thread.sleep(<span class="number">50</span>);    <span class="keyword">new</span> <span class="title class_">Thread</span>(() -&gt; &#123;        <span class="comment">// t1线程中断标识设置为true，等待县城自我中断</span>        t1.interrupt();        System.out.println(<span class="string">&quot;------- t2 stop: &quot;</span> + <span class="literal">true</span>);    &#125;, <span class="string">&quot;t2&quot;</span>).start();&#125;</code></pre><h2 id="3-中断API源码分析"><a href="#3-中断API源码分析" class="headerlink" title="3. 中断API源码分析"></a>3. 中断API源码分析</h2><ul><li><strong>实例方法interrupt()，没有返回值</strong></li></ul><pre><code class="highlight java"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">interrupt</span><span class="params">()</span> &#123;    <span class="keyword">if</span> (<span class="built_in">this</span> != Thread.currentThread())        checkAccess();    <span class="keyword">synchronized</span> (blockerLock) &#123;        <span class="type">Interruptible</span> <span class="variable">b</span> <span class="operator">=</span> blocker;        <span class="keyword">if</span> (b != <span class="literal">null</span>) &#123;            interrupt0();           <span class="comment">// Just to set the interrupt flag</span>            b.interrupt(<span class="built_in">this</span>);            <span class="keyword">return</span>;        &#125;    &#125;    interrupt0();&#125;<span class="comment">//Thread.java</span><span class="comment">/* Some private helper methods */</span><span class="keyword">private</span> <span class="keyword">native</span> <span class="keyword">void</span> <span class="title function_">setPriority0</span><span class="params">(<span class="type">int</span> newPriority)</span>;<span class="keyword">private</span> <span class="keyword">native</span> <span class="keyword">void</span> <span class="title function_">stop0</span><span class="params">(Object o)</span>;<span class="keyword">private</span> <span class="keyword">native</span> <span class="keyword">void</span> <span class="title function_">suspend0</span><span class="params">()</span>;<span class="keyword">private</span> <span class="keyword">native</span> <span class="keyword">void</span> <span class="title function_">resume0</span><span class="params">()</span>;<span class="keyword">private</span> <span class="keyword">native</span> <span class="keyword">void</span> <span class="title function_">interrupt0</span><span class="params">()</span>;  <span class="comment">//---------------------------调用了c底层原生方法</span><span class="keyword">private</span> <span class="keyword">native</span> <span class="keyword">void</span> <span class="title function_">setNativeName</span><span class="params">(String name)</span>;</code></pre><ul><li><strong>实例方法 isInterrupted，返回布尔值</strong></li></ul><pre><code class="highlight java"><span class="comment">/**</span><span class="comment"> * Tests whether this thread has been interrupted.  The &lt;i&gt;interrupted</span><span class="comment"> * status&lt;/i&gt; of the thread is unaffected by this method.</span><span class="comment"> *</span><span class="comment"> * &lt;p&gt;A thread interruption ignored because a thread was not alive</span><span class="comment"> * at the time of the interrupt will be reflected by this method</span><span class="comment"> * returning false.</span><span class="comment"> *</span><span class="comment"> * <span class="doctag">@return</span>  &lt;code&gt;true&lt;/code&gt; if this thread has been interrupted;</span><span class="comment"> *          &lt;code&gt;false&lt;/code&gt; otherwise.</span><span class="comment"> * <span class="doctag">@see</span>     #interrupted()</span><span class="comment"> * <span class="doctag">@revised</span> 6.0</span><span class="comment"> */</span><span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">isInterrupted</span><span class="params">()</span> &#123;    <span class="keyword">return</span> isInterrupted(<span class="literal">false</span>);&#125;<span class="comment">//Thread.java</span><span class="keyword">private</span> <span class="keyword">native</span> <span class="type">boolean</span> <span class="title function_">isInterrupted</span><span class="params">(<span class="type">boolean</span> ClearInterrupted)</span>;<span class="comment">//也调用了c底层</span></code></pre><p><strong>中断API相关说明：</strong></p><p>具体来说，当对一个线程，调用 interrupt() 时：</p><ul><li>如果线程处于<strong>正常活动状态</strong>，那么会将该线程的中断标志设置为 true，仅此而已。被设置中断标志的线程将继续正常运行，不受影响。所以， interrupt() 并不能真正的中断线程，需要被调用的线程自己进行配合才行（即：代码自行实现中断逻辑）。</li><li>如果线程处于被阻塞状态（例如处于sleep, wait, join 等状态），在别的线程中调用当前线程对象的interrupt方法，那么线程将立即退出被阻塞状态（中断状态将被清除），并抛出一个InterruptedException异常。（ 关于这一点，<code>interrupt()</code> 方法的注释有明确的说明，）</li><li>中断<strong>不活动的线程</strong>不会产生任何影响，具体看下面案例</li></ul><h3 id="3-1-当前线程的中断标识为true，是不是线程就立刻停止？"><a href="#3-1-当前线程的中断标识为true，是不是线程就立刻停止？" class="headerlink" title="3.1 当前线程的中断标识为true，是不是线程就立刻停止？"></a>3.1 <strong>当前线程的中断标识为true，是不是线程就立刻停止？</strong></h3><p>答案：否， 仅仅设置了一个中断状态为true。</p><pre><code class="highlight java"><span class="comment">/**</span><span class="comment"> * 中断为true后，并不是立刻stop程序</span><span class="comment"> */</span><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">m4</span><span class="params">()</span> &#123;    <span class="comment">//中断为true后，并不是立刻stop程序</span>    <span class="type">Thread</span> <span class="variable">t1</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Thread</span>(() -&gt; &#123;        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">1</span>; i &lt;= <span class="number">800</span>; i++) &#123;            System.out.println(<span class="string">&quot;------i: &quot;</span> + i);        &#125;        System.out.println(<span class="string">&quot;t1.interrupt()调用之后02： &quot;</span> + Thread.currentThread().isInterrupted());    &#125;, <span class="string">&quot;t1&quot;</span>);    t1.start();    System.out.println(<span class="string">&quot;t1.interrupt()调用之前,t1线程的中断标识默认值： &quot;</span> + t1.isInterrupted());    <span class="keyword">try</span> &#123;        TimeUnit.MILLISECONDS.sleep(<span class="number">3</span>);    &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;        e.printStackTrace();    &#125;    <span class="comment">//实例方法interrupt()仅仅是设置线程的中断状态位设置为true，不会停止线程</span>    t1.interrupt();    <span class="comment">//活动状态,t1线程还在执行中</span>    System.out.println(<span class="string">&quot;t1.interrupt()调用之后01： &quot;</span> + t1.isInterrupted());    <span class="keyword">try</span> &#123;        TimeUnit.MILLISECONDS.sleep(<span class="number">3000</span>);    &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;        e.printStackTrace();    &#125;    <span class="comment">//非活动状态,t1线程不在执行中，已经结束执行了, 此时调用 isInterrupted() 方法不起作用，中断状态标识位返回：false</span>    System.out.println(<span class="string">&quot;t1.interrupt()调用之后03： &quot;</span> + t1.isInterrupted());&#125;</code></pre><p>运行结果：</p><pre><code class="highlight shell">t1.interrupt()调用之前,t1线程的中断标识默认值： false------i: 1------i: 2------i: 3......------i: 645t1.interrupt()调用之后01： true // ------此处中断标志位设置为了true,但是t1仍然在运行------i: 646......------i: 798------i: 799------i: 800t1.interrupt()调用之后02： truet1.interrupt()调用之后03： false //中断不活动的线程不会产生任何影响，线程结束后应该是自动变为了false</code></pre><h3 id="3-2-中断异常代码案例："><a href="#3-2-中断异常代码案例：" class="headerlink" title="3.2 中断异常代码案例："></a>3.2 <strong>中断异常代码案例：</strong></h3><p>当线程处于 <code>wait</code> 、<code>join</code> 、<code>sleep</code> 时，此时调用 <code>interrupt()</code> 方法，会触发 <strong>中断异常</strong>， 且会导致程序无限循环. 因为 InterruptedException，将会把中断状态清除。</p><pre><code class="highlight java"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">m5</span><span class="params">()</span> &#123;    <span class="type">Thread</span> <span class="variable">t1</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Thread</span>(() -&gt; &#123;        <span class="keyword">while</span> (<span class="literal">true</span>) &#123;            <span class="keyword">if</span> (Thread.currentThread().isInterrupted()) &#123;                System.out.println(<span class="string">&quot;-----isInterrupted() = true，程序结束。&quot;</span>);                <span class="keyword">break</span>;            &#125;            <span class="keyword">try</span> &#123;                Thread.sleep(<span class="number">500</span>);            &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;<span class="comment">//                    Thread.currentThread().interrupt(); //线程的中断标志位为false,无法停下，需要再次掉interrupt()设置true</span>                e.printStackTrace();            &#125;            System.out.println(<span class="string">&quot;------hello Interrupt&quot;</span>);        &#125;    &#125;, <span class="string">&quot;t1&quot;</span>);    t1.start();    <span class="keyword">try</span> &#123;        TimeUnit.SECONDS.sleep(<span class="number">3</span>);    &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;        e.printStackTrace();    &#125;    <span class="keyword">new</span> <span class="title class_">Thread</span>(() -&gt; &#123;        t1.interrupt();<span class="comment">//修改t1线程的中断标志位为true</span>    &#125;, <span class="string">&quot;t2&quot;</span>).start();&#125;</code></pre><p><strong>运行结果：</strong></p><p>当调用 t1.interrupt(); 时，代码发生了异常，但 t1 依然在运行，没有结束掉</p><pre><code class="highlight shell">------hello Interrupt------hello Interruptjava.lang.InterruptedException: sleep interruptedat java.lang.Thread.sleep(Native Method)at com.atguigu.juc.interrupt.InterruptDemo.lambda$m5$0(InterruptDemo.java:34)at java.lang.Thread.run(Thread.java:748)------hello Interrupt------hello Interrupt------hello Interrupt......</code></pre><p><strong>解决方法：</strong></p><p>在 catch (InterruptedException e)  处添加 <code>Thread.currentThread().interrupt();</code> 发生异常后，再次调用代码执行中断，程序发生异常后依然可以正常结束；</p><pre><code class="highlight shell">------hello Interrupt------hello Interrupt------hello Interrupt------hello Interrupt------hello Interruptjava.lang.InterruptedException: sleep interruptedat java.lang.Thread.sleep(Native Method)at com.atguigu.juc.interrupt.InterruptDemo.lambda$m5$0(InterruptDemo.java:34)at java.lang.Thread.run(Thread.java:748)------hello Interrupt-----isInterrupted() = true，程序结束。</code></pre><h3 id="3-3-对静态方法-Thread-interrupted-的理解"><a href="#3-3-对静态方法-Thread-interrupted-的理解" class="headerlink" title="3.3 对静态方法 Thread.interrupted() 的理解"></a>3.3 对静态方法 Thread.interrupted() 的理解</h3><p><code>public static boolean interrupted()</code> </p><ul><li><p>静态方法，Thread.interrupted(); 判断线程是否被中断，并清除当前中断状态这个方法做了两件事：</p><ul><li>1 返回当前线程的中断状态</li><li>2 将当前线程的中断状态设为false</li></ul><p>注意：此方法连续调用两次的结果可能不一样</p></li></ul><pre><code class="highlight java"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;    System.out.println(Thread.currentThread().getName()+<span class="string">&quot;---&quot;</span>+Thread.interrupted()); <span class="comment">// main---false</span>    System.out.println(Thread.currentThread().getName()+<span class="string">&quot;---&quot;</span>+Thread.interrupted()); <span class="comment">// main---false</span>    System.out.println(<span class="string">&quot;111111&quot;</span>);    Thread.currentThread().interrupt();<span class="comment">///----false---&gt; true</span>    System.out.println(<span class="string">&quot;222222&quot;</span>);    System.out.println(Thread.currentThread().getName()+<span class="string">&quot;---&quot;</span>+Thread.interrupted()); <span class="comment">// main---true</span>    System.out.println(Thread.currentThread().getName()+<span class="string">&quot;---&quot;</span>+Thread.interrupted()); <span class="comment">// main---false</span>&#125;</code></pre><p>运行结果：</p><pre><code class="highlight shell">main---falsemain---false111111222222main---truemain---false</code></pre><p><strong>对比 <code>interrupted()</code> 与 <code>isInterrupted()</code> 源码</strong></p><pre><code class="highlight java"><span class="keyword">public</span> <span class="keyword">static</span> <span class="type">boolean</span> <span class="title function_">interrupted</span><span class="params">()</span> &#123;    <span class="keyword">return</span> currentThread().isInterrupted(<span class="literal">true</span>);&#125;<span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">isInterrupted</span><span class="params">()</span> &#123;    <span class="keyword">return</span> isInterrupted(<span class="literal">false</span>);&#125;<span class="comment">/**</span><span class="comment"> * Tests if some Thread has been interrupted.  The interrupted state</span><span class="comment"> * is reset or not based on the value of ClearInterrupted that is</span><span class="comment"> * passed.</span><span class="comment"> */</span><span class="keyword">private</span> <span class="keyword">native</span> <span class="type">boolean</span> <span class="title function_">isInterrupted</span><span class="params">(<span class="type">boolean</span> ClearInterrupted)</span>;</code></pre><p>他们在底层都调用了native方法 isInterrupted() , 只不过传入参数ClearInterrupted一个传参传了<code>true</code>，一个传了<code>false</code>。</p><ul><li>静态方法<code>interrupted() </code>中<code>true</code>表示清空当前中断状态。</li><li>实例方法<code>isInterrupted</code> 则不会。</li></ul><h2 id="4-总结"><a href="#4-总结" class="headerlink" title="4. 总结"></a>4. 总结</h2><p>线程中断相关的方法：</p><ul><li><p><code>interrupt()</code> 方法是一个实例方法</p><p>它通知目标线程中断，也就是设置目标线程的中断标志位为true，中断标志位表示当前线程已经被中断了。</p></li><li><p><code>isInterrupted()</code> 方法也是一个实例方法</p><p>它判断当前线程是否被中断（通过检查中断标志位）并获取中断标志</p></li><li><p>Thread类的静态方法 <code>interrupted()</code></p><p>返回当前线程的中断状态(boolean类型)且将当前线程的中断状态设为false，此方法调用之后会清除当前线程的中断标志位的状态（将中断标志置为false了），返回当前值并清零置false</p></li></ul><h1 id="二、LockSupport是什么"><a href="#二、LockSupport是什么" class="headerlink" title="二、LockSupport是什么"></a>二、LockSupport是什么</h1><p><code>LockSupport</code> 是用来创建锁和其他同步类的基本线程阻塞原语，其中 <code>park()</code> 和 <code>unpack()</code> 而作用分别是阻塞线程和解除阻塞线程.</p><p><img src="https://raw.githubusercontent.com/GeorgeChan95/blogimg/master/img/2024/09/23/20240923-133129.png" alt="LockSupport"></p><h1 id="三、线程等待唤醒机制"><a href="#三、线程等待唤醒机制" class="headerlink" title="三、线程等待唤醒机制"></a>三、线程等待唤醒机制</h1><h2 id="1-3种让线程等待和唤醒的方法"><a href="#1-3种让线程等待和唤醒的方法" class="headerlink" title="1. 3种让线程等待和唤醒的方法"></a>1. 3种让线程等待和唤醒的方法</h2><ul><li>使用Object中的<code>wait()</code>方法让线程等待，使用Object中的<code>notify()</code>方法唤醒线程</li><li>使用JUC包中<code>Condition</code>的<code>await()</code>方法让线程等待，使用<code>signal()</code>方法唤醒线程</li><li><code>LockSupport</code>类可以阻塞当前线程以及唤醒指定被阻塞的线程</li></ul><h2 id="2-Object类中的-wait-和-notify-方法实现线程等待和唤醒"><a href="#2-Object类中的-wait-和-notify-方法实现线程等待和唤醒" class="headerlink" title="2. Object类中的 wait 和 notify 方法实现线程等待和唤醒"></a>2. Object类中的 wait 和 notify 方法实现线程等待和唤醒</h2><p><strong>正确使用 wait &#x2F; notify</strong> </p><ul><li>wait 和 notify 都必须在 synchronized 覆盖的代码块中</li><li>必须先执行 wait， 再执行 notify</li></ul><pre><code class="highlight java"><span class="comment">/**</span><span class="comment"> * 正确使用 wait / notify 实现线程的等待和唤醒</span><span class="comment"> *</span><span class="comment"> * <span class="doctag">@throws</span> InterruptedException</span><span class="comment"> */</span><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">normal</span><span class="params">()</span> <span class="keyword">throws</span> InterruptedException &#123;    <span class="keyword">new</span> <span class="title class_">Thread</span>(() -&gt; &#123;        <span class="keyword">synchronized</span> (object) &#123;            <span class="keyword">try</span> &#123;                System.out.println(Thread.currentThread().getName() + <span class="string">&quot; ---- t1释放锁&quot;</span>);                <span class="comment">// wait方法会释放锁，给其他线程获取锁的机会</span>                object.wait();                System.out.println(Thread.currentThread().getName() + <span class="string">&quot; ---- t1重新获取锁&quot;</span>);            &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;                <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">RuntimeException</span>(e);            &#125;        &#125;    &#125;, <span class="string">&quot;t1&quot;</span>).start();    TimeUnit.SECONDS.sleep(<span class="number">1</span>);    <span class="keyword">new</span> <span class="title class_">Thread</span>(() -&gt; &#123;        <span class="keyword">synchronized</span> (object) &#123;            System.out.println(Thread.currentThread().getName() + <span class="string">&quot;---- notify&quot;</span>);            object.notify(); <span class="comment">// notify执行，让 t1 线程重新获取锁</span>        &#125;    &#125;, <span class="string">&quot;t2&quot;</span>).start();&#125;</code></pre><p>运行结果：</p><pre><code class="highlight shell">t1 ---- t1释放锁t2---- notifyt1 ---- t1重新获取锁</code></pre><p><strong>错误使用—： 去掉 synchronized</strong></p><pre><code class="highlight java"><span class="comment">/**</span><span class="comment"> * 错误方式—： 去掉 synchronized</span><span class="comment"> *</span><span class="comment"> * <span class="doctag">@throws</span> InterruptedException</span><span class="comment"> */</span><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">error1</span><span class="params">()</span> <span class="keyword">throws</span> InterruptedException &#123;    <span class="keyword">new</span> <span class="title class_">Thread</span>(() -&gt; &#123;        <span class="keyword">try</span> &#123;            System.out.println(Thread.currentThread().getName() + <span class="string">&quot; ---- t1释放锁&quot;</span>);            <span class="comment">// wait方法会释放锁，给其他线程获取锁的机会</span>            object.wait();            System.out.println(Thread.currentThread().getName() + <span class="string">&quot; ---- t1重新获取锁&quot;</span>);        &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;            <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">RuntimeException</span>(e);        &#125;    &#125;, <span class="string">&quot;t1&quot;</span>).start();    TimeUnit.SECONDS.sleep(<span class="number">1</span>);    <span class="keyword">new</span> <span class="title class_">Thread</span>(() -&gt; &#123;        System.out.println(Thread.currentThread().getName() + <span class="string">&quot;---- notify&quot;</span>);        object.notify(); <span class="comment">// notify执行，让 t1 线程重新获取锁</span>    &#125;, <span class="string">&quot;t2&quot;</span>).start();&#125;</code></pre><p>运行结果：</p><pre><code class="highlight shell">t1 ---- t1释放锁Exception in thread &quot;t1&quot; java.lang.IllegalMonitorStateExceptionat java.lang.Object.wait(Native Method)at java.lang.Object.wait(Object.java:502)at com.atguigu.juc.interrupt.SynchronizedDemo.lambda$error1$2(SynchronizedDemo.java:59)at java.lang.Thread.run(Thread.java:748)t2---- notifyException in thread &quot;t2&quot; java.lang.IllegalMonitorStateExceptionat java.lang.Object.notify(Native Method)at com.atguigu.juc.interrupt.SynchronizedDemo.lambda$error1$3(SynchronizedDemo.java:70)at java.lang.Thread.run(Thread.java:748)</code></pre><p><strong>错误使用二：把notify和wait的执行顺序对换</strong></p><pre><code class="highlight java"><span class="comment">/**</span><span class="comment"> * 错误使用二：把notify和wait的执行顺序对换</span><span class="comment"> *</span><span class="comment"> * <span class="doctag">@throws</span> InterruptedException</span><span class="comment"> */</span><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">error2</span><span class="params">()</span> <span class="keyword">throws</span> InterruptedException &#123;    <span class="keyword">new</span> <span class="title class_">Thread</span>(() -&gt; &#123;        <span class="keyword">try</span> &#123;            TimeUnit.SECONDS.sleep(<span class="number">2</span>); <span class="comment">// t1 线程先停2秒，等待t2线程执行结束</span>        &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;            <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">RuntimeException</span>(e);        &#125;        <span class="keyword">synchronized</span> (object) &#123;            <span class="keyword">try</span> &#123;                System.out.println(Thread.currentThread().getName() + <span class="string">&quot; ---- t1释放锁&quot;</span>);                <span class="comment">// wait方法会释放锁，给其他线程获取锁的机会</span>                object.wait();                System.out.println(Thread.currentThread().getName() + <span class="string">&quot; ---- t1重新获取锁&quot;</span>);            &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;                <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">RuntimeException</span>(e);            &#125;        &#125;    &#125;, <span class="string">&quot;t1&quot;</span>).start();    TimeUnit.SECONDS.sleep(<span class="number">1</span>);    <span class="keyword">new</span> <span class="title class_">Thread</span>(() -&gt; &#123;        <span class="keyword">synchronized</span> (object) &#123;            System.out.println(Thread.currentThread().getName() + <span class="string">&quot;---- notify&quot;</span>);            object.notify(); <span class="comment">// notify执行，让 t1 线程重新获取锁</span>        &#125;    &#125;, <span class="string">&quot;t2&quot;</span>).start();&#125;</code></pre><p>运行结果：</p><pre><code class="highlight shell">t2---- notifyt1 ---- t1释放锁</code></pre><p>现象：t1 线程没有结束掉。</p><p><strong>总结：</strong></p><ul><li>wait和notify方法必须要在<strong>同步</strong>块或者方法里面，且必须<strong>成对</strong>出现使用</li><li>先wait后notify才可以,<strong>顺序不能错</strong></li></ul><h2 id="3-Condition接口中的-await-后-signal-方法实现线程的等待和唤醒"><a href="#3-Condition接口中的-await-后-signal-方法实现线程的等待和唤醒" class="headerlink" title="3. Condition接口中的 await 后 signal 方法实现线程的等待和唤醒"></a>3. Condition接口中的 await 后 signal 方法实现线程的等待和唤醒</h2><p><strong>正确使用 await &#x2F; signal</strong> </p><ul><li>await 和 signal 都必须在 lock() &#x2F; unlock() 覆盖的代码块中</li><li>必须先执行 await ， 再执行 signal</li></ul><pre><code class="highlight java"><span class="comment">/**</span><span class="comment"> * 正确使用 Lock 的 await / signal 实现对线程的等待和唤醒</span><span class="comment"> * <span class="doctag">@throws</span> InterruptedException</span><span class="comment"> */</span><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">normal</span><span class="params">()</span> <span class="keyword">throws</span> InterruptedException &#123;    <span class="type">Lock</span> <span class="variable">lock</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ReentrantLock</span>();    <span class="type">Condition</span> <span class="variable">condition</span> <span class="operator">=</span> lock.newCondition();    <span class="keyword">new</span> <span class="title class_">Thread</span>(() -&gt; &#123;        <span class="keyword">try</span> &#123;            lock.lock();            System.out.println(Thread.currentThread().getName() + <span class="string">&quot;---- t1 释放锁&quot;</span>);            condition.await();            System.out.println(Thread.currentThread().getName() + <span class="string">&quot;---- t1 重新获取锁&quot;</span>);        &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;            <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">RuntimeException</span>(e);        &#125; <span class="keyword">finally</span> &#123;            lock.unlock();        &#125;    &#125;, <span class="string">&quot;t1&quot;</span>).start();    TimeUnit.SECONDS.sleep(<span class="number">1</span>);    <span class="keyword">new</span> <span class="title class_">Thread</span>(() -&gt; &#123;        <span class="keyword">try</span> &#123;            lock.lock();            System.out.println(Thread.currentThread().getName() + <span class="string">&quot;---- t2唤醒t1线程&quot;</span>);            condition.signal();        &#125; <span class="keyword">finally</span> &#123;            lock.unlock();        &#125;    &#125;, <span class="string">&quot;t2&quot;</span>).start();&#125;</code></pre><p>运行结果：</p><pre><code class="highlight shell">t1---- t1 释放锁t2---- t2唤醒t1线程t1---- t1 重新获取锁</code></pre><p><strong>错误使用一：await 和 signal 不在 lock() &#x2F; unlock() 覆盖的代码块中</strong></p><p>报错： java.lang.IllegalMonitorStateException</p><p><strong>错误使用二：必须先执行 signal ， 再执行 await</strong></p><p>线程没有正确的停止</p><h2 id="4-Object和Condition使用的限制条件"><a href="#4-Object和Condition使用的限制条件" class="headerlink" title="4. Object和Condition使用的限制条件"></a>4. Object和Condition使用的限制条件</h2><ul><li>线程先要获得并持有锁，必须在锁块(synchronized或lock)中</li><li>必须要先等待后唤醒，线程才能够被唤醒</li></ul><h2 id="5-LockSupport类中的park等待和unpark唤醒"><a href="#5-LockSupport类中的park等待和unpark唤醒" class="headerlink" title="5. LockSupport类中的park等待和unpark唤醒"></a>5. LockSupport类中的park等待和unpark唤醒</h2><h3 id="5-1-概念解析"><a href="#5-1-概念解析" class="headerlink" title="5.1 概念解析"></a>5.1 概念解析</h3><p>LockSupport 通过 <code>park()</code> 和 <code>unpark(thread)</code> 方法来实现阻塞和唤醒线程的操作</p><p><strong>官网解释</strong></p><p><img src="https://raw.githubusercontent.com/GeorgeChan95/blogimg/master/img/2024/09/23/20240923-145605.png" alt="LockSupport"></p><p>LockSupport是用来创建锁和其他同步类的基本线程阻塞原语。</p><ul><li>LockSupport类使用了一种名为Permit（许可）的概念来做到阻塞和唤醒线程的功能， 每个线程都有一个许可(permit)，</li><li>permit只有两个值1和零，默认是零。</li><li>可以把许可看成是一种(0,1)信号量（Semaphore），但与 Semaphore 不同的是，许可的累加上限是1。</li></ul><h3 id="5-2-主要方法"><a href="#5-2-主要方法" class="headerlink" title="5.2 主要方法"></a>5.2 主要方法</h3><h4 id="5-2-1-API"><a href="#5-2-1-API" class="headerlink" title="5.2.1 API"></a>5.2.1 API</h4><p><img src="https://raw.githubusercontent.com/GeorgeChan95/blogimg/master/img/2024/09/23/20240923-150101.png" alt="LockSupport API"></p><h4 id="5-2-2-阻塞"><a href="#5-2-2-阻塞" class="headerlink" title="5.2.2 阻塞"></a>5.2.2 阻塞</h4><ul><li><code>park() / park(Object blocker)</code></li><li>阻塞当前线程 &#x2F; 阻塞传入的具体线程</li></ul><p>调用<code>LockSupport.park()</code>时，发现它调用了<code>unsafe类</code>，并且默认传了一个0</p><pre><code class="highlight java"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">park</span><span class="params">()</span> &#123;    UNSAFE.park(<span class="literal">false</span>, <span class="number">0L</span>);&#125;</code></pre><ul><li>permit默认是零，所以一开始调用<code>park()</code>方法，当前线程就会阻塞，直到别的线程将当前线程的permit设置为1时，park方法会被唤醒，然后会将permit再次设置为零并返回。</li></ul><h4 id="5-2-3-唤醒"><a href="#5-2-3-唤醒" class="headerlink" title="5.2.3 唤醒"></a>5.2.3 唤醒</h4><p><code>unpark(Thread thread)</code> , 唤醒处于阻塞状态的指定线程</p><pre><code class="highlight java"><span class="comment">/**</span><span class="comment"> * Makes available the permit for the given thread, if it</span><span class="comment"> * was not already available.  If the thread was blocked on</span><span class="comment"> * &#123;<span class="doctag">@code</span> park&#125; then it will unblock.  Otherwise, its next call</span><span class="comment"> * to &#123;<span class="doctag">@code</span> park&#125; is guaranteed not to block. This operation</span><span class="comment"> * is not guaranteed to have any effect at all if the given</span><span class="comment"> * thread has not been started.</span><span class="comment"> *</span><span class="comment"> * <span class="doctag">@param</span> thread the thread to unpark, or &#123;<span class="doctag">@code</span> null&#125;, in which case</span><span class="comment"> *        this operation has no effect</span><span class="comment"> */</span><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">unpark</span><span class="params">(Thread thread)</span> &#123;    <span class="keyword">if</span> (thread != <span class="literal">null</span>)        UNSAFE.unpark(thread);&#125;</code></pre><p>调用<code>LockSupport.unpark();</code>时，也调用了<code>unsafe类</code></p><ul><li>调用unpark(thread)方法后，就会将 thread线程的许可 permit 设置成<strong>1</strong>(注意多次调用 unpark 方法，不会累加，permit 值还是1)会自动唤醒 thread 线程，即之前阻塞中的 LockSupport.park() 方法会立即返回。</li></ul><h3 id="5-3-LockSupport-代码示例"><a href="#5-3-LockSupport-代码示例" class="headerlink" title="5.3 LockSupport 代码示例"></a>5.3 LockSupport 代码示例</h3><p><strong>正常+无锁块要求</strong></p><pre><code class="highlight java"><span class="comment">/**</span><span class="comment"> * 正常使用，无锁块要求</span><span class="comment"> * 先阻塞后释放，可以实现线程的阻塞和唤醒</span><span class="comment"> *</span><span class="comment"> * <span class="doctag">@throws</span> InterruptedException</span><span class="comment"> */</span><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">m1</span><span class="params">()</span> <span class="keyword">throws</span> InterruptedException &#123;    <span class="type">Thread</span> <span class="variable">t1</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Thread</span>(() -&gt; &#123;        System.out.println(Thread.currentThread().getName() + <span class="string">&quot;---- come in&quot;</span>);        System.out.println(Thread.currentThread().getName() + <span class="string">&quot;---- park阻塞&quot;</span>);        LockSupport.park();        System.out.println(Thread.currentThread().getName() + <span class="string">&quot;---- 继续执行&quot;</span>);    &#125;, <span class="string">&quot;t1&quot;</span>);    t1.start();    TimeUnit.SECONDS.sleep(<span class="number">1</span>);    <span class="keyword">new</span> <span class="title class_">Thread</span>(() -&gt; &#123;        System.out.println(Thread.currentThread().getName() + <span class="string">&quot;---- come in&quot;</span>);        LockSupport.unpark(t1);    &#125;, <span class="string">&quot;t2&quot;</span>).start();&#125;</code></pre><p>运行结果：</p><pre><code class="highlight shell">t1---- come int1---- park阻塞t2---- come int1---- 继续执行</code></pre><p><strong>先唤醒后等待，LockSupport 同样支持</strong></p><pre><code class="highlight java"><span class="comment">/**</span><span class="comment"> * 先释放后阻塞，也可以实现线程的阻塞和唤醒</span><span class="comment"> *</span><span class="comment"> * <span class="doctag">@throws</span> InterruptedException</span><span class="comment"> */</span><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">m2</span><span class="params">()</span> <span class="keyword">throws</span> InterruptedException &#123;    <span class="type">Thread</span> <span class="variable">t1</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Thread</span>(() -&gt; &#123;        <span class="keyword">try</span> &#123;            TimeUnit.SECONDS.sleep(<span class="number">2</span>);        &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;            <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">RuntimeException</span>(e);        &#125;        System.out.println(Thread.currentThread().getName() + <span class="string">&quot;---- come in&quot;</span>);        System.out.println(Thread.currentThread().getName() + <span class="string">&quot;---- park阻塞&quot;</span>);        LockSupport.park();        System.out.println(Thread.currentThread().getName() + <span class="string">&quot;---- 继续执行&quot;</span>);    &#125;, <span class="string">&quot;t1&quot;</span>);    t1.start();    TimeUnit.SECONDS.sleep(<span class="number">1</span>);    <span class="keyword">new</span> <span class="title class_">Thread</span>(() -&gt; &#123;        System.out.println(Thread.currentThread().getName() + <span class="string">&quot;---- come in&quot;</span>);        System.out.println(Thread.currentThread().getName() + <span class="string">&quot;---- 给t1线程发通行证&quot;</span>);        LockSupport.unpark(t1);    &#125;, <span class="string">&quot;t2&quot;</span>).start();&#125;</code></pre><p>运行结果：</p><pre><code class="highlight shell">t2---- come int2---- 给t1线程发通行证t1---- come int1---- park阻塞t1---- 继续执行</code></pre><p>t1 sleep方法2秒后醒来，执行park无效，没有阻塞效果，这是因为 t2 先执行了<code>unpark(t1)</code>导致上面的park方法无效.</p><p>注意：park() &#x2F; unpark() 必须成对出现</p><p><strong>错误使用：连续执行 unpark(), 相当于只执行了一次 unpark()</strong> </p><pre><code class="highlight java"><span class="comment">/**</span><span class="comment"> * 连续执行 unpark(), 相当于只执行了一次 unpark()</span><span class="comment"> */</span><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">error1</span><span class="params">()</span> &#123;    <span class="type">Thread</span> <span class="variable">t1</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Thread</span>(() -&gt; &#123;        System.out.println(Thread.currentThread().getName() + <span class="string">&quot;\t&quot;</span> + <span class="string">&quot;---come in&quot;</span>);        System.out.println(Thread.currentThread().getName() + <span class="string">&quot;\t&quot;</span> + <span class="string">&quot;--- park1&quot;</span>);        LockSupport.park();        System.out.println(Thread.currentThread().getName() + <span class="string">&quot;\t&quot;</span> + <span class="string">&quot;--- park2&quot;</span>);        LockSupport.park();        System.out.println(Thread.currentThread().getName() + <span class="string">&quot;\t&quot;</span> + <span class="string">&quot;---被唤醒&quot;</span>);    &#125;, <span class="string">&quot;t1&quot;</span>);    t1.start();    <span class="keyword">new</span> <span class="title class_">Thread</span>(() -&gt; &#123;        LockSupport.unpark(t1);        LockSupport.unpark(t1);        System.out.println(Thread.currentThread().getName() + <span class="string">&quot;\t&quot;</span> + <span class="string">&quot;--- unpark1&quot;</span>);        System.out.println(Thread.currentThread().getName() + <span class="string">&quot;\t&quot;</span> + <span class="string">&quot;--- unpark2&quot;</span>);        <span class="keyword">try</span> &#123;            TimeUnit.SECONDS.sleep(<span class="number">3</span>);        &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;            e.printStackTrace();        &#125;    &#125;, <span class="string">&quot;t2&quot;</span>).start();&#125;</code></pre><p>运行结果：</p><pre><code class="highlight shell">t1---come int1--- park1t2--- unpark1t2--- unpark2t1--- park2</code></pre><p>t1 没有停止，继续阻塞，这是因为 t2 连续执行了两次 <code>unpark(t1)</code> ，但其实只发布了一个通行证，导致 t1 的第一次 park() 被唤醒了，但是第二次 park() 就没有通行证用来唤醒它，因此 t1 阻塞。</p><p><strong>总结：</strong></p><ul><li>Lock Support是用来创建锁和其他同步类的基本线程阻塞原语。</li><li>Lock Support是一个线程阻塞工具类， 所有的方法都是静态方法， 可以让线程在任意位置阻塞， 阻塞之后也有对应的唤醒方法。归根结底，Lock Support调用的Unsafe中的native代码。</li><li>Lock Support提供<code>park()</code> 和<code>unpark() </code>方法实现<strong>阻塞线程</strong>和<strong>解除线程阻塞</strong>的过程</li><li>Lock Support和每个使用它的线程都有一个许可(permit) 关联。</li><li>每个线程都有一个相关的 permit， permit 最多只有一个， 重复调用 <code>unpark()</code> 也不会积累凭证。</li></ul>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;一、线程中断机制&quot;&gt;&lt;a href=&quot;#一、线程中断机制&quot; class=&quot;headerlink&quot; title=&quot;一、线程中断机制&quot;&gt;&lt;/a&gt;一、线程中断机制&lt;/h1&gt;&lt;h2 id=&quot;1-什么是中断机制-？&quot;&gt;&lt;a href=&quot;#1-什么是中断机制-？&quot; class</summary>
      
    
    
    
    <category term="JUC" scheme="https://georgechan95.github.io/categories/JUC/"/>
    
    
    <category term="juc" scheme="https://georgechan95.github.io/tags/juc/"/>
    
    <category term="java" scheme="https://georgechan95.github.io/tags/java/"/>
    
  </entry>
  
  <entry>
    <title>03-JUC进阶-Java中的锁的解析</title>
    <link href="https://georgechan95.github.io/blog/219e52ea.html"/>
    <id>https://georgechan95.github.io/blog/219e52ea.html</id>
    <published>2024-09-21T06:15:20.000Z</published>
    <updated>2024-09-21T08:52:48.128Z</updated>
    
    <content type="html"><![CDATA[<h1 id="一、乐观锁和悲观锁"><a href="#一、乐观锁和悲观锁" class="headerlink" title="一、乐观锁和悲观锁"></a>一、乐观锁和悲观锁</h1><h2 id="1-悲观锁"><a href="#1-悲观锁" class="headerlink" title="1. 悲观锁"></a>1. 悲观锁</h2><p>悲观锁认为自己在使用数据的时候一定有别的线程来修改数据，因此在获取数据的时候会先加锁，确保数据不会被别的线程修改。</p><p><strong>悲观锁的实现方式</strong></p><ul><li><code>synchronized</code> 关键字</li><li><code>Lock</code> 的实现类都是悲观锁</li></ul><p><strong>适合写操作多的场景</strong>，先加锁可以保证写操作时数据正确。显示的锁定之后再操作同步资源。</p><pre><code class="highlight java"><span class="comment">//=============悲观锁的调用方式</span><span class="keyword">public</span> <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title function_">m1</span><span class="params">()</span>&#123;    <span class="comment">//加锁后的业务逻辑......</span>&#125;<span class="comment">// 保证多个线程使用的是同一个lock对象的前提下</span><span class="type">ReentrantLock</span> <span class="variable">lock</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ReentrantLock</span>();<span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">m2</span><span class="params">()</span> &#123;    lock.lock();    <span class="keyword">try</span> &#123;        <span class="comment">// 操作同步资源</span>    &#125;<span class="keyword">finally</span> &#123;        lock.unlock();    &#125;&#125;</code></pre><h2 id="2-乐观锁"><a href="#2-乐观锁" class="headerlink" title="2. 乐观锁"></a>2. 乐观锁</h2><p>乐观锁认为自己在使用数据时不会有别的线程修改数据，所以不会添加锁，只是在更新数据的时候去判断之前有没有别的线程更新了这个数据。如果这个数据没有被更新，当前线程将自己修改的数据成功写入。如果数据已经被其他线程更新，则根据不同的实现方式执行不同的操作</p><p><strong>乐观锁的实现方式</strong></p><ul><li>版本号机制Version。（只要有人提交了就会修改版本号，可以解决ABA问题）<ul><li><strong>ABA问题</strong>：再CAS中想读取一个值A，想把值A变为C，不能保证读取时的A就是赋值时的A，中间可能有个线程将A变为B再变为A。<ul><li>解决方法：Juc包提供了一个 <code>AtomicStampedReference</code>，原子更新带有版本号的引用类型，通过控制版本值的变化来解决ABA问题。</li></ul></li><li>最常采用的是CAS算法，Java原子类中的递增操作就通过CAS自旋实现的。</li></ul></li></ul><p><strong>适合读操作多的场景</strong>，不加锁的性能特点能够使其操作的性能大幅提升。</p><pre><code class="highlight java"><span class="comment">//=============乐观锁的调用方式</span><span class="comment">// 保证多个线程使用的是同一个AtomicInteger</span><span class="keyword">private</span> <span class="type">AtomicInteger</span> <span class="variable">atomicInteger</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">AtomicInteger</span>();atomicInteger.incrementAndGet();</code></pre><h1 id="二、synchronized-锁的8种情况"><a href="#二、synchronized-锁的8种情况" class="headerlink" title="二、synchronized 锁的8种情况"></a>二、synchronized 锁的8种情况</h1><p>下面通过一段代码，演示 synchronized 锁的 8 种情况</p><ol><li><p>标准访问，先打印短信还是邮件</p><pre><code class="highlight java"><span class="keyword">class</span> <span class="title class_">Phone</span> &#123;    <span class="keyword">public</span> <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title function_">sendSMS</span><span class="params">()</span> <span class="keyword">throws</span> Exception &#123;        System.out.println(<span class="string">&quot;------sendSMS&quot;</span>);    &#125;    <span class="keyword">public</span> <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title function_">sendEmail</span><span class="params">()</span> <span class="keyword">throws</span> Exception &#123;        System.out.println(<span class="string">&quot;------sendEmail&quot;</span>);    &#125;&#125;<span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Lock_8</span> &#123;    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception &#123;        <span class="type">Phone</span> <span class="variable">phone</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Phone</span>();        <span class="keyword">new</span> <span class="title class_">Thread</span>(() -&gt; &#123;            <span class="keyword">try</span> &#123;                phone.sendSMS();            &#125; <span class="keyword">catch</span> (Exception e) &#123;                e.printStackTrace();            &#125;        &#125;, <span class="string">&quot;AA&quot;</span>).start();        Thread.sleep(<span class="number">100</span>);        <span class="keyword">new</span> <span class="title class_">Thread</span>(() -&gt; &#123;            <span class="keyword">try</span> &#123;                phone.sendEmail();            &#125; <span class="keyword">catch</span> (Exception e) &#123;                e.printStackTrace();            &#125;        &#125;, <span class="string">&quot;BB&quot;</span>).start();    &#125;&#125;</code></pre><p>打印结果：</p><pre><code class="highlight shell">------sendSMS------sendEmail</code></pre><p>分析：两个方法都加了 synchronized 关键字，因为是同一个对象调用，所有是同一把锁，按照顺序执行。</p></li><li><p>停4秒在短信方法内，先打印短信还是邮件</p><pre><code class="highlight java"><span class="keyword">class</span> <span class="title class_">Phone</span> &#123;    <span class="keyword">public</span> <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title function_">sendSMS</span><span class="params">()</span> <span class="keyword">throws</span> Exception &#123;        <span class="comment">//停留4秒</span>        TimeUnit.SECONDS.sleep(<span class="number">4</span>);        System.out.println(<span class="string">&quot;------sendSMS&quot;</span>);    &#125;    <span class="keyword">public</span> <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title function_">sendEmail</span><span class="params">()</span> <span class="keyword">throws</span> Exception &#123;        System.out.println(<span class="string">&quot;------sendEmail&quot;</span>);    &#125;&#125;<span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Lock_8</span> &#123;    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception &#123;        <span class="type">Phone</span> <span class="variable">phone</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Phone</span>();        <span class="keyword">new</span> <span class="title class_">Thread</span>(() -&gt; &#123;            <span class="keyword">try</span> &#123;                phone.sendSMS();            &#125; <span class="keyword">catch</span> (Exception e) &#123;                e.printStackTrace();            &#125;        &#125;, <span class="string">&quot;AA&quot;</span>).start();        Thread.sleep(<span class="number">100</span>);        <span class="keyword">new</span> <span class="title class_">Thread</span>(() -&gt; &#123;            <span class="keyword">try</span> &#123;                phone.sendEmail();            &#125; <span class="keyword">catch</span> (Exception e) &#123;                e.printStackTrace();            &#125;        &#125;, <span class="string">&quot;BB&quot;</span>).start();    &#125;&#125;</code></pre><p>打印结果：</p><pre><code class="highlight shell">------sendSMS------sendEmail</code></pre><p>分析：两个方法都加了 synchronized 关键字，因为还是同一个对象调用，所有还是同一把锁，先拿到锁的方法执行结束后，另一个方法才能执行。</p></li><li><p>新增普通的hello方法，是先打短信还是hello</p><pre><code class="highlight java"><span class="keyword">class</span> <span class="title class_">Phone</span> &#123;    <span class="keyword">public</span> <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title function_">sendSMS</span><span class="params">()</span> <span class="keyword">throws</span> Exception &#123;        <span class="comment">//停留4秒</span>        TimeUnit.SECONDS.sleep(<span class="number">4</span>);        System.out.println(<span class="string">&quot;------sendSMS&quot;</span>);    &#125;    <span class="keyword">public</span> <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title function_">sendEmail</span><span class="params">()</span> <span class="keyword">throws</span> Exception &#123;        System.out.println(<span class="string">&quot;------sendEmail&quot;</span>);    &#125;    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">getHello</span><span class="params">()</span> &#123;        System.out.println(<span class="string">&quot;------getHello&quot;</span>);    &#125;&#125;<span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Lock_8</span> &#123;    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception &#123;        <span class="type">Phone</span> <span class="variable">phone</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Phone</span>();        <span class="keyword">new</span> <span class="title class_">Thread</span>(() -&gt; &#123;            <span class="keyword">try</span> &#123;                phone.sendSMS();            &#125; <span class="keyword">catch</span> (Exception e) &#123;                e.printStackTrace();            &#125;        &#125;, <span class="string">&quot;AA&quot;</span>).start();        Thread.sleep(<span class="number">100</span>);        <span class="keyword">new</span> <span class="title class_">Thread</span>(() -&gt; &#123;            <span class="keyword">try</span> &#123;                phone.getHello();            &#125; <span class="keyword">catch</span> (Exception e) &#123;                e.printStackTrace();            &#125;        &#125;, <span class="string">&quot;BB&quot;</span>).start();    &#125;&#125;</code></pre><p>打印结果：</p><pre><code class="highlight shell">------getHello------sendSMS</code></pre><p>分析：hello方法没有加锁，调用即执行，sendSMS有sleep阻塞。</p></li><li><p>现在有两部手机，先打印短信还是邮件</p><pre><code class="highlight java"><span class="keyword">class</span> <span class="title class_">Phone</span> &#123;    <span class="keyword">public</span> <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title function_">sendSMS</span><span class="params">()</span> <span class="keyword">throws</span> Exception &#123;        <span class="comment">//停留4秒</span>        TimeUnit.SECONDS.sleep(<span class="number">4</span>);        System.out.println(<span class="string">&quot;------sendSMS&quot;</span>);    &#125;    <span class="keyword">public</span> <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title function_">sendEmail</span><span class="params">()</span> <span class="keyword">throws</span> Exception &#123;        System.out.println(<span class="string">&quot;------sendEmail&quot;</span>);    &#125;&#125;<span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Lock_8</span> &#123;    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception &#123;        <span class="type">Phone</span> <span class="variable">phone</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Phone</span>();        <span class="type">Phone</span> <span class="variable">phone2</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Phone</span>();        <span class="keyword">new</span> <span class="title class_">Thread</span>(() -&gt; &#123;            <span class="keyword">try</span> &#123;                phone.sendSMS();            &#125; <span class="keyword">catch</span> (Exception e) &#123;                e.printStackTrace();            &#125;        &#125;, <span class="string">&quot;AA&quot;</span>).start();        Thread.sleep(<span class="number">100</span>);        <span class="keyword">new</span> <span class="title class_">Thread</span>(() -&gt; &#123;            <span class="keyword">try</span> &#123;                phone2.sendEmail();            &#125; <span class="keyword">catch</span> (Exception e) &#123;                e.printStackTrace();            &#125;        &#125;, <span class="string">&quot;BB&quot;</span>).start();    &#125;&#125;</code></pre><p>打印结果：</p><pre><code class="highlight shell">------sendEmail------sendSMS</code></pre><p>分析：synchronized 在方法上，是方法级的锁，由于是两个 phone 对象调用不同的方法，所以 sendSMS() 和 sendEmail() 持有的是不同的锁，互不影响。</p></li><li><p>两个静态同步方法，1部手机，先打印短信还是邮件</p><pre><code class="highlight java"><span class="keyword">class</span> <span class="title class_">Phone</span> &#123;    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title function_">sendSMS</span><span class="params">()</span> <span class="keyword">throws</span> Exception &#123;        <span class="comment">//停留4秒</span>        TimeUnit.SECONDS.sleep(<span class="number">4</span>);        System.out.println(<span class="string">&quot;------sendSMS&quot;</span>);    &#125;    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title function_">sendEmail</span><span class="params">()</span> <span class="keyword">throws</span> Exception &#123;        System.out.println(<span class="string">&quot;------sendEmail&quot;</span>);    &#125;&#125;<span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Lock_8</span> &#123;    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception &#123;        <span class="type">Phone</span> <span class="variable">phone</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Phone</span>();                <span class="keyword">new</span> <span class="title class_">Thread</span>(() -&gt; &#123;            <span class="keyword">try</span> &#123;                phone.sendSMS();            &#125; <span class="keyword">catch</span> (Exception e) &#123;                e.printStackTrace();            &#125;        &#125;, <span class="string">&quot;AA&quot;</span>).start();        Thread.sleep(<span class="number">100</span>);        <span class="keyword">new</span> <span class="title class_">Thread</span>(() -&gt; &#123;            <span class="keyword">try</span> &#123;                phone.sendEmail();            &#125; <span class="keyword">catch</span> (Exception e) &#123;                e.printStackTrace();            &#125;        &#125;, <span class="string">&quot;BB&quot;</span>).start();    &#125;&#125;</code></pre><p>打印结果：</p><pre><code class="highlight shell">------sendSMS------sendEmail</code></pre><p>分析：synchronized 在静态方法上，是类级别的锁，所以两个方法持有的是同一把锁，要按顺序执行</p></li><li><p>两个静态同步方法，2部手机，先打印短信还是邮件</p><pre><code class="highlight java"><span class="keyword">class</span> <span class="title class_">Phone</span> &#123;    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title function_">sendSMS</span><span class="params">()</span> <span class="keyword">throws</span> Exception &#123;        <span class="comment">//停留4秒</span>        TimeUnit.SECONDS.sleep(<span class="number">4</span>);        System.out.println(<span class="string">&quot;------sendSMS&quot;</span>);    &#125;    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title function_">sendEmail</span><span class="params">()</span> <span class="keyword">throws</span> Exception &#123;        System.out.println(<span class="string">&quot;------sendEmail&quot;</span>);    &#125;&#125;<span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Lock_8</span> &#123;    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception &#123;        <span class="type">Phone</span> <span class="variable">phone</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Phone</span>();        <span class="type">Phone</span> <span class="variable">phone2</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Phone</span>();        <span class="keyword">new</span> <span class="title class_">Thread</span>(() -&gt; &#123;            <span class="keyword">try</span> &#123;                phone.sendSMS();            &#125; <span class="keyword">catch</span> (Exception e) &#123;                e.printStackTrace();            &#125;        &#125;, <span class="string">&quot;AA&quot;</span>).start();        Thread.sleep(<span class="number">100</span>);        <span class="keyword">new</span> <span class="title class_">Thread</span>(() -&gt; &#123;            <span class="keyword">try</span> &#123;                phone2.sendEmail();            &#125; <span class="keyword">catch</span> (Exception e) &#123;                e.printStackTrace();            &#125;        &#125;, <span class="string">&quot;BB&quot;</span>).start();    &#125;&#125;</code></pre><p>打印结果：</p><pre><code class="highlight shell">------sendSMS------sendEmail</code></pre><p>分析：synchronized 在静态方法上，是类级别的锁，所以两个方法持有的是同一把锁，要按顺序执行</p></li><li><p>1个静态同步方法,1个普通同步方法，1部手机，先打印短信还是邮件</p><pre><code class="highlight java"><span class="keyword">class</span> <span class="title class_">Phone</span> &#123;    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title function_">sendSMS</span><span class="params">()</span> <span class="keyword">throws</span> Exception &#123;        <span class="comment">//停留4秒</span>        TimeUnit.SECONDS.sleep(<span class="number">4</span>);        System.out.println(<span class="string">&quot;------sendSMS&quot;</span>);    &#125;    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">getHello</span><span class="params">()</span> &#123;        System.out.println(<span class="string">&quot;------getHello&quot;</span>);    &#125;&#125;<span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Lock_8</span> &#123;    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception &#123;        <span class="type">Phone</span> <span class="variable">phone</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Phone</span>();        <span class="keyword">new</span> <span class="title class_">Thread</span>(() -&gt; &#123;            <span class="keyword">try</span> &#123;                phone.sendSMS();            &#125; <span class="keyword">catch</span> (Exception e) &#123;                e.printStackTrace();            &#125;        &#125;, <span class="string">&quot;AA&quot;</span>).start();        Thread.sleep(<span class="number">100</span>);        <span class="keyword">new</span> <span class="title class_">Thread</span>(() -&gt; &#123;            <span class="keyword">try</span> &#123;                phone.getHello();            &#125; <span class="keyword">catch</span> (Exception e) &#123;                e.printStackTrace();            &#125;        &#125;, <span class="string">&quot;BB&quot;</span>).start();    &#125;&#125;</code></pre><p>打印结果：</p><pre><code class="highlight shell">------getHello------sendSMS</code></pre><p>分析：类加锁对普通方法无限制，普通方法调用即执行。</p></li><li><p>1个静态同步方法,1个普通同步方法，2部手机，先打印短信还是邮件</p><pre><code class="highlight java"><span class="keyword">class</span> <span class="title class_">Phone</span> &#123;    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title function_">sendSMS</span><span class="params">()</span> <span class="keyword">throws</span> Exception &#123;        <span class="comment">//停留4秒</span>        TimeUnit.SECONDS.sleep(<span class="number">4</span>);        System.out.println(<span class="string">&quot;------sendSMS&quot;</span>);    &#125;    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">sendEmail</span><span class="params">()</span> <span class="keyword">throws</span> Exception &#123;        System.out.println(<span class="string">&quot;------sendEmail&quot;</span>);    &#125;&#125;<span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Lock_8</span> &#123;    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception &#123;        <span class="type">Phone</span> <span class="variable">phone</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Phone</span>();        <span class="type">Phone</span> <span class="variable">phone2</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Phone</span>();        <span class="keyword">new</span> <span class="title class_">Thread</span>(() -&gt; &#123;            <span class="keyword">try</span> &#123;                phone.sendSMS();            &#125; <span class="keyword">catch</span> (Exception e) &#123;                e.printStackTrace();            &#125;        &#125;, <span class="string">&quot;AA&quot;</span>).start();        Thread.sleep(<span class="number">100</span>);        <span class="keyword">new</span> <span class="title class_">Thread</span>(() -&gt; &#123;            <span class="keyword">try</span> &#123;                phone2.sendEmail();            &#125; <span class="keyword">catch</span> (Exception e) &#123;                e.printStackTrace();            &#125;        &#125;, <span class="string">&quot;BB&quot;</span>).start();    &#125;&#125;</code></pre><p>打印结果：</p><pre><code class="highlight shell">------sendEmail------sendSMS</code></pre><p>分析：类加锁对普通方法无限制，普通方法调用即执行。</p></li></ol><p><strong>总结：</strong></p><ul><li>synchronized 锁的是方法，则是对象锁，同个对象锁的机制要等待，不同对象锁的机制调用同一个不用等待</li><li>加了static则为class锁而不是对象锁</li><li>对于同步方法块，锁是 synchronized 括号里配置对象</li></ul><h1 id="三、字节码角度分析-synchronized-实现"><a href="#三、字节码角度分析-synchronized-实现" class="headerlink" title="三、字节码角度分析 synchronized 实现"></a>三、字节码角度分析 synchronized 实现</h1><h2 id="1-synchronized-同步代码块"><a href="#1-synchronized-同步代码块" class="headerlink" title="1. synchronized 同步代码块"></a>1. synchronized 同步代码块</h2><h3 id="1-1-文件反编译技巧"><a href="#1-1-文件反编译技巧" class="headerlink" title="1.1 文件反编译技巧"></a>1.1 文件反编译技巧</h3><ul><li><p>文件反编译 <code>javap -c ***.class</code> 文件反编译，-c表示对代码进行反汇编</p></li><li><p>假如需要更多信息 <code>javap -v ***.class</code> ，-v 即 -verbose 输出附加信息（包括行号、本地变量表、反汇编等详细信息）</p></li></ul><h3 id="1-2-synchronized-同步代码块"><a href="#1-2-synchronized-同步代码块" class="headerlink" title="1.2 synchronized 同步代码块"></a>1.2 synchronized 同步代码块</h3><pre><code class="highlight java"><span class="comment">/**</span><span class="comment"> * 锁同步代码块</span><span class="comment"> */</span><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">LockSyncDemo</span> &#123;    <span class="type">Object</span> <span class="variable">object</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Object</span>();    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">m1</span><span class="params">()</span>&#123;        <span class="keyword">synchronized</span> (object)&#123;            System.out.println(<span class="string">&quot;-----hello synchronized code block&quot;</span>);        &#125;    &#125;    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;    &#125;&#125;</code></pre><h3 id="1-3-class-文件反编译"><a href="#1-3-class-文件反编译" class="headerlink" title="1.3 class 文件反编译"></a>1.3 class 文件反编译</h3><p>执行命令 <code>javap -c LockSyncDemo.class</code></p><pre><code class="highlight shell">public class com.georg.controller.LockSyncDemo &#123;  java.lang.Object object;  public com.zhang.admin.controller.LockSyncDemo();    Code:       0: aload_0       1: invokespecial #1                  // Method java/lang/Object.&quot;&lt;init&gt;&quot;:()V       4: aload_0       5: new           #2                  // class java/lang/Object       8: dup       9: invokespecial #1                  // Method java/lang/Object.&quot;&lt;init&gt;&quot;:()V      12: putfield      #3                  // Field object:Ljava/lang/Object;      15: return  public void m1();    Code:       0: aload_0       1: getfield      #3                  // Field object:Ljava/lang/Object;       4: dup       5: astore_1       6: monitorenter        //**注****------进入锁       7: getstatic     #4                  // Field java/lang/System.out:Ljava/io/PrintStream;      10: ldc           #5                  // String -----hello synchronized code block      12: invokevirtual #6                  // Method java/io/PrintStream.println:(Ljava/lang/String;)V      15: aload_1      16: monitorexit        // **注**------退出锁      17: goto          25      20: astore_2      21: aload_1      22: monitorexit        //**注**-----这里又有一个exit, 目的当出现异常时，保证能够释放锁      23: aload_2      24: athrow      25: return    Exception table:       from    to  target type           7    17    20   any          20    23    20   any  public static void main(java.lang.String[]);    Code:       0: return&#125;</code></pre><p><strong>总结</strong></p><ul><li>synchronized 同步代码块，实现使用的是<code>moniterenter</code> 和 <code>moniterexit</code> 指令（ <code>moniterexit</code> 可能有两个）</li><li>那一定是一个enter两个exit吗？（不一样，如果主动throw一个RuntimeException，发现一个enter，一个exit，还有两个athrow）</li></ul><h2 id="2-synchronized-普通同步方法"><a href="#2-synchronized-普通同步方法" class="headerlink" title="2. synchronized 普通同步方法"></a>2. synchronized 普通同步方法</h2><pre><code class="highlight java"><span class="comment">/**</span><span class="comment"> * 锁普通的同步方法</span><span class="comment"> */</span><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">LockSyncDemo</span> &#123;    <span class="keyword">public</span> <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title function_">m2</span><span class="params">()</span>&#123;        System.out.println(<span class="string">&quot;------hello synchronized m2&quot;</span>);    &#125;    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;    &#125;&#125;</code></pre><ul><li>类似于上述操作，最后调用 <code>javap -v LockSyncDemo.class</code></li></ul><pre><code class="highlight java">.....<span class="keyword">public</span> <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title function_">m2</span><span class="params">()</span>;    descriptor: ()V    flags: ACC_PUBLIC, ACC_SYNCHRONIZED <span class="comment">//请注意该标志</span>    Code:      stack=<span class="number">2</span>, locals=<span class="number">1</span>, args_size=<span class="number">1</span>         <span class="number">0</span>: getstatic     #<span class="number">2</span>                  <span class="comment">// Field java/lang/System.out:Ljava/io/PrintStream;</span>         <span class="number">3</span>: ldc           #<span class="number">3</span>                  <span class="comment">// String ------hello synchronized m2</span>         <span class="number">5</span>: invokevirtual #<span class="number">4</span>                  <span class="comment">// Method java/io/PrintStream.println:(Ljava/lang/String;)V</span>         <span class="number">8</span>: <span class="keyword">return</span>      LineNumberTable:        line <span class="number">11</span>: <span class="number">0</span>        line <span class="number">12</span>: <span class="number">8</span>      LocalVariableTable:        Start  Length  Slot  Name   Signature            <span class="number">0</span>       <span class="number">9</span>     <span class="number">0</span>  <span class="built_in">this</span>   Lcom/zhang/admin/controller/LockSyncDemo;......</code></pre><p><strong>总结</strong></p><p>调用指令将会检查方法的 <strong>ACC_SYNCHRONIZED</strong> 访问标志是否被设置。如果设置了，执行线程会先持有monitor, 然后再执行方法，最后在方法完成（无论是正常完成还是非正常完成）时释放monitor</p><h2 id="3-synchronized-静态同步方法"><a href="#3-synchronized-静态同步方法" class="headerlink" title="3. synchronized 静态同步方法"></a>3. synchronized 静态同步方法</h2><pre><code class="highlight java"><span class="comment">/**</span><span class="comment"> * 锁静态同步方法</span><span class="comment"> */</span><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">LockSyncDemo</span> &#123;    <span class="keyword">public</span> <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title function_">m2</span><span class="params">()</span>&#123;        System.out.println(<span class="string">&quot;------hello synchronized m2&quot;</span>);    &#125;    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title function_">m3</span><span class="params">()</span>&#123;        System.out.println(<span class="string">&quot;------hello synchronized m3---static&quot;</span>);    &#125;    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;    &#125;&#125;</code></pre><ul><li>调用 <code>javap -v LockSyncDemo.class</code></li></ul><pre><code class="highlight shell"> ...... public static synchronized void m3();    descriptor: ()V    flags: ACC_PUBLIC, ACC_STATIC, ACC_SYNCHRONIZED //访问标志 区分该方法是否是静态同步方法    Code:      stack=2, locals=0, args_size=0         0: getstatic     #2                  // Field java/lang/System.out:Ljava/io/PrintStream;         3: ldc           #5                  // String ------hello synchronized m3---static         5: invokevirtual #4                  // Method java/io/PrintStream.println:(Ljava/lang/String;)V         8: return      LineNumberTable:        line 15: 0        line 16: 8......</code></pre><p><strong>总结</strong></p><p><strong>ACC_STATIC</strong> 访问标志区分该方法是否是静态同步方法。</p><h1 id="四、反编译解析-synchronized-锁的是什么"><a href="#四、反编译解析-synchronized-锁的是什么" class="headerlink" title="四、反编译解析 synchronized 锁的是什么"></a>四、反编译解析 synchronized 锁的是什么</h1><h2 id="1-管程概念"><a href="#1-管程概念" class="headerlink" title="1. 管程概念"></a>1. 管程概念</h2><ul><li>管程：Monitor（监视器），也就是我们平时说的锁。监视器锁</li><li>信号量及其操作原语“封装”在一个对象内部）管程实现了在一个时间点，最多只有一个线程在执行管程的某个子程序。 管程提供了一种机制，管程可以看做一个软件模块，它是将共享的变量和对于这些共享变量的操作封装起来，形成一个具有一定接口的功能模块，进程可以调用管程来实现线程级别的并发控制。</li><li>执行线程就要求先成功持有管程，然后才能执行方法，最后当方法完成（无论是正常完成还是非正常完成）时释放管理。在方法执行期间，执行线程持有了管程，其他任何线程都无法再获取到同一个管程。</li></ul><h2 id="2-解释为什么任何一个对象都可以成为一个锁"><a href="#2-解释为什么任何一个对象都可以成为一个锁" class="headerlink" title="2. 解释为什么任何一个对象都可以成为一个锁"></a>2. 解释为什么任何一个对象都可以成为一个锁</h2><p>Java Object 类是所有类的父类，也就是说 Java 的所有类都继承了 Object，子类可以使用 Object 的所有方法。</p><ul><li><code>ObjectMonitor.java</code> → <code>ObjectMonitor.cpp</code> → <code>objectMonitor.hpp</code></li></ul><p><code>ObjectMonitor.cpp</code> 中引入了头文件（include）<code>objectMonitor.hpp</code></p><p><img src="https://raw.githubusercontent.com/GeorgeChan95/blogimg/master/img/2024/09/21/20240921-153217.png" alt="objectMonitor.hpp"></p><ul><li><p><strong>objectMonitor.hpp</strong></p><table><thead><tr><th>属性</th><th>作用</th></tr></thead><tbody><tr><td>_owner</td><td>指向持有ObjectMonitor对象的线程</td></tr><tr><td>_WaitSet</td><td>存放处于wait状态的线程队列</td></tr><tr><td>_EntryList</td><td>存放处于等待锁block状态的线程队列</td></tr><tr><td>_recursions</td><td>锁的重入次数</td></tr><tr><td>_count</td><td>用来记录该线程获取锁的次数</td></tr></tbody></table><p><strong>因此：每个对象天生都带着一个对象监视器</strong></p></li></ul><h1 id="五、关于锁升级"><a href="#五、关于锁升级" class="headerlink" title="五、关于锁升级"></a>五、关于锁升级</h1><p>这里只是简单提及，做个了解，后面会再做深入讲解</p><p>synchronized必须作用于某个对象中，所以Java在对象的头文件存储了锁的相关信息。锁升级功能主要依赖于 MarkWord 中的锁标志位和释放偏向锁标志位。</p><p><img src="https://raw.githubusercontent.com/GeorgeChan95/blogimg/master/img/2024/09/21/20240921-153834.png" alt="锁升级"></p><h1 id="六、公平锁和非公平锁"><a href="#六、公平锁和非公平锁" class="headerlink" title="六、公平锁和非公平锁"></a>六、公平锁和非公平锁</h1><h2 id="1-案例演示"><a href="#1-案例演示" class="headerlink" title="1. 案例演示"></a>1. 案例演示</h2><h3 id="1-1-非公平锁"><a href="#1-1-非公平锁" class="headerlink" title="1.1 非公平锁"></a>1.1 非公平锁</h3><p>使用 ReentrantLock 实现抢票的案例</p><pre><code class="highlight java"><span class="keyword">class</span> <span class="title class_">Ticket</span> &#123;    <span class="keyword">private</span> <span class="type">int</span> <span class="variable">number</span> <span class="operator">=</span> <span class="number">30</span>;    <span class="keyword">private</span> <span class="type">Lock</span> <span class="variable">lock</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ReentrantLock</span>(); <span class="comment">//默认用的是非公平锁，分配的平均一点，=--》公平一点</span>    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">sale</span><span class="params">()</span> &#123;        lock.lock();        <span class="keyword">try</span> &#123;            <span class="keyword">if</span> (number &gt; <span class="number">0</span>) &#123;                System.out.println(Thread.currentThread().getName() + <span class="string">&quot;\t 卖出第: &quot;</span> + (number--) + <span class="string">&quot;\t 还剩下: &quot;</span> + number);            &#125;        &#125; <span class="keyword">finally</span> &#123;            lock.unlock();        &#125;    &#125;&#125;<span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">SaleTicketDemo</span> &#123;    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;        <span class="type">Ticket</span> <span class="variable">ticket</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Ticket</span>();        <span class="keyword">new</span> <span class="title class_">Thread</span>(() -&gt; &#123;<span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">1</span>; i &lt;= <span class="number">55</span>; i++) ticket.sale();&#125;, <span class="string">&quot;a&quot;</span>).start();        <span class="keyword">new</span> <span class="title class_">Thread</span>(() -&gt; &#123;<span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">1</span>; i &lt;= <span class="number">55</span>; i++) ticket.sale();&#125;, <span class="string">&quot;b&quot;</span>).start();        <span class="keyword">new</span> <span class="title class_">Thread</span>(() -&gt; &#123;<span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">1</span>; i &lt;= <span class="number">55</span>; i++) ticket.sale();&#125;, <span class="string">&quot;c&quot;</span>).start();    &#125;&#125;</code></pre><p>运行结果，不同的线程抢到票的几率差距很大，线程执行不公平。</p><pre><code class="highlight shell">a 卖出第: 30 还剩下: 29a 卖出第: 29 还剩下: 28a 卖出第: 28 还剩下: 27a 卖出第: 27 还剩下: 26c 卖出第: 26 还剩下: 25c 卖出第: 25 还剩下: 24c 卖出第: 24 还剩下: 23c 卖出第: 23 还剩下: 22c 卖出第: 22 还剩下: 21c 卖出第: 21 还剩下: 20c 卖出第: 20 还剩下: 19c 卖出第: 19 还剩下: 18c 卖出第: 18 还剩下: 17c 卖出第: 17 还剩下: 16c 卖出第: 16 还剩下: 15c 卖出第: 15 还剩下: 14c 卖出第: 14 还剩下: 13c 卖出第: 13 还剩下: 12c 卖出第: 12 还剩下: 11c 卖出第: 11 还剩下: 10c 卖出第: 10 还剩下: 9c 卖出第: 9 还剩下: 8c 卖出第: 8 还剩下: 7c 卖出第: 7 还剩下: 6c 卖出第: 6 还剩下: 5c 卖出第: 5 还剩下: 4c 卖出第: 4 还剩下: 3c 卖出第: 3 还剩下: 2c 卖出第: 2 还剩下: 1c 卖出第: 1 还剩下: 0</code></pre><h3 id="1-2-公平锁"><a href="#1-2-公平锁" class="headerlink" title="1.2 公平锁"></a>1.2 公平锁</h3><p>使用 ReentrantLock 实现公平抢票的案例</p><pre><code class="highlight java"><span class="keyword">class</span> <span class="title class_">Ticket</span> &#123;    <span class="keyword">private</span> <span class="type">int</span> <span class="variable">number</span> <span class="operator">=</span> <span class="number">30</span>;    <span class="keyword">private</span> <span class="type">Lock</span> <span class="variable">lock</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ReentrantLock</span>(<span class="literal">true</span>); <span class="comment">//默认用的是非公平锁，传 true 则为公平锁</span>    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">sale</span><span class="params">()</span> &#123;        lock.lock();        <span class="keyword">try</span> &#123;            <span class="keyword">if</span> (number &gt; <span class="number">0</span>) &#123;                System.out.println(Thread.currentThread().getName() + <span class="string">&quot;\t 卖出第: &quot;</span> + (number--) + <span class="string">&quot;\t 还剩下: &quot;</span> + number);            &#125;        &#125; <span class="keyword">finally</span> &#123;            lock.unlock();        &#125;    &#125;&#125;<span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">SaleTicketDemo</span> &#123;    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;        <span class="type">Ticket</span> <span class="variable">ticket</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Ticket</span>();        <span class="keyword">new</span> <span class="title class_">Thread</span>(() -&gt; &#123;<span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">1</span>; i &lt;= <span class="number">55</span>; i++) ticket.sale();&#125;, <span class="string">&quot;a&quot;</span>).start();        <span class="keyword">new</span> <span class="title class_">Thread</span>(() -&gt; &#123;<span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">1</span>; i &lt;= <span class="number">55</span>; i++) ticket.sale();&#125;, <span class="string">&quot;b&quot;</span>).start();        <span class="keyword">new</span> <span class="title class_">Thread</span>(() -&gt; &#123;<span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">1</span>; i &lt;= <span class="number">55</span>; i++) ticket.sale();&#125;, <span class="string">&quot;c&quot;</span>).start();    &#125;&#125;</code></pre><p>执行结果，每个线程都得到了较为公平的执行机会。</p><pre><code class="highlight shell">a 卖出第: 30 还剩下: 29a 卖出第: 29 还剩下: 28a 卖出第: 28 还剩下: 27a 卖出第: 27 还剩下: 26b 卖出第: 26 还剩下: 25c 卖出第: 25 还剩下: 24a 卖出第: 24 还剩下: 23b 卖出第: 23 还剩下: 22c 卖出第: 22 还剩下: 21a 卖出第: 21 还剩下: 20b 卖出第: 20 还剩下: 19c 卖出第: 19 还剩下: 18a 卖出第: 18 还剩下: 17b 卖出第: 17 还剩下: 16c 卖出第: 16 还剩下: 15a 卖出第: 15 还剩下: 14b 卖出第: 14 还剩下: 13c 卖出第: 13 还剩下: 12a 卖出第: 12 还剩下: 11b 卖出第: 11 还剩下: 10c 卖出第: 10 还剩下: 9a 卖出第: 9 还剩下: 8b 卖出第: 8 还剩下: 7c 卖出第: 7 还剩下: 6a 卖出第: 6 还剩下: 5b 卖出第: 5 还剩下: 4c 卖出第: 4 还剩下: 3a 卖出第: 3 还剩下: 2b 卖出第: 2 还剩下: 1c 卖出第: 1 还剩下: 0</code></pre><h2 id="2-公平锁-非公平锁-概念解析"><a href="#2-公平锁-非公平锁-概念解析" class="headerlink" title="2. 公平锁&#x2F;非公平锁 概念解析"></a>2. 公平锁&#x2F;非公平锁 概念解析</h2><ul><li>公平锁：是指多个线程按照申请锁的顺序来获取锁，这里类似于排队买票，先来的人先买，后来的人再队尾排着，这是公平的—– Lock lock &#x3D; new ReentrantLock(true)—表示公平锁，先来先得。</li><li>非公平锁：是指多个线程获取锁的顺序并不是按照申请的顺序，有可能后申请的线程比先申请的线程优先获取锁，在高并发环境下，有可能造成优先级反转或者饥饿的状态（某个线程一直得不到锁）—- Lock lock &#x3D; new  ReentrantLock(false)—表示非公平锁，后来的也可能先获得锁，默认为非公平锁。</li></ul><h2 id="3-关于-公平锁-非公平锁-的相关问题"><a href="#3-关于-公平锁-非公平锁-的相关问题" class="headerlink" title="3. 关于 公平锁&#x2F;非公平锁 的相关问题"></a>3. 关于 公平锁&#x2F;非公平锁 的相关问题</h2><h3 id="3-1-为什么会有公平锁-非公平锁的设计为什么默认非公平？"><a href="#3-1-为什么会有公平锁-非公平锁的设计为什么默认非公平？" class="headerlink" title="3.1 为什么会有公平锁&#x2F;非公平锁的设计为什么默认非公平？"></a>3.1 为什么会有公平锁&#x2F;非公平锁的设计为什么默认非公平？</h3><ul><li>恢复挂起的线程到真正锁的获取还是有时间差的，从开发人员来看这个时间微乎其微，但是从CPU的角度来看，这个时间差存在的还是很明显的。所以非公平锁能更充分的利用CPU 的时间片，尽量减少 CPU 空闲状态时间。</li><li>使用多线程很重要的考量点是线程切换的开销，当采用非公平锁时，当1个线程请求锁获取同步状态，然后释放同步状态，因为不需要考虑是否还有前驱节点，所以刚释放锁的线程在此刻再次获取同步状态的概率就变得非常大，所以就减少了线程的开销。</li></ul><h3 id="3-2-使⽤公平锁会有什么问题"><a href="#3-2-使⽤公平锁会有什么问题" class="headerlink" title="3.2 使⽤公平锁会有什么问题"></a>3.2 使⽤公平锁会有什么问题</h3><p>公平锁保证了排队的公平性，非公平锁霸气的忽视这个规则，所以就有可能导致排队的长时间在排队，也没有机会获取到锁，这就是传说中的 “锁饥饿”</p><h3 id="3-3-什么时候用公平？什么时候用非公平？"><a href="#3-3-什么时候用公平？什么时候用非公平？" class="headerlink" title="3.3 什么时候用公平？什么时候用非公平？"></a>3.3 什么时候用公平？什么时候用非公平？</h3><ul><li>如果为了更高的吞吐量，很显然非公平锁是比较合适的，因为节省很多线程切换时间，吞吐量自然就上去了；</li><li>否则那就用公平锁，大家公平使用。</li></ul><h1 id="七、可重入锁"><a href="#七、可重入锁" class="headerlink" title="七、可重入锁"></a>七、可重入锁</h1><h2 id="1-概念解析"><a href="#1-概念解析" class="headerlink" title="1. 概念解析"></a>1. 概念解析</h2><p><strong>可重入锁又名递归锁</strong></p><ul><li><p>是指在同一个线程在外层方法获取锁的时候，再进入该线程的内层方法会自动获取锁(前提，锁对象得是同一个对象)，不会因为之前已经获取过还没释放而阻塞。</p></li><li><p>如果是1个有 <code>synchronized</code> 修饰的递归调用方法，程序第2次进入被自己阻塞了这样递归方法也就不能继续执行下去了。所以Java中 <code>ReentrantLock</code> 和<code>synchronized</code> 都是可重入锁，可重入锁的一个优点是可一定程度避免死锁。</p></li></ul><h2 id="2-可重入锁种类"><a href="#2-可重入锁种类" class="headerlink" title="2. 可重入锁种类"></a>2. 可重入锁种类</h2><h3 id="2-1-隐式锁"><a href="#2-1-隐式锁" class="headerlink" title="2.1 隐式锁"></a>2.1 隐式锁</h3><p>隐式锁（即synchronized关键字使用的锁）默认是可重入锁</p><ul><li><p>作用于同步代码块</p><pre><code class="highlight java"><span class="keyword">static</span> <span class="type">Object</span> <span class="variable">objectLock</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Object</span>();<span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">syncBlock</span><span class="params">()</span>&#123;    <span class="keyword">new</span> <span class="title class_">Thread</span>(() -&gt; &#123;        <span class="keyword">synchronized</span> (objectLock) &#123;<span class="comment">// lock</span>            System.out.println(<span class="string">&quot;-----外层&quot;</span>);            <span class="keyword">synchronized</span> (objectLock)            &#123;                System.out.println(<span class="string">&quot;-----中层&quot;</span>);                <span class="keyword">synchronized</span> (objectLock)                &#123;                    System.out.println(<span class="string">&quot;-----内层&quot;</span>);                &#125;            &#125;        &#125;<span class="comment">//unlock</span>    &#125;,<span class="string">&quot;t1&quot;</span>).start();&#125;</code></pre><p>打印结果：</p><pre><code class="highlight plaintext">-----外层-----中层-----内层</code></pre></li><li><p>作用于同步方法中</p><pre><code class="highlight java"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ReEntryLockDemo</span>&#123;    <span class="keyword">public</span> <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title function_">m1</span><span class="params">()</span>    &#123;        <span class="comment">//指的是可重复可递归调用的锁，在外层使用之后，在内层仍然可以使用，并且不发生死锁，这样的锁就叫做可重入锁</span>        System.out.println(Thread.currentThread().getName()+<span class="string">&quot;\t&quot;</span>+<span class="string">&quot;-----come in m1&quot;</span>);        m2();        System.out.println(Thread.currentThread().getName()+<span class="string">&quot;\t-----end m1&quot;</span>);    &#125;    <span class="keyword">public</span> <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title function_">m2</span><span class="params">()</span>    &#123;        System.out.println(<span class="string">&quot;-----m2&quot;</span>);        m3();    &#125;    <span class="keyword">public</span> <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title function_">m3</span><span class="params">()</span>    &#123;        System.out.println(<span class="string">&quot;-----m3&quot;</span>);    &#125;    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span>    &#123;        <span class="type">ReEntryLockDemo</span> <span class="variable">reEntryLockDemo</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ReEntryLockDemo</span>();        reEntryLockDemo.m1();    &#125;&#125;<span class="comment">/**</span><span class="comment"> * main  -----come in m1</span><span class="comment"> * -----m2</span><span class="comment"> * -----m3</span><span class="comment"> * main  -----end m1</span><span class="comment"> */</span></code></pre><p>打印结果：</p><pre><code class="highlight java">main  -----come in m1-----m2-----m3main  -----end m1</code></pre></li><li></li></ul><h3 id="2-2-显式锁"><a href="#2-2-显式锁" class="headerlink" title="2.2 显式锁"></a>2.2 显式锁</h3><p>显式锁（即Lock）也有 ReentrantLock 这样的可重入锁。</p><ul><li>ReentrantLock 实现的显示可重入锁</li></ul><pre><code class="highlight java"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;    <span class="type">Lock</span> <span class="variable">lock</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ReentrantLock</span>();    <span class="keyword">new</span> <span class="title class_">Thread</span>(() -&gt; &#123;        lock.lock();        <span class="keyword">try</span> &#123;            System.out.println(Thread.currentThread().getName() + <span class="string">&quot;\t&quot;</span> + <span class="string">&quot;-----外层&quot;</span>);            lock.lock();            <span class="keyword">try</span> &#123;                System.out.println(Thread.currentThread().getName() + <span class="string">&quot;\t&quot;</span> + <span class="string">&quot;-----内层&quot;</span>);            &#125; <span class="keyword">finally</span> &#123;                lock.unlock();            &#125;        &#125; <span class="keyword">finally</span> &#123;            lock.unlock();        &#125;    &#125;, <span class="string">&quot;t1&quot;</span>).start();    <span class="keyword">new</span> <span class="title class_">Thread</span>(() -&gt; &#123;        lock.lock();        <span class="keyword">try</span> &#123;            System.out.println(<span class="string">&quot;------22222&quot;</span>);        &#125; <span class="keyword">finally</span> &#123;            lock.unlock();        &#125;    &#125;, <span class="string">&quot;t2&quot;</span>).start();&#125;</code></pre><p>打印结果：</p><pre><code class="highlight shell">t1-----外层t1-----内层------22222</code></pre><h2 id="3-Synchronized的可重入锁实现机理"><a href="#3-Synchronized的可重入锁实现机理" class="headerlink" title="3. Synchronized的可重入锁实现机理"></a>3. Synchronized的可重入锁实现机理</h2><p>再看 <code>ObjectMoitor.hpp</code></p><pre><code class="highlight cpp"><span class="number">140</span>行  <span class="built_in">ObjectMonitor</span>() &#123;    _header       = <span class="literal">NULL</span>;    _count        = <span class="number">0</span>; <span class="comment">//用来记录该线程获取锁的次数</span>    _waiters      = <span class="number">0</span>,    _recursions   = <span class="number">0</span>; <span class="comment">//锁的重入次数</span>    _object       = <span class="literal">NULL</span>;    _owner        = <span class="literal">NULL</span>; <span class="comment">//------最重要的----指向持有ObjectMonitor对象的线程，记录哪个线程持有了我</span>    _WaitSet      = <span class="literal">NULL</span>; <span class="comment">//存放处于wait状态的线程队列</span>    _WaitSetLock  = <span class="number">0</span> ;    _Responsible  = <span class="literal">NULL</span> ;    _succ         = <span class="literal">NULL</span> ;    _cxq          = <span class="literal">NULL</span> ;    FreeNext      = <span class="literal">NULL</span> ;    _EntryList    = <span class="literal">NULL</span> ; <span class="comment">//存放处于等待锁block状态的线程队列</span>    _SpinFreq     = <span class="number">0</span> ;    _SpinClock    = <span class="number">0</span> ;    OwnerIsThread = <span class="number">0</span> ;    _previous_owner_tid = <span class="number">0</span>;  &#125;</code></pre><ul><li><code>ObjectMoitor.hpp</code><strong>底层</strong>：每个锁对象拥有一个锁计数器和一个指向持有该锁的线程的指针。<code>_count</code> <code>_owner</code></li><li><strong>首次加锁</strong>：当执行<code>monitorenter</code>时，如果目标锁对象的计数器为零，那么说明它没有被其他线程所持有，Java虚拟机会将该锁对象的持有线程设置为当前线程，并且将其计数器<code>加1</code>。</li><li><strong>重入</strong>：在目标锁对象的计数器不为零的情况下，如果锁对象的持有线程是当前线程，那么 Java 虚拟机可以将其计数器<code>加1</code>，否则需要等待，直至持有线程释放该锁。</li><li><strong>释放锁</strong>：当执行monitorexit时，Java虚拟机则需将锁对象的计数器减1。计数器为零代表锁已被释放。</li></ul><h2 id="4-死锁及排查"><a href="#4-死锁及排查" class="headerlink" title="4. 死锁及排查"></a>4. 死锁及排查</h2><h3 id="4-1-死锁是什么"><a href="#4-1-死锁是什么" class="headerlink" title="4.1 死锁是什么"></a>4.1 死锁是什么</h3><p>死锁是指两个或两个以上的线程在执行过程中,因争夺资源而造成的一种互相等待的现象,若无外力干涉那它们都将无法推进下去，如果系统资源充足，进程的资源请求都能够得到满足，死锁出现的可能性就很低，否则就会因争夺有限的资源而陷入死锁。</p><p><img src="https://raw.githubusercontent.com/GeorgeChan95/blogimg/master/img/2024/09/21/20240921-163418.png" alt="死锁"></p><h3 id="4-2-死锁产生的原因"><a href="#4-2-死锁产生的原因" class="headerlink" title="4.2 死锁产生的原因"></a>4.2 死锁产生的原因</h3><ul><li>系统资源不足</li><li>进程运行推进的顺序不合适</li><li>资源分配不当</li></ul><h3 id="4-3-死锁代码案例"><a href="#4-3-死锁代码案例" class="headerlink" title="4.3 死锁代码案例"></a>4.3 死锁代码案例</h3><pre><code class="highlight java"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">DeadLockDemo</span> &#123;    <span class="keyword">static</span> <span class="type">Object</span> <span class="variable">lockA</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Object</span>();    <span class="keyword">static</span> <span class="type">Object</span> <span class="variable">lockB</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Object</span>();    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;        <span class="type">Thread</span> <span class="variable">a</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Thread</span>(() -&gt; &#123;            <span class="keyword">synchronized</span> (lockA) &#123;                System.out.println(Thread.currentThread().getName() + <span class="string">&quot;\t&quot;</span> + <span class="string">&quot; 自己持有A锁，期待获得B锁&quot;</span>);                <span class="keyword">try</span> &#123;                    TimeUnit.SECONDS.sleep(<span class="number">1</span>);                &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;                    e.printStackTrace();                &#125;                <span class="keyword">synchronized</span> (lockB) &#123;                    System.out.println(Thread.currentThread().getName() + <span class="string">&quot;\t 获得B锁成功&quot;</span>);                &#125;            &#125;        &#125;, <span class="string">&quot;a&quot;</span>);        a.start();        <span class="keyword">new</span> <span class="title class_">Thread</span>(() -&gt; &#123;            <span class="keyword">synchronized</span> (lockB) &#123;                System.out.println(Thread.currentThread().getName() + <span class="string">&quot;\t&quot;</span> + <span class="string">&quot; 自己持有B锁，期待获得A锁&quot;</span>);                <span class="keyword">try</span> &#123;                    TimeUnit.SECONDS.sleep(<span class="number">1</span>);                &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;                    e.printStackTrace();                &#125;                <span class="keyword">synchronized</span> (lockA) &#123;                    System.out.println(Thread.currentThread().getName() + <span class="string">&quot;\t 获得A锁成功&quot;</span>);                &#125;            &#125;        &#125;, <span class="string">&quot;b&quot;</span>).start();    &#125;&#125;</code></pre><p>运行结果：</p><pre><code class="highlight shell">a 自己持有A锁，期待获得B锁b 自己持有B锁，期待获得A锁</code></pre><p>程序运行到此没有停止，一直等待着……</p><h3 id="4-4-如何排查死锁"><a href="#4-4-如何排查死锁" class="headerlink" title="4.4 如何排查死锁"></a>4.4 如何排查死锁</h3><h4 id="4-4-1-命令行"><a href="#4-4-1-命令行" class="headerlink" title="4.4.1 命令行"></a>4.4.1 命令行</h4><ul><li><code>jps -l</code> 查看当前进程运行状况</li><li><code>jstack 进程编号</code> 查看该进程信息</li></ul><pre><code class="highlight shell">PS F:\&gt; jps -l29104 33360 com.atguigu.juc.locks.DeadLockDemo11172 org.jetbrains.jps.cmdline.Launcher27412 org.jetbrains.idea.maven.server.RemoteMavenServer3630148 org.jetbrains.idea.maven.server.RemoteMavenServer3645796 sun.tools.jps.Jps<span class="meta prompt_"></span><span class="meta prompt_">#</span><span class="language-bash"><span class="comment">####################################################################################</span></span>PS F:\&gt; jstack 333602024-09-21 16:39:01Full thread dump Java HotSpot(TM) 64-Bit Server VM (25.241-b07 mixed mode):&quot;Finalizer&quot; #3 daemon prio=8 os_prio=1 tid=0x0000000026eea000 nid=0x8df0 in Object.wait() [0x000000002a8ff000]   java.lang.Thread.State: WAITING (on object monitor)        at java.lang.Object.wait(Native Method)        - waiting on &lt;0x0000000716508ee0&gt; (a java.lang.ref.ReferenceQueue$Lock)        at java.lang.ref.ReferenceQueue.remove(ReferenceQueue.java:144)        - locked &lt;0x0000000716508ee0&gt; (a java.lang.ref.ReferenceQueue$Lock)        at java.lang.ref.ReferenceQueue.remove(ReferenceQueue.java:165)        at java.lang.ref.Finalizer$FinalizerThread.run(Finalizer.java:216)&quot;Reference Handler&quot; #2 daemon prio=10 os_prio=2 tid=0x0000000028ba8000 nid=0x3cb4 in Object.wait() [0x000000002a7ff000]   java.lang.Thread.State: WAITING (on object monitor)        at java.lang.Object.wait(Native Method)        - waiting on &lt;0x0000000716506c00&gt; (a java.lang.ref.Reference$Lock)        at java.lang.Object.wait(Object.java:502)        at java.lang.ref.Reference.tryHandlePending(Reference.java:191)        - locked &lt;0x0000000716506c00&gt; (a java.lang.ref.Reference$Lock)        at java.lang.ref.Reference$ReferenceHandler.run(Reference.java:153)&quot;VM Periodic Task Thread&quot; os_prio=2 tid=0x000000002b8e4000 nid=0x1378 waiting on conditionJNI global references: 317Found one Java-level deadlock:=============================&quot;b&quot;:  waiting to lock monitor 0x0000000028bab9f8 (object 0x00000007166f0fe8, a java.lang.Object),  which is held by &quot;a&quot;&quot;a&quot;:  waiting to lock monitor 0x0000000028bae338 (object 0x00000007166f0ff8, a java.lang.Object),  which is held by &quot;b&quot;Java stack information for the threads listed above:===================================================&quot;b&quot;:        at com.atguigu.juc.locks.DeadLockDemo.lambda$main$1(DeadLockDemo.java:44)        - waiting to lock &lt;0x00000007166f0fe8&gt; (a java.lang.Object)        - locked &lt;0x00000007166f0ff8&gt; (a java.lang.Object)        at com.atguigu.juc.locks.DeadLockDemo$$Lambda$2/1199823423.run(Unknown Source)        at java.lang.Thread.run(Thread.java:748)&quot;a&quot;:        at com.atguigu.juc.locks.DeadLockDemo.lambda$main$0(DeadLockDemo.java:27)        - waiting to lock &lt;0x00000007166f0ff8&gt; (a java.lang.Object)        - locked &lt;0x00000007166f0fe8&gt; (a java.lang.Object)        at com.atguigu.juc.locks.DeadLockDemo$$Lambda$1/1342443276.run(Unknown Source)        at java.lang.Thread.run(Thread.java:748)Found 1 deadlock.</code></pre><h4 id="4-4-2-图形化工具"><a href="#4-4-2-图形化工具" class="headerlink" title="4.4.2 图形化工具"></a>4.4.2 图形化工具</h4><p>这里使用JDK 自带的 <code>jconsole</code> 演示，此工具在jdk的安装的 <code>bin目录</code> 下，双击 jconsole.exe 打开即可。</p><p><img src="https://raw.githubusercontent.com/GeorgeChan95/blogimg/master/img/2024/09/21/20240921-164427.png" alt="image-20240921164426956"></p><h1 id="八、总结"><a href="#八、总结" class="headerlink" title="八、总结"></a>八、总结</h1><p>指针指向monitor对象（也称为管程或监视器锁）的起始地址。每个对象都存在着一个monitor与之关联，当一个monitor被某个线程持有后，它便处于锁定状态。在Java虚拟机(HotSpot)中，monitor是由ObjectMonitor实现的，其主要数据结构如下（位于HotSpot虚拟机源码ObjectMonitor.hpp,C++实现的）<br><img src="https://raw.githubusercontent.com/GeorgeChan95/blogimg/master/img/2024/09/21/20240921-165034.png" alt="锁"></p>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;一、乐观锁和悲观锁&quot;&gt;&lt;a href=&quot;#一、乐观锁和悲观锁&quot; class=&quot;headerlink&quot; title=&quot;一、乐观锁和悲观锁&quot;&gt;&lt;/a&gt;一、乐观锁和悲观锁&lt;/h1&gt;&lt;h2 id=&quot;1-悲观锁&quot;&gt;&lt;a href=&quot;#1-悲观锁&quot; class=&quot;header</summary>
      
    
    
    
    <category term="JUC" scheme="https://georgechan95.github.io/categories/JUC/"/>
    
    
    <category term="juc" scheme="https://georgechan95.github.io/tags/juc/"/>
    
    <category term="java" scheme="https://georgechan95.github.io/tags/java/"/>
    
  </entry>
  
  <entry>
    <title>02-JUC进阶-CompletableFuture</title>
    <link href="https://georgechan95.github.io/blog/7e2d78eb.html"/>
    <id>https://georgechan95.github.io/blog/7e2d78eb.html</id>
    <published>2024-09-18T14:50:00.000Z</published>
    <updated>2024-09-20T12:20:12.477Z</updated>
    
    <content type="html"><![CDATA[<h1 id="一、Future接口概述"><a href="#一、Future接口概述" class="headerlink" title="一、Future接口概述"></a>一、Future接口概述</h1><p>Future接口（FutureTask实现类）定义了操作异步任务执行一些方法，如获取异步任务的执行结果、取消异步任务的执行、判断任务是否被取消、判断任务执行是否完毕等。</p><p>举例：比如主线程让一个子线程去执行任务，子线程可能比较耗时，启动子线程开始执行任务后，主线程就去做其他事情了，忙完其他事情或者先执行完，过了一会再才去获取子任务的执行结果或变更的任务状态。</p><h1 id="二、Future接口实现类FutureTask"><a href="#二、Future接口实现类FutureTask" class="headerlink" title="二、Future接口实现类FutureTask"></a>二、Future接口实现类FutureTask</h1><h2 id="1-Future接口能干什么"><a href="#1-Future接口能干什么" class="headerlink" title="1. Future接口能干什么"></a>1. Future接口能干什么</h2><p>Future是 Java5 新加的一个接口，它提供一种异步并行计算的功能，如果主线程需要执行一个很耗时的计算任务，我们会就可以通过Future把这个任务放进异步线程中执行，主线程继续处理其他任务或者先行结束，再通过Future获取计算结果。</p><p>Future接口定义了操作异步任务执行一些方法，如获取异步任务的执行结果、取消任务的执行、判断任务是否被取消、判断任务执行是否完毕等。</p><h2 id="2-Future接口相关架构"><a href="#2-Future接口相关架构" class="headerlink" title="2. Future接口相关架构"></a>2. Future接口相关架构</h2><p><img src="https://raw.githubusercontent.com/GeorgeChan95/blogimg/master/img/2024/09/18/20240918-171237.png" alt="Future接口架构"></p><ul><li><p>目的：异步多线程任务执行且返回有结果，三个特点：多线程、有返回、异步任务（班长为老师去买水作为新启动的异步多线程任务且买到水有结果返回）</p></li><li><p>代码实现：Runnable接口+Callable接口+Future接口和FutureTask实现类。</p><pre><code class="highlight java"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">FutureTaskDemo3</span> &#123;    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> ExecutionException, InterruptedException &#123;        FutureTask&lt;String&gt; futureTask = <span class="keyword">new</span> <span class="title class_">FutureTask</span>&lt;&gt;(<span class="keyword">new</span> <span class="title class_">MyThread</span>());        <span class="type">Thread</span> <span class="variable">thread</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Thread</span>(futureTask, <span class="string">&quot;t1&quot;</span>);        <span class="comment">// 启动一个新的线程</span>        thread.start();        System.out.println(futureTask.get());    &#125;&#125;<span class="keyword">class</span> <span class="title class_">MyThread</span> <span class="keyword">implements</span> <span class="title class_">Callable</span>&lt;String&gt; &#123;    <span class="meta">@Override</span>    <span class="keyword">public</span> String <span class="title function_">call</span><span class="params">()</span> <span class="keyword">throws</span> Exception &#123;        System.out.println(Thread.currentThread().getName() + <span class="string">&quot; come in ......&quot;</span>);        <span class="keyword">return</span> <span class="string">&quot;Hello Callable&quot;</span>;    &#125;&#125;</code></pre></li></ul><h2 id="3-Future编码实战和优缺点分析"><a href="#3-Future编码实战和优缺点分析" class="headerlink" title="3. Future编码实战和优缺点分析"></a>3. Future编码实战和优缺点分析</h2><p><strong>优点</strong></p><p>Future+线程池异步多线程任务配合，能显著提高程序的运行效率。</p><p><strong>缺点</strong></p><ul><li>get() 阻塞—一旦调用get()方法求结果，一旦调用不见不散，非要等到结果才会离开，不管你是否计算完成，如果没有计算完成容易程序堵塞。</li></ul>  <pre><code class="highlight java"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">FutureTaskDemo1</span> &#123;    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> ExecutionException, InterruptedException, TimeoutException &#123;        FutureTask&lt;String&gt; futureTask = <span class="keyword">new</span> <span class="title class_">FutureTask</span>&lt;&gt;(() -&gt; &#123;            System.out.println(<span class="string">&quot;-----come in FutureTask&quot;</span>);            <span class="keyword">try</span> &#123;                TimeUnit.SECONDS.sleep(<span class="number">3</span>);            &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;                e.printStackTrace();            &#125;            <span class="keyword">return</span> <span class="string">&quot;&quot;</span> + ThreadLocalRandom.current().nextInt(<span class="number">100</span>);        &#125;);        <span class="type">Thread</span> <span class="variable">t1</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Thread</span>(futureTask, <span class="string">&quot;t1&quot;</span>);        t1.start();        <span class="comment">//3秒钟后才出来结果，还没有计算你提前来拿(只要一调用get方法，对于结果就是不见不散，会导致阻塞)</span>        <span class="comment">//System.out.println(Thread.currentThread().getName()+&quot;\t&quot;+futureTask.get());</span>        <span class="comment">//3秒钟后才出来结果，我只想等待1秒钟，过时不候</span>        System.out.println(Thread.currentThread().getName() + <span class="string">&quot;\t&quot;</span> + futureTask.get(<span class="number">1L</span>, TimeUnit.SECONDS));        System.out.println(Thread.currentThread().getName() + <span class="string">&quot;\t&quot;</span> + <span class="string">&quot; run... here&quot;</span>);    &#125;&#125;</code></pre><ul><li>isDone() 轮询—轮询的方式会耗费无谓的cpu资源，而且也不见得能及时得到计算结果，如果想要异步获取结果，通常会以轮询的方式去获取结果，尽量不要阻塞。</li></ul>  <pre><code class="highlight java"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">FutureTaskDemo2</span> &#123;    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> ExecutionException, InterruptedException &#123;        FutureTask&lt;String&gt; futureTask = <span class="keyword">new</span> <span class="title class_">FutureTask</span>&lt;&gt;(() -&gt; &#123;            System.out.println(<span class="string">&quot;-----come in FutureTask&quot;</span>);            <span class="keyword">try</span> &#123;                TimeUnit.SECONDS.sleep(<span class="number">3</span>);            &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;                e.printStackTrace();            &#125;            <span class="keyword">return</span> <span class="string">&quot;&quot;</span> + ThreadLocalRandom.current().nextInt(<span class="number">100</span>);        &#125;);        <span class="keyword">new</span> <span class="title class_">Thread</span>(futureTask, <span class="string">&quot;t1&quot;</span>).start();        System.out.println(Thread.currentThread().getName() + <span class="string">&quot;\t&quot;</span> + <span class="string">&quot;线程完成任务&quot;</span>);        <span class="comment">/**</span><span class="comment">         * 用于阻塞式获取结果,如果想要异步获取结果,通常都会以轮询的方式去获取结果</span><span class="comment">         */</span>        <span class="keyword">while</span> (<span class="literal">true</span>) &#123;            <span class="keyword">if</span> (futureTask.isDone()) &#123;                System.out.println(futureTask.get());                <span class="keyword">break</span>;            &#125;        &#125;    &#125;&#125;</code></pre><p><strong>结论：</strong>Future对于结果的获取不是很友好，只能通过阻塞或轮询的方式得到任务的结果。</p><h2 id="4-完成复杂的任务"><a href="#4-完成复杂的任务" class="headerlink" title="4. 完成复杂的任务"></a>4. 完成复杂的任务</h2><ul><li><p>回调通知（Future支持）</p><ul><li>应对Future的完成时间，完成了可以告诉我，也就是我们的回调通知</li><li>通过轮询的方式去判断任务是否完成这样非常占cpu并且代码也不优雅</li></ul></li><li><p>创建异步任务：Future+线程池组合</p><pre><code class="highlight java"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">FutureTaskDemo4</span> &#123;    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> ExecutionException, InterruptedException &#123;        <span class="comment">// 创建线程池</span>        <span class="type">ExecutorService</span> <span class="variable">executorService</span> <span class="operator">=</span> Executors.newFixedThreadPool(<span class="number">5</span>);                FutureTask&lt;String&gt; futureTask = <span class="keyword">new</span> <span class="title class_">FutureTask</span>&lt;&gt;(() -&gt; &#123;            System.out.println(Thread.currentThread().getName() + <span class="string">&quot;-----come in FutureTask&quot;</span>);            <span class="keyword">try</span> &#123;                TimeUnit.SECONDS.sleep(<span class="number">3</span>);            &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;                e.printStackTrace();            &#125;            <span class="keyword">return</span> <span class="string">&quot;&quot;</span> + ThreadLocalRandom.current().nextInt(<span class="number">100</span>);        &#125;);        <span class="comment">// 异步提交任务</span>        executorService.submit(futureTask);        System.out.println(Thread.currentThread().getName() + <span class="string">&quot;\t&quot;</span> + <span class="string">&quot;线程完成任务&quot;</span>);        <span class="comment">/**</span><span class="comment">         * 用于阻塞式获取结果,如果想要异步获取结果,通常都会以轮询的方式去获取结果</span><span class="comment">         */</span>        <span class="keyword">while</span> (<span class="literal">true</span>) &#123;            <span class="keyword">if</span> (futureTask.isDone()) &#123;                System.out.println(futureTask.get());                <span class="keyword">break</span>;            &#125;        &#125;        <span class="comment">// 关闭线程池</span>        executorService.shutdown();    &#125;&#125;</code></pre></li><li><p>多个任务前后依赖可以组合处理（Future不支持）</p><ul><li>想将多个异步任务的结果组合起来，后一个异步任务的计算结果需要前一个异步任务的值</li><li>想将两个或多个异步计算合并成为一个异步计算，这几个异步计算互相独立，同时后面这个又依赖前一个处理的结果</li></ul></li><li><p>对计算速度选最快的（Future不支持）</p><ul><li>当Future集合中某个任务最快结束时，返回结果，返回第一名处理结果</li></ul></li></ul><p><strong>结论</strong></p><ul><li>对于简单的业务场景使用 Future 完全 ok</li><li>对于复杂业务场景，使用 Future 之前提供的 API 处理起来不够优雅，这时候需要使用 CompletableFuture 以声明式的方式优雅的处理这些需求。</li><li>Future能干的，CompletableFuture 都能干</li></ul><h1 id="三、CompletableFuture对Future的改进"><a href="#三、CompletableFuture对Future的改进" class="headerlink" title="三、CompletableFuture对Future的改进"></a>三、CompletableFuture对Future的改进</h1><h2 id="1-CompletableFuture为什么会出现"><a href="#1-CompletableFuture为什么会出现" class="headerlink" title="1. CompletableFuture为什么会出现"></a>1. CompletableFuture为什么会出现</h2><ul><li>get() 方法在 Future 计算完成之前会一直处在阻塞状态下，阻塞的方式和异步编程的设计理念相违背。</li><li>isDone() 方法容易耗费 cpu 资源（cpu空转），</li><li>对于真正的异步处理我们希望是可以通过传入回调函数，在Future结束时自动调用该回调函数，这样，我们就不用等待结果</li></ul><p>jdk8 设计出 CompletableFuture，CompletableFuture 提供了一种观察者模式类似的机制，可以让任务执行完成后通知监听的一方。</p><h2 id="2-CompletableFuture-和-CompletionStage-介绍"><a href="#2-CompletableFuture-和-CompletionStage-介绍" class="headerlink" title="2. CompletableFuture 和 CompletionStage 介绍"></a>2. CompletableFuture 和 CompletionStage 介绍</h2><p><strong>类架构说明</strong>：</p><p><img src="https://raw.githubusercontent.com/GeorgeChan95/blogimg/master/img/2024/09/19/20240919-093123.png" alt="CompletableFuture"></p><p><img src="https://raw.githubusercontent.com/GeorgeChan95/blogimg/master/img/2024/09/19/20240919-093420.png" alt="CompletableFuture"></p><ul><li><strong>接口CompletionStage</strong><ul><li>代表异步计算过程中的某一个阶段，一个阶段完成以后可能会触发另外一个阶段。<ul><li>有些类似Linux系统的管道分隔符传参数</li></ul></li><li>一个阶段的执行可能是被单个阶段的完成触发，也可能是由多个阶段一起触发</li><li>一个阶段的计算执行可以是一个 function, Consumer 或者 Runnable。<ul><li>比如: <code>stage.thenApply(x -&gt; square(x).thenAccept(x -&gt; System.out.print(x)).thenRun(0)-&gt; system.out.println())</code></li></ul></li></ul></li><li><strong>类CompletableFuture</strong><ul><li>在Java8中，CompletableFuture 提供了非常强大的 Future 的扩展功能，可以帮助我们简化异步编程的复杂性，并且提供了函数式编程的能力，可以通过回调的方式处理计算结果，也提供了转换和组合 CompletableFuture 的方法,</li><li>它可能代表一个明确完成的 Future，也有可能代表一个完成阶段 (CompletionStage)，它支持在计算完成以后触发一些函数或执行某些动作。</li><li>它实现了 Future 和 CompletionStage 接口</li></ul></li></ul><h2 id="3-四个核心静态方法，创建异步任务"><a href="#3-四个核心静态方法，创建异步任务" class="headerlink" title="3. 四个核心静态方法，创建异步任务"></a>3. 四个核心静态方法，创建异步任务</h2><p>四个静态构造方法</p><p><img src="https://raw.githubusercontent.com/GeorgeChan95/blogimg/master/img/2024/09/19/20240919-094354.png" alt="CompletableFuture静态方法"></p><p><strong>对于上述Executor参数说明：若没有指定，则使用默认的 <code>ForkJoinPoolCommonPool()</code> 作为它的线程池执行异步代码，如果指定线程池，则使用我们自定义的或者特别指定的线程池执行异步代码</strong></p><h3 id="3-1-四个静态方法演示"><a href="#3-1-四个静态方法演示" class="headerlink" title="3.1 四个静态方法演示"></a>3.1 四个静态方法演示</h3><pre><code class="highlight java"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">CompletableFutureBuildDemo</span> &#123;    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> ExecutionException, InterruptedException &#123;        <span class="comment">// 自定义线程池</span>        <span class="type">ThreadPoolExecutor</span> <span class="variable">threadPoolExecutor</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ThreadPoolExecutor</span>(                <span class="number">1</span>,                <span class="number">20</span>,                <span class="number">1L</span>,                TimeUnit.SECONDS,                <span class="keyword">new</span> <span class="title class_">LinkedBlockingQueue</span>&lt;&gt;(<span class="number">50</span>),                Executors.defaultThreadFactory(),                <span class="keyword">new</span> <span class="title class_">ThreadPoolExecutor</span>.AbortPolicy());        <span class="comment">// 无返回值，默认线程池</span>        CompletableFuture&lt;Void&gt; future1 = CompletableFuture.runAsync(() -&gt; &#123;            <span class="keyword">try</span> &#123;                TimeUnit.SECONDS.sleep(<span class="number">1</span>);            &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;                <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">RuntimeException</span>(e);            &#125;            System.out.println(Thread.currentThread().getName() + <span class="string">&quot;无返回值，默认线程池：ForkJoinPool&quot;</span>);        &#125;);        System.out.println(<span class="string">&quot;future1 ==&gt; &quot;</span> + future1.get());        <span class="comment">/*</span><span class="comment">        * 打印：</span><span class="comment">        ForkJoinPool.commonPool-worker-1无返回值，默认线程池：ForkJoinPool</span><span class="comment">        future1 ==&gt; null</span><span class="comment">        * */</span>        System.out.println(<span class="string">&quot;----------------------------------------------------------&quot;</span>);        <span class="comment">// 无返回值，自定义线程池</span>        CompletableFuture&lt;Void&gt; future2 = CompletableFuture.runAsync(() -&gt; &#123;            <span class="keyword">try</span> &#123;                TimeUnit.SECONDS.sleep(<span class="number">1</span>);            &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;                <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">RuntimeException</span>(e);            &#125;            System.out.println(Thread.currentThread().getName() + <span class="string">&quot;无返回值，自定义线程池&quot;</span>);        &#125;, threadPoolExecutor);        System.out.println(<span class="string">&quot;future2 ==&gt; &quot;</span> + future2.get());        <span class="comment">/*</span><span class="comment">        * 打印：</span><span class="comment">        pool-1-thread-1无返回值，自定义线程池</span><span class="comment">        future2 ==&gt; null</span><span class="comment">        * */</span>        System.out.println(<span class="string">&quot;----------------------------------------------------------&quot;</span>);        CompletableFuture&lt;String&gt; future3 = CompletableFuture.supplyAsync(() -&gt; &#123;            <span class="keyword">try</span> &#123;                TimeUnit.SECONDS.sleep(<span class="number">1</span>);            &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;                <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">RuntimeException</span>(e);            &#125;            System.out.println(Thread.currentThread().getName() + <span class="string">&quot;有返回值，默认线程池：ForkJoinPool&quot;</span>);            <span class="keyword">return</span> <span class="string">&quot;有返回值，默认线程池：ForkJoinPool&quot;</span>;        &#125;);        System.out.println(<span class="string">&quot;future3 ==&gt; &quot;</span> + future3.get());        <span class="comment">/*</span><span class="comment">        * 打印：</span><span class="comment">        ForkJoinPool.commonPool-worker-1有返回值，默认线程池：ForkJoinPool</span><span class="comment">        future3 ==&gt; 有返回值，默认线程池：ForkJoinPool</span><span class="comment">        * */</span>        System.out.println(<span class="string">&quot;----------------------------------------------------------&quot;</span>);        CompletableFuture&lt;String&gt; future4 = CompletableFuture.supplyAsync(() -&gt; &#123;            <span class="keyword">try</span> &#123;                TimeUnit.SECONDS.sleep(<span class="number">1</span>);            &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;                <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">RuntimeException</span>(e);            &#125;            System.out.println(Thread.currentThread().getName() + <span class="string">&quot;有返回值，自定义线程池&quot;</span>);            <span class="keyword">return</span> <span class="string">&quot;有返回值，自定义线程池&quot;</span>;        &#125;, threadPoolExecutor);        System.out.println(<span class="string">&quot;future4 ==&gt; &quot;</span> + future4.get());        <span class="comment">/*</span><span class="comment">        * 打印：</span><span class="comment">        pool-1-thread-1有返回值，自定义线程池</span><span class="comment">        future4 ==&gt; 有返回值，自定义线程池</span><span class="comment">        * */</span>        <span class="comment">// 关闭线程池</span>        threadPoolExecutor.shutdown();    &#125;&#125;</code></pre><h3 id="3-2-回调方法演示"><a href="#3-2-回调方法演示" class="headerlink" title="3.2 回调方法演示"></a>3.2 回调方法演示</h3><p>CompletableFuture 减少阻塞和轮询，可以传入回调对象，当异步任务完成或者发生异常时，自动调用回调对象的回调方法。</p><pre><code class="highlight java"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">CompletableFutureUseDemo</span> &#123;    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> InterruptedException &#123;        <span class="comment">// 自定义线程池</span>        <span class="type">ThreadPoolExecutor</span> <span class="variable">threadPoolExecutor</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ThreadPoolExecutor</span>(<span class="number">1</span>,                <span class="number">20</span>,                <span class="number">1</span>,                TimeUnit.SECONDS,                <span class="keyword">new</span> <span class="title class_">LinkedBlockingQueue</span>&lt;&gt;(<span class="number">5</span>),                Executors.defaultThreadFactory(),                <span class="keyword">new</span> <span class="title class_">ThreadPoolExecutor</span>.AbortPolicy());        CompletableFuture&lt;Integer&gt; completableFuture = CompletableFuture.supplyAsync(() -&gt; &#123;            System.out.println(Thread.currentThread().getName() + <span class="string">&quot; 线程运行中...&quot;</span>);            <span class="type">int</span> <span class="variable">result</span> <span class="operator">=</span> ThreadLocalRandom.current().nextInt(<span class="number">10</span>);            <span class="keyword">try</span> &#123;                TimeUnit.SECONDS.sleep(<span class="number">1</span>);            &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;                <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">RuntimeException</span>(e);            &#125;            <span class="keyword">if</span> (result &gt; <span class="number">5</span>) &#123;                <span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">10</span> / <span class="number">0</span>;            &#125;            <span class="keyword">return</span> result;        &#125;, threadPoolExecutor).whenComplete((v, e) -&gt; &#123; <span class="comment">// 当计算完成时调用</span>            <span class="keyword">if</span> (e == <span class="literal">null</span>) &#123;                System.out.println(Thread.currentThread().getName() + <span class="string">&quot; 线程计算完成，结果为：&quot;</span> + v);            &#125;        &#125;).exceptionally(e -&gt; &#123;            e.printStackTrace();            <span class="type">String</span> <span class="variable">msg</span> <span class="operator">=</span> String.format(<span class="string">&quot;%s 线程计算出现异常，原因：%s, 错误信息：%s&quot;</span>, Thread.currentThread().getName(), e.getCause(), e.getMessage());            System.out.println(msg);            <span class="keyword">return</span> -<span class="number">1</span>;        &#125;);        System.out.println(Thread.currentThread().getName() + <span class="string">&quot; 线程先去完成其他任务&quot;</span>);        <span class="comment">// 线程不要立刻结束，否则CompletableFuture默认使用的线程池会立刻关闭：暂停3秒钟线程</span>        TimeUnit.SECONDS.sleep(<span class="number">2</span>);        <span class="comment">// 关闭自定义线程池</span>        threadPoolExecutor.shutdown();    &#125;&#125;<span class="comment">/*</span><span class="comment">无异常时打印如下：</span><span class="comment">pool-1-thread-1 线程运行中...</span><span class="comment">main 线程先去完成其他任务</span><span class="comment">pool-1-thread-1 线程计算完成，结果为：2</span><span class="comment">* */</span><span class="comment">/*</span><span class="comment">有异常时打印如下：</span><span class="comment">pool-1-thread-1 线程运行中...</span><span class="comment">main 线程先去完成其他任务</span><span class="comment">java.util.concurrent.CompletionException: java.lang.ArithmeticException: / by zero</span><span class="comment">at java.base/java.util.concurrent.CompletableFuture.encodeThrowable(CompletableFuture.java:315)</span><span class="comment">at java.base/java.util.concurrent.CompletableFuture.completeThrowable(CompletableFuture.java:320)</span><span class="comment">at java.base/java.util.concurrent.CompletableFuture$AsyncSupply.run(CompletableFuture.java:1770)</span><span class="comment">at java.base/java.util.concurrent.ThreadPoolExecutor.runWorker(ThreadPoolExecutor.java:1136)</span><span class="comment">at java.base/java.util.concurrent.ThreadPoolExecutor$Worker.run(ThreadPoolExecutor.java:635)</span><span class="comment">at java.base/java.lang.Thread.run(Thread.java:842)</span><span class="comment">Caused by: java.lang.ArithmeticException: / by zero</span><span class="comment">at com.atguigu.juc.cf.CompletableFutureUseDemo.lambda$main$0(CompletableFutureUseDemo.java:32)</span><span class="comment">at java.base/java.util.concurrent.CompletableFuture$AsyncSupply.run(CompletableFuture.java:1768)</span><span class="comment">... 3 more</span><span class="comment">pool-1-thread-1 线程计算出现异常，原因：java.lang.ArithmeticException: / by zero, 错误信息：java.lang.ArithmeticException: / by zero</span><span class="comment">* */</span></code></pre><p>CompletableFuture优点：</p><ul><li>异步任务<strong>结束</strong>时，会自动回调某个对象的方法</li><li>主线程设置好回调后，不用关心异步任务的执行，异步任务之间可以顺序执行</li><li>异步任务<strong>出错</strong>时，会自动回调某个对象的方法</li></ul><h1 id="四、函数式编程"><a href="#四、函数式编程" class="headerlink" title="四、函数式编程"></a>四、函数式编程</h1><p>Lambda表达式+Stream流式调用+Chain链式调用+Java8函数式编程</p><h2 id="1-函数式接口"><a href="#1-函数式接口" class="headerlink" title="1. 函数式接口"></a>1. 函数式接口</h2><ul><li><p>Runnable：无参数、无返回值</p><p><img src="https://raw.githubusercontent.com/GeorgeChan95/blogimg/master/img/2024/09/19/20240919-110244.png" alt="Runnable"></p></li><li><p>Function：接受一个参数，并且有返回值</p><p><img src="https://raw.githubusercontent.com/GeorgeChan95/blogimg/master/img/2024/09/19/20240919-110317.png" alt="Function"></p></li><li><p>Consumer：接受一个参数，没有返回值</p><p><img src="https://raw.githubusercontent.com/GeorgeChan95/blogimg/master/img/2024/09/19/20240919-110409.png" alt="Consumer"></p></li><li><p>BiConsumer：接受两个参数，没有返回值</p><p><img src="https://raw.githubusercontent.com/GeorgeChan95/blogimg/master/img/2024/09/19/20240919-110436.png" alt="BiConsumer"></p></li><li><p>Supplier：没有参数，有返回值</p><p><img src="https://raw.githubusercontent.com/GeorgeChan95/blogimg/master/img/2024/09/19/20240919-110455.png" alt="Supplier"></p></li></ul><p><strong>总结：</strong></p><table><thead><tr><th>函数式接口名称</th><th>方法名称</th><th>参数</th><th>返回值</th></tr></thead><tbody><tr><td>Runnable</td><td>run</td><td>无参数</td><td>无返回值</td></tr><tr><td>Function</td><td>apply</td><td>1个参数</td><td>有返回值</td></tr><tr><td>Consume</td><td>accept</td><td>1个参数</td><td>无返回值</td></tr><tr><td>Supplier</td><td>get</td><td>没有参数</td><td>有返回值</td></tr><tr><td>Biconsumer</td><td>accept</td><td>2个参数</td><td>无返回值</td></tr></tbody></table><h2 id="2-链式编程"><a href="#2-链式编程" class="headerlink" title="2. 链式编程"></a>2. 链式编程</h2><pre><code class="highlight java"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Chain</span> &#123;    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;        <span class="comment">//-------------------老式写法------------</span><span class="comment">//        Student student = new Student();</span><span class="comment">//        student.setId(1);</span><span class="comment">//        student.setMajor(&quot;cs&quot;);</span><span class="comment">//        student.setName(&quot;小卡&quot;);</span>        <span class="keyword">new</span> <span class="title class_">Student</span>().setId(<span class="number">1</span>).setName(<span class="string">&quot;大卡&quot;</span>).setMajor(<span class="string">&quot;cs&quot;</span>);    &#125;    &#125;<span class="meta">@NoArgsConstructor</span><span class="meta">@AllArgsConstructor</span><span class="meta">@Data</span><span class="meta">@Accessors(chain = true)</span><span class="comment">//开启链式编程</span><span class="keyword">class</span> <span class="title class_">Student</span>&#123;    <span class="keyword">private</span> <span class="type">int</span> id;    <span class="keyword">private</span> String name;    <span class="keyword">private</span> String major;&#125;</code></pre><h1 id="五、join-和-get-对比"><a href="#五、join-和-get-对比" class="headerlink" title="五、join 和 get 对比"></a>五、join 和 get 对比</h1><p>join 与 get 功能几乎一样，区别在于编码时是否需要抛出异常</p><ul><li>get() 方法需要抛出异常</li><li>join() 方法不需要抛出异常</li></ul><pre><code class="highlight java"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Chain</span> &#123;    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> ExecutionException, InterruptedException &#123; <span class="comment">//抛出异常</span>        CompletableFuture&lt;String&gt; completableFuture = CompletableFuture.supplyAsync(() -&gt; &#123;            <span class="keyword">return</span> <span class="string">&quot;hello 12345&quot;</span>;        &#125;);        System.out.println(completableFuture.get());    &#125;&#125;<span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Chain</span> &#123;    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span>  &#123;<span class="comment">// 不用抛出异常</span>        CompletableFuture&lt;String&gt; completableFuture = CompletableFuture.supplyAsync(() -&gt; &#123;            <span class="keyword">return</span> <span class="string">&quot;hello 12345&quot;</span>;        &#125;);        System.out.println(completableFuture.join());    &#125;&#125;</code></pre><h1 id="六、CompletableFuture-案例讲解"><a href="#六、CompletableFuture-案例讲解" class="headerlink" title="六、CompletableFuture 案例讲解"></a>六、CompletableFuture 案例讲解</h1><h2 id="1-需求说明"><a href="#1-需求说明" class="headerlink" title="1. 需求说明"></a>1. 需求说明</h2><p>电商网站比价需求分析：</p><ol><li><p>需求说明：</p></li><li><ol><li>同一款产品，同时搜索出同款产品在各大电商平台的售价</li><li>同一款产品，同时搜索出本产品在同一个电商平台下，各个入驻卖家售价是多少</li></ol></li><li><p>输出返回：</p></li><li><ol><li>出来结果希望是同款产品的在不同地方的价格清单列表，返回一个List<String></li></ol></li></ol><p>例如：《Mysql》 in jd price is 88.05  《Mysql》 in taobao price is 90.43</p><ol><li><p>解决方案，对比同一个产品在各个平台上的价格，要求获得一个清单列表</p></li><li><ol><li>step by step，按部就班，查完淘宝查京东，查完京东查天猫….</li><li>all in，万箭齐发，一口气多线程异步任务同时查询</li></ol></li></ol><h2 id="2-不使用多线程实现需求"><a href="#2-不使用多线程实现需求" class="headerlink" title="2. 不使用多线程实现需求"></a>2. 不使用多线程实现需求</h2><p>从不同的网站逐个查询，直到所有网站查询完成，返回结果。</p><pre><code class="highlight java"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">NetMallCase</span> &#123;    <span class="keyword">static</span> List&lt;NetMall&gt; list = Arrays.asList(            <span class="keyword">new</span> <span class="title class_">NetMall</span>(<span class="string">&quot;jd&quot;</span>),            <span class="keyword">new</span> <span class="title class_">NetMall</span>(<span class="string">&quot;pdd&quot;</span>),            <span class="keyword">new</span> <span class="title class_">NetMall</span>(<span class="string">&quot;taobao&quot;</span>),            <span class="keyword">new</span> <span class="title class_">NetMall</span>(<span class="string">&quot;dangdangwang&quot;</span>),            <span class="keyword">new</span> <span class="title class_">NetMall</span>(<span class="string">&quot;tmall&quot;</span>)    );    <span class="comment">/**</span><span class="comment">     * 不使用多线程，获取图书在不同平台的价格</span><span class="comment">     * <span class="doctag">@param</span> list</span><span class="comment">     * <span class="doctag">@param</span> productName</span><span class="comment">     * <span class="doctag">@return</span></span><span class="comment">     */</span>    <span class="keyword">public</span> <span class="keyword">static</span> List&lt;String&gt; <span class="title function_">getPriceByStep</span><span class="params">(List&lt;NetMall&gt; list, String productName)</span> &#123;        List&lt;String&gt; result = list.stream().map(netMall -&gt; &#123;            <span class="type">String</span> <span class="variable">str</span> <span class="operator">=</span> String.format(productName + <span class="string">&quot; in %s price is %.2f&quot;</span>, netMall.getMallName(), netMall.calcPrice(productName));            <span class="keyword">return</span> str;        &#125;).collect(Collectors.toList());        <span class="keyword">return</span> result;    &#125;    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;        <span class="type">long</span> <span class="variable">startTime</span> <span class="operator">=</span> System.currentTimeMillis();        List&lt;String&gt; resuts = getPriceByStep(list, <span class="string">&quot;mysql&quot;</span>);        <span class="keyword">for</span> (String data : resuts) &#123;            System.out.println(data);        &#125;        <span class="type">long</span> <span class="variable">endTime</span> <span class="operator">=</span> System.currentTimeMillis();        System.out.println(<span class="string">&quot;不使用多线程，costTime: &quot;</span> + (endTime - startTime) + <span class="string">&quot; 毫秒&quot;</span>);    &#125;&#125;<span class="keyword">class</span> <span class="title class_">NetMallData</span> &#123;    <span class="meta">@Getter</span>    <span class="keyword">private</span> String mallName;    <span class="keyword">public</span> <span class="title function_">NetMallData</span><span class="params">(String mallName)</span> &#123;        <span class="built_in">this</span>.mallName = mallName;    &#125;    <span class="keyword">public</span> <span class="type">double</span> <span class="title function_">calcPrice</span><span class="params">(String productName)</span> &#123;        <span class="comment">//检索需要1秒钟</span>        <span class="keyword">try</span> &#123;            TimeUnit.SECONDS.sleep(<span class="number">1</span>);        &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;            e.printStackTrace();        &#125;        <span class="keyword">return</span> ThreadLocalRandom.current().nextDouble() * <span class="number">2</span> + productName.charAt(<span class="number">0</span>);    &#125;&#125;</code></pre><p>执行结果：</p><pre><code class="highlight shell">mysql in jd price is 109.95mysql in pdd price is 109.86mysql in taobao price is 109.79mysql in dangdangwang price is 110.08mysql in tmall price is 110.55不使用多线程，costTime: 5070 毫秒</code></pre><p>多个查询逐个完成，执行效率低，执行时间长。</p><h2 id="3-使用-CompletableFuture-实现需求"><a href="#3-使用-CompletableFuture-实现需求" class="headerlink" title="3. 使用 CompletableFuture 实现需求"></a>3. 使用 CompletableFuture 实现需求</h2><pre><code class="highlight java"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">NetMallCase</span> &#123;    <span class="keyword">static</span> List&lt;NetMall&gt; list = Arrays.asList(            <span class="keyword">new</span> <span class="title class_">NetMall</span>(<span class="string">&quot;jd&quot;</span>),            <span class="keyword">new</span> <span class="title class_">NetMall</span>(<span class="string">&quot;pdd&quot;</span>),            <span class="keyword">new</span> <span class="title class_">NetMall</span>(<span class="string">&quot;taobao&quot;</span>),            <span class="keyword">new</span> <span class="title class_">NetMall</span>(<span class="string">&quot;dangdangwang&quot;</span>),            <span class="keyword">new</span> <span class="title class_">NetMall</span>(<span class="string">&quot;tmall&quot;</span>)    );    <span class="comment">/**</span><span class="comment">     * 不使用多线程，获取图书在不同平台的价格</span><span class="comment">     *</span><span class="comment">     * <span class="doctag">@param</span> list</span><span class="comment">     * <span class="doctag">@param</span> productName</span><span class="comment">     * <span class="doctag">@return</span></span><span class="comment">     */</span>    <span class="keyword">public</span> <span class="keyword">static</span> List&lt;String&gt; <span class="title function_">getPriceByStep</span><span class="params">(List&lt;NetMall&gt; list, String productName)</span> &#123;        List&lt;String&gt; result = list.stream().map(netMall -&gt; &#123;            <span class="type">String</span> <span class="variable">str</span> <span class="operator">=</span> String.format(productName + <span class="string">&quot; in %s price is %.2f&quot;</span>, netMall.getMallName(), netMall.calcPrice(productName));            <span class="keyword">return</span> str;        &#125;).collect(Collectors.toList());        <span class="keyword">return</span> result;    &#125;    <span class="comment">/**</span><span class="comment">     * 使用多线程异步的从不同平台获取图书价格</span><span class="comment">     *</span><span class="comment">     * <span class="doctag">@param</span> list</span><span class="comment">     * <span class="doctag">@param</span> productName</span><span class="comment">     * <span class="doctag">@return</span></span><span class="comment">     */</span>    <span class="keyword">public</span> <span class="keyword">static</span> List&lt;String&gt; <span class="title function_">getPriceByAsync</span><span class="params">(List&lt;NetMall&gt; list, String productName)</span> &#123;        List&lt;String&gt; results = list.stream().map(netMall -&gt;                        CompletableFuture.supplyAsync(() -&gt; String.format(productName + <span class="string">&quot; in %s price is %.2f&quot;</span>, netMall.getMallName(), netMall.calcPrice(productName))))                .collect(Collectors.toList())                .stream()                .map(CompletableFuture::join)                .collect(Collectors.toList());        <span class="keyword">return</span> results;    &#125;    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;        <span class="comment">// 使用异步多线程获取</span>        <span class="type">long</span> <span class="variable">startTime2</span> <span class="operator">=</span> System.currentTimeMillis();        List&lt;String&gt; resuts2 = getPriceByAsync(list, <span class="string">&quot;mysql&quot;</span>);        <span class="keyword">for</span> (String data : resuts2) &#123;            System.out.println(data);        &#125;        <span class="type">long</span> <span class="variable">endTime2</span> <span class="operator">=</span> System.currentTimeMillis();        System.out.println(<span class="string">&quot;使用异步多线程，costTime: &quot;</span> + (endTime2 - startTime2) + <span class="string">&quot; 毫秒&quot;</span>);    &#125;&#125;<span class="keyword">class</span> <span class="title class_">NetMallData</span> &#123;    <span class="meta">@Getter</span>    <span class="keyword">private</span> String mallName;    <span class="keyword">public</span> <span class="title function_">NetMallData</span><span class="params">(String mallName)</span> &#123;        <span class="built_in">this</span>.mallName = mallName;    &#125;    <span class="keyword">public</span> <span class="type">double</span> <span class="title function_">calcPrice</span><span class="params">(String productName)</span> &#123;        <span class="comment">//检索需要1秒钟</span>        <span class="keyword">try</span> &#123;            TimeUnit.SECONDS.sleep(<span class="number">1</span>);        &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;            e.printStackTrace();        &#125;        <span class="keyword">return</span> ThreadLocalRandom.current().nextDouble() * <span class="number">2</span> + productName.charAt(<span class="number">0</span>);    &#125;&#125;</code></pre><p>执行结果：</p><pre><code class="highlight shell">mysql in jd price is 110.91mysql in pdd price is 109.59mysql in taobao price is 109.30mysql in dangdangwang price is 110.85mysql in tmall price is 110.67使用异步多线程，costTime: 1056 毫秒</code></pre><p>使用异步多线程，执行效率大大提升。</p><h1 id="七、CompletableFuture-常用API"><a href="#七、CompletableFuture-常用API" class="headerlink" title="七、CompletableFuture 常用API"></a>七、CompletableFuture 常用API</h1><h2 id="1-获得结果和触发计算"><a href="#1-获得结果和触发计算" class="headerlink" title="1.获得结果和触发计算"></a>1.获得结果和触发计算</h2><ul><li><p>获取结果</p><ul><li><code>public T get()</code>  阻塞等待，直到得到返回结果</li><li><code>public T get(long timeout,TimeUnit unit)</code>  阻塞等待指定的时长，超时则报错：TimeOutException</li><li><code>public T join()</code>  类似于get()，区别在于不需要抛出异常</li><li><code>public T getNow(T valueIfAbsent)</code>  立即获取结果不阻塞<ul><li>计算完，返回计算完成后的结果</li><li>没算完，返回设定的valueAbsent(直接返回了备胎值xxx)</li></ul></li></ul></li><li><p>主动触发计算</p><ul><li><code>public boolean complete(T value)</code>  是否立即打断get()方法返回括号值<ul><li>(执行要2s，等待只有1s，所以还没执行完就被打断了。返回true表示打断了获取这个过程，直接返回了备胎值 complete；如果没打断，返回false 和原来的abc)</li></ul></li></ul><pre><code class="highlight java"><span class="comment">/**</span><span class="comment"> * 获得结果和触发计算</span><span class="comment"> *</span><span class="comment"> * <span class="doctag">@throws</span> InterruptedException</span><span class="comment"> * <span class="doctag">@throws</span> ExecutionException</span><span class="comment"> */</span><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">m1</span><span class="params">()</span> <span class="keyword">throws</span> InterruptedException, ExecutionException &#123;    <span class="type">ThreadPoolExecutor</span> <span class="variable">threadPoolExecutor</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ThreadPoolExecutor</span>(<span class="number">1</span>, <span class="number">20</span>, <span class="number">1L</span>, TimeUnit.SECONDS, <span class="keyword">new</span> <span class="title class_">LinkedBlockingQueue</span>&lt;&gt;(<span class="number">50</span>), Executors.defaultThreadFactory(), <span class="keyword">new</span> <span class="title class_">ThreadPoolExecutor</span>.AbortPolicy());    CompletableFuture&lt;Integer&gt; future = CompletableFuture.supplyAsync(() -&gt; &#123;        <span class="comment">//暂停几秒钟线程</span>        <span class="comment">//暂停几秒钟线程</span>        <span class="keyword">try</span> &#123;            TimeUnit.SECONDS.sleep(<span class="number">2</span>);        &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;            e.printStackTrace();        &#125;        <span class="keyword">return</span> <span class="number">1</span>;    &#125;, threadPoolExecutor);    <span class="comment">//System.out.println(future.get()); // 1</span>    <span class="comment">//System.out.println(future.get(2L,TimeUnit.SECONDS)); // 1</span>    <span class="comment">//暂停几秒钟线程</span>    <span class="keyword">try</span> &#123;        TimeUnit.SECONDS.sleep(<span class="number">1</span>);    &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;        e.printStackTrace();    &#125;    <span class="comment">//System.out.println(future.getNow(9999));</span>    System.out.println(future.complete(-<span class="number">44</span>) + <span class="string">&quot;\t&quot;</span> + future.get());        <span class="comment">// 关闭线程池</span>    threadPoolExecutor.shutdown();&#125;</code></pre><p>打印结果：</p><pre><code class="highlight shell">true-44</code></pre></li></ul><h2 id="2-对计算结果进行处理"><a href="#2-对计算结果进行处理" class="headerlink" title="2. 对计算结果进行处理"></a>2. 对计算结果进行处理</h2><ul><li><p><code>thenApply </code> 计算结果存在在依赖关系，使得线程串行化。因为依赖关系，所以一旦有异常，直接叫停。</p><pre><code class="highlight java"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">thenApplyDemo</span><span class="params">()</span> <span class="keyword">throws</span> InterruptedException &#123;    <span class="type">ThreadPoolExecutor</span> <span class="variable">threadPoolExecutor</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ThreadPoolExecutor</span>(<span class="number">1</span>, <span class="number">20</span>, <span class="number">1L</span>, TimeUnit.SECONDS, <span class="keyword">new</span> <span class="title class_">LinkedBlockingQueue</span>&lt;&gt;(<span class="number">50</span>), Executors.defaultThreadFactory(), <span class="keyword">new</span> <span class="title class_">ThreadPoolExecutor</span>.AbortPolicy());    CompletableFuture&lt;Integer&gt; completableFuture = CompletableFuture.supplyAsync(() -&gt; &#123;        <span class="type">int</span> <span class="variable">result</span> <span class="operator">=</span> ThreadLocalRandom.current().nextInt(<span class="number">10</span>);        <span class="keyword">try</span> &#123;            TimeUnit.SECONDS.sleep(<span class="number">1</span>);        &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;            <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">RuntimeException</span>(e);        &#125;        <span class="keyword">if</span> (result &gt; <span class="number">5</span>) &#123;            <span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">10</span> / <span class="number">0</span>;        &#125;        <span class="keyword">return</span> <span class="number">1</span>;    &#125;, threadPoolExecutor).thenApply(data -&gt; data + <span class="number">2</span>).whenComplete((v, e) -&gt; &#123;        <span class="keyword">if</span> (e == <span class="literal">null</span>) &#123;            System.out.println(<span class="string">&quot;执行完成，结果：&quot;</span> + v);        &#125;    &#125;).exceptionally(e -&gt; &#123;        e.printStackTrace();        <span class="type">String</span> <span class="variable">msg</span> <span class="operator">=</span> String.format(<span class="string">&quot;执行出现异常，原因：%s, 异常信息：%s&quot;</span>, e.getCause(), e.getMessage());        System.out.println(msg);        <span class="keyword">return</span> -<span class="number">1</span>;    &#125;);        System.out.println(<span class="string">&quot;执行结束，结果：&quot;</span> + completableFuture.join());    <span class="comment">// 关闭自定义线程池</span>    threadPoolExecutor.shutdown();    <span class="comment">// 主线程停留3秒</span>    TimeUnit.SECONDS.sleep(<span class="number">3</span>);&#125;</code></pre><p>正常执行结束打印：</p><pre><code class="highlight shell">执行完成，结果：3执行结束，结果：3</code></pre><p>异常执行结束打印：</p><pre><code class="highlight shell">java.util.concurrent.CompletionException: java.lang.ArithmeticException: / by zeroat java.util.concurrent.CompletableFuture.encodeThrowable(CompletableFuture.java:273)at java.util.concurrent.CompletableFuture.completeThrowable(CompletableFuture.java:280)at java.util.concurrent.CompletableFuture$AsyncSupply.run(CompletableFuture.java:1606)at java.util.concurrent.ThreadPoolExecutor.runWorker(ThreadPoolExecutor.java:1149)at java.util.concurrent.ThreadPoolExecutor$Worker.run(ThreadPoolExecutor.java:624)at java.lang.Thread.run(Thread.java:748)Caused by: java.lang.ArithmeticException: / by zeroat com.atguigu.juc.cf.CompletableFutureDemo.lambda$thenApplyDemo$0(CompletableFutureDemo.java:27)at java.util.concurrent.CompletableFuture$AsyncSupply.run(CompletableFuture.java:1604)... 3 more执行出现异常，原因：java.lang.ArithmeticException: / by zero, 异常信息：java.lang.ArithmeticException: / by zero执行结束，结果：-1</code></pre></li><li><p><code>handle </code> 类似于 thenApply，但是有异常的话仍然可以往下走一步。</p><pre><code class="highlight java"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">handleDemo</span><span class="params">()</span> <span class="keyword">throws</span> InterruptedException &#123;    <span class="comment">// 自定义线程池</span>    <span class="type">ThreadPoolExecutor</span> <span class="variable">threadPool</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ThreadPoolExecutor</span>(            <span class="number">4</span>,            <span class="number">5</span>,            <span class="number">50</span>,            TimeUnit.SECONDS,            <span class="keyword">new</span> <span class="title class_">LinkedBlockingQueue</span>&lt;&gt;(<span class="number">10</span>),            Executors.defaultThreadFactory(),            <span class="keyword">new</span> <span class="title class_">ThreadPoolExecutor</span>.AbortPolicy());    CompletableFuture.supplyAsync(() -&gt; &#123;        <span class="type">int</span> <span class="variable">result</span> <span class="operator">=</span> ThreadLocalRandom.current().nextInt(<span class="number">10</span>);        <span class="keyword">try</span> &#123;            TimeUnit.SECONDS.sleep(<span class="number">1</span>);        &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;            <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">RuntimeException</span>(e);        &#125;        <span class="keyword">if</span> (result &gt; <span class="number">5</span>) &#123;            <span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">10</span> / <span class="number">0</span>;        &#125;        <span class="keyword">return</span> <span class="number">10</span>;    &#125;, threadPool).handle((v, e) -&gt; &#123;        <span class="keyword">if</span> (e == <span class="literal">null</span>) &#123;            System.out.println(<span class="string">&quot;handle1执行完成，结果：&quot;</span> + v);        &#125; <span class="keyword">else</span> &#123;            System.out.println(<span class="string">&quot;handle1执行异常&quot;</span>);        &#125;        <span class="keyword">return</span> v + <span class="number">1</span>;    &#125;).handle((v, e) -&gt; &#123;        <span class="keyword">if</span> (e == <span class="literal">null</span>) &#123;            System.out.println(<span class="string">&quot;handle2执行完成，结果：&quot;</span> + v);        &#125; <span class="keyword">else</span> &#123;            System.out.println(<span class="string">&quot;handle2执行异常&quot;</span>);        &#125;        <span class="keyword">return</span> <span class="string">&quot;abc&quot;</span>;    &#125;).handle((v, e) -&gt; &#123;        <span class="keyword">if</span> (e == <span class="literal">null</span>) &#123;            System.out.println(<span class="string">&quot;handle3执行完成，结果：&quot;</span> + v);        &#125; <span class="keyword">else</span> &#123;            System.out.println(<span class="string">&quot;handle3执行异常&quot;</span>);        &#125;        <span class="keyword">return</span> <span class="string">&quot;xyz&quot;</span>;    &#125;).whenCompleteAsync((v, e) -&gt; &#123;        <span class="keyword">if</span> (e == <span class="literal">null</span>) &#123;            System.out.println(Thread.currentThread().getName() + <span class="string">&quot; whenComplete执行完成，结果：&quot;</span> + v);        &#125;    &#125;, threadPool).exceptionally(e -&gt; &#123;        e.printStackTrace();        <span class="type">String</span> <span class="variable">msg</span> <span class="operator">=</span> String.format(<span class="string">&quot;执行出现异常，原因：%s, 异常信息：%s&quot;</span>, e.getCause(), e.getMessage());        System.out.println(msg);        <span class="keyword">return</span> <span class="string">&quot;error&quot;</span>;    &#125;);    TimeUnit.SECONDS.sleep(<span class="number">5</span>);    <span class="comment">// 关闭线程池</span>    threadPool.shutdown();&#125;</code></pre><p>正常执行结束打印：</p><pre><code class="highlight shell">handle1执行完成，结果：10handle2执行完成，结果：11whenComplete执行完成，结果：abc</code></pre><p>异常执行结束打印：</p><pre><code class="highlight shell">handle1执行异常handle2执行异常handle3执行完成，结果：abcpool-1-thread-2 whenComplete执行完成，结果：xyz</code></pre><p><strong>注意：</strong>当 <code>supplyAsync</code> 方法执行异常时， 程序依然往下走，经过了 <code>handle1</code>、<code>handle2</code>、<code>handle3</code> ，而没有经过 <code>exceptionally</code> ，当 <code>handle3</code> 出现异常时（在<code>whenCompleteAsync</code> 上方的方法），才会经过 <code>exceptionally</code> 方法</p></li></ul><p><strong>thenApply 在实际工作中最常用</strong></p><h2 id="3-对计算结果进行消费"><a href="#3-对计算结果进行消费" class="headerlink" title="3. 对计算结果进行消费"></a>3. 对计算结果进行消费</h2><p>接收任务的处理结果，并消费处理，<strong>无返回结果|消费型函数式接口</strong>，之前的是Function</p><ul><li><p>thenAccept</p><ul><li>thenAccept(Consumer action)</li><li>任务A执行完执行B，B需要A的结果，但是任务B无返回值</li></ul><pre><code class="highlight java">System.out.println(CompletableFuture.supplyAsync(() -&gt; <span class="string">&quot;resultA&quot;</span>).thenAccept(r -&gt; System.out.println(r)).join());</code></pre></li><li><p>thenRun</p><ul><li>thenRun(Runnable runnable)</li><li>任务A执行完执行B，并且B不需要A的结果</li></ul><pre><code class="highlight java">System.out.println(CompletableFuture.supplyAsync(() -&gt; <span class="string">&quot;resultA&quot;</span>).thenRun(() -&gt; &#123;&#125;).join());</code></pre></li><li><p>thenApply</p><ul><li>thenApply(Function fn)</li><li>任务A执行完执行B，B需要A的结果，同时任务B有返回值</li></ul><pre><code class="highlight java">System.out.println(CompletableFuture.supplyAsync(() -&gt; <span class="string">&quot;resultA&quot;</span>).thenApply(resultA -&gt; resultA + <span class="string">&quot; resultB&quot;</span>).join());</code></pre></li></ul><p>示例代码：</p><pre><code class="highlight java"><span class="comment">/**</span><span class="comment"> * 对计算结果进行消费</span><span class="comment"> */</span><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">m3</span><span class="params">()</span> &#123;    CompletableFuture.supplyAsync(() -&gt; &#123;        <span class="keyword">return</span> <span class="number">1</span>;    &#125;).thenApply(f -&gt; &#123;        <span class="keyword">return</span> f + <span class="number">2</span>;    &#125;).thenApply(f -&gt; &#123;        <span class="keyword">return</span> f + <span class="number">3</span>;    &#125;).thenAccept(r -&gt; System.out.println(r));    <span class="comment">// 任务A执行完执行B，并且B不需要A的结果, 且B无返回值</span>    System.out.println(CompletableFuture.supplyAsync(() -&gt; <span class="string">&quot;resultA&quot;</span>).thenRun(() -&gt; &#123;&#125;).join());    <span class="comment">// 任务A执行完执行B，B需要A的结果，但是任务B无返回值</span>    System.out.println(CompletableFuture.supplyAsync(() -&gt; <span class="string">&quot;resultA&quot;</span>).thenAccept(r -&gt; System.out.println(r)).join());    <span class="comment">// 任务A执行完执行B，B需要A的结果，同时任务B有返回值</span>    System.out.println(CompletableFuture.supplyAsync(() -&gt; <span class="string">&quot;resultA&quot;</span>).thenApply(resultA -&gt; resultA + <span class="string">&quot; resultB&quot;</span>).join());&#125;</code></pre><h2 id="4-CompleteFuture和线程池说明（非常重要）"><a href="#4-CompleteFuture和线程池说明（非常重要）" class="headerlink" title="4. CompleteFuture和线程池说明（非常重要）"></a>4. CompleteFuture和线程池说明（非常重要）</h2><p>上面的几个方法都有普通版本和后面加<strong>Async</strong>的版本, 例如：<code>thenRun</code>、<code>thenRunAsync</code>、<code>thenApply</code>、<code>thenApplyAsync</code>、<code>whenComplete</code>、<code>whenCompleteAsync</code> ……</p><p>以 <code>thenRun</code>和<code>thenRunAsync</code>为例，有什么区别？</p><ul><li><p><code>thenRun</code> 没有传入自定义线程池，使用默认线程池 ForkJoinPool</p></li><li><p><code>thenRunAsync</code>可传入一个自定义线程池</p><ul><li>如果你执行第一个任务的时候，传入了一个自定义线程池，调用<code>thenRun</code>方法执行第二个任务的时候，则第二个任务和第一个任务是用同一个线程池。</li><li>调用<code>thenRunAsync</code>执行第二个任务的时候，则第一个任务使用的是你自己传入的线程池，第二个任务使用的是 <strong>ForkJoin线程池</strong></li></ul></li><li><p>特殊情况，任务处理太快，系统优化切换原则，直接使用main线程处理</p></li><li><p>thenRun 代码示例</p><pre><code class="highlight plaintext">private static void m7() throws InterruptedException &#123;    ThreadPoolExecutor threadPoolExecutor = new ThreadPoolExecutor(1, 20, 1L, TimeUnit.SECONDS, new LinkedBlockingQueue&lt;&gt;(50), Executors.defaultThreadFactory(), new ThreadPoolExecutor.AbortPolicy());    CompletableFuture&lt;Void&gt; completableFuture = CompletableFuture.supplyAsync(()-&gt;&#123;        try &#123;TimeUnit.MILLISECONDS.sleep(20);&#125; catch (InterruptedException e) &#123;e.printStackTrace();&#125;        System.out.println(&quot;1号任务&quot;+&quot;\t&quot;+Thread.currentThread().getName());        return &quot;abcd&quot;;    &#125;,threadPoolExecutor).thenRun(()-&gt;&#123;        try &#123;TimeUnit.MILLISECONDS.sleep(20);&#125; catch (InterruptedException e) &#123;e.printStackTrace();&#125;        System.out.println(&quot;2号任务&quot;+&quot;\t&quot;+Thread.currentThread().getName());    &#125;).thenRun(()-&gt;&#123;        try &#123;TimeUnit.MILLISECONDS.sleep(20);&#125; catch (InterruptedException e) &#123;e.printStackTrace();&#125;        System.out.println(&quot;3号任务&quot;+&quot;\t&quot;+Thread.currentThread().getName());    &#125;).thenRun(()-&gt;&#123;        try &#123;TimeUnit.MILLISECONDS.sleep(20);&#125; catch (InterruptedException e) &#123;e.printStackTrace();&#125;        System.out.println(&quot;4号任务&quot;+&quot;\t&quot;+Thread.currentThread().getName());    &#125;);    Thread.sleep(2000);    threadPoolExecutor.shutdown();&#125;</code></pre><p>  运行结果：</p><pre><code class="highlight shell">1号任务pool-1-thread-12号任务pool-1-thread-13号任务pool-1-thread-14号任务pool-1-thread-1</code></pre></li><li><p>thenRunAsync 代码示例</p><pre><code class="highlight java"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">m7</span><span class="params">()</span> <span class="keyword">throws</span> InterruptedException &#123;    <span class="type">ThreadPoolExecutor</span> <span class="variable">threadPoolExecutor</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ThreadPoolExecutor</span>(<span class="number">1</span>, <span class="number">20</span>, <span class="number">1L</span>, TimeUnit.SECONDS, <span class="keyword">new</span> <span class="title class_">LinkedBlockingQueue</span>&lt;&gt;(<span class="number">50</span>), Executors.defaultThreadFactory(), <span class="keyword">new</span> <span class="title class_">ThreadPoolExecutor</span>.AbortPolicy());    CompletableFuture&lt;Void&gt; completableFuture = CompletableFuture.supplyAsync(()-&gt;&#123;        <span class="keyword">try</span> &#123;TimeUnit.MILLISECONDS.sleep(<span class="number">20</span>);&#125; <span class="keyword">catch</span> (InterruptedException e) &#123;e.printStackTrace();&#125;        System.out.println(<span class="string">&quot;1号任务&quot;</span>+<span class="string">&quot;\t&quot;</span>+Thread.currentThread().getName());        <span class="keyword">return</span> <span class="string">&quot;abcd&quot;</span>;    &#125;,threadPoolExecutor).thenRunAsync(()-&gt;&#123;        <span class="keyword">try</span> &#123;TimeUnit.MILLISECONDS.sleep(<span class="number">20</span>);&#125; <span class="keyword">catch</span> (InterruptedException e) &#123;e.printStackTrace();&#125;        System.out.println(<span class="string">&quot;2号任务&quot;</span>+<span class="string">&quot;\t&quot;</span>+Thread.currentThread().getName());    &#125;).thenRun(()-&gt;&#123;        <span class="keyword">try</span> &#123;TimeUnit.MILLISECONDS.sleep(<span class="number">20</span>);&#125; <span class="keyword">catch</span> (InterruptedException e) &#123;e.printStackTrace();&#125;        System.out.println(<span class="string">&quot;3号任务&quot;</span>+<span class="string">&quot;\t&quot;</span>+Thread.currentThread().getName());    &#125;).thenRun(()-&gt;&#123;        <span class="keyword">try</span> &#123;TimeUnit.MILLISECONDS.sleep(<span class="number">20</span>);&#125; <span class="keyword">catch</span> (InterruptedException e) &#123;e.printStackTrace();&#125;        System.out.println(<span class="string">&quot;4号任务&quot;</span>+<span class="string">&quot;\t&quot;</span>+Thread.currentThread().getName());    &#125;);    Thread.sleep(<span class="number">2000</span>);    threadPoolExecutor.shutdown();&#125;</code></pre><p>运行结果：</p><pre><code class="highlight shell">1号任务pool-1-thread-12号任务ForkJoinPool.commonPool-worker-253号任务ForkJoinPool.commonPool-worker-254号任务ForkJoinPool.commonPool-worker-25</code></pre></li><li><p>特殊情况, 直接使用main线程处理</p><pre><code class="highlight java"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">m7</span><span class="params">()</span> <span class="keyword">throws</span> InterruptedException &#123;    <span class="type">ThreadPoolExecutor</span> <span class="variable">threadPoolExecutor</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ThreadPoolExecutor</span>(<span class="number">1</span>, <span class="number">20</span>, <span class="number">1L</span>, TimeUnit.SECONDS, <span class="keyword">new</span> <span class="title class_">LinkedBlockingQueue</span>&lt;&gt;(<span class="number">50</span>), Executors.defaultThreadFactory(), <span class="keyword">new</span> <span class="title class_">ThreadPoolExecutor</span>.AbortPolicy());    CompletableFuture&lt;Void&gt; completableFuture = CompletableFuture.supplyAsync(()-&gt;&#123;<span class="comment">//        try &#123;TimeUnit.MILLISECONDS.sleep(20);&#125; catch (InterruptedException e) &#123;e.printStackTrace();&#125;</span>        System.out.println(<span class="string">&quot;1号任务&quot;</span>+<span class="string">&quot;\t&quot;</span>+Thread.currentThread().getName());        <span class="keyword">return</span> <span class="string">&quot;abcd&quot;</span>;    &#125;,threadPoolExecutor).thenRunAsync(()-&gt;&#123;<span class="comment">//        try &#123;TimeUnit.MILLISECONDS.sleep(20);&#125; catch (InterruptedException e) &#123;e.printStackTrace();&#125;</span>        System.out.println(<span class="string">&quot;2号任务&quot;</span>+<span class="string">&quot;\t&quot;</span>+Thread.currentThread().getName());    &#125;).thenRun(()-&gt;&#123;<span class="comment">//        try &#123;TimeUnit.MILLISECONDS.sleep(20);&#125; catch (InterruptedException e) &#123;e.printStackTrace();&#125;</span>        System.out.println(<span class="string">&quot;3号任务&quot;</span>+<span class="string">&quot;\t&quot;</span>+Thread.currentThread().getName());    &#125;).thenRun(()-&gt;&#123;<span class="comment">//        try &#123;TimeUnit.MILLISECONDS.sleep(20);&#125; catch (InterruptedException e) &#123;e.printStackTrace();&#125;</span>        System.out.println(<span class="string">&quot;4号任务&quot;</span>+<span class="string">&quot;\t&quot;</span>+Thread.currentThread().getName());    &#125;);    Thread.sleep(<span class="number">2000</span>);    threadPoolExecutor.shutdown();&#125;</code></pre><p> 运行结果：</p><pre><code class="highlight shell">1号任务pool-1-thread-12号任务ForkJoinPool.commonPool-worker-253号任务main4号任务main</code></pre></li></ul><h2 id="5-对计算速度进行选用"><a href="#5-对计算速度进行选用" class="headerlink" title="5. 对计算速度进行选用"></a>5. 对计算速度进行选用</h2><ul><li>applyToEither 优先选择运行速度快的任务的结果</li></ul><pre><code class="highlight java"><span class="comment">/**</span><span class="comment"> * 对计算速度进行选用</span><span class="comment"> */</span><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">m4</span><span class="params">()</span> &#123;    System.out.println(CompletableFuture.supplyAsync(() -&gt; &#123;        <span class="comment">//暂停几秒钟线程</span>        <span class="keyword">try</span> &#123;            TimeUnit.SECONDS.sleep(<span class="number">1</span>);        &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;            e.printStackTrace();        &#125;        <span class="keyword">return</span> <span class="number">1</span>;    &#125;).applyToEither(CompletableFuture.supplyAsync(() -&gt; &#123;        <span class="keyword">try</span> &#123;            TimeUnit.SECONDS.sleep(<span class="number">2</span>);        &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;            e.printStackTrace();        &#125;        <span class="keyword">return</span> <span class="number">2</span>;    &#125;), r -&gt; &#123;        <span class="keyword">return</span> r;    &#125;).join());    <span class="comment">//暂停几秒钟线程</span>    <span class="keyword">try</span> &#123;        TimeUnit.SECONDS.sleep(<span class="number">3</span>);    &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;        e.printStackTrace();    &#125;&#125;</code></pre><p>运行结果：</p><pre><code class="highlight shell">1</code></pre><h2 id="6-对计算结果进行合并"><a href="#6-对计算结果进行合并" class="headerlink" title="6. 对计算结果进行合并"></a>6. 对计算结果进行合并</h2><ul><li><p><code>thenCombine</code> 合并</p><ul><li>两个 <code>CompletionStage</code> 任务都完成后，最终能把两个任务的结果一起交给 <code>thenCombine</code> 来处理</li><li>先完成的先等着，等待其它分支任务</li></ul><pre><code class="highlight java"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">m5</span><span class="params">()</span> <span class="keyword">throws</span> ExecutionException, InterruptedException &#123;    CompletableFuture&lt;Integer&gt; thenCombineResult = CompletableFuture.supplyAsync(() -&gt; &#123;        System.out.println(Thread.currentThread().getName() + <span class="string">&quot;\t&quot;</span> + <span class="string">&quot;---come in 1&quot;</span>);        <span class="keyword">return</span> <span class="number">10</span>;    &#125;).thenCombine(CompletableFuture.supplyAsync(() -&gt; &#123;        System.out.println(Thread.currentThread().getName() + <span class="string">&quot;\t&quot;</span> + <span class="string">&quot;---come in 2&quot;</span>);        <span class="keyword">return</span> <span class="number">20</span>;    &#125;), (x, y) -&gt; &#123;        System.out.println(Thread.currentThread().getName() + <span class="string">&quot;\t&quot;</span> + <span class="string">&quot;---come in 3&quot;</span>);        <span class="keyword">return</span> x + y;    &#125;).thenCombine(CompletableFuture.supplyAsync(() -&gt; &#123;        System.out.println(Thread.currentThread().getName() + <span class="string">&quot;\t&quot;</span> + <span class="string">&quot;---come in 4&quot;</span>);        <span class="keyword">return</span> <span class="number">30</span>;    &#125;), (a, b) -&gt; &#123;        System.out.println(Thread.currentThread().getName() + <span class="string">&quot;\t&quot;</span> + <span class="string">&quot;---come in 5&quot;</span>);        <span class="keyword">return</span> a + b;    &#125;);    System.out.println(<span class="string">&quot;-----主线程结束，END&quot;</span>);    System.out.println(thenCombineResult.get());    <span class="comment">// 主线程不要立刻结束，否则CompletableFuture默认使用的线程池会立刻关闭:</span>    <span class="keyword">try</span> &#123;        TimeUnit.SECONDS.sleep(<span class="number">10</span>);    &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;        e.printStackTrace();    &#125;&#125;</code></pre><p>打印结果：</p><pre><code class="highlight shell">ForkJoinPool.commonPool-worker-25---come in 1ForkJoinPool.commonPool-worker-25---come in 2main---come in 3ForkJoinPool.commonPool-worker-18---come in 4main---come in 5-----主线程结束，END60</code></pre></li></ul>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;一、Future接口概述&quot;&gt;&lt;a href=&quot;#一、Future接口概述&quot; class=&quot;headerlink&quot; title=&quot;一、Future接口概述&quot;&gt;&lt;/a&gt;一、Future接口概述&lt;/h1&gt;&lt;p&gt;Future接口（FutureTask实现类）定义了操作异步</summary>
      
    
    
    
    <category term="JUC" scheme="https://georgechan95.github.io/categories/JUC/"/>
    
    
    <category term="juc" scheme="https://georgechan95.github.io/tags/juc/"/>
    
    <category term="java" scheme="https://georgechan95.github.io/tags/java/"/>
    
  </entry>
  
  <entry>
    <title>01-JUC进阶-线程基础</title>
    <link href="https://georgechan95.github.io/blog/3d102971.html"/>
    <id>https://georgechan95.github.io/blog/3d102971.html</id>
    <published>2024-09-18T14:32:00.000Z</published>
    <updated>2024-09-18T08:10:02.284Z</updated>
    
    <content type="html"><![CDATA[<h1 id="一、Java多线程相关概念"><a href="#一、Java多线程相关概念" class="headerlink" title="一、Java多线程相关概念"></a>一、Java多线程相关概念</h1><ul><li><p><strong>进程</strong></p><p>是程序的⼀次执⾏，是系统进⾏资源分配和调度的独⽴单位，每⼀个进程都有它⾃⼰的内存空间和系统资源</p></li><li><p><strong>线程</strong></p><ul><li>在同⼀个进程内⼜可以执⾏多个任务，⽽这每⼀个任务我们就可以看做是⼀个线程</li><li>⼀个进程会有1个或多个线程的</li></ul></li><li><p><strong>管程</strong></p><p>Monitor(监视器)，也就是我们平时所说的锁</p><p>Monitor其实是一种同步机制，他的义务是保证（同一时间）只有一个线程可以访问被保护的数据和代码。</p><p>JVM中同步是基于进入和退出监视器对象(Monitor,管程对象)来实现的，每个对象实例都会有一个Monitor对象，</p><pre><code class="highlight java"><span class="type">Object</span> <span class="variable">o</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Object</span>();<span class="keyword">new</span> <span class="title class_">Thread</span>(() -&gt; &#123;    <span class="keyword">synchronized</span> (o)    &#123;    &#125;&#125;,<span class="string">&quot;t1&quot;</span>).start();</code></pre><p>Monitor对象会和Java对象一同创建并销毁，它底层是由C++语言来实现的。</p></li></ul><p><img src="https://raw.githubusercontent.com/GeorgeChan95/blogimg/master/img/2024/09/18/20240918-153629.png" alt="同步指令"></p><h1 id="二、用户线程和守护线程"><a href="#二、用户线程和守护线程" class="headerlink" title="二、用户线程和守护线程"></a>二、用户线程和守护线程</h1><p>Java线程分为用户线程和守护线程，<strong>线程的daemon属性为true表示是守护线程，false表示是用户线程</strong></p><ul><li><p>守护线程</p><p>是一种特殊的线程，在后台默默地完成一些系统性的服务，比如垃圾回收线程</p></li><li><p>用户线程</p><p>是系统的工作线程，它会完成这个程序需要完成的业务操作</p></li></ul><p><strong>代码示例：</strong></p><pre><code class="highlight java"><span class="comment">/**</span><span class="comment"> * &lt;p&gt;</span><span class="comment"> * 演示守护线程和用户线程</span><span class="comment"> * &lt;/p&gt;</span><span class="comment"> */</span><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">DaemonDemo</span> &#123;    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;        <span class="type">Thread</span> <span class="variable">a</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Thread</span>(() -&gt; &#123;            System.out.println(Thread.currentThread().getName() + <span class="string">&quot; come in：\t&quot;</span>                    + (Thread.currentThread().isDaemon() ? <span class="string">&quot;守护线程&quot;</span> : <span class="string">&quot;用户线程&quot;</span>));            <span class="keyword">while</span> (<span class="literal">true</span>) &#123;            &#125;        &#125;, <span class="string">&quot;a&quot;</span>);        a.setDaemon(<span class="literal">true</span>); <span class="comment">// daemon设置为true，表示该线程为守护线程</span>        <span class="comment">// setDaemon 必须在 start() 方法之前</span>        a.start();        <span class="comment">//暂停几秒钟线程</span>        <span class="keyword">try</span> &#123;            TimeUnit.SECONDS.sleep(<span class="number">2</span>);        &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;            e.printStackTrace();        &#125;        System.out.println(Thread.currentThread().getName() + <span class="string">&quot;\t&quot;</span> + <span class="string">&quot; ----task is over&quot;</span>);    &#125;&#125;</code></pre><p>运行结果：</p><pre><code class="highlight shell">a come in：守护线程main ----task is over</code></pre><p>结论：当主线程(用户线程)结束后，守护线程也随之结束了。</p><p><strong>重点</strong></p><ul><li><p>当程序中所有用户线程执行完毕之后，不管守护线程是否结束，系统都会自动退出</p><p>如果用户线程全部结束了，意味着程序需要完成的业务操作已经结束了，系统可以退出了。所以当系统只剩下守护进程的时候，java虚拟机会自动退出</p></li><li><p>设置守护线程，需要在start()方法之前进行</p></li></ul>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;一、Java多线程相关概念&quot;&gt;&lt;a href=&quot;#一、Java多线程相关概念&quot; class=&quot;headerlink&quot; title=&quot;一、Java多线程相关概念&quot;&gt;&lt;/a&gt;一、Java多线程相关概念&lt;/h1&gt;&lt;ul&gt;
&lt;li&gt;&lt;p&gt;&lt;strong&gt;进程&lt;/stron</summary>
      
    
    
    
    <category term="JUC" scheme="https://georgechan95.github.io/categories/JUC/"/>
    
    
    <category term="juc" scheme="https://georgechan95.github.io/tags/juc/"/>
    
    <category term="java" scheme="https://georgechan95.github.io/tags/java/"/>
    
  </entry>
  
  <entry>
    <title>11-CompletableFuture</title>
    <link href="https://georgechan95.github.io/blog/37d56d14.html"/>
    <id>https://georgechan95.github.io/blog/37d56d14.html</id>
    <published>2024-09-16T08:12:00.000Z</published>
    <updated>2024-09-18T07:30:50.861Z</updated>
    
    <content type="html"><![CDATA[<h1 id="一、CompletableFuture-简介"><a href="#一、CompletableFuture-简介" class="headerlink" title="一、CompletableFuture 简介"></a>一、CompletableFuture 简介</h1><p>CompletableFuture 在 Java 里面被用于异步编程，异步通常意味着非阻塞，可以使得我们的任务单独运行在与主线程分离的其他线程中，并且通过回调可以在主线程中得到异步任务的执行状态，是否完成，和是否异常等信息。</p><p>CompletableFuture 实现了 Future, CompletionStage 接口，实现了 Future接口就可以兼容现在有线程池框架，而 CompletionStage 接口才是异步编程的接口抽象，里面定义多种异步方法，通过这两者集合，从而打造出了强大的 CompletableFuture 类。</p><h1 id="二、Future-与-CompletableFuture"><a href="#二、Future-与-CompletableFuture" class="headerlink" title="二、Future 与 CompletableFuture"></a>二、Future 与 CompletableFuture</h1><p>Futrue 在 Java 里面，通常用来表示一个异步任务的引用，比如我们将任务提交到线程池里面，然后我们会得到一个 Futrue，在 Future 里面有 isDone 方法来 判断任务是否处理结束，还有 get 方法可以一直阻塞直到任务结束然后获取结果，但整体来说这种方式，还是同步的，因为需要客户端不断阻塞等待或者不断轮询才能知道任务是否完成。</p><p><strong>Future 的主要缺点如下：</strong></p><ul><li><p>不支持手动完成</p><p>我提交了一个任务，但是执行太慢了，我通过其他路径已经获取到了任务结果，现在没法把这个任务结果通知到正在执行的线程，所以必须主动取消或者一直等待它执行完成</p></li><li><p>不支持进一步的非阻塞调用</p><p>通过 Future 的 get 方法会一直阻塞到任务完成，但是想在获取任务之后执行额外的任务，因为 Future 不支持回调函数，所以无法实现这个功能</p></li><li><p>不支持链式调用</p><p>对于 Future 的执行结果，我们想继续传到下一个 Future 处理使用，从而形成一个链式的 pipline 调用，这在 Future 中是没法实现的。</p></li><li><p>不支持多个 Future 合并</p><p>比如我们有 10 个 Future 并行执行，我们想在所有的 Future 运行完毕之后，执行某些函数，是没法通过 Future 实现的。</p></li><li><p>不支持异常处理</p><p>Future 的 API 没有任何的异常处理的 api，所以在异步运行时，如果出了问题是不好定位的。</p></li></ul><h1 id="三、CompletableFuture-入门"><a href="#三、CompletableFuture-入门" class="headerlink" title="三、CompletableFuture 入门"></a>三、CompletableFuture 入门</h1><h2 id="1-使用-CompletableFuture"><a href="#1-使用-CompletableFuture" class="headerlink" title="1. 使用 CompletableFuture"></a>1. 使用 CompletableFuture</h2><p>场景:主线程里面创建一个 CompletableFuture，然后主线程调用 get 方法会阻塞，最后我们在一个子线程中使其终止。</p><pre><code class="highlight java"><span class="comment">/**</span><span class="comment"> * 主线程里面创建一个 CompletableFuture，然后主线程调用 get 方法会阻塞，最后我们在一个子线程中使其终止</span><span class="comment"> *</span><span class="comment"> * <span class="doctag">@throws</span> InterruptedException</span><span class="comment"> * <span class="doctag">@throws</span> ExecutionException</span><span class="comment"> */</span><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">method1</span><span class="params">()</span> <span class="keyword">throws</span> InterruptedException, ExecutionException &#123;    CompletableFuture&lt;String&gt; future = <span class="keyword">new</span> <span class="title class_">CompletableFuture</span>&lt;&gt;();    <span class="keyword">new</span> <span class="title class_">Thread</span>(() -&gt; &#123;        <span class="keyword">try</span> &#123;            System.out.println(Thread.currentThread().getName() + <span class="string">&quot;子线程开始干活&quot;</span>);            <span class="comment">//子线程睡 5 秒</span>            Thread.sleep(<span class="number">5000</span>);            <span class="comment">//在子线程中完成主线程</span>            future.complete(<span class="string">&quot;success&quot;</span>);        &#125; <span class="keyword">catch</span> (Exception e) &#123;            e.printStackTrace();        &#125;    &#125;, <span class="string">&quot;A&quot;</span>).start();    <span class="comment">//主线程调用 get 方法阻塞</span>    System.out.println(<span class="string">&quot;主线程调用 get 方法获取结果为: &quot;</span> + future.get());    System.out.println(<span class="string">&quot;主线程完成,阻塞结束!!!!!!&quot;</span>);&#125;</code></pre><p>打印结果:</p><pre><code class="highlight shell">A子线程开始干活主线程调用 get 方法获取结果为: success主线程完成,阻塞结束!!!!!!</code></pre><h2 id="2-没有返回值的异步任务"><a href="#2-没有返回值的异步任务" class="headerlink" title="2. 没有返回值的异步任务"></a>2. 没有返回值的异步任务</h2><pre><code class="highlight java"><span class="comment">/**</span><span class="comment">    * 没有返回值的异步任务</span><span class="comment">    *</span><span class="comment">    * <span class="doctag">@throws</span> InterruptedException</span><span class="comment">    * <span class="doctag">@throws</span> ExecutionException</span><span class="comment">    */</span>   <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">method2</span><span class="params">()</span> <span class="keyword">throws</span> InterruptedException, ExecutionException &#123;       CompletableFuture&lt;Void&gt; future = <span class="keyword">new</span> <span class="title class_">CompletableFuture</span>&lt;&gt;();       <span class="keyword">new</span> <span class="title class_">Thread</span>(() -&gt; &#123;           <span class="keyword">try</span> &#123;               System.out.println(Thread.currentThread().getName() + <span class="string">&quot;开始作业&quot;</span>);               TimeUnit.SECONDS.sleep(<span class="number">5</span>);               System.out.println(Thread.currentThread().getName() + <span class="string">&quot; 完成作业&quot;</span>);           &#125; <span class="keyword">catch</span> (Exception e) &#123;               e.printStackTrace();           &#125;       &#125;, <span class="string">&quot;线程1&quot;</span>).start();       <span class="comment">//主线程调用 get 方法阻塞</span>       future.get();       System.out.println(<span class="string">&quot;主线程结束&quot;</span>);   &#125;</code></pre><p>运行结果:</p><pre><code class="highlight shell">线程1开始作业线程1 完成作业</code></pre><h2 id="3-有返回值的异步任务"><a href="#3-有返回值的异步任务" class="headerlink" title="3. 有返回值的异步任务"></a>3. 有返回值的异步任务</h2><pre><code class="highlight java"><span class="comment">/**</span><span class="comment"> * 有返回值的异步任务</span><span class="comment"> *</span><span class="comment"> * <span class="doctag">@throws</span> InterruptedException</span><span class="comment"> * <span class="doctag">@throws</span> ExecutionException</span><span class="comment"> */</span><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">method3</span><span class="params">()</span> <span class="keyword">throws</span> InterruptedException, ExecutionException &#123;    CompletableFuture&lt;String&gt; future = CompletableFuture.supplyAsync(<span class="keyword">new</span> <span class="title class_">Supplier</span>&lt;String&gt;() &#123;        <span class="meta">@Override</span>        <span class="keyword">public</span> String <span class="title function_">get</span><span class="params">()</span> &#123;            <span class="keyword">try</span> &#123;                System.out.println(Thread.currentThread().getName() + <span class="string">&quot;开始作业&quot;</span>);                TimeUnit.SECONDS.sleep(<span class="number">5</span>);                System.out.println(Thread.currentThread().getName() + <span class="string">&quot; 完成作业&quot;</span>);            &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;                e.printStackTrace();            &#125;            <span class="keyword">return</span> <span class="string">&quot;异步结果&quot;</span>;        &#125;    &#125;);    <span class="comment">//主线程调用 get 方法阻塞</span>    future.get();    System.out.println(<span class="string">&quot;主线程结束&quot;</span>);&#125;</code></pre><p><strong>运行结果:</strong></p><pre><code class="highlight shell">ForkJoinPool.commonPool-worker-19开始作业ForkJoinPool.commonPool-worker-19 完成作业主线程结束</code></pre><h2 id="4-线程依赖"><a href="#4-线程依赖" class="headerlink" title="4. 线程依赖"></a>4. 线程依赖</h2><p>当一个线程依赖另一个线程时，可以使用 thenApply 方法来把这两个线程串行化。</p><pre><code class="highlight java"><span class="keyword">private</span> <span class="keyword">static</span> <span class="type">int</span> <span class="variable">num</span> <span class="operator">=</span> <span class="number">0</span>;<span class="comment">/**</span><span class="comment"> * 线程依赖</span><span class="comment"> * 先对一个数加 10,然后取平方</span><span class="comment"> * <span class="doctag">@throws</span> InterruptedException</span><span class="comment"> * <span class="doctag">@throws</span> ExecutionException</span><span class="comment"> */</span><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">method4</span><span class="params">()</span> <span class="keyword">throws</span> InterruptedException, ExecutionException &#123;    CompletableFuture&lt;Integer&gt; future = CompletableFuture.supplyAsync(() -&gt; &#123;        System.out.println(Thread.currentThread().getName() + <span class="string">&quot;开始对值进行 +10 操作&quot;</span>);        num += <span class="number">10</span>;        System.out.println(Thread.currentThread().getName() + <span class="string">&quot; 完成作业&quot;</span>);        <span class="keyword">return</span> num;    &#125;).thenApply(<span class="keyword">new</span> <span class="title class_">Function</span>&lt;Integer, Integer&gt;() &#123;        <span class="meta">@Override</span>        <span class="keyword">public</span> Integer <span class="title function_">apply</span><span class="params">(Integer data)</span> &#123;            System.out.println(Thread.currentThread().getName() + <span class="string">&quot;开始对值进行 取平方 操作&quot;</span>);            System.out.println(<span class="string">&quot;integer: &quot;</span> + data);            <span class="keyword">return</span> data*data;        &#125;    &#125;);    <span class="comment">//主线程调用 get 方法阻塞</span>    System.out.println(<span class="string">&quot;主线程阻塞获取结果,结果为:&quot;</span> + future.get());    System.out.println(<span class="string">&quot;主线程结束&quot;</span>);&#125;</code></pre><p>运行结果:</p><pre><code class="highlight shell">ForkJoinPool.commonPool-worker-19开始对值进行 +10 操作ForkJoinPool.commonPool-worker-19 完成作业ForkJoinPool.commonPool-worker-19开始对值进行 取平方 操作integer: 10主线程阻塞获取结果,结果为:100主线程结束</code></pre><h2 id="5-消费处理结果"><a href="#5-消费处理结果" class="headerlink" title="5. 消费处理结果"></a>5. 消费处理结果</h2><p>thenAccept 消费处理结果, 接收任务的处理结果，并消费处理，无返回结果。</p><pre><code class="highlight java"><span class="comment">/**</span><span class="comment"> * thenAccept 消费处理结果, 接收任务的处理结果，并消费处理，无返回结果。</span><span class="comment"> * </span><span class="comment"> * <span class="doctag">@throws</span> InterruptedException</span><span class="comment"> * <span class="doctag">@throws</span> ExecutionException</span><span class="comment"> */</span><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">method5</span><span class="params">()</span> <span class="keyword">throws</span> InterruptedException, ExecutionException &#123;    CompletableFuture&lt;Void&gt; completableFuture = CompletableFuture.supplyAsync(() -&gt; &#123;        System.out.println(Thread.currentThread().getName() + <span class="string">&quot;开始对值进行 +10 操作&quot;</span>);        num += <span class="number">10</span>;        System.out.println(Thread.currentThread().getName() + <span class="string">&quot; 完成作业&quot;</span>);        <span class="keyword">return</span> num;    &#125;).thenApply(data -&gt; &#123;        System.out.println(Thread.currentThread().getName() + <span class="string">&quot;开始对值进行 取平方 操作&quot;</span>);        System.out.println(<span class="string">&quot;integer: &quot;</span> + data);        <span class="keyword">return</span> data * data;    &#125;).thenAccept(integer -&gt; &#123;        System.out.println(<span class="string">&quot;子线程全部处理完成,最后调用了 accept,结果为:&quot;</span> + integer);    &#125;);    <span class="comment">//主线程调用 get 方法阻塞</span>    System.out.println(<span class="string">&quot;主线程阻塞获取结果,结果为:&quot;</span> + completableFuture.get());    System.out.println(<span class="string">&quot;主线程结束&quot;</span>);&#125;</code></pre><p>运行结果:</p><pre><code class="highlight shell">ForkJoinPool.commonPool-worker-19开始对值进行 +10 操作ForkJoinPool.commonPool-worker-19 完成作业ForkJoinPool.commonPool-worker-19开始对值进行 取平方 操作integer: 10子线程全部处理完成,最后调用了 accept,结果为:100主线程阻塞获取结果,结果为:null主线程结束</code></pre><h2 id="6-异常处理"><a href="#6-异常处理" class="headerlink" title="6. 异常处理"></a>6. 异常处理</h2><p>exceptionally 异常处理,出现异常时触发</p><pre><code class="highlight java"><span class="comment">/**</span><span class="comment"> * exceptionally 异常处理,出现异常时触发</span><span class="comment"> * <span class="doctag">@throws</span> InterruptedException</span><span class="comment"> * <span class="doctag">@throws</span> ExecutionException</span><span class="comment"> */</span><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">method6</span><span class="params">()</span> <span class="keyword">throws</span> InterruptedException, ExecutionException &#123;    CompletableFuture&lt;Integer&gt; completableFuture = CompletableFuture.supplyAsync(() -&gt; &#123;        <span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">1</span> / <span class="number">0</span>;        System.out.println(Thread.currentThread().getName() + <span class="string">&quot;开始对值进行 +10 操作&quot;</span>);        num += <span class="number">10</span>;        System.out.println(Thread.currentThread().getName() + <span class="string">&quot; 完成作业&quot;</span>);        <span class="keyword">return</span> num;    &#125;).exceptionally(throwable -&gt; &#123;        System.out.println(throwable.getMessage());        <span class="keyword">return</span> -<span class="number">1</span>;    &#125;);    <span class="comment">//主线程调用 get 方法阻塞</span>    System.out.println(<span class="string">&quot;主线程阻塞获取结果,结果为:&quot;</span> + completableFuture.get());    System.out.println(<span class="string">&quot;主线程结束&quot;</span>);&#125;</code></pre><p>执行结果:</p><pre><code class="highlight shell">java.lang.ArithmeticException: / by zero主线程阻塞获取结果,结果为:-1主线程结束</code></pre><p><strong>handle 类似于 thenAccept&#x2F;thenRun 方法,是最后一步的处理调用,但是同时可以处理异常</strong></p><pre><code class="highlight java"><span class="comment">/**</span><span class="comment"> * handle 类似于 thenAccept/thenRun 方法,是最后一步的处理调用,但是同时可以处理异常</span><span class="comment"> */</span><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">method7</span><span class="params">()</span> &#123;    System.out.println(<span class="string">&quot;主线程开始&quot;</span>);    CompletableFuture&lt;Integer&gt; future = CompletableFuture.supplyAsync(() -&gt; &#123;        System.out.println(<span class="string">&quot;加 10 任务开始&quot;</span>);        num += <span class="number">10</span>;        <span class="keyword">return</span> num;    &#125;).handle((i, ex) -&gt; &#123;        System.out.println(<span class="string">&quot;进入 handle 方法&quot;</span>);        <span class="keyword">if</span> (ex != <span class="literal">null</span>) &#123;            System.out.print(<span class="string">&quot;发生了异常,内容为:&quot;</span>);            System.out.println(ex.getMessage());            <span class="keyword">return</span> -<span class="number">1</span>;        &#125; <span class="keyword">else</span> &#123;            System.out.println(<span class="string">&quot;正常完成,内容为: &quot;</span> + i);            <span class="keyword">return</span> i;        &#125;    &#125;);&#125;</code></pre><p>运行结果:</p><pre><code class="highlight shell">主线程开始加 10 任务开始进入 handle 方法正常完成,内容为: 10</code></pre><p>发生异常时:</p><pre><code class="highlight shell">主线程开始加 10 任务开始进入 handle 方法发生了异常,内容为:java.lang.ArithmeticException: / by zero</code></pre><h2 id="7-结果合并"><a href="#7-结果合并" class="headerlink" title="7. 结果合并"></a>7. 结果合并</h2><p><strong>thenCompose 合并两个有依赖关系的 CompletableFutures 的执行结果.</strong></p><pre><code class="highlight java"><span class="comment">/**</span><span class="comment"> * thenCompose 合并两个有依赖关系的 CompletableFutures 的执行结果</span><span class="comment"> * <span class="doctag">@throws</span> ExecutionException</span><span class="comment"> * <span class="doctag">@throws</span> InterruptedException</span><span class="comment"> */</span><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">method8</span><span class="params">()</span> <span class="keyword">throws</span> ExecutionException, InterruptedException &#123;    System.out.println(<span class="string">&quot;主线程开始......&quot;</span>);    <span class="comment">//第一步加 10</span>    CompletableFuture&lt;Integer&gt; future1 = CompletableFuture.supplyAsync(() -&gt; &#123;        System.out.println(Thread.currentThread().getName() + <span class="string">&quot;线程执行num加10&quot;</span>);        num += <span class="number">10</span>;        <span class="keyword">return</span> num;    &#125;);    <span class="comment">// 合并</span>    CompletableFuture&lt;Integer&gt; future2 = future1.thenCompose(data -&gt; CompletableFuture.supplyAsync(() -&gt; &#123;        System.out.println(Thread.currentThread().getName() + <span class="string">&quot;线程执行合并&quot;</span>);        <span class="keyword">return</span> data + <span class="number">1</span>;    &#125;));    System.out.println(<span class="string">&quot;主线程阻塞获取结果: &quot;</span> + future1.get());    System.out.println(<span class="string">&quot;主线程阻塞获取结果: &quot;</span> + future2.get());&#125;</code></pre><p>执行结果:</p><pre><code class="highlight shell">主线程开始......ForkJoinPool.commonPool-worker-19线程执行num加10ForkJoinPool.commonPool-worker-5线程执行合并主线程阻塞获取结果: 10主线程阻塞获取结果: 11</code></pre><p><strong>thenCombine 合并两个没有依赖关系的 CompletableFutures 任务</strong></p><pre><code class="highlight java"><span class="comment">/**</span><span class="comment"> * thenCombine 合并两个没有依赖关系的 CompletableFutures 任务</span><span class="comment"> * <span class="doctag">@throws</span> ExecutionException</span><span class="comment"> * <span class="doctag">@throws</span> InterruptedException</span><span class="comment"> */</span><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">method9</span><span class="params">()</span> <span class="keyword">throws</span> ExecutionException, InterruptedException &#123;    System.out.println(<span class="string">&quot;主线程开始......&quot;</span>);    <span class="comment">//第一个线程加 10</span>    CompletableFuture&lt;Integer&gt; future1 = CompletableFuture.supplyAsync(() -&gt; &#123;        System.out.println(Thread.currentThread().getName() + <span class="string">&quot;线程执行num加10&quot;</span>);        num += <span class="number">10</span>;        <span class="keyword">return</span> num;    &#125;);    <span class="comment">// 第二个线程 *10</span>    CompletableFuture&lt;Integer&gt; future2 = CompletableFuture.supplyAsync(() -&gt; &#123;        System.out.println(Thread.currentThread().getName() + <span class="string">&quot;线程执行num * 10&quot;</span>);        num *= <span class="number">10</span>;        <span class="keyword">return</span> num;    &#125;);    <span class="comment">// 合并两个CompletableFuture</span>    CompletableFuture&lt;Object&gt; combine = future1.thenCombine(future2, (a, b) -&gt; &#123;        List&lt;Integer&gt; list = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();        list.add(a);        list.add(b);        <span class="keyword">return</span> list;    &#125;);    System.out.println(<span class="string">&quot;主线程阻塞获取future1结果: &quot;</span> + future1.get());    System.out.println(<span class="string">&quot;主线程阻塞获取future2结果: &quot;</span> + future2.get());    System.out.println(<span class="string">&quot;主线程阻塞获取combine结果: &quot;</span> + combine.get());&#125;</code></pre><p>执行结果:</p><pre><code class="highlight shell">主线程开始......ForkJoinPool.commonPool-worker-19线程执行num加10ForkJoinPool.commonPool-worker-5线程执行num * 10主线程阻塞获取future1结果: 10主线程阻塞获取future2结果: 100主线程阻塞获取combine结果: [10, 100]</code></pre><p><strong>合并多个任务的结果 allOf 与 anyOf</strong></p><p><strong>allOf:</strong>  一系列独立的 future 任务，等其所有的任务执行完后做一些事情</p><pre><code class="highlight java"><span class="comment">/**</span><span class="comment"> * allOf: 一系列独立的 future 任务，等其所有的任务执行完后做一些事情</span><span class="comment"> */</span><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">method10</span><span class="params">()</span> &#123;    System.out.println(<span class="string">&quot;主线程开始&quot;</span>);    List&lt;CompletableFuture&gt; list = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();    CompletableFuture&lt;Integer&gt; job1 = CompletableFuture.supplyAsync(() -&gt; &#123;        System.out.println(<span class="string">&quot;加 10 任务开始&quot;</span>);        num += <span class="number">10</span>;        <span class="keyword">return</span> num;    &#125;);    list.add(job1);    CompletableFuture&lt;Integer&gt; job2 = CompletableFuture.supplyAsync(() -&gt; &#123;        System.out.println(<span class="string">&quot;乘以 10 任务开始&quot;</span>);        num = num * <span class="number">10</span>;        <span class="keyword">return</span> num;    &#125;);    list.add(job2);    CompletableFuture&lt;Integer&gt; job3 = CompletableFuture.supplyAsync(() -&gt; &#123;        System.out.println(<span class="string">&quot;减以 10 任务开始&quot;</span>);        num = num * <span class="number">10</span>;        <span class="keyword">return</span> num;    &#125;);    list.add(job3);    CompletableFuture&lt;Integer&gt; job4 = CompletableFuture.supplyAsync(() -&gt; &#123;        System.out.println(<span class="string">&quot;除以 10 任务开始&quot;</span>);        num = num * <span class="number">10</span>;        <span class="keyword">return</span> num;    &#125;);    list.add(job4);    <span class="comment">//多任务合并</span>    List&lt;Integer&gt; collect =            list.stream().map(CompletableFuture&lt;Integer&gt;::join).collect(Collectors.toList());    System.out.println(<span class="string">&quot;所有任务执行结束,结果为: &quot;</span> + collect);&#125;</code></pre><p>运行结果:</p><pre><code class="highlight shell">主线程开始乘以 10 任务开始加 10 任务开始减以 10 任务开始除以 10 任务开始所有任务执行结束,结果为: [10, 0, 100, 1000]</code></pre><p><strong>anyOf</strong>: 只要在多个 future 里面有一个返回，整个任务就可以结束，而不需要等到每一个future 结束</p><pre><code class="highlight java"><span class="comment">/**</span><span class="comment"> * anyOf: 只要在多个 future 里面有一个返回，整个任务就可以结束，而不需要等到每一个future 结束</span><span class="comment"> * <span class="doctag">@throws</span> ExecutionException</span><span class="comment"> * <span class="doctag">@throws</span> InterruptedException</span><span class="comment"> */</span><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">method11</span><span class="params">()</span> <span class="keyword">throws</span> ExecutionException, InterruptedException &#123;    System.out.println(<span class="string">&quot;主线程开始&quot;</span>);    CompletableFuture&lt;Integer&gt;[] futures = <span class="keyword">new</span> <span class="title class_">CompletableFuture</span>[<span class="number">4</span>];    CompletableFuture&lt;Integer&gt; job1 = CompletableFuture.supplyAsync(() -&gt; &#123;        System.out.println(<span class="string">&quot;加 10 任务开始&quot;</span>);        num += <span class="number">10</span>;        <span class="keyword">return</span> num;    &#125;);    futures[<span class="number">0</span>] = job1;    CompletableFuture&lt;Integer&gt; job2 = CompletableFuture.supplyAsync(() -&gt; &#123;        System.out.println(<span class="string">&quot;乘以 10 任务开始&quot;</span>);        num = num * <span class="number">10</span>;        <span class="keyword">return</span> num;    &#125;);    futures[<span class="number">1</span>] = job2;    CompletableFuture&lt;Integer&gt; job3 = CompletableFuture.supplyAsync(() -&gt; &#123;        System.out.println(<span class="string">&quot;减以 10 任务开始&quot;</span>);        num = num * <span class="number">10</span>;        <span class="keyword">return</span> num;    &#125;);    futures[<span class="number">2</span>] = job3;    CompletableFuture&lt;Integer&gt; job4 = CompletableFuture.supplyAsync(() -&gt; &#123;        System.out.println(<span class="string">&quot;除以 10 任务开始&quot;</span>);        num = num * <span class="number">10</span>;        <span class="keyword">return</span> num;    &#125;);    futures[<span class="number">3</span>] = job4;    CompletableFuture&lt;Object&gt; future = CompletableFuture.anyOf(futures);    System.out.println(future.get());    System.out.println(<span class="string">&quot;其中一个任务执行结束,结果为: &quot;</span> + future.get());&#125;</code></pre><p>执行结果:</p><pre><code class="highlight shell">主线程开始乘以 10 任务开始加 10 任务开始减以 10 任务开始10除以 10 任务开始其中一个任务执行结束,结果为: 10</code></pre>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;一、CompletableFuture-简介&quot;&gt;&lt;a href=&quot;#一、CompletableFuture-简介&quot; class=&quot;headerlink&quot; title=&quot;一、CompletableFuture 简介&quot;&gt;&lt;/a&gt;一、CompletableFuture </summary>
      
    
    
    
    <category term="JUC" scheme="https://georgechan95.github.io/categories/JUC/"/>
    
    
    <category term="juc" scheme="https://georgechan95.github.io/tags/juc/"/>
    
    <category term="java" scheme="https://georgechan95.github.io/tags/java/"/>
    
  </entry>
  
  <entry>
    <title>10-Fork/Join</title>
    <link href="https://georgechan95.github.io/blog/31919959.html"/>
    <id>https://georgechan95.github.io/blog/31919959.html</id>
    <published>2024-09-16T05:10:00.000Z</published>
    <updated>2024-09-18T07:30:50.861Z</updated>
    
    <content type="html"><![CDATA[<h1 id="一、Fork-Join-框架简介"><a href="#一、Fork-Join-框架简介" class="headerlink" title="一、Fork&#x2F;Join 框架简介"></a>一、Fork&#x2F;Join 框架简介</h1><p>Fork&#x2F;Join 它可以将一个大的任务拆分成多个子任务进行并行处理，最后将子任务结果合并成最后的计算结果，并进行输出。Fork&#x2F;Join 框架要完成两件事情：</p><p><strong>Fork：把一个复杂任务进行分拆，大事化小</strong></p><p><strong>Join：把分拆任务的结果进行合并</strong></p><p><img src="https://raw.githubusercontent.com/GeorgeChan95/blogimg/master/img/2024/09/16/20240916-150030.png" alt="任务拆分"></p><ul><li><strong>任务分割：</strong>首先 Fork&#x2F;Join 框架需要把大的任务分割成足够小的子任务，如果子任务比较大的话还要对子任务进行继续分割</li><li><strong>执行任务并合并结果：</strong>分割的子任务分别放到双端队列里，然后几个启动线程分别从双端队列里获取任务执行。子任务执行完的结果都放在另外一个队列里，启动一个线程从队列里取数据，然后合并这些数据。</li></ul><p>在 Java 的 Fork&#x2F;Join 框架中，使用两个类完成上述操作</p><ul><li><strong>ForkJoinTask:</strong> 我们要使用 Fork&#x2F;Join 框架，首先需要创建一个 ForkJoin 任务。该类提供了在任务中执行 fork 和 join 的机制。通常情况下我们不需要直接集成 ForkJoinTask 类，只需要继承它的子类，Fork&#x2F;Join 框架提供了两个子类：<ul><li>RecursiveAction：用于没有返回结果的任务</li><li>RecursiveTask: 用于有返回结果的任务</li></ul></li><li><strong>ForkJoinPool</strong>: ForkJoinTask 需要通过 ForkJoinPool 来执行</li><li><strong>RecursiveTask</strong>: 继承后可以实现递归(自己调自己)调用的任务</li></ul><p><strong>Fork&#x2F;Join 框架的实现原理</strong></p><p>ForkJoinPool 由 ForkJoinTask 数组和 ForkJoinWorkerThread 数组组成，ForkJoinTask 数组负责将存放以及将程序提交给 ForkJoinPool，而ForkJoinWorkerThread 负责执行这些任务。</p><h1 id="二、Fork-方法"><a href="#二、Fork-方法" class="headerlink" title="二、Fork 方法"></a>二、Fork 方法</h1><p><img src="https://raw.githubusercontent.com/GeorgeChan95/blogimg/master/img/2024/09/16/20240916-150946.png" alt="ForkJoinPool继承体系"></p><p><img src="https://raw.githubusercontent.com/GeorgeChan95/blogimg/master/img/2024/09/16/20240916-151158.png" alt="ForkJoinTask继承体系"></p><p><strong>Fork 方法的实现原理：</strong> 当我们调用 ForkJoinTask 的 fork 方法时，程序会把任务放在 ForkJoinWorkerThread 的 pushTask 的 workQueue 中，异步地执行这个任务，然后立即返回结果. </p><pre><code class="highlight java"><span class="comment">/**</span><span class="comment"> * Arranges to asynchronously execute this task in the pool the</span><span class="comment"> * current task is running in, if applicable, or using the &#123;<span class="doctag">@link</span></span><span class="comment"> * ForkJoinPool#commonPool()&#125; if not &#123;<span class="doctag">@link</span> #inForkJoinPool&#125;.  While</span><span class="comment"> * it is not necessarily enforced, it is a usage error to fork a</span><span class="comment"> * task more than once unless it has completed and been</span><span class="comment"> * reinitialized.  Subsequent modifications to the state of this</span><span class="comment"> * task or any data it operates on are not necessarily</span><span class="comment"> * consistently observable by any thread other than the one</span><span class="comment"> * executing it unless preceded by a call to &#123;<span class="doctag">@link</span> #join&#125; or</span><span class="comment"> * related methods, or a call to &#123;<span class="doctag">@link</span> #isDone&#125; returning &#123;<span class="doctag">@code</span></span><span class="comment"> * true&#125;.</span><span class="comment"> *</span><span class="comment"> * <span class="doctag">@return</span> &#123;<span class="doctag">@code</span> this&#125;, to simplify usage</span><span class="comment"> */</span><span class="keyword">public</span> <span class="keyword">final</span> ForkJoinTask&lt;V&gt; <span class="title function_">fork</span><span class="params">()</span> &#123;    Thread t;    <span class="keyword">if</span> ((t = Thread.currentThread()) <span class="keyword">instanceof</span> ForkJoinWorkerThread)        ((ForkJoinWorkerThread)t).workQueue.push(<span class="built_in">this</span>);    <span class="keyword">else</span>        ForkJoinPool.common.externalPush(<span class="built_in">this</span>);    <span class="keyword">return</span> <span class="built_in">this</span>;&#125;</code></pre><p>pushTask 方法把当前任务存放在 ForkJoinTask 数组队列里。然后再调用ForkJoinPool 的 signalWork()方法唤醒或创建一个工作线程来执行任务。代码如下：</p><pre><code class="highlight java"><span class="comment">/**</span><span class="comment"> * Pushes a task. Call only by owner in unshared queues.</span><span class="comment"> *</span><span class="comment"> * <span class="doctag">@param</span> task the task. Caller must ensure non-null.</span><span class="comment"> * <span class="doctag">@throws</span> RejectedExecutionException if array cannot be resized</span><span class="comment"> */</span><span class="keyword">final</span> <span class="keyword">void</span> <span class="title function_">push</span><span class="params">(ForkJoinTask&lt;?&gt; task)</span> &#123;    ForkJoinTask&lt;?&gt;[] a;    <span class="type">int</span> <span class="variable">s</span> <span class="operator">=</span> top, d, cap, m;    <span class="type">ForkJoinPool</span> <span class="variable">p</span> <span class="operator">=</span> pool;    <span class="keyword">if</span> ((a = array) != <span class="literal">null</span> &amp;&amp; (cap = a.length) &gt; <span class="number">0</span>) &#123;        QA.setRelease(a, (m = cap - <span class="number">1</span>) &amp; s, task);        top = s + <span class="number">1</span>;        <span class="keyword">if</span> (((d = s - (<span class="type">int</span>)BASE.getAcquire(<span class="built_in">this</span>)) &amp; ~<span class="number">1</span>) == <span class="number">0</span> &amp;&amp;                p != <span class="literal">null</span>) &#123;                 <span class="comment">// size 0 or 1</span>            VarHandle.fullFence();            p.signalWork();        &#125;        <span class="keyword">else</span> <span class="keyword">if</span> (d == m)            growArray(<span class="literal">false</span>);    &#125;&#125;</code></pre><h1 id="三、join-方法"><a href="#三、join-方法" class="headerlink" title="三、join 方法"></a>三、join 方法</h1><p>Join 方法的主要作用是阻塞当前线程并等待获取结果。让我们一起看看 ForkJoinTask 的 join 方法的实现，代码如下：</p><pre><code class="highlight java"><span class="comment">/**</span><span class="comment"> * Returns the result of the computation when it</span><span class="comment"> * &#123;<span class="doctag">@linkplain</span> #isDone is done&#125;.</span><span class="comment"> * This method differs from &#123;<span class="doctag">@link</span> #get()&#125; in that abnormal</span><span class="comment"> * completion results in &#123;<span class="doctag">@code</span> RuntimeException&#125; or &#123;<span class="doctag">@code</span> Error&#125;,</span><span class="comment"> * not &#123;<span class="doctag">@code</span> ExecutionException&#125;, and that interrupts of the</span><span class="comment"> * calling thread do &lt;em&gt;not&lt;/em&gt; cause the method to abruptly</span><span class="comment"> * return by throwing &#123;<span class="doctag">@code</span> InterruptedException&#125;.</span><span class="comment"> *</span><span class="comment"> * <span class="doctag">@return</span> the computed result</span><span class="comment"> */</span><span class="keyword">public</span> <span class="keyword">final</span> V <span class="title function_">join</span><span class="params">()</span> &#123;    <span class="type">int</span> s;    <span class="keyword">if</span> (((s = doJoin()) &amp; ABNORMAL) != <span class="number">0</span>)        reportException(s);    <span class="keyword">return</span> getRawResult();&#125;</code></pre><p>它首先调用 doJoin 方法，通过 doJoin()方法得到当前任务的状态来判断返回什么结果，任务状态有 4 种：</p><p><strong>已完成（NORMAL）</strong>、<strong>被取消（CANCELLED）</strong>、<strong>信号（SIGNAL）</strong>和 <strong>出现异常（EXCEPTIONAL）</strong></p><ul><li>如果任务状态是已完成，则直接返回任务结果。</li><li>如果任务状态是被取消，则直接抛出 CancellationException</li><li>如果任务状态是抛出异常，则直接抛出对应的异常</li></ul><p><strong>分析一下 doJoin 方法的实现</strong></p><pre><code class="highlight java"><span class="comment">/**</span><span class="comment"> * Implementation for join, get, quietlyJoin. Directly handles</span><span class="comment"> * only cases of already-completed, external wait, and</span><span class="comment"> * unfork+exec.  Others are relayed to ForkJoinPool.awaitJoin.</span><span class="comment"> *</span><span class="comment"> * <span class="doctag">@return</span> status upon completion</span><span class="comment"> */</span><span class="keyword">private</span> <span class="type">int</span> <span class="title function_">doJoin</span><span class="params">()</span> &#123;    <span class="type">int</span> s; Thread t; ForkJoinWorkerThread wt; ForkJoinPool.WorkQueue w;    <span class="keyword">return</span> (s = status) &lt; <span class="number">0</span> ? s :            ((t = Thread.currentThread()) <span class="keyword">instanceof</span> ForkJoinWorkerThread) ?                    (w = (wt = (ForkJoinWorkerThread)t).workQueue).                            tryUnpush(<span class="built_in">this</span>) &amp;&amp; (s = doExec()) &lt; <span class="number">0</span> ? s :                            wt.pool.awaitJoin(w, <span class="built_in">this</span>, <span class="number">0L</span>) :                    externalAwaitDone();&#125;<span class="comment">/**</span><span class="comment"> * Primary execution method for stolen tasks. Unless done, calls</span><span class="comment"> * exec and records status if completed, but doesn&#x27;t wait for</span><span class="comment"> * completion otherwise.</span><span class="comment"> *</span><span class="comment"> * <span class="doctag">@return</span> status on exit from this method</span><span class="comment"> */</span><span class="keyword">final</span> <span class="type">int</span> <span class="title function_">doExec</span><span class="params">()</span> &#123;    <span class="type">int</span> s; <span class="type">boolean</span> completed;    <span class="keyword">if</span> ((s = status) &gt;= <span class="number">0</span>) &#123;        <span class="keyword">try</span> &#123;            completed = exec();        &#125; <span class="keyword">catch</span> (Throwable rex) &#123;            completed = <span class="literal">false</span>;            s = setExceptionalCompletion(rex);        &#125;        <span class="keyword">if</span> (completed)            s = setDone();    &#125;    <span class="keyword">return</span> s;&#125;</code></pre><p>在 doJoin()方法流程如下:</p><ul><li>首先通过查看任务的状态，看任务是否已经执行完成，如果执行完成，则直接返回任务状态；</li><li>如果没有执行完，则从任务数组里取出任务并执行。</li><li>如果任务顺利执行完成，则设置任务状态为 NORMAL，如果出现异常，则记录异常，并将任务状态设置为 EXCEPTIONAL。</li></ul><h1 id="四、Fork-Join-框架的异常处理"><a href="#四、Fork-Join-框架的异常处理" class="headerlink" title="四、Fork&#x2F;Join 框架的异常处理"></a>四、Fork&#x2F;Join 框架的异常处理</h1><p>ForkJoinTask 在执行的时候可能会抛出异常，但是我们没办法在主线程里直接捕获异常，所以 ForkJoinTask 提供了 isCompletedAbnormally() 方法来检查任务是否已经抛出异常或已经被取消了，并且可以通过 ForkJoinTask 的 getException 方法获取异常。</p><p>getException 方法返回 Throwable 对象，如果任务被取消了则返回 CancellationException。如果任务没有完成或者没有抛出异常则返回 null。</p><h1 id="五、入门案例"><a href="#五、入门案例" class="headerlink" title="五、入门案例"></a>五、入门案例</h1><p><strong>场景: 生成一个计算任务，计算 1+2+3………+100 每 10 个数切分一个子任务</strong></p><pre><code class="highlight java"><span class="keyword">class</span> <span class="title class_">MyTask</span> <span class="keyword">extends</span> <span class="title class_">RecursiveTask</span>&lt;Integer&gt; &#123;    <span class="comment">//拆分差值不能超过10，计算10以内运算</span>    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">Integer</span> <span class="variable">VALUE</span> <span class="operator">=</span> <span class="number">10</span>;    <span class="keyword">private</span> <span class="type">int</span> begin ;<span class="comment">//拆分开始值</span>    <span class="keyword">private</span> <span class="type">int</span> end;<span class="comment">//拆分结束值</span>    <span class="keyword">private</span> <span class="type">int</span> result ; <span class="comment">//返回结果</span>    <span class="comment">//创建有参数构造</span>    <span class="keyword">public</span> <span class="title function_">MyTask</span><span class="params">(<span class="type">int</span> begin,<span class="type">int</span> end)</span> &#123;        <span class="built_in">this</span>.begin = begin;        <span class="built_in">this</span>.end = end;    &#125;    <span class="comment">//拆分和合并过程</span>    <span class="meta">@Override</span>    <span class="keyword">protected</span> Integer <span class="title function_">compute</span><span class="params">()</span> &#123;<span class="comment">//        System.out.println(Thread.currentThread().getName() + &quot;, begin: &quot; + begin + &quot;, end: &quot; + end);</span>        <span class="comment">//判断相加两个数值是否大于10</span>        <span class="keyword">if</span>((end-begin)&lt;=VALUE) &#123;            <span class="comment">//相加操作</span>            <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> begin; i &lt;=end; i++) &#123;                result = result+i;            &#125;        &#125; <span class="keyword">else</span> &#123;<span class="comment">// 递归调用,切分为 2 个小任务</span>            <span class="comment">//获取中间值</span>            <span class="type">int</span> <span class="variable">middle</span> <span class="operator">=</span> (begin+end)/<span class="number">2</span>;            <span class="comment">//拆分左边</span>            <span class="type">MyTask</span> <span class="variable">task01</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">MyTask</span>(begin,middle);            <span class="comment">//拆分右边</span>            <span class="type">MyTask</span> <span class="variable">task02</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">MyTask</span>(middle+<span class="number">1</span>,end);            <span class="comment">// 执行:异步</span>            task01.fork();            task02.fork();            <span class="comment">// 同步阻塞获取执行结果</span>            result = task01.join()+task02.join();        &#125;        <span class="keyword">return</span> result;    &#125;&#125;<span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ForkJoinDemo</span> &#123;    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> ExecutionException, InterruptedException &#123;        <span class="comment">//创建MyTask对象</span>        <span class="type">MyTask</span> <span class="variable">myTask</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">MyTask</span>(<span class="number">0</span>,<span class="number">100</span>);        <span class="comment">//创建分支合并池对象</span>        <span class="type">ForkJoinPool</span> <span class="variable">forkJoinPool</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ForkJoinPool</span>();        ForkJoinTask&lt;Integer&gt; forkJoinTask = forkJoinPool.submit(myTask);        <span class="comment">//获取最终合并之后结果</span>        <span class="type">Integer</span> <span class="variable">result</span> <span class="operator">=</span> forkJoinTask.get();        System.out.println(result);        <span class="comment">//关闭池对象</span>        forkJoinPool.shutdown();    &#125;&#125;</code></pre>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;一、Fork-Join-框架简介&quot;&gt;&lt;a href=&quot;#一、Fork-Join-框架简介&quot; class=&quot;headerlink&quot; title=&quot;一、Fork&amp;#x2F;Join 框架简介&quot;&gt;&lt;/a&gt;一、Fork&amp;#x2F;Join 框架简介&lt;/h1&gt;&lt;p&gt;Fork</summary>
      
    
    
    
    <category term="JUC" scheme="https://georgechan95.github.io/categories/JUC/"/>
    
    
    <category term="juc" scheme="https://georgechan95.github.io/tags/juc/"/>
    
    <category term="java" scheme="https://georgechan95.github.io/tags/java/"/>
    
  </entry>
  
  <entry>
    <title>09-ThreadPool-线程池</title>
    <link href="https://georgechan95.github.io/blog/a0197c15.html"/>
    <id>https://georgechan95.github.io/blog/a0197c15.html</id>
    <published>2024-09-13T12:10:08.000Z</published>
    <updated>2024-09-18T07:30:50.861Z</updated>
    
    <content type="html"><![CDATA[<h1 id="一、线程池简介"><a href="#一、线程池简介" class="headerlink" title="一、线程池简介"></a>一、线程池简介</h1><p>线程池（英语：thread pool）：一种线程使用模式。线程过多会带来调度开销，进而影响缓存局部性和整体性能。而线程池维护着多个线程，等待着监督管理者分配可并发执行的任务。这避免了在处理短时间任务时创建与销毁线程的代价。线程池不仅能够保证内核的充分利用，还能防止过分调度。</p><p>例子： 10 年前单核 CPU 电脑，假的多线程，像马戏团小丑玩多个球，CPU 需要来回切换。 现在是多核电脑，多个线程各自跑在独立的 CPU 上，不用切换效率高</p><p><strong>线程池的优势：</strong> 线程池做的工作只要是控制运行的线程数量，处理过程中将任务放入队列，然后在线程创建后启动这些任务，如果线程数量超过了最大数量，超出数量的线程排队等候，等其他线程执行完毕，再从队列中取出任务来执行。</p><p><strong>它的主要特点为：</strong></p><ul><li>降低资源消耗: 通过重复利用已创建的线程降低线程创建和销毁造成的销耗。</li><li>提高响应速度: 当任务到达时，任务可以不需要等待线程创建就能立即执行。</li><li>提高线程的可管理性: 线程是稀缺资源，如果无限制的创建，不仅会销耗系统资源，还会降低系统的稳定性，使用线程池可以进行统一的分配，调优和监控。</li><li><strong>Java</strong> <strong>中的线程池是通过</strong> <strong>Executor</strong> <strong>框架实现的，该框架中用到了</strong> <strong>Executor，Executors,  ExecutorService，ThreadPoolExecutor这几个类</strong></li></ul><p><img src="https://raw.githubusercontent.com/GeorgeChan95/blogimg/master/img/2024/09/16/20240916-103643.png" alt="Executors继承体系"></p><h1 id="二、线程池参数说明"><a href="#二、线程池参数说明" class="headerlink" title="二、线程池参数说明"></a>二、线程池参数说明</h1><p>介绍 5 种类型的线程池</p><h2 id="1-常用参数-重点"><a href="#1-常用参数-重点" class="headerlink" title="1. 常用参数(重点)"></a>1. 常用参数(重点)</h2><ul><li>corePoolSize 线程池的核心线程数</li><li>maximumPoolSize 能容纳的最大线程数</li><li>keepAliveTime 空闲线程存活时间</li><li>unit 存活的时间单位</li><li>workQueue 存放提交但未执行任务的队列</li><li>threadFactory 创建线程的工厂类</li><li>handler 等待队列满后的拒绝策略</li></ul><p>线程池中，有三个重要的参数，决定影响了拒绝策略：corePoolSize - 核心线程数，也即最小的线程数。workQueue - 阻塞队列 。 maximumPoolSize - 最大线程数</p><p>当提交任务数大于 corePoolSize 的时候，会优先将任务放到 workQueue 阻塞队列中。当阻塞队列饱和后，会扩充线程池中线程数，直到达到 maximumPoolSize 最大线程数配置。此时，再多余的任务，则会触发线程池的拒绝策略了。</p><p>总结起来，也就是一句话，当提交的任务数大于（<code>workQueue.size()</code> + <code>maximumPoolSize</code> ），就会触发线程池的拒绝策略。</p><h2 id="2-拒绝策略-重点"><a href="#2-拒绝策略-重点" class="headerlink" title="2. 拒绝策略(重点)"></a>2. 拒绝策略(重点)</h2><ul><li><strong>CallerRunsPolicy</strong>: 当触发拒绝策略，只要线程池没有关闭的话，则使用调用线程直接运行任务。一般并发比较小，性能要求不高，不允许失败。但是，由于调用者自己运行任务，如果任务提交速度过快，可能导致程序阻塞，性能效率上必然的损失较大</li><li><strong>AbortPolicy</strong>: 丢弃任务，并抛出拒绝执行 RejectedExecutionException 异常信息。线程池默认的拒绝策略。必须处理好抛出的异常，否则会打断当前的执行流程，影响后续的任务执行。</li><li><strong>DiscardPolicy</strong>: 直接丢弃，其他啥都没有</li><li><strong>DiscardOldestPolicy</strong>: 当触发拒绝策略，只要线程池没有关闭的话，丢弃阻塞队列 workQueue 中最老的一个任务，并将新任务加入</li></ul><h1 id="三、线程池的种类与创建"><a href="#三、线程池的种类与创建" class="headerlink" title="三、线程池的种类与创建"></a>三、线程池的种类与创建</h1><h2 id="1-newCachedThreadPool-常用"><a href="#1-newCachedThreadPool-常用" class="headerlink" title="1. newCachedThreadPool(常用)"></a>1. newCachedThreadPool(常用)</h2><p><strong>作用</strong>：创建一个可缓存线程池，如果线程池长度超过处理需要，可灵活回收空闲线程，若无可回收，则新建线程.</p><p><strong>特点</strong>: </p><ul><li>线程池中数量没有固定，可达到最大值（<code>Interger. MAX_VALUE</code>）</li><li>线程池中的线程可进行缓存重复利用和回收（回收默认时间为 1 分钟）</li><li>当线程池中，没有可用线程，会重新创建一个线程</li></ul><p><strong>创建方式：</strong></p><pre><code class="highlight java"><span class="comment">/**</span><span class="comment"> * 可缓存线程池</span><span class="comment"> *</span><span class="comment"> * <span class="doctag">@return</span></span><span class="comment"> */</span><span class="keyword">public</span> <span class="keyword">static</span> ExecutorService <span class="title function_">newCachedThreadPool</span><span class="params">()</span> &#123;    <span class="comment">/**</span><span class="comment">     * corePoolSize 线程池的核心线程数</span><span class="comment">     * maximumPoolSize 能容纳的最大线程数</span><span class="comment">     * keepAliveTime 空闲线程存活时间</span><span class="comment">     * unit 存活的时间单位</span><span class="comment">     * workQueue 存放提交但未执行任务的队列</span><span class="comment">     * threadFactory 创建线程的工厂类:可以省略</span><span class="comment">     * handler 等待队列满后的拒绝策略:可以省略</span><span class="comment">     */</span>    <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">ThreadPoolExecutor</span>(<span class="number">0</span>,            Integer.MAX_VALUE,            <span class="number">60L</span>,            TimeUnit.SECONDS,            <span class="keyword">new</span> <span class="title class_">SynchronousQueue</span>&lt;&gt;(),            Executors.defaultThreadFactory(),            <span class="keyword">new</span> <span class="title class_">ThreadPoolExecutor</span>.AbortPolicy());&#125;</code></pre><p><strong>场景:</strong> 适用于创建一个可无限扩大的线程池，服务器负载压力较轻，执行时间较短，任务多的场景</p><h2 id="2-newFixedThreadPool-常用"><a href="#2-newFixedThreadPool-常用" class="headerlink" title="2. newFixedThreadPool(常用)"></a>2. newFixedThreadPool(常用)</h2><p><strong>作用</strong>：创建一个可重用固定线程数的线程池，以共享的无界队列方式来运行这些线程。在任意点，在大多数线程会处于处理任务的活动状态。如果在所有线程处于活动状态时提交附加任务，则在有可用线程之前，附加任务将在队列中等待。如果在关闭前的执行期间由于失败而导致任何线程终止，那么一个新线程将代替它执行后续的任务（如果需要）。在某个线程被显式地关闭之前，池中的线程将一直存在。</p><p><strong>特征：</strong></p><ul><li>线程池中的线程处于一定的量，可以很好的控制线程的并发量</li><li>线程可以重复被使用，在显示关闭之前，都将一直存在</li><li>超出一定量的线程被提交时候需在队列中等待</li></ul><p><strong>创建方式</strong>：</p><pre><code class="highlight java"><span class="comment">/**</span><span class="comment"> * 固定长度线程池</span><span class="comment"> * <span class="doctag">@return</span></span><span class="comment"> */</span><span class="keyword">public</span> <span class="keyword">static</span> ExecutorService <span class="title function_">newFixedThreadPool</span><span class="params">()</span>&#123;    <span class="comment">/**</span><span class="comment">     * corePoolSize 线程池的核心线程数</span><span class="comment">     * maximumPoolSize 能容纳的最大线程数</span><span class="comment">     * keepAliveTime 空闲线程存活时间</span><span class="comment">     * unit 存活的时间单位</span><span class="comment">     * workQueue 存放提交但未执行任务的队列</span><span class="comment">     * threadFactory 创建线程的工厂类:可以省略</span><span class="comment">     * handler 等待队列满后的拒绝策略:可以省略</span><span class="comment">     */</span>    <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">ThreadPoolExecutor</span>(<span class="number">10</span>,            <span class="number">10</span>,            <span class="number">0L</span>,            TimeUnit.SECONDS,            <span class="keyword">new</span> <span class="title class_">LinkedBlockingQueue</span>&lt;&gt;(),            Executors.defaultThreadFactory(),            <span class="keyword">new</span> <span class="title class_">ThreadPoolExecutor</span>.AbortPolicy());&#125;</code></pre><p><strong>场景:</strong> 适用于可以预测线程数量的业务中，或者服务器负载较重，对线程数有严格限制的场景</p><h2 id="3-newSingleThreadExecutor-常用"><a href="#3-newSingleThreadExecutor-常用" class="headerlink" title="3. newSingleThreadExecutor(常用)"></a>3. newSingleThreadExecutor(常用)</h2><p><strong>作用</strong>：创建一个使用单个 worker 线程的 Executor，以无界队列方式来运行该线程。（注意，如果因为在关闭前的执行期间出现失败而终止了此单个线程，那么如果需要，一个新线程将代替它执行后续的任务）。可保证顺序地执行各个任务，并且在任意给定的时间不会有多个线程是活动的。与其他等效的 newFixedThreadPool 不同，可保证无需重新配置此方法所返回的执行程序即可使用其他的线程。</p><p><strong>特征：</strong> 线程池中最多执行 1 个线程，之后提交的线程活动将会排在队列中以此执行</p><p><strong>创建方式：</strong></p><pre><code class="highlight java"><span class="comment">/**</span><span class="comment"> * 单一线程池</span><span class="comment"> *</span><span class="comment"> * <span class="doctag">@return</span></span><span class="comment"> */</span><span class="keyword">public</span> <span class="keyword">static</span> ExecutorService <span class="title function_">newSingleThreadExecutor</span><span class="params">()</span> &#123;    <span class="comment">/**</span><span class="comment">    * corePoolSize 线程池的核心线程数</span><span class="comment">    * maximumPoolSize 能容纳的最大线程数</span><span class="comment">    * keepAliveTime 空闲线程存活时间</span><span class="comment">    * unit 存活的时间单位</span><span class="comment">    * workQueue 存放提交但未执行任务的队列</span><span class="comment">    * threadFactory 创建线程的工厂类:可以省略</span><span class="comment">    * handler 等待队列满后的拒绝策略:可以省略</span><span class="comment">    */</span>    <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">ThreadPoolExecutor</span>(<span class="number">1</span>,            <span class="number">1</span>,            <span class="number">0L</span>,            TimeUnit.SECONDS,            <span class="keyword">new</span> <span class="title class_">LinkedBlockingQueue</span>&lt;&gt;(),            Executors.defaultThreadFactory(),            <span class="keyword">new</span> <span class="title class_">ThreadPoolExecutor</span>.AbortPolicy());&#125;</code></pre><p><strong>场景:</strong> 适用于需要保证顺序执行各个任务，并且在任意时间点，不会同时有多个线程的场景</p><h2 id="4-newScheduleThreadPool-了解"><a href="#4-newScheduleThreadPool-了解" class="headerlink" title="4. newScheduleThreadPool(了解)"></a>4. newScheduleThreadPool(了解)</h2><p><strong>作用:</strong> 线程池支持定时以及周期性执行任务，创建一个 corePoolSize 为传入参数，最大线程数为整形的最大数的线程池</p><p><strong>特征:</strong></p><ul><li>线程池中具有指定数量的线程，即便是空线程也将保留 </li><li>可定时或者延迟执行线程活动</li></ul><p><strong>创建方式:</strong></p><pre><code class="highlight java"><span class="keyword">public</span> <span class="keyword">static</span> ScheduledExecutorService <span class="title function_">newScheduledThreadPool</span><span class="params">(<span class="type">int</span> corePoolSize,</span><span class="params">                                                              ThreadFactory threadFactory)</span> &#123;    <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">ScheduledThreadPoolExecutor</span>(corePoolSize,                                           threadFactory);&#125;</code></pre><p><strong>场景:</strong> 适用于需要多个后台线程执行周期任务的场景</p><h2 id="5-newWorkStealingPool"><a href="#5-newWorkStealingPool" class="headerlink" title="5. newWorkStealingPool"></a>5. newWorkStealingPool</h2><p>jdk1.8 提供的线程池，底层使用的是 ForkJoinPool 实现，创建一个拥有多个任务队列的线程池，可以减少连接数，创建当前可用 cpu 核数的线程来并行执行任务</p><p><strong>创建方式:</strong></p><pre><code class="highlight java"><span class="keyword">public</span> <span class="keyword">static</span> ExecutorService <span class="title function_">newWorkStealingPool</span><span class="params">(<span class="type">int</span> parallelism)</span> &#123;    <span class="comment">/**</span><span class="comment">     * parallelism：并行级别，通常默认为 JVM 可用的处理器个数</span><span class="comment">     * factory：用于创建 ForkJoinPool 中使用的线程。</span><span class="comment">     * handler：用于处理工作线程未处理的异常，默认为 null</span><span class="comment">     * asyncMode：用于控制 WorkQueue 的工作模式:队列---反队列</span><span class="comment">     */</span>    <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">ForkJoinPool</span>(parallelism,            ForkJoinPool.defaultForkJoinWorkerThreadFactory,            <span class="literal">null</span>,            <span class="literal">true</span>);&#125;</code></pre><p><strong>场景:</strong> 适用于大耗时，可并行执行的场景</p><h1 id="四、线程池入门案例"><a href="#四、线程池入门案例" class="headerlink" title="四、线程池入门案例"></a>四、线程池入门案例</h1><p><strong>场景: 火车站 3 个售票口, 10 个用户买票</strong></p><pre><code class="highlight java"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ThreadPoolDemo1</span> &#123;    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;        <span class="comment">//一池五线程</span>        <span class="type">ExecutorService</span> <span class="variable">threadPool1</span> <span class="operator">=</span> Executors.newFixedThreadPool(<span class="number">3</span>); <span class="comment">//5个窗口</span>        <span class="comment">//一池一线程</span>        <span class="type">ExecutorService</span> <span class="variable">threadPool2</span> <span class="operator">=</span> Executors.newSingleThreadExecutor(); <span class="comment">//一个窗口</span>        <span class="comment">//一池可扩容线程</span>        <span class="type">ExecutorService</span> <span class="variable">threadPool3</span> <span class="operator">=</span> Executors.newCachedThreadPool();        <span class="comment">// 创建当前可用的CPU核数的线程数的线程池</span>        <span class="type">ExecutorService</span> <span class="variable">threadPool4</span> <span class="operator">=</span> Executors.newWorkStealingPool();        <span class="comment">//10个顾客请求</span>        <span class="keyword">try</span> &#123;            <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">1</span>; i &lt;= <span class="number">10</span>; i++) &#123;                <span class="keyword">final</span> <span class="type">int</span> <span class="variable">num</span> <span class="operator">=</span> i;                <span class="comment">//执行</span>                threadPool1.execute(() -&gt; &#123;                    System.out.println(Thread.currentThread().getName() + <span class="string">&quot;开始办理业务&quot;</span> + num);                    <span class="keyword">try</span> &#123;                        TimeUnit.SECONDS.sleep(<span class="number">5</span>);                    &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;                        e.printStackTrace();                    &#125;                    System.out.println(Thread.currentThread().getName() + <span class="string">&quot;结束办理业务&quot;</span> + num);                &#125;);            &#125;        &#125; <span class="keyword">catch</span> (Exception e) &#123;            e.printStackTrace();        &#125; <span class="keyword">finally</span> &#123;            <span class="comment">//关闭线程池</span>            threadPool1.shutdown();        &#125;    &#125;&#125;</code></pre><p><strong>运行结果:</strong></p><pre><code class="highlight shell">pool-1-thread-1开始办理业务1pool-1-thread-2开始办理业务2pool-1-thread-3开始办理业务3pool-1-thread-2结束办理业务2pool-1-thread-1结束办理业务1pool-1-thread-1开始办理业务5pool-1-thread-3结束办理业务3pool-1-thread-2开始办理业务4pool-1-thread-3开始办理业务6pool-1-thread-1结束办理业务5pool-1-thread-3结束办理业务6pool-1-thread-3开始办理业务8pool-1-thread-2结束办理业务4pool-1-thread-2开始办理业务9pool-1-thread-1开始办理业务7pool-1-thread-2结束办理业务9pool-1-thread-2开始办理业务10pool-1-thread-1结束办理业务7pool-1-thread-3结束办理业务8pool-1-thread-2结束办理业务10</code></pre><h1 id="五、线程池底层工作原理-重要"><a href="#五、线程池底层工作原理-重要" class="headerlink" title="五、线程池底层工作原理(重要)"></a>五、线程池底层工作原理(重要)</h1><p><img src="https://raw.githubusercontent.com/GeorgeChan95/blogimg/master/img/2024/09/16/20240916-115726.png" alt="线程池底层工作原理"></p><ul><li>在创建了线程池后，线程池中的线程数为零</li><li>当调用 execute()方法添加一个请求任务时，线程池会做出如下判断<ul><li>如果正在运行的线程数量小于 corePoolSize，那么马上创建线程运行这个任务；</li><li>如果正在运行的线程数量大于或等于 corePoolSize，那么将这个任务放入队列；</li><li>如果这个时候队列满了且正在运行的线程数量还小于maximumPoolSize，那么还是要创建非核心线程立刻运行这个任务；</li><li>如果队列满了且正在运行的线程数量大于或等于 maximumPoolSize，那么线程池会启动饱和拒绝策略来执行。</li></ul></li><li>当一个线程完成任务时，它会从队列中取下一个任务来执行</li><li>当一个线程无事可做超过一定的时间（keepAliveTime）时，线程会判断<ul><li>如果当前运行的线程数大于 corePoolSize，那么这个线程就被停掉。</li><li>所以线程池的所有任务完成后，它最终会收缩到 corePoolSize 的大小。</li></ul></li></ul><p><img src="https://raw.githubusercontent.com/GeorgeChan95/blogimg/master/img/2024/09/16/20240916-120237.png" alt="JDK内置拒绝策略"></p><h1 id="六、注意事项-重要"><a href="#六、注意事项-重要" class="headerlink" title="六、注意事项(重要)"></a>六、注意事项(重要)</h1><ul><li><p>项目中创建多线程时，使用常见的三种线程池创建方式，单一、可变、定长都有一定问题，原因是 FixedThreadPool 和 SingleThreadExecutor 底层都是用 LinkedBlockingQueue 实现的，这个队列最大长度为 Integer.MAX_VALUE，容易导致 OOM。所以实际生产一般自己通过 ThreadPoolExecutor 的 7 个参数，自定义线程池</p></li><li><p>创建线程池推荐适用 ThreadPoolExecutor 及其 7 个参数手动创建</p><ul><li>corePoolSize 线程池的核心线程数</li><li>maximumPoolSize 能容纳的最大线程数</li><li>keepAliveTime 空闲线程存活时间</li><li>unit 存活的时间单位</li><li>workQueue 存放提交但未执行任务的队列</li><li>threadFactory 创建线程的工厂类</li><li>handler 等待队列满后的拒绝策略</li></ul></li><li><p>为什么不允许适用不允许 Executors.的方式手动创建线程池,如下图</p></li></ul><p><img src="https://raw.githubusercontent.com/GeorgeChan95/blogimg/master/img/2024/09/16/20240916-120936.png" alt="阿里巴巴开发手册关于线程池创建要求"></p><pre><code class="highlight java"><span class="comment">//自定义线程池创建</span><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ThreadPoolDemo2</span> &#123;    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;        <span class="type">ExecutorService</span> <span class="variable">threadPool</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ThreadPoolExecutor</span>(                <span class="number">2</span>,                <span class="number">5</span>,                <span class="number">2L</span>,                TimeUnit.SECONDS,                <span class="keyword">new</span> <span class="title class_">ArrayBlockingQueue</span>&lt;&gt;(<span class="number">3</span>),                Executors.defaultThreadFactory(),                <span class="keyword">new</span> <span class="title class_">ThreadPoolExecutor</span>.AbortPolicy()        );        <span class="comment">//10个顾客请求</span>        <span class="keyword">try</span> &#123;            <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">1</span>; i &lt;=<span class="number">10</span>; i++) &#123;                <span class="comment">//执行</span>                threadPool.execute(()-&gt;&#123;                    System.out.println(Thread.currentThread().getName()+<span class="string">&quot; 办理业务&quot;</span>);                &#125;);            &#125;        &#125;<span class="keyword">catch</span> (Exception e) &#123;            e.printStackTrace();        &#125;<span class="keyword">finally</span> &#123;            <span class="comment">//关闭</span>            threadPool.shutdown();        &#125;    &#125;&#125;</code></pre>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;一、线程池简介&quot;&gt;&lt;a href=&quot;#一、线程池简介&quot; class=&quot;headerlink&quot; title=&quot;一、线程池简介&quot;&gt;&lt;/a&gt;一、线程池简介&lt;/h1&gt;&lt;p&gt;线程池（英语：thread pool）：一种线程使用模式。线程过多会带来调度开销，进而影响缓存局部性</summary>
      
    
    
    
    <category term="JUC" scheme="https://georgechan95.github.io/categories/JUC/"/>
    
    
    <category term="juc" scheme="https://georgechan95.github.io/tags/juc/"/>
    
    <category term="java" scheme="https://georgechan95.github.io/tags/java/"/>
    
  </entry>
  
  <entry>
    <title>08-阻塞队列BlockingQueue</title>
    <link href="https://georgechan95.github.io/blog/a6760d1f.html"/>
    <id>https://georgechan95.github.io/blog/a6760d1f.html</id>
    <published>2024-09-07T09:30:00.000Z</published>
    <updated>2024-09-13T00:27:39.289Z</updated>
    
    <content type="html"><![CDATA[<h1 id="一、阻塞队列概述"><a href="#一、阻塞队列概述" class="headerlink" title="一、阻塞队列概述"></a>一、阻塞队列概述</h1><p>阻塞队列，顾名思义，首先它是一个队列, 通过一个共享的队列，可以使得数据由队列的一端输入，从另外一端输出；</p><img src="https://raw.githubusercontent.com/GeorgeChan95/blogimg/master/img/2024/09/07/20240907-173358" alt="阻塞队列" style="zoom:50%;" /><ul><li>当队列是空的，从队列中获取元素的操作将会被阻塞</li><li>当队列是满的，从队列中添加元素的操作将会被阻塞</li><li>试图从空的队列中获取元素的线程将会被阻塞，直到其他线程往空的队列插入新的元素</li><li>试图向已满的队列中添加新元素的线程将会被阻塞，直到其他线程从队列中移除一个或多个元素或者完全清空，使队列变得空闲起来并后续新增</li></ul><p>常用的队列主要有以下两种：</p><ul><li>先进先出（FIFO）：先插入的队列的元素也最先出队列，类似于排队的功能。从某种程度上来说这种队列也体现了一种公平性</li><li>后进先出（LIFO）：后插入队列的元素最先出队列，这种队列优先处理最近发生的事件(栈)</li></ul><p>在多线程领域：所谓阻塞，在某些情况下会挂起线程（即阻塞），一旦条件满足，被挂起的线程又会自动被唤起</p><p><strong>为什么需要 BlockingQueue?</strong></p><p>好处是我们不需要关心什么时候需要阻塞线程，什么时候需要唤醒线程，因为这一切 BlockingQueue 都给你一手包办了.</p><p>在 concurrent 包发布以前，在多线程环境下，我们每个程序员都必须去自己控制这些细节，尤其还要兼顾效率和线程安全，而这会给我们的程序带来不小的复杂度。多线程环境中，通过队列可以很容易实现数据共享，比如经典的“生产者”和“消费者”模型中，通过队列可以很便利地实现两者之间的数据共享。假设我们有若干生产者线程，另外又有若干个消费者线程。如果生产者线程需要把准备好的数据共享给消费者线程，利用队列的方式来传递数据，就可以很方便地解决他们之间的数据共享问题。但如果生产者和消费者在某个时间段内，万一发生数据处理速度不匹配的情况呢？理想情况下，如果生产者产出数据的速度大于消费者消费的速度，并且当生产出来的数据累积到一定程度的时候，那么生产者必须暂停等待一下（阻塞生产者线程），以便等待消费者线程把累积的数据处理完毕，反之亦然。</p><ul><li>当队列中没有数据的情况下，消费者端的所有线程都会被自动阻塞（挂起），直到有数据放入队列</li><li>当队列中填满数据的情况下，生产者端的所有线程都会被自动阻塞（挂起），直到队列中有空的位置，线程被自动唤醒</li></ul><h1 id="二、BlockingQueue-核心方法"><a href="#二、BlockingQueue-核心方法" class="headerlink" title="二、BlockingQueue 核心方法"></a>二、BlockingQueue 核心方法</h1><table><thead><tr><th align="center">方法类型</th><th align="center">抛出异常</th><th align="center">特殊值</th><th align="center">阻塞</th><th align="center">超时</th></tr></thead><tbody><tr><td align="center">插入</td><td align="center">add(e)</td><td align="center">offer()</td><td align="center">put(e)</td><td align="center">offer(e,time,unit)</td></tr><tr><td align="center">移除</td><td align="center">remove()</td><td align="center">poll()</td><td align="center">take()</td><td align="center">poll(time,unit)</td></tr><tr><td align="center">检查</td><td align="center">element()</td><td align="center">peek()</td><td align="center">-</td><td align="center">-</td></tr></tbody></table><table><thead><tr><th>抛出异常</th><th>当阻塞队列满时，再往队列里add插入元素会抛出IllegalStateException:Queue full <br />当阻塞队列空时，再往队列里remove移除元素会抛出NoSuchElementException</th></tr></thead><tbody><tr><td><strong>特殊值</strong></td><td>插入方法，成功true，失败false 移除方法，成功返回出队列的元素，列表里没有就返回null</td></tr><tr><td><strong>阻塞</strong></td><td>当阻塞队列满时，生产者线程继续往队列里put元素，队列会一直阻塞生产者线程知道put数据或响应中断退出 当阻塞队列空时，消费者线程视图从队列里take元素，队列会一直阻塞消费者线程直到队列可用</td></tr><tr><td><strong>超时</strong></td><td>当阻塞队列满时，队列会阻塞生产者线程一定时间，超过限时后生产者线程会退出</td></tr></tbody></table><h2 id="1-放入数据"><a href="#1-放入数据" class="headerlink" title="1. 放入数据"></a>1. 放入数据</h2><ul><li>offer(Object):表示如果可能的话,将 Object 加到 BlockingQueue 里,即如果 BlockingQueue 可以容纳,则返回 true,否则返回 false.<strong>（本方法不阻塞当前执行方法的线程）</strong></li><li>offer(E o, long timeout, TimeUnit unit)：可以设定等待的时间，如果在指定的时间内，还不能往队列中加入 BlockingQueue，则返回失败</li><li>put(Object):把 Object 加到 BlockingQueue 里,如果 BlockQueue 没有空间,则调用此方法的线程被阻断直到 BlockingQueue 里面有空间再继续.</li></ul><h2 id="2-获取数据"><a href="#2-获取数据" class="headerlink" title="2. 获取数据"></a>2. 获取数据</h2><ul><li>poll(time): 取走 BlockingQueue 里排在首位的对象,若不能立即取出,则可以等time 参数规定的时间,取不到时返回 null</li><li>poll(long timeout, TimeUnit unit)：从 BlockingQueue 取出一个队首的对象，如果在指定时间内，队列一旦有数据可取，则立即返回队列中的数据。否则知道时间超时还没有数据可取，返回失败。</li><li>take(): 取走 BlockingQueue 里排在首位的对象,若 BlockingQueue 为空,<strong>阻断进入等待状态直到 BlockingQueue 有新的数据被加入</strong>;</li><li>drainTo(): 一次性从 BlockingQueue 获取所有可用的数据对象（还可以指定获取数据的个数），通过该方法，可以提升获取数据效率；不需要多次分批加锁或释放锁。</li></ul><h1 id="三、入门案例"><a href="#三、入门案例" class="headerlink" title="三、入门案例"></a>三、入门案例</h1><pre><code class="highlight java"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">BlockingQueueTest</span> &#123;    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> InterruptedException &#123;        <span class="comment">/********************* 第一种: 抛出异常 ***********************/</span>        BlockingQueue&lt;Object&gt; bQueue1 = <span class="keyword">new</span> <span class="title class_">ArrayBlockingQueue</span>&lt;&gt;(<span class="number">3</span>);        System.out.println(bQueue1.add(<span class="string">&quot;a&quot;</span>)); <span class="comment">// true</span>        System.out.println(bQueue1.add(<span class="string">&quot;b&quot;</span>)); <span class="comment">// true</span>        System.out.println(bQueue1.add(<span class="string">&quot;c&quot;</span>)); <span class="comment">// true</span><span class="comment">//        System.out.println(bQueue1.add(&quot;d&quot;)); // Exception in thread &quot;main&quot; java.lang.IllegalStateException: Queue full</span>        <span class="comment">// 检查</span>        System.out.println(bQueue1.element()); <span class="comment">// a</span>        System.out.println(bQueue1.remove()); <span class="comment">// a</span>        System.out.println(bQueue1.remove()); <span class="comment">// b</span>        System.out.println(bQueue1.element()); <span class="comment">// c</span>                <span class="comment">/********************* 第二种: 特殊值 ***********************/</span>        BlockingQueue&lt;Object&gt; bQueue2 = <span class="keyword">new</span> <span class="title class_">ArrayBlockingQueue</span>&lt;&gt;(<span class="number">3</span>);        System.out.println(bQueue2.offer(<span class="string">&quot;e&quot;</span>)); <span class="comment">// true</span>        System.out.println(bQueue2.offer(<span class="string">&quot;f&quot;</span>)); <span class="comment">// true</span>        System.out.println(bQueue2.offer(<span class="string">&quot;g&quot;</span>)); <span class="comment">// true</span>        System.out.println(bQueue2.offer(<span class="string">&quot;h&quot;</span>)); <span class="comment">// false</span>        System.out.println(bQueue2.peek()); <span class="comment">// e</span>        System.out.println(bQueue2.poll()); <span class="comment">// e</span>        System.out.println(bQueue2.poll()); <span class="comment">// f</span>                <span class="comment">/********************* 第三种: 阻塞 ***********************/</span>        BlockingQueue&lt;Object&gt; bQueue3 = <span class="keyword">new</span> <span class="title class_">ArrayBlockingQueue</span>&lt;&gt;(<span class="number">3</span>);        bQueue3.put(<span class="string">&quot;j&quot;</span>);        bQueue3.put(<span class="string">&quot;k&quot;</span>);        bQueue3.put(<span class="string">&quot;l&quot;</span>);        System.out.println(bQueue3.take()); <span class="comment">// j</span>        bQueue3.put(<span class="string">&quot;m&quot;</span>);        System.out.println(<span class="string">&quot;m&quot;</span>); <span class="comment">// m</span>        bQueue3.put(<span class="string">&quot;n&quot;</span>); <span class="comment">// 阻塞</span>                <span class="comment">/********************* 第四种: 超时 ***********************/</span>        BlockingQueue&lt;Object&gt; bQueue4 = <span class="keyword">new</span> <span class="title class_">ArrayBlockingQueue</span>&lt;&gt;(<span class="number">3</span>);        System.out.println(bQueue4.offer(<span class="string">&quot;o&quot;</span>, <span class="number">3</span>, TimeUnit.SECONDS)); <span class="comment">// true</span>        System.out.println(bQueue4.offer(<span class="string">&quot;p&quot;</span>, <span class="number">3</span>, TimeUnit.SECONDS)); <span class="comment">// true</span>        System.out.println(bQueue4.offer(<span class="string">&quot;q&quot;</span>, <span class="number">3</span>, TimeUnit.SECONDS)); <span class="comment">// true</span>        System.out.println(bQueue4.offer(<span class="string">&quot;r&quot;</span>, <span class="number">3</span>, TimeUnit.SECONDS)); <span class="comment">// false</span>        System.out.println(bQueue4.poll(<span class="number">2</span>, TimeUnit.SECONDS)); <span class="comment">// o</span>        System.out.println(bQueue4.poll(<span class="number">2</span>, TimeUnit.SECONDS)); <span class="comment">// p</span>        System.out.println(bQueue4.poll(<span class="number">2</span>, TimeUnit.SECONDS)); <span class="comment">// q</span>        System.out.println(bQueue4.poll(<span class="number">2</span>, TimeUnit.SECONDS)); <span class="comment">// null</span>    &#125;&#125;</code></pre><h1 id="四、常见的-BlockingQueue"><a href="#四、常见的-BlockingQueue" class="headerlink" title="四、常见的 BlockingQueue"></a>四、常见的 BlockingQueue</h1><h2 id="1-ArrayBlockingQueue-常用"><a href="#1-ArrayBlockingQueue-常用" class="headerlink" title="1. ArrayBlockingQueue(常用)"></a>1. ArrayBlockingQueue(常用)</h2><p><strong>由数组结构组成的有界阻塞队列</strong></p><p>基于数组的阻塞队列实现，在 ArrayBlockingQueue 内部，维护了一个定长数组，以便缓存队列中的数据对象，这是一个常用的阻塞队列，除了一个定长数组外，ArrayBlockingQueue 内部还保存着两个整形变量，分别标识着队列的头部和尾部在数组中的位置。</p><p>ArrayBlockingQueue 在生产者放入数据和消费者获取数据，都是共用同一个锁对象，由此也意味着两者无法真正并行运行，这点尤其不同于LinkedBlockingQueue；按照实现原理来分析，ArrayBlockingQueue完全可以采用分离锁，从而实现生产者和消费者操作的完全并行运行。Doug Lea之所以没这样去做，也许是因为ArrayBlockingQueue的数据写入和获取操作已经足够轻巧，以至于引入独立的锁机制，除了给代码带来额外的复杂性外，其在性能上完全占不到任何便宜。ArrayBlockingQueue和LinkedBlockingQueue间还有一个明显的不同之处在于，前者在插入或删除元素时不会产生或销毁任何额外的对象实例，而后者则会生成一个额外的Node对象。这在长时间内需要高效并发地处理大批量数据的系统中，其对于GC的影响还是存在一定的区别。而在创建ArrayBlockingQueue时，我们还可以控制对象的内部锁是否采用公平锁，默认采用非公平锁。</p><h2 id="2-LinkedBlockingQueue-常用"><a href="#2-LinkedBlockingQueue-常用" class="headerlink" title="2. LinkedBlockingQueue(常用)"></a>2. LinkedBlockingQueue(常用)</h2><p><strong>由链表结构组成的有界（但大小默认值为integer.MAX_VALUE）阻塞队列。</strong></p><p>基于链表的阻塞队列，同ArrayListBlockingQueue类似，其内部也维持着一个数据缓冲队列（该队列由一个链表构成），当生产者往队列中放入一个数据时，队列会从生产者手中获取数据，并缓存在队列内部，而生产者立即返回；只有当队列缓冲区达到最大值缓存容量时（LinkedBlockingQueue可以通过构造函数指定该值），才会阻塞生产者队列，直到消费者从队列中消费掉一份数据，生产者线程会被唤醒，反之对于消费者这端的处理也基于同样的原理。而LinkedBlockingQueue之所以能够高效的处理并发数据，还因为其对于生产者端和消费者端分别采用了独立的锁来控制数据同步，这也意味着在高并发的情况下生产者和消费者可以并行地操作队列中的数据，以此来提高整个队列的并发性能。</p><p><strong>ArrayBlockingQueue</strong> 和 <strong>LinkedBlockingQueue</strong> 是两个最普通也是最常用的阻塞队列，一般情况下，在处理多线程间的生产者消费者问题，使用这两个类足以。</p><h2 id="3-DelayQueue"><a href="#3-DelayQueue" class="headerlink" title="3. DelayQueue"></a>3. DelayQueue</h2><p><strong>使用优先级队列实现的延迟无界阻塞队列。</strong></p><p>DelayQueue中的元素只有当其指定的延迟时间到了，才能够从队列中获取到该元素。DelayQueue是一个没有大小限制的队列，因此往队列中插入数据的操作（生产者）永远不会被阻塞，而只有获取数据的操作（消费者）才会被阻塞。</p><h2 id="4-PriorityBlockingQueue"><a href="#4-PriorityBlockingQueue" class="headerlink" title="4. PriorityBlockingQueue"></a>4. PriorityBlockingQueue</h2><p><strong>支持优先级排序的无界阻塞队列。</strong></p><p>基于优先级的阻塞队列（优先级的判断通过构造函数传入的Compator对象来决定），但需要注意的是PriorityBlockingQueue并<strong>不会阻塞数据生产者，而只会在没有可消费的数据时，阻塞数据的消费者</strong>。</p><h2 id="5-SynchronousQueue"><a href="#5-SynchronousQueue" class="headerlink" title="5. SynchronousQueue"></a>5. SynchronousQueue</h2><p><strong>不存储元素的阻塞队列，也即单个元素的队列。</strong></p><p>一种无缓冲的等待队列，类似于无中介的直接交易，有点像原始社会中的生产者和消费者，生产者拿着产品去集市销售给产品的最终消费者，而消费者必须亲自去集市找到所要商品的直接生产者，如果一方没有找到合适的目标，那么对不起，大家都在集市等待。相对于有缓冲的BlockingQueue来说，少了一个中间经销商的环节（缓冲区），如果有经销商，生产者直接把产品批发给经销商，而无需在意经销商最终会将这些产品卖给那些消费者，由于经销商可以库存一部分商品，因此相对于直接交易模式，总体来说采用中间经销商的模式会吞吐量高一些（可以批量买卖）；但另一方面，又因为经销商的引入，使得产品从生产者到消费者中间增加了额外的交易环节，单个产品的及时响应性能可能会降低。</p><p>声明一个SynchronousQueue有两种不同的方式，它们之间有着不太一样的行为。</p><p><strong>公平模式和非公平模式的区别</strong>:</p><ul><li>公平模式：SynchronousQueue会采用公平锁，并配合一个FIFO队列来阻塞多余的生产者和消费者，从而体现整体的公平策略；</li><li>非公平模式（SynchronousQueue默认）：SynchronousQueue采用非公平锁，同时配合一个LIFO队列来管理多余的生产者和消费者，而后一种模式，如果生产者和消费者的处理速度有差距，则很容易出现饥渴的情况，即可能有某些生产者或者是消费者的数据永远都得不到处理。</li></ul><h2 id="6-LinkedTransferQueue"><a href="#6-LinkedTransferQueue" class="headerlink" title="6. LinkedTransferQueue"></a>6. LinkedTransferQueue</h2><p><strong>由链表组成的无界阻塞队列。</strong></p><p>LinkedTransferQueue 是一个由链表结构组成的无界阻塞 TransferQueue 队列。相对于其他阻塞队列，LinkedTransferQueue 多了 tryTransfer 和 transfer 方法.</p><p>LinkedTransferQueue 采用一种预占模式。意思就是消费者线程取元素时，如果队列不为空，则直接取走数据，若队列为空，那就生成一个节点（节点元素为 null）入队，然后消费者线程被等待在这个节点上，后面生产者线程入队时发现有一个元素为 null 的节点，生产者线程就不入队了，直接就将元素填充到该节点，并唤醒该节点等待的线程，被唤醒的消费者线程取走元素，从调用的方法返回。</p><h2 id="7-LinkedBlockingDeque"><a href="#7-LinkedBlockingDeque" class="headerlink" title="7.  LinkedBlockingDeque"></a>7.  LinkedBlockingDeque</h2><p><strong>由链表组成的双向阻塞队列</strong></p><p>LinkedBlockingDeque 是一个由链表结构组成的双向阻塞队列，即可以从队列的两端插入和移除元素。对于一些指定的操作，在插入或者获取队列元素时如果队列状态不允许该操作可能会阻塞住该线程直到队列状态变更为允许操作，这里的阻塞一般有两种情况</p><ul><li><p>插入元素时: 如果当前队列已满将会进入阻塞状态，一直等到队列有空的位置时再将该元素插入，该操作可以通过设置超时参数，超时后返回 false 表示操作失败，也可以不设置超时参数一直阻塞，中断后抛出 InterruptedException 异常</p></li><li><p>读取元素时: 如果当前队列为空会阻塞住直到队列不为空然后返回元素，同样可以通过设置超时参数</p></li></ul>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;一、阻塞队列概述&quot;&gt;&lt;a href=&quot;#一、阻塞队列概述&quot; class=&quot;headerlink&quot; title=&quot;一、阻塞队列概述&quot;&gt;&lt;/a&gt;一、阻塞队列概述&lt;/h1&gt;&lt;p&gt;阻塞队列，顾名思义，首先它是一个队列, 通过一个共享的队列，可以使得数据由队列的一端输入，从</summary>
      
    
    
    
    <category term="JUC" scheme="https://georgechan95.github.io/categories/JUC/"/>
    
    
    <category term="juc" scheme="https://georgechan95.github.io/tags/juc/"/>
    
    <category term="java" scheme="https://georgechan95.github.io/tags/java/"/>
    
  </entry>
  
  <entry>
    <title>07-JUC辅助类CountDownLatch、CyclicBarrier、Semaphore</title>
    <link href="https://georgechan95.github.io/blog/838e7581.html"/>
    <id>https://georgechan95.github.io/blog/838e7581.html</id>
    <published>2024-09-07T05:00:00.000Z</published>
    <updated>2024-09-07T07:42:20.066Z</updated>
    
    <content type="html"><![CDATA[<p>JUC 中提供了三种常用的辅助类，通过这些辅助类可以很好的解决线程数量过多时 Lock 锁的频繁操作。这三种辅助类为：</p><ul><li>CountDownLatch: 减少计数</li><li>CyclicBarrier: 循环栅栏</li><li>Semaphore: 信号灯</li></ul><h1 id="一、减少计数-CountDownLatch"><a href="#一、减少计数-CountDownLatch" class="headerlink" title="一、减少计数 CountDownLatch"></a>一、减少计数 CountDownLatch</h1><h2 id="1-概述"><a href="#1-概述" class="headerlink" title="1. 概述"></a>1. 概述</h2><p>该类的构造方法为 <code>CountDownLatch(int count)</code> 构造一个用给定计数初始化的 <code>CountDownLatch</code> </p><p>在这里插入代码片</p><pre><code class="highlight java"><span class="comment">/**</span><span class="comment"> * Constructs a &#123;<span class="doctag">@code</span> CountDownLatch&#125; initialized with the given count.</span><span class="comment"> *</span><span class="comment"> * <span class="doctag">@param</span> count the number of times &#123;<span class="doctag">@link</span> #countDown&#125; must be invoked</span><span class="comment"> *        before threads can pass through &#123;<span class="doctag">@link</span> #await&#125;</span><span class="comment"> * <span class="doctag">@throws</span> IllegalArgumentException if &#123;<span class="doctag">@code</span> count&#125; is negative</span><span class="comment"> */</span><span class="keyword">public</span> <span class="title function_">CountDownLatch</span><span class="params">(<span class="type">int</span> count)</span> &#123;    <span class="keyword">if</span> (count &lt; <span class="number">0</span>) <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">IllegalArgumentException</span>(<span class="string">&quot;count &lt; 0&quot;</span>);    <span class="built_in">this</span>.sync = <span class="keyword">new</span> <span class="title class_">Sync</span>(count);&#125;</code></pre><p>CountDownLatch 类可以设置一个计数器，然后通过 countDown 方法来进行减 1 的操作，使用 await 方法等待计数器不大于 0，然后继续执行 await 方法之后的语句。具体步骤可以演化为<strong>定义一个类，减1操作，并等待到0，为0执行结果</strong>。</p><p><strong>两个常用的主要方法</strong></p><ul><li>await() 使当前线程在锁存器倒计数至零之前一直在等待，除非线程被中断</li></ul><pre><code class="highlight java"><span class="comment">/**</span><span class="comment"> * Causes the current thread to wait until the latch has counted down to</span><span class="comment"> * zero, unless the thread is &#123;<span class="doctag">@linkplain</span> Thread#interrupt interrupted&#125;.</span><span class="comment"> *</span><span class="comment"> * &lt;p&gt;If the current count is zero then this method returns immediately.</span><span class="comment"> *</span><span class="comment"> * &lt;p&gt;If the current count is greater than zero then the current</span><span class="comment"> * thread becomes disabled for thread scheduling purposes and lies</span><span class="comment"> * dormant until one of two things happen:</span><span class="comment"> * &lt;ul&gt;</span><span class="comment"> * &lt;li&gt;The count reaches zero due to invocations of the</span><span class="comment"> * &#123;<span class="doctag">@link</span> #countDown&#125; method; or</span><span class="comment"> * &lt;li&gt;Some other thread &#123;<span class="doctag">@linkplain</span> Thread#interrupt interrupts&#125;</span><span class="comment"> * the current thread.</span><span class="comment"> * &lt;/ul&gt;</span><span class="comment"> *</span><span class="comment"> * &lt;p&gt;If the current thread:</span><span class="comment"> * &lt;ul&gt;</span><span class="comment"> * &lt;li&gt;has its interrupted status set on entry to this method; or</span><span class="comment"> * &lt;li&gt;is &#123;<span class="doctag">@linkplain</span> Thread#interrupt interrupted&#125; while waiting,</span><span class="comment"> * &lt;/ul&gt;</span><span class="comment"> * then &#123;<span class="doctag">@link</span> InterruptedException&#125; is thrown and the current thread&#x27;s</span><span class="comment"> * interrupted status is cleared.</span><span class="comment"> *</span><span class="comment"> * <span class="doctag">@throws</span> InterruptedException if the current thread is interrupted</span><span class="comment"> *         while waiting</span><span class="comment"> */</span><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">await</span><span class="params">()</span> <span class="keyword">throws</span> InterruptedException &#123;    sync.acquireSharedInterruptibly(<span class="number">1</span>);&#125;</code></pre><ul><li>countDown()递减锁存器的计数，如果计数达到零，将释放所有等待的线程</li></ul><pre><code class="highlight java"><span class="comment">/**</span><span class="comment"> * Decrements the count of the latch, releasing all waiting threads if</span><span class="comment"> * the count reaches zero.</span><span class="comment"> *</span><span class="comment"> * &lt;p&gt;If the current count is greater than zero then it is decremented.</span><span class="comment"> * If the new count is zero then all waiting threads are re-enabled for</span><span class="comment"> * thread scheduling purposes.</span><span class="comment"> *</span><span class="comment"> * &lt;p&gt;If the current count equals zero then nothing happens.</span><span class="comment"> */</span><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">countDown</span><span class="params">()</span> &#123;    sync.releaseShared(<span class="number">1</span>);&#125;<span class="comment">/**</span><span class="comment"> * Releases in shared mode.  Implemented by unblocking one or more</span><span class="comment"> * threads if &#123;<span class="doctag">@link</span> #tryReleaseShared&#125; returns true.</span><span class="comment"> *</span><span class="comment"> * <span class="doctag">@param</span> arg the release argument.  This value is conveyed to</span><span class="comment"> *        &#123;<span class="doctag">@link</span> #tryReleaseShared&#125; but is otherwise uninterpreted</span><span class="comment"> *        and can represent anything you like.</span><span class="comment"> * <span class="doctag">@return</span> the value returned from &#123;<span class="doctag">@link</span> #tryReleaseShared&#125;</span><span class="comment"> */</span><span class="keyword">public</span> <span class="keyword">final</span> <span class="type">boolean</span> <span class="title function_">releaseShared</span><span class="params">(<span class="type">int</span> arg)</span> &#123;    <span class="keyword">if</span> (tryReleaseShared(arg)) &#123;        signalNext(head);        <span class="keyword">return</span> <span class="literal">true</span>;    &#125;    <span class="keyword">return</span> <span class="literal">false</span>;&#125;</code></pre><h2 id="2-案例演示"><a href="#2-案例演示" class="headerlink" title="2. 案例演示"></a>2. 案例演示</h2><p>6个同学陆续离开教室之后，班长才能锁门</p><p><strong>演示没有CountDownLatch的情况</strong></p><p>如果不加 CountDownLatch类，会出现线程混乱执行，同学还未离开教室班长就已经锁门了</p><pre><code class="highlight java"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">NoCountDownLatch</span> &#123;    <span class="comment">//6个同学陆续离开教室之后，班长锁门</span>    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> InterruptedException &#123;        <span class="comment">// 创建六个线程，模拟六个学生</span>        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">1</span>; i &lt;=<span class="number">6</span>; i++) &#123;            <span class="keyword">new</span> <span class="title class_">Thread</span>(()-&gt;&#123;                System.out.println(Thread.currentThread().getName()+<span class="string">&quot;离开教室&quot;</span>);            &#125;,String.valueOf(i)).start();        &#125;        System.out.println(Thread.currentThread().getName()+<span class="string">&quot;锁门&quot;</span>);    &#125;&#125;</code></pre><p>运行结果：</p><pre><code class="highlight shell">5离开教室main锁门2离开教室1离开教室6离开教室3离开教室4离开教室</code></pre><p><strong>添加CountDownLatch</strong></p><pre><code class="highlight java"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">CountDownLatchDemo</span> &#123;    <span class="comment">//6个同学陆续离开教室之后，班长锁门</span>    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> InterruptedException &#123;        <span class="type">CountDownLatch</span> <span class="variable">countDownLatch</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">CountDownLatch</span>(<span class="number">6</span>);        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">1</span>; i &lt;= <span class="number">6</span>; i++) &#123;            <span class="keyword">new</span> <span class="title class_">Thread</span>(() -&gt; &#123;                System.out.println(Thread.currentThread().getName() + <span class="string">&quot; 号同学离开了教室&quot;</span>);                <span class="comment">// 计数器减1</span>                countDownLatch.countDown();            &#125;, String.valueOf(i)).start();        &#125;        <span class="comment">// 阻塞，等待计数器为0后，继续往下执行</span>        countDownLatch.await();        System.out.println(Thread.currentThread().getName() + <span class="string">&quot;执行了关门操作&quot;</span>);    &#125;&#125;</code></pre><p>运行结果：</p><pre><code class="highlight shell">2 号同学离开了教室5 号同学离开了教室6 号同学离开了教室1 号同学离开了教室4 号同学离开了教室3 号同学离开了教室main执行了关门操作</code></pre><h1 id="二、循环栅栏-CyclicBarrier"><a href="#二、循环栅栏-CyclicBarrier" class="headerlink" title="二、循环栅栏 CyclicBarrier"></a>二、循环栅栏 CyclicBarrier</h1><h2 id="1-概述-1"><a href="#1-概述-1" class="headerlink" title="1. 概述"></a>1. 概述</h2><p>CyclicBarrier 字面意思是环栅栏，是 JUC 下的一个并发工具，跟 CountDownLatch 很相似，都可以使线程先等待然后再执行，但是它的功能比 CountDownLatch 更加复杂和强大， CountDownLatch 是一个或者多个线程等待另外一批线程执行完毕后，在接着执行，而 CyclicBarrier 是等待一批线程到达某个状态之后再同时开始执行，回环的意思是当所有的线程被释放后，CyclicBarrier 可以被重启，也就是可以重复使用。</p><p><img src="https://raw.githubusercontent.com/GeorgeChan95/blogimg/master/img/2024/09/07/20240907-141817.png" alt="CyclicBarrier"></p><p>常用的构造方法有：**CyclicBarrier(int parties，Runnable barrierAction)**，其底层代码如下</p><pre><code class="highlight java"><span class="keyword">public</span> <span class="title function_">CyclicBarrier</span><span class="params">(<span class="type">int</span> parties, Runnable barrierAction)</span> &#123;    <span class="keyword">if</span> (parties &lt;= <span class="number">0</span>) <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">IllegalArgumentException</span>();    <span class="built_in">this</span>.parties = parties;    <span class="built_in">this</span>.count = parties;    <span class="comment">// 最后需要执行的方法</span>    <span class="built_in">this</span>.barrierCommand = barrierAction;&#125;</code></pre><p>创建一个新的CyclicBarrier，它将在<strong>给定数量的参与者</strong>（线程）处于等待状态时启动，并在启动barrier时执行**给定的屏障操作，*<em>该操作由最后一个*<em>进入barrier的线程操作</em></em></p><p>常用的方法有：</p><p><strong>await()</strong> 在所有的参与者都已经在此barrier上调用await方法之前一直等待。</p><pre><code class="highlight java"><span class="keyword">public</span> <span class="type">int</span> <span class="title function_">await</span><span class="params">()</span> <span class="keyword">throws</span> InterruptedException, BrokenBarrierException &#123;    <span class="keyword">try</span> &#123;        <span class="keyword">return</span> dowait(<span class="literal">false</span>, <span class="number">0L</span>);    &#125; <span class="keyword">catch</span> (TimeoutException toe) &#123;        <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">Error</span>(toe); <span class="comment">// cannot happen</span>    &#125;&#125;<span class="keyword">private</span> <span class="type">int</span> <span class="title function_">dowait</span><span class="params">(<span class="type">boolean</span> timed, <span class="type">long</span> nanos)</span>    <span class="keyword">throws</span> InterruptedException, BrokenBarrierException,TimeoutException &#123;    <span class="keyword">final</span> <span class="type">ReentrantLock</span> <span class="variable">lock</span> <span class="operator">=</span> <span class="built_in">this</span>.lock;    <span class="comment">// 同步锁</span>    lock.lock();    <span class="keyword">try</span> &#123;        <span class="keyword">final</span> <span class="type">Generation</span> <span class="variable">g</span> <span class="operator">=</span> generation;        <span class="keyword">if</span> (g.broken)            <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">BrokenBarrierException</span>();        <span class="keyword">if</span> (Thread.interrupted()) &#123;            breakBarrier();            <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">InterruptedException</span>();        &#125;<span class="comment">// 每次执行 CyclicBarrier 一次障碍数会加一，距离目标障碍数-1</span>        <span class="type">int</span> <span class="variable">index</span> <span class="operator">=</span> --count;        <span class="comment">// 当达到目标障碍数执行if内代码</span>        <span class="keyword">if</span> (index == <span class="number">0</span>) &#123;  <span class="comment">// tripped</span>            <span class="type">boolean</span> <span class="variable">ranAction</span> <span class="operator">=</span> <span class="literal">false</span>;            <span class="keyword">try</span> &#123;                <span class="keyword">final</span> <span class="type">Runnable</span> <span class="variable">command</span> <span class="operator">=</span> barrierCommand;                <span class="keyword">if</span> (command != <span class="literal">null</span>)                    <span class="comment">// 执行Runnable代码</span>                    command.run();                ranAction = <span class="literal">true</span>;                nextGeneration();                <span class="comment">// 返回0</span>                <span class="keyword">return</span> <span class="number">0</span>;            &#125; <span class="keyword">finally</span> &#123;                <span class="keyword">if</span> (!ranAction)                    breakBarrier();            &#125;        &#125;        <span class="comment">// 循环，直到触发、中断、中断或超时  </span>        <span class="keyword">for</span> (;;) &#123;            <span class="keyword">try</span> &#123;                <span class="keyword">if</span> (!timed)                    trip.await();                <span class="keyword">else</span> <span class="keyword">if</span> (nanos &gt; <span class="number">0L</span>)                    nanos = trip.awaitNanos(nanos);            &#125; <span class="keyword">catch</span> (InterruptedException ie) &#123;                <span class="keyword">if</span> (g == generation &amp;&amp; ! g.broken) &#123;                    breakBarrier();                    <span class="keyword">throw</span> ie;                &#125; <span class="keyword">else</span> &#123;                    <span class="comment">// We&#x27;re about to finish waiting even if we had not</span>                    <span class="comment">// been interrupted, so this interrupt is deemed to</span>                    <span class="comment">// &quot;belong&quot; to subsequent execution.</span>                    Thread.currentThread().interrupt();                &#125;            &#125;            <span class="keyword">if</span> (g.broken)                <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">BrokenBarrierException</span>();            <span class="keyword">if</span> (g != generation)                <span class="keyword">return</span> index;            <span class="keyword">if</span> (timed &amp;&amp; nanos &lt;= <span class="number">0L</span>) &#123;                breakBarrier();                <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">TimeoutException</span>();            &#125;        &#125;    &#125; <span class="keyword">finally</span> &#123;        lock.unlock();    &#125;&#125;</code></pre><p>从底层代码可知， CyclicBarrier 的构造方法第一个参数是目标障碍数，每次执行 CyclicBarrier 一次障碍数会+1，如果达到了目标障碍数，才会执行 cyclicBarrier.await()之后的语句。可以将 CyclicBarrier 理解为+1 操作（指与目标障碍数的距离）</p><h2 id="2-案例演示-1"><a href="#2-案例演示-1" class="headerlink" title="2. 案例演示"></a>2. 案例演示</h2><p><strong>代码案例：集齐7颗龙珠就可以召唤神龙</strong></p><pre><code class="highlight java"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">CyclicBarrirtTest</span> &#123;    <span class="keyword">private</span> <span class="keyword">static</span> <span class="type">Integer</span> <span class="variable">NUMBER</span> <span class="operator">=</span> <span class="number">7</span>;    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;        <span class="comment">// 每次执行 CyclicBarrier 一次障碍数会加一，如果达到了目标障碍数，才会执行 cyclicBarrier.await()之后的语句。</span>        <span class="type">CyclicBarrier</span> <span class="variable">cyclicBarrier</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">CyclicBarrier</span>(NUMBER, () -&gt; System.out.println(<span class="string">&quot;集齐7颗龙珠，可以召唤神龙了&quot;</span>));        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">1</span>; i &lt;= <span class="number">7</span>; i++) &#123;            <span class="keyword">new</span> <span class="title class_">Thread</span>(() -&gt; &#123;                System.out.println(Thread.currentThread().getName() + <span class="string">&quot; 号龙珠已收集&quot;</span>);                <span class="keyword">try</span> &#123;                    <span class="comment">// 执行 await() 方法，障碍数 +1</span>                    cyclicBarrier.await();                &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;                    <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">RuntimeException</span>(e);                &#125; <span class="keyword">catch</span> (BrokenBarrierException e) &#123;                    <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">RuntimeException</span>(e);                &#125;            &#125;, String.valueOf(i)).start();        &#125;    &#125;&#125;</code></pre><p><strong>执行结果</strong></p><pre><code class="highlight shell">5 号龙珠已收集1 号龙珠已收集4 号龙珠已收集2 号龙珠已收集6 号龙珠已收集3 号龙珠已收集7 号龙珠已收集集齐7颗龙珠，可以召唤神龙了</code></pre><h1 id="三、信号灯-Semaphore"><a href="#三、信号灯-Semaphore" class="headerlink" title="三、信号灯 Semaphore"></a>三、信号灯 Semaphore</h1><h2 id="1-概述-2"><a href="#1-概述-2" class="headerlink" title="1. 概述"></a>1. 概述</h2><p>信号量(Semaphore)，又被称为信号灯，在多线程环境下用于协调各个线程, 以保证它们能够正确、合理的使用公共资源。信号量维护了一个许可集，我们在初始化Semaphore时需要为这个许可集传入一个数量值，该数量值代表同一时间能访问共享资源的线程数量。</p><p>线程可以通过acquire()方法获取到一个许可，然后对共享资源进行操作。注意如果许可集已分配完了，那么线程将进入等待状态，直到其他线程释放许可才有机会再获取许可，线程释放一个许可通过release()方法完成，”许可”将被归还给Semaphore。</p><p><strong>具体常用的构造方法有：</strong></p><p>Semaphore(int permits) 创建具有给定的许可数和非公平的公平设置的 Semapore</p><pre><code class="highlight java"><span class="keyword">public</span> <span class="title function_">Semaphore</span><span class="params">(<span class="type">int</span> <span class="keyword">permits</span>)</span> &#123;    <span class="comment">// 默认创建非公平锁</span>    sync = <span class="keyword">new</span> <span class="title class_">NonfairSync</span>(<span class="keyword">permits</span>);&#125;<span class="keyword">public</span> <span class="title function_">Semaphore</span><span class="params">(<span class="type">int</span> <span class="keyword">permits</span>, <span class="type">boolean</span> fair)</span> &#123;    <span class="comment">// fair为true时，为公平锁</span>    sync = fair ? <span class="keyword">new</span> <span class="title class_">FairSync</span>(<span class="keyword">permits</span>) : <span class="keyword">new</span> <span class="title class_">NonfairSync</span>(<span class="keyword">permits</span>);&#125;</code></pre><p><strong>具体常用的方法有：</strong></p><p>acquire()从此信号量获取一个许可，在获取到许可前一直将线程阻塞。</p><p>release()释放一个许可，将其返回给信号量</p><pre><code class="highlight java"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">acquire</span><span class="params">()</span> <span class="keyword">throws</span> InterruptedException &#123;    <span class="comment">// 阻塞当前线程</span>    sync.acquireSharedInterruptibly(<span class="number">1</span>);&#125;<span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">release</span><span class="params">()</span> &#123;    <span class="comment">// 释放一个许可</span>    sync.releaseShared(<span class="number">1</span>);&#125;</code></pre><p>设置许可数量 <code>Semaphore semaphore = new Semaphore(3);</code></p><p><strong>一般 acquire(）都会抛出异常，release 在 finally 中执行</strong></p><h2 id="2-案例演示-2"><a href="#2-案例演示-2" class="headerlink" title="2. 案例演示"></a>2. 案例演示</h2><p>6辆汽车，停3个车位</p><pre><code class="highlight java"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">SemaphoreTest</span> &#123;    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;        <span class="comment">//创建Semaphore，设置许可数量</span>        <span class="type">Semaphore</span> <span class="variable">semaphore</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Semaphore</span>(<span class="number">3</span>);        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">1</span>; i &lt;= <span class="number">6</span>; i++) &#123;            <span class="keyword">new</span> <span class="title class_">Thread</span>(() -&gt; &#123;                <span class="keyword">try</span> &#123;                    <span class="comment">// 获取许可，在获取到前，线程阻塞</span>                    semaphore.acquire();                    System.out.println(Thread.currentThread().getName() + <span class="string">&quot; 找到了车位&quot;</span>);                    <span class="comment">// 设置停车时间</span>                    TimeUnit.SECONDS.sleep(<span class="keyword">new</span> <span class="title class_">Random</span>().nextInt(<span class="number">5</span>));                    <span class="comment">// 离开车位</span>                    System.out.println(Thread.currentThread().getName()+<span class="string">&quot;------离开了车位&quot;</span>);                &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;                    <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">RuntimeException</span>(e);                &#125; <span class="keyword">finally</span> &#123;                    <span class="comment">// 释放许可</span>                    semaphore.release();                &#125;            &#125;, <span class="string">&quot;车辆&quot;</span> + i).start();        &#125;    &#125;&#125;</code></pre><p><strong>执行结果：</strong></p><pre><code class="highlight shell">车辆1 找到了车位车辆3 找到了车位车辆2 找到了车位车辆1------离开了车位车辆4 找到了车位车辆2------离开了车位车辆5 找到了车位车辆5------离开了车位车辆6 找到了车位车辆3------离开了车位车辆6------离开了车位车辆4------离开了车位</code></pre>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;JUC 中提供了三种常用的辅助类，通过这些辅助类可以很好的解决线程数量过多时 Lock 锁的频繁操作。这三种辅助类为：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;CountDownLatch: 减少计数&lt;/li&gt;
&lt;li&gt;CyclicBarrier: 循环栅栏&lt;/li&gt;
&lt;li&gt;Semap</summary>
      
    
    
    
    <category term="JUC" scheme="https://georgechan95.github.io/categories/JUC/"/>
    
    
    <category term="juc" scheme="https://georgechan95.github.io/tags/juc/"/>
    
    <category term="java" scheme="https://georgechan95.github.io/tags/java/"/>
    
  </entry>
  
</feed>
