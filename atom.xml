<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>George&#39;s Blog</title>
  
  <subtitle>个人邮箱：george_95@126.com</subtitle>
  <link href="https://georgechan95.github.io/atom.xml" rel="self"/>
  
  <link href="https://georgechan95.github.io/"/>
  <updated>2024-08-16T08:50:41.901Z</updated>
  <id>https://georgechan95.github.io/</id>
  
  <author>
    <name>George</name>
    
  </author>
  
  <generator uri="https://hexo.io/">Hexo</generator>
  
  <entry>
    <title>第二十三章-JVM监控及诊断工具-GUI篇</title>
    <link href="https://georgechan95.github.io/2024/08/16/jvm/%E7%AC%AC%E4%BA%8C%E5%8D%81%E4%B8%89%E7%AB%A0-JVM%E7%9B%91%E6%8E%A7%E5%8F%8A%E8%AF%8A%E6%96%AD%E5%B7%A5%E5%85%B7-GUI%E7%AF%87/"/>
    <id>https://georgechan95.github.io/2024/08/16/jvm/%E7%AC%AC%E4%BA%8C%E5%8D%81%E4%B8%89%E7%AB%A0-JVM%E7%9B%91%E6%8E%A7%E5%8F%8A%E8%AF%8A%E6%96%AD%E5%B7%A5%E5%85%B7-GUI%E7%AF%87/</id>
    <published>2024-08-16T13:00:00.000Z</published>
    <updated>2024-08-16T08:50:41.901Z</updated>
    
    <content type="html"><![CDATA[<p>一、</p><pre><code class="highlight plaintext">关于P332案例分析的几个问题解答,首先老师讲错了一点，普通Java对象头的大小为12字节或16字节默认采用了指针压缩则为12字节，没有采用则为16字节（数组还需要加上数组长度）。详情参考我的博客。1.为什么有152字节和144字节：因为我们的URL和content存在两种情况URL:&quot;http://www.7.com&quot;、content:&quot;7&quot;-----URL:&quot;http://www.14.com&quot;、content:&quot;14&quot;第一种URL长度为16，底层的char数组的占用空间为(【】方括号里面整个都属于对象头，分开写方便大家理解)【普通对象头(12) + 数组长度(4)】 + 16个字符(32) = 48字节，符合8字节对齐同理content 占用 【普通对象头(12) +数组长度(4)】+ 一个字符(2) = 18字节,八字节对齐=24字节第二种URL长度为17，底层的插入数组的占用空间为【普通对象头(12) + 数组长度(4)】 + 17个字符(34) = 50字节，不符合8字节对齐，对齐为56同理content 占用 【普通对象头(12) +数组长度(4)】+ 两个字符(4) = 20字节,八字节对齐=24字节所以第一种总字节为48 + 24 = 72,第二种总字节为56 + 24 = 80因此第二种比第一种多了8字节，所以是152和144。(为什么总大小是152而不是72是因为我们只计算了String底层的char数组的区别没有计算各变量本身的浅堆,因为结构都想相同，所以差别就差在内容的占用上)2.为什么最终结果是1288首先ElementData数组本身的浅堆大小为 【普通对象头(12) + 数组长度(4)】 + 数组内容【15个Obejct引用=16*4】 = 76,八字节对齐=80字节15个Object分为13个152字节+2个144字节，总大小为=2264字节7号和其他student重复的有0、21、42、63、84、35、70总计6个152和1一个144所以2264 - 6 * 152 - 144 = 1208字节所以ElementData本身的浅堆80 + 仅能通过它到达的浅堆1208 = 1288</code></pre>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;一、&lt;/p&gt;
&lt;pre&gt;&lt;code class=&quot;highlight plaintext&quot;&gt;关于P332案例分析的几个问题解答,首先老师讲错了一点，普通Java对象头的大小为12字节或16字节
默认采用了指针压缩则为12字节，没有采用则为16字节（数组还需要加上数组长度）。</summary>
      
    
    
    
    <category term="JVM" scheme="https://georgechan95.github.io/categories/JVM/"/>
    
    
    <category term="jvm" scheme="https://georgechan95.github.io/tags/jvm/"/>
    
    <category term="java" scheme="https://georgechan95.github.io/tags/java/"/>
    
  </entry>
  
  <entry>
    <title>第二十二章-JVM监控及诊断工具-命令行篇</title>
    <link href="https://georgechan95.github.io/2024/08/12/jvm/%E7%AC%AC%E4%BA%8C%E5%8D%81%E4%BA%8C%E7%AB%A0-JVM%E7%9B%91%E6%8E%A7%E5%8F%8A%E8%AF%8A%E6%96%AD%E5%B7%A5%E5%85%B7-%E5%91%BD%E4%BB%A4%E8%A1%8C%E7%AF%87/"/>
    <id>https://georgechan95.github.io/2024/08/12/jvm/%E7%AC%AC%E4%BA%8C%E5%8D%81%E4%BA%8C%E7%AB%A0-JVM%E7%9B%91%E6%8E%A7%E5%8F%8A%E8%AF%8A%E6%96%AD%E5%B7%A5%E5%85%B7-%E5%91%BD%E4%BB%A4%E8%A1%8C%E7%AF%87/</id>
    <published>2024-08-12T11:36:32.000Z</published>
    <updated>2024-08-16T08:58:14.965Z</updated>
    
    <content type="html"><![CDATA[<h1 id="一、概述"><a href="#一、概述" class="headerlink" title="一、概述"></a>一、概述</h1><p>性能诊断是软件工程师在日常工作中需要经常面对和解决的问题，在用户体验至上的今天，解决好应用的性能问题能带来非常大的收益。</p><p>Java 作为最流行的编程语言之一，其应用性能诊断一直受到业界广泛关注。可能造成 Java 应用出现性能问题的因素非常多，例如线程控制、磁盘读写、数据库访问、网络I&#x2F;O、垃圾收集等。想要定位这些问题，一款优秀的性能诊断工具必不可少。</p><h2 id="1-简单命令行工具"><a href="#1-简单命令行工具" class="headerlink" title="1. 简单命令行工具"></a>1. 简单命令行工具</h2><p>除了我们最了解的两个命令: javac，java 之外, 进入到安装jdk的bin目录，发现还有一系列辅助工具。这些辅助工具用来获取目标 JVM 不同方面、不同层次的信息，帮助开发人员很好地解决Java应用程序的一些疑难杂症。</p><p><img src="https://raw.githubusercontent.com/GeorgeChan95/blogimg/master/img/2024/08/12/20240812-194528.png" alt="mac系统jdk安装目录"></p><p><img src="https://raw.githubusercontent.com/GeorgeChan95/blogimg/master/img/2024/08/12/20240812-194744.png" alt="win下JDK安装目录"></p><p>官方源码地址：<a href="https://hg.openjdk.org/jdk/jdk11/file/1ddf9a99e4ad/src/jdk.jcmd/share/classes/sun/tools">https://hg.openjdk.org/jdk/jdk11/file/1ddf9a99e4ad/src/jdk.jcmd/share/classes/sun/tools</a></p><h1 id="二、jps：查看正在运行的Java进程"><a href="#二、jps：查看正在运行的Java进程" class="headerlink" title="二、jps：查看正在运行的Java进程"></a>二、jps：查看正在运行的Java进程</h1><p>jps (Java Process Status)：显示指定系统内所有的HotSpot虚拟机进程（查看虚拟机进程信息），可用于查询正在运行的虚拟机进程。</p><p>说明：对于本地虚拟机进程来说，进程的本地虚拟机ID与操作系统的进程ID是一致的，是唯一的。</p><p><strong>基本使用语法为：</strong><code>jps [options] [hostid]</code></p><p>我们还可以通过追加参数，来打印额外的信息。</p><h2 id="1-options参数"><a href="#1-options参数" class="headerlink" title="1. options参数"></a>1. options参数</h2><ul><li><p>-q：仅仅显示LVMID（local virtual machine id），即本地虚拟机唯一id。不显示主类的名称等</p></li><li><p>-l：输出应用程序主类的全类名 或 如果进程执行的是jar包，则输出jar完整路径</p></li><li><p>-m：输出虚拟机进程启动时传递给主类main()的参数</p></li><li><p>-v：列出虚拟机进程启动时的JVM参数。比如：-Xms20m -Xmx50m是启动程序指定的jvm参数。</p></li></ul><p>说明：以上参数可以综合使用。</p><p>补充：如果某 Java 进程关闭了默认开启的UsePerfData参数（即使用参数 <code>-XX：-UsePerfData</code>），那么jps命令（以及下面介绍的jstat）将无法探知该Java 进程。</p><p>解决Windows11下,  jps 命令无效的问题: <a href="https://blog.csdn.net/lingyiwin/article/details/123238600">https://blog.csdn.net/lingyiwin/article/details/123238600</a></p><h2 id="2-hostid参数"><a href="#2-hostid参数" class="headerlink" title="2. hostid参数"></a>2. hostid参数</h2><p>RMI注册表中注册的主机名。如果想要远程监控主机上的 java 程序，需要安装 <code>jstatd</code> 。</p><p>对于具有更严格的安全实践的网络场所而言，可能使用一个自定义的策略文件来显示对特定的可信主机或网络的访问，尽管这种技术容易受到IP地址欺诈攻击。</p><p>如果安全问题无法使用一个定制的策略文件来处理，那么最安全的操作是不运行jstatd服务器，而是在本地使用jstat和jps工具。</p><p>关于 jps [hostid] 的使用, 参考: <a href="https://www.cnblogs.com/keystone/p/10789382.html">https://www.cnblogs.com/keystone/p/10789382.html</a></p><h2 id="3-综合使用"><a href="#3-综合使用" class="headerlink" title="3. 综合使用"></a>3. 综合使用</h2><p><code>jps -l -m</code> 等价于 <code>jps -lm</code></p><p><strong>如何将信息输出到同级文件中：</strong><br><strong>语法：</strong>命令 &gt; 文件名称<br><strong>例如：</strong>jps -l &gt; a.txt</p><h1 id="三、jstat：查看JVM统计信息"><a href="#三、jstat：查看JVM统计信息" class="headerlink" title="三、jstat：查看JVM统计信息"></a>三、jstat：查看JVM统计信息</h1><p><code>jstat</code>（JVM Statistics Monitoring Tool）：用于监视虚拟机各种运行状态信息的命令行工具。它可以显示本地或者远程虚拟机进程中的类装载、内存、垃圾收集、JIT编译等运行数据。在没有GUI图形界面，只提供了纯文本控制台环境的服务器上，它将是运行期定位虚拟机性能问题的首选工具。常用于检测垃圾回收问题以及内存泄漏问题。</p><p><strong>官方文档：</strong><a href="https://docs.oracle.com/javase/8/docs/technotes/tools/unix/jstat.html">https://docs.oracle.com/javase/8/docs/technotes/tools/unix/jstat.html</a></p><p><strong>基本使用语法为：</strong> <code>jstat -&lt;option&gt; [-t] [-h&lt;lines&gt;] &lt;vmid&gt; [&lt;interval&gt; [&lt;count&gt;]]</code> </p><p><strong>查看命令相关参数：</strong>jstat -h  或  jstat -help</p><p><strong>查看options选项:</strong>   <code>jstat -options</code> </p><p>其中<strong>vmid是进程id号</strong>，也就是jps之后看到的前面的号码，如下：</p><p><img src="https://raw.githubusercontent.com/GeorgeChan95/blogimg/master/img/2024/08/14/20240814-121106.png" alt="image-20240814121104746"></p><h2 id="1-option参数"><a href="#1-option参数" class="headerlink" title="1. option参数"></a>1. option参数</h2><p>选项option可以由以下值构成。</p><p><strong>类装载相关的：</strong></p><ul><li>-class：显示ClassLoader的相关信息：类的装载、卸载数量、总空间、类装载所消耗的时间等</li></ul><p><strong>垃圾回收相关的：</strong></p><ul><li><p>-gc：显示与GC相关的堆信息。包括Eden区、两个Survivor区、老年代、永久代等的容量、已用空间、GC时间合计等信息。</p></li><li><p>-gccapacity：显示内容与-gc基本相同，但输出主要关注Java堆各个区域使用到的最大、最小空间。</p></li><li><p>-gcutil：显示内容与-gc基本相同，但输出主要关注已使用空间占总空间的百分比。</p></li><li><p>-gccause：与-gcutil功能一样，但是会额外输出导致最后一次或当前正在发生的GC产生的原因。</p></li><li><p>-gcnew：显示新生代GC状况</p></li><li><p>-gcnewcapacity：显示内容与-gcnew基本相同，输出主要关注使用到的最大、最小空间</p></li><li><p>-geold：显示老年代GC状况</p></li><li><p>-gcoldcapacity：显示内容与-gcold基本相同，输出主要关注使用到的最大、最小空间</p></li><li><p>-gcpermcapacity：显示永久代使用到的最大、最小空间。</p></li></ul><p><strong>JIT相关的：</strong></p><ul><li><p>-compiler：显示JIT编译器编译过的方法、耗时等信息</p></li><li><p>-printcompilation：输出已经被JIT编译的方法</p></li></ul><h3 id="2-使用示例"><a href="#2-使用示例" class="headerlink" title="2. 使用示例"></a>2. 使用示例</h3><h4 id="class"><a href="#class" class="headerlink" title="-class"></a>-class</h4><p><strong>jstat -class -t -h5 29544 1000 10</strong> </p><p>其中h5中的5代表每隔5个分隔一次，29544 代表类的进程id，1000代表每隔1000毫秒打印一次，10代表一共打印10次，如下所示：</p><p><img src="https://raw.githubusercontent.com/GeorgeChan95/blogimg/master/img/2024/08/15/20240815-173507.png" alt="-class"></p><p>以下是输出结果中每个参数的含义：</p><ol><li><strong>Timestamp</strong>: 运行时的时间戳，单位为秒，表示自 JVM 启动以来的时间。通过这个时间戳可以了解当前统计数据是在 JVM 运行多长时间之后获取的。在你的输出中，时间戳分别为 <code>13.1</code>, <code>14.1</code>, <code>15.1</code> 等。</li><li><strong>Loaded</strong>: 已加载的类的数量。这里显示的是自 JVM 启动以来，JVM 加载到内存中的类的总数。在输出中，<code>Loaded</code> 的值始终为 <code>610</code>，表示在每个采样点 JVM 中已加载了 610 个类。</li><li><strong>Bytes</strong>: 已加载的类所占用的内存空间大小，单位为 KB。在输出中，<code>Bytes</code> 的值始终为 <code>1234.0</code> KB，表示 JVM 中已加载的类占用了 1234 KB 的内存空间。</li><li><strong>Unloaded</strong>: 自 JVM 启动以来，已卸载的类的数量。在你的输出中，<code>Unloaded</code> 的值始终为 <code>0</code>，表示没有卸载过任何类。</li><li><strong>Bytes</strong>: 已卸载的类释放的内存空间大小，单位为 KB。因为没有类被卸载，所以这个值始终为 <code>0.0</code> KB。</li><li><strong>Time</strong>: JVM 在类加载和卸载上所花费的总时间，单位为秒。这里的 <code>Time</code> 值为 <code>0.05</code> 秒，表示 JVM 在处理类加载和卸载操作上总共花费了 0.05 秒。</li></ol><h4 id="gc"><a href="#gc" class="headerlink" title="-gc"></a>-gc</h4><p><strong>jstat -gc -t -h5 28100 1000 10</strong></p><p>其中h5中的5代表每隔5个分隔一次，28100 代表类的进程id，1000代表每隔1000毫秒打印一次，10代表一共打印10次，如下所示：</p><p><img src="https://raw.githubusercontent.com/GeorgeChan95/blogimg/master/img/2024/08/15/20240815-173658.png" alt="-gc"></p><p>以下是每个参数的含义和解释：</p><ol><li><strong>Timestamp</strong>: 运行时的时间戳，单位为秒，表示自 JVM 启动以来的时间。在你的输出中，时间戳分别为 <code>12.7</code>, <code>13.7</code>, <code>14.7</code> 等。</li><li><strong>S0C</strong> (Survivor Space 0 Capacity): 新生代中第一个存活区（Survivor 0 区）的容量，单位为 KB。在你的输出中，<code>S0C</code> 的值始终为 <code>2048.0</code> KB，表示 Survivor 0 区的容量为 2048 KB。</li><li><strong>S1C</strong> (Survivor Space 1 Capacity): 新生代中第二个存活区（Survivor 1 区）的容量，单位为 KB。<code>S1C</code> 的值也为 <code>2048.0</code> KB，表示 Survivor 1 区的容量为 2048 KB。</li><li><strong>S0U</strong> (Survivor Space 0 Utilization): 新生代中第一个存活区（Survivor 0 区）的使用量，单位为 KB。在输出中，<code>S0U</code> 的值大部分时间为 <code>0.0</code>，表示 Survivor 0 区未被使用。</li><li><strong>S1U</strong> (Survivor Space 1 Utilization): 新生代中第二个存活区（Survivor 1 区）的使用量，单位为 KB。在第一个时间戳中，<code>S1U</code> 的值为 <code>0.0</code>，表示未使用。在后续时间戳中，<code>S1U</code> 的值为 <code>2024.3</code> KB，表示 Survivor 1 区几乎已满。</li><li><strong>EC</strong> (Eden Space Capacity): Eden 区的容量，单位为 KB。<code>EC</code> 的值为 <code>16384.0</code> KB，表示 Eden 区的容量为 16384 KB。</li><li><strong>EU</strong> (Eden Space Utilization): Eden 区的使用量，单位为 KB。随着时间的推移，<code>EU</code> 的值从 <code>13888.0</code> KB 增加到 <code>5002.0</code> KB，表示 Eden 区的使用情况逐渐变化。</li><li><strong>OC</strong> (Old Generation Capacity): 老年代的容量，单位为 KB。<code>OC</code> 的值为 <code>40960.0</code> KB，表示老年代的容量为 40960 KB。</li><li><strong>OU</strong> (Old Generation Utilization): 老年代的使用量，单位为 KB。最初 <code>OU</code> 的值为 <code>0.0</code> KB，但在时间戳 <code>15.7</code> 之后变为 <code>11817.8</code> KB，表示部分对象被移入了老年代。</li><li><strong>MC</strong> (Metaspace Capacity): 元空间的容量，单位为 KB。<code>MC</code> 的值为 <code>4480.0</code> KB，后续增加到 <code>4864.0</code> KB，表示元空间的容量略有增加。</li><li><strong>MU</strong> (Metaspace Utilization): 元空间的使用量，单位为 KB。<code>MU</code> 的值从 <code>776.8</code> KB 增加到 <code>3743.2</code> KB，表示元空间的使用情况变化较大。</li><li><strong>CCSC</strong> (Compressed Class Space Capacity): 压缩类空间的容量，单位为 KB。<code>CCSC</code> 的值最初为 <code>384.0</code> KB，随后增加到 <code>512.0</code> KB，表示压缩类空间的容量有所增加。</li><li><strong>CCSU</strong> (Compressed Class Space Utilization): 压缩类空间的使用量，单位为 KB。<code>CCSU</code> 的值从 <code>76.6</code> KB 增加到 <code>409.7</code> KB，表示压缩类空间的使用情况变化较大。</li><li><strong>YGC</strong> (Young Generation GC Events): 新生代 GC（Minor GC）的次数。<code>YGC</code> 的值最初为 <code>0</code>，随后增加到 <code>1</code>，表示发生了一次 Minor GC。</li><li><strong>YGCT</strong> (Young Generation GC Time): 新生代 GC 总时间，单位为秒。<code>YGCT</code> 的值从 <code>0.000</code> 秒增加到 <code>0.007</code> 秒，表示 Minor GC 总共花费了 0.007 秒。</li><li><strong>FGC</strong> (Full GC Events): Full GC（涉及整个堆的 GC） 的次数。在输出中，<code>FGC</code> 的值为 <code>0</code>，表示未发生过 Full GC。</li><li><strong>FGCT</strong> (Full GC Time): Full GC 总时间，单位为秒。<code>FGCT</code> 的值为 <code>0.000</code> 秒，表示 Full GC 总共花费了 0 秒。</li><li><strong>GCT</strong> (Total GC Time): GC 总时间，单位为秒，包含 Minor GC 和 Full GC 的时间。<code>GCT</code> 的值从 <code>0.000</code> 秒增加到 <code>0.007</code> 秒，表示 GC 总时间为 0.007 秒。</li></ol><h4 id="gccapacity"><a href="#gccapacity" class="headerlink" title="-gccapacity"></a>-gccapacity</h4><p><code>jstat -gccapacity 3060</code>，其中 3060 代表类的进程id，执行结果如下：</p><p><img src="https://raw.githubusercontent.com/GeorgeChan95/blogimg/master/img/2024/08/15/20240815-170535.png" alt="-gccapacity"></p><p>以下是每个参数的含义：</p><ol><li><strong>NGCMN</strong> (Minimum New Generation Capacity): 新生代内存区域的最小容量。</li><li><strong>NGCMX</strong> (Maximum New Generation Capacity): 新生代内存区域的最大容量。</li><li><strong>NGC</strong> (Current New Generation Capacity): 新生代内存区域的当前容量。</li><li><strong>S0C</strong> (Current Survivor Space 0 Capacity): 新生代中第一个存活区的当前容量。</li><li><strong>S1C</strong> (Current Survivor Space 1 Capacity): 新生代中第二个存活区的当前容量。</li><li><strong>EC</strong> (Current Eden Space Capacity): Eden 区的当前容量。Eden 区是新对象首先分配内存的地方。</li><li><strong>OGCMN</strong> (Minimum Old Generation Capacity): 老年代内存区域的最小容量。</li><li><strong>OGCMX</strong> (Maximum Old Generation Capacity): 老年代内存区域的最大容量。</li><li><strong>OGC</strong> (Current Old Generation Capacity): 老年代内存区域的当前容量。</li><li><strong>OC</strong> (Current Old Space Capacity): 老年代的当前容量，通常等同于 OGC。</li><li><strong>MCMN</strong> (Minimum Metaspace Capacity): 元空间的最小容量（元空间用于存储类元数据）。</li><li><strong>MCMX</strong> (Maximum Metaspace Capacity): 元空间的最大容量。</li><li><strong>MC</strong> (Current Metaspace Capacity): 元空间的当前容量。</li><li><strong>CCSMN</strong> (Minimum Compressed Class Space Capacity): 压缩类空间的最小容量。压缩类空间用于存储类的相关元数据（如果开启了类元数据的压缩）。</li><li><strong>CCSMX</strong> (Maximum Compressed Class Space Capacity): 压缩类空间的最大容量。</li><li><strong>CCSC</strong> (Current Compressed Class Space Capacity): 压缩类空间的当前容量。</li><li><strong>YGC</strong> (Number of Young Generation GC Events): 新生代 GC（通常称为 Minor GC）的次数。</li><li><strong>FGC</strong> (Number of Full GC Events): Full GC（涉及整个堆的 GC） 的次数。</li></ol><h4 id="gcutil"><a href="#gcutil" class="headerlink" title="-gcutil"></a>-gcutil</h4><p><code>jstat -gcutil 33520</code>，其中13152代表类的进程id，执行结果如下所示：</p><p><img src="https://raw.githubusercontent.com/GeorgeChan95/blogimg/master/img/2024/08/15/20240815-172341.png" alt="-gcutil"></p><p>以下是每个参数的含义：</p><ol><li><strong>S0</strong> (Survivor Space 0 Utilization): 新生代中第一个存活区（Survivor 0 区）的使用率（百分比）。在这个例子中，<code>S0</code> 的值为 <code>0.00</code>，表示 Survivor 0 区未被使用。</li><li><strong>S1</strong> (Survivor Space 1 Utilization): 新生代中第二个存活区（Survivor 1 区）的使用率（百分比）。<code>S1</code> 的值为 <code>0.00</code>，表示 Survivor 1 区未被使用。</li><li><strong>E</strong> (Eden Space Utilization): Eden 区的使用率（百分比）。<code>E</code> 的值为 <code>81.10</code>，表示 Eden 区的 81.10% 被使用。</li><li><strong>O</strong> (Old Generation Utilization): 老年代的使用率（百分比）。<code>O</code> 的值为 <code>0.00</code>，表示老年代未被使用。</li><li><strong>M</strong> (Metaspace Utilization): 元空间的使用率（百分比）。<code>M</code> 的值为 <code>17.34</code>，表示元空间的 17.34% 被使用。</li><li><strong>CCS</strong> (Compressed Class Space Utilization): 压缩类空间的使用率（百分比）。<code>CCS</code> 的值为 <code>19.94</code>，表示压缩类空间的 19.94% 被使用。</li><li><strong>YGC</strong> (Number of Young Generation GC Events): 新生代 GC（Minor GC）的次数。<code>YGC</code> 的值为 <code>0</code>，表示未发生过 Minor GC。</li><li><strong>YGCT</strong> (Young Generation GC Time): 新生代 GC 总时间（以秒为单位）。<code>YGCT</code> 的值为 <code>0.000</code>，表示 Minor GC 消耗的总时间为 0 秒。</li><li><strong>FGC</strong> (Number of Full GC Events): Full GC（涉及整个堆的 GC） 的次数。<code>FGC</code> 的值为 <code>0</code>，表示未发生过 Full GC。</li><li><strong>FGCT</strong> (Full GC Time): Full GC 总时间（以秒为单位）。<code>FGCT</code> 的值为 <code>0.000</code>，表示 Full GC 消耗的总时间为 0 秒。</li><li><strong>GCT</strong> (Total GC Time): GC 总时间（以秒为单位），包括所有 Minor GC 和 Full GC 的时间。<code>GCT</code> 的值为 <code>0.000</code>，表示 GC 总时间为 0 秒。</li></ol><h4 id="gccause"><a href="#gccause" class="headerlink" title="-gccause"></a>-gccause</h4><p><code>jstat -gccause 9180</code>，其中 9180 代表类的进程id，执行结果如下：</p><p><img src="https://raw.githubusercontent.com/GeorgeChan95/blogimg/master/img/2024/08/15/20240815-172707.png" alt="-gccause"></p><p>以下是每个参数的含义：</p><ol><li><strong>S0</strong> (Survivor Space 0 Utilization): 新生代中第一个存活区（Survivor 0 区）的使用率（百分比）。在这个例子中，<code>S0</code> 的值为 <code>0.00</code>，表示 Survivor 0 区未被使用。</li><li><strong>S1</strong> (Survivor Space 1 Utilization): 新生代中第二个存活区（Survivor 1 区）的使用率（百分比）。<code>S1</code> 的值为 <code>0.00</code>，表示 Survivor 1 区未被使用。</li><li><strong>E</strong> (Eden Space Utilization): Eden 区的使用率（百分比）。<code>E</code> 的值为 <code>66.45</code>，表示 Eden 区的 66.45% 被使用。</li><li><strong>O</strong> (Old Generation Utilization): 老年代的使用率（百分比）。<code>O</code> 的值为 <code>0.00</code>，表示老年代未被使用。</li><li><strong>M</strong> (Metaspace Utilization): 元空间的使用率（百分比）。<code>M</code> 的值为 <code>17.34</code>，表示元空间的 17.34% 被使用。</li><li><strong>CCS</strong> (Compressed Class Space Utilization): 压缩类空间的使用率（百分比）。<code>CCS</code> 的值为 <code>19.94</code>，表示压缩类空间的 19.94% 被使用。</li><li><strong>YGC</strong> (Number of Young Generation GC Events): 新生代 GC（Minor GC）的次数。<code>YGC</code> 的值为 <code>0</code>，表示未发生过 Minor GC。</li><li><strong>YGCT</strong> (Young Generation GC Time): 新生代 GC 总时间（以秒为单位）。<code>YGCT</code> 的值为 <code>0.000</code>，表示 Minor GC 消耗的总时间为 0 秒。</li><li><strong>FGC</strong> (Number of Full GC Events): Full GC（涉及整个堆的 GC） 的次数。<code>FGC</code> 的值为 <code>0</code>，表示未发生过 Full GC。</li><li><strong>FGCT</strong> (Full GC Time): Full GC 总时间（以秒为单位）。<code>FGCT</code> 的值为 <code>0.000</code>，表示 Full GC 消耗的总时间为 0 秒。</li><li><strong>GCT</strong> (Total GC Time): GC 总时间（以秒为单位），包括所有 Minor GC 和 Full GC 的时间。<code>GCT</code> 的值为 <code>0.000</code>，表示 GC 总时间为 0 秒。</li><li><strong>LGCC</strong> (Last GC Cause): 最近一次 GC 发生的原因。<code>LGCC</code> 的值为 <code>Allocation Failure</code>，表示最近一次 GC 是由于内存分配失败（即 Eden 空间不足以容纳新对象）而触发的。</li><li><strong>GCC</strong> (Current GC Cause): 当前 GC 发生的原因。如果当前正在进行 GC，该值会显示触发 GC 的原因。<code>GCC</code> 的值为 <code>No GC</code>，表示当前没有 GC 正在进行。</li></ol><h2 id="2-interval参数"><a href="#2-interval参数" class="headerlink" title="2. interval参数"></a>2. interval参数</h2><p>用于指定输出统计数据的周期，单位为毫秒。即：查询间隔</p><h2 id="3-count参数"><a href="#3-count参数" class="headerlink" title="3. count参数"></a>3. count参数</h2><p> 用于指定查询的总次数</p><h2 id="4-t参数"><a href="#4-t参数" class="headerlink" title="4. -t参数"></a>4. -t参数</h2><p>可以在输出信息前加上一个Timestamp列，显示程序的运行时间。单位：秒</p><h2 id="5-h参数"><a href="#5-h参数" class="headerlink" title="5. -h参数"></a>5. -h参数</h2><p>可以在周期性数据输出时，输出多少行数据后输出一个表头信息</p><h2 id="补充"><a href="#补充" class="headerlink" title="补充"></a>补充</h2><p>jstat还可以用来判断是否出现内存泄漏。</p><p>第1步：在长时间运行的 Java 程序中，我们可以运行jstat命令连续获取多行性能数据，并取这几行数据中 OU 列（即已占用的老年代内存）的最小值。</p><p>第2步：然后，我们每隔一段较长的时间重复一次上述操作，来获得多组 OU 最小值。如果这些值呈上涨趋势，则说明该 Java 程序的老年代内存已使用量在不断上涨，这意味着无法回收的对象在不断增加，因此很有可能存在内存泄漏。</p><h1 id="四、jinfo：实时查看和修改JVM配置参数"><a href="#四、jinfo：实时查看和修改JVM配置参数" class="headerlink" title="四、jinfo：实时查看和修改JVM配置参数"></a>四、jinfo：实时查看和修改JVM配置参数</h1><p>jinfo(Configuration Info for Java)：查看虚拟机配置参数信息，也可用于调整虚拟机的配置参数。在很多情况下，Java应用程序不会指定所有的Java虚拟机参数。而此时，开发人员可能不知道某一个具体的Java虚拟机参数的默认值。在这种情况下，可能需要通过查找文档获取某个参数的默认值。这个查找过程可能是非常艰难的。但有了jinfo工具，开发人员可以很方便地找到Java虚拟机参数的当前值。</p><p><strong>基本使用语法为：jinfo [options] pid</strong></p><p>说明：java 进程ID必须要加上</p><table><thead><tr><th>选项</th><th>选项说明</th></tr></thead><tbody><tr><td>no option</td><td>输出全部的参数和系统属性</td></tr><tr><td>-flag name</td><td>输出对应名称的参数</td></tr><tr><td>-flag [+-]name</td><td>开启或者关闭对应名称的参数 只有被标记为manageable的参数才可以被动态修改</td></tr><tr><td>-flag name&#x3D;value</td><td>设定对应名称的参数</td></tr><tr><td>-flags</td><td>输出全部的参数</td></tr><tr><td>-sysprops</td><td>输出系统属性</td></tr></tbody></table><p><strong>官方帮助文档:</strong> <a href="https://docs.oracle.com/en/java/javase/11/tools/jinfo.html">https://docs.oracle.com/en/java/javase/11/tools/jinfo.html</a></p><h2 id="1-jinfo-sysprops-pid-输出系统属性"><a href="#1-jinfo-sysprops-pid-输出系统属性" class="headerlink" title="1. jinfo -sysprops pid 输出系统属性"></a>1. jinfo -sysprops pid 输出系统属性</h2><p><strong>jinfo -sysprops 2176</strong></p><p>2176 是通过 jps 指令查询的 java 进程ID, jinfo -sysprops pid 可以查看由 <code>System.getProperties()</code> 取得的参数</p><p><img src="https://raw.githubusercontent.com/GeorgeChan95/blogimg/master/img/2024/08/15/20240815-184047.png" alt="-sysprops"></p><h2 id="2-jinfo-flags-pid-输出全部的参数"><a href="#2-jinfo-flags-pid-输出全部的参数" class="headerlink" title="2. jinfo -flags pid 输出全部的参数"></a>2. jinfo -flags pid 输出全部的参数</h2><p><strong>jinfo -flags 25244</strong></p><p>25244 是通过 jps 指令查询的 java 进程ID, <code>jinfo -flags pid</code> 可以查看当前进程JVM赋了值的参数信息.</p><p><img src="https://raw.githubusercontent.com/GeorgeChan95/blogimg/master/img/2024/08/15/20240815-184848.png" alt="-flags"></p><h2 id="3-jinfo-flag-参数-pid-查看某个java进程的具体参数信息"><a href="#3-jinfo-flag-参数-pid-查看某个java进程的具体参数信息" class="headerlink" title="3. jinfo -flag 参数 pid 查看某个java进程的具体参数信息"></a>3. jinfo -flag 参数 pid 查看某个java进程的具体参数信息</h2><p><strong>jinfo -flag UseG1GC 24340</strong></p><p>其中: <code>UseG1GC</code> 是要查看的具体的参数, 24340 是通过 jps 指令查询的 java 进程ID</p><p><img src="https://raw.githubusercontent.com/GeorgeChan95/blogimg/master/img/2024/08/15/20240815-185233.png" alt="-flag param"></p><h2 id="4-jinfo-flag-name-pid-修改参数信息"><a href="#4-jinfo-flag-name-pid-修改参数信息" class="headerlink" title="4. jinfo -flag [+-]name pid 修改参数信息"></a>4. jinfo -flag [+-]name pid 修改参数信息</h2><p>jinfo不仅可以查看运行时某一个]ava虚拟机参数的实际取值，甚至可以在运行时修改部分参数，并使之立即生效。</p><p>但是，并非所有参数都支持动态修改。参数只有被标记为 <code>manageable</code> 的 flag 可以被实时修改。其实，这个修改能力是极其有限的。</p><h3 id="4-1-查看被标记为manageable的参数"><a href="#4-1-查看被标记为manageable的参数" class="headerlink" title="4.1 查看被标记为manageable的参数"></a>4.1 查看被标记为manageable的参数</h3><pre><code class="highlight shell">root@ubuntu:~# java -XX:+PrintFlagsFinal -version | grep manageable     intx CMSAbortablePrecleanWaitMillis            = 100                                 &#123;manageable&#125;     intx CMSTriggerInterval                        = -1                                  &#123;manageable&#125;     intx CMSWaitDuration                           = 2000                                &#123;manageable&#125;     bool HeapDumpAfterFullGC                       = false                               &#123;manageable&#125;     bool HeapDumpBeforeFullGC                      = false                               &#123;manageable&#125;     bool HeapDumpOnOutOfMemoryError                = false                               &#123;manageable&#125;    ccstr HeapDumpPath                              =                                     &#123;manageable&#125;    uintx MaxHeapFreeRatio                          = 100                                 &#123;manageable&#125;    uintx MinHeapFreeRatio                          = 0                                   &#123;manageable&#125;     bool PrintClassHistogram                       = false                               &#123;manageable&#125;     bool PrintClassHistogramAfterFullGC            = false                               &#123;manageable&#125;     bool PrintClassHistogramBeforeFullGC           = false                               &#123;manageable&#125;     bool PrintConcurrentLocks                      = false                               &#123;manageable&#125;     bool PrintGC                                   = false                               &#123;manageable&#125;     bool PrintGCDateStamps                         = false                               &#123;manageable&#125;     bool PrintGCDetails                            = false                               &#123;manageable&#125;     bool PrintGCID                                 = false                               &#123;manageable&#125;     bool PrintGCTimeStamps                         = false                               &#123;manageable&#125;java version &quot;1.8.0_261&quot;Java(TM) SE Runtime Environment (build 1.8.0_261-b12)Java HotSpot(TM) 64-Bit Server VM (build 25.261-b12, mixed mode)</code></pre><h3 id="4-2-针对boolean类型的修改"><a href="#4-2-针对boolean类型的修改" class="headerlink" title="4.2 针对boolean类型的修改"></a>4.2 针对boolean类型的修改</h3><p>jinfo -flag [+|-]参数名称 进程id</p><p>PID可以通过jps命令查看，如果使用+号，那就可以让该参数起作用，否则使用-号就让该参数不起作用，具体例子如下：</p><p><img src="https://raw.githubusercontent.com/GeorgeChan95/blogimg/master/img/2024/08/15/20240815-192843.png" alt="-flag boolean类型"></p><p><em>PrintGCDetails 参数用于控制垃圾回收 (GC) 详情的输出</em></p><h3 id="4-3-针对非boolean类型的修改"><a href="#4-3-针对非boolean类型的修改" class="headerlink" title="4.3 针对非boolean类型的修改"></a>4.3 针对非boolean类型的修改</h3><p>jinfo -flag 参数名称&#x3D;参数值 进程id</p><p>PID可以通过jps命令查看，如果使用+号，那就可以让该参数起作用，否则使用-号就让该参数不起作用，具体例子如下：</p><p><img src="https://raw.githubusercontent.com/GeorgeChan95/blogimg/master/img/2024/08/15/20240815-193525.png" alt="-flag 非boolean类型"></p><p><em>MaxHeapFreeRatio 定义了堆内存中空闲内存的最大百分比。当堆内存的空闲比例超过此值时，JVM可能会考虑缩小堆的大小。默认值通常为70%，意味着当超过70%的堆空闲时，JVM会尝试减小堆大小。（当-Xmx与-Xms相等时，该配置无效）</em></p><h2 id="5-拓展"><a href="#5-拓展" class="headerlink" title="5. 拓展"></a>5. 拓展</h2><ul><li><p><code>java -XX:+PrintFlagsInitial</code> 查看所有JVM参数启动的初始值</p><p><img src="https://raw.githubusercontent.com/GeorgeChan95/blogimg/master/img/2024/08/15/20240815-195517.png" alt="-XX:+PrintFlagsInitial"></p><p><strong>在编译后的class文件夹下执行</strong></p></li><li><p><code>java -XX:+PrintFlagsFinal</code> 查看所有JVM参数的最终值</p><ul><li>java -XX:+UseSerialGC -XX:+PrintFlagsFinal com.atguigu.jstat.GCTest <ul><li>这个命令会启动 JVM，并使用 Serial GC 进行垃圾回收，同时打印出所有 JVM 参数的最终配置。然后 JVM 会执行 <code>com.atguigu.jstat.GCTest</code> 类中的 <code>main</code> 方法。</li></ul></li></ul><p><img src="https://raw.githubusercontent.com/GeorgeChan95/blogimg/master/img/2024/08/15/20240815-195355.png" alt="-XX:+PrintFlagsFinal"></p><p><strong>在编译后的class文件夹下执行</strong></p></li><li><p>java -XX:+PrintCommandLineFlags 查看那些已经被用户或者JVM设置过的详细的XX参数的名称和值</p><ul><li><p>java -XX:+UseSerialGC -XX:+PrintCommandLineFlags com.atguigu.jstat.GCTest</p><ul><li>这个命令启动 JVM，并使用 Serial 垃圾回收器，同时在启动时打印出所有命令行标志。随后，JVM 会执行 <code>com.atguigu.jstat.GCTest</code> 类中的 <code>main</code> 方法。</li></ul><p><img src="https://raw.githubusercontent.com/GeorgeChan95/blogimg/master/img/2024/08/15/20240815-195141.png" alt="+PrintCommandLineFlags"></p><p><strong>在编译后的class文件夹下执行</strong></p></li></ul></li></ul><h1 id="五、jmap：导出内存映像文件-内存使用情况"><a href="#五、jmap：导出内存映像文件-内存使用情况" class="headerlink" title="五、jmap：导出内存映像文件&amp;内存使用情况"></a>五、jmap：导出内存映像文件&amp;内存使用情况</h1><h2 id="1-简述"><a href="#1-简述" class="headerlink" title="1. 简述"></a>1. 简述</h2><p>jmap（JVM Memory Map）：作用一方面是获取dump文件（堆转储快照文件，二进制文件），它还可以获取目标Java进程的内存相关信息，包括Java堆各区域的使用情况、堆中对象的统计信息、类加载信息等。开发人员可以在控制台中输入命令“ jmap -help ”查阅 jmap 工具的具体使用方式和一些标准选项配置。</p><ul><li><p><strong>官方帮助文档：</strong><a href="https://docs.oracle.com/en/java/javase/11/tools/jmap.html">https://docs.oracle.com/en/java/javase/11/tools/jmap.html</a></p></li><li><p><strong>基本使用语法</strong>：</p><ul><li><p><code>jmap [option] &lt;pid&gt;</code></p></li><li><p><code>jmap [option] &lt;executable &lt;core&gt;</code></p></li><li><p><code>jmap [option] [server_id@] &lt;remote server IP or hostname&gt;</code></p></li></ul></li></ul><h2 id="2-基本语法"><a href="#2-基本语法" class="headerlink" title="2. 基本语法"></a>2. 基本语法</h2><ul><li>-dump<ul><li>生成Java堆转储快照：dump文件</li></ul></li><li>-dump:live<ul><li>生成Java堆转储快照：dump文件, 但只保存堆中的存活对象</li><li>相较于 <code>-dump</code> , 文件体积会小一些</li></ul></li><li>-heap<ul><li>输出整个堆空间的详细信息，包括GC的使用、堆配置信息，以及内存的使用信息等</li></ul></li><li>-histo<ul><li>输出堆中对象的同级信息，包括类、实例数量和合计容量</li><li>特别的：-histo:live 只统计堆中的存活对象</li></ul></li><li>-histo:live<ul><li>输出堆中对象的同级信息，包括类、实例数量和合计容量, 但是只统计堆中的存活对象</li></ul></li><li>-permstat<ul><li>以ClassLoader 为统计口径输出永久代的内存状态信息</li><li>仅 linux&#x2F;solaris 平台有效</li></ul></li><li>-finalizerinfo<ul><li>显示在 F-Queue 中等待 Finalizer 线程执行 finalize 方法的对象</li><li>仅linux&#x2F;solaris平台有效</li></ul></li><li>-F<ul><li>当虚拟机进程对-dump选项没有任何响应时，可使用此选项强制执行生成dump文件</li><li>仅linux&#x2F;solaris平台有效</li></ul></li><li>-h | -help<ul><li>jamp工具使用的帮助命令</li></ul></li><li>-J <flag><ul><li>传递参数给 jmap 启动的 jvm</li></ul></li></ul><h2 id="3-导出内存映像文件"><a href="#3-导出内存映像文件" class="headerlink" title="3. 导出内存映像文件"></a>3. 导出内存映像文件</h2><h3 id="3-1-手动导出"><a href="#3-1-手动导出" class="headerlink" title="3.1 手动导出"></a>3.1 手动导出</h3><p><code>jmap -dump:format=b,file=&lt;filename.hprof&gt; &lt;pid&gt;</code></p><p><strong>说明:</strong></p><ul><li><code>&lt;filename.hprof&gt;</code> 中的filename是文件名称，而 <code>.hprof</code> 是后缀名，&lt;***&gt;代表该值可以省略&lt;&gt;，当然后面的 <pid> 是进程id，需要通过jps查询出来</li><li><code>format=b</code> 表示生成的是标准的dump文件，用来进行格式限定</li></ul><p><strong>具体例子如下：</strong></p><ul><li><p>生成堆中所有对象的快照：</p><p><strong>jmap -dump:format&#x3D;b,file&#x3D;d:\1.hprof 22096</strong></p></li></ul><p><img src="https://raw.githubusercontent.com/GeorgeChan95/blogimg/master/img/2024/08/16/20240816-082026.png" alt="-dump"></p><ul><li><p>生成堆中存活对象的快照：</p><p>jmap -dump:live,format&#x3D;b,file&#x3D;d:\2.hprof 22012</p><p><img src="https://raw.githubusercontent.com/GeorgeChan95/blogimg/master/img/2024/08/16/20240816-082159.png" alt="-dump:live"></p></li></ul><p><strong>其中 <code>file=</code> 后面的是生成的dump文件地址，最后的11696 是进程id，可以通过jps查看</strong></p><p><img src="https://raw.githubusercontent.com/GeorgeChan95/blogimg/master/img/2024/08/16/20240816-083214.png" alt="导出的dump文件"></p><p>一般使用的是第二种方式，也就是生成堆中存活对象的快照，毕竟这种方式生成的dump文件更小，我们传输处理都更方便</p><p>由于jmap将访问堆中的所有对象，为了保证在此过程中不被应用线程干扰，jmap需要借助安全点机制，让所有线程停留在不改变堆中数据的状态。也就是说，由jmap导出的堆快照必定是安全点位置的。这可能导致基于该堆快照的分析结果存在偏差。<br>举个例子，假设在编译生成的机器码中，某些对象的生命周期在两个安全点之间，那么:1ive选项将无法探知到这些对象。<br>另外，如果某个线程长时间无法跑到安全点，jmap将一直等下去。与前面讲的jstat则不同垃圾回收器会主动将jstat所需要的摘要数据保存至固定位置之中，而jstat只需直接读取即可。</p><h3 id="3-2-自动导出"><a href="#3-2-自动导出" class="headerlink" title="3.2 自动导出"></a>3.2 自动导出</h3><p>当程序发生OOM退出系统时，一些瞬时信息都随着程序的终止而消失，而重现OOM问题往往比较困难或者耗时。此时若能在OOM时，自动导出dump文件就显得非常迫切。</p><p>这里介绍一种比较常用的取得堆快照文件的方法，即使用:</p><ul><li><code>-XX:+HeapDumpOn0utOfMemoryError</code> : 在程序发生OOM时，导出应用程序的当前堆快照。</li><li><code>-XX:HeapDumpPath</code> : 可以指定堆快照的保存位置。</li></ul><p><strong>例如:</strong></p><pre><code class="highlight plaintext">-Xms100m -Xmx100m -XX:+HeapDumpOnOutOfMemoryError -XX:HeapDumpPath=D:\m.hprof</code></pre><p><img src="https://raw.githubusercontent.com/GeorgeChan95/blogimg/master/img/2024/08/16/20240816-083406.png" alt="VM Options 配置"></p><p><strong>示例代码:</strong></p><pre><code class="highlight java"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">GCTest</span> &#123;    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;        ArrayList&lt;<span class="type">byte</span>[]&gt; list = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; <span class="number">1000</span>; i++) &#123;            <span class="type">byte</span>[] arr = <span class="keyword">new</span> <span class="title class_">byte</span>[<span class="number">1024</span> * <span class="number">100</span>];<span class="comment">//100KB</span>            list.add(arr);            <span class="keyword">try</span> &#123;                Thread.sleep(<span class="number">60</span>);            &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;                e.printStackTrace();            &#125;        &#125;    &#125;&#125;</code></pre><p>运行代码,当程序出现OOM时, 会自动在D盘根目录下生成 m.hprof 文件</p><p><img src="https://raw.githubusercontent.com/GeorgeChan95/blogimg/master/img/2024/08/16/20240816-083748.png" alt="image-20240816083747704"></p><h2 id="4-显示堆内存相关信息"><a href="#4-显示堆内存相关信息" class="headerlink" title="4. 显示堆内存相关信息"></a>4. 显示堆内存相关信息</h2><h3 id="4-1-jmap-heap-进程id"><a href="#4-1-jmap-heap-进程id" class="headerlink" title="4.1 jmap -heap 进程id"></a>4.1 <strong>jmap -heap 进程id</strong></h3><ul><li><p><code>jmap -heap &lt;pid&gt;</code> 只是时间点上的堆信息，而 <code>jstat</code> 后面可以添加参数，可以指定时间动态观察数据改变情况，而图形化界面工具，例如 jvisualvm 等，它们可以用图表的方式动态展示出相关信息，更加直观明了</p><p><img src="https://raw.githubusercontent.com/GeorgeChan95/blogimg/master/img/2024/08/16/20240816-085807.png" alt="jmap -heap"></p></li></ul><p>**参数解析: **</p><ul><li><p>一般信息</p><pre><code class="highlight shell">Attaching to process ID 28420, please wait...Debugger attached successfully.Server compiler detected.JVM version is 25.241-b07</code></pre><ul><li><p><strong>Attaching to process ID 28420</strong>: 表示 <code>jmap</code> 工具正在连接到进程 ID 为 28420 的 JVM 实例。</p></li><li><p><strong>Debugger attached successfully</strong>: 调试器成功附加到 JVM 实例。</p></li><li><p><strong>Server compiler detected</strong>: JVM 使用的是服务器模式的编译器，这通常用于高性能环境。</p></li><li><p><strong>JVM version is 25.241-b07</strong>: 表示 JVM 的版本号是 25.241-b07，这通常是 Java 8 的一个版本。</p></li></ul></li><li><p>GC 信息</p><pre><code class="highlight shell">using thread-local object allocation.Parallel GC with 15 thread(s)</code></pre><ul><li><p><strong>using thread-local object allocation</strong>: JVM 使用线程本地对象分配（TLOA），这是为了提高对象分配的效率。</p></li><li><p><strong>Parallel GC with 15 thread(s)</strong>: JVM 使用的是并行垃圾回收器（Parallel GC），并且使用了 15 个线程来进行垃圾回收。</p></li></ul></li><li><p>堆内存配置 (Heap Configuration)</p><pre><code class="highlight shell">Heap Configuration:   MinHeapFreeRatio         = 0   MaxHeapFreeRatio         = 100   MaxHeapSize              = 104857600 (100.0MB)   NewSize                  = 34603008 (33.0MB)   MaxNewSize               = 34603008 (33.0MB)   OldSize                  = 70254592 (67.0MB)   NewRatio                 = 2   SurvivorRatio            = 8   MetaspaceSize            = 21807104 (20.796875MB)   CompressedClassSpaceSize = 1073741824 (1024.0MB)   MaxMetaspaceSize         = 17592186044415 MB   G1HeapRegionSize         = 0 (0.0MB)</code></pre><ul><li><p><strong>MinHeapFreeRatio &#x3D; 0</strong>: 最小堆内存空闲比例为 0%，表示没有保留的最小空闲空间。</p></li><li><p><strong>MaxHeapFreeRatio &#x3D; 100</strong>: 最大堆内存空闲比例为 100%，表示堆可以完全空闲。</p></li><li><p><strong>MaxHeapSize &#x3D; 104857600 (100.0MB)</strong>: 最大堆大小设置为 100MB。</p></li><li><p><strong>NewSize &#x3D; 34603008 (33.0MB)</strong>: 新生代的初始大小为 33MB。</p></li><li><p><strong>MaxNewSize &#x3D; 34603008 (33.0MB)</strong>: 新生代的最大大小为 33MB。</p></li><li><p><strong>OldSize &#x3D; 70254592 (67.0MB)</strong>: 老年代的初始大小为 67MB。</p></li><li><p><strong>NewRatio &#x3D; 2</strong>: 新生代与老年代的比例为 1:2。</p></li><li><p><strong>SurvivorRatio &#x3D; 8</strong>: Eden 区与 Survivor 区的比例为 8:1。</p></li><li><p><strong>MetaspaceSize &#x3D; 21807104 (20.796875MB)</strong>: 元空间的初始大小为约 20.8MB。</p></li><li><p><strong>CompressedClassSpaceSize &#x3D; 1073741824 (1024.0MB)</strong>: 压缩类空间大小为 1024MB。</p></li><li><p><strong>MaxMetaspaceSize &#x3D; 17592186044415 MB</strong>: 最大元空间大小非常大，几乎没有限制。</p></li><li><p><strong>G1HeapRegionSize &#x3D; 0 (0.0MB)</strong>: G1 GC 堆区域大小为 0，表示未使用 G1 垃圾回收器。</p></li></ul></li><li><p>堆内存使用情况 (Heap Usage)</p><pre><code class="highlight shell">Heap Usage:PS Young GenerationEden Space:   capacity = 26214400 (25.0MB)   used     = 23077464 (22.008384704589844MB)   free     = 3136936 (2.9916152954101562MB)   88.03353881835938% usedFrom Space:   capacity = 4194304 (4.0MB)   used     = 0 (0.0MB)   free     = 4194304 (4.0MB)   0.0% usedTo Space:   capacity = 4194304 (4.0MB)   used     = 0 (0.0MB)   free     = 4194304 (4.0MB)   0.0% usedPS Old Generation   capacity = 70254592 (67.0MB)   used     = 0 (0.0MB)   free     = 70254592 (67.0MB)   0.0% used</code></pre><p><strong>PS Young Generation</strong>: 年轻代（Parallel Scavenge GC）信息。</p><ul><li>Eden Space<ul><li><strong>capacity &#x3D; 26214400 (25.0MB)</strong>: Eden 区的总容量为 25MB。</li><li><strong>used &#x3D; 23077464 (22.008384704589844MB)</strong>: 已使用 22MB。</li><li><strong>free &#x3D; 3136936 (2.9916152954101562MB)</strong>: 空闲 3MB。</li><li><strong>88.03353881835938% used</strong>: 使用率为 88%。</li></ul></li><li>From Space<ul><li><strong>capacity &#x3D; 4194304 (4.0MB)</strong>: From Survivor 区的总容量为 4MB。</li><li><strong>used &#x3D; 0 (0.0MB)</strong>: 未使用。</li><li><strong>free &#x3D; 4194304 (4.0MB)</strong>: 完全空闲。</li><li><strong>0.0% used</strong>: 使用率为 0%。</li></ul></li><li>To Space<ul><li><strong>capacity &#x3D; 4194304 (4.0MB)</strong>: To Survivor 区的总容量为 4MB。</li><li><strong>used &#x3D; 0 (0.0MB)</strong>: 未使用。</li><li><strong>free &#x3D; 4194304 (4.0MB)</strong>: 完全空闲。</li><li><strong>0.0% used</strong>: 使用率为 0%。</li></ul></li></ul><p><strong>PS Old Generation</strong>: 老年代信息。</p><ul><li><p><strong>capacity &#x3D; 70254592 (67.0MB)</strong>: 老年代的总容量为 67MB。</p></li><li><p><strong>used &#x3D; 0 (0.0MB)</strong>: 未使用。</p></li><li><p><strong>free &#x3D; 70254592 (67.0MB)</strong>: 完全空闲。</p></li><li><p><strong>0.0% used</strong>: 使用率为 0%。</p></li></ul></li><li><p>字符串池的使用情况</p><pre><code class="highlight shell">2164 interned Strings occupying 200768 bytes.</code></pre><ul><li><p><strong>2164 interned Strings</strong>: 字符串池中有 2164 个字符串。</p></li><li><p><strong>occupying 200768 bytes</strong>: 这些字符串占用了约 200768 字节（约 196 KB）的内存。</p></li></ul></li></ul><h3 id="4-2-jmap-histo-进程id"><a href="#4-2-jmap-histo-进程id" class="headerlink" title="4.2 jmap -histo 进程id"></a>4.2 jmap -histo 进程id</h3><p>输出堆中对象的同级信息，包括类、实例数量和合计容量，也是这一时刻的内存中的对象信息</p><p><img src="https://raw.githubusercontent.com/GeorgeChan95/blogimg/master/img/2024/08/16/20240816-091150.png" alt="jmap -histo"></p><h2 id="5-其它作用"><a href="#5-其它作用" class="headerlink" title="5. 其它作用"></a>5. 其它作用</h2><ul><li><code>jmap -permstat 进程id</code> : 查看系统的ClassLoader信息</li><li><code>jmap -finalizerinfo</code> : 查看堆积在finalizer队列中的对象</li></ul><p>这两个指令仅linux&#x2F;solaris平台有效，所以无法在windows操作平台上使用</p><h2 id="6-总结"><a href="#6-总结" class="headerlink" title="6. 总结"></a>6. 总结</h2><ul><li>由于jmap将访问堆中的所有对象，为了保证在此过程中不被应用线程干扰，jmap需要借助安全点机制，让所有线程停留在不改变堆中数据的状态。也就是说，由jmap导出的堆快照必定是安全点位置的。这可能导致基于该堆快照的分析结果存在偏差。</li><li>举个例子，假设在编译生成的机器码中，某些对象的生命周期在两个安全点之间，那么 <code>:live</code> 选项将无法探知到这些对象。</li><li>另外，如果某个线程长时间无法跑到安全点，jmap将一直等下去。与前面讲的jstat则不同, 垃圾回收器会主动将jstat所需要的摘要数据保存至固定位置之中，而jstat只需直接读取即可。</li></ul><h1 id="六、jhat：JDK自带堆分析工具"><a href="#六、jhat：JDK自带堆分析工具" class="headerlink" title="六、jhat：JDK自带堆分析工具"></a>六、jhat：JDK自带堆分析工具</h1><p>jhat 命令在 jdk9 及其之后就被移除了，官方建议使用 Jvisualvm 代替jhat，所以该指令只需简单了解一下即可</p><p><code>jhat</code> (JVM Heap Analysis Tool):</p><ul><li>Sun ]DK 提供的 jhat 命令与 jmap 命令搭配使用，用于分析 jmap 生成的 heap dump文件(堆转储快照) 。jhat 内置了一个微型的 HTTP&#x2F;HTML 服务器， 生成 dump 文件的分析结果后， 用户可以在浏览器中查看分析结果(分析虚拟机转储快照信息)。</li><li>使用了 jhat 命令，就启动了一个http服务，端口是 7008，即 <a href="http://1ocalhost:7800/%EF%BC%8C%E5%B0%B1%E5%8F%AF%E4%BB%A5%E5%9C%A8%E6%B5%8F%E8%A7%88%E5%99%A8%E9%87%8C%E5%88%86%E6%9E%90%E3%80%82">http://1ocalhost:7800/，就可以在浏览器里分析。</a></li><li>说明: jhat 命令在JDK9、JDK18中已经被删除，官方建议用 <code>VisualVM</code> 代替</li></ul><h2 id="1-基本语法"><a href="#1-基本语法" class="headerlink" title="1. 基本语法"></a>1. 基本语法</h2><p><code>jhat [option] [dumpfile]</code></p><p>其中dumpfile代表dump文件的地址以及名称，例如：</p><p><img src="https://raw.githubusercontent.com/GeorgeChan95/blogimg/master/img/2024/08/16/20240816-140048.png" alt="jhat"></p><p><img src="https://raw.githubusercontent.com/GeorgeChan95/blogimg/master/img/2024/08/16/20240816-140120.png" alt="jhat web"></p><h2 id="2-options参数"><a href="#2-options参数" class="headerlink" title="2. options参数"></a>2. options参数</h2><ul><li>-stack false l true<ul><li>关闭|打开对象分配调用栈跟踪</li></ul></li><li>-refs false l true<ul><li>关闭|打开对象引用跟踪</li></ul></li><li>-port port-number <ul><li>设置 jhat HTTP Server的端口号，默认7000</li></ul></li><li>-exclude exclude-file<ul><li>执行对象查询时需要排除的数据成员</li></ul></li><li>-baseline exclude-file<ul><li>指定一个基准堆转储</li></ul></li><li>-debug int<ul><li>设置debug级别</li></ul></li><li>-version<ul><li>启动后显示版本信息就退出</li></ul></li><li>-J <flag><ul><li>传入启动参数，比如小 -J -Xmx512m</li></ul></li></ul><p><strong>示例:</strong></p><pre><code class="highlight sh">jhat -stack <span class="literal">false</span> d:\1.hprofjhat -port 6565 d:\1.hprofjhat -version</code></pre><h1 id="七、jstack：打印JVM中线程快照"><a href="#七、jstack：打印JVM中线程快照" class="headerlink" title="七、jstack：打印JVM中线程快照"></a>七、jstack：打印JVM中线程快照</h1><h2 id="1-基本情况"><a href="#1-基本情况" class="headerlink" title="1. 基本情况"></a>1. 基本情况</h2><p><strong>jstack (JVM stack Trace)</strong> : 用于生成虚拟机指定进程当前时刻的线程快照(虚拟机堆栈跟踪)。 线程快照就是当前虚拟机内指定进程的每一条线程正在执行的方法堆栈的集合。</p><p><strong>生成线程快照的作用</strong> : 可用于定位线程出现长时间停顿的原因，如线程间死锁、死循环、请求外部资源导致的长时间等待等问题。这些都是导致线程长时间停顿的常见原因。当线程出现停顿时，就可以用 jstack 显示各个线程调用的堆情况。</p><p><strong>官方帮助文档:</strong><br><a href="https://docs.oracle.com/en/java/javase/11/tools/jstack.html">https://docs.oracle.com/en/java/javase/11/tools/jstack.html</a></p><p>在 <strong>thread dump</strong> 中，要留意下面几种状态</p><ul><li>死锁，Deadlock(重点关注)</li><li>等待资源，Waiting on condition(重点关注)</li><li>等待获取监视器，Waiting on monitor entry(重点关注)</li><li>阻塞，Blocked(重点关注)</li><li>执行中，Runnable</li><li>暂停，Suspended</li><li>对象等待中，Object.wait() 或 TIMED WAITING</li><li>停止，Parked</li></ul><h2 id="2-基本语法-1"><a href="#2-基本语法-1" class="headerlink" title="2. 基本语法"></a>2. 基本语法</h2><p><img src="https://raw.githubusercontent.com/GeorgeChan95/blogimg/master/img/2024/08/16/20240816-142006.png" alt="jstack"></p><p><strong>它的基本使用语法为:</strong> <code>jstack option pid</code></p><p><strong>option 参数</strong></p><ul><li><p>-F</p><p>当正常输出的请求不被响应时，强制输出线程堆栈</p></li><li><p>-l</p><p>除堆栈外，显示关于锁的附加信息</p></li><li><p>-m</p><p>如果调用本地方法的话，可以显示C&#x2F;C++的堆栈</p></li><li><p>-h</p><p>帮助操作</p></li></ul><p><strong>使用示例: 测试jstack排查死锁</strong></p><ul><li><p>测试代码</p><pre><code class="highlight java"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ThreadDeadLock</span> &#123;    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;        <span class="type">StringBuilder</span> <span class="variable">s1</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">StringBuilder</span>();        <span class="type">StringBuilder</span> <span class="variable">s2</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">StringBuilder</span>();        <span class="keyword">new</span> <span class="title class_">Thread</span>()&#123;            <span class="meta">@Override</span>            <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span> &#123;                <span class="keyword">synchronized</span> (s1)&#123;                    s1.append(<span class="string">&quot;a&quot;</span>);                    s2.append(<span class="string">&quot;1&quot;</span>);                    <span class="keyword">try</span> &#123;                        Thread.sleep(<span class="number">100</span>);                    &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;                        e.printStackTrace();                    &#125;                    <span class="keyword">synchronized</span> (s2)&#123;                        s1.append(<span class="string">&quot;b&quot;</span>);                        s2.append(<span class="string">&quot;2&quot;</span>);                        System.out.println(s1);                        System.out.println(s2);                    &#125;                &#125;            &#125;        &#125;.start();        <span class="keyword">new</span> <span class="title class_">Thread</span>(<span class="keyword">new</span> <span class="title class_">Runnable</span>() &#123;            <span class="meta">@Override</span>            <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span> &#123;                <span class="keyword">synchronized</span> (s2)&#123;                    s1.append(<span class="string">&quot;c&quot;</span>);                    s2.append(<span class="string">&quot;3&quot;</span>);                    <span class="keyword">try</span> &#123;                        Thread.sleep(<span class="number">100</span>);                    &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;                        e.printStackTrace();                    &#125;                    <span class="keyword">synchronized</span> (s1)&#123;                        s1.append(<span class="string">&quot;d&quot;</span>);                        s2.append(<span class="string">&quot;4&quot;</span>);                        System.out.println(s1);                        System.out.println(s2);                    &#125;                &#125;            &#125;        &#125;).start();        <span class="keyword">try</span> &#123;            Thread.sleep(<span class="number">1000</span>);        &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;            e.printStackTrace();        &#125;        <span class="keyword">new</span> <span class="title class_">Thread</span>(<span class="keyword">new</span> <span class="title class_">Runnable</span>() &#123;            <span class="meta">@Override</span>            <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span> &#123;                Map&lt;Thread, StackTraceElement[]&gt; all = Thread.getAllStackTraces();<span class="comment">//追踪当前进程中的所有的线程</span>                Set&lt;Map.Entry&lt;Thread, StackTraceElement[]&gt;&gt; entries = all.entrySet();                <span class="keyword">for</span>(Map.Entry&lt;Thread, StackTraceElement[]&gt; en : entries)&#123;                    <span class="type">Thread</span> <span class="variable">t</span> <span class="operator">=</span> en.getKey();                    StackTraceElement[] v = en.getValue();                    System.out.println(<span class="string">&quot;【Thread name is :&quot;</span> + t.getName() + <span class="string">&quot;】&quot;</span>);                    <span class="keyword">for</span>(StackTraceElement s : v)&#123;                        System.out.println(<span class="string">&quot;\t&quot;</span> + s.toString());                    &#125;                &#125;            &#125;        &#125;).start();    &#125;&#125;</code></pre></li><li><p>启动程序</p></li><li><p>使用 jstack 打印线程信息</p><p><code>jstack -l 19076</code> : 其中 19076 是程序的进程ID</p><p><img src="https://raw.githubusercontent.com/GeorgeChan95/blogimg/master/img/2024/08/16/20240816-144116.png" alt="jstack 排查死锁问题"></p></li></ul><h1 id="八、jcmd：多功能命令行"><a href="#八、jcmd：多功能命令行" class="headerlink" title="八、jcmd：多功能命令行"></a>八、jcmd：多功能命令行</h1><p>在 JDK 1.7 以后，新增了一个命令行工具jcmd。</p><p>它是一个多功能的工具，可以用来实现前面除了 jstat 之外所有命令的功能。比如:用它来导出堆、内存使用、查看Java进程、导出线程信息、执行GC、JVM运行时间等</p><p><strong>官方帮助文档:</strong> <a href="https://docs.oracle.com/en/java/javase/11/tools/jcmd.html">https://docs.oracle.com/en/java/javase/11/tools/jcmd.html</a></p><p>jcmd 拥有 jmap 的大部分功能，并且在Oracle的官方网站上也推荐使用 jcmd 命令代 jmap 命令</p><h2 id="1-基本语法-1"><a href="#1-基本语法-1" class="headerlink" title="1. 基本语法"></a>1. 基本语法</h2><ul><li><p>jcmd -l </p><p>列出所有的JVM进程</p></li><li><p>jcmd 进程号 help</p><p>针对指定的进程，列出支持的所有具体命令</p><p><img src="https://raw.githubusercontent.com/GeorgeChan95/blogimg/master/img/2024/08/16/20240816-150959.png" alt="jcmd help"></p><p>根据以上命令来替换之前的那些操作：</p><ul><li>Thread.print 可以替换 jstack 指令</li><li>GC.class_histogram 可以替换 jmap中的 -histo 操作</li><li>GC.heap_dump 可以替换 jmap中的 -dump 操作</li><li>GC.run 可以查看GC的执行情况</li><li>VM.uptime 可以查看程序的总执行时间，可以替换jstat指令中的 -t 操作</li><li>VM.system_properties 可以替换 jinfo -sysprops 进程id</li><li>VM.flags 可以获取JVM的配置参数信息</li></ul></li><li><p>jcmd 进程号 具体命令</p><p>显示指定进程的指令命令的数据</p><p><img src="https://raw.githubusercontent.com/GeorgeChan95/blogimg/master/img/2024/08/16/20240816-151415.png" alt="jcmd 打印线程信息"></p></li></ul><h1 id="九、jstatd：远程主机信息收集"><a href="#九、jstatd：远程主机信息收集" class="headerlink" title="九、jstatd：远程主机信息收集"></a>九、jstatd：远程主机信息收集</h1><p>之前的指令只涉及到监控本机的Java应用程序，而在这些工具中，一些监控工具也支持对远程计算机的监控(如 <code>jps</code>、<code>jstat</code> )。为了启用远程监控，则需要配合使用 <code>jstatd</code> 工具。<br>命令 jstatd 是一个RMI服务端程序，它的作用相当于代理服务器，建立本地计算机与远程监控工具的通信。jstatd 服务器将本机的Java应用程序信息传递到远程计算机。</p><p><img src="https://raw.githubusercontent.com/GeorgeChan95/blogimg/master/img/2024/08/16/20240816-164755.png" alt="jstatd的理解"></p>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;一、概述&quot;&gt;&lt;a href=&quot;#一、概述&quot; class=&quot;headerlink&quot; title=&quot;一、概述&quot;&gt;&lt;/a&gt;一、概述&lt;/h1&gt;&lt;p&gt;性能诊断是软件工程师在日常工作中需要经常面对和解决的问题，在用户体验至上的今天，解决好应用的性能问题能带来非常大的收益。&lt;/</summary>
      
    
    
    
    <category term="JVM" scheme="https://georgechan95.github.io/categories/JVM/"/>
    
    
    <category term="jvm" scheme="https://georgechan95.github.io/tags/jvm/"/>
    
    <category term="java" scheme="https://georgechan95.github.io/tags/java/"/>
    
  </entry>
  
  <entry>
    <title>第二十一章-性能监控与调优概述</title>
    <link href="https://georgechan95.github.io/2024/08/12/jvm/%E7%AC%AC%E4%BA%8C%E5%8D%81%E4%B8%80%E7%AB%A0-%E6%80%A7%E8%83%BD%E7%9B%91%E6%8E%A7%E4%B8%8E%E8%B0%83%E4%BC%98%E6%A6%82%E8%BF%B0/"/>
    <id>https://georgechan95.github.io/2024/08/12/jvm/%E7%AC%AC%E4%BA%8C%E5%8D%81%E4%B8%80%E7%AB%A0-%E6%80%A7%E8%83%BD%E7%9B%91%E6%8E%A7%E4%B8%8E%E8%B0%83%E4%BC%98%E6%A6%82%E8%BF%B0/</id>
    <published>2024-08-12T11:13:06.000Z</published>
    <updated>2024-08-12T11:33:13.887Z</updated>
    
    <content type="html"><![CDATA[<h1 id="一、背景说明"><a href="#一、背景说明" class="headerlink" title="一、背景说明"></a>一、背景说明</h1><h2 id="1-生产环境中的问题"><a href="#1-生产环境中的问题" class="headerlink" title="1. 生产环境中的问题"></a>1. 生产环境中的问题</h2><ul><li><p>生产环境发生了内存溢出该如何处理？</p></li><li><p>生产环境应该给服务器分配多少内存合适？</p></li><li><p>如何对垃圾回收器的性能进行调优？</p></li><li><p>生产环境CPU负载飙高该如何处理？</p></li><li><p>生产环境应该给应用分配多少线程合适？</p></li><li><p>不加log，如何确定请求是否执行了某一行代码？</p></li><li><p>不加log，如何实时查看某个方法的入参与返回值？</p></li></ul><h2 id="2-为什么要调优"><a href="#2-为什么要调优" class="headerlink" title="2. 为什么要调优"></a>2. 为什么要调优</h2><ul><li><p>防止出现OOM</p></li><li><p>解决OOM</p></li><li><p>减少Full GC出现的频率</p></li></ul><h2 id="3-不同阶段的考虑"><a href="#3-不同阶段的考虑" class="headerlink" title="3. 不同阶段的考虑"></a>3. 不同阶段的考虑</h2><ul><li><p>上线前</p></li><li><p>项目运行阶段</p></li><li><p>线上出现OOM</p></li></ul><h1 id="二、调优概述"><a href="#二、调优概述" class="headerlink" title="二、调优概述"></a>二、调优概述</h1><h2 id="1-监控的依据"><a href="#1-监控的依据" class="headerlink" title="1. 监控的依据"></a>1. 监控的依据</h2><ul><li><p>运行日志</p></li><li><p>异常堆栈</p></li><li><p>GC日志</p></li><li><p>线程快照</p></li><li><p>堆转储快照</p></li></ul><h2 id="2-调优的大方向"><a href="#2-调优的大方向" class="headerlink" title="2. 调优的大方向"></a>2. 调优的大方向</h2><ul><li><p>合理地编写代码</p></li><li><p>充分并合理的使用硬件资源</p></li><li><p>合理地进行JVM调优</p></li></ul><h1 id="三、性能优化的步骤"><a href="#三、性能优化的步骤" class="headerlink" title="三、性能优化的步骤"></a>三、性能优化的步骤</h1><h2 id="第1步：性能监控"><a href="#第1步：性能监控" class="headerlink" title="第1步：性能监控"></a>第1步：性能监控</h2><ul><li><p>GC频繁</p></li><li><p>cpu load过高</p></li><li><p>OOM</p></li><li><p>内存泄露</p></li><li><p>死锁</p></li><li><p>程序响应时间较长</p></li></ul><h2 id="第2步：性能分析"><a href="#第2步：性能分析" class="headerlink" title="第2步：性能分析"></a>第2步：性能分析</h2><ul><li><p>打印GC日志，通过 GCviewer 或者 <a href="http://gceasy.io/">http://gceasy.io</a> 来分析异常信息</p></li><li><p>灵活运用命令行工具、jstack、jmap、jinfo等</p></li><li><p>dump出堆文件，使用内存分析工具分析文件</p></li><li><p>使用阿里Arthas、jconsole、JVisualVM来实时查看JVM状态</p></li><li><p>jstack查看堆栈信息</p></li></ul><h2 id="第3步：性能调优"><a href="#第3步：性能调优" class="headerlink" title="第3步：性能调优"></a>第3步：性能调优</h2><ul><li><p>适当增加内存，根据业务背景选择垃圾回收器</p></li><li><p>优化代码，控制内存使用</p></li><li><p>增加机器，分散节点压力</p></li><li><p>合理设置线程池线程数量</p></li><li><p>使用中间件提高程序效率，比如缓存、消息队列等</p></li><li><p>其他……</p></li></ul><h1 id="四、性能评价-测试指标"><a href="#四、性能评价-测试指标" class="headerlink" title="四、性能评价&#x2F;测试指标"></a>四、性能评价&#x2F;测试指标</h1><h2 id="1-停顿时间（或响应时间）"><a href="#1-停顿时间（或响应时间）" class="headerlink" title="1. 停顿时间（或响应时间）"></a>1. 停顿时间（或响应时间）</h2><p>提交请求和返回该请求的响应之间使用的时间，一般比较关注平均响应时间。常用操作的响应时间列表：</p><table><thead><tr><th>操作</th><th>响应时间</th></tr></thead><tbody><tr><td>打开一个站点</td><td>几秒</td></tr><tr><td>数据库查询一条记录（有索引）</td><td>十几毫秒</td></tr><tr><td>机械磁盘一次寻址定位</td><td>4毫秒</td></tr><tr><td>从机械磁盘顺序读取1M数据</td><td>2毫秒</td></tr><tr><td>从SSD磁盘顺序读取1M数据</td><td>0.3毫秒</td></tr><tr><td>从远程分布式换成Redis 读取一个数据</td><td>0.5毫秒</td></tr><tr><td>从内存读取 1M数据</td><td>十几微妙</td></tr><tr><td>Java程序本地方法调用</td><td>几微妙</td></tr><tr><td>网络传输2Kb数据</td><td>1 微妙</td></tr></tbody></table><p>在垃圾回收环节中：</p><ul><li><p>暂停时间：执行垃圾收集时，程序的工作线程被暂停的时间。</p></li><li><p>-XX:MaxGCPauseMillis (设置最大暂停时间)</p></li></ul><h2 id="2-吞吐量"><a href="#2-吞吐量" class="headerlink" title="2. 吞吐量"></a>2. 吞吐量</h2><ul><li><p>对单位时间内完成的工作量（请求）的量度</p></li><li><p>在GC中：运行用户代码的事件占总运行时间的比例（总运行时间：程序的运行时间+内存回收的时间）</p></li><li><p>吞吐量为1-1&#x2F;(1+n)，其中-XX::GCTimeRatio&#x3D;n</p><ul><li>parallel scavenge 收集器参数, 即: 垃圾收集时间占总时间的比率, 默认值: 99</li></ul></li></ul><h2 id="3-并发数"><a href="#3-并发数" class="headerlink" title="3. 并发数"></a>3. 并发数</h2><ul><li>同一时刻，对服务器有实际交互的请求数<ul><li>1000个人同时在线，估计并发数在5%-15%之间，也就是同时并发量：50-150之间。</li></ul></li></ul><h2 id="4-内存占用"><a href="#4-内存占用" class="headerlink" title="4. 内存占用"></a>4. 内存占用</h2><ul><li>Java堆区所占的内存大小</li></ul>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;一、背景说明&quot;&gt;&lt;a href=&quot;#一、背景说明&quot; class=&quot;headerlink&quot; title=&quot;一、背景说明&quot;&gt;&lt;/a&gt;一、背景说明&lt;/h1&gt;&lt;h2 id=&quot;1-生产环境中的问题&quot;&gt;&lt;a href=&quot;#1-生产环境中的问题&quot; class=&quot;headerli</summary>
      
    
    
    
    <category term="JVM" scheme="https://georgechan95.github.io/categories/JVM/"/>
    
    
    <category term="jvm" scheme="https://georgechan95.github.io/tags/jvm/"/>
    
    <category term="java" scheme="https://georgechan95.github.io/tags/java/"/>
    
  </entry>
  
  <entry>
    <title>第二十章-再谈类的加载器</title>
    <link href="https://georgechan95.github.io/2024/08/10/jvm/%E7%AC%AC%E4%BA%8C%E5%8D%81%E7%AB%A0-%E5%86%8D%E8%B0%88%E7%B1%BB%E7%9A%84%E5%8A%A0%E8%BD%BD%E5%99%A8/"/>
    <id>https://georgechan95.github.io/2024/08/10/jvm/%E7%AC%AC%E4%BA%8C%E5%8D%81%E7%AB%A0-%E5%86%8D%E8%B0%88%E7%B1%BB%E7%9A%84%E5%8A%A0%E8%BD%BD%E5%99%A8/</id>
    <published>2024-08-10T05:43:10.000Z</published>
    <updated>2024-08-10T10:00:50.532Z</updated>
    
    <content type="html"><![CDATA[<p><strong>以下内容关于类加载器都是基于 JDK8 讲解的, JDK9的类加载器与之不同</strong></p><h1 id="一、概述"><a href="#一、概述" class="headerlink" title="一、概述"></a>一、概述</h1><p>类加载器是JVM执行类加载机制的前提。</p><p><strong>ClassLoader的作用：</strong></p><p>ClassLoader是Java的核心组件，所有的Class都是由ClassLoader进行加载的，ClassLoader负责通过各种方式将Class信息的二进制数据流读入JVM内部，转换为一个与目标类对应的java.lang.Class对象实例。然后交给Java虚拟机进行链接、初始化等操作。因此，ClassLoader在整个装载阶段，只能影响到类的加载，而无法通过ClassLoader去改变类的链接和初始化行为。至于它是否可以运行，则由Execution Engine决定。</p><p><img src="https://raw.githubusercontent.com/GeorgeChan95/blogimg/master/img/2024/08/10/20240810-135915.png" alt="类的加载"></p><p>类加载器最早出现在Java1.8版本中，那个时候只是单纯地为了满足Java Applet应用而被研发出来。但如今类加载器却在OSGi、字节码加解密领域大放异彩。这主要归功于]ava虚拟机的设计者们当初在设计类加载器的时候，并没有考虑将它绑定在JVM内部，这样做的好处就是能够更加灵活和动态地执行类加载操作。</p><h2 id="1-类加载器的分类"><a href="#1-类加载器的分类" class="headerlink" title="1. 类加载器的分类"></a>1. 类加载器的分类</h2><p><strong>类的加载分类：显式加载 vs 隐式加载</strong></p><p>class文件的显式加载与隐式加载的方式是指JVM加载class文件到内存的方式。</p><ul><li>显式加载指的是在代码中通过调用ClassLoader加载class对象，如直接使用 <code>Class.forName(name)</code> 或 <code>this.getClass().getClassLoader().loadClass()</code> 加载class对象。</li><li>隐式加载则是不直接在代码中调用ClassLoader的方法加载class对象，而是通过虚拟机自动加载到内存中，如在加载某个类的class文件时，该类的class文件中引用了另外一个类的对象，此时额外引用的类将通过JVM自动加载到内存中。</li></ul><p>在日常开发以上两种方式一般会混合使用。</p><pre><code class="highlight java"><span class="comment">//隐式加载</span>User user=<span class="keyword">new</span> <span class="title class_">User</span>();<span class="comment">//显式加载，并初始化</span>Class clazz=Class.forName(<span class="string">&quot;com.test.java.User&quot;</span>);<span class="comment">//显式加载，但不初始化</span>ClassLoader.getSystemClassLoader().loadClass(<span class="string">&quot;com.test.java.Parent&quot;</span>);</code></pre><h2 id="2-类加载器的必要性"><a href="#2-类加载器的必要性" class="headerlink" title="2. 类加载器的必要性"></a>2. 类加载器的必要性</h2><p>一般情况下，Java开发人员并不需要在程序中显式地使用类加载器，但是了解类加载器的加载机制却显得至关重要。从以下几个方面说：</p><ul><li><p>避免在开发中遇到 <code>java.lang.ClassNotFoundException</code> 异常或 <code>java.lang.NoClassDefFoundError</code> 异常时，手足无措。只有了解类加载器的 加载机制才能够在出现异常的时候快速地根据错误异常日志定位问题和解决问题</p></li><li><p>需要支持类的动态加载或需要对编译后的字节码文件进行加解密操作时，就需要与类加载器打交道了。</p></li><li><p>开发人员可以在程序中编写自定义类加载器来重新定义类的加载规则，以便实现一些自定义的处理逻辑。</p></li></ul><h2 id="3-命名空间"><a href="#3-命名空间" class="headerlink" title="3. 命名空间"></a>3. 命名空间</h2><p><strong>何为类的唯一性？</strong></p><p>对于任意一个类，都需要由加载它的类加载器和这个类本身一同确认其在Java虚拟机中的唯一性。每一个类加载器，都拥有一个独立的类名称空间：比较两个类是否相等，只有在这两个类是由同一个类加载器加载的前提下才有意义。否则，即使这两个类源自同一个Class文件，被同一个虚拟机加载，只要加载他们的类加载器不同，那这两个类就必定不相等。</p><p><strong>命名空间</strong></p><ul><li><p>每个类加载器都有自己的命名空间，命名空间由该加载器及所有的父加载器所加载的类组成 </p></li><li><p>在同一命名空间中，不会出现类的完整名字（包括类的包名）相同的两个类 </p></li><li><p>在不同的命名空间中，有可能会出现类的完整名字（包括类的包名）相同的两个类</p></li></ul><p>在大型应用中，我们往往借助这一特性，来运行同一个类的不同版本。</p><h2 id="4-类加载机制的基本特征"><a href="#4-类加载机制的基本特征" class="headerlink" title="4. 类加载机制的基本特征"></a>4. 类加载机制的基本特征</h2><p>通常类的加载机制有三个基本特征</p><ul><li>双亲委派模型。但不是所有类加载都遵守这个模型，有的时候，启动类加载器所加载的类型，是可能要加载用户代码的，比如JDK内部的<code>ServiceProvider/ServiceLoader</code> 机制，用户可以在标准API框架上，提供自己的实现，JDK也需要提供些默认的参考实现。例如，Java中JNDI、JDBC、文件系统、Cipher等很多方面，都是利用的这种机制，这种情况就不会用双亲委派模型去加载，而是利用所谓的上下文加载器。</li><li>可见性。子类加载器可以访问父加载器加载的类型，但是反过来是不允许的。不然，因为缺少必要的隔离，我们就没有办法利用类加载器去实现容器的逻辑。</li><li>单一性。由于父加载器的类型对于子加载器是可见的，所以父加载器中加载过的类型，就不会在子加载器中重复加载。但是注意，类加载器“邻居”间，同一类型仍然可以被加载多次，因为互相并不可见。</li></ul><h2 id="5-类加载器之间的关系"><a href="#5-类加载器之间的关系" class="headerlink" title="5. 类加载器之间的关系"></a>5. 类加载器之间的关系</h2><h3 id="5-1-Launcher类核心代码"><a href="#5-1-Launcher类核心代码" class="headerlink" title="5.1 Launcher类核心代码"></a>5.1 Launcher类核心代码</h3><p>JDK8中, 全路径: <code>sun.misc.Launcher</code></p><pre><code class="highlight java"><span class="keyword">public</span> <span class="title function_">Launcher</span><span class="params">()</span> &#123;    <span class="comment">// .......</span>        ExtClassLoader var1;    <span class="keyword">try</span> &#123;        var1 = Launcher.ExtClassLoader.getExtClassLoader();    &#125; <span class="keyword">catch</span> (IOException var10) &#123;        <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">InternalError</span>(<span class="string">&quot;Could not create extension class loader&quot;</span>, var10);    &#125;    <span class="keyword">try</span> &#123;        <span class="built_in">this</span>.loader = Launcher.AppClassLoader.getAppClassLoader(var1);    &#125; <span class="keyword">catch</span> (IOException var9) &#123;        <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">InternalError</span>(<span class="string">&quot;Could not create application class loader&quot;</span>, var9);    &#125;    Thread.currentThread().setContextClassLoader(<span class="built_in">this</span>.loader);        <span class="comment">// ......</span>&#125;</code></pre><h3 id="5-2-关键代码分析"><a href="#5-2-关键代码分析" class="headerlink" title="5.2 关键代码分析"></a>5.2 关键代码分析</h3><h4 id="5-2-1-ExtClassLoader的Parent类是null"><a href="#5-2-1-ExtClassLoader的Parent类是null" class="headerlink" title="5.2.1 ExtClassLoader的Parent类是null"></a>5.2.1 <strong>ExtClassLoader的Parent类是null</strong></h4><p>先看：</p><pre><code class="highlight java">var1 = Launcher.ExtClassLoader.getExtClassLoader();</code></pre><p>获取到扩展类加载器，点击该方法往里面追溯，在找到：</p><pre><code class="highlight java">instance = createExtClassLoader();</code></pre><p>我们在点击该方法往里面追溯，在找到：</p><pre><code class="highlight java"><span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">ExtClassLoader</span>(var1);</code></pre><p>我们在点击该方法往里面追溯，在找到：</p><pre><code class="highlight java"><span class="built_in">super</span>(getExtURLs(var1), (ClassLoader)<span class="literal">null</span>, Launcher.factory);</code></pre><p>然后点击super，往里面追溯，在找到：</p><pre><code class="highlight java"><span class="keyword">public</span> <span class="title function_">URLClassLoader</span><span class="params">(URL[] urls, ClassLoader parent,</span><span class="params">                          URLStreamHandlerFactory factory)</span> &#123;    <span class="built_in">super</span>(parent);    <span class="comment">// this is to make the stack depth consistent with 1.1</span>    <span class="type">SecurityManager</span> <span class="variable">security</span> <span class="operator">=</span> System.getSecurityManager();    <span class="keyword">if</span> (security != <span class="literal">null</span>) &#123;        security.checkCreateClassLoader();    &#125;</code></pre><p>点击其中的parent就是null，我们点击super，往里面追溯，在找到：</p><pre><code class="highlight java"><span class="keyword">protected</span> <span class="title function_">SecureClassLoader</span><span class="params">(ClassLoader parent)</span> &#123;    <span class="built_in">super</span>(parent);</code></pre><p>点击其中的parent就是null，我们点击super，往里面追溯，在找到：</p><pre><code class="highlight java"><span class="keyword">protected</span> <span class="title function_">ClassLoader</span><span class="params">(ClassLoader parent)</span> &#123;    <span class="built_in">this</span>(checkCreateClassLoader(), parent);&#125;</code></pre><p>点击其中的parent就是null，我们点击this，往里面追溯，在找到：</p><pre><code class="highlight java"><span class="keyword">private</span> <span class="title function_">ClassLoader</span><span class="params">(Void unused, ClassLoader parent)</span> &#123;    <span class="built_in">this</span>.parent = parent;</code></pre><p>由于parent就是null，所以ExtClassLoader(扩展类加载器)的父类是null，也就是Bootstrap ClassLoader(引导类加载器)，因此我们调用获取扩展类加载器父类的方法获得的结果是null</p><h4 id="5-2-2-AppClassLoader的Parent类是ExtClassLoader"><a href="#5-2-2-AppClassLoader的Parent类是ExtClassLoader" class="headerlink" title="5.2.2 AppClassLoader的Parent类是ExtClassLoader"></a>5.2.2 AppClassLoader的Parent类是ExtClassLoader</h4><p>先看：</p><pre><code class="highlight plaintext">this.loader = Launcher.AppClassLoader.getAppClassLoader(var1);</code></pre><p>获取到系统类加载器，点击该方法往里面追溯，在找到：</p><pre><code class="highlight plaintext">return new AppClassLoader(var1x, var0);</code></pre><p>其中 <code>var0</code> 就是扩展类加载器，点击AppClassLoader，往里面追溯，在找到：</p><pre><code class="highlight plaintext">AppClassLoader(URL[] var1, ClassLoader var2) &#123;    super(var1, var2, Launcher.factory);    this.ucp.initLookupCache(this);&#125;</code></pre><p>其中var2就是扩展类加载器，我们点击super，往里面追溯，在找到：</p><pre><code class="highlight plaintext">public URLClassLoader(URL[] urls, ClassLoader parent,                      URLStreamHandlerFactory factory) &#123;    super(parent);</code></pre><p>里面的parent就是扩展类加载器，我们点击super，往里面追溯，在找到：</p><pre><code class="highlight plaintext">protected SecureClassLoader(ClassLoader parent) &#123;    super(parent);</code></pre><p>里面的parent就是扩展类加载器，我们点击super，往里面追溯，在找到：</p><pre><code class="highlight plaintext">protected ClassLoader(ClassLoader parent) &#123;    this(checkCreateClassLoader(), parent);&#125;</code></pre><p>里面的parent就是扩展类加载器，我们点击this，往里面追溯，在找到：</p><pre><code class="highlight plaintext">private ClassLoader(Void unused, ClassLoader parent) &#123;    this.parent = parent;</code></pre><p>由于parent就是扩展类加载器，所以系统类加载器的父类是扩展类加载器，因此我们调用获取系统类加载器父类的方法获得的结果是扩展类加载器</p><h4 id="5-2-3-当前线程的ClassLoader是AppClassLoader"><a href="#5-2-3-当前线程的ClassLoader是AppClassLoader" class="headerlink" title="5.2.3  当前线程的ClassLoader是AppClassLoader"></a>5.2.3  当前线程的ClassLoader是AppClassLoader</h4><p><code>Thread.currentThread().setContextClassLoader(this.loader)</code> 就是将系统类加载器设置为当前线程的上下文加载器，所以<code>Thread.currentThread().getContextClassLoader()</code> 获取到的就是系统类加载器</p><p><strong>注意，这里的Parent类并不是Java语言意义上的继承关系，而是一种包含关系</strong></p><h1 id="二、类的加载器分类"><a href="#二、类的加载器分类" class="headerlink" title="二、类的加载器分类"></a>二、类的加载器分类</h1><p>JVM支持两种类型的类加载器，分别为引导类加载器（Bootstrap ClassLoader）和自定义类加载器（User-Defined ClassLoader）。</p><p>从概念上来讲，自定义类加载器一般指的是程序中由开发人员自定义的一类类加载器，但是Java虚拟机规范却没有这么定义，而是将所有派生于抽象类ClassLoader的类加载器都划分为自定义类加载器。无论类加载器的类型如何划分，在程序中我们最常见的类加载器结构主要是如下情况：</p><p><img src="https://raw.githubusercontent.com/GeorgeChan95/blogimg/master/img/2024/08/10/20240810-150849.png" alt="类加载器的分类"></p><ul><li><p>除了顶层的启动类加载器外，其余的类加载器都应当有自己的“父类”加载器。</p></li><li><p>不同类加载器看似是继承（Inheritance）关系，实际上是包含关系。在下层加载器中，包含着上层加载器的引用。</p></li></ul><p>父类加载器和子类加载器的关系：</p><pre><code class="highlight java"><span class="keyword">class</span> <span class="title class_">ClassLoader</span>&#123;    ClassLoader parent;<span class="comment">//父类加载器</span>    <span class="keyword">public</span> <span class="title function_">ClassLoader</span><span class="params">(ClassLoader parent)</span>&#123;    <span class="built_in">this</span>.parent = parent;    &#125;&#125;<span class="keyword">class</span> <span class="title class_">ParentClassLoader</span> <span class="keyword">extends</span> <span class="title class_">ClassLoader</span>&#123;    <span class="keyword">public</span> <span class="title function_">ParentClassLoader</span><span class="params">(ClassLoader parent)</span>&#123;        <span class="built_in">super</span>(parent);    &#125;&#125;<span class="keyword">class</span> <span class="title class_">ChildClassLoader</span> <span class="keyword">extends</span> <span class="title class_">ClassLoader</span>&#123;    <span class="keyword">public</span> <span class="title function_">ChildClassLoader</span><span class="params">(ClassLoader parent)</span>&#123; <span class="comment">//parent = new ParentClassLoader();</span>        <span class="built_in">super</span>(parent);    &#125;&#125;</code></pre><p>正是由于子类加载器中包含着父类加载器的引用，所以可以通过子类加载器的方法获取对应的父类加载器</p><p><strong>注意：</strong></p><p>启动类加载器通过C&#x2F;C++语言编写，而自定义类加载器都是由Java语言编写的，虽然扩展类加载器和应用程序类加载器是被jdk开发人员使用java语言来编写的，但是也是由java语言编写的，所以也被称为自定义类加载器.</p><h2 id="1-引导类加载器"><a href="#1-引导类加载器" class="headerlink" title="1. 引导类加载器"></a>1. 引导类加载器</h2><p>启动类加载器（引导类加载器，Bootstrap ClassLoader）</p><ul><li><p>这个类加载使用C&#x2F;C++语言实现的，嵌套在JVM内部。 </p></li><li><p>它用来加载Java的核心库（<code>JAVAHOME/jre/lib/</code>rt.jar或<code>sun.boot.class.path</code>路径下的内容）。用于提供JVM自身需要的类。 </p></li><li><p>并不继承自java.lang.ClassLoader，没有父加载器。 </p></li><li><p>出于安全考虑，Bootstrap启动类加载器只加载包名为java、javax、sun等开头的类 </p></li><li><p>加载扩展类和应用程序类加载器，并指定为他们的父类加载器。</p></li></ul><p><img src="https://raw.githubusercontent.com/GeorgeChan95/blogimg/master/img/2024/08/10/20240810-153117.png" alt="引导类加载器"></p><p>使用 <code>-XX:+TraceClassLoading</code> 参数得到。</p><p><strong>代码示例:</strong></p><pre><code class="highlight java">System.out.println(<span class="string">&quot;**********启动类加载器**************&quot;</span>);<span class="comment">//获取BootstrapClassLoader能够加载的api的路径</span>URL[] urLs = sun.misc.Launcher.getBootstrapClassPath().getURLs();<span class="keyword">for</span> (URL element : urLs) &#123;    System.out.println(element.toExternalForm());&#125;<span class="comment">//从上面的路径中随意选择一个类,来看看他的类加载器是什么:引导类加载器</span><span class="type">ClassLoader</span> <span class="variable">classLoader</span> <span class="operator">=</span> java.security.Provider.class.getClassLoader();System.out.println(classLoader);</code></pre><p><strong>执行结果：</strong></p><pre><code class="highlight txt">**********启动类加载器**************file:/E:/software/Java/jdk1.8.0_241/jre/lib/resources.jarfile:/E:/software/Java/jdk1.8.0_241/jre/lib/rt.jarfile:/E:/software/Java/jdk1.8.0_241/jre/lib/sunrsasign.jarfile:/E:/software/Java/jdk1.8.0_241/jre/lib/jsse.jarfile:/E:/software/Java/jdk1.8.0_241/jre/lib/jce.jarfile:/E:/software/Java/jdk1.8.0_241/jre/lib/charsets.jarfile:/E:/software/Java/jdk1.8.0_241/jre/lib/jfr.jarfile:/E:/software/Java/jdk1.8.0_241/jre/classesnull</code></pre><h2 id="2-扩展类加载器"><a href="#2-扩展类加载器" class="headerlink" title="2. 扩展类加载器"></a>2. 扩展类加载器</h2><p>扩展类加载器（Extension ClassLoader）</p><p>● Java语言编写，由sun.misc.Launcher$ExtClassLoader实现。<br>●  继承于ClassLoader类<br>●  父类加载器为启动类加载器<br>●  从java.ext.dirs系统属性所指定的目录中加载类库，或从JDK的安装目录的jre&#x2F;lib&#x2F;ext子目录下加载类库。如果用户创建的JAR放在此目录下，也会自动由扩展类加载器加载。</p><p><img src="https://raw.githubusercontent.com/GeorgeChan95/blogimg/master/img/2024/08/10/20240810-155020.png" alt="image-20240810155019744"></p><p><strong>代码示例:</strong></p><pre><code class="highlight java">System.out.println(<span class="string">&quot;***********扩展类加载器*************&quot;</span>);<span class="type">String</span> <span class="variable">extDirs</span> <span class="operator">=</span> System.getProperty(<span class="string">&quot;java.ext.dirs&quot;</span>);<span class="keyword">for</span> (String path : extDirs.split(<span class="string">&quot;;&quot;</span>)) &#123;    System.out.println(path);&#125;<span class="comment">//从上面的路径中随意选择一个类,来看看他的类加载器是什么:扩展类加载器</span><span class="type">ClassLoader</span> <span class="variable">classLoader1</span> <span class="operator">=</span> sun.security.ec.CurveDB.class.getClassLoader();System.out.println(classLoader1); <span class="comment">// sun.misc.Launcher$ExtClassLoader@12a3a380</span></code></pre><p><strong>执行结果:</strong></p><pre><code class="highlight txt">***********扩展类加载器*************E:\software\Java\jdk1.8.0_241\jre\lib\extC:\Windows\Sun\Java\lib\extsun.misc.Launcher$ExtClassLoader@12a3a380</code></pre><h2 id="3-系统类加载器"><a href="#3-系统类加载器" class="headerlink" title="3. 系统类加载器"></a>3. 系统类加载器</h2><p>应用程序类加载器（系统类加载器，AppClassLoader）</p><ul><li><p>java语言编写，由sun.misc.Launcher$AppClassLoader实现</p></li><li><p>继承于ClassLoader类</p></li><li><p>父类加载器为扩展类加载器</p></li><li><p>它负责加载环境变量classpath或系统属性java.class.path 指定路径下的类库</p></li><li><p>应用程序中的类加载器默认是系统类加载器。</p></li><li><p>它是用户自定义类加载器的默认父加载器</p></li><li><p>通过ClassLoader的getSystemClassLoader()方法可以获取到该类加载器</p><pre><code class="highlight java"><span class="comment">//获取系统该类加载器</span><span class="type">ClassLoader</span> <span class="variable">systemClassLoader</span> <span class="operator">=</span> ClassLoader.getSystemClassLoader();System.out.println(systemClassLoader);<span class="comment">//sun.misc.Launcher$AppClassLoader@18b4aac2</span></code></pre></li></ul><p><img src="https://raw.githubusercontent.com/GeorgeChan95/blogimg/master/img/2024/08/10/20240810-155619.png" alt="image-20240810155619231"></p><h2 id="4-用户自定义类加载器"><a href="#4-用户自定义类加载器" class="headerlink" title="4. 用户自定义类加载器"></a>4. 用户自定义类加载器</h2><ul><li><p>在Java的日常应用程序开发中，类的加载几乎是由上述3种类加载器相互配合执行的。在必要时，我们还可以自定义类加载器，来定制类的加载方式。</p></li><li><p>体现Java语言强大生命力和巨大魅力的关键因素之一便是，Java开发者可以自定义类加载器来实现类库的动态加载，加载源可以是本地的JAR包，也可以是网络上的远程资源。</p></li><li><p>通过类加载器可以实现非常绝妙的插件机制，这方面的实际应用案例举不胜举。例如，著名的OSGI组件框架，再如Eclipse的插件机制。类加载器为应用程序提供了一种动态增加新功能的机制，这种机制无须重新打包发布应用程序就能实现。</p></li><li><p>同时，自定义加载器能够实现应用隔离，例如Tomcat，Spring等中间件和组件框架都在内部实现了自定义的加载器，并通过自定义加载器隔离不同的组件模块。这种机制比C&#x2F;C程序要好太多，想不修改C&#x2F;C程序就能为其新增功能，几乎是不可能的，仅仅一个兼容性便能阻挡住所有美好的设想。</p></li><li><p>自定义类加载器通常需要继承于ClassLoader。</p></li></ul><h1 id="三、测试不同的类的加载器"><a href="#三、测试不同的类的加载器" class="headerlink" title="三、测试不同的类的加载器"></a>三、测试不同的类的加载器</h1><p>每个Class对象都会包含一个定义它的ClassLoader的一个引用。</p><pre><code class="highlight java"><span class="comment">//获取系统该类加载器</span><span class="type">ClassLoader</span> <span class="variable">systemClassLoader</span> <span class="operator">=</span> ClassLoader.getSystemClassLoader();System.out.println(systemClassLoader);<span class="comment">//sun.misc.Launcher$AppClassLoader@18b4aac2</span><span class="comment">//获取扩展类加载器</span><span class="type">ClassLoader</span> <span class="variable">extClassLoader</span> <span class="operator">=</span> systemClassLoader.getParent();System.out.println(extClassLoader);<span class="comment">//sun.misc.Launcher$ExtClassLoader@1540e19d</span><span class="comment">//试图获取引导类加载器：失败</span><span class="type">ClassLoader</span> <span class="variable">bootstrapClassLoader</span> <span class="operator">=</span> extClassLoader.getParent();System.out.println(bootstrapClassLoader);<span class="comment">//null</span><span class="type">ClassLoader</span> <span class="variable">classLoader</span> <span class="operator">=</span> Class.forName(<span class="string">&quot;java.lang.String&quot;</span>).getClassLoader();System.out.println(classLoader); <span class="comment">// null, String是核心类库,使用Bootstrap ClassLoader加载</span><span class="comment">//自定义的类默认使用系统类加载器</span><span class="type">ClassLoader</span> <span class="variable">classLoader1</span> <span class="operator">=</span> Class.forName(<span class="string">&quot;com.atguigu.java.ClassLoaderTest1&quot;</span>).getClassLoader();System.out.println(classLoader1); <span class="comment">// sun.misc.Launcher$AppClassLoader@18b4aac2</span><span class="comment">//关于数组类型的加载:使用的类的加载器与数组元素的类的加载器相同</span>String[] arrStr = <span class="keyword">new</span> <span class="title class_">String</span>[<span class="number">10</span>];System.out.println(arrStr.getClass().getClassLoader()); <span class="comment">//null:表示使用的是引导类加载器</span>ClassLoaderTest1[] arr1 = <span class="keyword">new</span> <span class="title class_">ClassLoaderTest1</span>[<span class="number">10</span>];System.out.println(arr1.getClass().getClassLoader()); <span class="comment">//sun.misc.Launcher$AppClassLoader@18b4aac2</span><span class="type">int</span>[] arr2 = <span class="keyword">new</span> <span class="title class_">int</span>[<span class="number">10</span>];System.out.println(arr2.getClass().getClassLoader()); <span class="comment">//null: 基本数据类型不需要类的加载器</span><span class="comment">// 当前线程上下文的ClassLoader就是系统类加载器，</span>System.out.println(Thread.currentThread().getContextClassLoader()); <span class="comment">// sun.misc.Launcher$AppClassLoader@18b4aac2</span></code></pre><p><strong>解释:</strong></p><ul><li><p>站在程序的角度看，引导类加载器与另外两种类加载器（系统类加载器和扩展类加载器）并不是同一个层次意义上的加<br>载器，引导类加载器是使用C++语言编写而成的，而另外两种类加载器则是使用Java语言编写而成的。由于引导类加载<br>器压根儿就不是一个Java类，因此在Java程序中只能打印出空值。</p></li><li><p>数组类的Class对象，不是由类加载器去创建的，而是在Java运行期JVM根据需要自动创建的。对于数组类的类加载器<br>来说，是通过Class.getClassLoader()返回的，与数组当中元素类型的类加载器是一样的；如果数组当中的元素类型<br>是基本数据类型，数组类是没有类加载器的。</p></li></ul><h1 id="四、ClassLoader源码解析"><a href="#四、ClassLoader源码解析" class="headerlink" title="四、ClassLoader源码解析"></a>四、ClassLoader源码解析</h1><p><strong>ClassLoader与现有类的关系：</strong></p><p><img src="https://raw.githubusercontent.com/GeorgeChan95/blogimg/master/img/2024/08/10/20240810-163038.png" alt="ClassLoader继承关系"></p><p>除了以上虚拟机自带的加载器外，用户还可以定制自己的类加载器。Java提供了抽象类java.lang.ClassLoader，所有用户自定义的类加载器都应该继承ClassLoader类。</p><h2 id="1-ClassLoader的主要方法"><a href="#1-ClassLoader的主要方法" class="headerlink" title="1. ClassLoader的主要方法"></a>1. ClassLoader的主要方法</h2><p>抽象类ClassLoader的主要方法：（内部没有抽象方法）</p><ol><li><p>返回该类加载器的超类加载器</p><pre><code class="highlight java"><span class="keyword">public</span> <span class="keyword">final</span> ClassLoader <span class="title function_">getParent</span><span class="params">()</span></code></pre></li><li><p>加载名称为name的类，返回结果为java.lang.Class类的实例。如果找不到类，则返回 <code>ClassNotFoundException</code> 异常。该方法中的逻辑就是双亲委派模式的实现。</p><pre><code class="highlight java"><span class="keyword">public</span> Class&lt;?&gt; loadClass(String name) <span class="keyword">throws</span> ClassNotFoundException</code></pre></li><li><p>查找二进制名称为name的类，返回结果为java.lang.Class类的实例。这是一个受保护的方法，JVM鼓励我们重写此方法，需要自定义加载器遵循双亲委托机制，该方法会在检查完父类加载器之后被loadClass()方法调用。</p><pre><code class="highlight plaintext">protected Class&lt;?&gt; findClass(String name) throws ClassNotFoundException</code></pre><ul><li>在JDK1.2之前，在自定义类加载时，总会去继承ClassLoader类并重写loadClass方法，从而实现自定义的类加载类。但是在JDK1.2之后已不再建议用户去覆盖loadClass()方法，而是建议把自定义的类加载逻辑写在findClass()方法中，从前面的分析可知，findClass()方法是在loadClass()方法中被调用的，当loadClass()方法中父加载器加载失败后，则会调用自己的findClass()方法来完成类加载，这样就可以保证自定义的类加载器也符合双亲委托模式。 </li><li>需要注意的是 ClassLoader 类中并没有实现 findClass() 方法的具体代码逻辑，取而代之的是抛出 ClassNotFoundException 异常，同时应该知道的是 findClass 方法通常是和 defineClass 方法一起使用的。</li></ul><p><strong>一般情况下，在自定义类加载器时，会直接覆盖 ClassLoader 的 findClass() 方法并编写加载规则，取得要加载类的字节码后转换成流，然后调用 defineClass() 方法生成类的Class对象。</strong></p></li><li><p>根据给定的 字节数组b 转换为Class的实例，off 和 len 参数表示实际Class信息在byte数组中的位置和长度，其中byte数组b是ClassLoader从外部获取的。这是受保护的方法，只有在自定义ClassLoader子类中可以使用。</p><pre><code class="highlight java"><span class="keyword">protected</span> <span class="keyword">final</span> Class&lt;?&gt; defineClass(String name, <span class="type">byte</span>[] b,<span class="type">int</span> off,<span class="type">int</span> len)</code></pre><ul><li><p>defineClass() 方法是用来将byte字节流解析成JVM能够识别的Class对象（ClassLoader中已实现该方法逻辑），通过这个方法不仅能够通过class文件实例化class对象，也可以通过其他方式实例化class对象，如通过网络接收一个类的字节码，然后转换为byte字节流创建对应的Class对象。 </p></li><li><p><strong>defineClass() 方法通常与 findClass() 方法一起使用，一般情况下，在自定义类加载器时，会直接覆盖 ClassLoader 的 findClass() 方法并编写加载规则，取得要加载类的字节码后转换成流，然后调用 defineClass() 方法生成类的Class对象</strong></p></li></ul><p><strong>举例说明</strong></p><pre><code class="highlight java"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">UserClassLoader</span> <span class="keyword">extends</span> <span class="title class_">ClassLoader</span> &#123;    <span class="keyword">private</span> String rootDir;    <span class="keyword">public</span> <span class="title function_">UserClassLoader</span><span class="params">(String rootDir)</span> &#123;        <span class="built_in">this</span>.rootDir = rootDir;    &#125;    <span class="comment">/**</span><span class="comment">     * 编写findClass方法的逻辑</span><span class="comment">     */</span>    <span class="meta">@Override</span>    <span class="keyword">protected</span> Class&lt;?&gt; findClass(String name) <span class="keyword">throws</span> ClassNotFoundException &#123;        <span class="comment">// 获取类的class文件字节数组</span>        <span class="type">byte</span>[] classData = getClassData(name);        <span class="keyword">if</span> (classData == <span class="literal">null</span>) &#123;            <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">ClassNotFoundException</span>();        &#125; <span class="keyword">else</span> &#123;            <span class="comment">//直接生成class对象</span>            <span class="keyword">return</span> defineClass(name, classData, <span class="number">0</span>, classData.length);        &#125;    &#125;    <span class="comment">/**</span><span class="comment">     * 编写获取class文件并转换为字节码流的逻辑 * <span class="doctag">@param</span> className * <span class="doctag">@return</span></span><span class="comment">     */</span>    <span class="keyword">private</span> <span class="type">byte</span>[] getClassData(String className) &#123;        <span class="comment">// 读取类文件的字节</span>        <span class="type">String</span> <span class="variable">path</span> <span class="operator">=</span> classNameToPath(className);        <span class="keyword">try</span> &#123;            <span class="type">InputStream</span> <span class="variable">ins</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">FileInputStream</span>(path);            <span class="type">ByteArrayOutputStream</span> <span class="variable">baos</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ByteArrayOutputStream</span>();            <span class="type">byte</span>[] buffer = <span class="keyword">new</span> <span class="title class_">byte</span>[<span class="number">1024</span>];            <span class="type">int</span> <span class="variable">len</span> <span class="operator">=</span> <span class="number">0</span>;            <span class="comment">// 读取类文件的字节码</span>            <span class="keyword">while</span> ((len = ins.read(buffer)) != -<span class="number">1</span>) &#123;                baos.write(buffer, <span class="number">0</span>, len);            &#125;            <span class="keyword">return</span> baos.toByteArray();        &#125; <span class="keyword">catch</span> (IOException e) &#123;            e.printStackTrace();        &#125;        <span class="keyword">return</span> <span class="literal">null</span>;    &#125;    <span class="comment">/**</span><span class="comment">     * 类文件的完全路径</span><span class="comment">     */</span>    <span class="keyword">private</span> String <span class="title function_">classNameToPath</span><span class="params">(String className)</span> &#123;        <span class="keyword">return</span> rootDir + <span class="string">&quot;\\&quot;</span> + className.replace(<span class="string">&#x27;.&#x27;</span>, <span class="string">&#x27;\\&#x27;</span>) + <span class="string">&quot;.class&quot;</span>;    &#125;    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;        <span class="type">String</span> <span class="variable">rootDir</span> <span class="operator">=</span> <span class="string">&quot;E:\\testWorkspace\\jvm-demo-mid\\chapter04\\src\\&quot;</span>;        <span class="keyword">try</span> &#123;            <span class="comment">//创建自定义的类的加载器1</span>            <span class="type">UserClassLoader</span> <span class="variable">loader1</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">UserClassLoader</span>(rootDir);            <span class="type">Class</span> <span class="variable">clazz1</span> <span class="operator">=</span> loader1.findClass(<span class="string">&quot;com.atguigu.java.User&quot;</span>);            <span class="comment">//创建自定义的类的加载器2</span>            <span class="type">UserClassLoader</span> <span class="variable">loader2</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">UserClassLoader</span>(rootDir);            <span class="type">Class</span> <span class="variable">clazz2</span> <span class="operator">=</span> loader2.findClass(<span class="string">&quot;com.atguigu.java.User&quot;</span>);            System.out.println(clazz1 == clazz2); <span class="comment">//结果:false, clazz1与clazz2对应了不同的类模板结构。</span>            System.out.println(clazz1.getClassLoader()); <span class="comment">// com.atguigu.java.UserClassLoader@16f65612</span>            System.out.println(clazz2.getClassLoader()); <span class="comment">// com.atguigu.java.UserClassLoader@7c53a9eb</span>            <span class="comment">//######################</span>            <span class="type">Class</span> <span class="variable">clazz3</span> <span class="operator">=</span> ClassLoader.getSystemClassLoader().loadClass(<span class="string">&quot;com.atguigu.java.User&quot;</span>);            System.out.println(clazz3.getClassLoader()); <span class="comment">// sun.misc.Launcher$AppClassLoader@18b4aac2</span>            <span class="comment">// 自定义类加载器的父类加载器是 AppClassLoader</span>            System.out.println(clazz1.getClassLoader().getParent()); <span class="comment">// sun.misc.Launcher$AppClassLoader@18b4aac2</span>        &#125; <span class="keyword">catch</span> (ClassNotFoundException e) &#123;            e.printStackTrace();        &#125;    &#125;&#125;</code></pre></li><li><p>链接指定的一个Java类。使用该方法可以使用类的Class对象创建完成的同时也被解析。前面我们说链接阶段主要是对字节码进行验证，为类变量分配内存并设置初始值同时将字节码文件中的符号引用转换为直接引用。</p><pre><code class="highlight java"><span class="keyword">protected</span> <span class="keyword">final</span> Class&lt;?&gt; findLoadedClass(String name)</code></pre></li><li><p>查找名称为name的已经被加载过的类，返回结果为java.lang.Class类的实例。这个方法是final方法，无法被修改。</p><pre><code class="highlight java"><span class="keyword">protected</span> <span class="keyword">final</span> Class&lt;?&gt; findLoadedClass(String name)</code></pre></li><li><p>它也是一个ClassLoader的实例，这个字段所表示的ClassLoader也称为这个ClassLoader的双亲。在类加载的过程中，ClassLoader可能会将某些请求交予自己的双亲处理。</p><pre><code class="highlight java"><span class="keyword">private</span> <span class="keyword">final</span> ClassLoader parent;</code></pre></li></ol><h2 id="2-SecureClassLoader与URLClassLoader"><a href="#2-SecureClassLoader与URLClassLoader" class="headerlink" title="2. SecureClassLoader与URLClassLoader"></a>2. SecureClassLoader与URLClassLoader</h2><p>接着<strong>SecureClassLoader</strong>扩展了ClassLoader，新增了几个与使用相关的代码源（对代码源的位置及其证书的验证）和权限定义类验证（主要指对class源码的访问权限）的方法，一般我们不会直接跟这个类打交道，更多是与它的子类<strong>URLClassLoader</strong>有所关联。</p><p>前面说过，ClassLoader是一个抽象类，很多方法是空的没有实现，比如findClass()、findResource()等。而URLClassLoader这个实现类为这些方法提供了具体的实现。并新增了URLClassPath类协助取得Class字节码流等功能。<strong>在编写自定义类加载器时，如果没有太过于复杂的需求，可以直接继承URLClassLoader类</strong>，这样就可以避免自己去编写findClass()方法及其获取字节码流的方式，使自定义类加载器编写更加简洁。</p><p><img src="https://raw.githubusercontent.com/GeorgeChan95/blogimg/master/img/2024/08/10/20240810-165250.png" alt="URLClassLoader"></p><h2 id="3-ExtClassLoader与AppClassLoader"><a href="#3-ExtClassLoader与AppClassLoader" class="headerlink" title="3. ExtClassLoader与AppClassLoader"></a>3. ExtClassLoader与AppClassLoader</h2><p>了解完URLClassLoader后接着看看剩余的两个类加载器，即<strong>拓展类加载器ExtClassLoader</strong>和<strong>系统类加载器AppClassLoader</strong>，这两个类都继承自URLClassLoader，是 <code>sun.misc.Launcher</code> 的静态内部类。</p><p><code>sun.misc.Launcher</code> 主要被系统用于启动主应用程序，ExtClassLoader和AppClassLoader都是由sun.misc.Launcher创建的，其类主要类结构如下：</p><p><img src="https://raw.githubusercontent.com/GeorgeChan95/blogimg/master/img/2024/08/10/20240810-165757.png" alt="Launcher"></p><p>我们发现ExtClassLoader并没有重写loadClass()方法，这足矣说明其遵循双亲委派模式，而AppClassLoader重载了loadClass()方法，但最终调用的还是父类loadClass()方法，因此依然遵守双亲委派模式。</p><h2 id="4-Class-forName-与ClassLoader-loadClass"><a href="#4-Class-forName-与ClassLoader-loadClass" class="headerlink" title="4. Class.forName()与ClassLoader.loadClass()"></a>4. Class.forName()与ClassLoader.loadClass()</h2><p><strong>Class.forName()</strong></p><ul><li>Class.forName()：是一个<strong>静态方法</strong>，最常用的是Class.forName(String className); </li><li>根据传入的类的全限定名返回一个Class对象。该方法在将Class文件加载到内存的同时，<strong>会执行类的初始化</strong>。</li></ul><pre><code class="highlight java">Class.forName(<span class="string">&quot;com.atguigu.java.Helloworld&quot;</span>);</code></pre><p><strong>ClassLoader.loadClass()</strong></p><ul><li><p>ClassLoader.loadClass()：这是一个<strong>实例方法</strong>，需要一个ClassLoader对象来调用该方法。 </p></li><li><p>该方法将Class文件加载到内存时，并<strong>不会执行类的初始化，直到这个类第一次使用时才进行初始化</strong>。该方法因为需要得到一个ClassLoader对象，所以可以根据需要指定使用哪个类加载器。</p></li></ul><pre><code class="highlight java"><span class="type">Class</span> <span class="variable">clazz</span> <span class="operator">=</span> ClassLoader.getSystemClassLoader().loadClass(<span class="string">&quot;com.atguigu.java1.Person&quot;</span>);</code></pre><h1 id="五、双亲委派模型"><a href="#五、双亲委派模型" class="headerlink" title="五、双亲委派模型"></a>五、双亲委派模型</h1><h2 id="1-定义与本质"><a href="#1-定义与本质" class="headerlink" title="1. 定义与本质"></a>1. 定义与本质</h2><p>类加载器用来把类加载到Java虚拟机中。从JDK1.2版本开始，类的加载过程采用双亲委派机制，这种机制能更好地保证Java平台的安全。</p><p><strong>定义</strong></p><p>如果一个类加载器在接到加载类的请求时，它首先不会自己尝试去加载这个类，而是把这个请求任务委托给父类加载器去完成，依次递归，如果父类加载器可以完成类加载任务，就成功返回。只有父类加载器无法完成此加载任务时，才自己去加载。</p><p><strong>本质</strong></p><p>规定了类加载的顺序是：引导类加载器先加载，若加载不到，由扩展类加载器加载，若还加载不到，才会由系统类加载器或自定义的类加载器进行加载。</p><p><img src="https://raw.githubusercontent.com/GeorgeChan95/blogimg/master/img/2024/08/10/20240810-170952.png" alt="双亲委派模型"></p><p><img src="https://raw.githubusercontent.com/GeorgeChan95/blogimg/master/img/2024/08/10/20240810-171002.png" alt="双亲委派模型2"></p><h2 id="2-优势与劣势"><a href="#2-优势与劣势" class="headerlink" title="2. 优势与劣势"></a>2. 优势与劣势</h2><h3 id="2-1-双亲委派机制优势"><a href="#2-1-双亲委派机制优势" class="headerlink" title="2.1 双亲委派机制优势"></a>2.1 双亲委派机制优势</h3><ul><li><p>避免类的重复加载，确保一个类的全局唯一性</p><p>Java类随着它的类加载器一起具备了一种带有优先级的层次关系，通过这种层级关可以避免类的重复加载，当父亲已经加载了该类时，就没有必要子ClassLoader再加载一次。</p></li><li><p>保护程序安全，防止核心API被随意篡改</p></li></ul><h3 id="2-2-代码支持"><a href="#2-2-代码支持" class="headerlink" title="2.2 代码支持"></a>2.2 代码支持</h3><p>双亲委派机制在 <code>java.lang.ClassLoader.loadClass(String，boolean)</code> 接口中体现。该接口的逻辑如下：</p><ol><li>先在当前加载器的缓存中查找有无目标类，如果有，直接返回。</li><li>判断当前加载器的父加载器是否为空，如果不为空，则调用 <code>parent.loadClass(name，false)</code> 接口进行加载。</li><li>反之，如果当前加载器的父类加载器为空，则调用 <code>findBootstrapClassorNull(name)</code> 接口，让引导类加载器进行加载。</li><li>如果通过以上3条路径都没能成功加载，则调用 <code>findClass(name)</code> 接口进行加载。该接口最终会调用java.lang.ClassLoader接口的defineClass系列的native接口加载目标Java类。</li></ol><p>双亲委派的模型就隐藏在这第2和第3步中。</p><h3 id="2-3-举例"><a href="#2-3-举例" class="headerlink" title="2.3 举例"></a>2.3 举例</h3><p>假设当前加载的是java.lang.Object这个类，很显然，该类属于JDK中核心得不能再核心的一个类，因此一定只能由引导类加载器进行加载。当]VM准备加载javaJang.Object时，JVM默认会使用系统类加载器去加载，按照上面4步加载的逻辑，在第1步从系统类的缓存中肯定查找不到该类，于是进入第2步。由于从系统类加载器的父加载器是扩展类加载器，于是扩展类加载器继续从第1步开始重复。由于扩展类加载器的缓存中也一定查找不到该类，因此进入第2步。扩展类的父加载器是null，因此系统调用findClass（String），最终通过引导类加载器进行加载。</p><h3 id="2-4-思考"><a href="#2-4-思考" class="headerlink" title="2.4 思考"></a>2.4 思考</h3><p>如果在自定义的类加载器中重写 <code>java.lang.ClassLoader.loadClass(String)</code> 或 <code>java.lang.ClassLoader.loadclass(String，boolean)</code> 方法，抹去其中的双亲委派机制，仅保留上面这4步中的第l步与第4步，那么是不是就能够加载核心类库了呢？</p><p>这也不行！因为JDK还为核心类库提供了一层保护机制。不管是自定义的类加载器，还是系统类加载器抑或扩展类加载器，最终都必须调用 <code>java.lang.ClassLoader.defineclass(String，byte[]，int，int，ProtectionDomain)</code> 方法，而该方法会执行 <code>preDefineClass()</code> 接口，该接口中提供了对JDK核心类库的保护。</p><h3 id="2-5-弊端"><a href="#2-5-弊端" class="headerlink" title="2.5 弊端"></a>2.5 弊端</h3><p>检查类是否加载的委托过程是单向的，这个方式虽然从结构上说比较清晰，使各个ClassLoader的职责非常明确，但是同时会带来一个问题，即顶层的ClassLoader无法访问底层的ClassLoader所加载的类。</p><p>通常情况下，启动类加载器中的类为系统核心类，包括一些重要的系统接口，而在应用类加载器中的类为应用类。按照这种模式，应用类访问系统类自然是没有问题，但是系统类访问应用类就会出现问题。比如在系统类中提供了一个接口，该接口需要在应用类中得以实现，该接口还绑定一个工厂方法，用于创建该接口的实例，而接口和工厂方法都在启动类加载器中。这时，就会出现该工厂方法无法创建由应用类加载器加载的应用实例的问题。</p><h3 id="2-6-结论"><a href="#2-6-结论" class="headerlink" title="2.6 结论"></a>2.6 结论</h3><p><strong>由于Java虚拟机规范并没有明确要求类加载器的加载机制一定要使用双亲委派模型，只是建议采用这种方式而已。</strong>比如在Tomcat中，类加载器所采用的加载机制就和传统的双亲委派模型有一定区别，当缺省的类加载器接收到一个类的加载任务时，首先会由它自行加载，当它加载失败时，才会将类的加载任务委派给它的超类加载器去执行，这同时也是Servlet规范推荐的一种做法。</p><h2 id="3-破坏双亲委派机制"><a href="#3-破坏双亲委派机制" class="headerlink" title="3. 破坏双亲委派机制"></a>3. 破坏双亲委派机制</h2><p>双亲委派模型并不是一个具有强制性约束的模型，而是Java设计者推荐给开发者们的类加载器实现方式。</p><p>在Java的世界中大部分的类加载器都遵循这个模型，但也有例外的情况，直到Java模块化出现为止，双亲委派模型主要出现过3次较大规模“被破坏”的情况。</p><h3 id="3-1-破坏双亲委派机制1"><a href="#3-1-破坏双亲委派机制1" class="headerlink" title="3.1 破坏双亲委派机制1"></a>3.1 破坏双亲委派机制1</h3><p>双亲委派模型的第一次“被破坏”其实发生在双亲委派模型出现之前–即JDK1.2面世以前的“远古”时代。</p><p>由于双亲委派模型在JDK 1.2之后才被引入，但是类加载器的概念和抽象类java.lang.ClassLoader则在Java的第一个版本中就已经存在，面对经存在的用户自定义类加载器的代码，Java设计者们引入双亲委派模型时不得不做出一些妥协，为了兼容这些已有代码，无法再以技术手段避免loadClass()被子类覆盖的可能性，只能在JDK1.2之后的java.lang.ClassLoader中添加一个新的protected方法findClass()，并引导用户编写的类加载逻辑时尽可能去重写这个方法，而不是在loadClass()中编写代码。上节我们已经分析过loadClass()方法，双亲委派的具体逻辑就实现在这里面，按照loadClass()方法的逻辑，如果父类加载失败，会自动调用自己的findClass()方法来完成加载，这样既不影响用户按照自己的意愿去加载类，又可以保证新写出来的类加载器是符合双亲委派规则的。</p><h3 id="3-2-破坏双亲委派机制1"><a href="#3-2-破坏双亲委派机制1" class="headerlink" title="3.2 破坏双亲委派机制1"></a>3.2 破坏双亲委派机制1</h3><p>双亲委派模型的第二次“被破坏”是由这个模型自身的缺陷导致的，双亲委派很好地解决了各个类加载器协作时基础类型的一致性问题（越基础的类由越上层的加载器进行加载），基础类型之所以被称为“基础”，是因为它们总是作为被用户代码继承、调用的API存在，但程序设计往往没有绝对不变的完美规则，如果有基础类型又要调用回用户的代码，那该怎么办呢？</p><p>这并非是不可能出现的事情，一个典型的例子便是JNDI服务，JNDI现在已经是Java的标准服务，它的代码由启动类加载器来完成加载（在JDK 1.3时加入到rt.jar的），肯定属于Java中很基础的类型了。但JNDI存在的目的就是对资源进行查找和集中管理，它需要调用由其他厂商实现并部署在应用程序的ClassPath下的JNDI服务提供者接口（Service Provider Interface，SPI）的代码，现在问题来了，启动类加载器是绝不可能认识、加载这些代码的，那该怎么办？（SPI：在Java平台中，通常把核心类rt.jar中提供外部服务、可由应用层自行实现的接口称为SPI）</p><p>为了解决这个困境，Java的设计团队只好引入了一个不太优雅的设计：<strong>线程上下文类加载器（Thread Context ClassLoader）</strong>。这个类加载器可以通过java.lang.Thread类的setContextClassLoader()方法进行设置，如果创建线程时还未设置，它将会从父线程中继承一个，如果在应用程序的全局范围内都没有设置过的话，那这个类加载器默认就是应用程序类加载器。</p><p>有了线程上下文类加载器，程序就可以做一些“舞弊”的事情了。JNDI服务使用这个线程上下文类加载器去加载所需的SPI服务代码，</p><p>**这是一种父类加载器去请求子类加载器完成类加载的行为，这种行为实际上是打通了双亲委派模型的层次结构来逆向使用类加载器，已经违背了双亲委派模型的一般性原则, **但也是无可奈何的事情。 例如JNDI、JDBC、JCE、JAXB和JBI等。不过，当SPI的服务提供者多于一个的时候，代码就只能根据具体提供者的类型来硬编码判断，为了消除这种极不优雅的实现方式，在JDK6时，JDK提供了java.util.ServiceLoader类，以META-INF&#x2F;services中的配置信息，辅以责任链模式，这才算是给SPI的加载提供了一种相对合理的解决方案。</p><p><img src="https://raw.githubusercontent.com/GeorgeChan95/blogimg/master/img/2024/08/10/20240810-173847.png" alt="线程上下文类加载器"></p><p>默认线程上下文加载器就是应用类加载器，这样以上下文加载器为中介，使得启动类加载器中的代码也可以访问应用类加载器中的类。</p><h3 id="3-3-破坏双亲委派机制1"><a href="#3-3-破坏双亲委派机制1" class="headerlink" title="3.3 破坏双亲委派机制1"></a>3.3 破坏双亲委派机制1</h3><p>双亲委派模型的第三次“被破坏”是由于用户对程序动态性的追求而导致的。如：**代码热替换(Hot Swap)、模块热部署(Hot Deployment)**等</p><p>IBM公司主导的 <strong>JSR-291</strong> (即OSGiR4.2)实现模块化热部署的关键是它自定义的类加载器机制的实现，每一个程序模块(osGi中称为Bundle)都有一个自己的类加载器，当需要更换一个Bundle时，就把Bund1e连同类加载器一起换掉以实现代码的热替换。在OSGi环境下，类加载器不再双亲委派模型推荐的树状结构，而是进一步发展为更加复杂的网状结构。</p><p>当收到类加载请求时，OSGi将按照下面的顺序进行类搜索：</p><ol><li>将以java.*开头的类，委派给父类加载器加载。</li><li>否则，将委派列表名单内的类，委派给父类加载器加载。</li><li>否则，将Import列表中的类，委派给Export这个类的Bundle的类加载器加载。</li><li>否则，查找当前Bundle的ClassPath，使用自己的类加载器加载。</li><li>否则，查找类是否在自己的Fragment Bundle中，如果在，则委派给Fragment Bundle的类加载器加载。</li><li>否则，查找Dynamic Import列表的Bundle，委派给对应Bund1e的类加载器加载。</li><li>否则，类查找失败。</li></ol><p>说明：只有开头两点仍然符合双亲委派模型的原则，其余的类查找都是在平级的类加载器中进行的</p><p>小结：这里，我们使用了“被破坏”这个词来形容上述不符合双亲委派模型原则的行为，但这里“被破坏”并不一定是带有贬义的。只要有明确的目的和充分的理由，突破旧有原则无疑是一种创新。</p><p>正如：OSGi中的类加载器的设计不符合传统的双亲委派的类加载器架构，且业界对其为了实现热部署而带来的额外的高复杂度还存在不少争议，但对这方面有了解的技术人员基本还是能达成一个共识，认为<strong>OSGi中对类加载器的运用是值得学习的，完全弄懂了OSGi的实现，就算是掌握了类加载器的精粹。</strong></p><h2 id="4-热替换的实现"><a href="#4-热替换的实现" class="headerlink" title="4. 热替换的实现"></a>4. 热替换的实现</h2><h3 id="4-1-理论概述"><a href="#4-1-理论概述" class="headerlink" title="4.1 理论概述"></a>4.1 理论概述</h3><p><strong>热替换是指在程序的运行过程中，不停止服务，只通过替换程序文件来修改程序的行为。</strong></p><p>热替换的关键需求在于服务不能中断，修改必须立即表现正在运行的系统之中。基本上大部分脚本语言都是天生支持热替换的，比如：PHP，只要替换了PHP源文件，这种改动就会立即生效，而无需重启Web服务器。</p><p>但对Java来说，热替换并非天生就支持，如果一个类已经加载到系统中，通过修改类文件，并无法让系统再来加载并重定义这个类。因此，在Java中实现这一功能的一个可行的方法就是灵活运用ClassLoader。</p><p><strong>注意：由不同ClassLoader加载的同名类属于不同的类型，不能相互转换和兼容。即两个不同的ClassLoader加载同一个类，在虚拟机内部，会认为这2个类是完全不同的。</strong></p><p>根据这个特点，可以用来模拟热替换的实现，基本思路如下图所示：</p><p><img src="https://raw.githubusercontent.com/GeorgeChan95/blogimg/master/img/2024/08/10/20240810-174651.png" alt="热替换的实现"></p><p>每次调用方法之前都要加载字节码文件，然后创建对象，我们可以把字节码文件变成最新的，那么创建的对象肯定是最新的，所以这就完成了热替换</p><h3 id="4-2-代码实现"><a href="#4-2-代码实现" class="headerlink" title="4.2 代码实现"></a><strong>4.2 代码实现</strong></h3><ul><li><p>基础类</p><pre><code class="highlight java"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Demo1</span> &#123;    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">hot</span><span class="params">()</span> &#123;        System.out.println(<span class="string">&quot;OldDemo1&quot;</span>);    &#125;&#125;</code></pre></li><li><p>自定义ClassLoader</p><pre><code class="highlight java"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">MyClassLoader</span> <span class="keyword">extends</span> <span class="title class_">ClassLoader</span> &#123;    <span class="keyword">private</span> String rootDir;    <span class="keyword">public</span> <span class="title function_">MyClassLoader</span><span class="params">(String rootDir)</span> &#123;        <span class="built_in">this</span>.rootDir = rootDir;    &#125;    <span class="keyword">protected</span> Class&lt;?&gt; findClass(String className) <span class="keyword">throws</span> ClassNotFoundException &#123;        <span class="type">Class</span> <span class="variable">clazz</span> <span class="operator">=</span> <span class="built_in">this</span>.findLoadedClass(className);        <span class="type">FileChannel</span> <span class="variable">fileChannel</span> <span class="operator">=</span> <span class="literal">null</span>;        <span class="type">WritableByteChannel</span> <span class="variable">outChannel</span> <span class="operator">=</span> <span class="literal">null</span>;        <span class="keyword">if</span> (<span class="literal">null</span> == clazz) &#123;            <span class="keyword">try</span> &#123;                <span class="type">String</span> <span class="variable">classFile</span> <span class="operator">=</span> getClassFile(className);                <span class="type">FileInputStream</span> <span class="variable">fis</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">FileInputStream</span>(classFile);                fileChannel = fis.getChannel();                <span class="type">ByteArrayOutputStream</span> <span class="variable">baos</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ByteArrayOutputStream</span>();                outChannel = Channels.newChannel(baos);                <span class="type">ByteBuffer</span> <span class="variable">buffer</span> <span class="operator">=</span> ByteBuffer.allocateDirect(<span class="number">1024</span>);                <span class="keyword">while</span> (<span class="literal">true</span>) &#123;                    <span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> fileChannel.read(buffer);                    <span class="keyword">if</span> (i == <span class="number">0</span> || i == -<span class="number">1</span>) &#123;                        <span class="keyword">break</span>;                    &#125;                    buffer.flip();                    outChannel.write(buffer);                    buffer.clear();                &#125;                <span class="type">byte</span>[] bytes = baos.toByteArray();                clazz = defineClass(className, bytes, <span class="number">0</span>, bytes.length);            &#125; <span class="keyword">catch</span> (FileNotFoundException e) &#123;                e.printStackTrace();            &#125; <span class="keyword">catch</span> (IOException e) &#123;                e.printStackTrace();            &#125; <span class="keyword">finally</span> &#123;                <span class="keyword">try</span> &#123;                    <span class="keyword">if</span> (fileChannel != <span class="literal">null</span>)                        fileChannel.close();                &#125; <span class="keyword">catch</span> (IOException e) &#123;                    e.printStackTrace();                &#125;                <span class="keyword">try</span> &#123;                    <span class="keyword">if</span> (outChannel != <span class="literal">null</span>)                        outChannel.close();                &#125; <span class="keyword">catch</span> (IOException e) &#123;                    e.printStackTrace();                &#125;            &#125;        &#125;        <span class="keyword">return</span> clazz;    &#125;    <span class="comment">/**</span><span class="comment">     * 类文件的完全路径</span><span class="comment">     */</span>    <span class="keyword">private</span> String <span class="title function_">getClassFile</span><span class="params">(String className)</span> &#123;        <span class="keyword">return</span> rootDir + <span class="string">&quot;\\&quot;</span> + className.replace(<span class="string">&#x27;.&#x27;</span>, <span class="string">&#x27;\\&#x27;</span>) + <span class="string">&quot;.class&quot;</span>;    &#125;&#125;</code></pre></li><li><p>测试类</p><pre><code class="highlight java"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">LoopRun</span> &#123;    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String args[])</span> &#123;        <span class="keyword">while</span> (<span class="literal">true</span>) &#123;            <span class="keyword">try</span> &#123;                <span class="comment">//1. 创建自定义类加载器的实例</span>                <span class="type">MyClassLoader</span> <span class="variable">loader</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">MyClassLoader</span>(<span class="string">&quot;E:\\testWorkspace\\jvm-demo-mid\\chapter04\\src\\&quot;</span>);                <span class="comment">//2. 加载指定的类</span>                <span class="type">Class</span> <span class="variable">clazz</span> <span class="operator">=</span> loader.findClass(<span class="string">&quot;com.atguigu.java1.Demo1&quot;</span>);                <span class="comment">//3. 创建运行时类的实例</span>                <span class="type">Object</span> <span class="variable">demo</span> <span class="operator">=</span> clazz.newInstance();                <span class="comment">//4. 获取运行时类中指定的方法</span>                <span class="type">Method</span> <span class="variable">m</span> <span class="operator">=</span> clazz.getMethod(<span class="string">&quot;hot&quot;</span>);                <span class="comment">//5. 调用指定的方法</span>                m.invoke(demo);                Thread.sleep(<span class="number">5000</span>);            &#125; <span class="keyword">catch</span> (Exception e) &#123;                System.out.println(<span class="string">&quot;not find&quot;</span>);                <span class="keyword">try</span> &#123;                    Thread.sleep(<span class="number">5000</span>);                &#125; <span class="keyword">catch</span> (InterruptedException ex) &#123;                    ex.printStackTrace();                &#125;            &#125;        &#125;    &#125;&#125;</code></pre></li></ul><h3 id="4-3-代码测试"><a href="#4-3-代码测试" class="headerlink" title="4.3 代码测试"></a>4.3 代码测试</h3><ul><li><p>启动测试类, 控制台打印:</p><p><img src="https://raw.githubusercontent.com/GeorgeChan95/blogimg/master/img/2024/08/10/20240810-175542.png" alt="热替换前"></p></li><li><p>修改Demo1.java, 重新编译生成新的Demo1.class文件</p><p><img src="https://raw.githubusercontent.com/GeorgeChan95/blogimg/master/img/2024/08/10/20240810-175647.png" alt="修改并重新编译"></p></li><li><p>无需重启服务, 再次查看控制台</p><p><img src="https://raw.githubusercontent.com/GeorgeChan95/blogimg/master/img/2024/08/10/20240810-175845.png" alt="热替换后"></p></li></ul><p>六、沙箱安全机制</p><p>七、自定义类的加载器</p><p>八、Java9新特性</p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;&lt;strong&gt;以下内容关于类加载器都是基于 JDK8 讲解的, JDK9的类加载器与之不同&lt;/strong&gt;&lt;/p&gt;
&lt;h1 id=&quot;一、概述&quot;&gt;&lt;a href=&quot;#一、概述&quot; class=&quot;headerlink&quot; title=&quot;一、概述&quot;&gt;&lt;/a&gt;一、概述&lt;/h1&gt;&lt;p</summary>
      
    
    
    
    <category term="JVM" scheme="https://georgechan95.github.io/categories/JVM/"/>
    
    
    <category term="jvm" scheme="https://georgechan95.github.io/tags/jvm/"/>
    
    <category term="java" scheme="https://georgechan95.github.io/tags/java/"/>
    
  </entry>
  
  <entry>
    <title>第十九章-类的加载过程详解</title>
    <link href="https://georgechan95.github.io/2024/08/02/jvm/%E7%AC%AC%E5%8D%81%E4%B9%9D%E7%AB%A0-%E7%B1%BB%E7%9A%84%E5%8A%A0%E8%BD%BD%E8%BF%87%E7%A8%8B%E8%AF%A6%E8%A7%A3/"/>
    <id>https://georgechan95.github.io/2024/08/02/jvm/%E7%AC%AC%E5%8D%81%E4%B9%9D%E7%AB%A0-%E7%B1%BB%E7%9A%84%E5%8A%A0%E8%BD%BD%E8%BF%87%E7%A8%8B%E8%AF%A6%E8%A7%A3/</id>
    <published>2024-08-02T11:33:27.000Z</published>
    <updated>2024-08-08T11:42:53.482Z</updated>
    
    <content type="html"><![CDATA[<h1 id="一、概述"><a href="#一、概述" class="headerlink" title="一、概述"></a>一、概述</h1><p>在Java中数据类型分为基本数据类型和引用数据类型。<strong>基本数据类型由虚拟机预先定义，引用数据类型则需要进行类的加载。</strong></p><p>按照Java虚拟机规范，从class文件到加载到内存中的类，到类卸载出内存为止，它的整个生命周期包括如下7个阶段：</p><p><img src="https://raw.githubusercontent.com/GeorgeChan95/blogimg/master/img/2024/08/02/20240802-195737.png" alt="类的生命周期"></p><p>其中，验证、准备、解析3个部分统称为链接（Linking）</p><p>从程序中类的使用过程看</p><p><img src="https://raw.githubusercontent.com/GeorgeChan95/blogimg/master/img/2024/08/02/20240802-195857.png" alt="类的使用过程"></p><p><strong>注意: 我们所说的加载完毕包括：加载、链接、初始化三个阶段都完成之后类进入方法区中</strong></p><h1 id="二、过程一-Loading-加载-阶段"><a href="#二、过程一-Loading-加载-阶段" class="headerlink" title="二、过程一: Loading (加载)阶段"></a>二、过程一: Loading (加载)阶段</h1><h2 id="1-加载完成的操作"><a href="#1-加载完成的操作" class="headerlink" title="1. 加载完成的操作"></a>1. 加载完成的操作</h2><h3 id="1-1-加载的理解"><a href="#1-1-加载的理解" class="headerlink" title="1.1 加载的理解"></a>1.1 加载的理解</h3><p><strong>所谓加载，简而言之就是 JAVA类的字节码文件加载到机器内存中，并在内存中构建出JAVA类的原型——类模板对象。</strong></p><p>所谓类模板对象，其实就是Java类在]VM内存中的一个快照，JVM将从字节码文件中解析出的常量池、类字段、类方法等信息存储到类模板中，这样]VM在运行期便能通过类模板而获取Java类中的任意信息，能够对Java类的成员变量进行遍历，也能进行Java方法的调用。</p><p>反射的机制即基于这一基础。如果JVM没有将Java类的声明信息存储起来，则JVM在运行期也无法反射。</p><h3 id="1-2-加载完成的操作"><a href="#1-2-加载完成的操作" class="headerlink" title="1.2 加载完成的操作"></a>1.2 加载完成的操作</h3><p><strong>加载阶段，简言之，查找并加载类的二进制数据，生成Class的实例</strong></p><p>在加载类时，Java虚拟机必须完成以下3件事情：</p><ul><li>通过<em>类的全名</em>，获取类的二进制数据流。 </li><li>解析类的二进制数据流为方法区内的数据结构（Java类模型） </li><li>创建java.lang.Class类的实例，表示该类型。作为方法区这个类的各种数据的访问入口</li></ul><h2 id="2-二进制流的获取方式"><a href="#2-二进制流的获取方式" class="headerlink" title="2. 二进制流的获取方式"></a>2. 二进制流的获取方式</h2><p>对于类的二进制数据流，虚拟机可以通过多种途径产生或获得。（只要所读取的字节码符合JVM规范即可）</p><ul><li><p>虚拟机可能通过文件系统读入一个class后缀的文件（最常见)</p></li><li><p>读入jar、zip等归档数据包，提取类文件。</p></li><li><p>事先存放在数据库中的类的二进制数据</p></li><li><p>使用类似于HTTP之类的协议通过网络进行加载</p></li><li><p>在运行时生成一段class的二进制信息等</p></li><li><p>在获取到类的二进制信息后，Java虚拟机就会处理这些数据，并最终转为一个java.lang.Class的实例。</p></li></ul><p><strong>如果输入数据不是ClassFile的结构，则会抛出ClassFormatError。</strong></p><h2 id="3-类模型与Class实例的位置"><a href="#3-类模型与Class实例的位置" class="headerlink" title="3. 类模型与Class实例的位置"></a>3. 类模型与Class实例的位置</h2><h3 id="3-1-类模型的位置"><a href="#3-1-类模型的位置" class="headerlink" title="3.1 类模型的位置"></a>3.1 类模型的位置</h3><p><strong>加载的类在JVM中创建相应的类结构，类结构会存储在方法区</strong>（JDK1.8之前：永久代；JDK1.8及之后：元空间）。</p><h3 id="3-2-Class实例的位置"><a href="#3-2-Class实例的位置" class="headerlink" title="3.2 Class实例的位置"></a>3.2 Class实例的位置</h3><p>类将.class文件加载至元空间后，会<strong>在堆中创建一个Java.lang.Class 对象</strong>，用来封装类位于方法区内的数据结构，该Class对象是在加载类的过程中创建的，每个类都对应有一个Class类型的对象。</p><p><img src="https://raw.githubusercontent.com/GeorgeChan95/blogimg/master/img/2024/08/02/20240802-202716.png" alt="Class实例的位置"></p><p><strong>示例:</strong></p><p>通过Class类，获得了 java.lang.String 类的所有方法信息，并打印方法访问标识符、描述符</p><pre><code class="highlight java"><span class="comment">/**</span><span class="comment"> * 过程一：加载阶段</span><span class="comment"> *</span><span class="comment"> * 通过Class类，获得了java.lang.String类的所有方法信息，并打印方法访问标识符、描述符</span><span class="comment"> */</span><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">LoadingTest</span> &#123;    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;        <span class="keyword">try</span> &#123;            <span class="type">Class</span> <span class="variable">clazz</span> <span class="operator">=</span> Class.forName(<span class="string">&quot;java.lang.String&quot;</span>);            <span class="comment">//获取当前运行时类声明的所有方法</span>            Method[] ms = clazz.getDeclaredMethods();            <span class="keyword">for</span> (Method m : ms) &#123;                <span class="comment">//获取方法的修饰符</span>                <span class="type">String</span> <span class="variable">mod</span> <span class="operator">=</span> Modifier.toString(m.getModifiers());                System.out.print(mod + <span class="string">&quot; &quot;</span>);                <span class="comment">//获取方法的返回值类型</span>                <span class="type">String</span> <span class="variable">returnType</span> <span class="operator">=</span> m.getReturnType().getSimpleName();                System.out.print(returnType + <span class="string">&quot; &quot;</span>);                <span class="comment">//获取方法名</span>                System.out.print(m.getName() + <span class="string">&quot;(&quot;</span>);                <span class="comment">//获取方法的参数列表</span>                Class&lt;?&gt;[] ps = m.getParameterTypes();                <span class="keyword">if</span> (ps.length == <span class="number">0</span>) System.out.print(<span class="string">&#x27;)&#x27;</span>);                <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; ps.length; i++) &#123;                    <span class="type">char</span> <span class="variable">end</span> <span class="operator">=</span> (i == ps.length - <span class="number">1</span>) ? <span class="string">&#x27;)&#x27;</span> : <span class="string">&#x27;,&#x27;</span>;                    <span class="comment">//获取参数的类型</span>                    System.out.print(ps[i].getSimpleName() + end);                &#125;                System.out.println();            &#125;        &#125; <span class="keyword">catch</span> (ClassNotFoundException e) &#123;            e.printStackTrace();        &#125;    &#125;&#125;</code></pre><h2 id="4-数组类的加载"><a href="#4-数组类的加载" class="headerlink" title="4. 数组类的加载"></a>4. 数组类的加载</h2><p>创建数组类的情况稍微有些特殊，因为数组类本身并不是由类加载器负责创建，而是由JVM在运行时根据需要而直接创建的，但数组的元素类型仍然需要依靠类加载器去创建。创建数组类（下述简称A）的过程：</p><ul><li><p>如果数组的元素类型是引用类型，那么就遵循定义的加载过程递归加载和创建数组A的元素类型；</p></li><li><p>JVM使用指定的元素类型和数组维度来创建新的数组类。</p></li></ul><p>如果数组的元素类型是引用类型，数组类的可访问性就由元素类型的可访问性决定。否则数组类的可访问性将被缺省定义为public。</p><p><strong>详细解析:</strong></p><ol><li><strong>数组类的创建方式</strong>：<ul><li>与普通类不同，数组类不是由类加载器（ClassLoader）创建的。</li><li>数组类是由JVM（Java虚拟机）在运行时根据需要直接创建的。</li></ul></li><li><strong>数组元素类型的依赖</strong>：<ul><li>尽管数组类本身由JVM直接创建，数组的元素类型仍然需要类加载器来加载和创建。</li></ul></li><li><strong>创建数组类的具体过程</strong>：<ul><li>引用类型元素：<ul><li>如果数组的元素是引用类型（例如对象），则按照Java类加载的常规流程递归地加载和创建这些元素类型。</li><li>比如，创建一个<code>String</code>类型数组，JVM会首先确保<code>String</code>类已经加载。</li></ul></li><li>JVM创建数组类：<ul><li>JVM根据指定的元素类型和数组的维度来创建新的数组类。</li><li>例如，对于一个二维整型数组<code>int[][]</code>，JVM会创建一个包含整型的二维数组类。</li></ul></li></ul></li><li><strong>数组类的可访问性</strong>：<ul><li>引用类型元素：<ul><li>如果数组的元素类型是引用类型，则数组类的可访问性由元素类型的可访问性决定。</li><li>比如，如果一个数组包含的元素类是<code>private</code>的，那么这个数组类也会是<code>private</code>的。</li></ul></li><li>基本类型元素：<ul><li>如果数组的元素类型是基本类型（如<code>int</code>、<code>char</code>），数组类的可访问性默认为<code>public</code>。</li></ul></li></ul></li></ol><h1 id="三、过程二-Linking-链接-阶段"><a href="#三、过程二-Linking-链接-阶段" class="headerlink" title="三、过程二: Linking (链接)阶段"></a>三、过程二: Linking (链接)阶段</h1><h2 id="1-环节1：链接阶段之Verification（验证）"><a href="#1-环节1：链接阶段之Verification（验证）" class="headerlink" title="1. 环节1：链接阶段之Verification（验证）"></a>1. 环节1：链接阶段之Verification（验证）</h2><p>当类加载到系统后，就开始链接操作，验证是链接操作的第一步。</p><p><strong>它的目的是保证加载的字节码是合法、合理并符合规范的.</strong></p><p>验证的步骤比较复杂，实际要验证的项目也很繁多，大体上Java虚拟机需要做以下检查，如图所示。</p><p><img src="https://raw.githubusercontent.com/GeorgeChan95/blogimg/master/img/2024/08/07/20240807-082017.png" alt="验证"></p><h3 id="1-1-整体说明"><a href="#1-1-整体说明" class="headerlink" title="1.1 整体说明"></a>1.1 整体说明</h3><p>验证的内容则涵盖了类数据信息的格式验证、语义检查、字节码验证，以及符号引用验证等。</p><ul><li><strong>其中格式验证会和加载阶段一起执行。</strong>验证通过之后，类加载器才会成功将类的二进制数据信息加载到方法区中。</li><li><strong>格式验证之外的验证操作将会在方法区中进行。</strong>(这是因为类数据模板已经被加载到方法区了)</li></ul><p>链接阶段的验证虽然拖慢了加载速度，但是它避免了在字节码运行时还需要进行各种检查。（磨刀不误砍柴工）</p><h3 id="1-2-具体说明"><a href="#1-2-具体说明" class="headerlink" title="1.2 具体说明"></a>1.2 具体说明</h3><ul><li><p>格式验证：是否以魔数<code>0XCAFEBABE</code>开头，主版本和副版本号是否在当前Java虚拟机的支持范围内，数据中每一个项是否都拥有正确的长度等。 </p></li><li><p>语义检查：Java虚拟机会进行字节码的语义检查，但凡在语义上不符合规范的，虚拟机也不会给予验证通过。比如： </p></li><li><ul><li>是否所有的类都有父类的存在（在Java里，除了object外，其他类都应该有父类）</li></ul></li><li><ul><li>是否一些被定义为final的方法或者类被重写或继承了</li></ul></li><li><ul><li>非抽象类是否实现了所有抽象方法或者接口方法</li></ul></li><li><p>字节码验证：Java虚拟机还会进行字节码验证，<strong>字节码验证也是验证过程中最为复杂的一个过程。</strong>它试图通过对字节码流的分析，判断字节码是否可以被正确地执行。比如： </p><ul><li>在字节码的执行过程中，是否会跳转到一条不存在的指令</li><li>函数的调用是否传递了正确类型的参数</li><li>变量的赋值是不是给了正确的数据类型等</li></ul><p>栈映射帧（StackMapTable）就是在这个阶段，用于检测在特定的字节码处，其局部变量表和操作数栈是否有着正确的数据类型。但遗憾的是，100%准确地判断一段字节码是否可以被安全执行是无法实现的，因此，该过程只是尽可能地检查出可以预知的明显的问题。如果在这个阶段无法通过检查，虚拟机也不会正确装载这个类。但是，如果通过了这个阶段的检查，也不能说明这个类是完全没有问题的。</p><p><strong>在前面3次检查中，已经排除了文件格式错误、语义错误以及字节码的不正确性。但是依然不能确保类是没有问题的。</strong></p></li><li><p>符号引用的验证：校验器还将进符号引用的验证。Class文件在其常量池会通过字符串记录自己将要使用的其他类或者方法。因此，在验证阶段，虚拟机就会检查这些类或者方法确实是存在的，并且当前类有权限访问这些数据，如果一个需要使用类无法在系统中找到，则会抛出NoClassDefFoundError，如果一个方法无法被找到，则会抛出NoSuchMethodError。此阶段在解析环节才会执行。</p></li></ul><h2 id="2-环节2：链接阶段之Preparation（准备）"><a href="#2-环节2：链接阶段之Preparation（准备）" class="headerlink" title="2. 环节2：链接阶段之Preparation（准备）"></a>2. 环节2：链接阶段之Preparation（准备）</h2><p>准备阶段（Preparation），简言之，为类的静态变量分配内存，并将其初始化为默认值。</p><p>当一个类验证通过时，虚拟机就会进入准备阶段。在这个阶段，虚拟机就会为这个类分配相应的内存空间，并设置默认初始值。Java虚拟机为各类型变量默认的初始值如表所示。</p><table><thead><tr><th>类型</th><th>默认初始值</th></tr></thead><tbody><tr><td>byte</td><td>(byte)0</td></tr><tr><td>short</td><td>(short)0</td></tr><tr><td>int</td><td>0</td></tr><tr><td>long</td><td>0L</td></tr><tr><td>float</td><td>0.0f</td></tr><tr><td>double</td><td>0.0</td></tr><tr><td>char</td><td>\u0000</td></tr><tr><td>boolean</td><td>false</td></tr><tr><td>reference</td><td>null</td></tr></tbody></table><p>Java并不支持boolean类型，对于boolean类型，内部实现是int，由于int的默认值是0，故对应的，boolean的默认值就是false。</p><p><strong>注意</strong></p><ul><li><p><strong>这里不包含基本数据类型的字段用staticfinal修饰的情况，因为final在编译的时候就会分配了，准备阶段会显式赋值。</strong></p><pre><code class="highlight java"><span class="comment">// 一般情况：static final修饰的基本数据类型、字符串类型字面量会在准备阶段赋值</span><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">String</span> <span class="variable">str</span> <span class="operator">=</span> <span class="string">&quot;Hello world&quot;</span>;<span class="comment">// 特殊情况：static final修饰的引用类型不会在准备阶段赋值，而是在初始化阶段赋值</span><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">String</span> <span class="variable">str</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">String</span>(<span class="string">&quot;Hello world&quot;</span>);</code></pre></li><li><p>注意这里不会为实例变量分配初始化，类变量会分配在方法区中，而实例变量是会随着对象一起分配到Java堆中。 </p></li><li><p>在这个阶段并不会像初始化阶段中那样会有初始化或者代码被执行。</p></li><li><p>准备环节不会有代码执行，只是进行非final的数据类型的初始值赋值</p></li></ul><p><strong>注意：以下前3点的前提都是字段已经完成显示赋值（定义的后面已经赋了值）的前提下进行的</strong><br>1、非final修饰的静态变量会在准备阶段赋初始值，然后在初始化中的<clinit>方法中显示赋值<br>2、静态常量（基本数据类型、String类型字面量（”XXX”这种情况））在编译阶段会初始化赋值，然后在准备阶段就会显示赋值<br>3、引用数据类型的静态常量，尤其是new String(“XXX”)这种形式，都是在初始化中的<clinit>中进行显示赋值的<br>4、如果在static静态代码块中具有显示赋值操作（定义的后面没有赋值），那肯定就是在初始化中的<clinit>方法中显示赋值</p><h2 id="3-环节3：链接阶段之Resolution（解析）"><a href="#3-环节3：链接阶段之Resolution（解析）" class="headerlink" title="3. 环节3：链接阶段之Resolution（解析）"></a>3. 环节3：链接阶段之Resolution（解析）</h2><p>在准备阶段完成后，就进入了解析阶段。解析阶段（Resolution），简言之，将类、接口、字段和方法的符号引用转为直接引用。</p><p><strong>具体描述</strong>：</p><p>符号引用就是一些字面量的引用，和虚拟机的内部数据结构和和内存布局无关。比较容易理解的就是在Class类文件中，通过常量池进行了大量的符号引用。但是在程序实际运行时，只有符号引用是不够的，比如当如下println()方法被调用时，系统需要明确知道该方法的位置。</p><p><strong>举例</strong>：</p><p>输出操作System.out.println()对应的字节码：</p><pre><code class="highlight txt">invokevirtual #24 &lt;java/io/PrintStream.println&gt;</code></pre><p><img src="https://raw.githubusercontent.com/GeorgeChan95/blogimg/master/img/2024/08/07/20240807-092933.png" alt="符号引用"></p><p>以方法为例，Java虚拟机为每个类都准备了一张方法表，将其所有的方法都列在表中，当需要调用一个类的方法的时候，只要知道这个方法在方法表中的偏移量就可以直接调用该方法。<br>通过解析操作，符号引用就可以转变为目标方法在类中方法表中的位置，从而使得方法被成功调用。</p><h1 id="四、过程三-Initialization-初始化-阶段"><a href="#四、过程三-Initialization-初始化-阶段" class="headerlink" title="四、过程三: Initialization (初始化)阶段"></a>四、过程三: Initialization (初始化)阶段</h1><h2 id="1-static与final的搭配问题"><a href="#1-static与final的搭配问题" class="headerlink" title="1. static与final的搭配问题"></a>1. static与final的搭配问题</h2><p><strong>说明</strong>：使用static+ final修饰的字段的显式赋值的操作，到底是在哪个阶段进行的赋值？</p><ul><li><p>情况1：在链接阶段的准备环节赋值 </p></li><li><p>情况2：在初始化阶段<clinit>()中赋值</p></li></ul><p><strong>结论</strong>： 在<strong>链接阶段</strong>的准备环节赋值的情况：</p><ul><li><p>对于基本数据类型的字段来说，如果使用static final修饰，则显式赋值(直接赋值常量，而非调用方法)通常是在链接阶段的准备环节进行 </p></li><li><p>对于String来说，如果使用字面量的方式赋值，使用static final修饰的话，则显式赋值通常是在链接阶段的准备环节进行 </p></li><li><p>在初始化阶段<clinit>()中赋值的情况： 排除上述的在准备环节赋值的情况之外的情况。</p></li></ul><pre><code class="highlight java"><span class="keyword">public</span> <span class="keyword">static</span> <span class="type">int</span> <span class="variable">a</span> <span class="operator">=</span> <span class="number">1</span>;<span class="comment">//在初始化阶段&lt;clinit&gt;()中赋值</span><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">int</span> <span class="variable">INT_CONSTANT</span> <span class="operator">=</span> <span class="number">10</span>;<span class="comment">//在链接阶段的准备环节赋值</span><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">Integer</span> <span class="variable">INTEGER_CONSTANT1</span> <span class="operator">=</span> Integer.valueOf(<span class="number">100</span>);<span class="comment">//在初始化阶段&lt;clinit&gt;()中赋值</span><span class="keyword">public</span> <span class="keyword">static</span> <span class="type">Integer</span> <span class="variable">INTEGER_CONSTANT2</span> <span class="operator">=</span> Integer.valueOf(<span class="number">1000</span>);<span class="comment">//在初始化阶段&lt;clinit&gt;()中赋值</span><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">String</span> <span class="variable">s0</span> <span class="operator">=</span> <span class="string">&quot;helloworld0&quot;</span>;<span class="comment">//在链接阶段的准备环节赋值</span><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">String</span> <span class="variable">s1</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">String</span>(<span class="string">&quot;helloworld1&quot;</span>);<span class="comment">//在初始化阶段&lt;clinit&gt;()中赋值</span><span class="keyword">public</span> <span class="keyword">static</span> <span class="type">String</span> <span class="variable">s2</span> <span class="operator">=</span> <span class="string">&quot;helloworld2&quot;</span>; <span class="comment">// 在初始化阶段&lt;clinit&gt;()中赋值</span><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">int</span> <span class="variable">NUM1</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Random</span>().nextInt(<span class="number">10</span>);<span class="comment">//在初始化阶段&lt;clinit&gt;()中赋值</span></code></pre><p><strong>最终结论：使用static+final修饰，且显式赋值中不涉及到方法或构造器调用的基本数据类到或String类型的显式赋值，是在链接阶段的准备环节进行。</strong></p><p>对于准备阶段就完成赋值的，其字段下面的有属性ConstantValue，否则是没有属性ConstantValue的，如下：</p><p><img src="https://raw.githubusercontent.com/GeorgeChan95/blogimg/master/img/2024/08/08/20240808-125400.png" alt="准备阶段完成赋值"></p><p>在初始化中的<clinit>方法中完成赋值的，引用类型静态常量的例子我就不举了，我举一个静态变量的例子吧，如下：</p><p><img src="https://raw.githubusercontent.com/GeorgeChan95/blogimg/master/img/2024/08/08/20240808-125608.png" alt="clinit"></p><h2 id="2-clinit-的线程安全性"><a href="#2-clinit-的线程安全性" class="headerlink" title="2. clinit 的线程安全性"></a>2. clinit 的线程安全性</h2><p>对于 <code>&lt;clinit&gt;()</code> 方法的调用，也就是类的初始化，虚拟机会在内部确保其多线程环境中的安全性。</p><p>虚拟机会保证一个类的 <code>&lt;clinit&gt;()</code> 方法在多线程环境中被正确地加锁、同步，如果多个线程同时去初始化一个类，那么只会有一个线程去执行这个类的 <code>&lt;clinit&gt;()</code> 方法，其他线程都需要阻塞等待，直到活动线程执行 <code>&lt;clinit&gt;()</code> 方法完毕。</p><p>正是因为函数 <code>&lt;clinit&gt;()</code> 带锁线程安全的，因此，如果在一个类的 <code>&lt;clinit&gt;()</code> 方法中有耗时很长的操作，就可能造成多个线程阻塞，引发死锁。并且这种死锁是很难发现的，因为看起来它们并没有可用的锁信息。</p><p>如果之前的线程成功加载了类，则等在队列中的线程就没有机会再执行 <code>&lt;clinit&gt;()</code> 方法了。那么，当需要使用这个类时，虚拟机会直接返回给它已经准备好的信息。(这也说明了类的初始化只会执行一次)</p><h2 id="3-类的初始化情况：主动使用vs被动使用"><a href="#3-类的初始化情况：主动使用vs被动使用" class="headerlink" title="3. 类的初始化情况：主动使用vs被动使用"></a>3. 类的初始化情况：主动使用vs被动使用</h2><p>Java程序对类的使用分为两种：主动使用和被动使用。</p><h3 id="3-1-主动使用"><a href="#3-1-主动使用" class="headerlink" title="3.1 主动使用"></a>3.1 主动使用</h3><p>Class只有在必须要首次使用的时候才会被装载，Java虚拟机不会无条件地装载Class类型。Java虚拟机规定，一个类或接口在初次使用前，必须要进行初始化。这里指的“使用”，是指主动使用，主动使用只有下列几种情况：（即：如果出现如下的情况，则会对类进行初始化操作。而初始化操作之前的加载、验证、准备已经完成。</p><ul><li><p><strong>实例化</strong>：当创建一个类的实例时，比如使用new关键字，或者通过反射、克隆、反序列化。 </p><pre><code class="highlight java"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ActiveUse1</span> &#123;    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;        <span class="comment">// 1. 使用new关键字</span>        <span class="type">Order</span> <span class="variable">order</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Order</span>();    &#125;    <span class="comment">/**</span><span class="comment">     * 2. 使用new关键字</span><span class="comment">     * 序列化的过程</span><span class="comment">     */</span>    <span class="meta">@Test</span>    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">test1</span><span class="params">()</span> &#123;        <span class="type">ObjectOutputStream</span> <span class="variable">oos</span> <span class="operator">=</span> <span class="literal">null</span>;        <span class="keyword">try</span> &#123;            oos = <span class="keyword">new</span> <span class="title class_">ObjectOutputStream</span>(<span class="keyword">new</span> <span class="title class_">FileOutputStream</span>(<span class="string">&quot;order.dat&quot;</span>));            oos.writeObject(<span class="keyword">new</span> <span class="title class_">Order</span>());        &#125; <span class="keyword">catch</span> (IOException e) &#123;            e.printStackTrace();        &#125; <span class="keyword">finally</span> &#123;            <span class="keyword">try</span> &#123;                <span class="keyword">if</span> (oos != <span class="literal">null</span>)                    oos.close();            &#125; <span class="keyword">catch</span> (IOException e) &#123;                e.printStackTrace();            &#125;        &#125;    &#125;    <span class="comment">/**</span><span class="comment">     * 3.反序列化的过程：（验证）</span><span class="comment">     */</span>    <span class="meta">@Test</span>    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">test2</span><span class="params">()</span> &#123;        <span class="type">ObjectInputStream</span> <span class="variable">ois</span> <span class="operator">=</span> <span class="literal">null</span>;        <span class="keyword">try</span> &#123;            ois = <span class="keyword">new</span> <span class="title class_">ObjectInputStream</span>(<span class="keyword">new</span> <span class="title class_">FileInputStream</span>(<span class="string">&quot;order.dat&quot;</span>));            <span class="type">Order</span> <span class="variable">order</span> <span class="operator">=</span> (Order) ois.readObject();        &#125; <span class="keyword">catch</span> (IOException e) &#123;            e.printStackTrace();        &#125; <span class="keyword">catch</span> (ClassNotFoundException e) &#123;            e.printStackTrace();        &#125; <span class="keyword">finally</span> &#123;            <span class="keyword">try</span> &#123;                <span class="keyword">if</span> (ois != <span class="literal">null</span>)                    ois.close();            &#125; <span class="keyword">catch</span> (IOException e) &#123;                e.printStackTrace();            &#125;        &#125;    &#125;&#125;<span class="keyword">class</span> <span class="title class_">Order</span> <span class="keyword">implements</span> <span class="title class_">Serializable</span>&#123;    <span class="keyword">static</span> &#123;        System.out.println(<span class="string">&quot;Order类的初始化过程&quot;</span>);    &#125;    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">method</span><span class="params">()</span>&#123;        System.out.println(<span class="string">&quot;Order method()....&quot;</span>);    &#125;&#125;</code></pre></li><li><p><strong>静态方法</strong>：当调用类的静态方法时，即当使用了字节码invokestatic指令。 </p><pre><code class="highlight java"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ActiveUse1</span> &#123;    <span class="comment">/**</span><span class="comment">     * 4. 静态方法调用</span><span class="comment">     */</span>    <span class="meta">@Test</span>    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">test3</span><span class="params">()</span>&#123;        Order.method();    &#125;&#125;<span class="keyword">class</span> <span class="title class_">Order</span> <span class="keyword">implements</span> <span class="title class_">Serializable</span>&#123;    <span class="keyword">static</span> &#123;        System.out.println(<span class="string">&quot;Order类的初始化过程&quot;</span>);    &#125;    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">method</span><span class="params">()</span>&#123;        System.out.println(<span class="string">&quot;Order method()....&quot;</span>);    &#125;&#125;</code></pre></li><li><p><strong>静态字段</strong>：当使用类、接口的静态字段时（final修饰特殊考虑），比如，使用getstatic或者putstatic指令。（对应访问变量、赋值变量操作）</p><ul><li><p>类使用静态字段触发初始化</p><pre><code class="highlight java"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ActiveUse2</span> &#123;    <span class="meta">@Test</span>    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">test1</span><span class="params">()</span>&#123;        System.out.println(User.num); <span class="comment">// 执行了 User 的初始化</span>        System.out.println(User.num1); <span class="comment">// 不执行 User 的初始化, 因为num1为static final修饰的常量</span>        System.out.println(User.num2); <span class="comment">// 执行了 User 的初始化</span>    &#125;&#125;<span class="keyword">class</span> <span class="title class_">User</span>&#123;    <span class="keyword">static</span>&#123;        System.out.println(<span class="string">&quot;User类的初始化过程&quot;</span>);    &#125;    <span class="keyword">public</span> <span class="keyword">static</span> <span class="type">int</span> <span class="variable">num</span> <span class="operator">=</span> <span class="number">1</span>;    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">int</span> <span class="variable">num1</span> <span class="operator">=</span> <span class="number">2</span>;    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">int</span> <span class="variable">num2</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Random</span>().nextInt(<span class="number">10</span>);&#125;</code></pre></li><li><p>接口的初始化</p><pre><code class="highlight java"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ActiveUse2</span> &#123;    <span class="meta">@Test</span>    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">test2</span><span class="params">()</span>&#123;<span class="comment">//        System.out.println(CompareA.NUM1);</span>        System.out.println(CompareA.NUM2);    &#125;&#125;<span class="keyword">interface</span> <span class="title class_">CompareA</span>&#123;    <span class="comment">// 测试接口的初始化</span>    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">Thread</span> <span class="variable">t</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Thread</span>()&#123;        &#123;            System.out.println(<span class="string">&quot;CompareA的初始化&quot;</span>);        &#125;    &#125;;    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">int</span> <span class="variable">NUM1</span> <span class="operator">=</span> <span class="number">1</span>; <span class="comment">// 不经过clinit防范</span>    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">int</span> <span class="variable">NUM2</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Random</span>().nextInt(<span class="number">10</span>); <span class="comment">// 经过clinit方法,触发接口初始化</span>&#125;</code></pre></li></ul></li><li><p><strong>反射</strong>：当使用java.lang.reflect包中的方法反射类的方法时。比如：Class.forName(“com.atguigu.java.Test”) </p></li><li><p><strong>继承</strong>：当初始化子类时，如果发现其父类还没有进行过初始化，则需要先触发其父类的初始化。</p></li></ul><p>  当Java虚拟机初始化一个类时，要求它的所有父类都已经被初始化，但是这条规则并不适用于接口。可以使用 <code>-XX:+TraceClassLoading</code> 参数配置查看类加载路径</p><ul><li><p>在初始化一个类时，并不会先初始化它所实现的接口</p></li><li><p>在初始化一个接口时，并不会先初始化它的父接口</p></li><li><p>因此，一个父接口并不会因为它的子接口或者实现类的初始化而初始化。只有当程序首次使用特定接口的静态字段时，才会导致该接口的初始化。</p></li><li><p>default方法：如果一个接口定义了default方法，那么直接实现或者间接实现该接口的类的初始化，该接口要在其之前被初始化。 </p><pre><code class="highlight java"><span class="keyword">interface</span> <span class="title class_">CompareB</span> &#123;    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">Thread</span> <span class="variable">t</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Thread</span>() &#123;        &#123;            System.out.println(<span class="string">&quot;CompareB的初始化&quot;</span>);        &#125;    &#125;;    <span class="keyword">public</span> <span class="keyword">default</span> <span class="keyword">void</span> <span class="title function_">method1</span><span class="params">()</span>&#123;        System.out.println(<span class="string">&quot;你好！&quot;</span>);    &#125;&#125;<span class="keyword">class</span> <span class="title class_">Father</span> &#123;    <span class="keyword">static</span> &#123;        System.out.println(<span class="string">&quot;Father类的初始化过程&quot;</span>);    &#125;&#125;<span class="keyword">class</span> <span class="title class_">Son</span> <span class="keyword">extends</span> <span class="title class_">Father</span> <span class="keyword">implements</span> <span class="title class_">CompareB</span>&#123;    <span class="keyword">static</span> &#123;        System.out.println(<span class="string">&quot;Son类的初始化过程&quot;</span>);    &#125;    <span class="keyword">public</span> <span class="keyword">static</span> <span class="type">int</span> <span class="variable">num</span> <span class="operator">=</span> <span class="number">1</span>;&#125;<span class="meta">@Test</span><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">test2</span><span class="params">()</span> &#123;    System.out.println(Son.num);&#125;<span class="comment">// 打印结果:</span>Father类的初始化过程CompareB的初始化Son类的初始化过程<span class="number">1</span></code></pre></li><li><p>main方法：当虚拟机启动时，用户需要指定一个要执行的主类（包含main()方法的那个类），虚拟机会先初始化这个主类。</p></li></ul><p>  JVM启动的时候通过引导类加载器加载一个初始类。这个类在调用public static void main(String[])方法之前被链接和初始化。这个方法的执行将依次导致所需的类的加载，链接和初始化。</p><ul><li>MethodHandle：当初次调用MethodHandle实例时，初始化该MethodHandle指向的方法所在的类。（涉及解析REF getStatic、REF_putStatic、REF invokeStatic方法句柄对应的类）</li></ul><h3 id="3-2-被动使用"><a href="#3-2-被动使用" class="headerlink" title="3.2 被动使用"></a>3.2 被动使用</h3><p>除了以上的情况属于主动使用，其他的情况均属于被动使用。<strong>被动使用不会引起类的初始化</strong>。</p><p>也就是说：<strong>并不是在代码中出现的类，就一定会被加载或者初始化。</strong>如果不符合主动使用的条件，类就不会初始化。</p><ul><li><p><strong>静态字段</strong>：当通过子类引用父类的静态变量，不会导致子类初始化，只有真正声明这个字段的类才会被初始化。 </p><pre><code class="highlight java"><span class="keyword">class</span> <span class="title class_">Parent</span>&#123;    <span class="keyword">static</span>&#123;        System.out.println(<span class="string">&quot;Parent的初始化过程&quot;</span>);    &#125;    <span class="keyword">public</span> <span class="keyword">static</span> <span class="type">int</span> <span class="variable">num</span> <span class="operator">=</span> <span class="number">1</span>;&#125;<span class="keyword">class</span> <span class="title class_">Child</span> <span class="keyword">extends</span> <span class="title class_">Parent</span>&#123;    <span class="keyword">static</span>&#123;        System.out.println(<span class="string">&quot;Child的初始化过程&quot;</span>);    &#125;&#125;<span class="meta">@Test</span><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">test1</span><span class="params">()</span>&#123;    System.out.println(Child.num);&#125;<span class="comment">// 打印结果: </span>Parent的初始化过程<span class="number">1</span></code></pre></li><li><p><strong>数组定义</strong>：通过数组定义类引用，不会触发此类的初始化 </p><pre><code class="highlight java"><span class="meta">@Test</span><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">test2</span><span class="params">()</span>&#123;    Parent[] parents = <span class="keyword">new</span> <span class="title class_">Parent</span>[<span class="number">10</span>];    System.out.println(parents.getClass()); <span class="comment">// class [Lcom.atguigu.java1.Parent;</span>    System.out.println(parents.getClass().getSuperclass()); <span class="comment">// class java.lang.Object</span>    parents[<span class="number">0</span>] = <span class="keyword">new</span> <span class="title class_">Parent</span>(); <span class="comment">// Parent的初始化过程</span>    parents[<span class="number">1</span>] = <span class="keyword">new</span> <span class="title class_">Parent</span>(); <span class="comment">// 没有打印任何东西,类仅初始化一次</span>&#125;</code></pre></li><li><p><strong>引用常量</strong>：引用常量不会触发此类或接口的初始化。因为常量在链接阶段就已经被显式赋值了。 </p><pre><code class="highlight java"><span class="keyword">interface</span> <span class="title class_">SerialA</span>&#123;    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">Thread</span> <span class="variable">t</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Thread</span>() &#123;        &#123;            System.out.println(<span class="string">&quot;SerialA的初始化&quot;</span>);        &#125;    &#125;;    <span class="type">int</span> <span class="variable">ID</span> <span class="operator">=</span> <span class="number">1</span>; <span class="comment">// 接口中默认就是常量, 不需要初始化</span>    <span class="type">int</span> <span class="variable">ID1</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Random</span>().nextInt(<span class="number">10</span>); <span class="comment">//此时的赋值操作需要在&lt;clinit&gt;()中执行</span>&#125;<span class="meta">@Test</span><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">test2</span><span class="params">()</span>&#123;    System.out.println(SerialA.ID); <span class="comment">// 打印: 1, 没有触发接口初始化</span>    System.out.println(SerialA.ID1); <span class="comment">// 打印: SerialA的初始化, 触发接口初始化</span>&#125;</code></pre></li><li><p><strong>loadClass方法</strong>：调用ClassLoader类的loadClass()方法加载一个类，并不是对类的主动使用，不会导致类的初始化。 </p><pre><code class="highlight java"><span class="keyword">class</span> <span class="title class_">Person</span>&#123;    <span class="keyword">static</span>&#123;        System.out.println(<span class="string">&quot;Person类的初始化&quot;</span>);    &#125;    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">int</span> <span class="variable">NUM</span> <span class="operator">=</span> <span class="number">1</span>;<span class="comment">//在链接过程的准备环节就被赋值为1了。</span>    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">int</span> <span class="variable">NUM1</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Random</span>().nextInt(<span class="number">10</span>);<span class="comment">//此时的赋值操作需要在&lt;clinit&gt;()中执行</span>&#125;<span class="meta">@Test</span><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">test3</span><span class="params">()</span>&#123;    <span class="keyword">try</span> &#123;        <span class="type">Class</span> <span class="variable">clazz</span> <span class="operator">=</span> ClassLoader.getSystemClassLoader().loadClass(<span class="string">&quot;com.atguigu.java1.Person&quot;</span>);    &#125; <span class="keyword">catch</span> (ClassNotFoundException e) &#123;        e.printStackTrace();    &#125;&#125;</code></pre></li></ul><blockquote><p>**扩展: **  -XX:+TraceClassLoading：追踪打印类的加载信息</p></blockquote><h1 id="五、过程四-类的Using-使用"><a href="#五、过程四-类的Using-使用" class="headerlink" title="五、过程四: 类的Using (使用)"></a>五、过程四: 类的Using (使用)</h1><p>任何一个类型在使用之前都必须经历过完整的加载、链接和初始化3个类加载步骤。一旦一个类型成功经历过这3个步骤之后，便“厉事俱备只欠东风”，就等着开发者使用了。</p><p>开发人员可以在程序中访问和调用它的静态类成员信息（比如：静态字段、静态方法），或者使用new关键字为其创建对象实例。</p><h1 id="六、过程五-类的Unloading-卸载"><a href="#六、过程五-类的Unloading-卸载" class="headerlink" title="六、过程五: 类的Unloading (卸载)"></a>六、过程五: 类的Unloading (卸载)</h1><h2 id="1-类、类的加载器、类的实例之间的引用关系"><a href="#1-类、类的加载器、类的实例之间的引用关系" class="headerlink" title="1. 类、类的加载器、类的实例之间的引用关系"></a>1. 类、类的加载器、类的实例之间的引用关系</h2><p>在类加载器的内部实现中，用一个Java集合来存放所加载类的引用。另一方面，一个Class对象总是会引用它的类加载器，调用Class对象的getClassLoader()方法，就能获得它的类加载器。由此可见，代表某个类的Class实例与其类的加载器之间为双向关联关系。</p><p>一个类的实例总是引用代表这个类的Class对象。在Object类中定义了getClass()方法，这个方法返回代表对象所属类的Class对象的引用。此外，所有的java类都有一个静态属性class，它引用代表这个类的Class对象。</p><h2 id="2-类的生命周期"><a href="#2-类的生命周期" class="headerlink" title="2. 类的生命周期"></a>2. 类的生命周期</h2><p>当Sample类被加载、链接和初始化后，它的生命周期就开始了。当代表Sample类的Class对象不再被引用，即不可触及时，Class对象就会结束生命周期，Sample类在方法区内的数据也会被卸载，从而结束Sample类的生命周期。</p><p><strong>一个类何时结束生命周期，取决于代表它的Class对象何时结束生命周期。</strong></p><h2 id="3-具体例子"><a href="#3-具体例子" class="headerlink" title="3. 具体例子"></a>3. 具体例子</h2><p><img src="https://raw.githubusercontent.com/GeorgeChan95/blogimg/master/img/2024/08/08/20240808-193450.png" alt="类的卸载"></p><p>loader1变量和obj变量间接引用代表Sample类的Class对象，而objClass变量则直接引用它。</p><p>如果程序运行过程中，将上图左侧三个引用变量都置为null，此时Sample对象结束生命周期，MyClassLoader对象结束生命周期，代表Sample类的Class对象也结束生命周期，Sample类在方法区内的二进制数据被卸载。</p><p>当再次有需要时，会检查Sample类的Class对象是否存在，如果存在会直接使用，不再重新加载；如果不存在Sample类会被重新加载，在Java虚拟机的堆区会生成一个新的代表Sample类的Class实例（可以通过哈希码查看是否是同一个实例）</p><h2 id="4-类的卸载"><a href="#4-类的卸载" class="headerlink" title="4. 类的卸载"></a>4. 类的卸载</h2><ol><li>启动类加载器加载的类型在整个运行期间是不可能被卸载的（jvm和jls规范）</li><li>被系统类加载器和扩展类加载器加载的类型在运行期间不太可能被卸载，因为系统类加载器实例或者扩展类的实例基本上在整个运行期间总能直接或者间接的访问的到，其达到unreachable的可能性极小。</li><li>被开发者自定义的类加载器实例加载的类型只有在很简单的上下文环境中才能被卸载，而且一般还要借助于强制调用虚拟机的垃圾收集功能才可以做到。可以预想，稍微复杂点的应用场景中（比如：很多时候用户在开发自定义类加载器实例的时候采用缓存的策略以提高系统性能），被加载的类型在运行期间也是几乎不太可能被卸载的（至少卸载的时间是不确定的）。</li></ol><p>综合以上三点，一个已经加载的类型被卸载的几率很小至少被卸载的时间是不确定的。同时我们可以看的出来，开发者在开发代码时候，不应该对虚拟机的类型卸载做任何假设的前提下，来实现系统中的特定功能。</p><h2 id="回顾：方法区的垃圾回收"><a href="#回顾：方法区的垃圾回收" class="headerlink" title="回顾：方法区的垃圾回收"></a>回顾：方法区的垃圾回收</h2><p>方法区的垃圾收集主要回收两部分内容：<strong>常量池中废弃的常量和不再使用的类型</strong>。</p><p>HotSpot虚拟机对常量池的回收策略是很明确的，只要常量池中的常量没有被任何地方引用，就可以被回收。</p><p>判定一个常量是否“废弃”还是相对简单，而要判定一个类型是否属于“不再使用的类”的条件就比较苛刻了。需要同时满足下面三个条件：</p><ul><li><p>该类所有的实例都已经被回收。也就是Java堆中不存在该类及其任何派生子类的实例。</p></li><li><p>加载该类的类加载器已经被回收。这个条件除非是经过精心设计的可替换类加载器的场景，如OSGi、JSP的重加载等，否则通常是很难达成的。</p></li><li><p>该类对应的java.lang.Class对象没有在任何地方被引用，无法在任何地方通过反射访问该类的方法.</p></li></ul><p>Java虚拟机被允许对满足上述三个条件的无用类进行回收，这里说的仅仅是“被允许”，而并不是和对象一样，没有引用了就必然会回收。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;一、概述&quot;&gt;&lt;a href=&quot;#一、概述&quot; class=&quot;headerlink&quot; title=&quot;一、概述&quot;&gt;&lt;/a&gt;一、概述&lt;/h1&gt;&lt;p&gt;在Java中数据类型分为基本数据类型和引用数据类型。&lt;strong&gt;基本数据类型由虚拟机预先定义，引用数据类型则需要进行类的</summary>
      
    
    
    
    <category term="JVM" scheme="https://georgechan95.github.io/categories/JVM/"/>
    
    
    <category term="jvm" scheme="https://georgechan95.github.io/tags/jvm/"/>
    
    <category term="java" scheme="https://georgechan95.github.io/tags/java/"/>
    
  </entry>
  
  <entry>
    <title>第十八章-字节码指令集与解析指令</title>
    <link href="https://georgechan95.github.io/2024/08/01/jvm/%E7%AC%AC%E5%8D%81%E5%85%AB%E7%AB%A0-%E5%AD%97%E8%8A%82%E7%A0%81%E6%8C%87%E4%BB%A4%E9%9B%86%E4%B8%8E%E8%A7%A3%E6%9E%90%E4%B8%BE%E4%BE%8B/"/>
    <id>https://georgechan95.github.io/2024/08/01/jvm/%E7%AC%AC%E5%8D%81%E5%85%AB%E7%AB%A0-%E5%AD%97%E8%8A%82%E7%A0%81%E6%8C%87%E4%BB%A4%E9%9B%86%E4%B8%8E%E8%A7%A3%E6%9E%90%E4%B8%BE%E4%BE%8B/</id>
    <published>2024-07-31T17:40:02.000Z</published>
    <updated>2024-08-02T11:42:40.195Z</updated>
    
    <content type="html"><![CDATA[<h1 id="一、概述"><a href="#一、概述" class="headerlink" title="一、概述"></a>一、概述</h1><ul><li>java字节码对于虚拟机，就好像汇编语言对于计算机，属于基本执行指令。</li><li>Java 虚拟机的指令由一个字节长度的、代表着某种特定操作含义的数字(称为操作码，Opcode)以及跟随其后的零至多个代表此操作所需参数(称为操作数, Operands而构成。由于 Java 虚拟机采用面向操作数栈而不是寄存器的结构，所以大多数的指令都不包含操作数，只有一个操作码。</li><li>由于限制了 Java 虚拟机操作码的长度为一个字节(即 0~255)，这意味着指令集的操作码总数不可能超过256 条。</li><li>官方文档:<a href="https://docs.oracle.com/javase/specs/jvms/se8/html/jvms-6.html">https://docs.oracle.com/javase/specs/jvms/se8/html/jvms-6.html</a></li><li>熟悉虚拟机的指令对于动态字节码生成、反编译class文件、Class文件修补都有着非常重要的价值。因此，阅读字节码作为了解 Java 虚拟机的基础技能，需要熟练掌握常见指令。</li></ul><h2 id="1-执行模型"><a href="#1-执行模型" class="headerlink" title="1. 执行模型"></a>1. 执行模型</h2><p>如果不考虑异常处理的话，那么Java虚拟机的解释器可以使用下面这个伪代码当做最基本的执行模型来理解</p><pre><code class="highlight java"><span class="keyword">do</span>&#123;    自动计算PC寄存器的值加<span class="number">1</span>;    根据PC寄存器的指示位置，从字节码流中取出操作码;    <span class="keyword">if</span>(字节码存在操作数) 从字节码流中取出操作数;    执行操作码所定义的操作;&#125;<span class="keyword">while</span>(字节码长度&gt;<span class="number">0</span>);</code></pre><h2 id="2-字节码与数据类型"><a href="#2-字节码与数据类型" class="headerlink" title="2. 字节码与数据类型"></a>2. 字节码与数据类型</h2><p>在Java虚拟机的指令集中，大多数的指令都包含了其操作所对应的数据类型信息。例如，iload指令用于从局部变量表中加载int型的数据到操作数栈中，而fload指令加载的则是float类型的数据。</p><p>对于大部分与数据类型相关的字节码指令，它们的操作码助记符中都有特殊的字符来表明专门为哪种数据类型服务：</p><ul><li><p>i代表对int类型的数据操作，</p></li><li><p>l代表long</p></li><li><p>s代表short</p></li><li><p>b代表byte</p></li><li><p>c代表char</p></li><li><p>f代表float</p></li><li><p>d代表double</p></li></ul><p>也有一些指令的助记符中没有明确地指明操作类型的字母，如arraylength指令，它没有代表数据类型的特殊字符，但操作数永远只能是一个数组类型的对象。</p><p>还有另外一些指令，如无条件跳转指令goto则是与数据类型无关的。</p><p>大部分的指令都没有支持整数类型byte、char和short，甚至没有任何指令支持boolean类型。编译器会在编译期或运行期将byte和short类型的数据带符号扩展（Sign-Extend）为相应的int类型数据，将boolean和char类型数据零位扩展（Zero-Extend）为相应的int类型数据。与之类似，在处理boolean、byte、short和char类型的数组时，也会转换为使用对应的int类型的字节码指令来处理。因此，大多数对于boolean、byte、short和char类型数据的操作，实际上都是使用相应的int类型作为运算类型。</p><h2 id="3-指令分析"><a href="#3-指令分析" class="headerlink" title="3. 指令分析"></a>3. 指令分析</h2><p>由于完全介绍和学习这些指令需要花费大量时间。为了让大家能够更快地熟悉和了解这些基本指令，这里将JVM中的字节码指令集按用途大致分成9类。</p><ul><li><p>加载与存储指令</p></li><li><p>算术指令</p></li><li><p>类型转换指令</p></li><li><p>对象的创建与访问指令</p></li><li><p>方法调用与返回指令</p></li><li><p>操作数栈管理指令</p></li><li><p>比较控制指令</p></li><li><p>异常处理指令</p></li><li><p>同步控制指令</p></li></ul><p>（说在前面）在做值相关操作时：</p><ul><li><p>一个指令，可以从局部变量表、常量池、堆中对象、方法调用、系统调用中等取得数据，这些数据（可能是值，可能是对象的引用）被压入操作数栈。</p></li><li><p>一个指令，也可以从操作数栈中取出一到多个值（pop多次），完成赋值、加减乘除、方法传参、系统调用等等操作。</p></li></ul><h1 id="二、加载与存储指令"><a href="#二、加载与存储指令" class="headerlink" title="二、加载与存储指令"></a>二、加载与存储指令</h1><h2 id="1-作用"><a href="#1-作用" class="headerlink" title="1. 作用"></a>1. 作用</h2><p>加载和存储指令用于将数据从栈帧的局部变量表和操作数栈之间来回传递。</p><h2 id="2-常用指令"><a href="#2-常用指令" class="headerlink" title="2. 常用指令"></a>2. 常用指令</h2><ol><li>【局部变量压栈指令】将一个局部变量加载到操作数栈：xload、xload_<n>（其中x为i、l、f、d、a，n为0到3）</li><li>【常量入栈指令】将一个常量加载到操作数栈：bipush、sipush、ldc、ldc_w、ldc2_w、aconst_null、iconst_m1、iconst_<i>、lconst_<l>、fconst_<f>、dconst_<d></li><li>【出栈装入局部变量表指令】将一个数值从操作数栈存储到局部变量表：xstore、xstore_<n>（其中x为i、l、f、d、a，n为0到3）；xastore（其中x为i、l、f、d、a、b、c、s）</li><li>扩充局部变量表的访问索引的指令：wide。</li></ol><p>上面所列举的指令助记符中，有一部分是以尖括号结尾的（例如iload_<n>）。这些指令助记符实际上代表了一组指令（例如iload_<n>代表了<code>iload_0、iload_1、iload_2</code>和<code>iload_3</code>这几个指令）。这几组指令都是某个带有一个操作数的通用指令（例如iload）的特殊形式，对于这若干组特殊指令来说，它们表面上没有操作数，不需要进行取操作数的动作，但操作数都隐含在指令中。</p><p>除此之外，它们的语义与原生的通用指令完全一致（例如<code>iload_0</code>的语义与操作数为0时的iload指令语义完全一致）。在尖括号之间的字母指定了指令隐含操作数的数据类型，<n>代表非负的整数，<i>代表是int类型数据，<l>代表long类型，<f>代表float类型，<d>代表double类型。</p><p>操作byte、char、short和boolean类型数据时，经常用int类型的指令来表示。</p><h2 id="3-再谈操作数栈与局部变量表"><a href="#3-再谈操作数栈与局部变量表" class="headerlink" title="3. 再谈操作数栈与局部变量表"></a>3. 再谈操作数栈与局部变量表</h2><h3 id="3-1-操作数栈（Operand-Stacks）"><a href="#3-1-操作数栈（Operand-Stacks）" class="headerlink" title="3.1 操作数栈（Operand Stacks）"></a>3.1 操作数栈（Operand Stacks）</h3><p>我们知道，Java字节码是Java虚拟机所使用的指令集。因此，它与Java虚拟机基于栈的计算模型是密不可分的。在解释执行过程中，每当为Java方法分配栈桢时，Java虚拟机往往需要开辟一块额外的空间作为操作数栈，来存放计算的操作数以及返回结果。</p><p>具体来说便是：执行每一条指令之前，Java虚拟机要求该指令的操作数已被压入操作数栈中。在执行指令时，Java虚拟机会将该指令所需的操作数弹出，并且将指令的结果重新压入栈中。</p><p><img src="https://raw.githubusercontent.com/GeorgeChan95/blogimg/master/img/2024/07/25/20240725-134709.png" alt="操作数栈1"></p><p>以加法指令iadd为例。假设在执行该指令前，栈顶的两个元素分别为int值1和int值2，那么iadd指令将弹出这两个int，并将求得的和int值3压入栈中。</p><p><img src="https://raw.githubusercontent.com/GeorgeChan95/blogimg/master/img/2024/07/25/20240725-134734.png" alt="操作数栈2"></p><p>由于iadd指令只消耗栈顶的两个元素，因此，对于离栈顶距离为2的元素，即图中的问号，iadd 指令并不关心它是否存在，更加不会对其进行修改。</p><h3 id="3-2-局部变量表（Local-Variables）"><a href="#3-2-局部变量表（Local-Variables）" class="headerlink" title="3.2 局部变量表（Local Variables）"></a>3.2 局部变量表（Local Variables）</h3><p>Java方法栈桢的另外一个重要组成部分则是局部变量区，字节码程序可以将计算的结果缓存在局部变量区之中。</p><p>实际上，Java虚拟机将局部变量区当成一个数组，依次存放this指针（<strong>仅非静态方法</strong>），所传入的参数，以及字节码中的局部变量。</p><p>和操作数栈一样，long类型以及double类型的值将占据两个单元，其余类型仅占据一个单元。</p><p><img src="https://raw.githubusercontent.com/GeorgeChan95/blogimg/master/img/2024/07/25/20240725-210722.png" alt="不同类型占局部变量表长度"></p><p>举例：</p><pre><code class="highlight java"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">foo</span><span class="params">(<span class="type">long</span> l, <span class="type">float</span> f)</span> &#123;    &#123;        <span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> e;    &#125;    &#123;        <span class="type">String</span> <span class="variable">s</span> <span class="operator">=</span> <span class="string">&quot;Hello, World&quot;</span>;    &#125;&#125;</code></pre><p>对应的图示：</p><p><img src="https://raw.githubusercontent.com/GeorgeChan95/blogimg/master/img/2024/07/25/20240725-210848.png" alt="局部变量表"></p><p>this表示当前类的引用，l 和 f 的类型的值占两个槽位，i 和 s 变量由于分别在各自代码块中，没有共同的生命周期，所以占同一个槽位（即槽位复用）</p><p>在栈帧中，与性能调优关系最为密切的部分就是局部变量表。局部变量表中的变量也是重要的垃圾回收根节点，只要被局部变量表中直接或间接引用的对象都不会被回收。</p><h3 id="3-3-局部变量压栈指令"><a href="#3-3-局部变量压栈指令" class="headerlink" title="3.3 局部变量压栈指令"></a>3.3 局部变量压栈指令</h3><ul><li><code>iload</code> 从局部变量中装载int类型值</li><li><code>lload</code> 从局部变量中装载long类型值</li><li><code>fload</code> 从局部变量中装载float类型值</li><li><code>dload</code> 从局部变量中装载double类型值</li><li><code>aload</code> 从局部变量中装载引用类型值（refernce）</li><li><code>iload_0</code> ,<code>iload_1</code>,<code>iload_2</code>,<code>iload_3</code> 将局部变量表下标为0, 1, 2, 3的 <code>int类型</code> 的值,加载到操作数栈中</li><li><code>lload_0</code> ,<code>lload_1</code> ,<code>lload_2</code> ,<code>lload_3</code> 将局部变量表下标为0, 1, 2, 3 的 <code>long类型</code> 的值,加载到操作数栈中</li><li><code>fload_0</code>, <code>fload_1</code>, <code>fload_2</code>, <code>fload_3</code> 将局部变量表下标为0, 1, 2, 3 的 <code>float类型</code> 的值,加载到操作数栈中</li><li><code>dload_0</code>, <code>dload_1</code>, <code>dload_2</code>, <code>dload_3</code> 将局部变量表下标为0, 1, 2, 3 的 <code>double类型</code> 的值,加载到操作数栈中</li><li><code>aload_0</code>, <code>aload_1</code>, <code>aload_2</code>, <code>aload_3</code> 将局部变量表下标为0, 1, 2, 3 的 <code>引用类型</code> 的值,加载到操作数栈中</li><li><code>iaload</code> 将 int 型数组指定索引的值推送至栈顶, 执行该指令后，将从操作数栈出栈2个参数arrayref和index</li><li><code>laload</code> 将 long 型数组指定索引的值推送至栈顶</li><li><code>faload</code> 将 float 型数组指定索引的值推送至栈顶</li><li><code>daload</code> 将 double 型数组指定索引的值推送至栈顶</li><li><code>aaload</code> 将引用型数组指定索引的值推送至栈顶</li><li><code>baload</code> 将byte类型或boolean类型值数组指定索引的值推送至栈顶</li><li><code>caload</code> 将char型数组指定索引的值推送至栈顶</li><li><code>saload</code> 将 short 型数组指定索引的值推送至栈顶</li></ul><h4 id="3-3-1-局部变量压栈指令剖析"><a href="#3-3-1-局部变量压栈指令剖析" class="headerlink" title="3.3.1 局部变量压栈指令剖析"></a>3.3.1 局部变量压栈指令剖析</h4><p>局部变量压栈指令将给定的局部变量表中的数据压入操作数栈, 这类指令大体可以分为：</p><ul><li><p><code>xload_&lt;n&gt;</code>（x为i、l、f、d、a，n为0到3）</p></li><li><p><code>xload</code>（x为i、l、f、d、a）</p></li></ul><p><strong>说明：</strong>在这里，x的取值表示数据类型。</p><p>指令xload_n表示将第n个局部变量压入操作数栈，比如iload_1、fload_0、aload_0等指令。其中aload_n表示将一个对象引用压栈。</p><p>指令xload通过指定参数的形式，把局部变量压入操作数栈，当使用这个命令时，表示局部变量的数量可能超过了4个，比如指令iload、fload等。</p><p><strong>举例：</strong></p><pre><code class="highlight java"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">load</span><span class="params">(<span class="type">int</span> num, Object obj, <span class="type">long</span> count, <span class="type">boolean</span> flag, <span class="type">short</span>[] arr)</span> &#123;    System.out.println(num);    System.out.println(obj);    System.out.println(count);    System.out.println(flag);    System.out.println(arr);&#125;</code></pre><p><strong>字节码执行过程：</strong></p><p><img src="https://raw.githubusercontent.com/GeorgeChan95/blogimg/master/img/2024/07/26/20240726-093706.png" alt="字节码执行过程"></p><h3 id="3-4-常量入栈指令"><a href="#3-4-常量入栈指令" class="headerlink" title="3.4 常量入栈指令"></a>3.4 常量入栈指令</h3><ul><li><code>aconst_null</code> 将null对象引用压入栈</li><li><code>iconst_m1</code> 将int类型常量-1压入栈</li><li><code>iconst_0</code>, <code>iconst_1</code>, <code>iconst_2</code>,<code>iconst_3</code>,<code>iconst_4</code>,<code>iconst_5</code> 将int类型常量 0, 1, 2, 3, 4, 5 压入栈</li><li><code>lconst_0</code>, <code>lconst_1</code>, 将long类型常量0, 1压入栈</li><li><code>fconst_0</code>, <code>fconst_1</code> 将float类型常量0, 1压入栈</li><li><code>dconst_0</code>, <code>dconst_1</code> 将double类型常量0, 1压入栈</li><li><code>bipush</code> 将一个8位带符号整数压入栈(-128~127)</li><li><code>sipush</code> 将16位带符号整数压入栈(-32768~32767)</li><li><code>ldc index</code> 加载常量池中的无符号byte类型的常量到操作数栈，‌index 最大值是 255, 索引指向的数据类型可以是： <code>int</code>、 <code>float</code> 或 <code>String</code></li><li><code>ldc_w index</code>  如果常量池的大小超过255，‌或者需要加载的常量值超过一个byte可以表示的范围，‌这时就需要使用 <code>ldc_w</code> 指令。‌<code>ldc_w</code> 指令可以加载常量池中的宽索引项到操作数栈，‌从而支持更大的常量值。‌索引指向的数据类型可以是： <code>int</code>、 <code>float</code> 或 <code>String</code></li><li><code>ldc2_w index</code> 将long或double型常量值从常量池中推送至栈顶（宽索引）（分两次压入，因为 long, double 是 8 个字节）索引指向的数据类型可以是： <code>int</code>、 <code>float</code> 或 <code>String</code></li></ul><h4 id="3-4-1-常量入栈常用指令集"><a href="#3-4-1-常量入栈常用指令集" class="headerlink" title="3.4.1 常量入栈常用指令集"></a>3.4.1 常量入栈常用指令集</h4><table><thead><tr><th>xconst_n</th><th>范围</th><th>xconst_null</th><th>xconst_m1</th><th>xconst_0</th><th>xconst_1</th><th>xconst_2</th><th>xconst_3</th><th>xconst_4</th><th>xconst_5</th></tr></thead><tbody><tr><td><strong>iconst_n</strong></td><td>[-1, 5]</td><td></td><td>iconst_m1</td><td>iconst_0</td><td>iconst_1</td><td>iconst_2</td><td>iconst_3</td><td>iconst_4</td><td>iconst_5</td></tr><tr><td><strong>lconst_n</strong></td><td>0, 1</td><td></td><td></td><td>lconst_0</td><td>lconst_1</td><td></td><td></td><td></td><td></td></tr><tr><td><strong>fconst_n</strong></td><td>0, 1, 2</td><td></td><td></td><td>fconst_0</td><td>fconst_1</td><td>fconst_2</td><td></td><td></td><td></td></tr><tr><td><strong>dconst_n</strong></td><td>0, 1</td><td></td><td></td><td>dconst_0</td><td>dconst_1</td><td></td><td></td><td></td><td></td></tr><tr><td><strong>aconst_n</strong></td><td>null, String literal, Class literal</td><td>aconst_null</td><td></td><td></td><td></td><td></td><td></td><td></td><td></td></tr><tr><td><strong>bipush</strong></td><td>一个字节有符号整数，[-2<sup>7</sup>, 2<sup>7</sup> - 1]，即[-128, 127]</td><td></td><td></td><td></td><td></td><td></td><td></td><td></td><td></td></tr><tr><td><strong>sipush</strong></td><td>两个字节有符号整数，[-2<sup>15</sup>, 2<sup>15</sup> - 1]，即[-32768, 32767]</td><td></td><td></td><td></td><td></td><td></td><td></td><td></td><td></td></tr><tr><td><strong>ldc</strong></td><td>1个字节(8位)无符号数，-2<sup>8</sup> - 1, 即不超过255</td><td></td><td></td><td></td><td></td><td></td><td></td><td></td><td></td></tr><tr><td><strong>ldc_w</strong></td><td>宽索引, 接收两个8位参数，能支持的索引范围大于ldc, 索引范围比ldc更大</td><td></td><td></td><td></td><td></td><td></td><td></td><td></td><td></td></tr><tr><td><strong>ldc2_w</strong></td><td>宽索引，long或double</td><td></td><td></td><td></td><td></td><td></td><td></td><td></td><td></td></tr></tbody></table><h4 id="3-4-2-常量入栈指令剖析"><a href="#3-4-2-常量入栈指令剖析" class="headerlink" title="3.4.2 常量入栈指令剖析"></a>3.4.2 常量入栈指令剖析</h4><p>常量入栈指令的功能是将常数压入操作数栈，根据数据类型和入栈内容的不同，又可以分为 const 系列、push 系列和 ldc 指令。</p><p>指令const系列：用于对特定的常量入栈，入栈的常量隐含在指令本身里。指令有：<code>iconst_&lt;i&gt;（i从-1到5）、lconst_&lt;l&gt;（l从0到1）、fconst_&lt;f&gt;（f从0到2）、dconst_&lt;d&gt;（d从0到1）、aconst_null</code>。比如，</p><ul><li><p><code>iconst_m1</code> 将-1压入操作数栈；</p></li><li><p><code>iconst_x</code>（x为0到5）将x压入栈；</p></li><li><p><code>lconst_0</code>、<code>lconst_1</code>分别将长整数0和1压入栈；</p></li><li><p><code>fconst_0</code>、<code>fconst_1</code>、<code>fconst_2</code> 分别将浮点数0、1、2压入栈；</p></li><li><p><code>dconst_0</code> 和 <code>dconst_1</code> 分别将double型0和1压入栈；</p></li><li><p><code>aconst_null</code> 将null压入操作数栈；</p></li></ul><p>从指令的命名上不难找出规律，指令助记符的第一个字符总是喜欢表示数据类型，i表示整数，l表示长整数，f表示浮点数，d表示双精度浮点，习惯上用a表示对象引用。如果指令隐含操作的参数，会以下划线形式给出。</p><p>指令push系列：主要包括bipush和sipush。它们的区别在于接收数据类型的不同，bipush接收8位整数作为参数，sipush接收16位整数，它们都将参数压入栈。</p><p>指令ldc系列：如果以上指令都不能满足需求，那么可以使用万能的</p><ul><li><p>ldc 指令，它可以接收一个8位的参数，该参数指向常量池中的int、float或者String的索引，将指定的内容压入堆栈。</p></li><li><p>类似的还有ldc_w，它接收两个8位参数，能支持的索引范围大于ldc。</p></li><li><p>如果要压入的元素是long或者double类型的，则使用ldc2_w指令，使用方式都是类似的</p></li></ul><p>总结如下：</p><table><thead><tr><th>类型</th><th>常数指令</th><th>范围</th></tr></thead><tbody><tr><td>int(boolean,byte,char,short)</td><td>iconst</td><td>[-1, 5]</td></tr><tr><td></td><td>bipush</td><td>[-128, 127]</td></tr><tr><td></td><td>sipush</td><td>[-32768, 32767]</td></tr><tr><td></td><td>ldc</td><td>any int value</td></tr><tr><td>long</td><td>lconst</td><td>0, 1</td></tr><tr><td></td><td>ldc</td><td>any long value</td></tr><tr><td>float</td><td>fconst</td><td>0, 1, 2</td></tr><tr><td></td><td>ldc</td><td>any float value</td></tr><tr><td>double</td><td>dconst</td><td>0, 1</td></tr><tr><td></td><td>ldc</td><td>any double value</td></tr><tr><td>reference</td><td>aconst</td><td>null</td></tr><tr><td></td><td>ldc</td><td>String literal, Class literal</td></tr></tbody></table><p><img src="https://raw.githubusercontent.com/GeorgeChan95/blogimg/master/img/2024/07/26/20240726-105330.png" alt="字节码指令示例1"></p><p><img src="https://raw.githubusercontent.com/GeorgeChan95/blogimg/master/img/2024/07/26/20240726-105342.png" alt="字节码指令示例2"></p><h3 id="3-5-出栈装入局部变量表指令"><a href="#3-5-出栈装入局部变量表指令" class="headerlink" title="3.5 出栈装入局部变量表指令"></a>3.5 出栈装入局部变量表指令</h3><ul><li><p><code>istore</code> 将int类型值存入局部变量</p></li><li><p><code>lstore</code> 将long类型值存入局部变量</p></li><li><p><code>fstore</code> 将float类型值存入局部变量</p></li><li><p><code>dstore</code> 将double类型值存入局部变量</p></li><li><p><code>astore</code> 将将引用类型或returnAddress类型值存入局部变量</p></li><li><p><code>istore_0</code>, <code>istore_1</code>, <code>istore_2</code>, <code>istore_3</code> 分别将int类型值存入局部变量0, 1, 2, 3索引位置</p></li><li><p><code>lstore_0</code>, <code>lstore_1</code>, <code>lstore_2</code>, <code>lstore_3</code> 将long类型值存入局部变量0, 1, 2, 3 索引位置</p></li><li><p><code>fstore_0</code>, <code>fstore_1</code>, <code>fstore_2</code>, <code>fstore_3</code>, 将float类型值存入局部变量0, 1, 2, 3 索引位置</p></li><li><p><code>dstore_0</code>, <code>dstore_1</code>, <code>dstore_2</code>, <code>dstore_3</code>, 将double类型值存入局部变量0</p></li><li><p><code>astore_0</code>, <code>astore_1</code>, <code>astore_2</code>, <code>astore_3</code> 将引用类型或returnAddress类型值存入局部变量0, 1, 2, 3 索引位置</p></li><li><p><code>iastore</code> 将int类型值存入数组中</p></li><li><p><code>lastore</code> 将long类型值存入数组中</p></li><li><p><code>fastore</code> 将float类型值存入数组中</p></li><li><p><code>dastore</code> 将double类型值存入数组中</p></li><li><p><code>aastore</code> 将引用类型值存入数组中</p></li><li><p><code>bastore</code> 将byte类型或者boolean类型值存入数组中</p></li><li><p><code>castore</code> 将char类型值存入数组中</p></li><li><p><code>sastore</code> 将short类型值存入数组中</p></li><li><p>wide指令</p></li><li><p>wide 使用附加字节扩展局部变量索引</p></li></ul><h4 id="3-5-1-出栈装入局部变量表指令剖析"><a href="#3-5-1-出栈装入局部变量表指令剖析" class="headerlink" title="3.5.1 出栈装入局部变量表指令剖析"></a>3.5.1 出栈装入局部变量表指令剖析</h4><p>出栈装入局部变量表指令用于将操作数栈中栈顶元素弹出后，装入局部变量表的指定位置，用于给局部变量赋值。这类指令主要以store的形式存在，比如<code>xstore（x为i、l、f、d、a）、xstore_n（x为i、l、f、d、a，n为0至3）</code>。</p><ul><li><p>其中，指令istore_n将从操作数栈中弹出一个整数，并把它值给局部变量索引n位置。</p></li><li><p>指令xstore由于没有隐含参数信息，故需要提供一个byte类型的参数类指定目标局部变量表的位置。</p></li></ul><p>说明：一般说来，类似像store这样的命令需要带一个参数，用来指明将弹出的元素放在局部变量表的第几个位置。但是，为了尽可能压缩指令大小，使用专门的istore_1指令表示将弹出的元素放置在局部变量表第1个位置。类似的还有istore_0、istore_2、istore_3，它们分别表示从操作数栈顶弹出一个元素，存放在局部变量表第0、2、3个位置。由于局部变量表前几个位置总是非常常用，因此这种做法虽然增加了指令数量，但是可以大大压缩生成的字节码的体积。如果局部变量表很大，需要存储的槽位大于3，那么可以使用istore指令，外加一个参数，用来表示需要存放的槽位位置。</p><p><img src="https://raw.githubusercontent.com/GeorgeChan95/blogimg/master/img/2024/07/26/20240726-110910.png" alt="字节码指令执行过程"></p><h1 id="三、算数指令"><a href="#三、算数指令" class="headerlink" title="三、算数指令"></a>三、算数指令</h1><h2 id="1-作用-1"><a href="#1-作用-1" class="headerlink" title="1. 作用"></a>1. 作用</h2><p>算术指令用于对两个操作数栈上的值进行某种特定运算，并把结果重新压入操作数栈。</p><h2 id="2-分类"><a href="#2-分类" class="headerlink" title="2. 分类"></a>2. 分类</h2><p>大体上算术指令可以分为两种：对<strong>整型数据进行运算</strong>的指令与对<strong>浮点类型数据进行运算</strong>的指令。</p><h2 id="3-byte、short、char和boolean类型说明"><a href="#3-byte、short、char和boolean类型说明" class="headerlink" title="3. byte、short、char和boolean类型说明"></a>3. byte、short、char和boolean类型说明</h2><p>在每一大类中，都有针对Java虚拟机具体数据类型的专用算术指令。但没有直接支持byte、short、char和boolean类型的算术指令，对于这些数据的运算，都使用int类型的指令来处理。此外，在处理boolean、byte、short和char类型的数组时，也会转换为使用对应的int类型的字节码指令来处理。</p><p><img src="https://raw.githubusercontent.com/GeorgeChan95/blogimg/master/img/2024/07/26/20240726-111216.png" alt="java虚拟机中实际类型与运算类型"></p><h2 id="4-运算时的溢出"><a href="#4-运算时的溢出" class="headerlink" title="4. 运算时的溢出"></a>4. 运算时的溢出</h2><p>数据运算可能会导致溢出，例如两个很大的正整数相加，结果可能是一个负数。其实Java虚拟机规范并无明确规定过整型数据溢出的具体结果，仅规定了在处理整型数据时，只有除法指令以及求余指令中当出现除数为0时会导致虚拟机抛出异常ArithmeticException。</p><h2 id="5-运算模式"><a href="#5-运算模式" class="headerlink" title="5. 运算模式"></a>5. 运算模式</h2><p><strong>向最接近数舍入模式</strong>：JVM要求在进行浮点数计算时，所有的运算结果都必须舍入到适当的精度，非精确结果必须舍入为可被表示的最接近的精确值，如果有两种可表示的形式与该值一样接近，将优先选择最低有效位为零的；</p><p><strong>向零舍入模式</strong>：将浮点数转换为整数时，采用该模式，该模式将在目标数值类型中选择一个最接近但是不大于原值的数字作为最精确的舍入结果；</p><h2 id="6-NaN值使用"><a href="#6-NaN值使用" class="headerlink" title="6. NaN值使用"></a>6. NaN值使用</h2><p>当一个操作产生溢出时，将会使用有符号的无穷大表示，如果某个操作结果没有明确的数学定义的话，将会使用NaN值来表示。而且所有使用NaN值作为操作数的算术操作，结果都会返回NaN；</p><p><img src="https://raw.githubusercontent.com/GeorgeChan95/blogimg/master/img/2024/07/26/20240726-111920.png" alt="无穷大与NaN"></p><h2 id="7-所有算术指令"><a href="#7-所有算术指令" class="headerlink" title="7. 所有算术指令"></a>7. 所有算术指令</h2><p><strong>整数运算</strong></p><ul><li><code>iadd</code> 执行int类型的加法</li><li><code>ladd</code> 执行long类型的加法</li><li><code>isub</code> 执行int类型的减法</li><li><code>lsub</code> 执行long类型的减法</li><li><code>imul</code> 执行int类型的乘法</li><li><code>lmul</code> 执行long类型的乘法</li><li><code>idiv</code> 执行int类型的除法</li><li><code>ldiv</code> 执行long类型的除法</li><li><code>irem</code> 计算int类型除法的余数</li><li><code>lrem</code> 计算long类型除法的余数</li><li><code>ineg</code> 对一个int类型值进行取反操作</li><li><code>lneg</code> 对一个long类型值进行取反操作</li><li><code>iinc</code> 把一个常量值加到一个int类型的局部变量上</li></ul><p><strong>移位操作</strong></p><ul><li><code>ishl</code> 执行int类型的向左移位操作</li><li><code>lshl</code> 执行long类型的向左移位操作</li><li><code>ishr</code> 执行int类型的向右移位操作</li><li><code>lshr</code> 执行long类型的向右移位操作</li><li><code>iushr</code> 执行int类型的向右逻辑移位操作</li><li><code>lushr</code> 执行long类型的向右逻辑移位操作</li></ul><p><strong>按位布尔运算</strong></p><ul><li><code>iand</code> 对int类型值进行“逻辑与”操作</li><li><code>land</code> 对long类型值进行“逻辑与”操作</li><li><code>ior</code> 对int类型值进行“逻辑或”操作</li><li><code>lor</code> 对long类型值进行“逻辑或”操作</li><li><code>ixor</code> 对int类型值进行“逻辑异或”操作</li><li><code>lxor</code> 对long类型值进行“逻辑异或”操作</li></ul><p><strong>浮点运算</strong></p><ul><li><code>fadd</code> 执行float类型的加法</li><li><code>dadd</code> 执行double类型的加法</li><li><code>fsub</code> 执行float类型的减法</li><li><code>dsub</code> 执行double类型的减法</li><li><code>fmul</code> 执行float类型的乘法</li><li><code>dmul</code> 执行double类型的乘法</li><li><code>fdiv</code> 执行float类型的除法</li><li><code>ddiv</code> 执行double类型的除法</li><li><code>frem</code> 计算float类型除法的余数</li><li><code>drem</code> 计算double类型除法的余数</li><li><code>fneg</code> 将一个float类型的数值取反</li><li><code>dneg</code> 将一个double类型的数值取反</li></ul><p><strong>算术指令集</strong></p><table><thead><tr><th>算数指令</th><th>int(boolean,byte,char,short)</th><th>long</th><th>float</th><th>double</th></tr></thead><tbody><tr><td>加法指令</td><td>iadd</td><td>ladd</td><td>fadd</td><td>dadd</td></tr><tr><td>减法指令</td><td>isub</td><td>lsub</td><td>fsub</td><td>dsub</td></tr><tr><td>乘法指令</td><td>imul</td><td>lmul</td><td>fmul</td><td>dmul</td></tr><tr><td>除法指令</td><td>idiv</td><td>ldiv</td><td>fdiv</td><td>ddiv</td></tr><tr><td>求余指令</td><td>irem</td><td>lrem</td><td>frem</td><td>drem</td></tr><tr><td>取反指令</td><td>ineg</td><td>lneg</td><td>fneg</td><td>dneg</td></tr><tr><td>自增指令</td><td>iinc</td><td></td><td></td><td></td></tr><tr><td>位运算指令</td><td>按位或指令</td><td>ior</td><td>lor</td><td></td></tr><tr><td></td><td>按位或指令</td><td>ior</td><td>lor</td><td></td></tr><tr><td></td><td>按位与指令</td><td>iand</td><td>land</td><td></td></tr><tr><td></td><td>按位异或指令</td><td>ixor</td><td>lxor</td><td></td></tr><tr><td>比较指令</td><td></td><td>lcmp</td><td>fcmpg &#x2F; fcmpl</td><td>dcmpg &#x2F; dcmpl</td></tr></tbody></table><p><strong>示例1</strong></p><pre><code class="highlight java"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">add</span><span class="params">()</span> &#123;<span class="type">byte</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">15</span>;<span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> <span class="number">8</span>;<span class="type">int</span> <span class="variable">k</span> <span class="operator">=</span> i + j;&#125;</code></pre><p><img src="https://raw.githubusercontent.com/GeorgeChan95/blogimg/master/img/2024/07/27/20240727-145225.png" alt="1"></p><p><img src="https://raw.githubusercontent.com/GeorgeChan95/blogimg/master/img/2024/07/27/20240727-145233.png" alt="2"></p><p><img src="https://raw.githubusercontent.com/GeorgeChan95/blogimg/master/img/2024/07/27/20240727-145245.png" alt="3"></p><p><img src="https://raw.githubusercontent.com/GeorgeChan95/blogimg/master/img/2024/07/27/20240727-145254.gif" alt="4"></p><p><strong>示例2</strong></p><pre><code class="highlight java"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;<span class="type">int</span> <span class="variable">x</span> <span class="operator">=</span> <span class="number">500</span>;<span class="type">int</span> <span class="variable">y</span> <span class="operator">=</span> <span class="number">100</span>;<span class="type">int</span> <span class="variable">a</span> <span class="operator">=</span> x / y;<span class="type">int</span> <span class="variable">b</span> <span class="operator">=</span> <span class="number">50</span>;System.out.println(a + b);&#125;</code></pre><p><img src="https://raw.githubusercontent.com/GeorgeChan95/blogimg/master/img/2024/07/27/20240727-145932.png" alt="1"></p><p><img src="https://raw.githubusercontent.com/GeorgeChan95/blogimg/master/img/2024/07/27/20240727-145944.png" alt="2"></p><h1 id="四、类型转换指令"><a href="#四、类型转换指令" class="headerlink" title="四、类型转换指令"></a>四、类型转换指令</h1><h2 id="1-类型转换指令说明"><a href="#1-类型转换指令说明" class="headerlink" title="1. 类型转换指令说明"></a>1. 类型转换指令说明</h2><ul><li>类型转换指令可以将两种不同的数值类型进行相互转换。</li><li>这些转换操作一般用于实现用户代码中的显式类型转换操作，或者用来处理字节码指令集中数据类型相关指令无法与数据类型一一对应的问题。</li></ul><p><strong>宽化类型转换指令</strong></p><ul><li><code>i2l</code> 把int类型的数据转化为long类型</li><li><code>i2f</code> 把int类型的数据转化为float类型</li><li><code>i2d</code> 把int类型的数据转化为double类型</li><li><code>l2f</code> 把long类型的数据转化为float类型</li><li><code>l2d</code> 把long类型的数据转化为double类型</li><li><code>f2d</code> 把float类型的数据转化为double类型</li></ul><p><strong>窄化类型转换</strong></p><ul><li><code>i2b</code> 把int类型的数据转化为byte类型</li><li><code>i2c</code> 把int类型的数据转化为char类型</li><li><code>i2s</code> 把int类型的数据转化为short类型</li><li><code>l2i</code> 把long类型的数据转化为int类型</li><li><code>f2i</code> 把float类型的数据转化为int类型</li><li><code>f2l</code> 把float类型的数据转化为long类型</li><li><code>d2i</code> 把double类型的数据转化为int类型</li><li><code>d2l</code> 把double类型的数据转化为long类型</li><li><code>d2f</code> 把double类型的数据转化为float类型</li></ul><p><strong>类型转换指令集</strong></p><table><thead><tr><th></th><th><strong>byte</strong></th><th><strong>char</strong></th><th><strong>short</strong></th><th><strong>int</strong></th><th><strong>long</strong></th><th><strong>float</strong></th><th><strong>double</strong></th></tr></thead><tbody><tr><td><strong>int</strong></td><td>i2b</td><td>i2c</td><td>i2s</td><td>-</td><td>i2l</td><td>i2f</td><td>i2d</td></tr><tr><td><strong>long</strong></td><td>l2i   i2b</td><td>l2i   i2c</td><td>l2i   i2s</td><td>l2i</td><td>-</td><td>l2f</td><td>l2d</td></tr><tr><td><strong>float</strong></td><td>f2i   i2b</td><td>f2i   i2c</td><td>f2i   i2s</td><td>f2i</td><td>f2l</td><td>-</td><td>f2d</td></tr><tr><td><strong>double</strong></td><td>d2i   i2b</td><td>d2i   i2c</td><td>d2i   i2s</td><td>d2i</td><td>d2l</td><td>d2f</td><td>-</td></tr></tbody></table><h2 id="2-宽化类型转换指令"><a href="#2-宽化类型转换指令" class="headerlink" title="2. 宽化类型转换指令"></a>2. 宽化类型转换指令</h2><p><strong>宽化类型转换( Widening Numeric Conversions)</strong></p><h3 id="2-1-转换规则"><a href="#2-1-转换规则" class="headerlink" title="2.1 转换规则"></a>2.1 转换规则</h3><p>Java虚拟机直接支持以下数值的宽化类型转换（ widening numeric conversion,小范围类型向大范围类型的安全转换）。也就是说，并不需要指令执行，包括</p><ul><li><p>从int类型到long、float或者 double类型。对应的指令为：i21、i2f、i2d </p></li><li><p>从long类型到float、 double类型。对应的指令为：l2f、l2d </p></li><li><p>从float类型到double类型。对应的指令为：f2d</p></li></ul><p>简化为：int–&gt;long–&gt;float-&gt; double</p><p><a href="https://juejin.cn/post/7206123045855969337">float的表示范围为什么比long大?</a></p><h3 id="2-2-精度损失问题"><a href="#2-2-精度损失问题" class="headerlink" title="2.2 精度损失问题"></a>2.2 精度损失问题</h3><ul><li><p>宽化类型转换是不会因为超过目标类型最大值而丢失信息的，例如，从int转换到long,或者从int转换到double,都不会丢失任何信息，转换前后的值是精确相等的。 </p></li><li><p>从int、long类型数值转换到float，或者long类型数值转换到double时，将可能发生精度丢失一一可能丢失掉几个最低有效位上的值，转换后的浮点数值是根据IEEE754最接近含入模式所得到的正确整数值。</p></li></ul><p><strong>尽管宽化类型转换实际上是可能发生精度丢失的，但是这种转换永远不会导致Java虚拟机抛出运行时异常</strong></p><h3 id="2-3-补充说明"><a href="#2-3-补充说明" class="headerlink" title="2.3 补充说明"></a>2.3 补充说明</h3><p>从byte、char和 short类型到int类型的宽化类型转换实际上是不存在的。对于byte类型转为int,虚拟机并没有做实质性的转化处理，只是简单地通过操作数栈交換了两个数据。而将byte转为long时，使用的是i2l,可以看到在内部，byte在这里已经等同于int类型处理，类似的还有 short类型，这种处理方式有两个特点：</p><ul><li>一方面可以减少实际的数据类型，如果为 short和byte都准备一套指令，那么指令的数量就会大増，而虚拟机目前的设计上，只愿意使用一个字节表示指令，因此指令总数不能超过256个，为了节省指令资源，将 short和byte当做int处理也在情理之中。</li><li>另一方面，由于局部变量表中的槽位固定为32位，无论是byte或者 short存入局部变量表，都会占用32位空间。从这个角度说，也没有必要特意区分这几种数据类型。</li></ul><h2 id="3-窄化类型转换指令"><a href="#3-窄化类型转换指令" class="headerlink" title="3. 窄化类型转换指令"></a>3. 窄化类型转换指令</h2><p><strong>窄化类型转换( Narrowing Numeric Conversion)</strong></p><h3 id="3-1-转换规则"><a href="#3-1-转换规则" class="headerlink" title="3.1 转换规则"></a>3.1 转换规则</h3><p>Java虚拟机也直接支持以下窄化类型转换：</p><ul><li><p>从主int类型至byte、 short或者char类型。对应的指令有：i2b、i2c、i2s </p></li><li><p>从long类型到int类型。对应的指令有：l2i </p></li><li><p>从float类型到int或者long类型。对应的指令有：f2i、f2l </p></li><li><p>从double类型到int、long或者float类型。对应的指令有：d2i、d2l、d2f</p></li></ul><h3 id="3-2-精度损失问题"><a href="#3-2-精度损失问题" class="headerlink" title="3.2 精度损失问题"></a>3.2 精度损失问题</h3><p>窄化类型转换可能会导致转换结果具备不同的正负号、不同的数量级，因此，转换过程很可能会导致数值丢失精度。</p><p>尽管数据类型窄化转换可能会发生上限溢出、下限溢出和精度丢失等情况，但是Java虚拟机规范中明确规定数值类型的窄化转换指令永远不可能导致虚拟机抛出运行时异常</p><h3 id="3-3-补充说明"><a href="#3-3-补充说明" class="headerlink" title="3.3 补充说明"></a>3.3 补充说明</h3><p>当将一个浮点值窄化转换为整数类型T(T限于int或long类型之一)的时候，将遵循以下转换规则：</p><ul><li><p>如果浮点值是NaN,那转换结果就是int或long类型的0. </p></li><li><p>如果浮点值不是无穷大的话，浮点值使用IEEE754的向零含入模式取整，获得整数值v。如果v在目标类型T(int或long)的表示范围之内，那转换结果就是v。否则，将根据v的符号，转换为T所能表示的最大或者最小正数</p></li></ul><p>当将一个double类型窄化转换为float类型时，将遵循以下转换规则，通过向最接近数舍入模式舍入一个可以使用float类型表示的数字。最后结果根据下面这3条规则判断：</p><ul><li><p>如果转换结果的绝对值太小而无法使用float来表示，将返回float类型的正负零 </p></li><li><p>如果转换结果的绝对值太大而无法使用float来表示，将返回float类型的正负无穷大。 </p></li><li><p>对于double类型的NaN值将按规定转换为float类型的NaN值。</p></li></ul><h1 id="五、对象的创建与访问指令"><a href="#五、对象的创建与访问指令" class="headerlink" title="五、对象的创建与访问指令"></a>五、对象的创建与访问指令</h1><p>Java是面向对象的程序设计语言，虚拟机平台从字节码层面就对面向对象做了深层次的支持。有一系列指令专门用于对象操作，可进一步细分为创建指令、字段访问指令、数组操作指令、类型检查指令。</p><ul><li><strong>对象操作指令</strong><ul><li><code>new</code> 创建一个新对象</li><li><code>getfield</code> 从对象中获取字段</li><li><code>putfield</code> 设置对象中字段的值</li><li><code>getstatic</code> 从类中获取静态字段</li><li><code>putstatic</code> 设置类中静态字段的值</li><li><code>checkcast</code> 确定对象为所给定的类型。后跟目标类，判断栈顶元素是否为目标类 &#x2F; 接口的实例。如果不是便抛出异常</li><li><code>instanceof</code> 判断对象是否为给定的类型。后跟目标类，判断栈顶元素是否为目标类 &#x2F; 接口的实例。是则压入 1，否则压入 0</li></ul></li><li><strong>数组操作指令</strong><ul><li><code>newarray</code> 分配数据成员类型为基本数据类型的新数组</li><li><code>anewarray</code> 分配数据成员类型为引用类型的新数组</li><li><code>arraylength</code> 获取数组长度</li><li><code>multianewarray</code> 分配新的多维数组</li></ul></li></ul><h2 id="1-创建指令"><a href="#1-创建指令" class="headerlink" title="1. 创建指令"></a>1. 创建指令</h2><table><thead><tr><th>创建指令</th><th>含义</th></tr></thead><tbody><tr><td>new</td><td>创建类实例</td></tr><tr><td>newarray</td><td>创建基本类型数组</td></tr><tr><td>anewarray</td><td>创建引用类型数组</td></tr><tr><td>multilanewarra</td><td>创建多维数组</td></tr></tbody></table><p>虽然类实例和数组都是对象，但Java虚拟机对类实例和数组的创建与操作使用了不同的字节码指令：</p><ul><li>创建类实例的指令： <ul><li>创建类实例的指令：new</li><li>它接收一个操作数，为指向常量池的索引，表示要创建的类型，执行完成后，将对象的引用压入栈。</li></ul></li><li>创建数组的指令： <ul><li>创建数组的指令：newarray、anewarray、multianewarray</li><li>上述创建指令可以用于创建对象或者数组，由于对象和数组在Java中的广泛使用，这些指令的使用频率也非常高。</li></ul></li></ul><h2 id="2-字段访问指令"><a href="#2-字段访问指令" class="headerlink" title="2. 字段访问指令"></a>2. 字段访问指令</h2><table><thead><tr><th>字段访问指令</th><th>含义</th></tr></thead><tbody><tr><td>getstatic、putstatic</td><td>访问类字段（static字段，或者称为类变量）的指令</td></tr><tr><td>getfield、 putfield</td><td>访问类实例字段（非static字段，或者称为实例变量）的指令</td></tr></tbody></table><p>对象创建后，就可以通过对象访问指令获取对象实例或数组实例中的字段或者数组元素。</p><ul><li><p>访问类字段（static字段，或者称为类变量）的指令：getstatic、putstatic</p></li><li><p>访问类实例字段（非static字段，或者称为实例变量）的指令：getfield、putfield</p></li></ul><p>举例：以getstatic指令为例，它含有一个操作数，为指向常量池的Fieldref索引，它的作用就是获取Fieldref指定的对象或者值，并将其压入操作数栈。</p><pre><code class="highlight java"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setOrderId</span><span class="params">()</span>&#123;    <span class="type">Order</span> <span class="variable">order</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Order</span>();    order.id = <span class="number">1001</span>;    System.out.println(order.id);    Order.name = <span class="string">&quot;ORDER&quot;</span>;    System.out.println(Order.name);&#125;<span class="comment">// Order类代码如下:</span><span class="keyword">class</span> <span class="title class_">Order</span>&#123;    <span class="type">int</span> id;    <span class="keyword">static</span> String name;&#125;</code></pre><p>setOrderId() 方法对应的字节码指令：</p><pre><code class="highlight shell"> 0 new #11 &lt;com/atguigu/java/Order&gt; 3 dup 4 invokespecial #12 &lt;com/atguigu/java/Order.&lt;init&gt; : ()V&gt; 7 astore_1 8 aload_1 9 sipush 100112 putfield #13 &lt;com/atguigu/java/Order.id : I&gt;15 getstatic #8 &lt;java/lang/System.out : Ljava/io/PrintStream;&gt;18 aload_119 getfield #13 &lt;com/atguigu/java/Order.id : I&gt;22 invokevirtual #14 &lt;java/io/PrintStream.println : (I)V&gt;25 ldc #15 &lt;ORDER&gt;27 putstatic #16 &lt;com/atguigu/java/Order.name : Ljava/lang/String;&gt;30 getstatic #8 &lt;java/lang/System.out : Ljava/io/PrintStream;&gt;33 getstatic #16 &lt;com/atguigu/java/Order.name : Ljava/lang/String;&gt;36 invokevirtual #10 &lt;java/io/PrintStream.println : (Ljava/lang/String;)V&gt;39 return</code></pre><p><img src="https://raw.githubusercontent.com/GeorgeChan95/blogimg/master/img/2024/07/28/20240728-104906.png" alt="字节码指令执行过程"></p><h2 id="3-数组操作指令"><a href="#3-数组操作指令" class="headerlink" title="3. 数组操作指令"></a>3. 数组操作指令</h2><p>数组操作指令主要有：xastore和xaload指令。具体为：</p><ul><li><p>把一个数组元素加载到操作数栈的指令：baload、caload、saload、iaload、laload、faload、daload、aaload</p></li><li><p>将一个操作数栈的值存储到数组元素中的指令：bastore、castore、sastore、iastore、lastore、fastore、dastore、aastore</p></li></ul><table><thead><tr><th>数组指令</th><th>byte(boolean)</th><th>char</th><th>short</th><th>long</th><th>long</th><th>float</th><th>double</th><th>reference</th></tr></thead><tbody><tr><td><strong>xaload</strong></td><td>baload</td><td>caload</td><td>saload</td><td>iaload</td><td>laload</td><td>faload</td><td>daload</td><td>aaload</td></tr><tr><td><strong>xastore</strong></td><td>bastore</td><td>castore</td><td>sastore</td><td>iastore</td><td>lastore</td><td>fastore</td><td>dastore</td><td>aastore</td></tr></tbody></table><p>取数组长度的指令：<code>arraylength</code>。该指令弹出栈顶的数组元素，获取数组的长度，将长度压入栈。</p><p>指令 <code>xaload</code> 表示将数组的元素压栈，比如saload、caload分别表示压入short数组和char数组。指令xaload在执行时，要求操作数中栈顶元素为数组索引 i，栈顶顺位第2个元素为数组引用 a，该指令会弹出栈顶这两个元素，并将 a[i] 重新压入栈。</p><p><code>xastore</code> 则专门针对数组操作，以 iastore 为例，它用于给一个int数组的给定索引赋值。在iastore执行前，操作数栈顶需要以此准备3个元素：值、索引、数组引用，iastore会弹出这3个值，并将值赋给数组中指定索引的位置。</p><h2 id="4-类型检查指令"><a href="#4-类型检查指令" class="headerlink" title="4. 类型检查指令"></a>4. 类型检查指令</h2><p>检查类实例或数组类型的指令：instanceof、checkcast。</p><ul><li>指令 <code>instanceof</code> 用来判断给定对象是否是某一个类的实例，它会将判断结果压入操作数栈</li><li>指令 <code>checkcast</code> 用于检查类型强制转换是否可以进行。如果可以进行，那么checkcast指令不会改变操作数栈，否则它会抛出ClassCastException异常</li></ul><table><thead><tr><th>类型检查指令</th><th>含义</th></tr></thead><tbody><tr><td>instanceof</td><td>判断对象是否为给定的类型。后跟目标类，判断栈顶元素是否为目标类 &#x2F; 接口的实例。是则压入 1，否则压入 0</td></tr><tr><td>checkcast</td><td>确定对象为所给定的类型。后跟目标类，判断栈顶元素是否为目标类 &#x2F; 接口的实例。如果不是便抛出异常</td></tr></tbody></table><h1 id="六、方法的调用与返回指令"><a href="#六、方法的调用与返回指令" class="headerlink" title="六、方法的调用与返回指令"></a>六、方法的调用与返回指令</h1><ul><li><strong>方法调用指令</strong><ul><li>invokevirtual 运行时按照对象的类来调用实例方法</li><li>invokespecial 根据编译时类型来调用实例方法</li><li>invokestatic 调用类（静态）方法</li><li>invokcinterface 调用接口方法</li></ul></li><li><strong>方法返回指令</strong><ul><li>ireturn 从方法中返回int类型的数据</li><li>lreturn 从方法中返回long类型的数据</li><li>freturn 从方法中返回float类型的数据</li><li>dreturn 从方法中返回double类型的数据</li><li>areturn 从方法中返回引用类型的数据</li><li>return 从方法中返回，返回值为void</li></ul></li></ul><h2 id="1-方法调用指令"><a href="#1-方法调用指令" class="headerlink" title="1. 方法调用指令"></a>1. 方法调用指令</h2><p>方法调用指令：invokevirtual、invokeinterface、invokespecial、invokestatic、invokedynamic，以下5条指令用于方法调用：</p><ul><li><p><code>invokevirtual</code> 指令用于调用对象的实例方法，根据对象的实际类型进行分派（虚方法分派），支持多态。这也是Java语言中最常见的方法分派方式。</p><ul><li><p>首先，对象的实例方法是指定义在类中并用关键字“this”引用对象自身的方法，它们以对象作为调用者进行调用，而且同一个类的不同实例对象所调用的同名函数可能会表现出不同的行为。而调用对象的实例方法需要使用特定的指令来完成，Java语言中最常见的方法分派方式就是使用“invokevirtual”指令。</p><p>其次，“invokevirtual”指令支持多态，这也是Java语言中的一大特点。多态是指同一个函数名可以被多个子类继承并实现不同的方法，当程序调用该函数时，编译器不能确定调用的是哪个子类的方法，而是在运行时根据对象的实际类型进行分派，即虚方法分派。</p><p>具体来说，在执行“invokevirtual”指令时，虚拟机会根据对象的实际类型找到对应的方法，并进行调用。这个过程称为虚拟方法分派，它可以保证程序的灵活性和可扩展性，也是Java语言中面向对象特性的重要体现。</p><p>总之，“invokevirtual”指令用于调用对象的实例方法，根据对象的实际类型进行虚方法分派，支持多态，是Java语言中最常用的方法分派方式之一。</p></li></ul></li><li><p><code>invokeinterface</code> 指令用于调用接口方法，它会在运行时搜索由特定对象所实现的这个接口方法，并找出适合的方法进行调用。</p></li><li><p><code>invokespecial</code> 指令用于调用一些需要特殊处理的实例方法，包括实例初始化方法（构造器）、私有方法和父类方法。这些方法都是静态类型绑定的，不会在调用时进行动态派发。</p></li><li><p><code>invokestatic</code> 指令用于调用命名类中的类方法（static方法）。这是静态绑定的。</p></li><li><p><code>invokedynamic</code> 指令用于调用动态绑定的方法，这个是JDK1.7后新加入的指令。用于在运行时动态解析出调用点限定符所引用的方法，并执行该方法。<code>invokedynamic</code> 指令的分派逻辑是由用户所设定的引导方法决定的，而前面4条调用指令的分派逻辑都固化在java虚拟机内部。</p></li></ul><h2 id="2-方法返回指令"><a href="#2-方法返回指令" class="headerlink" title="2. 方法返回指令"></a>2. 方法返回指令</h2><p>方法调用结束前，需要进行返回。方法返回指令是根据返回值的类型区分的。</p><ul><li><p>包括ireturn（当返回值是boolean、byte、char、short和int 类型时使用）、lreturn、freturn、dreturn 和 areturn</p></li><li><p>另外还有一条return 指令供声明为void的方法、实例初始化方法以及类和接口的类初始化方法使用。</p></li></ul><table><thead><tr><th>方法返回指令</th><th>void</th><th>int、boolean、byte、char、short</th><th>long</th><th>float</th><th>double</th><th>reference</th></tr></thead><tbody><tr><td><strong>xreturn</strong></td><td>return</td><td>ireturn</td><td>lreturn</td><td>freutrn</td><td>dreturn</td><td>areturn</td></tr></tbody></table><p>通过ireturn指令，将当前函数操作数栈的顶层元素弹出，并将这个元素压入调用者函数的操作数栈中（因为调用者非常关心函数的返回值），所有在当前函数操作数栈中的其他元素都会被丢弃。</p><p>如果当前返回的是synchronized方法，那么还会执行一个隐含的monitorexit指令，退出临界区。</p><p>最后，会丢弃当前方法的整个帧，恢复调用者的帧，并将控制权转交给调用者。</p><p><strong>举例：</strong></p><pre><code class="highlight java"><span class="keyword">public</span> <span class="type">int</span> <span class="title function_">methodReturn</span><span class="params">()</span> &#123;    <span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">500</span>;    <span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> <span class="number">200</span>;    <span class="type">int</span> <span class="variable">k</span> <span class="operator">=</span> <span class="number">50</span>;        <span class="keyword">return</span> (i + j) / k;&#125;</code></pre><p><strong>图示：</strong></p><p><img src="https://raw.githubusercontent.com/GeorgeChan95/blogimg/master/img/2024/07/28/20240728-113404.png" alt="方法返回指令"></p><h1 id="七、操作数栈管理指令"><a href="#七、操作数栈管理指令" class="headerlink" title="七、操作数栈管理指令"></a>七、操作数栈管理指令</h1><h2 id="1-指令概述"><a href="#1-指令概述" class="headerlink" title="1. 指令概述"></a>1. 指令概述</h2><p>如同操作一个普通数据结构中的堆栈那样，JVM提供的操作数栈管理指令，可以用于直接操作操作数栈的指令。</p><p>这类指令包括如下内容：</p><ul><li><p>将一个或两个元素从栈顶弹出，并且直接废弃：<code>pop，pop2</code></p></li><li><p>复制栈顶占一个solt长度的值,并重新压入栈的指令: <code>dup，dup_x1，dup_×2</code></p></li><li><p>复制栈顶占两个solt长度的值(1个八子节或2个四字节的值),并重新压入栈的指令: <code>dup2，dup2_×1，dup2_×2</code></p></li><li><p>将栈最顶端的两个Slot数值位置交换：<code>swap</code>。Java虚拟机没有提供交换两个64位数据类型（long、double）数值的指令。</p></li><li><p>指令<code>nop</code>，是一个非常特殊的指令，它的字节码为0x00。和汇编语言中的nop一样，它表示什么都不做。这条指令一般可用于调试、占位等。</p></li></ul><p>这些指令属于通用型，对栈的压入或者弹出无需指明数据类型。</p><ul><li><p>不带_x的指令是复制栈顶数据并压入栈顶。包括两个指令，<code>dup，dup2</code>。dup的系数代表要复制的Slot个数。dup开头的指令用于复制1个Slot的数据。例如1个int或1个reference类型数据dup2开头的指令用于复制2个Slot的数据。例如1个long，或2个int，或1个int+1个float类型数据</p></li><li><p>带_x的指令是复制栈顶数据并插入栈顶以下的某个位置。共有4个指令，<code>dup_×1，dup2_×1，dup_×2，dup2×2</code>。对于带<em>x的复制插入指令，只要将指令的dup和x的系数相加，结果即为需要插入的位置。因此dup</em>×1插入位置：1+1&#x3D;2，即栈顶2个slot下面dup_×2插入位置：1+2&#x3D;3，即栈顶3个slot下面；dup2×1插入位置：2+1&#x3D;3，即栈顶3个Slot下面</p></li><li><p><code>pop</code>：将栈顶的1个Slot数值出栈。例如1个short类型数值</p></li><li><p><code>pop2</code>：将栈顶的2个slot数值出栈。例如1个double类型数值，或者2个int类型数值</p></li></ul><h2 id="2-实例解析"><a href="#2-实例解析" class="headerlink" title="2. 实例解析"></a>2. 实例解析</h2><p><strong>代码示例</strong></p><pre><code class="highlight java"><span class="keyword">private</span> <span class="type">long</span> <span class="variable">index</span> <span class="operator">=</span> <span class="number">0</span>;<span class="keyword">public</span> <span class="type">long</span> <span class="title function_">nextIndex</span><span class="params">()</span> &#123; <span class="comment">// 返回结果: 0</span>    <span class="keyword">return</span> ++index;&#125;</code></pre><p><strong>nextIndex()方法字节码</strong></p><pre><code class="highlight shell"> 0 aload_0 1 dup 2 getfield #2 &lt;com/atguigu/java/StackOperateTest.index : J&gt; 5 dup2_x1 6 lconst_1 7 ladd 8 putfield #2 &lt;com/atguigu/java/StackOperateTest.index : J&gt;11 lreturn</code></pre><p><strong>字节码解析</strong></p><p><img src="https://raw.githubusercontent.com/GeorgeChan95/blogimg/master/img/2024/07/28/20240728-182711.png" alt="操作数栈指令解析"></p><h1 id="八、控制转义指令"><a href="#八、控制转义指令" class="headerlink" title="八、控制转义指令"></a>八、控制转义指令</h1><p>程序流程离不开条件控制，为了支持条件跳转，虚拟机提供了大量字节码指令，大体上可以分为</p><ul><li><p>比较指令</p><ul><li><code>lcmp</code> 比较long类型值</li><li><code>fcmpl</code> 比较float类型值（当遇到NaN时，返回-1）</li><li><code>fcmpg</code> 比较float类型值（当遇到NaN时，返回1）</li><li><code>dcmpl</code> 比较double类型值（当遇到NaN时，返回-1）</li><li><code>dcmpg</code> 比较double类型值（当遇到NaN时，返回1）</li></ul></li><li><p>条件跳转指令</p><ul><li><code>ifeq</code> 如果等于0，则跳转</li><li><code>ifne</code> 如果不等于0，则跳转</li><li><code>iflt</code> 如果小于0，则跳转</li><li><code>ifge</code> 如果大于等于0，则跳转</li><li><code>ifgt</code> 如果大于0，则跳转</li><li><code>ifle</code> 如果小于等于0，则跳转</li></ul></li><li><p>比较条件跳转指令</p><ul><li><code>if_icmpeq</code> 如果两个int值相等，则跳转</li><li><code>if_icmpne</code> 如果两个int类型值不相等，则跳转</li><li><code>if_icmplt</code> 如果一个int类型值小于另外一个int类型值，则跳转</li><li><code>if_icmpge</code> 如果一个int类型值大于或者等于另外一个int类型值，则跳转</li><li><code>if_icmpgt</code> 如果一个int类型值大于另外一个int类型值，则跳转</li><li><code>if_icmple</code> 如果一个int类型值小于或者等于另外一个int类型值，则跳转</li><li><code>ifnull</code> 如果等于null，则跳转</li><li><code>ifnonnull</code> 如果不等于null，则跳转</li><li><code>if_acmpeq</code> 如果两个对象引用相等，则跳转</li><li><code>if_acmpne</code> 如果两个对象引用不相等，则跳转</li></ul></li><li><p>多条件分支跳转指令</p><ul><li><code>tableswitch</code> 通过索引访问跳转表，并跳转</li><li><code>lookupswitch</code> 通过键值匹配访问跳转表，并执行跳转操作</li></ul></li><li><p>无条件跳转指令等</p><ul><li><code>goto</code> 无条件跳转</li><li><code>goto_w</code> 无条件跳转（宽索引）</li></ul></li></ul><h2 id="1-比较指令"><a href="#1-比较指令" class="headerlink" title="1. 比较指令"></a>1. 比较指令</h2><p>比较指令的作用是比较占栈顶两个元素的大小，并将比较结果入栈。比较指令有： <code>dcmpg</code>、<code>dcmpl</code>、<code>fcmpg</code>、<code>fcmpl</code>、<code>lcmp</code>。与前面讲解的指令类似，首字符d表示double类型，f表示float, l表示long。</p><p>对于double和float类型的数字，由于NaN的存在，各有两个版本的比较指令。以float为例，有 fcmpg 和 fcmpl 两个指令，它们的区别在于在数字比较时，若遇到NaN值，处理结果不同。</p><p>指令 dcmpl 和 dcmpg 也是类似的，根据其命名可以推测其含义，在此不再赘述。</p><p>数值类型的数据，才可以谈大小！boolean、引用数据类型不能比较大小。</p><p><strong>举例</strong></p><pre><code class="highlight java"><span class="comment">//结合比较指令</span><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">compare2</span><span class="params">()</span> &#123;    <span class="type">float</span> <span class="variable">f1</span> <span class="operator">=</span> <span class="number">9</span>;    <span class="type">float</span> <span class="variable">f2</span> <span class="operator">=</span> <span class="number">10</span>;    System.out.println(f1 &lt; f2);<span class="comment">//true</span>&#125;</code></pre><p><strong>字节码:</strong></p><pre><code class="highlight txt"> 0 ldc #2 &lt;9.0&gt; 2 fstore_1 3 ldc #3 &lt;10.0&gt; 5 fstore_2 6 getstatic #4 &lt;java/lang/System.out : Ljava/io/PrintStream;&gt; 9 fload_110 fload_211 fcmpg12 ifge 19 (+7)15 iconst_116 goto 20 (+4)19 iconst_020 invokevirtual #5 &lt;java/io/PrintStream.println : (Z)V&gt;23 return</code></pre><p><img src="https://raw.githubusercontent.com/GeorgeChan95/blogimg/master/img/2024/07/31/20240731-192344.png" alt="字节码指令执行过程"></p><p><strong>解析:</strong></p><p>指令 fcmp和fcmpl都从中弹出两个操作数，并将它们做比较，设栈顶的元素为v2，顶顺位第2位的元素为v1：若v1&#x3D;v2，则压入0；若v1&gt;v2，则压入1；若v1&lt;v2，则压入-1。</p><p>两个指令的不同之处在于，如果遇到NaN值， fcmpg会压入1,而fcmpl会压入-1</p><h2 id="2-条件跳转指令"><a href="#2-条件跳转指令" class="headerlink" title="2. 条件跳转指令"></a>2. 条件跳转指令</h2><p>条件跳转指令通常和比较指令结合使用。在条件跳转指令执行前，一般可以先用比较指令进行栈顶元素的准备，然后进行条件跳转。</p><p>条件跳转指令有：ifeq，iflt，ifle，ifne，ifgt，ifge，ifnull，ifnonnull。这些指令都接收两个字节的操作数，用于计算跳转的位置（16位符号整数作为当前位置的offset）。</p><p>它们的统一含义为：弹出栈顶元素，测试它是否满足某一条件，如果满足条件，则跳转到给定位置。</p><table><thead><tr><th>&lt;</th><th>&lt;&#x3D;</th><th>&#x3D;&#x3D;</th><th>!&#x3D;</th><th>&gt;&#x3D;</th><th>&gt;</th><th>null</th><th>not null</th></tr></thead><tbody><tr><td>iflt</td><td>ifle</td><td>ifeq</td><td>ifng</td><td>ifge</td><td>ifgt</td><td>ifnull</td><td>ifnonnull</td></tr></tbody></table><p>与前面运算规则一致：</p><ul><li><p>对于boolean、byte、char、short类型的条件分支比较操作，都是使用int类型的比较指令完成</p></li><li><p>对于long、float、double类型的条件分支比较操作，则会先执行相应类型的比较运算指令，运算指令会返回一个整型值到操作数栈中，随后再执行int类型的条件分支比较操作来完成整个分支跳转</p></li></ul><p>由于各类型的比较最终都会转为int类型的比较操作，所以Java虚拟机提供的int类型的条件分支指令是最为丰富和强大的。</p><h2 id="3-比较条件跳转指令"><a href="#3-比较条件跳转指令" class="headerlink" title="3. 比较条件跳转指令"></a>3. 比较条件跳转指令</h2><p>比较条件跳转指令类似于比较指令和条件跳转指令的结合体，它将比较和跳转两个步骤合二为一。</p><p>这类指令有：<code>if_icmpeq</code>、<code>if_icmpne</code>、<code>if_icmplt</code>、<code>if_icmpgt</code>、<code>if_icmple</code>、<code>if_icmpge</code>、<code>if_acmpeq</code> 和 <code>if_acmpne</code>。其中指令助记符加上“if_”后，以字符“i”开头的指令针对 int 型整数操作（也包括short和byte类型），以字符“a”开头的指令表示对象引用的比较。</p><table><thead><tr><th>&lt;</th><th>&lt;&#x3D;</th><th>&#x3D;&#x3D;</th><th>!&#x3D;</th><th>&gt;&#x3D;</th><th>&gt;</th></tr></thead><tbody><tr><td>if_icmplt</td><td>if_icmple</td><td>if_icmpeq、if_acmpeq</td><td>if_icmpne、if_acmpne</td><td>if_icmpge</td><td>if_icmpgt</td></tr></tbody></table><p>这些指令都接收两个字节的操作数作为参数，用于计算跳转的位置。同时在执行指令时，栈顶需要准备两个元素进行比较。指令执行完成后，栈顶的这两个元素被清空，且没有任何数据入栈。如果预设条件成立，则执行跳转，否则，继续执行下一条语句。</p><p><strong>示例</strong></p><pre><code class="highlight java"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">ifCompare3</span><span class="params">()</span> &#123;        <span class="type">Object</span> <span class="variable">obj1</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Object</span>();        <span class="type">Object</span> <span class="variable">obj2</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Object</span>();        System.out.println(obj1 == obj2);<span class="comment">//false</span>        System.out.println(obj1 != obj2);<span class="comment">//true</span>    &#125;</code></pre><p><strong>字节码</strong></p><pre><code class="highlight txt"> 0 new #10 &lt;java/lang/Object&gt; 3 dup 4 invokespecial #1 &lt;java/lang/Object.&lt;init&gt; : ()V&gt; 7 astore_1 8 new #10 &lt;java/lang/Object&gt;11 dup12 invokespecial #1 &lt;java/lang/Object.&lt;init&gt; : ()V&gt;15 astore_216 getstatic #4 &lt;java/lang/System.out : Ljava/io/PrintStream;&gt;19 aload_120 aload_221 if_acmpne 28 (+7)24 iconst_125 goto 29 (+4)28 iconst_029 invokevirtual #5 &lt;java/io/PrintStream.println : (Z)V&gt;32 getstatic #4 &lt;java/lang/System.out : Ljava/io/PrintStream;&gt;35 aload_136 aload_237 if_acmpeq 44 (+7)40 iconst_141 goto 45 (+4)44 iconst_045 invokevirtual #5 &lt;java/io/PrintStream.println : (Z)V&gt;48 return</code></pre><h2 id="4-多条件分支跳转指令"><a href="#4-多条件分支跳转指令" class="headerlink" title="4. 多条件分支跳转指令"></a>4. 多条件分支跳转指令</h2><p>多条件分支跳转指令是专为switch-case语句设计的，主要有 <code>tableswitch</code> 和 <code>lookupswitch</code> 。</p><table><thead><tr><th>指令名称</th><th>描述</th></tr></thead><tbody><tr><td>tableswitch</td><td>用于switch条件跳转，case值连续</td></tr><tr><td>lookupswitch</td><td>用于switch条件跳转，case值不连续</td></tr></tbody></table><p>从助记符上看，两者都是switch语句的实现，它们的区别：</p><ul><li><p><code>tableswitch</code> 要求多个条件分支值是连续的，它内部只存放起始值和终止值，以及若干个跳转偏移量，通过给定的操作数index，可以立即定位到跳转偏移量位置，因此效率比较高。</p></li><li><p><code>lookupswitch</code> 内部存放着各个离散的case-offset对，每次执行都要搜索全部的case-offset对，找到匹配的case值，并根据对应的offset计算跳转地址，因此效率较低。</p></li></ul><p>指令tableswitch的示意图如下图所示。由于tableswitch的case值是连续的，因此只需要记录最低值和最高值，以及每一项对应的offset偏移量，根据给定的index值通过简单的计算即可直接定位到offset。</p><p><img src="https://raw.githubusercontent.com/GeorgeChan95/blogimg/master/img/2024/07/31/20240731-200001.png" alt="table-switch"></p><p><strong>示例:</strong></p><pre><code class="highlight java"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">swtich2</span><span class="params">(<span class="type">int</span> select)</span>&#123;    <span class="type">int</span> num;    <span class="keyword">switch</span>(select)&#123;        <span class="keyword">case</span> <span class="number">100</span>:            num = <span class="number">10</span>;            <span class="keyword">break</span>;        <span class="keyword">case</span> <span class="number">500</span>:            num = <span class="number">20</span>;            <span class="keyword">break</span>;        <span class="keyword">case</span> <span class="number">200</span>:            num = <span class="number">30</span>;            <span class="keyword">break</span>;        <span class="keyword">default</span>:            num = <span class="number">40</span>;    &#125;&#125;</code></pre><p><strong>字节码</strong></p><pre><code class="highlight txt"> 0 iload_1 1 tableswitch 1 to 31:  28 (+27)2:  34 (+33)3:  37 (+36)default:  43 (+42)28 bipush 1030 istore_231 goto 46 (+15)34 bipush 2036 istore_237 bipush 3039 istore_240 goto 46 (+6)43 bipush 4045 istore_246 return</code></pre><p>指令 lookupswitch 处理的是离散的case值，但是出于效率考虑，将case-offset对按照case值大小排序，给定index时，需要查找与index相等的case，获得其offset，如果找不到则跳转到default。指令lookupswitch如下图所示。</p><p><img src="https://raw.githubusercontent.com/GeorgeChan95/blogimg/master/img/2024/07/31/20240731-200220.png" alt="lookupswitch"></p><p><strong>示例</strong></p><pre><code class="highlight java"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">swtich2</span><span class="params">(<span class="type">int</span> select)</span>&#123;    <span class="type">int</span> num;    <span class="keyword">switch</span>(select)&#123;        <span class="keyword">case</span> <span class="number">100</span>:            num = <span class="number">10</span>;            <span class="keyword">break</span>;        <span class="keyword">case</span> <span class="number">500</span>:            num = <span class="number">20</span>;            <span class="keyword">break</span>;        <span class="keyword">case</span> <span class="number">200</span>:            num = <span class="number">30</span>;            <span class="keyword">break</span>;        <span class="keyword">default</span>:            num = <span class="number">40</span>;    &#125;&#125;</code></pre><p><strong>字节码</strong></p><pre><code class="highlight txt"> 0 iload_1 1 lookupswitch 3100:  36 (+35)200:  48 (+47)500:  42 (+41)default:  54 (+53)36 bipush 1038 istore_239 goto 57 (+18)42 bipush 2044 istore_245 goto 57 (+12)48 bipush 3050 istore_251 goto 57 (+6)54 bipush 4056 istore_257 return</code></pre><h2 id="5-无条件跳转指令"><a href="#5-无条件跳转指令" class="headerlink" title="5. 无条件跳转指令"></a>5. 无条件跳转指令</h2><p>目前主要的无条件跳转指令为goto。指令goto接收两个字节的操作数，共同组成一个带符号的整数，用于指定指令的偏移量，指令执行的目的就是跳转到偏移量给定的位置处。</p><p>如果指令偏移量太大，超过双字节的带符号整数的范围，则可以使用指令goto_w，它和goto有相同的作用，但是它接收4个字节的操作数，可以表示更大的地址范围。</p><p><em>指令jsr、jsr_w、ret虽然也是无条件跳转的，但主要用于try-finally语句，且已经被虚拟机逐渐废弃，故不在这里介绍这两个指令。</em></p><table><thead><tr><th>指令名称</th><th>描述</th></tr></thead><tbody><tr><td>goto</td><td>无条件跳转</td></tr><tr><td>goto_w</td><td>无条件跳转（宽索引）</td></tr><tr><td>jsr</td><td>跳转至指定16位offset位置，并将jsr下一条指令地址压入栈顶</td></tr><tr><td>jsr_w</td><td>跳转至指定32位offer位置，并将jsr_w下一条指令地址压入栈顶</td></tr><tr><td>ret</td><td>返回至由指定的局部变量所给出的指令位置（一般与jsr、jsr_w联合使用）</td></tr></tbody></table><h1 id="九、异常处理指令"><a href="#九、异常处理指令" class="headerlink" title="九、异常处理指令"></a>九、异常处理指令</h1><p><strong>异常处理指令</strong></p><ul><li><code>athrow</code> 抛出异常或错误。将栈顶异常抛出</li><li><code>jsr</code> 跳转到子例程</li><li><code>jsr_w</code> 跳转到子例程（宽索引）</li><li><code>ret</code> 从子例程返回</li></ul><h2 id="1-athrow指令"><a href="#1-athrow指令" class="headerlink" title="1. athrow指令"></a>1. athrow指令</h2><p>在Java程序中显示抛出异常的操作（throw语句）都是由athrow指令来实现。</p><p>除了使用throw语句显示抛出异常情况之外，JVM规范还规定了许多运行时异常会在其他Java虚拟机指令检测到异常状况时自动抛出。例如，在之前介绍的整数运算时，当除数为零时，虚拟机会在 <code>idiv</code> 或 <code>ldiv</code> 指令中抛出ArithmeticException异常。</p><p><strong>正常情况下，操作数栈的压入弹出都是一条条指令完成的。唯一的例外情况是在抛异常时，Java虚拟机会清除操作数栈上的所有内容，而后将异常实例压入调用者操作数栈上。</strong></p><p><strong>注意：</strong></p><p>如果使用throw new 异常名称()这种形式来抛出异常，那就会在代码中出现athrow指令，而在方法上面添加throw 异常名称这种形式来抛出异常，然后使用jclasslib的时候就会出现在方法下面多出现一个属性Exceptions，如下图所示：</p><p><img src="https://raw.githubusercontent.com/GeorgeChan95/blogimg/master/img/2024/07/31/20240731-201555.png" alt="image-20240731201553896"></p><p><strong>示例:</strong></p><pre><code class="highlight java"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">throwOne</span><span class="params">(<span class="type">int</span> i)</span> <span class="keyword">throws</span> RuntimeException,IOException&#123;    <span class="keyword">if</span>(i == <span class="number">1</span>)&#123;        <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">RuntimeException</span>(<span class="string">&quot;参数值为1&quot;</span>);    &#125;&#125;</code></pre><p><img src="https://raw.githubusercontent.com/GeorgeChan95/blogimg/master/img/2024/07/31/20240731-201731.png" alt="image-20240731201731105"></p><p><img src="https://raw.githubusercontent.com/GeorgeChan95/blogimg/master/img/2024/07/31/20240731-201747.png" alt="image-20240731201746649"></p><h2 id="2-处理异常"><a href="#2-处理异常" class="headerlink" title="2. 处理异常"></a>2. 处理异常</h2><p>在Java虚拟机中，处理异常（catch语句）不是由字节码指令来实现的（早期使用jsr、ret指令），而是采用异常表来完成的。</p><h2 id="3-异常表"><a href="#3-异常表" class="headerlink" title="3. 异常表"></a>3. 异常表</h2><p>如果一个方法定义了一个try-catch 或者try-finally的异常处理，就会创建一个异常表。它包含了每个异常处理或者finally块的信息。异常表保存了每个异常处理信息。比如：</p><ul><li><p>起始位置</p></li><li><p>结束位置</p></li><li><p>程序计数器记录的代码处理的偏移地址</p></li><li><p>被捕获的异常类在常量池中的索引</p></li></ul><p>当一个异常被抛出时，JVM会在当前的方法里寻找一个匹配的处理，如果没有找到，这个方法会强制结束并弹出当前栈帧，并且异常会重新抛给上层调用的方法（在调用方法栈帧）。如果在所有栈帧弹出前仍然没有找到合适的异常处理，这个线程将终止。如果这个异常在最后一个非守护线程里抛出，将会导致JVM自己终止，比如这个线程是个main线程。</p><p>不管什么时候抛出异常，如果异常处理最终匹配了所有异常类型，代码就会继续执行。在这种情况下，如果方法结束后没有抛出异常，仍然执行finally块，在return前，它直接跳到finally块来完成目标</p><p><strong>示例:</strong></p><pre><code class="highlight java"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">tryCatch</span><span class="params">()</span>&#123;    <span class="keyword">try</span>&#123;        <span class="type">File</span> <span class="variable">file</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">File</span>(<span class="string">&quot;d:/hello.txt&quot;</span>);        <span class="type">FileInputStream</span> <span class="variable">fis</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">FileInputStream</span>(file);        <span class="type">String</span> <span class="variable">info</span> <span class="operator">=</span> <span class="string">&quot;hello!&quot;</span>;    &#125;<span class="keyword">catch</span> (FileNotFoundException e) &#123;        e.printStackTrace();    &#125;    <span class="keyword">catch</span>(RuntimeException e)&#123;        e.printStackTrace();    &#125;&#125;</code></pre><p><strong>字节码</strong></p><pre><code class="highlight txt"> 0 new #8 &lt;java/io/File&gt; 3 dup 4 ldc #9 &lt;d:/hello.txt&gt; 6 invokespecial #10 &lt;java/io/File.&lt;init&gt; : (Ljava/lang/String;)V&gt; 9 astore_110 new #11 &lt;java/io/FileInputStream&gt;13 dup14 aload_115 invokespecial #12 &lt;java/io/FileInputStream.&lt;init&gt; : (Ljava/io/File;)V&gt;18 astore_219 ldc #13 &lt;hello!&gt;21 astore_322 goto 38 (+16)25 astore_126 aload_127 invokevirtual #15 &lt;java/io/FileNotFoundException.printStackTrace : ()V&gt;30 goto 38 (+8)33 astore_134 aload_135 invokevirtual #16 &lt;java/lang/RuntimeException.printStackTrace : ()V&gt;38 return</code></pre><p><img src="https://raw.githubusercontent.com/GeorgeChan95/blogimg/master/img/2024/07/31/20240731-202434.png" alt="异常表"></p><h1 id="十、同步控制指令"><a href="#十、同步控制指令" class="headerlink" title="十、同步控制指令"></a>十、同步控制指令</h1><p>Java虚拟机支持两种同步结构：方法级的同步和方法内部一段指令序列的同步，这两种同步都是使用monitor来支持的. </p><h2 id="1-方法级的同步"><a href="#1-方法级的同步" class="headerlink" title="1. 方法级的同步"></a>1. 方法级的同步</h2><p><strong>方法级的同步：是隐式的</strong>，即无须通过字节码指令来控制，它实现在方法调用和返回操作之中。虚拟机可以从方法常量池的方法表结构中的 <code>ACC_SYNCHRONIZED</code>访问标志 得知一个方法是否声明为同步方法；</p><p>当调用方法时，调用指令将会检查方法的 <strong>ACC_SYNCHRONIZED访问标志</strong> 是否设置。</p><ul><li><p>如果设置了，执行线程将先持有同步锁，然后执行方法。最后在方法完成（无论是正常完成还是非正常完成）时释放同步锁。</p></li><li><p>在方法执行期间，执行线程持有了同步锁，其他任何线程都无法再获得同一个锁。</p></li><li><p>如果一个同步方法执行期间抛出了异常，并且在方法内部无法处理此异常，<strong>那这个同步方法所持有的锁将在异常抛到同步方法之外时自动释放</strong>。</p></li></ul><p><strong>示例</strong></p><pre><code class="highlight java"><span class="keyword">private</span> <span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>;<span class="keyword">public</span> <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title function_">add</span><span class="params">()</span> &#123;i++;&#125;</code></pre><p>对应的字节码：</p><pre><code class="highlight txt"> 0 aload_0 1 dup 2 getfield #2 &lt;com/atguigu/java1/SynchronizedTest.i : I&gt; 5 iconst_1 6 iadd 7 putfield #2 &lt;com/atguigu/java1/SynchronizedTest.i : I&gt;10 return</code></pre><p>这段代码和普通的无同步操作的代码没有什么不同，没有使用 <code>monitorenter</code> 和 <code>monitorexit</code> 进行同步区控制。</p><p>这是因为，对于同步方法而言，当虚拟机通过方法的访问标示符判断是一个同步方法时，会自动在方法调用前进行加锁，当同步方法执行完毕后，不管方法是正常结束还是有异常抛出，均会由虚拟机释放这个锁。</p><p><img src="https://raw.githubusercontent.com/GeorgeChan95/blogimg/master/img/2024/07/31/20240731-203639.png" alt="方法级同步"></p><p>因此，对于同步方法而言，monitorenter 和 monitorexit 指令是隐式存在的，并未直接出现在字节码中。</p><h2 id="2-方法内指令指令序列的同步"><a href="#2-方法内指令指令序列的同步" class="headerlink" title="2. 方法内指令指令序列的同步"></a>2. 方法内指令指令序列的同步</h2><p>同步一段指令集序列：通常是由java中的 synchronized语句块 来表示的。jvm的指令集有 <code>monitorenter</code> 和 <code>monitorexit</code> 两条指令来支持synchronized关键字的语义。</p><p>当一个线程进入同步代码块时，它使用 monitorenter 指令请求进入。如果当前对象的监视器计数器为0，则它会被准许进入，若为1，则判断持有当前监视器的线程是否为自己，如果是，则进入，否则进行等待，直到对象的监视器计数器为0，才会被允许进入同步块。</p><p>当线程退出同步块时，需要使用monitorexit声明退出。在Java虚拟机中，任何对象都有一个监视器与之相关联，用来判断对象是否被锁定，当监视器被持有后，对象处于锁定状态。</p><p>指令monitorenter和monitorexit在执行时，都需要在操作数栈顶压入对象，之后 monitorenter 和 monitorexit 的锁定和释放都是针对这个对象的监视器进行的。</p><p><strong>示例:</strong></p><pre><code class="highlight java"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">subtract</span><span class="params">()</span>&#123;    <span class="keyword">synchronized</span> (obj)&#123;        i--;    &#125;&#125;</code></pre><p><strong>字节码</strong></p><pre><code class="highlight txt">0: aloade 1: dup 2: astore_1 3: monitorenter 4: aload_0 5: dup 6: getfield #2 //Field i:I 9: iconst_110: isub11: putfield #2 //Field i:I14: aload_115: monitorexit16: goto 2419: astore_226: aload_121: monitorexit22: aload_223: athrow24: returnException table:from to target type4 16   19  any19 22    19  any</code></pre><p>编译器必须确保无论方法通过何种方式完成，方法中调用过的每条monitorenter指令都必须执行其对应的monitorexit指令，而无论这个方法是正常结束还是异常结束。</p><p>为了保证在方法异常完成时monitorenter和monitorexit指令依然可以正确配对执行，编译器会自动产生一个异常处理器，这个异常处理器声明可处理所有的异常，它的目的就是用来执行monitorexit</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;一、概述&quot;&gt;&lt;a href=&quot;#一、概述&quot; class=&quot;headerlink&quot; title=&quot;一、概述&quot;&gt;&lt;/a&gt;一、概述&lt;/h1&gt;&lt;ul&gt;
&lt;li&gt;java字节码对于虚拟机，就好像汇编语言对于计算机，属于基本执行指令。&lt;/li&gt;
&lt;li&gt;Java 虚拟机的指令</summary>
      
    
    
    
    <category term="JVM" scheme="https://georgechan95.github.io/categories/JVM/"/>
    
    
    <category term="jvm" scheme="https://georgechan95.github.io/tags/jvm/"/>
    
    <category term="java" scheme="https://georgechan95.github.io/tags/java/"/>
    
  </entry>
  
  <entry>
    <title>第十七章-使用javap指令解析class文件</title>
    <link href="https://georgechan95.github.io/2024/07/22/jvm/%E7%AC%AC%E5%8D%81%E4%B8%83%E7%AB%A0-%E4%BD%BF%E7%94%A8javap%E6%8C%87%E4%BB%A4%E8%A7%A3%E6%9E%90class%E6%96%87%E4%BB%B6/"/>
    <id>https://georgechan95.github.io/2024/07/22/jvm/%E7%AC%AC%E5%8D%81%E4%B8%83%E7%AB%A0-%E4%BD%BF%E7%94%A8javap%E6%8C%87%E4%BB%A4%E8%A7%A3%E6%9E%90class%E6%96%87%E4%BB%B6/</id>
    <published>2024-07-22T15:54:00.000Z</published>
    <updated>2024-07-22T02:14:17.121Z</updated>
    
    <content type="html"><![CDATA[<h1 id="一、解析字节码的作用"><a href="#一、解析字节码的作用" class="headerlink" title="一、解析字节码的作用"></a>一、解析字节码的作用</h1><p>通过反编译生成的字节码文件，我们可以深入的了解java代码的工作机制。但是，自己分析类文件结构太麻烦了! 除了使用第三方的jclasslib工具之外，oracle官方也提供了工具: <code>javap</code> 。<br>javap 是jdk自带的反解析工具。它的作用就是根据class字节码文件，反解析出当前类对应的code区(字节码指令)局部变量表、异常表和代码行偏移量映射表、常量池等信息。<br>通过局部变量表，我们可以查看局部变量的作用域范围、所在槽位等信息，甚至可以看到槽位复用等信息。</p><h1 id="二、javac-g-操作"><a href="#二、javac-g-操作" class="headerlink" title="二、javac -g 操作"></a>二、javac -g 操作</h1><p>解析字节码文件得到的信息中，有些信息(如局部变量表、指令和代码行偏移量映射表、常量池中方法的参数名称等等)需要在使用javac编译成class文件时，指定参数才能输出。<br>比如，你直接javac xx.java，就不会在生成对应的局部变量表等信息，如果你使用javac -g xx.java就可以生成所有相关信息了。如果你使用的eclipse或 IDEA，则默认情况下，eclipse、IDEA在编译时会帮你生成局部变量表、指令和代码行偏移量映射表等信息的。</p><h1 id="三、javap-的用法"><a href="#三、javap-的用法" class="headerlink" title="三、javap 的用法"></a>三、javap 的用法</h1><p>javap的用法格式:</p><ul><li><p>javap <options> <classes></p><ul><li><p>其中，classes就是你要反编译的class文件。</p></li><li><p>在命令行中直接输入javap或javap -help可以看到javap的options有如下选项:</p><p><img src="https://raw.githubusercontent.com/GeorgeChan95/blogimg/master/img/2024/07/22/20240722-094028.png" alt="javap"></p></li></ul></li></ul><p>一般常用的是 -v -l -c三个选项。</p><ul><li>javap -l 会输出行号和本地变量表信息。</li><li>javap -c 会对当前class字节码进行反编译生成汇编代码。</li><li>javap -v classxx 除了包含-c内容外，还会输出行号、局部变量表信息、常量池等信息。</li></ul><p><strong>注意：</strong></p><p>① -v 相当于 -c -l </p><p>② -v 也不会输出私有的字段、方法等信息，所以如果想输出私有的信息，那需要在 -v 后面加上 -p 才行</p><h1 id="四、使用举例"><a href="#四、使用举例" class="headerlink" title="四、使用举例"></a>四、使用举例</h1><h2 id="1-代码"><a href="#1-代码" class="headerlink" title="1. 代码"></a>1. 代码</h2><pre><code class="highlight java"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">JavapTest</span> &#123;    <span class="keyword">private</span> <span class="type">int</span> num;    <span class="type">boolean</span> flag;    <span class="keyword">protected</span> <span class="type">char</span> gender;    <span class="keyword">public</span> String info;    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">int</span> <span class="variable">COUNTS</span> <span class="operator">=</span> <span class="number">1</span>;    <span class="keyword">static</span>&#123;        <span class="type">String</span> <span class="variable">url</span> <span class="operator">=</span> <span class="string">&quot;www.atguigu.com&quot;</span>;    &#125;    &#123;        info = <span class="string">&quot;java&quot;</span>;    &#125;    <span class="keyword">public</span> <span class="title function_">JavapTest</span><span class="params">()</span>&#123;    &#125;    <span class="keyword">private</span> <span class="title function_">JavapTest</span><span class="params">(<span class="type">boolean</span> flag)</span>&#123;        <span class="built_in">this</span>.flag = flag;    &#125;    <span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">methodPrivate</span><span class="params">()</span>&#123;    &#125;    <span class="type">int</span> <span class="title function_">getNum</span><span class="params">(<span class="type">int</span> i)</span>&#123;        <span class="keyword">return</span> num + i;    &#125;    <span class="keyword">protected</span> <span class="type">char</span> <span class="title function_">showGender</span><span class="params">()</span>&#123;        <span class="keyword">return</span> gender;    &#125;    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">showInfo</span><span class="params">()</span>&#123;        <span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">10</span>;        System.out.println(info + i);    &#125;&#125;</code></pre><h2 id="2-字节码分析"><a href="#2-字节码分析" class="headerlink" title="2. 字节码分析"></a>2. 字节码分析</h2><h3 id="2-1-使用-javap-命令解析class文件"><a href="#2-1-使用-javap-命令解析class文件" class="headerlink" title="2.1 使用 javap 命令解析class文件"></a>2.1 使用 <code>javap</code> 命令解析class文件</h3><pre><code class="highlight shell">javap -v -p JavapTest</code></pre><h3 id="2-2-版本信息"><a href="#2-2-版本信息" class="headerlink" title="2.2 版本信息"></a>2.2 版本信息</h3><pre><code class="highlight shell">警告: 二进制文件JavapTest包含com.atguigu.java1.JavapTestClassfile /E:/testWorkspace/jvm-demo-mid/out/production/chapter01/com/atguigu/java1/JavapTest.class   // 字节码文件所属的路径  Last modified 2024-7-22; size 1358 bytes  // 最后修改时间，字节码文件的大小  MD5 checksum 526b4a845e4d98180438e4c5781b7e88 // MD5散列值  Compiled from &quot;JavapTest.java&quot;   // 源文件的名称public class com.atguigu.java1.JavapTest  minor version: 0 // 副版本  major version: 52 // 主版本  flags: ACC_PUBLIC, ACC_SUPER // 访问标识</code></pre><h3 id="2-3-常量池"><a href="#2-3-常量池" class="headerlink" title="2.3 常量池"></a>2.3 常量池</h3><pre><code class="highlight shell">Constant pool:<span class="meta prompt_">   #</span><span class="language-bash">1 = Methodref          <span class="comment">#16.#46        // java/lang/Object.&quot;&lt;init&gt;&quot;:()V</span></span><span class="meta prompt_">   #</span><span class="language-bash">2 = String             <span class="comment">#47            // java</span></span><span class="meta prompt_">   #</span><span class="language-bash">3 = Fieldref           <span class="comment">#15.#48        // com/atguigu/java1/JavapTest.info:Ljava/lang/String;</span></span><span class="meta prompt_">   #</span><span class="language-bash">4 = Fieldref           <span class="comment">#15.#49        // com/atguigu/java1/JavapTest.flag:Z</span></span><span class="meta prompt_">   #</span><span class="language-bash">5 = Fieldref           <span class="comment">#15.#50        // com/atguigu/java1/JavapTest.num:I</span></span><span class="meta prompt_">   #</span><span class="language-bash">6 = Fieldref           <span class="comment">#15.#51        // com/atguigu/java1/JavapTest.gender:C</span></span><span class="meta prompt_">   #</span><span class="language-bash">7 = Fieldref           <span class="comment">#52.#53        // java/lang/System.out:Ljava/io/PrintStream;</span></span><span class="meta prompt_">   #</span><span class="language-bash">8 = Class              <span class="comment">#54            // java/lang/StringBuilder</span></span><span class="meta prompt_">   #</span><span class="language-bash">9 = Methodref          <span class="comment">#8.#46         // java/lang/StringBuilder.&quot;&lt;init&gt;&quot;:()V</span></span><span class="meta prompt_">  #</span><span class="language-bash">10 = Methodref          <span class="comment">#8.#55         // java/lang/StringBuilder.append:(Ljava/lang/String;)Ljava/lang/StringBuilder;</span></span><span class="meta prompt_">  #</span><span class="language-bash">11 = Methodref          <span class="comment">#8.#56         // java/lang/StringBuilder.append:(I)Ljava/lang/StringBuilder;</span></span><span class="meta prompt_">  #</span><span class="language-bash">12 = Methodref          <span class="comment">#8.#57         // java/lang/StringBuilder.toString:()Ljava/lang/String;</span></span><span class="meta prompt_">  #</span><span class="language-bash">13 = Methodref          <span class="comment">#58.#59        // java/io/PrintStream.println:(Ljava/lang/String;)V</span></span><span class="meta prompt_">  #</span><span class="language-bash">14 = String             <span class="comment">#60            // www.atguigu.com</span></span><span class="meta prompt_">  #</span><span class="language-bash">15 = Class              <span class="comment">#61            // com/atguigu/java1/JavapTest</span></span><span class="meta prompt_">  #</span><span class="language-bash">16 = Class              <span class="comment">#62            // java/lang/Object</span></span><span class="meta prompt_">  #</span><span class="language-bash">17 = Utf8               num</span><span class="meta prompt_">  #</span><span class="language-bash">18 = Utf8               I</span><span class="meta prompt_">  #</span><span class="language-bash">19 = Utf8               flag</span><span class="meta prompt_">  #</span><span class="language-bash">20 = Utf8               Z</span><span class="meta prompt_">  #</span><span class="language-bash">21 = Utf8               gender</span><span class="meta prompt_">  #</span><span class="language-bash">22 = Utf8               C</span><span class="meta prompt_">  #</span><span class="language-bash">23 = Utf8               info</span><span class="meta prompt_">  #</span><span class="language-bash">24 = Utf8               Ljava/lang/String;</span><span class="meta prompt_">  #</span><span class="language-bash">25 = Utf8               COUNTS</span><span class="meta prompt_">  #</span><span class="language-bash">26 = Utf8               ConstantValue</span><span class="meta prompt_">  #</span><span class="language-bash">27 = Integer            1</span><span class="meta prompt_">  #</span><span class="language-bash">28 = Utf8               &lt;init&gt;</span><span class="meta prompt_">  #</span><span class="language-bash">29 = Utf8               ()V</span><span class="meta prompt_">  #</span><span class="language-bash">30 = Utf8               Code</span><span class="meta prompt_">  #</span><span class="language-bash">31 = Utf8               LineNumberTable</span><span class="meta prompt_">  #</span><span class="language-bash">32 = Utf8               LocalVariableTable</span><span class="meta prompt_">  #</span><span class="language-bash">33 = Utf8               this</span><span class="meta prompt_">  #</span><span class="language-bash">34 = Utf8               Lcom/atguigu/java1/JavapTest;</span><span class="meta prompt_">  #</span><span class="language-bash">35 = Utf8               (Z)V</span><span class="meta prompt_">  #</span><span class="language-bash">36 = Utf8               methodPrivate</span><span class="meta prompt_">  #</span><span class="language-bash">37 = Utf8               getNum</span><span class="meta prompt_">  #</span><span class="language-bash">38 = Utf8               (I)I</span><span class="meta prompt_">  #</span><span class="language-bash">39 = Utf8               i</span><span class="meta prompt_">  #</span><span class="language-bash">40 = Utf8               showGender</span><span class="meta prompt_">  #</span><span class="language-bash">41 = Utf8               ()C</span><span class="meta prompt_">  #</span><span class="language-bash">42 = Utf8               showInfo</span><span class="meta prompt_">  #</span><span class="language-bash">43 = Utf8               &lt;clinit&gt;</span><span class="meta prompt_">  #</span><span class="language-bash">44 = Utf8               SourceFile</span><span class="meta prompt_">  #</span><span class="language-bash">45 = Utf8               JavapTest.java</span><span class="meta prompt_">  #</span><span class="language-bash">46 = NameAndType        <span class="comment">#28:#29        // &quot;&lt;init&gt;&quot;:()V</span></span><span class="meta prompt_">  #</span><span class="language-bash">47 = Utf8               java</span><span class="meta prompt_">  #</span><span class="language-bash">48 = NameAndType        <span class="comment">#23:#24        // info:Ljava/lang/String;</span></span><span class="meta prompt_">  #</span><span class="language-bash">49 = NameAndType        <span class="comment">#19:#20        // flag:Z</span></span><span class="meta prompt_">  #</span><span class="language-bash">50 = NameAndType        <span class="comment">#17:#18        // num:I</span></span><span class="meta prompt_">  #</span><span class="language-bash">51 = NameAndType        <span class="comment">#21:#22        // gender:C</span></span><span class="meta prompt_">  #</span><span class="language-bash">52 = Class              <span class="comment">#63            // java/lang/System</span></span><span class="meta prompt_">  #</span><span class="language-bash">53 = NameAndType        <span class="comment">#64:#65        // out:Ljava/io/PrintStream;</span></span><span class="meta prompt_">  #</span><span class="language-bash">54 = Utf8               java/lang/StringBuilder</span><span class="meta prompt_">  #</span><span class="language-bash">55 = NameAndType        <span class="comment">#66:#67        // append:(Ljava/lang/String;)Ljava/lang/StringBuilder;</span></span><span class="meta prompt_">  #</span><span class="language-bash">56 = NameAndType        <span class="comment">#66:#68        // append:(I)Ljava/lang/StringBuilder;</span></span><span class="meta prompt_">  #</span><span class="language-bash">57 = NameAndType        <span class="comment">#69:#70        // toString:()Ljava/lang/String;</span></span><span class="meta prompt_">  #</span><span class="language-bash">58 = Class              <span class="comment">#71            // java/io/PrintStream</span></span><span class="meta prompt_">  #</span><span class="language-bash">59 = NameAndType        <span class="comment">#72:#73        // println:(Ljava/lang/String;)V</span></span><span class="meta prompt_">  #</span><span class="language-bash">60 = Utf8               www.atguigu.com</span><span class="meta prompt_">  #</span><span class="language-bash">61 = Utf8               com/atguigu/java1/JavapTest</span><span class="meta prompt_">  #</span><span class="language-bash">62 = Utf8               java/lang/Object</span><span class="meta prompt_">  #</span><span class="language-bash">63 = Utf8               java/lang/System</span><span class="meta prompt_">  #</span><span class="language-bash">64 = Utf8               out</span><span class="meta prompt_">  #</span><span class="language-bash">65 = Utf8               Ljava/io/PrintStream;</span><span class="meta prompt_">  #</span><span class="language-bash">66 = Utf8               append</span><span class="meta prompt_">  #</span><span class="language-bash">67 = Utf8               (Ljava/lang/String;)Ljava/lang/StringBuilder;</span><span class="meta prompt_">  #</span><span class="language-bash">68 = Utf8               (I)Ljava/lang/StringBuilder;</span><span class="meta prompt_">  #</span><span class="language-bash">69 = Utf8               toString</span><span class="meta prompt_">  #</span><span class="language-bash">70 = Utf8               ()Ljava/lang/String;</span><span class="meta prompt_">  #</span><span class="language-bash">71 = Utf8               java/io/PrintStream</span><span class="meta prompt_">  #</span><span class="language-bash">72 = Utf8               println</span><span class="meta prompt_">  #</span><span class="language-bash">73 = Utf8               (Ljava/lang/String;)V</span></code></pre><h3 id="2-4-字段表集合的信息"><a href="#2-4-字段表集合的信息" class="headerlink" title="2.4 字段表集合的信息"></a>2.4 字段表集合的信息</h3><pre><code class="highlight shell">&#123;  private int num; // 字段名    descriptor: I // 字段表集合的信息    flags: ACC_PRIVATE // 字段的访问标识  boolean flag;    descriptor: Z    flags:  protected char gender;    descriptor: C    flags: ACC_PROTECTED  public java.lang.String info;    descriptor: Ljava/lang/String;    flags: ACC_PUBLIC  public static final int COUNTS;    descriptor: I    flags: ACC_PUBLIC, ACC_STATIC, ACC_FINAL    ConstantValue: int 1 // 常量字段的属性：ConstantValue</code></pre><h3 id="2-5-方法表集合的信息"><a href="#2-5-方法表集合的信息" class="headerlink" title="2.5 方法表集合的信息"></a>2.5 方法表集合的信息</h3><pre><code class="highlight shell">  public com.atguigu.java1.JavapTest(); // 无参构造器方法信息    descriptor: ()V    flags: ACC_PUBLIC    Code:      stack=2, locals=1, args_size=1         0: aload_0         1: invokespecial #1                  // Method java/lang/Object.&quot;&lt;init&gt;&quot;:()V         4: aload_0         5: ldc           #2                  // String java         7: putfield      #3                  // Field info:Ljava/lang/String;        10: return      LineNumberTable:        line 20: 0        line 18: 4        line 22: 10      LocalVariableTable:        Start  Length  Slot  Name   Signature            0      11     0  this   Lcom/atguigu/java1/JavapTest;private com.atguigu.java1.JavapTest(boolean); // 单个参数构造器方法信息    descriptor: (Z)V    flags: ACC_PRIVATE    Code:      stack=2, locals=2, args_size=2         0: aload_0         1: invokespecial #1                  // Method java/lang/Object.&quot;&lt;init&gt;&quot;:()V         4: aload_0         5: ldc           #2                  // String java         7: putfield      #3                  // Field info:Ljava/lang/String;        10: aload_0        11: iload_1        12: putfield      #4                  // Field flag:Z        15: return      LineNumberTable:        line 23: 0        line 18: 4        line 24: 10        line 25: 15      LocalVariableTable:        Start  Length  Slot  Name   Signature            0      16     0  this   Lcom/atguigu/java1/JavapTest;            0      16     1  flag   Z  private void methodPrivate();    descriptor: ()V    flags: ACC_PRIVATE    Code:      stack=0, locals=1, args_size=1         0: return      LineNumberTable:        line 28: 0      LocalVariableTable:        Start  Length  Slot  Name   Signature            0       1     0  this   Lcom/atguigu/java1/JavapTest;  int getNum(int);    descriptor: (I)I    flags:    Code:      stack=2, locals=2, args_size=2         0: aload_0         1: getfield      #5                  // Field num:I         4: iload_1         5: iadd         6: ireturn      LineNumberTable:        line 30: 0      LocalVariableTable:        Start  Length  Slot  Name   Signature            0       7     0  this   Lcom/atguigu/java1/JavapTest;            0       7     1     i   I  protected char showGender();    descriptor: ()C    flags: ACC_PROTECTED    Code:      stack=1, locals=1, args_size=1         0: aload_0         1: getfield      #6                  // Field gender:C         4: ireturn      LineNumberTable:        line 33: 0      LocalVariableTable:        Start  Length  Slot  Name   Signature            0       5     0  this   Lcom/atguigu/java1/JavapTest;  public void showInfo();    descriptor: ()V  // 方法的描述符：方法的形参列表、返回值类型    flags: ACC_PUBLIC // 方法的访问标识    Code: // 方法的Code属性      stack=3, locals=2, args_size=1  // stack：操作数栈的最大深度   locals：局部变量表的长度   args_size：方法接受参数的个数      // 偏移量  操作码   操作数         0: bipush        10         2: istore_1         3: getstatic     #7                  // Field java/lang/System.out:Ljava/io/PrintStream;         6: new           #8                  // class java/lang/StringBuilder         9: dup        10: invokespecial #9                  // Method java/lang/StringBuilder.&quot;&lt;init&gt;&quot;:()V        13: aload_0        14: getfield      #3                  // Field info:Ljava/lang/String;        17: invokevirtual #10                 // Method java/lang/StringBuilder.append:(Ljava/lang/String;)Ljava/lang/StringBuilder;        20: iload_1        21: invokevirtual #11                 // Method java/lang/StringBuilder.append:(I)Ljava/lang/StringBuilder;        24: invokevirtual #12                 // Method java/lang/StringBuilder.toString:()Ljava/lang/String;        27: invokevirtual #13                 // Method java/io/PrintStream.println:(Ljava/lang/String;)V        30: return              // 行号表：指明字节码指令的偏移量与java源代码中代码的行号的一一对应关系      LineNumberTable:        line 36: 0        line 37: 3        line 38: 30              // 局部变量表：描述内部局部变量的相关信息      LocalVariableTable:        Start  Length  Slot  Name   Signature            0      31     0  this   Lcom/atguigu/java1/JavapTest;            3      28     1     i   I  static &#123;&#125;;    descriptor: ()V    flags: ACC_STATIC    Code:      stack=1, locals=1, args_size=0         0: ldc           #14                 // String www.atguigu.com         2: astore_0         3: return      LineNumberTable:        line 15: 0        line 16: 3      LocalVariableTable:        Start  Length  Slot  Name   Signature&#125; // 附加属性：指明当前字节码文件对应的源程序文件名SourceFile: &quot;JavapTest.java&quot;</code></pre><h3 id="2-6-jclasslib展示的内容："><a href="#2-6-jclasslib展示的内容：" class="headerlink" title="2.6 jclasslib展示的内容："></a>2.6 jclasslib展示的内容：</h3><p><img src="https://raw.githubusercontent.com/GeorgeChan95/blogimg/master/img/2024/07/22/20240722-100533.png" alt="jclasslib"></p><h1 id="五、总结"><a href="#五、总结" class="headerlink" title="五、总结"></a>五、总结</h1><ul><li><p>通过 javap 命令可以査看一个java类反汇编得到的class文件版本号、常量池、访问标识、变量表、指令代码行号表等等信息。不显示类索引、父类索引、接口索引集合、<clinit>()、<init>()等结构</p></li><li><p>通过对前面例子代码反汇编文件的简单分析，可以发现，一个方法的执行通常会涉及下面几块内存的操作:</p><ul><li>java栈中:局部变量表、操作数栈。</li><li>java堆。通过对象的地址引用去操作。</li><li>常量池。</li><li>其他如帧数据区、方法区的剩余部分等情况，测试中没有显示出来，这里说明一下。</li></ul></li><li><p>平常，我们比较关注的是java类中每个方法的反汇编中的指令操作过程，这些指令都是顺序执行的，可以参考官方文档查看每个指令的含义，很简单: <a href="https://docs.oracle.com/javase/specs/jvms/se7/html/jvms-6.html">https://docs.oracle.com/javase/specs/jvms/se7/html/jvms-6.html</a></p></li></ul>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;一、解析字节码的作用&quot;&gt;&lt;a href=&quot;#一、解析字节码的作用&quot; class=&quot;headerlink&quot; title=&quot;一、解析字节码的作用&quot;&gt;&lt;/a&gt;一、解析字节码的作用&lt;/h1&gt;&lt;p&gt;通过反编译生成的字节码文件，我们可以深入的了解java代码的工作机制。但是，</summary>
      
    
    
    
    <category term="JVM" scheme="https://georgechan95.github.io/categories/JVM/"/>
    
    
    <category term="jvm" scheme="https://georgechan95.github.io/tags/jvm/"/>
    
    <category term="java" scheme="https://georgechan95.github.io/tags/java/"/>
    
  </entry>
  
  <entry>
    <title>第十六章-Class文件结构</title>
    <link href="https://georgechan95.github.io/2024/07/15/jvm/%E7%AC%AC%E5%8D%81%E5%85%AD%E7%AB%A0-Class%E6%96%87%E4%BB%B6%E7%BB%93%E6%9E%84/"/>
    <id>https://georgechan95.github.io/2024/07/15/jvm/%E7%AC%AC%E5%8D%81%E5%85%AD%E7%AB%A0-Class%E6%96%87%E4%BB%B6%E7%BB%93%E6%9E%84/</id>
    <published>2024-07-15T11:54:50.000Z</published>
    <updated>2024-07-20T09:51:02.837Z</updated>
    
    <content type="html"><![CDATA[<h1 id="一、概述"><a href="#一、概述" class="headerlink" title="一、概述"></a>一、概述</h1><h2 id="1-字节码文件的跨平台型"><a href="#1-字节码文件的跨平台型" class="headerlink" title="1. 字节码文件的跨平台型"></a>1. 字节码文件的跨平台型</h2><p><strong>1. Java语言: 跨平台的语言</strong></p><p>当Java源代码成功编译成字节码后，如果想在不同的平台上面运行，则无须再次编译,这个优势不再那么吸引人了。Python、PHP、Per1、Ruby、Lisp等有强大的解释器。跨平台似乎已经快成为一门语言必选的特性。</p><p><strong>2. Java 虚拟机:跨语言的平台</strong></p><p><strong>Java虚拟机不和包括 Java 在内的任何语言绑定，它只与“c1ass 文件”这种特定的二进制文件格式所关联。</strong>无论使用何种语言进行软件开发，只要能将源文件编译为正确的Class文件，那么这种语言就可以在Java虚拟机上执行。可以说，统一而强大的Class文件结构，就是Java虚拟机的基石、桥梁。</p><p><img src="https://raw.githubusercontent.com/GeorgeChan95/blogimg/master/img/2024/07/19/20240719-103403.jpg" alt="JVM的平台无关性"></p><p>JAVA虚拟机规范官方文档: <a href="https://docs.oracle.com/javase/specs/jvms/se8/html/index.html">https://docs.oracle.com/javase/specs/jvms/se8/html/index.html</a></p><p>所有的JVM全部遵守Java虚拟机规范，也就是说所有的JVM环境都是一样的，这样一来字节码文件可以在各种JVM上运行。</p><p><strong>3. 想要让一个]ava程序正确地运行在JVM中，Java源码就必须要被编译为符合JVM规范的字节码。</strong></p><ul><li>前端编译器的主要任务就是负责将符合]ava语法规范的]ava代码转换为符合JVM规范的字节码文件。</li><li>javac是一种能够将Java源码编译为字节码的前端编译器。</li><li>Javac编译器在将]ava源码编译为一个有效的字节码文件过程中经历了4个步骤，分别是 <strong>词法解析、语法解析、语义解析以及生成字节码</strong>。</li></ul><p><img src="https://raw.githubusercontent.com/GeorgeChan95/blogimg/master/img/2024/07/19/20240719-103432.jpg" alt="JVM结构"></p><p><strong>Oracle的JDK软件包括两部分内容:</strong></p><ul><li><p>一部分是将Java源代码编译成Java虚拟机的指令集的编译器</p></li><li><p>另一部分是用于实现Java虚拟机的运行时环境。</p></li></ul><h2 id="2-Java的前端编译器"><a href="#2-Java的前端编译器" class="headerlink" title="2. Java的前端编译器"></a>2. Java的前端编译器</h2><p><img src="https://raw.githubusercontent.com/GeorgeChan95/blogimg/master/img/2024/07/19/20240719-103807.jpg" alt="理解执行引擎"></p><p><strong>前端编译器 vs 后端编译器</strong></p><p>Java源代码的编译结果是字节码，那么肯定需要有一种编译器能够将]ava源码编译为字节码，承担这个重要责任的就是配置在path环境变量中的javac编译器。iavac是一种能够将]ava源码编译为字节码的前端编译器。</p><p>Hotspot VM并没有强制要求前端编译器只能使用javac来编译字节码，其实只要编译结果符合JVM规范都可以被JVM所识别即可。在]ava的前端编译器领域，除了javac之外，还有一种被大家经常用到的前端编译器，那就是内置在Eclipse中的ECJ(Eclipse Compiler for Java)编译器。和Javac的全量式编译不同，ECj是一种增量式编译器。</p><ul><li>在Eclipse中，当开发人员编写完代码后，使用“ctrl+S”快捷键时，ECj编译器所采取的编译方案是把未编译部分的源码逐行进行编译，而非每次都全量编译。因此ECJ的编译效率会比Javac更加迅速和高效，当然编译质量和javac相比大致还是一样的。</li><li>ECJ不仅是Eclipse的默认内置前端编译器，在Tomcat中同样也是使用ECJ编译器来编译jsp文件。由于ECJ编译器是采用GPLv2的开源协议进行源代码公开，所以，大家可以登录eclipse官网下载ECJ编译器的源码进行二次开发。默认情况下，IntelliJ IDEA 使用 javac 编译器。(还可以自己设置为AspectJ编译器 ajc)</li></ul><p>前端编译器并不会直接涉及编译优化等方面的技术，而是将这些具体优化细节移交给HotSpot的JIT编译器负责。</p><p>顺便提一句: <strong>AOT(静态提前编译器，Ahead Of Time Compiler)</strong></p><h1 id="二、虚拟机的基石-Class文件"><a href="#二、虚拟机的基石-Class文件" class="headerlink" title="二、虚拟机的基石: Class文件"></a>二、虚拟机的基石: Class文件</h1><ul><li><p>字节码文件里是什么?</p><p>源代码经过编译器编译之后便会生成一个字节码文件，字节码是一种二进制的类文件，它的内容是JVM的指令，而不像C、C++经由编译器直接生成机器码。</p></li><li><p>什么是字节码指令(byte code)?</p><p>Java虚拟机的指令由一个字节长度的、代表着某种特定操作含义的操作码(opcode)以及跟随其后的零至多个代表此操作所需参数的操作数(operand)所构成。虚拟机中许多指令并不包含操作数，只有一个操作码。</p><p><img src="https://raw.githubusercontent.com/GeorgeChan95/blogimg/master/img/2024/07/19/20240719-111004.png" alt="字节码指令"></p></li></ul><p><strong>如何解读供虚拟机解释执行的二进制字节码?</strong></p><ul><li><p>方式一: 一个一个二进制的看。这里用到的是Notepad++,需要安装一个HEX-Editor插件，或者使用Binary Viewer</p><img src="https://raw.githubusercontent.com/GeorgeChan95/blogimg/master/img/2024/07/19/20240719-112211.png" alt="使用HEX-Editor插件插件.class文件" style="zoom: 67%;" /><p>插件离线下载地址: <a href="https://github.com/chcg/NPP_HexEdit/releases">https://github.com/chcg/NPP_HexEdit/releases</a></p></li><li><p>方式二:使用javap指令:jdk自带的反解析工具</p><pre><code class="highlight shell">javap -v xxx.class</code></pre><p><img src="https://raw.githubusercontent.com/GeorgeChan95/blogimg/master/img/2024/07/19/20240719-112549.png" alt="javap指令"></p></li><li><p>方式三:【使用IDEA插件:jclasslib 或jclasslib bytecode viewer客户端工具。(可视化更好)</p><p><img src="https://raw.githubusercontent.com/GeorgeChan95/blogimg/master/img/2024/07/19/20240719-112658.png" alt="IDEA插件:jclasslib"></p></li></ul><h1 id="三、Class字节码文件结构"><a href="#三、Class字节码文件结构" class="headerlink" title="三、Class字节码文件结构"></a>三、Class字节码文件结构</h1><h2 id="0-字节码文件概览"><a href="#0-字节码文件概览" class="headerlink" title="0. 字节码文件概览"></a>0. 字节码文件概览</h2><p><strong>1. 文件结构</strong></p><table><thead><tr><th></th><th>类型</th><th>名称</th><th>说明</th><th>长度</th><th>数量</th></tr></thead><tbody><tr><td>魔数</td><td>u4</td><td>magic</td><td>魔数,识别Class文件格式</td><td>4个字节</td><td>1</td></tr><tr><td>版本号</td><td>u2</td><td>minor_version</td><td>副版本号(小版本)</td><td>2个字节</td><td>1</td></tr><tr><td></td><td>u2</td><td>major_version</td><td>主版本号(大版本)</td><td>2个字节</td><td>1</td></tr><tr><td>常量池集合</td><td>u2</td><td>constant_pool_count</td><td>常量池计数器</td><td>2个字节</td><td>1</td></tr><tr><td></td><td>cp_info</td><td>constant_pool</td><td>常量池表</td><td>n个字节</td><td>constant_pool_count - 1</td></tr><tr><td>访问标识</td><td>u2</td><td>access_flags</td><td>访问标识</td><td>2个字节</td><td>1</td></tr><tr><td>索引集合</td><td>u2</td><td>this_class</td><td>类索引</td><td>2个字节</td><td>1</td></tr><tr><td></td><td>u2</td><td>super_class</td><td>父类索引</td><td>2个字节</td><td>1</td></tr><tr><td></td><td>u2</td><td>interfaces_count</td><td>接口计数器</td><td>2个字节</td><td>1</td></tr><tr><td></td><td>u2</td><td>interfaces</td><td>接口索引集合</td><td>2个字节</td><td>interfaces_count</td></tr><tr><td>字段表集合</td><td>u2</td><td>fields_count</td><td>字段计数器</td><td>2个字节</td><td>1</td></tr><tr><td></td><td>field_info</td><td>fields</td><td>字段表</td><td>n个字节</td><td>fields_count</td></tr><tr><td>方法表集合</td><td>u2</td><td>methods_count</td><td>方法计数器</td><td>2个字节</td><td>1</td></tr><tr><td></td><td>method_info</td><td>methods</td><td>方法表</td><td>n个字节</td><td>methods_count</td></tr><tr><td>属性表集合</td><td>u2</td><td>attributes_count</td><td>属性计数器</td><td>2个字节</td><td>1</td></tr><tr><td></td><td>attribute_info</td><td>attributes</td><td>属性表</td><td>n个字节</td><td>attributes_count</td></tr></tbody></table><p><strong>2. 示例代码</strong></p><pre><code class="highlight plaintext">public class Demo &#123;    private int num = 1;    public int add()&#123;        num = num + 2;        return num;    &#125;&#125;</code></pre><p><strong>3. 字节码</strong></p><pre><code class="highlight txt">cafebabe0000003400160a0004001209000300130700140700150100036e756d 010001490100063c696e69743e010003282956010004436f646501000f4c696e 654e756d6265725461626c650100124c 6f63616c5661726961626c655461626c 65010004746869730100184c636f6d2f 617467756967752f6a617661312f44656d6f3b01000361646401000328294901000a536f7572636546696c6501000944656d6f2e6a6176610c000700080c00050006010016636f6d2f617467756967752f6a617661312f44656d6f0100106a6176612f6c616e672f4f626a65637400210003000400000001000200050006000000020001000700080001000900000038000200010000000a2ab700012a04b50002b100000002000a0000000a00020000000700040008000b0000000c00010000000a000c000d00000001000e000f000100090000003d000300010000000f2a2a b400020560b500022ab40002ac00000002000a0000000a00020000000b000a000c000b0000000c00010000000f000c000d000000010010000000020011</code></pre><p><strong>4. 字节码解析</strong></p><p><img src="https://raw.githubusercontent.com/GeorgeChan95/blogimg/master/img/2024/07/20/20240720-175022.png" alt="demo.java字节码解析"></p><p>二、Class文件数据类型</p><table><thead><tr><th>数据类型</th><th>定义</th><th>说明</th></tr></thead><tbody><tr><td>无符号数</td><td>无符号数可以用来描述数字、索引引用、数量值或按照utf-8编码构成的字符串值。</td><td>其中无符号数属于基本的数据类型。 以u1、u2、u4、u8来分别代表1个字节、2个字节、4个字节和8个字节</td></tr><tr><td>表</td><td>表是由多个无符号数或其他表构成的复合数据结构。</td><td>所有的表都以“_info”结尾。 由于表没有固定长度，所以通常会在其前面加上个数说明。</td></tr></tbody></table><h2 id="1-魔数"><a href="#1-魔数" class="headerlink" title="1. 魔数"></a>1. 魔数</h2><p><strong>Magic Number（魔数）</strong></p><ul><li><p>每个Class文件开头的4个字节的无符号整数称为魔数（Magic Number）</p></li><li><p>它的唯一作用是确定这个文件是否为一个能被虚拟机接受的有效合法的Class文件。即：魔数是Class文件的标识符。</p></li><li><p>魔数值固定为0xCAFEBABE。不会改变。</p></li><li><p>如果一个Class文件不以0xCAFEBABE开头，虚拟机在进行文件校验的时候就会直接抛出以下错误：</p><pre><code class="highlight java">Error: A JNI error has occurred, please check your installation and <span class="keyword">try</span> againException in thread <span class="string">&quot;main&quot;</span> java.lang.ClassFormatError: Incompatible magic value <span class="number">1885430635</span> in <span class="keyword">class</span> <span class="title class_">file</span> StringTest</code></pre></li></ul><h2 id="2-文件版本号"><a href="#2-文件版本号" class="headerlink" title="2. 文件版本号"></a>2. 文件版本号</h2><p>紧接着魔数的4个字节存储的是Class文件的版本号。同样也是4个字节。第5个和第6个字节所代表的含义就是编译的副版本号minor_version，而第7个和第8个字节就是编译的主版本号major_version。</p><p>它们共同构成了class文件的格式版本号。譬如某个Class文件的主版本号为M，副版本号为m，那么这个Class文件的格式版本号就确定为M.m。</p><h3 id="2-1-Class文件版本号对应关系"><a href="#2-1-Class文件版本号对应关系" class="headerlink" title="2.1 Class文件版本号对应关系"></a>2.1 Class文件版本号对应关系</h3><table><thead><tr><th>主版本（十进制）</th><th>副版本（十进制）</th><th>编译器版本</th></tr></thead><tbody><tr><td>45</td><td>3</td><td>1.1</td></tr><tr><td>46</td><td>0</td><td>1.2</td></tr><tr><td>47</td><td>0</td><td>1.3</td></tr><tr><td>48</td><td>0</td><td>1.4</td></tr><tr><td>49</td><td>0</td><td>1.5</td></tr><tr><td>50</td><td>0</td><td>1.6</td></tr><tr><td>51</td><td>0</td><td>1.7</td></tr><tr><td>52</td><td>0</td><td>1.8</td></tr><tr><td>53</td><td>0</td><td>1.9</td></tr><tr><td>54</td><td>0</td><td>1.10</td></tr><tr><td>55</td><td>0</td><td>1.11</td></tr></tbody></table><p>Java的版本号是从45开始的，JDK1.1之后的每个JDK大版本发布主版本号向上加1。</p><p>不同版本的Java编译器编译的Class文件对应的版本是不一样的。目前，高版本的Java虚拟机可以执行由低版本编译器生成的Class文件，但是低版本的Java虚拟机不能执行由高版本编译器生成的Class文件。否则JVM会抛出java.lang.UnsupportedClassVersionError异常。（向下兼容）</p><p>在实际应用中，由于开发环境和生产环境的不同，可能会导致该问题的发生。因此，需要我们在开发时，特别注意开发编译的JDK版本和生产环境中的JDK版本是否一致。</p><ul><li>虚拟机JDK版本为1.k（k&gt;&#x3D;2）时，对应的class文件格式版本号的范围为45.0 - 44+k.0（含两端）。</li></ul><h2 id="3-常量池集合"><a href="#3-常量池集合" class="headerlink" title="3. 常量池集合"></a>3. 常量池集合</h2><p>常量池是Class文件中内容最为丰富的区域之一。常量池对于Class文件中的字段和方法解析也有着至关重要的作用。</p><p>随着Java虚拟机的不断发展，常量池的内容也日渐丰富。可以说，常量池是整个Class文件的基石。</p><p><img src="https://raw.githubusercontent.com/GeorgeChan95/blogimg/master/img/2024/07/18/20240718-192319.png" alt="常量池"></p><p>在版本号之后，紧跟着的是常量池的数量，以及若干个常量池表项。</p><p>常量池中常量的数量是不固定的，所以在常量池的入口需要放置一项u2类型的无符号数，代表常量池容量计数值（constant_pool_count）。与Java中语言习惯不一样的是，这个容量计数是从1而不是0开始的。</p><table><thead><tr><th>类型</th><th>名称</th><th>数量</th></tr></thead><tbody><tr><td>u2（无符号数）</td><td>constant_pool_count</td><td>1</td></tr><tr><td>cp_info（表）</td><td>constant_pool</td><td>constant_pool_count - 1</td></tr></tbody></table><p>由上表可见，Class文件使用了一个前置的容量计数器（constant_pool_count）加若干个连续的数据项（constant_pool）的形式来描述常量池内容。我们把这一系列连续常量池数据称为常量池集合。</p><ul><li>常量池表项中，用于存放编译时期生成的各种字面量和符号引用，这部分内容将在类加载后进入方法区的运行时常量池中存放</li></ul><p><img src="https://raw.githubusercontent.com/GeorgeChan95/blogimg/master/img/2024/07/18/20240718-194527.png" alt="jclasslib"></p><h3 id="3-1-常量池计数器"><a href="#3-1-常量池计数器" class="headerlink" title="3.1 常量池计数器"></a>3.1 常量池计数器</h3><p><strong>constant_pool_count（常量池计数器）</strong></p><ul><li><p>由于常量池的数量不固定，时长时短，所以需要放置两个字节来表示常量池容量计数值。</p></li><li><p>常量池容量计数值（u2类型）：从1开始，表示常量池中有多少项常量。即constant_pool_count&#x3D;1表示常量池中有0个常量项。</p></li><li><p>Demo的值为：</p><p><img src="https://raw.githubusercontent.com/GeorgeChan95/blogimg/master/img/2024/07/18/20240718-200507.png" alt="常量池计数器"></p></li></ul><p>其值为0x0016，转换成10进制就是22。需要注意的是，这实际上只有21项常量。索引为范围是1-21。为什么呢？</p><p>通常我们写代码时都是从0开始的，但是这里的常量池却是从1开始，因为它把第0项常量空出来了。这是为了满足后面某些指向常量池的索引值的数据在特定情况下需要表达“不引用任何一个常量池项目”的含义，这种情况可用索引值0来表示。</p><h3 id="3-2-常量池表"><a href="#3-2-常量池表" class="headerlink" title="3.2 常量池表"></a>3.2 常量池表</h3><p>constant_pool是一种表结构，以1 ~ constant_pool_count - 1为索引。表明了后面有多少个常量项。</p><p><strong>常量池主要存放两大类常量：字面量（Literal）和符号引用（Symbolic References）</strong></p><p>它包含了class文件结构及其子结构中引用的所有字符串常量、类或接口名、字段名和其他常量。常量池中的每一项都具备相同的特征。第1个字节作为类型标记，用于确定该项的格式，这个字节称为tag byte（标记字节、标签字节）。</p><p><strong>常量类型与结构表</strong></p><table><thead><tr><th>类型</th><th>标志(或标识)</th><th>描述</th></tr></thead><tbody><tr><td>CONSTANT_Utf8_info</td><td>1</td><td>UTF-8编码的字符串</td></tr><tr><td>CONSTANT_Integer_info</td><td>3</td><td>整型字面量</td></tr><tr><td>CONSTANT_Float_info</td><td>4</td><td>浮点型字面量</td></tr><tr><td>CONSTANT_Long_info</td><td>5</td><td>长整型字面量</td></tr><tr><td>CONSTANT_Double_info</td><td>6</td><td>双精度浮点型字面量</td></tr><tr><td>CONSTANT_Class_info</td><td>7</td><td>类或接口的符号引用</td></tr><tr><td>CONSTANT_String_info</td><td>8</td><td>字符串类型字面量</td></tr><tr><td>CONSTANT_Fieldref_info</td><td>9</td><td>字段的符号引用</td></tr><tr><td>CONSTANT_Methodref_info</td><td>10</td><td>类中方法的符号引用</td></tr><tr><td>CONSTANT_InterfaceMethodref_info</td><td>11</td><td>接口中方法的符号引用</td></tr><tr><td>CONSTANT_NameAndType_info</td><td>12</td><td>字段或方法的符号引用</td></tr><tr><td>CONSTANT_MethodHandle_info</td><td>15</td><td>表示方法句柄</td></tr><tr><td>CONSTANT_MethodType_info</td><td>16</td><td>标志方法类型</td></tr><tr><td>CONSTANT_InvokeDynamic_info</td><td>18</td><td>表示一个动态方法调用点</td></tr></tbody></table><p><strong>常量类型与结构细节</strong></p><table><thead><tr><th>标志</th><th>常量</th><th>描述</th><th>细节</th><th>长度</th><th>细节描述</th></tr></thead><tbody><tr><td>1</td><td>CONSTANT_utf8_info</td><td>UTF-8编码的字符串</td><td>tag</td><td>u1</td><td>值为1</td></tr><tr><td></td><td></td><td></td><td>length</td><td>u2</td><td>UTF-8编码的字符串占用的字符数</td></tr><tr><td></td><td></td><td></td><td>bytes</td><td>u1</td><td>长度为length的UTF-8编码的字符串</td></tr><tr><td>3</td><td>CONSTANT_Integer_info</td><td>整型字面量</td><td>tag</td><td>u1</td><td>值为3</td></tr><tr><td></td><td></td><td></td><td>bytes</td><td>u4</td><td>按照高位在前存储的int值</td></tr><tr><td>4</td><td>CONSTANT_Float_info</td><td>浮点型字面量</td><td>tag</td><td>u1</td><td>值为4</td></tr><tr><td></td><td></td><td></td><td>bytes</td><td>u4</td><td>按照高位在前存储的float值</td></tr><tr><td>5</td><td>CONSTANT_Long_info</td><td>长整型字面量</td><td>tag</td><td>u1</td><td>值为5</td></tr><tr><td></td><td></td><td></td><td>bytes</td><td>u8</td><td>按照高位在前存储的long值</td></tr><tr><td>6</td><td>CONSTANT_Double_info</td><td>双精度浮点型字面量</td><td>tag</td><td>u1</td><td>值为6</td></tr><tr><td></td><td></td><td></td><td>bytes</td><td>u8</td><td>按照高位在前存储的double值</td></tr><tr><td>7</td><td>CONSTANT_Class_info</td><td>类或接口的符号引用</td><td>tag</td><td>u1</td><td>值为7</td></tr><tr><td></td><td></td><td></td><td>index</td><td>u2</td><td>指向全限定名常量项的索引</td></tr><tr><td>8</td><td>CONSTANT_String_info</td><td>字符串类型字面量</td><td>tag</td><td>u1</td><td>值为8</td></tr><tr><td></td><td></td><td></td><td>index</td><td>u2</td><td>指向字符串字面量的索引</td></tr><tr><td>9</td><td>CONSTANT_Fieldref_info</td><td>字段的符号引用</td><td>tag</td><td>u1</td><td>值为9</td></tr><tr><td></td><td></td><td></td><td>index</td><td>u2</td><td>指向声明字段的类或接口描述符CONSTANT_Class_info的索引项</td></tr><tr><td></td><td></td><td></td><td>index</td><td>u2</td><td>指向字段描述符CONSTANT_NameAndType的索引项</td></tr><tr><td>10</td><td>CONSTANT_Methodref_info</td><td>类中方法的符号引用</td><td>tag</td><td>u1</td><td>值为10</td></tr><tr><td></td><td></td><td></td><td>index</td><td>u2</td><td>指向声明方法的类描述符CONSTANT_Class_Info的索引项</td></tr><tr><td></td><td></td><td></td><td>index</td><td>u2</td><td>指向名称及类型描述符CONSTANT_NameAndType的索引项</td></tr><tr><td>11</td><td>CONSTANT_InterfaceMethodref_info</td><td>接口中方法的符号引用</td><td>tag</td><td>u1</td><td>值为11</td></tr><tr><td></td><td></td><td></td><td>index</td><td>u2</td><td>指向声明方法的接口描述符CONSTANT_Class_Info的索引项</td></tr><tr><td></td><td></td><td></td><td>index</td><td>u2</td><td>指向名称及类型描述符CONSTANT_NameAndType的索引项</td></tr><tr><td>12</td><td>CONSTANT_NameAndType_info</td><td>字段或方法的符号引用</td><td>tag</td><td>u1</td><td>值为12</td></tr><tr><td></td><td></td><td></td><td>index</td><td>u2</td><td>指向该字段或方法名称常量项的索引</td></tr><tr><td></td><td></td><td></td><td>index</td><td>u2</td><td>指向该字段或方法描述符常量项的索引</td></tr><tr><td>15</td><td>CONSTANT_MethodHandle_info</td><td>表示方法句柄</td><td>tag</td><td>u1</td><td>值为15</td></tr><tr><td></td><td></td><td></td><td>reference_kind</td><td>u1</td><td>值必须在1-9之间，它决定了方法句柄的类型方法句柄类型的值表示方法句柄的字节码行为</td></tr><tr><td></td><td></td><td></td><td>reference_index</td><td>u2</td><td>值必须是对常量池的有效索引</td></tr><tr><td>16</td><td>CONSTANT_MethodType_info</td><td>标志方法类型</td><td>tag</td><td>u1</td><td>值为16</td></tr><tr><td></td><td></td><td></td><td>descriptor_index</td><td>u2</td><td>值必须是对常量池的有效索引，常量池在该索引处的项必须是CONSTANT_Utf8_info结构，表示方法的描述符</td></tr><tr><td>18</td><td>CONSTANT_InvokeDynamic_info</td><td>表示一个动态方法调用点</td><td>tag</td><td>u1</td><td>值为18</td></tr><tr><td></td><td></td><td></td><td>bootstrap_method_attr</td><td>u2</td><td>值必须是对当前Class文件中引导方法表的bootstrap_methods[]数组的有效索引</td></tr><tr><td></td><td></td><td></td><td>name_and_type_index</td><td>u2</td><td>值必须是对当前常量池的有效索引，常量池在该索引处的项必须是CONSTANT_NameAndType_Info结构，表示方法名和方法描述符</td></tr></tbody></table><h4 id="3-2-1-字面量和符号引用"><a href="#3-2-1-字面量和符号引用" class="headerlink" title="3.2.1 字面量和符号引用"></a>3.2.1 字面量和符号引用</h4><p>在对这些常量解读前，我们需要搞清楚几个概念。</p><p>常量池主要存放两大类常量：<strong>字面量（Literal）和符号引用（Symbolic References）</strong>。如下表：</p><table><thead><tr><th>常量</th><th>具体的常量</th></tr></thead><tbody><tr><td>字面量</td><td>文本字符串</td></tr><tr><td></td><td>声明为final的常量值</td></tr><tr><td>符号引用</td><td>类和接口的全限定名</td></tr><tr><td></td><td>字段的名称和描述符</td></tr><tr><td></td><td>方法的名称和描述符</td></tr></tbody></table><p><strong>全限定名</strong></p><p>com&#x2F;atguigu&#x2F;test&#x2F;Demo这个就是类的全限定名，仅仅是把包名的“.“替换成”&#x2F;”，为了使连续的多个全限定名之间不产生混淆，在使用时最后一般会加入一个“;”表示全限定名结束。</p><p><strong>简单名称</strong></p><p>简单名称是指<strong>没有类型和参数修饰的方法或者字段名称</strong>，上面例子中的类的add()方法和num字段的简单名称分别是add和num。</p><p><strong>描述符</strong></p><p>描述符的作用是用来描述字段的数据类型、方法的参数列表（包括数量、类型以及顺序）和返回值。根据描述符规则，基本数据类型（byte、char、double、float、int、long、short、boolean）以及代表无返回值的void类型都用一个大写字符来表示，而对象类型则用字符L加对象的全限定名来表示，详见下表：</p><table><thead><tr><th>标志符</th><th>含义</th></tr></thead><tbody><tr><td>B</td><td>基本数据类型byte</td></tr><tr><td>C</td><td>基本数据类型char</td></tr><tr><td>D</td><td>基本数据类型double</td></tr><tr><td>F</td><td>基本数据类型float</td></tr><tr><td>I</td><td>基本数据类型int</td></tr><tr><td>J</td><td>基本数据类型long</td></tr><tr><td>S</td><td>基本数据类型short</td></tr><tr><td>Z</td><td>基本数据类型boolean</td></tr><tr><td>V</td><td>代表void类型</td></tr><tr><td>L</td><td>对象类型，比如：<code>Ljava/lang/Object;</code></td></tr><tr><td>[</td><td>数组类型，代表一维数组。比如：&#96;double[] is [D</td></tr></tbody></table><p>用描述符来描述方法时，按照先参数列表，后返回值的顺序描述，参数列表按照参数的严格顺序放在一组小括号“()”之内。如方法 java.lang.String tostring() 的描述符为 <code>()Ljava/lang/String</code> ，方法 <code>int abc(int[]x, int y)</code> 的描述符为 <code>([II)I</code></p><p><strong>补充说明：</strong></p><p>虚拟机在加载Class文件时才会进行动态链接，也就是说，Class文件中不会保存各个方法和字段的最终内存布局信息。因此，这些字段和方法的符号引用不经过转换是无法直接被虚拟机使用的。当虚拟机运行时，需要从常量池中获得对应的符号引用，再在类加载过程中的解析阶段将其替换为直接引用，并翻译到具体的内存地址中。</p><p>这里说明下符号引用和直接引用的区别与关联：</p><ul><li><p>符号引用：符号引用以一组符号来描述所引用的目标，符号可以是任何形式的字面量，只要使用时能无歧义地定位到目标即可。符号引用与虚拟机实现的内存布局无关，引用的目标并不一定已经加载到了内存中。</p></li><li><p>直接引用：直接引用可以是直接指向目标的指针、相对偏移量或是一个能间接定位到目标的句柄。直接引用是与虚拟机实现的内存布局相关的，同一个符号引用在不同虚拟机实例上翻译出来的直接引用一般不会相同。如果有了直接引用，那说明引用的目标必定已经存在于内存之中了。</p></li></ul><h4 id="3-2-2-常量类型和结构"><a href="#3-2-2-常量类型和结构" class="headerlink" title="3.2.2 常量类型和结构"></a>3.2.2 常量类型和结构</h4><p>常量池中每一项常量都是一个表，J0K1.7之后共有14种不同的表结构数据。如下表格所示：</p><p><img src="https://raw.githubusercontent.com/GeorgeChan95/blogimg/master/img/2024/07/18/20240718-205459.png" alt="常量类型和结构"></p><p>根据上图每个类型的描述我们也可以知道每个类型是用来描述常量池中哪些内容（主要是字面量、符号引用）的。比如 :</p><p>CONSTANT_Integer_info是用来描述常量池中字面量信息的，而且只是整型字面量信息。</p><p>标志为15、16、18的常量项类型是用来支持动态语言调用的（jdk1.7时才加入的）。</p><p><strong>细节说明</strong></p><ul><li><p>CONSTANT_Class_info 结构用于表示类或接口</p></li><li><p>CONSTAT_Fieldref_info、CONSTAHT_Methodref_info 和 CONSTANIT_InterfaceMethodref_info 结构表示字段、方法和接口方法</p></li><li><p>CONSTANT_String_info 结构用于表示String类型的常量对象</p></li><li><p>CONSTANT_Integer_info 和 CONSTANT_Float_info 表示4字节（int和float）的数值常量</p></li><li><p>CONSTANT_Long_info 和 CONSTANT_Double_info 结构表示8字节（long和double）的数值常量 </p></li><li><ul><li>在class文件的常量池表中，所有的8字节常量均占两个表成员（项）的空间。如果一个CONSTANT_Long_info 和 CONSTANT_Double_info 结构在常量池中的索引位n，则常量池中一个可用的索引位n+2，此时常量池长中索引为n+1的项仍然有效但必须视为不可用的。</li></ul></li><li><p>CONSTANT_NameAndType_info 结构用于表示字段或方法，但是和之前的3个结构不同，CONSTANT_NameAndType_info 结构没有指明该字段或方法所属的类或接口。</p></li><li><p>CONSTANT_Utf8_info 用于表示字符常量的值</p></li><li><p>CONSTANT_MethodHandle_info 结构用于表示方法句柄</p></li><li><p>CONSTANT_MethodType_info 结构表示方法类型</p></li><li><p>CONSTANT_InvokeDynamic_info结构表示invokedynamic指令所用到的引导方法(bootstrap method)、引导方法所用到的动态调用名称(dynamic invocation name)、参数和返回类型，并可以给引导方法传入一系列称为静态参数（static argument）的常量。</p></li></ul><h2 id="4-访问标志"><a href="#4-访问标志" class="headerlink" title="4. 访问标志"></a>4. 访问标志</h2><p><strong>访问标识（access_flag、访问标志、访问标记）</strong></p><p>在常量池后，紧跟着访问标记。该标记使用两个字节表示，用于识别一些类或者接口层次的访问信息，包括：这个Class是类还是接口；是否定义为public类型；是否定义为abstract类型；如果是类的话，是否被声明为final等。各种访问标记如下所示：</p><table><thead><tr><th>标志名称</th><th>标志值</th><th>含义</th></tr></thead><tbody><tr><td>ACC_PUBLIC</td><td>0x0001</td><td>标志为public类型</td></tr><tr><td>ACC_FINAL</td><td>0x0010</td><td>标志被声明为final，只有类可以设置</td></tr><tr><td>ACC_SUPER</td><td>0x0020</td><td>标志允许使用invokespecial字节码指令的新语义，JDK1.0.2之后编译出来的类的这个标志默认为真。（使用增强的方法调用父类方法）</td></tr><tr><td>ACC_INTERFACE</td><td>0x0200</td><td>标志这是一个接口</td></tr><tr><td>ACC_ABSTRACT</td><td>0x0400</td><td>是否为abstract类型，对于接口或者抽象类来说，此标志值为真，其他类型为假</td></tr><tr><td>ACC_SYNTHETIC</td><td>0x1000</td><td>标志此类并非由用户代码产生（即：由编译器产生的类，没有源码对应）</td></tr><tr><td>ACC_ANNOTATION</td><td>0x2000</td><td>标志这是一个注解</td></tr><tr><td>ACC_ENUM</td><td>0x4000</td><td>标志这是一个枚举</td></tr></tbody></table><ul><li>类的访问权限通常为ACC_开头的常量。</li><li>每一种类型的表示都是通过设置访问标记的32位中的特定位来实现的。比如，若是public final的类，则该标记为ACC_PUBLIC | ACC_FINAL</li><li>使用ACC_SUPER可以让类更准确地定位到父类的方法super.method()，现代编译器都会设置并且使用这个标记。</li></ul><p><strong>补充说明：</strong></p><ul><li><p>带有ACC_INTERFACE标志的class文件表示的是接口而不是类，反之则表示的是类而不是接口。 </p></li><li><ul><li>如果一个class文件被设置了ACC_INTERFACE标志，那么同时也得设置ACC_ABSTRACT标志。同时它不能再设置ACC_FINAL、ACC_SUPER 或ACC_ENUM标志。</li></ul></li><li><ul><li>如果没有设置ACC_INTERFACE标志，那么这个class文件可以具有上表中除ACC_ANNOTATION外的其他所有标志。当然，ACC_FINAL和ACC_ABSTRACT这类互斥的标志除外。这两个标志不得同时设置。</li></ul></li><li><p>ACC_SUPER标志用于确定类或接口里面的invokespecial指令使用的是哪一种执行语义。针对Java虚拟机指令集的编译器都应当设置这个标志。对于Java SE 8及后续版本来说，无论class文件中这个标志的实际值是什么，也不管class文件的版本号是多少，Java虚拟机都认为每个class文件均设置了ACC_SUPER标志。 </p></li><li><ul><li>ACC_SUPER标志是为了向后兼容由旧Java编译器所编译的代码而设计的。目前的ACC_SUPER标志在由JDK1.0.2之前的编译器所生成的access_flags中是没有确定含义的，如果设置了该标志，那么oracle的Java虚拟机实现会将其忽略。</li></ul></li><li><p>ACC_SYNTHETIC标志意味着该类或接口是由编译器生成的，而不是由源代码生成的。 </p></li><li><p>注解类型必须设置ACC_ANNOTATION标志。如果设置了ACC_ANNOTATION标志，那么也必须设置ACC_INTERFACE标志。 </p></li><li><p>ACC_ENUM标志表明该类或其父类为枚举类型。</p></li></ul><h2 id="5-类索引、父类索引、接口索引"><a href="#5-类索引、父类索引、接口索引" class="headerlink" title="5. 类索引、父类索引、接口索引"></a>5. 类索引、父类索引、接口索引</h2><p>在访问标记后，会指定该类的类别、父类类别以及实现的接口，格式如下：</p><table><thead><tr><th>长度</th><th>含义</th></tr></thead><tbody><tr><td>u2</td><td>this_class</td></tr><tr><td>u2</td><td>super_class</td></tr><tr><td>u2</td><td>interfaces_count</td></tr><tr><td>u2</td><td>interfaces[interfaces_count]</td></tr></tbody></table><p>这三项数据来确定这个类的继承关系：</p><ul><li><p>类索引用于确定这个类的全限定名</p></li><li><p>父类索引用于确定这个类的父类的全限定名。由于Java语言不允许多重继承，所以父类索引只有一个，除了java.lang.Object之外，所有的Java类都有父类，因此除了java.lang.Object外，所有Java类的父类索引都不为0。</p></li><li><p>接口索引集合就用来描述这个类实现了哪些接口，这些被实现的接口将按implements语句（如果这个类本身是一个接口，则应当是extends语句）后的接口顺序从左到右排列在接口索引集合中。</p></li></ul><h3 id="5-1-this-class（类索引）"><a href="#5-1-this-class（类索引）" class="headerlink" title="5.1. this_class（类索引）"></a>5.1. this_class（类索引）</h3><p>2字节无符号整数，指向常量池的索引。它提供了类的全限定名，如com&#x2F;atguigu&#x2F;java1&#x2F;Demo。this_class的值必须是对常量池表中某项的一个有效索引值。常量池在这个索引处的成员必须为CONSTANT_Class_info类型结构体，该结构体表示这个class文件所定义的类或接口。</p><h3 id="5-2-super-class（父类索引）"><a href="#5-2-super-class（父类索引）" class="headerlink" title="5.2. super_class（父类索引）"></a>5.2. super_class（父类索引）</h3><p>2字节无符号整数，指向常量池的索引。它提供了当前类的父类的全限定名。如果我们没有继承任何类，其默认继承的是java&#x2F;lang&#x2F;object类。同时，由于Java不支持多继承，所以其父类只有一个。</p><p><strong>super_class指向的父类不能是final。</strong></p><h3 id="5-3-interfaces"><a href="#5-3-interfaces" class="headerlink" title="5.3. interfaces"></a>5.3. interfaces</h3><p>指向常量池索引集合，它提供了一个符号引用到所有已实现的接口</p><p>由于一个类可以实现多个接口，因此需要以数组形式保存多个接口的索引，表示接口的每个索引也是一个指向常量池的CONSTANT_Class（当然这里就必须是接口，而不是类）。</p><h4 id="5-3-1-interfaces-count（接口计数器）"><a href="#5-3-1-interfaces-count（接口计数器）" class="headerlink" title="5.3.1 interfaces_count（接口计数器）"></a>5.3.1 interfaces_count（接口计数器）</h4><p>interfaces_count 项的值表示当前类或接口的直接超接口数量。</p><h4 id="5-3-2-interfaces-（接口索引集合）"><a href="#5-3-2-interfaces-（接口索引集合）" class="headerlink" title="5.3.2 interfaces[]（接口索引集合）"></a>5.3.2 interfaces[]（接口索引集合）</h4><p>interfaces[]中每个成员的值必须是对常量池表中某项的有效索引值，它的长度为interfaces_count。每个成员interfaces[i]必须为CONSTANT_Class_info结构，其中0 &lt;&#x3D; i &lt; interfaces_count。在interfaces[]中，各成员所表示的接口顺序和对应的源代码中给定的接口顺序（从左至右）一样，即interfaces[0]对应的是源代码中最左边的接口。</p><h2 id="6-字段表集合"><a href="#6-字段表集合" class="headerlink" title="6. 字段表集合"></a>6. 字段表集合</h2><p><strong>fields</strong></p><ul><li><p>用于描述接口或类中声明的变量。字段（field）包括类级变量以及实例级变量，但是不包括方法内部、代码块内部声明的局部变量。</p></li><li><p>字段叫什么名字、字段被定义为什么数据类型，这些都是无法固定的，只能引用常量池中的常量来描述。</p></li><li><p>它指向常量池索引集合，它描述了每个字段的完整信息。比如字段的标识符、访问修饰符（public、private或protected）、是类变量还是实例变量（static修饰符）、是否是常量（final修饰符）等。</p></li></ul><p><strong>注意事项：</strong></p><ul><li><p>字段表集合中不会列出从父类或者实现的接口中继承而来的字段，但有可能列出原本Java代码之中不存在的字段。譬如在内部类中为了保持对外部类的访问性，会自动添加指向外部类实例的字段。</p></li><li><p>在Java语言中字段是无法重载的，两个字段的数据类型、修饰符不管是否相同，都必须使用不一样的名称，但是对于字节码来讲，如果两个字段的描述符不一致，那字段重名就是合法的。</p></li></ul><h3 id="6-1-字段计数器"><a href="#6-1-字段计数器" class="headerlink" title="6.1 字段计数器"></a>6.1 字段计数器</h3><p><strong>fields_count（字段计数器）</strong></p><p>fields_count 的值表示当前class文件fields表的成员个数。使用两个字节来表示。</p><p>fields表中每个成员都是一个field_info结构，用于表示该类或接口所声明的所有类字段或者实例字段，不包括方法内部声明的变量，也不包括从父类或父接口继承的那些字段。</p><table><thead><tr><th>标志名称</th><th>标志值</th><th>含义</th><th>数量</th></tr></thead><tbody><tr><td>u2</td><td>access_flags</td><td>访问标志</td><td>1</td></tr><tr><td>u2</td><td>name_index</td><td>字段名索引</td><td>1</td></tr><tr><td>u2</td><td>descriptor_index</td><td>描述符索引</td><td>1</td></tr><tr><td>u2</td><td>attributes_count</td><td>属性计数器</td><td>1</td></tr><tr><td>attribute_info</td><td>attributes</td><td>属性集合</td><td>attributes_count</td></tr></tbody></table><h3 id="6-2-字段表"><a href="#6-2-字段表" class="headerlink" title="6.2 字段表"></a>6.2 字段表</h3><h4 id="6-2-1-字段表访问标识"><a href="#6-2-1-字段表访问标识" class="headerlink" title="6.2.1 字段表访问标识"></a>6.2.1 字段表访问标识</h4><p>我们知道，一个字段可以被各种关键字去修饰，比如：作用域修饰符（public、private、protected）、static修饰符、final修饰符、volatile修饰符等等。因此，其可像类的访问标志那样，使用一些标志来标记字段。字段的访问标志有如下这些：</p><table><thead><tr><th>标志名称</th><th>标志值</th><th>含义</th></tr></thead><tbody><tr><td>ACC_PUBLIC</td><td>0x0001</td><td>字段是否为public</td></tr><tr><td>ACC_PRIVATE</td><td>0x0002</td><td>字段是否为private</td></tr><tr><td>ACC_PROTECTED</td><td>0x0004</td><td>字段是否为protected</td></tr><tr><td>ACC_STATIC</td><td>0x0008</td><td>字段是否为static</td></tr><tr><td>ACC_FINAL</td><td>0x0010</td><td>字段是否为final</td></tr><tr><td>ACC_VOLATILE</td><td>0x0040</td><td>字段是否为volatile</td></tr><tr><td>ACC_TRANSTENT</td><td>0x0080</td><td>字段是否为transient</td></tr><tr><td>ACC_SYNCHETIC</td><td>0x1000</td><td>字段是否为由编译器自动产生</td></tr><tr><td>ACC_ENUM</td><td>0x4000</td><td>字段是否为enum</td></tr></tbody></table><h4 id="6-2-2-描述符索引"><a href="#6-2-2-描述符索引" class="headerlink" title="6.2.2 描述符索引"></a>6.2.2 描述符索引</h4><p>描述符的作用是用来描述字段的数据类型、方法的参数列表（包括数量、类型以及顺序）和返回值。根据描述符规则，基本数据类型（byte，char，double，float，int，long，short，boolean）及代表无返回值的void类型都用一个大写字符来表示，而对象则用字符L加对象的全限定名来表示，如下所示：</p><table><thead><tr><th>标志符</th><th>含义</th></tr></thead><tbody><tr><td>B</td><td>基本数据类型byte</td></tr><tr><td>C</td><td>基本数据类型char</td></tr><tr><td>D</td><td>基本数据类型double</td></tr><tr><td>F</td><td>基本数据类型float</td></tr><tr><td>I</td><td>基本数据类型int</td></tr><tr><td>J</td><td>基本数据类型long</td></tr><tr><td>S</td><td>基本数据类型short</td></tr><tr><td>Z</td><td>基本数据类型boolean</td></tr><tr><td>V</td><td>代表void类型</td></tr><tr><td>L</td><td>对象类型，比如：<code>Ljava/lang/Object;</code></td></tr><tr><td>[</td><td>数组类型，代表一维数组.  示例：<code>double[][][]</code> is <code>[[[D</code></td></tr></tbody></table><h4 id="6-3-属性表集合"><a href="#6-3-属性表集合" class="headerlink" title="6.3 属性表集合"></a>6.3 属性表集合</h4><p>一个字段还可能拥有一些属性，用于存储更多的额外信息。比如初始化值、一些注释信息等。属性个数存放在attribute_count中，属性具体内容存放在attributes数组中。</p><pre><code class="highlight java"><span class="comment">// 以常量属性为例，结构为：</span>ConstantValue_attribute&#123;u2 attribute_name_index;u4 attribute_length;    u2 constantvalue_index;&#125;</code></pre><p>说明：对于常量属性而言，attribute_length值恒为2。</p><p><img src="https://raw.githubusercontent.com/GeorgeChan95/blogimg/master/img/2024/07/19/20240719-154111.png" alt="字段常量属性示例"></p><h2 id="7-方法表集合"><a href="#7-方法表集合" class="headerlink" title="7. 方法表集合"></a>7. 方法表集合</h2><p>Methods：指向常量池索引集合，它完整描述了每个方法的签名。</p><ul><li><p>在字节码文件中，每一个method_info项都对应着一个类或者接口中的方法信息。比如方法的访问修饰符（public、private或protected），方法的返回值类型以及方法的参数信息等。</p></li><li><p>如果这个方法不是抽象的或者不是native的，那么字节码中会体现出来。</p></li><li><p>一方面，methods表只描述当前类或接口中声明的方法，不包括从父类或父接口继承的方法。另一方面，methods表有可能会出现由编译器自动添加的方法，最典型的便是编译器产生的方法信息（比如：类（接口）初始化方法<clinit>()和实例初始化方法<init>()）。</p></li></ul><p><strong>使用注意事项：</strong></p><p>在Java语言中，要重载（Overload）一个方法，除了要与原方法具有相同的简单名称之外，还要求必须拥有一个与原方法不同的特征签名，特征签名就是一个方法中各个参数在常量池中的字段符号引用的集合，也就是因为返回值不会包含在特征签名之中，因此Java语言里无法仅仅依靠返回值的不同来对一个已有方法进行重载。但在Class文件格式中，特征签名的范围更大一些，只要描述符不是完全一致的两个方法就可以共存。也就是说，如果两个方法有相同的名称和特征签名，但返回值不同，那么也是可以合法共存于同一个class文件中。</p><p>也就是说，尽管Java语法规范并不允许在一个类或者接口中声明多个方法签名相同的方法，但是和Java语法规范相反，字节码文件中却恰恰允许存放多个方法签名相同的方法，唯一的条件就是这些方法之间的返回值不能相同。</p><h3 id="7-1-方法计数器"><a href="#7-1-方法计数器" class="headerlink" title="7.1 方法计数器"></a>7.1 方法计数器</h3><p><strong>methods_count（方法计数器）</strong></p><ul><li><p>methods_count 的值表示当前class文件methods表的成员个数。使用<strong>两个字节</strong>来表示。</p></li><li><p>methods表中每个成员都是一个method_info结构。</p></li></ul><h4 id="7-2-方法表"><a href="#7-2-方法表" class="headerlink" title="7.2 方法表"></a>7.2 方法表</h4><p><strong>methods[]（方法表）</strong></p><ul><li><p>methods表中的每个成员都必须是一个method_info结构，用于表示当前类或接口中某个方法的完整描述。如果某个method_info结构的access_flags项既没有设置ACC_NATIVE标志也没有设置ACC_ABSTRACT标志，那么该结构中也应包含实现这个方法所用的Java虚拟机指令。</p></li><li><p>method_info结构可以表示类和接口中定义的所有方法，包括实例方法、类方法、实例初始化方法和类或接口初始化方法.</p></li></ul><p>方法表的结构实际跟字段表是一样的，方法表结构如下：</p><table><thead><tr><th>标志名称</th><th>标志值</th><th>含义</th><th>数量</th></tr></thead><tbody><tr><td>u2</td><td>access_flags</td><td>访问标志</td><td>1</td></tr><tr><td>u2</td><td>name_index</td><td>方法名索引</td><td>1</td></tr><tr><td>u2</td><td>descriptor_index</td><td>描述符索引</td><td>1</td></tr><tr><td>u2</td><td>attributes_count</td><td>属性计数器</td><td>1</td></tr><tr><td>attribute_info</td><td>attributes</td><td>属性集合</td><td>attributes_count</td></tr></tbody></table><p><strong>方法表访问标志</strong></p><p>跟字段表一样，方法表也有访问标志，而且他们的标志有部分相同，部分则不同，方法表的具体访问标志如下：</p><table><thead><tr><th>标志名称</th><th>标志值</th><th>含义</th></tr></thead><tbody><tr><td>ACC_PUBLIC</td><td>0x0001</td><td>public，方法可以从包外访问</td></tr><tr><td>ACC_PRIVATE</td><td>0x0002</td><td>private，方法只能本类访问</td></tr><tr><td>ACC_PROTECTED</td><td>0x0004</td><td>protected，方法在自身和子类可以访问</td></tr><tr><td>ACC_STATIC</td><td>0x0008</td><td>static，静态方法</td></tr></tbody></table><h2 id="8-属性表集合"><a href="#8-属性表集合" class="headerlink" title="8. 属性表集合"></a>8. 属性表集合</h2><p>方法表集合之后的属性表集合，指的是class文件所携带的辅助信息，比如该class文件的源文件的名称。以及任何带有RetentionPolicy.CLASS 或者RetentionPolicy.RUNTIME的注解。这类信息通常被用于Java虚拟机的验证和运行，以及Java程序的调试，一般无须深入了解。</p><p>此外，字段表、方法表都可以有自己的属性表。用于描述某些场景专有的信息。</p><p>属性表集合的限制没有那么严格，不再要求各个属性表具有严格的顺序，并且只要不与已有的属性名重复，任何人实现的编译器都可以向属性表中写入自己定义的属性信息，但Java虚拟机运行时会忽略掉它不认识的属性。</p><h3 id="8-1-属性计数器"><a href="#8-1-属性计数器" class="headerlink" title="8.1 属性计数器"></a>8.1 属性计数器</h3><p><strong>attributes_count（属性计数器）</strong></p><p>attributes_count的值表示当前class文件属性表的成员个数。属性表中每一项都是一个attribute_info结构。</p><h3 id="8-2-属性表"><a href="#8-2-属性表" class="headerlink" title="8.2 属性表"></a>8.2 属性表</h3><p><strong>attributes[]（属性表）</strong></p><p>属性表的每个项的值必须是attribute_info结构。属性表的结构比较灵活，各种不同的属性只要满足以下结构即可。</p><h4 id="8-2-1-属性的通用格式"><a href="#8-2-1-属性的通用格式" class="headerlink" title="8.2.1 属性的通用格式"></a><strong>8.2.1 属性的通用格式</strong></h4><table><thead><tr><th>类型</th><th>名称</th><th>数量</th><th>含义</th></tr></thead><tbody><tr><td>u2</td><td>attribute_name_index</td><td>1</td><td>属性名索引</td></tr><tr><td>u4</td><td>attribute_length</td><td>1</td><td>属性长度</td></tr><tr><td>u1</td><td>info</td><td>attribute_length</td><td>属性表</td></tr></tbody></table><h4 id="8-2-2-属性类型"><a href="#8-2-2-属性类型" class="headerlink" title="8.2.2 属性类型"></a><strong>8.2.2 属性类型</strong></h4><p>属性表实际上可以有很多类型，上面看到的Code属性只是其中一种，Java8里面定义了23种属性。下面这些是虚拟机中预定义的属性：</p><table><thead><tr><th>属性名称</th><th>使用位置</th><th>含义</th></tr></thead><tbody><tr><td>Code</td><td>方法表</td><td>Java代码编译成的字节码指令</td></tr><tr><td>ConstantValue</td><td>字段表</td><td>final关键字定义的常量池</td></tr><tr><td>Deprecated</td><td>类，方法，字段表</td><td>被声明为deprecated的方法和字段</td></tr><tr><td>Exceptions</td><td>方法表</td><td>方法抛出的异常</td></tr><tr><td>EnclosingMethod</td><td>类文件</td><td>仅当一个类为局部类或者匿名类时才能拥有这个属性，这个属性用于标识这个类所在的外围方法</td></tr><tr><td>InnerClass</td><td>类文件</td><td>内部类列表</td></tr><tr><td>LineNumberTable</td><td>Code属性</td><td>Java源码的行号与字节码指令的对应关系</td></tr><tr><td>LocalVariableTable</td><td>Code属性</td><td>方法的局部变量描述</td></tr><tr><td>StackMapTable</td><td>Code属性</td><td>JDK1.6中新增的属性，供新的类型检查检验器和处理目标方法的局部变量和操作数有所需要的类是否匹配</td></tr><tr><td>Signature</td><td>类，方法表，字段表</td><td>用于支持泛型情况下的方法签名</td></tr><tr><td>SourceFile</td><td>类文件</td><td>记录源文件名称</td></tr><tr><td>SourceDebugExtension</td><td>类文件</td><td>用于存储额外的调试信息</td></tr><tr><td>Synthetic</td><td>类，方法表，字段表</td><td>标志方法或字段为编译器自动生成的</td></tr><tr><td>LocalVariableTypeTable</td><td>类</td><td>使用特征签名代替描述符，是为了引入泛型语法之后能描述泛型参数化类型而添加</td></tr><tr><td>RuntimeVisibleAnnotations</td><td>类，方法表，字段表</td><td>为动态注解提供支持</td></tr><tr><td>RuntimeInvisibleAnnotations</td><td>类，方法表，字段表</td><td>用于指明哪些注解是运行时不可见的</td></tr><tr><td>RuntimeVisibleParameterAnnotation</td><td>方法表</td><td>作用与RuntimeVisibleAnnotations属性类似，只不过作用对象或方法</td></tr><tr><td>RuntimeInvisibleParameterAnnotation</td><td>方法表</td><td>作用与RuntimeInvisibleAnnotations属性类似，只不过作用对象或方法</td></tr><tr><td>AnnotationDefault</td><td>方法表</td><td>用于记录注解类元素的默认值</td></tr><tr><td>BootstrapMethods</td><td>类文件</td><td>用于保存invokeddynamic指令引用的引导方法限定符</td></tr></tbody></table><p>官方网址查看: <a href="https://docs.oracle.com/javase/specs/jvms/se8/html/jvms-4.html#jvms-4.7">https://docs.oracle.com/javase/specs/jvms/se8/html/jvms-4.html#jvms-4.7</a></p><h4 id="8-2-3-部分属性详解"><a href="#8-2-3-部分属性详解" class="headerlink" title="8.2.3 部分属性详解"></a>8.2.3 部分属性详解</h4><p><strong>① ConstantValue属性</strong></p><p>ConstantValue属性表示一个常量字段的值。位于field_info结构的属性表中。</p><pre><code class="highlight java">ConstantValue_attribute&#123;u2 attribute_name_index;u4 attribute_length;u2 constantvalue_index;<span class="comment">//字段值在常量池中的索引，常量池在该索引处的项给出该属性表示的常量值。（例如，值是1ong型的，在常量池中便是CONSTANT_Long）</span>&#125;</code></pre><p><img src="https://raw.githubusercontent.com/GeorgeChan95/blogimg/master/img/2024/07/20/20240720-171159.png" alt="ConstantValue"></p><p><strong>② Deprecated 属性</strong></p><p>Deprecated 属性是在JDK1.1为了支持注释中的关键词@deprecated而引入的。</p><pre><code class="highlight java">Deprecated_attribute&#123;u2 attribute_name_index;u4 attribute_length;&#125;</code></pre><p><strong>③ Code属性</strong></p><p>Code属性就是存放方法体里面的代码。但是，并非所有方法表都有Code属性。像接口或者抽象方法，他们没有具体的方法体，因此也就不会有Code属性了。Code属性表的结构，如下表：</p><table><thead><tr><th>类型</th><th>名称</th><th>数量</th><th>含义</th></tr></thead><tbody><tr><td>u2</td><td>attribute_name_index</td><td>1</td><td>属性名索引</td></tr><tr><td>u4</td><td>attribute_length</td><td>1</td><td>属性长度</td></tr><tr><td>u2</td><td>max_stack</td><td>1</td><td>操作数栈深度的最大值</td></tr><tr><td>u2</td><td>max_locals</td><td>1</td><td>局部变量表所需的存续空间</td></tr><tr><td>u4</td><td>code_length</td><td>1</td><td>字节码指令的长度</td></tr><tr><td>u1</td><td>code</td><td>code_lenth</td><td>存储字节码指令</td></tr><tr><td>u2</td><td>exception_table_length</td><td>1</td><td>异常表长度</td></tr><tr><td>exception_info</td><td>exception_table</td><td>exception_length</td><td>异常表</td></tr><tr><td>u2</td><td>attributes_count</td><td>1</td><td>属性集合计数器</td></tr><tr><td>attribute_info</td><td>attributes</td><td>attributes_count</td><td>属性集合</td></tr></tbody></table><p><img src="https://raw.githubusercontent.com/GeorgeChan95/blogimg/master/img/2024/07/20/20240720-171543.png" alt="Code属性"></p><p>可以看到：Code属性表的前两项跟属性表是一致的，即Code属性表遵循属性表的结构，后面那些则是他自定义的结构。</p><p><strong>④ InnerClasses 属性</strong></p><p>为了方便说明特别定义一个表示类或接口的Class格式为C。如果C的常量池中包含某个CONSTANT_Class_info成员，且这个成员所表示的类或接口不属于任何一个包，那么C的ClassFile结构的属性表中就必须含有对应的InnerClasses属性。InnerClasses属性是在JDK1.1中为了支持内部类和内部接口而引入的，位于ClassFile结构的属性表。</p><p><strong>⑤ LineNumberTable属性</strong></p><p>LineNumberTable属性是可选变长属性，位于Code结构的属性表。</p><p><strong>LineNumberTable属性是用来描述 <code>Java源码行号</code> 与 <code>字节码行号</code> 之间的对应关系</strong>。这个属性可以用来在调试的时候定位代码执行的行数。</p><ul><li>start_pc，即字节码行号；line_number，即Java源代码行号。</li></ul><p>在Code属性的属性表中，LineNumberTable属性可以按照任意顺序出现，此外，多个LineNumberTable属性可以共同表示一个行号在源文件中表示的内容，即LineNumberTable属性不需要与源文件的行一一对应。</p><pre><code class="highlight java"><span class="comment">// LineNumberTable属性表结构：</span>LineNumberTable_attribute&#123;    u2 attribute_name_index;    u4 attribute_length;    u2 line_number_table_length;    &#123;        u2 start_pc;        u2 line_number;    &#125; line_number_table[line_number_table_length];&#125;</code></pre><p><img src="https://raw.githubusercontent.com/GeorgeChan95/blogimg/master/img/2024/07/20/20240720-172941.png" alt="字节码"></p><p><img src="https://raw.githubusercontent.com/GeorgeChan95/blogimg/master/img/2024/07/20/20240720-173134.png" alt="LineNumberTable"></p><p><strong>⑥ LocalVariableTable属性</strong></p><p>LocalVariableTable是可选变长属性，位于Code属性的属性表中。它被调试器用于确定方法在执行过程中局部变量的信息。在Code属性的属性表中，LocalVariableTable属性可以按照任意顺序出现。Code属性中的每个局部变量最多只能有一个LocalVariableTable属性。</p><ul><li><p>start pc + length表示这个变量在字节码中的生命周期起始和结束的偏移位置（this生命周期从头0到结尾15）</p></li><li><p>index就是这个变量在局部变量表中的槽位（槽位可复用）</p></li><li><p>name就是变量名</p></li><li><p>Descriptor表示局部变量类型描述</p></li></ul><pre><code class="highlight java"><span class="comment">// LocalVariableTable属性表结构：</span>LocalVariableTable_attribute&#123;    u2 attribute_name_index;    u4 attribute_length;    u2 local_variable_table_length;    &#123;        u2 start_pc;        u2 length;        u2 name_index;        u2 descriptor_index;        u2 index;    &#125; local_variable_table[local_variable_table_length];&#125;</code></pre><p><img src="https://raw.githubusercontent.com/GeorgeChan95/blogimg/master/img/2024/07/20/20240720-173346.png" alt="LocalVariableTable"></p><p><strong>⑦ Signature属性</strong></p><p>Signature属性是可选的定长属性，位于ClassFile，field_info或method_info结构的属性表中。在Java语言中，任何类、接口、初始化方法或成员的泛型签名如果包含了类型变量（Type Variables）或参数化类型（Parameterized Types），则Signature属性会为它记录泛型签名信息。</p><p><strong>⑧ SourceFile属性</strong></p><p>SourceFile属性结构</p><table><thead><tr><th>类型</th><th>名称</th><th>数量</th><th>含义</th></tr></thead><tbody><tr><td>u2</td><td>attribute_name_index</td><td>1</td><td>属性名索引</td></tr><tr><td>u4</td><td>attribute_length</td><td>1</td><td>属性长度</td></tr><tr><td>u2</td><td>source file name index</td><td>1</td><td>源码文件素引</td></tr></tbody></table><p>可以看到，其长度总是固定的8个字节。</p><p><strong>⑨ 其他属性</strong></p><p>Java虚拟机中预定义的属性有20多个，这里就不一一介绍了，通过上面几个属性的介绍，只要领会其精髓，其他属性的解读也是易如反掌。</p><h1 id="参考文档"><a href="#参考文档" class="headerlink" title="参考文档"></a>参考文档</h1><blockquote><p>参考1: <a href="https://blog.csdn.net/weelyy/article/details/78969412">https://blog.csdn.net/weelyy/article/details/78969412</a></p><p>JAVA虚拟机规范官方文档:<a href="https://docs.oracle.com/javase/specs/jvms/se8/html/index.html">https://docs.oracle.com/javase/specs/jvms/se8/html/index.html</a></p></blockquote>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;一、概述&quot;&gt;&lt;a href=&quot;#一、概述&quot; class=&quot;headerlink&quot; title=&quot;一、概述&quot;&gt;&lt;/a&gt;一、概述&lt;/h1&gt;&lt;h2 id=&quot;1-字节码文件的跨平台型&quot;&gt;&lt;a href=&quot;#1-字节码文件的跨平台型&quot; class=&quot;headerlink&quot; </summary>
      
    
    
    
    <category term="JVM" scheme="https://georgechan95.github.io/categories/JVM/"/>
    
    
    <category term="jvm" scheme="https://georgechan95.github.io/tags/jvm/"/>
    
    <category term="java" scheme="https://georgechan95.github.io/tags/java/"/>
    
  </entry>
  
  <entry>
    <title>第十五章-GC日志分析</title>
    <link href="https://georgechan95.github.io/2024/07/13/jvm/%E7%AC%AC%E5%8D%81%E4%BA%94%E7%AB%A0-GC%E6%97%A5%E5%BF%97%E5%88%86%E6%9E%90/"/>
    <id>https://georgechan95.github.io/2024/07/13/jvm/%E7%AC%AC%E5%8D%81%E4%BA%94%E7%AB%A0-GC%E6%97%A5%E5%BF%97%E5%88%86%E6%9E%90/</id>
    <published>2024-07-13T00:34:00.000Z</published>
    <updated>2024-07-15T11:53:27.745Z</updated>
    
    <content type="html"><![CDATA[<h1 id="一、GC日志参数"><a href="#一、GC日志参数" class="headerlink" title="一、GC日志参数"></a>一、GC日志参数</h1><p>通过阅读Gc日志，我们可以了解Java虚拟机内存分配与回收策略。 内存分配与垃圾回收的参数列表.</p><ul><li><p><code>-XX:+PrintGC</code> 输出GC日志。类似：<code>-verbose:gc</code></p></li><li><p><code>-XX:+PrintGCDetails</code> 输出GC的详细日志</p></li><li><p><code>-XX:+PrintGCTimestamps</code> 输出GC的时间戳（以基准时间的形式）</p></li><li><p><code>-XX:+PrintGCDatestamps</code> 输出GC的时间戳（以日期的形式，如2013-05-04T21：53：59.234+0800）</p></li><li><p><code>-XX:+PrintHeapAtGC</code> 在进行GC的前后打印出堆的信息</p></li><li><p><code>-Xloggc:../logs/gc.log</code> 日志文件的输出路径</p></li></ul><h2 id="1-实例1"><a href="#1-实例1" class="headerlink" title="1. 实例1"></a>1. 实例1</h2><p>打开GC日志</p><pre><code class="highlight shell">-verbose:gc</code></pre><p>这个只会显示总的GC堆的变化，如下：</p><pre><code class="highlight shell">[GC (Allocation Failure) 80832K-&gt;19298K(227840K),0.0084018 secs][GC (Metadata GC Threshold) 109499K-&gt;21465K(228352K),0.0184066 secs][Full GC (Metadata GC Threshold) 21465K-&gt;16716K(201728K),0.0619261 secs]</code></pre><p>参数解析</p><pre><code class="highlight shell">GC、Full GC：GC的类型，GC只在新生代上进行，Full GC包括永生代，新生代，老年代。Allocation Failure：GC发生的原因。<span class="meta prompt_">80832K-&gt;</span><span class="language-bash">19298K：堆在GC前的大小和GC后的大小。</span>227840k：现在的堆大小。0.0084018 secs：GC持续的时间。</code></pre><h2 id="2-实例2"><a href="#2-实例2" class="headerlink" title="2. 实例2"></a>2. 实例2</h2><p>查看GC日志详细</p><pre><code class="highlight shell">-verbose:gc -XX:+PrintGCDetails</code></pre><p>输出信息如下</p><pre><code class="highlight shell">[GC (Allocation Failure) [PSYoungGen:70640K-&gt;10116K(141312K)] 80541K-&gt;20017K(227328K),0.0172573 secs] [Times:user=0.03 sys=0.00,real=0.02 secs][GC (Metadata GC Threshold) [PSYoungGen:98859K-&gt;8154K(142336K)] 108760K-&gt;21261K(228352K),0.0151573 secs] [Times:user=0.00 sys=0.01,real=0.02 secs][Full GC (Metadata GC Threshold)[PSYoungGen:8154K-&gt;0K(142336K)][ParOldGen:13107K-&gt;16809K(62464K)] 21261K-&gt;16809K(204800K),[Metaspace:20599K-&gt;20599K(1067008K)],0.0639732 secs][Times:user=0.14 sys=0.00,real=0.06 secs]</code></pre><p>参数解析</p><pre><code class="highlight java">GC，Full FC：同样是GC的类型Allocation Failure：GC原因PSYoungGen：使用了Parallel Scavenge并行垃圾收集器的新生代GC前后大小的变化ParOldGen：使用了Parallel Old并行垃圾收集器的老年代GC前后大小的变化Metadata：元数据区GC前后大小的变化，JDK1<span class="number">.8</span>中引入了元数据区以替代永久代xxx secs：指GC花费的时间Times：user：指的是垃圾收集器花费的所有CPU时间，sys：花费在等待系统调用或系统事件的时间，real：GC从开始到结束的时间，包括其他进程占用时间片的实际时间。</code></pre><h2 id="3-实例3"><a href="#3-实例3" class="headerlink" title="3. 实例3"></a>3. 实例3</h2><p>打开GC日志</p><pre><code class="highlight shell">-verbose:gc -XX:+PrintGCDetails -XX:+PrintGCTimestamps -XX:+PrintGCDatestamps</code></pre><p>输出信息如下</p><pre><code class="highlight shell">2019-09-24T22:15:24.518+0800: 3.287: [GC (Allocation Failure) [PSYoungGen:136162K-&gt;5113K(136192K)] 141425K-&gt;17632K(222208K),0.0248249 secs] [Times:user=0.05 sys=0.00,real=0.03 secs]2019-09-24T22:15:25.559+0800: 4.329: [GC (Metadata GC Threshold) [PSYoungGen:97578K-&gt;10068K(274944K)] 110096K-&gt;22658K(360960K),0.0094071 secs] [Times: user=0.00 sys=0.00,real=0.01 secs]2019-09-24T22:15:25.569+0800: 4.338: [Full GC (Metadata GC Threshold) [PSYoungGen:10068K-&gt;0K(274944K)][ParoldGen:12590K-&gt;13564K(56320K)] 22658K-&gt;13564K(331264K),[Metaspace:20590K-&gt;20590K(1067008K)],0.0494875 secs] [Times: user=0.17 sys=0.02,real=0.05 secs]</code></pre><p>说明：带上了日期和时间</p><h2 id="4-日出输出log"><a href="#4-日出输出log" class="headerlink" title="4. 日出输出log"></a>4. 日出输出log</h2><p>如果想把GC日志存到文件的话，是下面的参数：</p><pre><code class="highlight shell">-Xloggc:/path/to/gc.log</code></pre><h2 id="5-日志补充说明"><a href="#5-日志补充说明" class="headerlink" title="5. 日志补充说明"></a>5. 日志补充说明</h2><ul><li><p>“<code>[GC</code>“和”<code>[Full GC</code>“说明了这次垃圾收集的停顿类型，如果有”Full”则说明GC发生了”Stop The World” </p></li><li><p>使用Serial收集器在新生代的名字是Default New Generation，因此显示的是”<code>[DefNew</code>“ </p></li><li><p>使用ParNew收集器在新生代的名字会变成”<code>[ParNew</code>“，意思是”Parallel New Generation” </p></li><li><p>使用Parallel scavenge收集器在新生代的名字是”<code>[PSYoungGen</code>“ </p></li><li><p>老年代的收集和新生代道理一样，名字也是收集器决定的 </p></li><li><p>使用G1收集器的话，会显示为”garbage-first heap” </p></li><li><p>Allocation Failure<br>  表明本次引起GC的原因是因为在年轻代中没有足够的空间能够存储新的数据了。 </p></li><li><p>[PSYoungGen：5986K-&gt;696K(8704K) ] 5986K-&gt;704K(9216K)<br>  中括号内：GC回收前年轻代大小，回收后大小，（年轻代总大小）<br>  括号外：GC回收前年轻代和老年代大小，回收后大小，（年轻代和老年代总大小） </p></li><li><p>user代表用户态回收耗时，sys内核态回收耗时，real实际耗时。由于多核的原因，时间总和可能会超过real时间</p></li></ul><pre><code class="highlight java">Heap（堆）PSYoungGen（Parallel Scavenge收集器新生代）total 9216K，used 6234K [<span class="number">0x00000000ff600000</span>,<span class="number">0x0000000100000000</span>,<span class="number">0x0000000100000000</span>)eden space（堆中的Eden区默认占比是<span class="number">8</span>）8192K，<span class="number">768</span> used [<span class="number">0x00000000ff600000</span>,<span class="number">0x00000000ffc16b08</span>,<span class="number">0x00000000ffe00000</span>)from space（堆中的Survivor，这里是From Survivor区默认占比是<span class="number">1</span>）1024K， <span class="number">0</span>% used [<span class="number">0x00000000fff00000</span>,<span class="number">0x00000000fff00000</span>,<span class="number">0x0000000100000000</span>)to space（堆中的Survivor，这里是to Survivor区默认占比是<span class="number">1</span>，需要先了解一下堆的分配策略）1024K, <span class="number">0</span>% used [<span class="number">0x00000000ffe00000</span>,<span class="number">0x00000000ffe00000</span>,<span class="number">0x00000000fff00000</span>)                                                                         ParOldGen（老年代总大小和使用大小）total 10240K， used 7001K ［<span class="number">0x00000000fec00000</span>,<span class="number">0x00000000ff600000</span>,<span class="number">0x00000000ff600000</span>)object space（显示个使用百分比）10240K，<span class="number">688</span> used [<span class="number">0x00000000fec00000</span>,<span class="number">0x00000000ff2d6630</span>,<span class="number">0x00000000ff600000</span>)PSPermGen（永久代总大小和使用大小）total 21504K， used 4949K [<span class="number">0x00000000f9a00000</span>,<span class="number">0x00000000faf00000</span>,<span class="number">0x00000000fec00000</span>)object space（显示个使用百分比，自己能算出来）21504K， <span class="number">238</span> used [<span class="number">0x00000000f9a00000</span>,<span class="number">0x00000000f9ed55e0</span>,<span class="number">0x00000000faf00000</span>)</code></pre><h1 id="二、Minor-GC日志"><a href="#二、Minor-GC日志" class="headerlink" title="二、Minor GC日志"></a>二、Minor GC日志</h1><p><img src="https://raw.githubusercontent.com/GeorgeChan95/blogimg/master/img/2024/07/13/20240713-172009.png" alt="Minor GC"></p><h1 id="三、Full-GC日志"><a href="#三、Full-GC日志" class="headerlink" title="三、Full GC日志"></a>三、Full GC日志</h1><p><img src="https://raw.githubusercontent.com/GeorgeChan95/blogimg/master/img/2024/07/13/20240713-192253.png" alt="Full GC日志"></p><h1 id="四、举例"><a href="#四、举例" class="headerlink" title="四、举例"></a>四、举例</h1><p>**代码如下: **</p><pre><code class="highlight shell">private static final int _1MB = 1024 * 1024;public static void testAllocation() &#123;    byte [] allocation1, allocation2, allocation3, allocation4;    allocation1 = new byte[2 *_1MB];    allocation2 = new byte[2 *_1MB];    allocation3 = new byte[2 *_1MB];    allocation4 = new byte[4 *_1MB];&#125;public static void main(String[] args) &#123;    testAllocation();&#125;</code></pre><p><strong>设置JVM参数(使用SerialGC)</strong></p><p><strong>JDK8环境</strong></p><pre><code class="highlight shell">-verbose:gc -Xms20M -Xmx20M -Xmn10M -XX:+PrintGCDetails -XX:SurvivorRatio=8 -XX:+UseSerialGC</code></pre><p>打印GC日志如下:</p><pre><code class="highlight shell">[GC (Allocation Failure) [DefNew: 7953K-&gt;624K(9216K), 0.0043498 secs] 7953K-&gt;6768K(19456K), 0.0043857 secs] [Times: user=0.00 sys=0.00, real=0.00 secs] Heap def new generation   total 9216K, used 4802K [0x00000000fec00000, 0x00000000ff600000, 0x00000000ff600000)  eden space 8192K,  51% used [0x00000000fec00000, 0x00000000ff014930, 0x00000000ff400000)  from space 1024K,  60% used [0x00000000ff500000, 0x00000000ff59c198, 0x00000000ff600000)  to   space 1024K,   0% used [0x00000000ff400000, 0x00000000ff400000, 0x00000000ff500000) tenured generation   total 10240K, used 6144K [0x00000000ff600000, 0x0000000100000000, 0x0000000100000000)   the space 10240K,  60% used [0x00000000ff600000, 0x00000000ffc00030, 0x00000000ffc00200, 0x0000000100000000) Metaspace       used 3222K, capacity 4496K, committed 4864K, reserved 1056768K  class space    used 348K, capacity 388K, committed 512K, reserved 1048576K</code></pre><p><strong>解析:</strong></p><p>使用Serial GC, 当需要分配4MB的对象 allocation4 时, 此时年轻代的内存不足了, 这时先将年轻代的数据移动到老年代,然后再将 allocation4 对象放到年轻代. 从日志可以看出来, eden 内存使用了约51%, eden又占整个年轻代的80%(8MB), 老年代GC后使用了 6144K (约6MB) . 从日志中这里也能看出来, Serial GC 的内存分配逻辑.</p><p><strong>图示</strong></p><p><img src="https://raw.githubusercontent.com/GeorgeChan95/blogimg/master/img/2024/07/13/20240713-192925.png" alt="d95ef629-b9fa-43d7-86d2-d1cc26ca9c61"></p><p><img src="https://raw.githubusercontent.com/GeorgeChan95/blogimg/master/img/2024/07/13/20240713-192946.png" alt="bd35738f-276b-4a8c-8d28-cb24aaa99503"></p><p><strong>重新设置JVM参数:</strong></p><p><strong>JDK8环境, 使用默认的Parallel GC</strong></p><pre><code class="highlight shell">-verbose:gc -Xms20M -Xmx20M -Xmn10M -XX:+PrintGCDetails -XX:SurvivorRatio=8</code></pre><p>打印日志如下:</p><pre><code class="highlight shell">Heap PSYoungGen      total 9216K, used 8118K [0x00000000ff600000, 0x0000000100000000, 0x0000000100000000)  eden space 8192K, 99% used [0x00000000ff600000,0x00000000ffded800,0x00000000ffe00000)  from space 1024K, 0% used [0x00000000fff00000,0x00000000fff00000,0x0000000100000000)  to   space 1024K, 0% used [0x00000000ffe00000,0x00000000ffe00000,0x00000000fff00000) ParOldGen       total 10240K, used 4096K [0x00000000fec00000, 0x00000000ff600000, 0x00000000ff600000)  object space 10240K, 40% used [0x00000000fec00000,0x00000000ff000010,0x00000000ff600000) Metaspace       used 3221K, capacity 4496K, committed 4864K, reserved 1056768K  class space    used 348K, capacity 388K, committed 512K, reserved 1048576K</code></pre><p><strong>解析:</strong></p><p>当不指定垃圾收集器时,默认使用的是 Parallel GC. 当需要给 allocation4 分配内存空间时, 此时年轻代的空间已经不够了, 年轻代发生了一次 Minor GC, 由于 allocation1, allocation2, allocation3 没有被释放掉, 年龄也不到默认的阈值 15, 所以只能往 Survivor 区移动,但是 Survivor 区的空间又不够,只能回退到 Eden区. 这样就导致了 allocation4 对象被直接分配到了老年代. 所以老年代使用了 40% 的空间(老年代共10MB). </p><p>至于为什么年轻代使用了99%, 这是由于在分配<code>allocation4</code>时，JVM触发了Minor GC，但并未完全清理Eden区，导致一些对象仍然保留在Eden区。</p><p>这也是 Parallel GC 与 Serial GC 的不同之处.</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;一、GC日志参数&quot;&gt;&lt;a href=&quot;#一、GC日志参数&quot; class=&quot;headerlink&quot; title=&quot;一、GC日志参数&quot;&gt;&lt;/a&gt;一、GC日志参数&lt;/h1&gt;&lt;p&gt;通过阅读Gc日志，我们可以了解Java虚拟机内存分配与回收策略。 内存分配与垃圾回收的参数列</summary>
      
    
    
    
    <category term="JVM" scheme="https://georgechan95.github.io/categories/JVM/"/>
    
    
    <category term="jvm" scheme="https://georgechan95.github.io/tags/jvm/"/>
    
    <category term="java" scheme="https://georgechan95.github.io/tags/java/"/>
    
  </entry>
  
  <entry>
    <title>第十四章-垃圾收集器</title>
    <link href="https://georgechan95.github.io/2024/07/10/jvm/%E7%AC%AC%E5%8D%81%E5%9B%9B%E7%AB%A0-%E5%9E%83%E5%9C%BE%E6%94%B6%E9%9B%86%E5%99%A8/"/>
    <id>https://georgechan95.github.io/2024/07/10/jvm/%E7%AC%AC%E5%8D%81%E5%9B%9B%E7%AB%A0-%E5%9E%83%E5%9C%BE%E6%94%B6%E9%9B%86%E5%99%A8/</id>
    <published>2024-07-10T11:27:00.000Z</published>
    <updated>2024-07-12T10:21:37.094Z</updated>
    
    <content type="html"><![CDATA[<h1 id="一、GC分类与性能指标"><a href="#一、GC分类与性能指标" class="headerlink" title="一、GC分类与性能指标"></a>一、GC分类与性能指标</h1><h2 id="1-垃圾回收器概述"><a href="#1-垃圾回收器概述" class="headerlink" title="1. 垃圾回收器概述"></a>1. 垃圾回收器概述</h2><ul><li>垃圾收集器没有在规范中进行过多的规定，可以由不同的厂商、不同版本的JVM来实现。</li><li>由于JDK的版本处于高速迭代过程中，因此Java发展至今已经衍生了众多的GC版本。</li><li>从不同角度分析垃圾收集器，可以将GC分为不同的类型。</li></ul><h2 id="2-垃圾收集器分类"><a href="#2-垃圾收集器分类" class="headerlink" title="2. 垃圾收集器分类"></a>2. 垃圾收集器分类</h2><ul><li><p>按线程数分，可以分为串行垃圾回收器和并行垃圾回收器。</p><p><img src="https://raw.githubusercontent.com/GeorgeChan95/blogimg/master/img/2024/07/10/20240710-194330.png" alt="串行与并行"></p><ul><li><p><strong>串行回收</strong>指的是在同一时间段内只允许有一个CPU用于执行垃圾回收操作，此时工作线程被暂停，直至垃圾收集工作结束。</p><ul><li>在诸如单CPU处理器或者较小的应用内存等硬件平台不是特别优越的场合，串行回收器的性能表现可以超过并行回收器和并发回收器。所以，串行回收默认被应用在客户端的Client模式下的JVM中</li><li>在并发能力比较强的CPU上，并行回收器产生的停顿时间要短于串行回收器。</li></ul></li><li><p><strong>并行收集</strong>可以运用多个CPU同时执行垃圾回收，因此提升了应用的吞吐量，不过并行回收仍然与串行回收一样，采用独占式，使用了“Stop-the-World”机制。</p><ul><li>按照工作模式分，可以分为并发式垃圾回收器和独占式垃圾回收器。<ul><li><strong>并发式垃圾回收器</strong>与应用程序线程交替工作，以尽可能减少应用程序的停顿时间。</li><li><strong>独占式垃圾回收器</strong>（Stop the world）一旦运行，就停止应用程序中的所有用户线程，直到垃圾回收过程完全结束。</li></ul></li></ul><p><img src="https://raw.githubusercontent.com/GeorgeChan95/blogimg/master/img/2024/07/10/20240710-194733.png" alt="独占与并发"></p></li></ul></li><li><p>按碎片处理方式分，可分为压缩式垃圾回收器和非压缩式垃圾回收器。</p><ul><li><p><strong>压缩式垃圾回收器</strong>会在回收完成后，对存活对象进行压缩整理，消除回收后的碎片。</p></li><li><p><strong>非压缩式的垃圾回收器</strong>不进行这步操作。</p></li></ul></li><li><p>按工作的内存区间分，又可分为<strong>年轻代垃圾回收器</strong>和<strong>老年代垃圾回收器</strong>。</p></li></ul><h2 id="3-评估GC的性能指标"><a href="#3-评估GC的性能指标" class="headerlink" title="3. 评估GC的性能指标"></a>3. 评估GC的性能指标</h2><ul><li><p><strong>吞吐量</strong>：运行用户代码的时间占总运行时间的比例（总运行时间 &#x3D; 程序的运行时间 + 内存回收的时间）</p></li><li><p>垃圾收集开销：吞吐量的补数，垃圾收集所用时间与总运行时间的比例。</p></li><li><p><strong>暂停时间</strong>：执行垃圾收集时，程序的工作线程被暂停的时间。</p></li><li><p>收集频率：相对于应用程序的执行，收集操作发生的频率。</p></li><li><p><strong>内存占用</strong>：Java堆区所占的内存大小。</p></li><li><p>快速：一个对象从诞生到被回收所经历的时间。</p></li></ul><p>吞吐量、暂停时间、内存占用 这三者共同构成一个“不可能三角”。三者总体的表现会随着技术进步而越来越好。一款优秀的收集器通常最多同时满足其中的两项。</p><p>这三项里，暂停时间的重要性日益凸显。因为随着硬件发展，内存占用多些越来越能容忍，硬件性能的提升也有助于降低收集器运行时对应用程序的影响，即提高了吞吐量。而内存的扩大，对延迟反而带来负面效果。</p><p><strong>简单来说，主要抓住两点：吞吐量、暂停时间</strong></p><h3 id="3-1-吞吐量"><a href="#3-1-吞吐量" class="headerlink" title="3.1 吞吐量"></a>3.1 吞吐量</h3><p>吞吐量就是CPU用于运行用户代码的时间与CPU总消耗时间的比值，即吞吐量 &#x3D; 运行用户代码时间 &#x2F;（运行用户代码时间+垃圾收集时间）。比如：虚拟机总共运行了100分钟，其中垃圾收集花掉1分钟，那吞吐量就是99%。</p><p>这种情况下，应用程序能容忍较高的暂停时间，因此，高吞吐量的应用程序有更长的时间基准，快速响应是不必考虑的.</p><p>吞吐量优先，意味着在单位时间内，STW的时间最短：0.2 + 0.2 &#x3D; 0.4</p><p><img src="https://raw.githubusercontent.com/GeorgeChan95/blogimg/master/img/2024/07/10/20240710-195512.png" alt="吞吐量优先"></p><h3 id="3-2-暂停时间"><a href="#3-2-暂停时间" class="headerlink" title="3.2 暂停时间"></a>3.2 暂停时间</h3><p>“暂停时间”是指一个时间段内应用程序线程暂停，让GC线程执行的状态。</p><p>例如，GC期间100毫秒的暂停时间意味着在这100毫秒期间内没有应用程序线程是活动的。</p><p>暂停时间优先，意味着尽可能让单次STW的时间最短：0.1 + 0.1 + 0.1 + 0.1 + 0.1 &#x3D; 0.5</p><p><img src="https://raw.githubusercontent.com/GeorgeChan95/blogimg/master/img/2024/07/10/20240710-195651.png" alt="暂停时间优先"></p><h3 id="3-3-吞吐量-vs-暂停时间"><a href="#3-3-吞吐量-vs-暂停时间" class="headerlink" title="3.3 吞吐量 vs 暂停时间"></a>3.3 吞吐量 vs 暂停时间</h3><p>高吞吐量较好因为这会让应用程序的最终用户感觉只有应用程序线程在做“生产性”工作。直觉上，吞吐量越高程序运行越快。</p><p>低暂停时间（低延迟）较好因为从最终用户的角度来看不管是GC还是其他原因导致一个应用被挂起始终是不好的。这取决于应用程序的类型，有时候甚至短暂的200毫秒暂停都可能打断终端用户体验。因此，具有低的较大暂停时间是非常重要的，特别是对于一个交互式应用程序。</p><p>不幸的是”高吞吐量”和”低暂停时间”是一对相互竞争的目标（矛盾）。</p><ul><li>因为如果选择以吞吐量优先，那么必然需要降低内存回收的执行频率，但是这样会导致GC需要更长的暂停时间来执行内存回收。</li><li>相反的，如果选择以低延迟优先为原则，那么为了降低每次执行内存回收时的暂停时间，也只能频繁地执行内存回收，但这又引起了年轻代内存的缩减和导致程序吞吐量的下降。</li></ul><p>在设计（或使用）GC算法时，我们必须确定我们的目标：一个GC算法只可能针对两个目标之一（即只专注于较大吞吐量或最小暂停时间），或尝试找到一个二者的折衷。</p><p>现在标准：<strong>在最大吞吐量优先的情况下，降低停顿时间</strong></p><h1 id="二、不同的垃圾回收器概述"><a href="#二、不同的垃圾回收器概述" class="headerlink" title="二、不同的垃圾回收器概述"></a>二、不同的垃圾回收器概述</h1><h2 id="1-垃圾回收器发展史"><a href="#1-垃圾回收器发展史" class="headerlink" title="1. 垃圾回收器发展史"></a>1. 垃圾回收器发展史</h2><p>有了虚拟机，就一定需要收集垃圾的机制，这就是Garbage Collection，对应的产品我们称为Garbage Collector。</p><ul><li><p>1999年随JDK1.3.1一起来的是串行方式的serialGc，它是第一款GC。ParNew垃圾收集器是Serial收集器的多线程版本</p></li><li><p>2002年2月26日，Parallel GC和Concurrent Mark Sweep GC跟随JDK1.4.2一起发布·</p></li><li><p>Parallel GC在JDK6之后成为HotSpot默认GC。</p></li><li><p>2012年，在JDK1.7u4版本中，G1可用。</p></li><li><p>2017年，JDK9中G1变成默认的垃圾收集器，以替代CMS。</p></li><li><p>2018年3月，JDK10中G1垃圾回收器的并行完整垃圾回收，实现并行性来改善最坏情况下的延迟。</p></li><li><p>2018年9月，JDK11发布。引入Epsilon 垃圾回收器，又被称为 “No-Op(无操作)“ 回收器。同时，引入ZGC：可伸缩的低延迟垃圾回收器（Experimental）</p></li><li><p>2019年3月，JDK12发布。增强G1，自动返回未用堆内存给操作系统。同时，引入Shenandoah GC：低停顿时间的GC（Experimental）。·</p></li><li><p>2019年9月，JDK13发布。增强ZGC，自动返回未用堆内存给操作系统。</p></li><li><p>2020年3月，JDK14发布。删除CMS垃圾回收器。扩展ZGC在macos和Windows上的应用</p></li></ul><h2 id="2-7种经典的垃圾收集器"><a href="#2-7种经典的垃圾收集器" class="headerlink" title="2. 7种经典的垃圾收集器"></a>2. 7种经典的垃圾收集器</h2><ul><li><p>串行回收器：Serial、Serial Old</p></li><li><p>并行回收器：ParNew、Parallel Scavenge、Parallel old</p></li><li><p>并发回收器：CMS、G1</p></li></ul><img src="https://raw.githubusercontent.com/GeorgeChan95/blogimg/master/img/2024/07/10/20240710-201713.png" alt="经典垃圾回收器" style="zoom:67%;" /><p>官方手册：<a href="https://www.oracle.com/technetwork/java/javase/tech/memorymanagement-whitepaper-1-150020.pdf">https://www.oracle.com/technetwork/java/javase/tech/memorymanagement-whitepaper-1-150020.pdf</a></p><h2 id="3-7款经典收集器与垃圾分代之间的关系"><a href="#3-7款经典收集器与垃圾分代之间的关系" class="headerlink" title="3. 7款经典收集器与垃圾分代之间的关系"></a>3. 7款经典收集器与垃圾分代之间的关系</h2><ul><li><p>新生代收集器：Serial、ParNew、Parallel Scavenge； </p></li><li><p>老年代收集器：Serial Old、Parallel Old、CMS； </p></li><li><p>整堆收集器：G1；</p></li></ul><p><img src="https://raw.githubusercontent.com/GeorgeChan95/blogimg/master/img/2024/07/10/20240710-201821.png" alt="经典收集器与垃圾分代之间的关系"></p><h2 id="4-垃圾收集器的组合关系"><a href="#4-垃圾收集器的组合关系" class="headerlink" title="4. 垃圾收集器的组合关系"></a>4. 垃圾收集器的组合关系</h2><p><img src="https://raw.githubusercontent.com/GeorgeChan95/blogimg/master/img/2024/07/10/20240710-201913.png" alt="垃圾收集器的组合关系"></p><ol><li>两个收集器间有连线，表明它们可以搭配使用：Serial&#x2F;Serial Old、Serial&#x2F;CMS、ParNew&#x2F;Serial Old、ParNew&#x2F;CMS、Parallel Scavenge&#x2F;Serial Old、Parallel Scavenge&#x2F;Parallel Old、G1；</li><li>其中Serial Old作为CMS出现”<code>Concurrent Mode Failure</code>“失败的后备预案。</li><li>（红色虚线）由于维护和兼容性测试的成本，在JDK 8时将Serial+CMS、ParNew+Serial Old这两个组合声明为废弃（JEP173），并在JDK9中完全取消了这些组合的支持（JEP214），即：移除。</li><li>（绿色虚线）JDK14中：弃用Parallel Scavenge和Serialold GC组合（JEP366）</li><li>（绿色虚框）JDK14中：删除CMS垃圾回收器（JEP363）</li></ol><h2 id="5-不同的垃圾收集器概述"><a href="#5-不同的垃圾收集器概述" class="headerlink" title="5.  不同的垃圾收集器概述"></a>5.  不同的垃圾收集器概述</h2><p>为什么要有很多收集器，一个不够吗？因为Java的使用场景很多，移动端，服务器等。所以就需要针对不同的场景，提供不同的垃圾收集器，提高垃圾收集的性能。</p><p>虽然我们会对各个收集器进行比较，但并非为了挑选一个最好的收集器出来。没有一种放之四海皆准、任何场景下都适用的完美收集器存在，更加没有万能的收集器。所以我们选择的只是对具体应用最合适的收集器。</p><h2 id="6-如何查看默认垃圾收集器"><a href="#6-如何查看默认垃圾收集器" class="headerlink" title="6. 如何查看默认垃圾收集器"></a>6. 如何查看默认垃圾收集器</h2><ul><li><p><code>-XX:+PrintCommandLineFlags</code>：查看命令行相关参数（包含使用的垃圾收集器）</p></li><li><p>使用命令行指令：<code>jinfo -flag 相关垃圾回收器参数 进程ID</code></p></li></ul><h1 id="三、Serial垃圾回收器-串行回收"><a href="#三、Serial垃圾回收器-串行回收" class="headerlink" title="三、Serial垃圾回收器:串行回收"></a>三、Serial垃圾回收器:串行回收</h1><ul><li><p>Serial收集器是最基本、历史最悠久的垃圾收集器了。JDK1.3之前回收新生代唯一的选择。</p></li><li><p>Serial收集器作为<strong>HotSpot中client模式下的默认新生代垃圾收集器</strong>。</p></li><li><p>Serial收集器采用<strong>复制算法、串行回收</strong>和”stop-the-World”机制的方式执行内存回收。</p></li><li><p>除了年轻代之外，Serial收集器还提供用于执行老年代垃圾收集的<strong>Serial Old收集器</strong>。Serial Old收集器同样也采用了<strong>串行回收</strong>和”Stop the World”机制，只不过内存回收算法使用的是<strong>标记-压缩算法</strong>。</p><ul><li><p>Serial old是运行在Client模式下默认的老年代的垃圾回收器</p></li><li><p>Serial 0ld在Server模式下主要有两个用途：① 与新生代的Parallel scavenge配合使用 ② 作为老年代CMS收集器的后备垃圾收集方案</p><p><img src="https://raw.githubusercontent.com/GeorgeChan95/blogimg/master/img/2024/07/10/20240710-202618.png" alt="Serial与Serial Old"></p></li></ul></li></ul><p>这个收集器是一个单线程的收集器，但它的“单线程”的意义并不仅仅说明它只会使用一个CPU或一条收集线程去完成垃圾收集工作，更重要的是在它进行垃圾收集时，必须暂停其他所有的工作线程，直到它收集结束（Stop The World）</p><p><strong>优势：简单而高效</strong>（与其他收集器的单线程比），对于限定单个CPU的环境来说，Serial收集器由于没有线程交互的开销，专心做垃圾收集自然可以获得最高的单线程收集效率。运行在Client模式下的虚拟机是个不错的选择。在用户的桌面应用场景中，可用内存一般不大（几十MB至一两百MB），可以在较短时间内完成垃圾收集（几十ms至一百多ms），只要不频繁发生，使用串行回收器是可以接受的。</p><p>在HotSpot虚拟机中，使用**<code>-XX:+UseSerialGC</code>参数**可以指定年轻代和老年代都使用串行收集器。等价于新生代用Serial GC，且老年代用Serial Old GC</p><ul><li><code>-XX:+UseSerialGC</code> : 使用Serial 与 Serial Old GC</li></ul><p><strong>总结</strong></p><p>了解即可,现在的CPU都不是单核的了.对于交互较强的应用而言，这种垃圾收集器是不能接受的。一般在Java web应用程序中是不会采用串行垃圾收集器的。</p><h1 id="四、ParNew回收器-并行回收"><a href="#四、ParNew回收器-并行回收" class="headerlink" title="四、ParNew回收器:并行回收"></a>四、ParNew回收器:并行回收</h1><p>如果说Serial GC是年轻代中的单线程垃圾收集器，那么ParNew收集器则是Serial收集器的多线程版本。Par是Parallel的缩写，New：只能处理的是新生代.</p><p>ParNew 收集器除了采用并行回收的方式执行内存回收外，两款垃圾收集器之间几乎没有任何区别。ParNew收集器在年轻代中同样也是采用复制算法、”Stop-the-World”机制。</p><p>ParNew 是很多JVM运行在Server模式下新生代的默认垃圾收集器。</p><p><img src="C:/Users/kd/Desktop/f0178eb2-630b-40ae-86e7-2b37c00351ce.png" alt="ParNew/SerialOld"></p><ul><li>对于新生代，回收次数频繁，使用并行方式高效。</li><li>对于老年代，回收次数少，使用串行方式节省资源。（CPU并行需要切换线程，串行可以省去切换线程的资源）</li></ul><p>由于ParNew收集器是基于并行回收，那么是否可以断定ParNew收集器的回收效率在任何场景下都会比serial收集器更高效？</p><ul><li><p>ParNew 收集器运行在多CPU的环境下，由于可以充分利用多CPU、多核心等物理硬件资源优势，可以更快速地完成垃圾收集，提升程序的吞吐量。</p></li><li><p>但是在单个CPU的环境下，ParNew收集器不比Serial 收集器更高效。虽然Serial收集器是基于串行回收，但是由于CPU不需要频繁地做任务切换，因此可以有效避免多线程交互过程中产生的一些额外开销。</p></li></ul><p><strong>除Serial外，目前只有ParNew GC能与CMS收集器配合工作.</strong></p><p>在程序中，开发人员可以通过选项 <strong>“<code>-XX:+UseParNewGC</code>“</strong> 手动指定使用ParNew收集器执行内存回收任务。它表示年轻代使用并行收集器，不影响老年代。</p><p><strong><code>-XX:ParallelGCThreads</code></strong> : 限制线程数量，默认开启和CPU数据相同的线程数。</p><h1 id="五、Parallel回收器-吞吐量优先"><a href="#五、Parallel回收器-吞吐量优先" class="headerlink" title="五、Parallel回收器:吞吐量优先"></a>五、Parallel回收器:吞吐量优先</h1><p>HotSpot的年轻代中除了拥有ParNew收集器是基于并行回收的以外，Parallel Scavenge收集器同样也采用了复制算法、并行回收和”Stop the World”机制。</p><p>那么Parallel 收集器的出现是否多此一举？</p><ul><li><p>和ParNew收集器不同，ParallelScavenge收集器的目标则是达到一个<strong>可控制的吞吐量（Throughput）</strong>，它也被称为<strong>吞吐量优先的垃圾收集器</strong>。</p></li><li><p><strong>自适应调节策略</strong>也是Parallel Scavenge与ParNew一个重要区别。</p></li></ul><p>高吞吐量则可以高效率地利用CPU时间，尽快完成程序的运算任务，主要适合在后台运算而不需要太多交互的任务。因此，常见在服务器环境中使用。例如，那些执行批量处理、订单处理、工资支付、科学计算的应用程序。</p><p>Parallel 收集器在JDK1.6时提供了用于执行老年代垃圾收集的Parallel Old收集器，用来代替老年代的Serial Old收集器。</p><p><strong>Parallel Old收集器采用了标记-压缩算法，但同样也是基于并行回收和”Stop-the-World”机制。</strong></p><p><img src="https://raw.githubusercontent.com/GeorgeChan95/blogimg/master/img/2024/07/11/20240711-154238.png" alt="Parallel Scavenge/Parallel Old"></p><p>在程序吞吐量优先的应用场景中，Parallel 收集器和Parallel Old收集器的组合，在Server模式下的内存回收性能很不错。在<strong>Java8中，默认是此垃圾收集器。</strong></p><p><strong>参数配置</strong></p><ul><li><p><code>-XX:+UseParallelGC</code> 手动指定年轻代使用Parallel并行收集器执行内存回收任务。 </p></li><li><p><code>-XX:+UseParallelOldGC</code> 手动指定老年代都是使用并行回收收集器。 </p></li><li><ul><li>分别适用于新生代和老年代。默认jdk8是开启的。</li></ul></li><li><ul><li>上面两个参数，默认开启一个，另一个也会被开启。（互相激活）</li></ul></li><li><p><code>-XX:ParallelGCThreads</code> 设置年轻代并行收集器的线程数。一般地，最好与CPU数量相等，以避免过多的线程数影响垃圾收集性能。</p></li></ul><p>  <img src="https://raw.githubusercontent.com/GeorgeChan95/blogimg/master/img/2024/07/11/20240711-154905.png" alt="ParallelGC线程数分配算法"></p><ul><li><p><code>-XX:MaxGCPauseMillis</code> 设置垃圾收集器最大停顿时间（即STW的时间）。单位是毫秒。 </p></li><li><ul><li>为了尽可能地把停顿时间控制在MaxGCPauseMills以内，收集器在工作时会调整Java堆大小或者其他一些参数。</li></ul></li><li><ul><li>对于用户来讲，停顿时间越短体验越好。但是在服务器端，我们注重高并发，整体的吞吐量。所以服务器端适合Parallel，进行控制。</li></ul></li><li><ul><li>该参数使用需谨慎。</li></ul></li><li><p><code>-XX:GCTimeRatio</code> 垃圾收集时间占总时间的比例（&#x3D;1 &#x2F;（N+1））。用于衡量吞吐量的大小。 </p></li><li><ul><li>取值范围（0, 100）。默认值99，也就是垃圾回收时间不超过1%。</li></ul></li><li><ul><li>与前一个<code>-XX:MaxGCPauseMillis</code>参数有一定矛盾性。暂停时间越长，Radio参数就容易超过设定的比例。</li></ul></li><li><p><code>-XX:+UseAdaptivesizePolicy</code> 设置Parallel Scavenge收集器具有自适应调节策略 </p></li><li><ul><li>在这种模式下，年轻代的大小、Eden和Survivor的比例、晋升老年代的对象年龄等参数会被自动调整，已达到在堆大小、吞吐量和停顿时间之间的平衡点。</li></ul></li><li><ul><li>在手动调优比较困难的场合，可以直接使用这种自适应的方式，仅指定虚拟机的最大堆、目标的吞吐量（<code>GCTimeRatio</code>）和停顿时间（<code>MaxGCPauseMills</code>），让虚拟机自己完成调优工作。</li></ul></li></ul><h1 id="六、CMS回收器-低延迟"><a href="#六、CMS回收器-低延迟" class="headerlink" title="六、CMS回收器:低延迟"></a>六、CMS回收器:低延迟</h1><h2 id="1-CMS概述"><a href="#1-CMS概述" class="headerlink" title="1. CMS概述"></a>1. CMS概述</h2><p>在JDK1.5时期，Hotspot推出了一款在<em>强交互应用中</em>几乎可认为有划时代意义的垃圾收集器：CMS（Concurrent-Mark-Sweep）收集器，这款收集器是HotSpot虚拟机中第一款真正意义上的并发收集器，它第一次实现了让垃圾收集线程与用户线程同时工作。</p><p>CMS收集器的关注点是尽可能缩短垃圾收集时用户线程的停顿时间。停顿时间越短（低延迟）就越适合与用户交互的程序，良好的响应速度能提升用户体验。</p><p><strong>CMS的垃圾收集算法采用标记-清除算法，并且也会”Stop-the-World”</strong></p><p>不幸的是，CMS作为老年代的收集器，却无法与JDK1.4.0中已经存在的新生代收集器Parallel Scavenge配合工作，所以在JDK1.5中使用CMS来收集老年代的时候，新生代只能选择ParNew或者Serial收集器中的一个。</p><p>在G1出现之前，CMS使用还是非常广泛的。一直到今天，仍然有很多系统使用CMS GC。</p><p><img src="https://raw.githubusercontent.com/GeorgeChan95/blogimg/master/img/2024/07/11/20240711-155804.png" alt="CMS GC"></p><p>CMS整个过程比之前的收集器要复杂，整个过程分为4个主要阶段，即初始标记阶段、并发标记阶段、重新标记阶段和并发清除阶段</p><ul><li><p><strong>初始标记</strong>（Initial-Mark）阶段：在这个阶段中，程序中所有的工作线程都将会因为“Stop-the-World”机制而出现短暂的暂停，这个阶段的主要任务仅仅只是标记出GCRoots能直接关联到的对象。一旦标记完成之后就会恢复之前被暂停的所有应用线程。由于直接关联对象比较小，所以这里的速度非常快。</p></li><li><p><strong>并发标记</strong>（Concurrent-Mark）阶段：从GC Roots的直接关联对象开始遍历整个对象图的过程，这个过程耗时较长但是不需要停顿用户线程，可以与垃圾收集线程一起并发运行。</p></li><li><p><strong>重新标记</strong>（Remark）阶段：由于在并发标记阶段中，程序的工作线程会和垃圾收集线程同时运行或者交叉运行，因此为了修正并发标记期间，因用户程序继续运作而导致标记产生变动的那一部分对象的标记记录，这个阶段的停顿时间通常会比初始标记阶段稍长一些，但也远比并发标记阶段的时间短。</p></li><li><p><strong>并发清除</strong>（Concurrent-Sweep）阶段：此阶段清理删除掉标记阶段判断的已经死亡的对象，释放内存空间。由于不需要移动存活对象，所以这个阶段也是可以与用户线程同时并发的</p></li></ul><p>尽管CMS收集器采用的是并发回收（非独占式），但是在其初始化标记和再次标记这两个阶段中仍然需要执行“Stop-the-World”机制暂停程序中的工作线程，不过暂停时间并不会太长，因此可以说明目前所有的垃圾收集器都做不到完全不需要“stop-the-World”，只是尽可能地缩短暂停时间。</p><p>由于最耗费时间的并发标记与并发清除阶段都不需要暂停工作，所以整体的回收是低停顿的。</p><p>另外，由于在垃圾收集阶段用户线程没有中断，所以在CMS回收过程中，还应该确保应用程序用户线程有足够的内存可用。因此，CMS收集器不能像其他收集器那样等到老年代几乎完全被填满了再进行收集，而是当堆内存使用率达到某一阈值时，便开始进行回收，以确保应用程序在CMS工作过程中依然有足够的空间支持应用程序运行。要是CMS运行期间预留的内存无法满足程序需要，就会出现一次“<code>Concurrent Mode Failure</code>” 失败，这时虚拟机将启动后备预案：临时启用Serial Old收集器来重新进行老年代的垃圾收集，这样停顿时间就很长了。</p><p><strong>CMS收集器的垃圾收集算法采用的是标记清除算法</strong>，这意味着每次执行完内存回收后，由于被执行内存回收的无用对象所占用的内存空间极有可能是不连续的一些内存块，不可避免地将会产生一些内存碎片。那么CMS在为新对象分配内存空间时，将无法使用指针碰撞（Bump the Pointer）技术，而<strong>只能够选择空闲列表（Free List）执行内存分配。</strong></p><p><img src="https://raw.githubusercontent.com/GeorgeChan95/blogimg/master/img/2024/07/11/20240711-160320.png" alt="CMS垃圾清理"></p><p><strong>有人会觉得既然Mark Sweep会造成内存碎片，那么为什么不把算法换成Mark Compact？</strong></p><p>答案其实很简单，因为当并发清除的时候，用Compact整理内存的话，原来的用户线程使用的内存还怎么用呢？要保证用户线程能继续执行，前提的它运行的资源不受影响嘛。Mark Compact更适合“Stop the World” 这种场景下使用</p><h2 id="2-CMS的优点"><a href="#2-CMS的优点" class="headerlink" title="2. CMS的优点"></a>2. CMS的优点</h2><ul><li><p>并发收集</p></li><li><p>低延迟</p></li></ul><h2 id="3-CMS的弊端"><a href="#3-CMS的弊端" class="headerlink" title="3. CMS的弊端"></a>3. CMS的弊端</h2><ul><li><p>会产生内存碎片，导致并发清除后，用户线程可用的空间不足。在无法分配大对象的情况下，不得不提前触发FullGC。</p></li><li><p>CMS收集器对CPU资源非常敏感。在并发阶段，它虽然不会导致用户停顿，但是会因为占用了一部分线程而导致应用程序变慢，总吞吐量会降低。</p></li><li><p>CMS收集器无法处理浮动垃圾。可能出现“<code>Concurrent Mode Failure</code>“失败而导致另一次Full GC的产生。在并发标记阶段由于程序的工作线程和垃圾收集线程是同时运行或者交叉运行的，那么在并发标记阶段如果产生新的垃圾对象，CMS将无法对这些垃圾对象进行标记，最终会导致这些新产生的垃圾对象没有被及时回收，从而只能在下一次执行GC时释放这些之前未被回收的内存空间。</p></li></ul><h3 id=""><a href="#" class="headerlink" title=""></a></h3><h2 id="4-参数设置"><a href="#4-参数设置" class="headerlink" title="4. 参数设置"></a>4. 参数设置</h2><ul><li><p><code>-XX:+UseConcMarkSweepGC</code> 手动指定使用CMS收集器执行内存回收任务。<br>开启该参数后会自动将<code>-xx:+UseParNewGC</code>打开。即：ParNew（Young区用）+CMS（Old区用）+ Serial Old的组合。 </p></li><li><p><code>-XX:CMSInitiatingOccupanyFraction</code> 设置堆内存使用率的阈值，一旦达到该阈值，便开始进行回收。 </p></li><li><ul><li>JDK5及以前版本的默认值为68，即当老年代的空间使用率达到68%时，会执行一次CMS回收。JDK6及以上版本默认值为92%</li></ul></li><li><ul><li>如果内存增长缓慢，则可以设置一个稍大的值，大的阀值可以有效降低CMS的触发频率，减少老年代回收的次数可以较为明显地改善应用程序性能。反之，如果应用程序内存使用率增长很快，则应该降低这个阈值，以避免频繁触发老年代串行收集器。因此通过该选项便可以有效降低Ful1Gc的执行次数。</li></ul></li><li><p><code>-XX:+UseCMSCompactAtFullCollection</code> 用于指定在执行完Full GC后对内存空间进行压缩整理，以此避免内存碎片的产生。不过由于内存压缩整理过程无法并发执行，所带来的问题就是停顿时间变得更长了。 </p></li><li><p><code>-XX:CMSFullGCsBeforeCompaction</code> 设置在执行多少次Full GC后对内存空间进行压缩整理。 </p></li><li><p><code>-XX:ParallelCMSThreads=&lt;number&gt;</code> 设置CMS的线程数量。 </p></li><li><ul><li>CMS默认启动的线程数是（ParallelGCThreads+3）&#x2F;4，ParallelGCThreads是年轻代并行收集器的线程数。当CPU资源比较紧张时，受到CMS收集器线程的影响，应用程序的性能在垃圾回收阶段可能会非常糟糕。</li></ul></li></ul><h2 id="5-总结"><a href="#5-总结" class="headerlink" title="5. 总结"></a>5. 总结</h2><p>Serial GC、Parallel GC、Concurrent Mark Sweep GC这三个Gc有什么不同？</p><ul><li><p>如果你想要最小化地使用内存和并行开销，请选Serial GC；</p></li><li><p>如果你想要最大化应用程序的吞吐量，请选Parallel GC；</p></li><li><p>如果你想要最小化GC的中断或停顿时间，请选CMS GC。</p></li></ul><h2 id="6-JDK后续版本中CMS的变化"><a href="#6-JDK后续版本中CMS的变化" class="headerlink" title="6. JDK后续版本中CMS的变化"></a>6. JDK后续版本中CMS的变化</h2><p>JDK9新特性：CMS被标记为Deprecate了（JEP291）</p><ul><li>如果对JDK9及以上版本的HotSpot虚拟机使用参数<code>-XX: +UseConcMarkSweepGC</code>来开启CMS收集器的话，用户会收到一个警告信息，提示CMS未来将会被废弃。</li></ul><p>JDK14新特性：删除CMS垃圾回收器（JEP363）</p><ul><li>移除了CMS垃圾收集器，如果在JDK14中使用 <code>-XX:+UseConcMarkSweepGC</code>的话，JVM不会报错，只是给出一个warning信息，但是不会exit。JVM会自动回退以默认GC方式启动JVM</li></ul><h1 id="七、G1回收器-区域化分代式"><a href="#七、G1回收器-区域化分代式" class="headerlink" title="七、G1回收器:区域化分代式"></a>七、G1回收器:区域化分代式</h1><h2 id="1-概述"><a href="#1-概述" class="headerlink" title="1. 概述"></a>1. 概述</h2><p><strong>既然我们已经有了前面几个强大的GC，为什么还要发布Garbage First（G1）？</strong></p><ul><li><p>原因就在于应用程序所应对的业务越来越庞大、复杂，用户越来越多，没有GC就不能保证应用程序正常进行，而经常造成STW的GC又跟不上实际的需求，所以才会不断地尝试对GC进行优化。G1（Garbage-First）垃圾回收器是在Java7 update4之后引入的一个新的垃圾回收器，是当今收集器技术发展的最前沿成果之一。</p></li><li><p>与此同时，为了适应现在不断扩大的内存和不断增加的处理器数量，进一步降低暂停时间（pause time），同时兼顾良好的吞吐量。官方给G1设定的目标是<strong>在延迟可控的情况下获得尽可能高的吞吐量</strong>，所以才担当起“<strong>全功能收集器</strong>”的重任与期望。</p></li></ul><p><strong>为什么名字叫 Garbage First(G1)呢？</strong></p><ul><li>因为G1是一个并行回收器，它把堆内存分割为很多不相关的区域（Region）（物理上不连续的）。使用不同的Region来表示Eden、幸存者0区，幸存者1区，老年代等。</li><li>G1 GC有计划地避免在整个Java堆中进行全区域的垃圾收集。G1跟踪各个Region里面的垃圾堆积的价值大小（回收所获得的空间大小以及回收所需时间的经验值），在后台维护一个优先列表，每次根据允许的收集时间，优先回收价值最大的Region。</li><li>由于这种方式的侧重点在于回收垃圾最大量的区间（Region），所以我们给G1一个名字：<strong>垃圾优先（Garbage First）</strong>。</li><li>G1（Garbage-First）是一款面向服务端应用的垃圾收集器，主要针对配备多核CPU及大容量内存的机器，以极高概率满足GC停顿时间的同时，还兼具高吞吐量的性能特征。</li><li>在JDK1.7版本正式启用，移除了Experimenta1的标识，是JDK9以后的默认垃圾回收器，取代了CMS回收器以及Parallel+Parallel Old组合。被Oracle官方称为“全功能的垃圾收集器”。</li><li>与此同时，CMS已经在JDK9中被标记为废弃（deprecated）。在jdk8中还不是默认的垃圾回收器，需要使用<code>-XX:+UseG1GC</code>来启用。</li></ul><h2 id="2-G1回收器的特点（优势）"><a href="#2-G1回收器的特点（优势）" class="headerlink" title="2. G1回收器的特点（优势）"></a>2. G1回收器的特点（优势）</h2><p>与其他GC收集器相比，G1使用了全新的分区算法，其特点如下所示：</p><h3 id="2-1-并行与并发"><a href="#2-1-并行与并发" class="headerlink" title="2.1 并行与并发"></a>2.1 并行与并发</h3><ul><li><p>并行性：G1在回收期间，可以有多个GC线程同时工作，有效利用多核计算能力。此时用户线程STW</p></li><li><p>并发性：G1拥有与应用程序交替执行的能力，部分工作可以和应用程序同时执行，因此，一般来说，不会在整个回收阶段发生完全阻塞应用程序的情况</p></li></ul><h3 id="2-2-分代收集"><a href="#2-2-分代收集" class="headerlink" title="2.2 分代收集"></a>2.2 分代收集</h3><ul><li><p>从分代上看，G1依然属于分代型垃圾回收器，它会区分年轻代和老年代，年轻代依然有Eden区和Survivor区。但从堆的结构上看，它不要求整个Eden区、年轻代或者老年代都是连续的，也不再坚持固定大小和固定数量。</p></li><li><p>将堆空间分为若干个区域（Region），这些区域中包含了逻辑上的年轻代和老年代。</p></li><li><p>和之前的各类回收器不同，它同时兼顾年轻代和老年代。对比其他回收器，要么只能工作在年轻代，要么只能工作在老年代；</p></li></ul><p><img src="https://raw.githubusercontent.com/GeorgeChan95/blogimg/master/img/2024/07/12/20240712-160058.png" alt="G1内存划分"></p><h3 id="2-3-空间整合"><a href="#2-3-空间整合" class="headerlink" title="2.3 空间整合"></a>2.3 空间整合</h3><ul><li><p>CMS：“标记-清除”算法、内存碎片、若干次GC后进行一次碎片整理</p></li><li><p>G1将内存划分为一个个的region。内存的回收是以region作为基本单位的。Region之间是复制算法，但整体上实际可看作是标记-压缩（Mark-Compact）算法，两种算法都可以避免内存碎片。这种特性有利于程序长时间运行，分配大对象时不会因为无法找到连续内存空间而提前触发下一次GC。尤其是当Java堆非常大的时候，G1的优势更加明显。</p></li></ul><h3 id="2-4-可预测的停顿时间模型（即：软实时soft-real-time）"><a href="#2-4-可预测的停顿时间模型（即：软实时soft-real-time）" class="headerlink" title="2.4 可预测的停顿时间模型（即：软实时soft real-time）"></a>2.4 可预测的停顿时间模型（即：软实时soft real-time）</h3><p>这是G1相对于CMS的另一大优势，G1除了追求低停顿外，还能建立可预测的停顿时间模型，能让使用者明确指定在一个长度为M毫秒的时间片段内，消耗在垃圾收集上的时间不得超过N毫秒。</p><ul><li><p>由于分区的原因，G1可以只选取部分区域进行内存回收，这样缩小了回收的范围，因此对于全局停顿情况的发生也能得到较好的控制。</p></li><li><p>G1跟踪各个Region里面的垃圾堆积的价值大小（回收所获得的空间大小以及回收所需时间的经验值），在后台维护一个优先列表，每次根据允许的收集时间，优先回收价值最大的Region。保证了G1收集器在有限的时间内可以获取尽可能高的收集效率。</p></li><li><p>相比于CMS，G1未必能做到CMS在最好情况下的延时停顿，但是最差情况要好很多。</p></li></ul><h2 id="3-G1垃圾收集器的缺点"><a href="#3-G1垃圾收集器的缺点" class="headerlink" title="3. G1垃圾收集器的缺点"></a>3. G1垃圾收集器的缺点</h2><p>相较于CMS，G1还不具备全方位、压倒性优势。比如在用户程序运行过程中，G1无论是为了垃圾收集产生的内存占用（Footprint）还是程序运行时的额外执行负载（Overload）都要比CMS要高。</p><p>从经验上来说，在小内存应用上CMS的表现大概率会优于G1，而G1在大内存应用上则发挥其优势。平衡点在6-8GB之间。</p><h2 id="4-G1回收器的参数设置"><a href="#4-G1回收器的参数设置" class="headerlink" title="4. G1回收器的参数设置"></a>4. G1回收器的参数设置</h2><ul><li><p><code>-XX:+UseG1GC</code>：手动指定使用G1垃圾收集器执行内存回收任务</p></li><li><p><code>-XX:G1HeapRegionSize</code> 设置每个Region的大小。值是2的幂，范围是1MB到32MB之间，目标是根据最小的Java堆大小划分出约2048个区域。默认是堆内存的1&#x2F;2000。</p></li><li><p><code>-XX:MaxGCPauseMillis</code> 设置期望达到的最大GC停顿时间指标（JVM会尽力实现，但不保证达到）。默认值是200ms（人的平均反应速度）</p></li><li><p><code>-XX:+ParallelGCThreads</code> 设置STW工作线程数的值。最多设置为8（上面说过Parallel回收器的线程计算公式，当CPU_Count &gt; 8时，ParallelGCThreads 也会大于8）</p></li><li><p><code>-XX:ConcGCThreads</code> 设置并发标记的线程数。将n设置为并行垃圾回收线程数（ParallelGCThreads）的1&#x2F;4左右。</p></li><li><p><code>-XX:InitiatingHeapOccupancyPercent</code> 设置触发并发GC周期的Java堆占用率阈值。超过此值，就触发GC。默认值是45。</p></li></ul><h2 id="5-G1收集器的常见操作步骤"><a href="#5-G1收集器的常见操作步骤" class="headerlink" title="5. G1收集器的常见操作步骤"></a>5. G1收集器的常见操作步骤</h2><p>G1的设计原则就是简化JVM性能调优，开发人员只需要简单的三步即可完成调优：</p><ul><li><p>第一步：开启G1垃圾收集器</p></li><li><p>第二步：设置堆的最大内存</p></li><li><p>第三步：设置最大的停顿时间</p></li></ul><p>G1中提供了三种垃圾回收模式：<strong>Young GC</strong>、<strong>Mixed GC</strong> 和 <strong>Full GC</strong>，在不同的条件下被触发。</p><h2 id="6-G1收集器的适用场景"><a href="#6-G1收集器的适用场景" class="headerlink" title="6. G1收集器的适用场景"></a>6. G1收集器的适用场景</h2><p><strong>面向服务端应用，针对具有大内存、多处理器的机器。</strong>（在普通大小的堆里表现并不惊喜）</p><p>最主要的<strong>应用是需要低GC延迟</strong>，并具有大堆的应用程序提供解决方案；如：在堆大小约6GB或更大时，可预测的暂停时间可以低于0.5秒；（G1通过每次只清理一部分而不是全部的Region的增量式清理来保证每次GC停顿时间不会过长）。</p><p>用来替换掉JDK1.5中的CMS收集器；在下面的情况时，使用G1可能比CMS好：</p><ul><li><p>超过50%的Java堆被活动数据占用；</p></li><li><p>对象分配频率或年代提升频率变化很大；</p></li><li><p>GC停顿时间过长（长于0.5至1秒）</p></li></ul><p>HotSpot垃圾收集器里，除了G1以外，其他的垃圾收集器使用内置的 JVM 线程执行GC的多线程操作，而G1 GC可以采用应用线程承担后台运行的 GC 工作，即当JVM 的 GC 线程处理速度慢时，系统会调用应用程序线程帮助加速垃圾回收过程。</p><h2 id="7-分区Region：化整为零"><a href="#7-分区Region：化整为零" class="headerlink" title="7. 分区Region：化整为零"></a>7. 分区Region：化整为零</h2><p>使用G1收集器时，它将整个Java堆划分成约2048个大小相同的独立Region块，每个Region块大小根据堆空间的实际大小而定，整体被控制在1MB到32MB之间，且为2的N次幂，即1MB，2MB，4MB，8MB，16MB，32MB。可以通过 <strong><code>-XX:G1HeapRegionSize</code></strong> 设定。所有的Region大小相同，且在JVM生命周期内不会被改变。</p><p>虽然还保留有新生代和老年代的概念，但新生代和老年代不再是物理隔离的了，它们都是一部分Region（不需要连续）的集合。通过Region的动态分配方式实现逻辑上的连续。</p><p><img src="https://raw.githubusercontent.com/GeorgeChan95/blogimg/master/img/2024/07/12/20240712-162935.png" alt="G1 Region"></p><p>一个region有可能属于Eden，Survivor或者Old&#x2F;Tenured内存区域。但是一个region只可能属于一个角色。图中的E表示该region属于Eden内存区域，S表示属于survivor内存区域，O表示属于Old内存区域。图中空白的表示未使用的内存空间。</p><p>G1垃圾收集器还增加了一种新的内存区域，叫做 <strong>Humongous</strong> 内存区域，如图中的H块。主要用于存储大对象，如果超过1.5个region，就放到H。</p><p><strong>设置H的原因：</strong>对于堆中的对象，默认直接会被分配到老年代，但是如果它是一个短期存在的大对象就会对垃圾收集器造成负面影响。为了解决这个问题，G1划分了一个Humongous区，它用来专门存放大对象。如果一个H区装不下一个大对象，那么G1会寻找连续的H区来存储。为了能找到连续的H区，有时候不得不启动Full GC。G1的大多数行为都把H区作为老年代的一部分来看待。</p><p><strong>每个Region都是通过指针碰撞来分配空间</strong></p><p><img src="https://raw.githubusercontent.com/GeorgeChan95/blogimg/master/img/2024/07/12/20240712-163408.png" alt="region分配方式"></p><h2 id="8-G1垃圾回收器的回收过程"><a href="#8-G1垃圾回收器的回收过程" class="headerlink" title="8. G1垃圾回收器的回收过程"></a>8. G1垃圾回收器的回收过程</h2><p>G1GC的垃圾回收过程主要包括如下三个环节：</p><ul><li><p>年轻代GC（Young GC） </p></li><li><p>老年代并发标记过程（Concurrent Marking） </p></li><li><p>混合回收（Mixed GC）<br>  （如果需要，单线程、独占式、高强度的Full GC还是继续存在的。它针对GC的评估失败提供了一种失败保护机制，即强力回收。）</p></li></ul><p><img src="https://raw.githubusercontent.com/GeorgeChan95/blogimg/master/img/2024/07/12/20240712-163649.png" alt="G1垃圾回收器的回收过程"></p><p>顺时针，Young gc -&gt; Young gc + Concurrent mark-&gt;Mixed GC顺序，进行垃圾回收。</p><p>应用程序分配内存，当年轻代的Eden区用尽时开始年轻代回收过程；<strong>G1的年轻代收集阶段是一个并行的独占式收集器。</strong>在年轻代回收期，G1GC暂停所有应用程序线程，启动多线程执行年轻代回收。然后从年轻代区间移动存活对象到Survivor区间或者老年区间，也有可能是两个区间都会涉及。</p><p><strong>当堆内存使用达到一定值（默认45%）时，开始老年代并发标记过程。</strong></p><p>标记完成马上开始混合回收过程。对于一个混合回收期，G1 GC从老年区间移动存活对象到空闲区间，这些空闲区间也就成为了老年代的一部分。和年轻代不同，老年代的G1回收器和其他GC不同，G1的老年代回收器不需要整个老年代被回收，一次只需要扫描&#x2F;回收一小部分老年代的Region就可以了。同时，这个老年代Region是和年轻代一起被回收的。</p><p>举个例子：一个Web服务器，Java进程最大堆内存为4G，每分钟响应1500个请求，每45秒钟会新分配大约2G的内存。G1会每45秒钟进行一次年轻代回收，每31个小时整个堆的使用率会达到45%，会开始老年代并发标记过程，标记完成后开始四到五次的混合回收。</p><h2 id="9-Remembered-Set"><a href="#9-Remembered-Set" class="headerlink" title="9. Remembered Set"></a>9. Remembered Set</h2><ul><li><p>一个对象被不同区域引用的问题 </p></li><li><p>一个Region不可能是孤立的，一个Region中的对象可能被其他任意Region中对象引用，判断对象存活时，是否需要扫描整个Java堆才能保证准确？ </p></li><li><p>在其他的分代收集器，也存在这样的问题（而G1更突出）回收新生代也不得不同时扫描老年代？ </p></li><li><p>这样的话会降低MinorGC的效率；</p></li></ul><p><strong>解决方法：</strong></p><ul><li><p>无论G1还是其他分代收集器，JVM都是使用Remembered Set来避免全局扫描, </p></li><li><p>每个Region都有一个对应的Remembered Set；</p></li><li><p>每次Reference类型数据写操作时，都会产生一个Write Barrier暂时中断操作；</p></li><li><p>然后检查将要写入的引用指向的对象是否和该Reference类型数据在不同的Region（其他收集器：检查老年代对象是否引用了新生代对象）；</p></li><li><p>如果不同，通过CardTable把相关引用信息记录到引用指向对象的所在Region对应的Remembered Set中；</p></li><li><p>当进行垃圾收集时，在GC根节点的枚举范围加入Remembered Set；就可以保证不进行全局扫描，也不会有遗漏。</p></li></ul><p><img src="https://raw.githubusercontent.com/GeorgeChan95/blogimg/master/img/2024/07/12/20240712-165200.png" alt="记忆集"></p><h2 id="10-G1回收过程"><a href="#10-G1回收过程" class="headerlink" title="10. G1回收过程"></a>10. G1回收过程</h2><h3 id="10-1-回收过程一-年轻代GC"><a href="#10-1-回收过程一-年轻代GC" class="headerlink" title="10.1 回收过程一: 年轻代GC"></a>10.1 回收过程一: 年轻代GC</h3><p>JVM启动时，G1先准备好Eden区，程序在运行过程中不断创建对象到Eden区，当Eden空间耗尽时，G1会启动一次年轻代垃圾回收过程。</p><p>年轻代垃圾回收只会回收Eden区和Survivor区。</p><p>首先G1停止应用程序的执行（Stop-The-World），G1创建回收集（Collection Set），回收集是指需要被回收的内存分段的集合，年轻代回收过程的回收集包含年轻代Eden区和Survivor区所有的内存分段。</p><p><img src="https://raw.githubusercontent.com/GeorgeChan95/blogimg/master/img/2024/07/12/20240712-170726.png" alt="G1年轻代垃圾收集"></p><p>然后开始如下回收过程：</p><ol><li><strong>第一阶段，扫描根。</strong>根是指static变量指向的对象，正在执行的方法调用链条上的局部变量等。根引用连同RSet记录的外部引用作为扫描存活对象的入口。</li><li><strong>第二阶段，更新RSet</strong>。处理dirty card queue（见备注）中的card，更新RSet。此阶段完成后，RSet可以准确的反映老年代对所在的内存分段中对象的引用。</li><li><strong>第三阶段，处理RSet</strong>。识别被老年代对象指向的Eden中的对象，这些被指向的Eden中的对象被认为是存活的对象。</li><li><strong>第四阶段，复制对象</strong>。此阶段，对象树被遍历，Eden区内存段中存活的对象会被复制到Survivor区中空的内存分段，Survivor区内存段中存活的对象如果年龄未达阈值，年龄会加1，达到阀值会被会被复制到Old区中空的内存分段。如果Survivor空间不够，Eden空间的部分数据会直接晋升到老年代空间。</li><li><strong>第五阶段，处理引用</strong>。处理Soft，Weak，Phantom，Final，JNI Weak 等引用。最终Eden空间的数据为空，GC停止工作，而目标内存中的对象都是连续存储的，没有碎片，所以复制过程可以达到内存整理的效果，减少碎片。</li></ol><h3 id="10-2-回收过程二-并发标记过程"><a href="#10-2-回收过程二-并发标记过程" class="headerlink" title="10.2 回收过程二: 并发标记过程"></a>10.2 回收过程二: 并发标记过程</h3><ol><li><strong>初始标记</strong>阶段：标记从根节点直接可达的对象。这个阶段是STW的，并且会触发一次年轻代GC。</li><li><strong>根区域扫描</strong>（Root Region Scanning）：G1 GC扫描Survivor区直接可达的老年代区域对象，并标记被引用的对象。这一过程必须在YoungGC之前完成。</li><li><strong>并发标记</strong>（Concurrent Marking）：在整个堆中进行并发标记（和应用程序并发执行），此过程可能被YoungGC中断。在并发标记阶段，若发现区域对象中的所有对象都是垃圾，那这个区域会被立即回收。同时，并发标记过程中，会计算每个区域的对象活性（区域中存活对象的比例）。</li><li><strong>再次标记</strong>（Remark）：由于应用程序持续进行，需要修正上一次的标记结果。是STW的。<strong>G1中采用了比CMS更快的初始快照算法：snapshot-at-the-beginning（SATB）。</strong></li><li><strong>独占清理</strong>（cleanup，STW）：计算各个区域的存活对象和GC回收比例，并进行排序，识别可以混合回收的区域。为下阶段做铺垫。是STW的。这个阶段并不会实际上去做垃圾的收集</li><li><strong>并发清理阶段</strong>：识别并清理完全空闲的区域。</li></ol><h3 id="10-3-G1回收过程三-混合回收"><a href="#10-3-G1回收过程三-混合回收" class="headerlink" title="10.3 G1回收过程三: 混合回收"></a>10.3 G1回收过程三: 混合回收</h3><p>当越来越多的对象晋升到老年代old region时，为了避免堆内存被耗尽，虚拟机会触发一个混合的垃圾收集器，即Mixed GC，该算法并不是一个Old GC，除了回收整个Young Region，还会回收一部分的Old Region。这里需要注意：是一部分老年代，而不是全部老年代。可以选择哪些Old Region进行收集，从而可以对垃圾回收的耗时时间进行控制。也要注意的是Mixed GC并不是Full GC。</p><p><img src="https://raw.githubusercontent.com/GeorgeChan95/blogimg/master/img/2024/07/12/20240712-175608.png" alt="混合回收"></p><p>并发标记结束以后，老年代中百分百为垃圾的内存分段被回收了，部分为垃圾的内存分段被计算了出来。默认情况下，这些老年代的内存分段会分8次（可以通过 <code>-XX:G1MixedGCCountTarget</code> 设置）被回收.</p><p>混合回收的回收集（Collection Set）包括八分之一的老年代内存分段，Eden区内存分段，Survivor区内存分段。混合回收的算法和年轻代回收的算法完全一样，只是回收集多了老年代的内存分段。具体过程请参考上面的年轻代回收过程。</p><p>由于老年代中的内存分段默认分8次回收，G1会优先回收垃圾多的内存分段。垃圾占内存分段比例越高的，越会被先回收。并且有一个阈值会决定内存分段是否被回收，<code>-XX:G1MixedGCLiveThresholdPercent</code>，默认为65%，意思是垃圾占内存分段比例要达到65%才会被回收。如果垃圾占比太低，意味着存活的对象占比高，在复制的时候会花费更多的时间。</p><p>混合回收并不一定要进行8次。有一个阈值<code>-XX:G1HeapWastePercent</code>，默认值为10%，意思是允许整个堆内存中有10%的空间被浪费，意味着如果发现可以回收的垃圾占堆内存的比例低于10%，则不再进行混合回收。因为GC会花费很多的时间但是回收到的内存却很少。</p><h3 id="10-4-G1回收可选的过程四：Full-GC"><a href="#10-4-G1回收可选的过程四：Full-GC" class="headerlink" title="10.4 G1回收可选的过程四：Full GC"></a>10.4 G1回收可选的过程四：Full GC</h3><p>G1的初衷就是要避免Full GC的出现。但是如果上述方式不能正常工作，G1会停止应用程序的执行（Stop-The-World），使用单线程的内存回收算法进行垃圾回收，性能会非常差，应用程序停顿时间会很长。</p><p>要避免Full GC的发生，一旦发生需要进行调整。什么时候会发生Full GC呢？比如堆内存太小，当G1在复制存活对象的时候没有空的内存分段可用，则会回退到Full GC，这种情况可以通过增大内存解决。</p><p>导致G1 Full GC的原因可能有两个：</p><ul><li><p>Evacuation的时候没有足够的to-space来存放晋升的对象；</p></li><li><p>并发处理过程完成之前空间耗尽。</p></li></ul><h2 id="10-5-补充"><a href="#10-5-补充" class="headerlink" title="10.5 补充"></a>10.5 补充</h2><p>从Oracle官方透露出来的信息可获知，回收阶段（Evacuation）其实本也有想过设计成与用户程序一起并发执行，但这件事情做起来比较复杂，考虑到G1只是回一部分Region，停顿时间是用户可控制的，所以并不迫切去实现，而选择把这个特性放到了G1之后出现的低延迟垃圾收集器（即ZGC）中。另外，还考虑到G1不是仅仅面向低延迟，停顿用户线程能够最大幅度提高垃圾收集效率，为了保证吞吐量所以才选择了完全暂停用户线程的实现方案。</p><h2 id="10-6-G1回收器优化建议"><a href="#10-6-G1回收器优化建议" class="headerlink" title="10.6 G1回收器优化建议"></a>10.6 G1回收器优化建议</h2><ul><li><p>年轻代</p><ul><li><p>避免使用<code>-Xmn</code>或<code>-XX:NewRatio</code>等相关选项显式设置年轻代大小</p></li><li><p>固定年轻代的大小会覆盖暂停时间目标</p></li></ul></li><li><p>暂停时间目标不要太过严苛</p><ul><li><p>G1 GC的吞吐量目标是90%的应用程序时间和10%的垃圾回收时间</p></li><li><p>评估G1 GC的吞吐量时，暂停时间目标不要太严苛。目标太过严苛表示你愿意承受更多的垃圾回收开销，而这些会直接影响到吞吐量。</p></li></ul></li></ul><h1 id="八、垃圾回收器总结"><a href="#八、垃圾回收器总结" class="headerlink" title="八、垃圾回收器总结"></a>八、垃圾回收器总结</h1><h2 id="1-7种经典垃圾回收器总结"><a href="#1-7种经典垃圾回收器总结" class="headerlink" title="1. 7种经典垃圾回收器总结"></a>1. 7种经典垃圾回收器总结</h2><p>截止JDK1.8，一共有7款不同的垃圾收集器。每一款的垃圾收集器都有不同的特点，在具体使用的时候，需要根据具体的情况选用不同的垃圾收集器。</p><table><thead><tr><th>垃圾收集器</th><th>分类</th><th>作用位置</th><th>使用算法</th><th>特点</th><th>适用场景</th></tr></thead><tbody><tr><td>Serial</td><td>串行运行</td><td>作用于新生代</td><td>复制算法</td><td>响应速度优先</td><td>适用于单CPU环境下的client模式</td></tr><tr><td>ParNew</td><td>并行运行</td><td>作用于新生代</td><td>复制算法</td><td>响应速度优先</td><td>多CPU环境Server模式下与CMS配合使用</td></tr><tr><td>Parallel</td><td>并行运行</td><td>作用于新生代</td><td>复制算法</td><td>吞吐量优先</td><td>适用于后台运算而不需要太多交互的场景</td></tr><tr><td>Serial Old</td><td>串行运行</td><td>作用于老年代</td><td>标记-压缩算法</td><td>响应速度优先</td><td>适用于单CPU环境下的Client模式</td></tr><tr><td>Parallel Old</td><td>并行运行</td><td>作用于老年代</td><td>标记-压缩算法</td><td>吞吐量优先</td><td>适用于后台运算而不需要太多交互的场景</td></tr><tr><td>CMS</td><td>并发运行</td><td>作用于老年代</td><td>标记-清除算法</td><td>响应速度优先</td><td>适用于互联网或B／S业务</td></tr><tr><td>G1</td><td>并发、并行运行</td><td>作用于新生代、老年代</td><td>标记-压缩算法、复制算法</td><td>响应速度优先</td><td>面向服务端应用</td></tr></tbody></table><p>GC发展阶段：Serial &#x3D;&gt; Parallel（并行）&#x3D;&gt; CMS（并发）&#x3D;&gt; G1 &#x3D;&gt; ZGC</p><h2 id="2-垃圾回收器组合"><a href="#2-垃圾回收器组合" class="headerlink" title="2. 垃圾回收器组合"></a>2. 垃圾回收器组合</h2><p>不同厂商、不同版本的虚拟机实现差距比较大。HotSpot虚拟机在JDK7&#x2F;8后所有收集器及组合如下图</p><p><img src="https://raw.githubusercontent.com/GeorgeChan95/blogimg/master/img/2024/07/12/20240712-181450.png" alt="垃圾回收器组合"></p><ul><li>两个收集器间有连线，表明它们可以搭配使用：Serial&#x2F;Serial Old、Serial&#x2F;CMS、ParNew&#x2F;Serial Old、ParNew&#x2F;CMS、Parallel Scavenge&#x2F;Serial Old、Parallel Scavenge&#x2F;Parallel Old、G1; </li><li>其中Serial Old作为CMS出现＂<code>Concurrent Mode Failure</code>＂失败的后备预案。 </li><li>（红色虚线）由于维护和兼容性测试的成本，在JDK 8时将Serial＋CMS、ParNew＋Serial old这两个组合声明为Deprecated（JEP 173），并在JDK 9中完全取消了这些组合的支持（JEP214），即：移除。</li><li>（绿色虚线）JDK 14中：弃用ParallelScavenge和SeriaOold GC组合(JEP 366) </li><li>（绿色虚框）JDK 14中：删除CMS垃圾回收器（JEP 363）</li></ul><h2 id="3-怎么选择垃圾回收器"><a href="#3-怎么选择垃圾回收器" class="headerlink" title="3. 怎么选择垃圾回收器"></a>3. 怎么选择垃圾回收器</h2><p>Java垃圾收集器的配置对于JVM优化来说是一个很重要的选择，选择合适的垃圾收集器可以让JVM的性能有一个很大的提升。</p><p>怎么选择垃圾收集器？</p><ul><li>优先调整堆的大小让JVM自适应完成。 </li><li>如果内存小于100M，使用串行收集器 </li><li>如果是单核、单机程序，并且没有停顿时间的要求，串行收集器 </li><li>如果是多CPU、需要高吞吐量、允许停顿时间超过1秒，选择并行或者JVM自己选择 </li><li>如果是多CPU、追求低停顿时间，需快速响应（比如延迟不能超过1秒，如互联网应用），使用并发收集器<br>官方推荐G1，性能高。现在互联网的项目，基本都是使用G1。</li></ul><p>最后需要明确一个观点：</p><ul><li>没有最好的收集器，更没有万能的收集</li><li>调优永远是针对特定场景、特定需求，不存在一劳永逸的收集器</li></ul>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;一、GC分类与性能指标&quot;&gt;&lt;a href=&quot;#一、GC分类与性能指标&quot; class=&quot;headerlink&quot; title=&quot;一、GC分类与性能指标&quot;&gt;&lt;/a&gt;一、GC分类与性能指标&lt;/h1&gt;&lt;h2 id=&quot;1-垃圾回收器概述&quot;&gt;&lt;a href=&quot;#1-垃圾回收器概</summary>
      
    
    
    
    <category term="JVM" scheme="https://georgechan95.github.io/categories/JVM/"/>
    
    
    <category term="jvm" scheme="https://georgechan95.github.io/tags/jvm/"/>
    
    <category term="java" scheme="https://georgechan95.github.io/tags/java/"/>
    
  </entry>
  
  <entry>
    <title>合并两个有序链表</title>
    <link href="https://georgechan95.github.io/2024/07/06/algorithm/%E5%90%88%E5%B9%B6%E4%B8%A4%E4%B8%AA%E6%9C%89%E5%BA%8F%E9%93%BE%E8%A1%A8/"/>
    <id>https://georgechan95.github.io/2024/07/06/algorithm/%E5%90%88%E5%B9%B6%E4%B8%A4%E4%B8%AA%E6%9C%89%E5%BA%8F%E9%93%BE%E8%A1%A8/</id>
    <published>2024-07-06T01:11:00.000Z</published>
    <updated>2024-07-06T06:05:05.982Z</updated>
    
    <content type="html"><![CDATA[<h1 id="1-题目描述"><a href="#1-题目描述" class="headerlink" title="1. 题目描述"></a>1. 题目描述</h1><p>将两个升序链表合并为一个新的 <strong>升序</strong> 链表并返回。新链表是通过拼接给定的两个链表的所有节点组成的。 </p><p><strong>示例 1：</strong></p><p><img src="https://raw.githubusercontent.com/GeorgeChan95/blogimg/master/img/2024/07/06/20240706-125245.jpg" alt="img"></p><blockquote><p><strong>输入：</strong>l1 &#x3D; [1,2,4], l2 &#x3D; [1,3,4]<br><strong>输出：</strong>[1,1,2,3,4,4]</p></blockquote><p><strong>示例 2：</strong></p><blockquote><p><strong>输入：</strong>l1 &#x3D; [], l2 &#x3D; []<br><strong>输出：</strong>[]</p></blockquote><p><strong>示例 3：</strong></p><blockquote><p><strong>输入：</strong>l1 &#x3D; [], l2 &#x3D; [0]<br><strong>输出：</strong>[0]</p></blockquote><h1 id="2-解决思路"><a href="#2-解决思路" class="headerlink" title="2. 解决思路"></a>2. 解决思路</h1><p>可以使用迭代方法来实现有序链表的合并.</p><p>假设有两个有序链表 list1和list2, 当这两个链表都不是空链表时,选择头节点中较小的一个作为合并链表的头节点,.</p><p>移动有序链表的指针,比较list1和list2最新的头节点, 添加到合并链表中.</p><h1 id="3-关键代码"><a href="#3-关键代码" class="headerlink" title="3. 关键代码"></a>3. 关键代码</h1><pre><code class="highlight java"><span class="comment">/**</span><span class="comment"> * 合并两个有序列表</span><span class="comment"> *</span><span class="comment"> * <span class="doctag">@param</span> list1 有序链表1, 顺序: 由小到大</span><span class="comment"> * <span class="doctag">@param</span> list2 有序链表2, 顺序: 由小到大</span><span class="comment"> * <span class="doctag">@return</span> ListNode 合并后的有序链表</span><span class="comment"> */</span><span class="keyword">public</span> <span class="keyword">static</span> ListNode <span class="title function_">merge</span><span class="params">(ListNode list1, ListNode list2)</span> &#123;    <span class="comment">// 极值判断</span>    <span class="keyword">if</span> (list1 == <span class="literal">null</span> || list2 == <span class="literal">null</span>) &#123;        <span class="keyword">return</span> list1 == <span class="literal">null</span> ? list2 : list1;    &#125;    <span class="type">ListNode</span> <span class="variable">cur1</span> <span class="operator">=</span> list1; <span class="comment">// list1中当前正在比较的头节点</span>    <span class="type">ListNode</span> <span class="variable">cur2</span> <span class="operator">=</span> list2; <span class="comment">// list2中当前正在比较的头节点</span>    <span class="type">ListNode</span> <span class="variable">head</span> <span class="operator">=</span> <span class="literal">null</span>; <span class="comment">// 已完成合并操作的链表(默认头节点是两个有序链表头节点中较小的一个)</span>    <span class="keyword">if</span> (cur1.val &lt;= cur2.val) &#123;        head = cur1;        cur1 = cur1.next; <span class="comment">// 更新cur1的头节点</span>    &#125; <span class="keyword">else</span> &#123;        head = cur2;        cur2 = cur2.next; <span class="comment">// 更新cur2的头节点</span>    &#125;    <span class="type">ListNode</span> <span class="variable">pre</span> <span class="operator">=</span> head; <span class="comment">// 临时节点,开始指向head, 后面通过pre不断调整head节点的next属性的引用</span>    <span class="keyword">while</span> (cur1 != <span class="literal">null</span> &amp;&amp; cur2 != <span class="literal">null</span>) &#123; <span class="comment">// 仅当两个队列当前操作的节点都不为空时,才需要进行比较与合并操作</span>        <span class="keyword">if</span> (cur1.val &lt;= cur2.val) &#123;            pre.next = cur1; <span class="comment">// 当cur1的值小于cur2时,next指向cur1</span>            cur1 = cur1.next; <span class="comment">// cur1节点后移,继续后面节点的比较</span>        &#125; <span class="keyword">else</span> &#123;            pre.next = cur2; <span class="comment">// 当cur2的值小于cur1时,将cur2作为待合并的节点</span>            cur2 = cur2.next; <span class="comment">// cur2节点后移,继续后面节点的比较</span>        &#125;        <span class="comment">// 这一行同时也不断调整了head节点的next属性,扩充了head链表</span>        pre = pre.next; <span class="comment">// 链表指针后移</span>    &#125;    <span class="comment">// 当其中一个链表(假设是cur1)的最后一个节点完成了合并操作,而另一个链表(假设是cur2)还有剩余节点未合并,</span>    <span class="comment">// 此时就需要将最后完成合并的节点(pre节点)的next指向还有节点未合并的链表(不为空的链表).</span>    <span class="comment">// 这一步是必须存在的,因为两个有序链表合并,必然会存在其中一个节点先完成合并.</span>    pre.next = cur1 != <span class="literal">null</span> ? cur1 : cur2;    <span class="comment">// 返回合并后,完整的有序链表</span>    <span class="keyword">return</span> head;&#125;</code></pre><p>完整测试代码:</p><p><a href="https://github.com/GeorgeChan95/algorithm/blob/master/src/main/java/com/george/mergeTwoList/MergeTwoList.java">https://github.com/GeorgeChan95/algorithm/blob/master/src/main/java/com/george/mergeTwoList/MergeTwoList.java</a></p><h1 id="4-复杂度分析"><a href="#4-复杂度分析" class="headerlink" title="4. 复杂度分析"></a>4. 复杂度分析</h1><ul><li><p>时间复杂度：O(n+m)，其中 n 和 m 分别为两个链表的长度。因为每次循环迭代中，l1 和 l2 只有一个元素会被放进合并链表中， 因此 while 循环的次数不会超过两个链表的长度之和。所有其他操作的时间复杂度都是常数级别的，因此总的时间复杂度为 O(n+m)。</p></li><li><p>空间复杂度：O(1)。我们只需要常数的空间存放若干变量。</p></li></ul>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;1-题目描述&quot;&gt;&lt;a href=&quot;#1-题目描述&quot; class=&quot;headerlink&quot; title=&quot;1. 题目描述&quot;&gt;&lt;/a&gt;1. 题目描述&lt;/h1&gt;&lt;p&gt;将两个升序链表合并为一个新的 &lt;strong&gt;升序&lt;/strong&gt; 链表并返回。新链表是通过拼接给定的</summary>
      
    
    
    
    <category term="算法" scheme="https://georgechan95.github.io/categories/%E7%AE%97%E6%B3%95/"/>
    
    
    <category term="算法" scheme="https://georgechan95.github.io/tags/%E7%AE%97%E6%B3%95/"/>
    
    <category term="合并有序链表" scheme="https://georgechan95.github.io/tags/%E5%90%88%E5%B9%B6%E6%9C%89%E5%BA%8F%E9%93%BE%E8%A1%A8/"/>
    
  </entry>
  
  <entry>
    <title>链表反转</title>
    <link href="https://georgechan95.github.io/2024/07/05/algorithm/%E9%93%BE%E8%A1%A8%E5%8F%8D%E8%BD%AC/"/>
    <id>https://georgechan95.github.io/2024/07/05/algorithm/%E9%93%BE%E8%A1%A8%E5%8F%8D%E8%BD%AC/</id>
    <published>2024-07-05T11:45:45.000Z</published>
    <updated>2024-07-05T12:00:12.790Z</updated>
    
    <content type="html"><![CDATA[<h1 id="1-单向链表反转"><a href="#1-单向链表反转" class="headerlink" title="1. 单向链表反转"></a>1. 单向链表反转</h1><h2 id="1-1-题目要求"><a href="#1-1-题目要求" class="headerlink" title="1.1 题目要求"></a>1.1 题目要求</h2><p>给你单链表的头节点 <code>head</code> ，请你反转链表，并返回反转后的链表。</p><p><strong>示例1:</strong></p><p><img src="https://raw.githubusercontent.com/GeorgeChan95/blogimg/master/img/2024/07/05/20240705-194718.jpg" alt="img"></p><blockquote><p><strong>输入：</strong>head &#x3D; [1,2,3,4,5]</p><p><strong>输出：</strong>[5,4,3,2,1]</p></blockquote><p><strong>示例2:</strong></p><p><img src="https://raw.githubusercontent.com/GeorgeChan95/blogimg/master/img/2024/07/05/20240705-195131.jpg" alt="img"></p><blockquote><p>输入：head &#x3D; [1,2]<br>输出：[2,1]</p></blockquote><p><strong>示例3:</strong></p><blockquote><p>输入：head &#x3D; []<br>输出：[]</p></blockquote><h2 id="1-2-思路分析"><a href="#1-2-思路分析" class="headerlink" title="1.2 思路分析"></a>1.2 思路分析</h2><p>假设链表为 1→2→3→∅，我们想要把它改成 ∅←1←2←3。</p><p>在遍历链表时，将当前节点的 next 指针改为指向前一个节点。由于节点没有引用其前一个节点，因此必须事先存储其前一个节点。在更改引用之前，还需要存储后一个节点。最后返回新的头引用。</p><h2 id="1-3-关键代码"><a href="#1-3-关键代码" class="headerlink" title="1.3 关键代码"></a>1.3 关键代码</h2><pre><code class="highlight java"><span class="comment">/**</span><span class="comment"> * 单向节点</span><span class="comment"> */</span><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">SinglyNode</span> &#123;    <span class="keyword">public</span> <span class="type">int</span> val;    <span class="comment">/**</span><span class="comment">     * 下一个节点</span><span class="comment">     */</span>    <span class="keyword">public</span> SinglyNode next;    <span class="keyword">public</span> <span class="title function_">SinglyNode</span><span class="params">(<span class="type">int</span> val)</span> &#123;        <span class="built_in">this</span>.val = val;    &#125;    <span class="keyword">public</span> <span class="title function_">SinglyNode</span><span class="params">(<span class="type">int</span> val, SinglyNode next)</span> &#123;        <span class="built_in">this</span>.val = val;        <span class="built_in">this</span>.next = next;    &#125;&#125;<span class="comment">/**</span><span class="comment"> * 单向链表反转</span><span class="comment"> * <span class="doctag">@param</span> head 头节点</span><span class="comment"> * <span class="doctag">@return</span></span><span class="comment"> */</span><span class="keyword">public</span> <span class="keyword">static</span> SinglyNode <span class="title function_">reverseSinglyList</span><span class="params">(SinglyNode head)</span> &#123;    <span class="type">SinglyNode</span> <span class="variable">pre</span> <span class="operator">=</span> <span class="literal">null</span>; <span class="comment">// 当前节点的前一个节点,默认是null</span>    <span class="type">SinglyNode</span> <span class="variable">next</span> <span class="operator">=</span> <span class="literal">null</span>; <span class="comment">// 当前节点的下一个节点,默认是null</span>    <span class="keyword">while</span> (head != <span class="literal">null</span>) &#123;        next = head.next; <span class="comment">// 获取当前节点的下一个节点</span>        head.next = pre; <span class="comment">// 当前节点的前一个节点变成当前的下一个节点(方向反转)</span>        pre = head; <span class="comment">// 当前节点赋值给pre,指针后移</span>        head = next; <span class="comment">// 指针移动到next节点,继续循环</span>    &#125;    <span class="keyword">return</span> pre; <span class="comment">// 最后头节点的引用</span>&#125;</code></pre><p>完整测试代码见: <a href="https://github.com/GeorgeChan95/algorithm/blob/master/src/main/java/com/george/reverseList/ReverseSingleList.java">https://github.com/GeorgeChan95/algorithm/blob/master/src/main/java/com/george/reverseList/ReverseSingleList.java</a></p><h1 id="2-双向链表反转"><a href="#2-双向链表反转" class="headerlink" title="2. 双向链表反转"></a>2. 双向链表反转</h1><h2 id="2-1-关键代码"><a href="#2-1-关键代码" class="headerlink" title="2.1 关键代码"></a>2.1 关键代码</h2><pre><code class="highlight java"><span class="comment">/**</span><span class="comment"> * 双向链表节点</span><span class="comment"> */</span><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">DoubleListNode</span> &#123;    <span class="keyword">public</span> <span class="type">int</span> value;    <span class="comment">/**</span><span class="comment">     * 前一个节点</span><span class="comment">     */</span>    <span class="keyword">public</span> DoubleListNode last;    <span class="comment">/**</span><span class="comment">     * 下一个节点</span><span class="comment">     */</span>    <span class="keyword">public</span> DoubleListNode next;    <span class="keyword">public</span> <span class="title function_">DoubleListNode</span><span class="params">(<span class="type">int</span> value)</span> &#123;        <span class="built_in">this</span>.value = value;    &#125;&#125;<span class="comment">/**</span><span class="comment"> * 双向链表反转</span><span class="comment"> * <span class="doctag">@param</span> head 头节点</span><span class="comment"> * <span class="doctag">@return</span></span><span class="comment"> */</span><span class="keyword">public</span> <span class="keyword">static</span> DoubleListNode <span class="title function_">reverseList</span><span class="params">(DoubleListNode head)</span> &#123;    <span class="type">DoubleListNode</span> <span class="variable">last</span> <span class="operator">=</span> <span class="literal">null</span>; <span class="comment">// 前一个节点</span>    <span class="type">DoubleListNode</span> <span class="variable">next</span> <span class="operator">=</span> <span class="literal">null</span>; <span class="comment">// 下一个节点</span>    <span class="keyword">while</span> (head != <span class="literal">null</span>) &#123;        next = head.next; <span class="comment">// 获取当前节点的下一个节点</span>        head.next = last; <span class="comment">// 前一个节点变成当前节点的下一个节点(链表方向反转)[原来头节点的last节点为空,反转后在链表末尾,next节点为空]</span>        head.last = next; <span class="comment">// 下一个节点变成当前节点的前一个节点(方向反转)[原链表末尾节next节点为空,反转后变成头节点,last节点为空]</span>        last = head; <span class="comment">// 当前节点变成前一个节点,指针后移</span>        head = next; <span class="comment">// 指针指向下一个节点,进入下一轮循环.</span>    &#125;    <span class="keyword">return</span> last; <span class="comment">// 返回反转后的头节点的引用</span>&#125;</code></pre>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;1-单向链表反转&quot;&gt;&lt;a href=&quot;#1-单向链表反转&quot; class=&quot;headerlink&quot; title=&quot;1. 单向链表反转&quot;&gt;&lt;/a&gt;1. 单向链表反转&lt;/h1&gt;&lt;h2 id=&quot;1-1-题目要求&quot;&gt;&lt;a href=&quot;#1-1-题目要求&quot; class=&quot;he</summary>
      
    
    
    
    <category term="算法" scheme="https://georgechan95.github.io/categories/%E7%AE%97%E6%B3%95/"/>
    
    
    <category term="算法" scheme="https://georgechan95.github.io/tags/%E7%AE%97%E6%B3%95/"/>
    
    <category term="链表" scheme="https://georgechan95.github.io/tags/%E9%93%BE%E8%A1%A8/"/>
    
  </entry>
  
  <entry>
    <title>选择-冒泡-插入排序</title>
    <link href="https://georgechan95.github.io/2024/07/03/algorithm/%E9%80%89%E6%8B%A9-%E5%86%92%E6%B3%A1-%E6%8F%92%E5%85%A5%E6%8E%92%E5%BA%8F/"/>
    <id>https://georgechan95.github.io/2024/07/03/algorithm/%E9%80%89%E6%8B%A9-%E5%86%92%E6%B3%A1-%E6%8F%92%E5%85%A5%E6%8E%92%E5%BA%8F/</id>
    <published>2024-07-03T03:02:16.000Z</published>
    <updated>2024-07-03T07:17:03.424Z</updated>
    
    <content type="html"><![CDATA[<h1 id="一-选择排序"><a href="#一-选择排序" class="headerlink" title="一. 选择排序"></a>一. 选择排序</h1><h2 id="1-算法步骤"><a href="#1-算法步骤" class="headerlink" title="1. 算法步骤"></a>1. 算法步骤</h2><ul><li>首先在未排序序列中找到最小（大）元素，存放到排序序列的起始位置。</li><li>再从剩余未排序元素中继续寻找最小（大）元素，然后放到已排序序列的末尾。</li><li>重复第二步，直到所有元素均排序完毕。</li></ul><h2 id="2-动图演示"><a href="#2-动图演示" class="headerlink" title="2. 动图演示"></a>2. 动图演示</h2><p><img src="https://www.runoob.com/wp-content/uploads/2019/03/selectionSort.gif" alt="选择排序"></p><h2 id="3-代码实现"><a href="#3-代码实现" class="headerlink" title="3. 代码实现"></a>3. 代码实现</h2><pre><code class="highlight java"><span class="comment">/**</span><span class="comment"> * 选择排序</span><span class="comment"> * <span class="doctag">@param</span> arr 无序数组</span><span class="comment"> */</span><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">selectSort</span><span class="params">(<span class="type">int</span>[] arr)</span> &#123;    <span class="keyword">if</span> (arr == <span class="literal">null</span> || arr.length &lt; <span class="number">2</span>) &#123; <span class="comment">// 极值判断</span>        <span class="keyword">return</span>;    &#125;    <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; arr.length; i++) &#123; <span class="comment">// 外层循环,每次循环找到一个最小值,并将它排序,数组中有多少元素,就需要循环排序多少次</span>        <span class="type">int</span> <span class="variable">minIndex</span> <span class="operator">=</span> i; <span class="comment">// 每一次循环中,先初始化一个最小值的位置索引,在后面的循环中再更新这个索引,直到找到最小值所在位置</span>        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> i+<span class="number">1</span>; j &lt; arr.length; j++) &#123; <span class="comment">// 内层循环目的是:找到数组元素中最小的值所在位置的索引.</span>            <span class="keyword">if</span> (arr[minIndex] &gt; arr[j]) &#123; <span class="comment">// 如果发现了比minIndex位置的值更小的值,就更新minIndex,这样就保证了minIndex始终是最小元素的索引</span>                minIndex = j;            &#125;        &#125;        <span class="comment">// 找到外层循环中最小的值后,交换i位置和minIndex位置的值,目的是将最小的值往前放,在下一轮循环中不再遍历它了</span>        swap(arr, minIndex, i);    &#125;&#125;</code></pre><h1 id="二-冒泡排序"><a href="#二-冒泡排序" class="headerlink" title="二. 冒泡排序"></a>二. 冒泡排序</h1><h2 id="1-算法步骤-1"><a href="#1-算法步骤-1" class="headerlink" title="1. 算法步骤"></a>1. 算法步骤</h2><ul><li>比较相邻的元素。如果第一个比第二个大，就交换他们两个。</li><li>对每一对相邻元素作同样的工作，从开始第一对到结尾的最后一对。这步做完后，最后的元素会是最大的数。</li><li>针对所有的元素重复以上的步骤，除了最后一个。</li><li>持续每次对越来越少的元素重复上面的步骤，直到没有任何一对数字需要比较。</li></ul><h2 id="2-动图演示-1"><a href="#2-动图演示-1" class="headerlink" title="2. 动图演示"></a>2. 动图演示</h2><p><img src="https://www.runoob.com/wp-content/uploads/2019/03/bubbleSort.gif" alt="冒泡排序"></p><h2 id="3-代码实现-1"><a href="#3-代码实现-1" class="headerlink" title="3. 代码实现"></a>3. 代码实现</h2><pre><code class="highlight java"><span class="comment">/**</span><span class="comment"> * 冒泡排序</span><span class="comment"> *</span><span class="comment"> * <span class="doctag">@param</span> arr</span><span class="comment"> */</span><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">bubbleSort</span><span class="params">(<span class="type">int</span>[] arr)</span> &#123;    <span class="keyword">if</span> (arr == <span class="literal">null</span> || arr.length &lt; <span class="number">2</span>) &#123; <span class="comment">// 极值判断,无需排序</span>        <span class="keyword">return</span>;    &#125;    <span class="comment">// 外层循环,从后往前遍历,目的是将数组按照从小到大的顺利排列</span>    <span class="comment">// 使用 i&gt;0 而不是 i&gt;=0,是因为这是从后往前遍历,当后面的元素全部已经排好序之后,最后一个元素无需再比较,它只能是最小的那个.</span>    <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> arr.length - <span class="number">1</span>; i &gt; <span class="number">0</span>; i--) &#123;        <span class="comment">// 内存循环逐个比较当前元素与后一个元素的大小,如果当前元素大于后一个元素,则交换位置</span>        <span class="comment">// i是数组的元素的个数,使用 j&lt;i,而不是j&lt;=i是因为要把j与j后面的元素比较大小和交换位置,无需遍历到最后一个元素.</span>        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> <span class="number">0</span>; j &lt; i; j++) &#123;            <span class="comment">// 如果j大j+1的值,则将j与j+1位置交换</span>            <span class="comment">// 在交换位置后,有开始下一轮for循环,再往后比较和交换每一个值,重复下去,直到找到最大的值放到数组右边</span>            <span class="keyword">if</span> (arr[j] &gt; arr[j + <span class="number">1</span>]) &#123;                swap(arr, j, j + <span class="number">1</span>);            &#125;        &#125;    &#125;&#125;</code></pre><h1 id="三-插入排序"><a href="#三-插入排序" class="headerlink" title="三. 插入排序"></a>三. 插入排序</h1><h2 id="1-算法步骤-2"><a href="#1-算法步骤-2" class="headerlink" title="1. 算法步骤"></a>1. 算法步骤</h2><ul><li>将数组中的第一个元素看做一个有序序列，把第二个元素到最后一个元素当成是未排序序列。</li><li>从头到尾依次扫描未排序序列，将扫描到的每个元素插入有序序列的适当位置。（如果待插入的元素与有序序列中的某个元素相等，则将待插入元素插入到相等元素的后面。）</li></ul><h2 id="2-动图演示-2"><a href="#2-动图演示-2" class="headerlink" title="2. 动图演示"></a>2. 动图演示</h2><p><img src="https://www.runoob.com/wp-content/uploads/2019/03/insertionSort.gif" alt="插入排序"></p><h2 id="3-代码实现-2"><a href="#3-代码实现-2" class="headerlink" title="3. 代码实现"></a>3. 代码实现</h2><pre><code class="highlight java"><span class="comment">/**</span><span class="comment"> * 插入排序</span><span class="comment"> *</span><span class="comment"> * <span class="doctag">@param</span> arr</span><span class="comment"> */</span><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">insertSort</span><span class="params">(<span class="type">int</span>[] arr)</span> &#123;    <span class="keyword">if</span> (arr == <span class="literal">null</span> || arr.length &lt; <span class="number">2</span>) &#123; <span class="comment">// 极值判断</span>        <span class="keyword">return</span>;    &#125;    <span class="comment">// 将arr数组的第0个元素看作是一个有序数组(就一个元素肯定有序),第1个元素到第arr.length-1个元素看作是无序数组,</span>    <span class="comment">// 外层循环就是遍历这个无序数组,将它们逐个向有序数组中插入.</span>    <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">1</span>; i &lt; arr.length; i++) &#123;        <span class="comment">// arr数组中i-1位置到0位置是有序的,i位置(也就是j+1)就是本轮内层循环要比较插入的数</span>        <span class="comment">// 内层循环从后向前(从大到小)遍历有序数组的每一个元素与j+1的数进行比较,如果j+1的数小,就往前插</span>        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> i - <span class="number">1</span>; j &gt;= <span class="number">0</span> &amp;&amp; arr[j] &gt; arr[j + <span class="number">1</span>]; j--) &#123;            swap(arr, j, j + <span class="number">1</span>);        &#125;    &#125;&#125;</code></pre><p>完整测试代码: <a href="https://github.com/GeorgeChan95/algorithm/blob/master/src/main/java/com/george/baseSort/SelectBubbleInsert.java">https://github.com/GeorgeChan95/algorithm/blob/master/src/main/java/com/george/baseSort/SelectBubbleInsert.java</a></p><blockquote><p><strong>参考链接</strong></p></blockquote><p>[菜鸟教程]: <a href="https://www.runoob.com/w3cnote/insertion-sort.html">https://www.runoob.com/w3cnote/insertion-sort.html</a>“插入排序”<br>[菜鸟教程]: <a href="https://www.runoob.com/w3cnote/bubble-sort.html">https://www.runoob.com/w3cnote/bubble-sort.html</a>“冒泡排序”<br>[菜鸟教程]: <a href="https://www.runoob.com/w3cnote/selection-sort.html">https://www.runoob.com/w3cnote/selection-sort.html</a>“选择排序”</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;一-选择排序&quot;&gt;&lt;a href=&quot;#一-选择排序&quot; class=&quot;headerlink&quot; title=&quot;一. 选择排序&quot;&gt;&lt;/a&gt;一. 选择排序&lt;/h1&gt;&lt;h2 id=&quot;1-算法步骤&quot;&gt;&lt;a href=&quot;#1-算法步骤&quot; class=&quot;headerlink&quot; ti</summary>
      
    
    
    
    <category term="算法" scheme="https://georgechan95.github.io/categories/%E7%AE%97%E6%B3%95/"/>
    
    
    <category term="算法" scheme="https://georgechan95.github.io/tags/%E7%AE%97%E6%B3%95/"/>
    
    <category term="选择排序" scheme="https://georgechan95.github.io/tags/%E9%80%89%E6%8B%A9%E6%8E%92%E5%BA%8F/"/>
    
    <category term="冒泡排序" scheme="https://georgechan95.github.io/tags/%E5%86%92%E6%B3%A1%E6%8E%92%E5%BA%8F/"/>
    
    <category term="插入排序" scheme="https://georgechan95.github.io/tags/%E6%8F%92%E5%85%A5%E6%8E%92%E5%BA%8F/"/>
    
  </entry>
  
  <entry>
    <title>二分搜索</title>
    <link href="https://georgechan95.github.io/2024/06/29/algorithm/%E4%BA%8C%E5%88%86%E6%90%9C%E7%B4%A2/"/>
    <id>https://georgechan95.github.io/2024/06/29/algorithm/%E4%BA%8C%E5%88%86%E6%90%9C%E7%B4%A2/</id>
    <published>2024-06-29T02:04:10.000Z</published>
    <updated>2024-07-03T03:00:38.633Z</updated>
    
    <content type="html"><![CDATA[<h1 id="1-二分搜索的概念"><a href="#1-二分搜索的概念" class="headerlink" title="1. 二分搜索的概念"></a>1. 二分搜索的概念</h1><ul><li><p>二分查找是一种在有序数组中查找某一特定元素的搜索算法。</p></li><li><p>二分查找的原理是，将目标元素和查找范围的中间值做比较，如果目标元素等于中间值，则查找结束；如果目标元素大于或小于中间元素，则在数组大于或小于中间元素的那一半中查找，而且跟开始一样从中间元素开始比较。这样每一次比较都使搜索范围缩小一半。</p></li></ul><h1 id="2-在有序数组中查找-num-是否存在"><a href="#2-在有序数组中查找-num-是否存在" class="headerlink" title="2. 在有序数组中查找 num 是否存在"></a>2. 在有序数组中查找 num 是否存在</h1><ul><li><p>需求</p><p>给定一个有序数组 <code>arr</code> , 给定一个目标值 <code>target</code> , 查找 <code>target</code> 在 <code>arr</code> 中是否存在.</p></li><li><p>思路</p><p>对于有序数组中的数值查找, 首先想到使用二分法实现.</p></li><li><p>关键代码</p><pre><code class="highlight java"><span class="comment">/**</span><span class="comment"> * 查找target在arr中是否存在</span><span class="comment"> *</span><span class="comment"> * <span class="doctag">@param</span> arr    有序数组</span><span class="comment"> * <span class="doctag">@param</span> target 目标值</span><span class="comment"> * <span class="doctag">@return</span> true:表示target在arr中存在, false表示不存在</span><span class="comment"> */</span><span class="keyword">public</span> <span class="keyword">static</span> <span class="type">boolean</span> <span class="title function_">exist</span><span class="params">(<span class="type">int</span>[] arr, <span class="type">int</span> target)</span> &#123;    <span class="keyword">if</span> (arr == <span class="literal">null</span> || arr.length == <span class="number">0</span>) &#123; <span class="comment">// 当数组为空时,无需查找,返回false.</span>        <span class="keyword">return</span> <span class="literal">false</span>;    &#125;    <span class="type">int</span> <span class="variable">L</span> <span class="operator">=</span> <span class="number">0</span>; <span class="comment">// 查找范围区间左侧的元素的下标,从0开始</span>    <span class="type">int</span> <span class="variable">R</span> <span class="operator">=</span> arr.length - <span class="number">1</span>; <span class="comment">// 查找范围区间右侧元素的下标,从arr的末尾开始</span>    <span class="type">int</span> <span class="variable">M</span> <span class="operator">=</span> <span class="number">0</span>; <span class="comment">// 中间元素的位置,默认是0</span>    <span class="comment">// &lt;= 表示这是一个 [左闭,右闭] 的区间范围.</span>    <span class="comment">// 不使用 &lt; 是考虑到在查找的过程中会动态调整L和R的值,有可能出现 L和R 重合的情况,即区间范围只有一个值的情况.</span>    <span class="keyword">while</span> (L &lt;= R) &#123;        M = (L + R) / <span class="number">2</span>; <span class="comment">// 获取查询区间的中点</span>        <span class="comment">// 下面这种方式计算结果与上面相同,但是可以避免 L + R 溢出的问题</span>        <span class="comment">// M = L + ((R-L)&gt;&gt;1);</span>        <span class="keyword">if</span> (arr[M] == target) &#123; <span class="comment">// 中点的值正好等于target,找找到了该元素,返回true.</span>            <span class="keyword">return</span> <span class="literal">true</span>;        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (arr[M] &lt; target) &#123; <span class="comment">// 目标值大于中点的值,则从中点+1的位置往右查找</span>            L = M + <span class="number">1</span>;        &#125; <span class="keyword">else</span> &#123; <span class="comment">// 目标值小于中点的值,则从中点-1的位置往左查找</span>            R = M - <span class="number">1</span>;        &#125;    &#125;    <span class="comment">// 如果while循环没有找到target,则返回false;</span>    <span class="keyword">return</span> <span class="literal">false</span>;&#125;</code></pre></li><li><p>完整测试代码</p><p><a href="https://github.com/GeorgeChan95/algorithm/blob/master/src/main/java/com/george/binarySearch/FindNumber.java">https://github.com/GeorgeChan95/algorithm/blob/master/src/main/java/com/george/binarySearch/FindNumber.java</a></p></li></ul><h1 id="3-在有序数组中查找-num-的最左位置"><a href="#3-在有序数组中查找-num-的最左位置" class="headerlink" title="3. 在有序数组中查找 &gt;&#x3D;num 的最左位置"></a>3. 在有序数组中查找 &gt;&#x3D;num 的最左位置</h1><ul><li><p>需求</p><p>给定一个从小到大的有序数组 arr, 给定一个目标值 target, 查找在这个数组中 &gt;&#x3D;target的 最左侧的元素的下标值.</p></li><li><p>实现思路</p><ul><li>有序数组中的操作,首先考虑二分查找.找到数组中间位置的数据,比较中间值是否大于等于目标值, 如果是则表明目标值一定在中间元素的左边.此时就需要向左查找.</li><li>如果中间值小于目标值,则表明目标值在中间值的右边,此时就需要往右查找.</li></ul></li><li><p>关键代码</p><pre><code class="highlight java"><span class="comment">/**</span><span class="comment"> * 使用二分查找法,获取 &gt;=target 的最左边的数的下标</span><span class="comment"> *</span><span class="comment"> * <span class="doctag">@param</span> arr    目标数组, 例如: [1,2,3,4,5,6,7,8,9]</span><span class="comment"> * <span class="doctag">@param</span> target 目标值, 例如: 2</span><span class="comment"> * <span class="doctag">@return</span></span><span class="comment"> */</span><span class="keyword">public</span> <span class="keyword">static</span> <span class="type">int</span> <span class="title function_">findLeft</span><span class="params">(<span class="type">int</span>[] arr, <span class="type">int</span> target)</span> &#123;    <span class="type">int</span> <span class="variable">L</span> <span class="operator">=</span> <span class="number">0</span>; <span class="comment">// 查找范围区间左侧的元素的下标,从0开始</span>    <span class="type">int</span> <span class="variable">R</span> <span class="operator">=</span> arr.length - <span class="number">1</span>; <span class="comment">// 查找范围区间右侧元素的下标,从arr的末尾开始</span>    <span class="type">int</span> <span class="variable">M</span> <span class="operator">=</span> <span class="number">0</span>; <span class="comment">// 中间元素的位置,默认是0</span>    <span class="type">int</span> <span class="variable">ans</span> <span class="operator">=</span> -<span class="number">1</span>; <span class="comment">// 查找到的目标值的下标,没有找到则返回-1</span>    <span class="keyword">if</span> (arr == <span class="literal">null</span> || arr.length == <span class="number">0</span>) &#123; <span class="comment">// 当数组为空时,无需查找,返回 -1.</span>        <span class="keyword">return</span> ans;    &#125;    <span class="keyword">while</span> (L &lt;= R) &#123; <span class="comment">// 确保查找范围区间元素数量 &gt;=1 个</span>        M = (L + R) / <span class="number">2</span>; <span class="comment">// 获取查询区间的中点</span>        <span class="comment">// 下面这种方式计算结果与上面相同,但是可以避免 L + R 溢出的问题</span>        <span class="comment">// M = L + ((R-L)&gt;&gt;1);</span>        <span class="keyword">if</span> (arr[M] &gt;= target) &#123; <span class="comment">// 如果中点元素值 &gt;=target 说明中点往左可能还有别的数也 &gt;=target,此时记录下标值,继续向中点左侧找,直到找到最左边 &gt;=target 的值.</span>            R = M - <span class="number">1</span>; <span class="comment">// 区间往左搜小</span>            ans = M; <span class="comment">// 记录当前下标值</span>        &#125; <span class="keyword">else</span> &#123; <span class="comment">// 如果中点元素值 &lt;target, 说明目标元素在中点往右的位置,则需要向右查找</span>            L = M + <span class="number">1</span>;        &#125;    &#125;    <span class="comment">// &gt;=target最左边的数的下标</span>    <span class="keyword">return</span> ans;&#125;</code></pre></li><li><p>完整测试代码</p><p><a href="https://github.com/GeorgeChan95/algorithm/blob/master/src/main/java/com/george/binarySearch/FindLeft.java">https://github.com/GeorgeChan95/algorithm/blob/master/src/main/java/com/george/binarySearch/FindLeft.java</a></p></li></ul><h1 id="4-在有序数组中查找"><a href="#4-在有序数组中查找" class="headerlink" title="4. 在有序数组中查找 &lt;&#x3D;num 的最右位置"></a>4. 在有序数组中查找 &lt;&#x3D;num 的最右位置</h1><ul><li><p>需求</p><p>给定一个从小到大的有序数组 arr, 给定一个目标值 target, 查找在arr数组中 &lt;&#x3D;target 的最右侧(最大)的元素的下标值.</p></li><li><p>思路</p><ul><li>有序数组中的操作,首先考虑二分查找.找到数组中间位置的数据,比较中间值是否小于等于目标值, 如果是则表明目标值一定在中间元素的右边.此时就需要向右查找.</li><li>如果中间值大于目标值,则表明目标值在中间值的左边,此时就需要往左查找.</li></ul></li><li><p>关键代码</p><pre><code class="highlight java"><span class="comment">/**</span><span class="comment">  * 使用二分查找，数组arr中 &lt;=num 最右边的数的下标值</span><span class="comment">  *</span><span class="comment">  * <span class="doctag">@param</span> arr    从小到大的有序数组</span><span class="comment">  * <span class="doctag">@param</span> target 要查询的目标值</span><span class="comment">  * <span class="doctag">@return</span></span><span class="comment">  */</span><span class="keyword">public</span> <span class="keyword">static</span> <span class="type">int</span> <span class="title function_">findRight</span><span class="params">(<span class="type">int</span>[] arr, <span class="type">int</span> target)</span> &#123;    <span class="type">int</span> <span class="variable">L</span> <span class="operator">=</span> <span class="number">0</span>; <span class="comment">// 数组中查找的左侧区间范围，从0开始</span>    <span class="type">int</span> <span class="variable">R</span> <span class="operator">=</span> arr.length - <span class="number">1</span>; <span class="comment">// 数组中查找的右侧区间范围,从数组的末尾开始</span>    <span class="type">int</span> <span class="variable">M</span> <span class="operator">=</span> <span class="number">0</span>; <span class="comment">// 初始中间位置</span>    <span class="type">int</span> <span class="variable">ans</span> <span class="operator">=</span> -<span class="number">1</span>; <span class="comment">// 响应结果,-1表示没有找到该元素</span>    <span class="keyword">if</span> (arr == <span class="literal">null</span> || arr.length == <span class="number">0</span>) &#123; <span class="comment">// 数组为空,不再继续查找</span>        <span class="keyword">return</span> ans;    &#125;    <span class="keyword">while</span> (L &lt;= R) &#123; <span class="comment">// 确保查找范围区间元素数量 &gt;=1 个</span>        M = L + (R - L) / <span class="number">2</span>; <span class="comment">// 获取中间位置</span>        <span class="keyword">if</span> (arr[M] &lt;= target) &#123; <span class="comment">// 中间值与目标值进行比较,如果&lt;=target,则标记下当前位置,继续向右查找,如果 &gt;target则向左继续查找</span>            ans = M; <span class="comment">// 标记当前下标</span>            L = M + <span class="number">1</span>; <span class="comment">// 左侧查询区间移动到 M+1 位置,继续往右查找</span>        &#125; <span class="keyword">else</span> &#123;            R = M - <span class="number">1</span>; <span class="comment">// 右侧查询区间移动到 M-1 位置,继续往左查找</span>        &#125;    &#125;    <span class="comment">// 返回查询结果</span>    <span class="keyword">return</span> ans;&#125;</code></pre></li><li><p>完整测试代码</p><p><a href="https://github.com/GeorgeChan95/algorithm/blob/master/src/main/java/com/george/binarySearch/FindRight.java">https://github.com/GeorgeChan95/algorithm/blob/master/src/main/java/com/george/binarySearch/FindRight.java</a></p></li></ul><h1 id="5-无序数组使用二分法寻找峰值"><a href="#5-无序数组使用二分法寻找峰值" class="headerlink" title="5. 无序数组使用二分法寻找峰值"></a>5. 无序数组使用二分法寻找峰值</h1><ul><li><p><strong>题目描述</strong></p><ul><li><p>峰值元素是指其值严格大于左右相邻值的元素。</p></li><li><p>给你一个整数数组 <code>nums</code>，找到峰值元素并返回其索引。数组可能包含多个峰值，在这种情况下，返回 <strong>任何一个峰值</strong> 所在位置即可。</p></li><li><p>你可以假设 <code>nums[-1] = nums[n] = -∞</code> 。</p></li><li><p>你必须实现时间复杂度为 <code>O(log n)</code> 的算法来解决此问题。</p></li></ul></li><li><p><strong>示例 1：</strong></p><ul><li>输入：nums &#x3D; [1,2,3,1]</li><li>输出：2</li><li>解释：3 是峰值元素，你的函数应该返回其索引 2。</li></ul></li><li><p><strong>示例 2：</strong></p><ul><li>输入：nums &#x3D; [1,2,1,3,5,6,4]</li><li>输出：1 或 5 </li><li>解释：你的函数可以返回索引 1，其峰值元素为 2；<br> 或者返回索引 5， 其峰值元素为 6。</li></ul></li><li><p><strong>提示：</strong></p><ul><li>1 &lt;&#x3D; nums.length &lt;&#x3D; 1000 (数组长度在 1~1000范围内)</li><li>-2<sup>31</sup>  &lt;&#x3D; nums[i]  &lt;&#x3D; 2<sup>31-1</sup>  (数组元素值不超过int最大值)</li><li>对于所有有效的 i 都有 nums[i] !&#x3D; nums[i + 1] (数组中任意相邻的两个数不相等)</li></ul></li><li><p><strong>思路</strong></p><ul><li><p>虽然寻找峰值这样的题目,不是在有序数组中,但具体题目的要求,依然可以使用二分查找解决这个问题.</p></li><li><p>如果一个数组中存在峰值,那么从这个数组的第0个位置到最后一个位置所经过的数值,连成线一定是时高时低(想象着把数值连城折线图). </p></li><li><p>可以先从中间位置开始找峰值, 如果中间位置的数比左右两侧的数都要大,则找到峰值.</p></li><li><p>如果中间位置比左侧的数据小,则表示在左边一定至少存在一个峰值. 因为哪怕是最极端的情况, 从0位置到中间位置数据是逐个减小的,那么0位置就是峰值. 所以至少会有一个峰值. 按照这个思路继续使用二分法向左边查找峰值,直到找到一个峰值.</p></li><li><p>如果中间位置比右侧的数据小,则表示在右边至少存在一个峰值,理由和上一条相同.</p></li></ul></li><li><p><strong>关键代码</strong></p><pre><code class="highlight java"><span class="comment">/**</span><span class="comment">  * 使用二分查找,找到数组中的峰值</span><span class="comment">  * <span class="doctag">@param</span> arr 数组</span><span class="comment">  * <span class="doctag">@return</span></span><span class="comment">  */</span><span class="keyword">public</span> <span class="keyword">static</span> <span class="type">int</span> <span class="title function_">findPeak</span><span class="params">(<span class="type">int</span>[] arr)</span> &#123;    <span class="type">int</span> <span class="variable">n</span> <span class="operator">=</span> arr.length; <span class="comment">// 数组的长度</span>    <span class="keyword">if</span> (n == <span class="number">1</span>) &#123; <span class="comment">// 数组长度为1,那么这个元素就是峰值,因为: arr[-1] = arr[n] = 无穷小</span>        <span class="keyword">return</span> <span class="number">0</span>;    &#125;    <span class="keyword">if</span> (arr[<span class="number">0</span>] &gt; arr[<span class="number">1</span>]) &#123; <span class="comment">// 满足条件: arr[-1] = 无穷小</span>        <span class="keyword">return</span> <span class="number">0</span>;    &#125;    <span class="keyword">if</span> (arr[n - <span class="number">1</span>] &gt; arr[n - <span class="number">2</span>]) &#123; <span class="comment">// 满足条件: arr[n] = 无穷小</span>        <span class="keyword">return</span> n - <span class="number">1</span>;    &#125;    <span class="type">int</span> <span class="variable">L</span> <span class="operator">=</span> <span class="number">1</span>; <span class="comment">// 二分查找的左侧区间范围, 从 1 开始</span>    <span class="type">int</span> <span class="variable">R</span> <span class="operator">=</span> n - <span class="number">2</span>; <span class="comment">// 二分查找的右侧区间范围, 从 n-2 开始</span>    <span class="type">int</span> <span class="variable">M</span> <span class="operator">=</span> <span class="number">0</span>; <span class="comment">// 中间索引,默认:0</span>    <span class="type">int</span> <span class="variable">ans</span> <span class="operator">=</span> -<span class="number">1</span>; <span class="comment">// 峰值所在位置索引</span>    <span class="keyword">while</span> (L &lt;= R) &#123;        M = L + ((R - L) / <span class="number">2</span>); <span class="comment">// 计算中间值索引</span>        <span class="keyword">if</span> (arr[M + <span class="number">1</span>] &gt; arr[M]) &#123; <span class="comment">// M到n-1区域一定存在峰值,向右查找</span>            L = M + <span class="number">1</span>;        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (arr[M - <span class="number">1</span>] &gt; arr[M]) &#123; <span class="comment">// 0到M区域一定存在峰值,向左查找</span>            R = M - <span class="number">1</span>;        &#125; <span class="keyword">else</span> &#123;            ans = M; <span class="comment">// 找到峰值, 跳出循环</span>            <span class="keyword">break</span>;        &#125;    &#125;    <span class="keyword">return</span> ans;&#125;</code></pre></li><li><p>测试地址</p><p><a href="https://leetcode.cn/problems/find-peak-element/">https://leetcode.cn/problems/find-peak-element/</a></p></li></ul><h1 id="6-技巧"><a href="#6-技巧" class="headerlink" title="6. 技巧"></a>6. 技巧</h1><ul><li>二分查找需要根据左右两个查询区间找到中间位置的下标, 但是当查询范围特别大时,比如数组长度: 2<sup>31</sup> , 左右区间相加就会溢出,导致计算出错. 为了避免数值溢出, 不能使用 <code>(L+R)/2</code> 的方式计算中间值, 需要用 <code>L+(R-L)/2</code> 的方式.</li><li>L + ((R-L) &gt;&gt; 1) 也等同于 L+(R-L)&#x2F;2 , 样做是利用了位运算 &gt;&gt; 的特点, 右移1位, 就等于除以2</li></ul>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;1-二分搜索的概念&quot;&gt;&lt;a href=&quot;#1-二分搜索的概念&quot; class=&quot;headerlink&quot; title=&quot;1. 二分搜索的概念&quot;&gt;&lt;/a&gt;1. 二分搜索的概念&lt;/h1&gt;&lt;ul&gt;
&lt;li&gt;&lt;p&gt;二分查找是一种在有序数组中查找某一特定元素的搜索算法。&lt;/p&gt;</summary>
      
    
    
    
    <category term="算法" scheme="https://georgechan95.github.io/categories/%E7%AE%97%E6%B3%95/"/>
    
    
    <category term="算法" scheme="https://georgechan95.github.io/tags/%E7%AE%97%E6%B3%95/"/>
    
    <category term="二分法" scheme="https://georgechan95.github.io/tags/%E4%BA%8C%E5%88%86%E6%B3%95/"/>
    
  </entry>
  
  <entry>
    <title>二进制和位运算</title>
    <link href="https://georgechan95.github.io/2024/06/20/algorithm/%E4%BA%8C%E8%BF%9B%E5%88%B6%E5%92%8C%E4%BD%8D%E8%BF%90%E7%AE%97/"/>
    <id>https://georgechan95.github.io/2024/06/20/algorithm/%E4%BA%8C%E8%BF%9B%E5%88%B6%E5%92%8C%E4%BD%8D%E8%BF%90%E7%AE%97/</id>
    <published>2024-06-20T00:04:00.000Z</published>
    <updated>2024-06-29T01:23:57.157Z</updated>
    
    <content type="html"><![CDATA[<h1 id="一、二进制基础"><a href="#一、二进制基础" class="headerlink" title="一、二进制基础"></a>一、二进制基础</h1><h2 id="1、二进制与十进制的转换"><a href="#1、二进制与十进制的转换" class="headerlink" title="1、二进制与十进制的转换"></a>1、二进制与十进制的转换</h2><ul><li><p>举例：<code>0101</code> –&gt; <code>5</code></p><p>二进制[0101] 表示:  0 * 2<sup>3</sup> + 1 * 2<sup>2</sup> + 0 * 2<sup>1</sup> + 1 * 2<sup>0</sup> &#x3D; 5</p></li></ul><p>计算结果正好等于十进制数：5</p><p>上面的计算使用的是4位二进制数来表示的，<strong>4位二进制数可表示的10进制数有 2<sup>4</sup> &#x3D; 16 个，表示十进制数的范围是 0 ~ 2<sup>4</sup> -1 ，即：0 ~ 15 。</strong></p><h2 id="2、有符号数与无符号数"><a href="#2、有符号数与无符号数" class="headerlink" title="2、有符号数与无符号数"></a>2、有符号数与无符号数</h2><ul><li><p>无符号数</p><p>一个二进制数上的所有 0 和 1 都表示数字。</p></li><li><p>有符号数</p><p>二进制数上最左边的数字表示：<strong>符号位</strong></p><ul><li>0：表示该二进制为正数</li><li>1：表示该二进制为负数</li></ul></li></ul><p><strong>举例说明：</strong></p><p>比如一个4位长度的二进制数，它能表示的十进制数依然有 2<sup>4</sup> &#x3D; 16 个，表示的正数只有 2<sup>3</sup> 个，负数也是 2<sup>3</sup>,即：</p><ul><li><p>正数：0000 ~ 0111 </p><p>十进制表示：0 ~ 7</p></li><li><p>负数：1111 ~ 1000 【计算机中负数的表示，与正数不同】</p><p>十进制表示：-1 ~ -8</p></li></ul><h2 id="3、源码、反码与补码"><a href="#3、源码、反码与补码" class="headerlink" title="3、源码、反码与补码"></a>3、源码、反码与补码</h2><ul><li><p>应用范围：源码、补码、反码只能应用在整数中：正整数、负整数</p></li><li><p>在正整数中：源码 &#x3D;反码 &#x3D;补码</p></li><li><p>在负整数中：如果是负数，将源码的符号位不变，其余各位取反，得到反码。</p><ul><li>如果是负数，将反码加1，得到补码</li></ul></li><li><p>举例：int a &#x3D; 3 ;</p></li></ul><pre><code class="highlight java"><span class="type">int</span> <span class="variable">a</span> <span class="operator">=</span> <span class="number">3</span> ; <span class="comment">// int整型为4字节，32个bit位</span><span class="comment">//源码：00000000 00000000 00000000 00000011</span><span class="comment">//反码：00000000 00000000 00000000 00000011</span><span class="comment">//补码：00000000 00000000 00000000 00000011</span><span class="comment">//因为是正整数所以 源码=反码=补码</span></code></pre><ul><li>举例：int a &#x3D; -3 ;</li></ul><pre><code class="highlight java"><span class="type">int</span> <span class="variable">a</span> <span class="operator">=</span> -<span class="number">3</span> ; <span class="comment">// int 为整型4个字节32个bit位</span><span class="comment">//因为是负数，所以最高位是 1</span><span class="comment">//源码：10000000 00000000 00000000 00000011</span><span class="comment">//源码符号位不变，其余各个位按位取反，得到反码</span><span class="comment">//反码：11111111 11111111 11111111 11111100</span><span class="comment">//反码+1，得到补码</span><span class="comment">//补码：11111111 11111111 11111111 11111101</span></code></pre><ul><li>工具：<a href="https://www.lddgo.net/convert/number-binary-code">在线转换：源码、反码、补码</a></li></ul><h2 id="4、十进制负数如何转换成二进制数"><a href="#4、十进制负数如何转换成二进制数" class="headerlink" title="4、十进制负数如何转换成二进制数"></a>4、十进制负数如何转换成二进制数</h2><p>十进制负数转成二进制数的转换逻辑大致是，先将负数取正，转成二进制数，再减1，然后取反。下面举例说明转换过程：</p><ul><li><em>示例1，十进制数：<code>-1</code></em><ul><li>先将 <code>-1</code> 转成 正数 <code>1</code>，并得到正数 <code>1</code> 的二进制数 <code>0001</code> </li><li>再将二进制数 <code>0001</code> 减去 <code>1</code> ，得到二进制数 <code>0000</code></li><li>然后将二进制数 <code>0000</code> 取反，得到 二进制数 <code>1111</code></li><li>此时就得到了 -1 的 二进制表示：<code>1111</code></li></ul></li><li><em>示例2，十进制数：<code>-7</code></em><ul><li>先将 <code>-7</code> 转成 正数 <code>7</code>，并得到正数 <code>7</code> 的二进制数 <code>0111</code> </li><li>再将二进制数 <code>0111</code> 减去 <code>1</code> ，得到二进制数 <code>0110</code></li><li>然后将二进制数 <code>0110</code> 取反，得到 二进制数 <code>1001</code></li><li>此时就得到了 -7 的 二进制表示：<code>1001</code></li></ul></li><li><em>示例3，十进制数：<code>-8</code></em><ul><li>先将 <code>-8</code> 转成 正数 <code>8</code>，并得到正数 <code>8</code> 的二进制数 <code>1000</code> </li><li>再将二进制数 <code>1000</code> 减去 <code>1</code> ，得到二进制数 <code>0111</code></li><li>然后将二进制数 <code>0111</code> 取反，得到 二进制数 <code>1000</code></li><li>此时就得到了 -8 的 二进制表示：<code>1000</code></li></ul></li></ul><p><strong>注意：上面的方法得到的都是对应负数的二进制补码。</strong></p><h2 id="5、负数二进制数如何转成十进制数"><a href="#5、负数二进制数如何转成十进制数" class="headerlink" title="5、负数二进制数如何转成十进制数"></a>5、负数二进制数如何转成十进制数</h2><p>根据有符号数的定义：如果一个二进制数表示一个负数，那么在这个二进制数中，最左侧的数一定是1。确定符号位是否为负数，是后面进行转换的前提。</p><p>负数二进制数转十进制数 与 负数十进制数转二进制的过程正好相反，转换逻辑大致是，先将负数二进制数整体取反，然后再加1，得到十进制数的二进制表示，转成十进制数，再将10进制数取反，得到负的十进制数。</p><ul><li>示例1，二进制数：<code>1001</code><ul><li>首位是1，表示它是一个负数</li><li>先将二进制数 <code>1001</code> 整体取反得到 <code>0110</code></li><li>再将取反后的二进制数 <code>0110</code> + 1 得到二进制数 <code>0111</code> </li><li><code>0111</code> 表示十进制数 <code>7</code></li><li>再将十进制数 <code>7</code> 取反，得到负数 <code>-7</code></li><li>所以二进制数 <code>1001</code> 对应的十进制数为 <code>-7</code></li></ul></li><li>示例2，二进制数：<code>1000</code><ul><li>首位是1，表示它是一个负数</li><li>先将二进制数 <code>1000</code> 整体取反得到 <code>0111</code></li><li>再将取反后的二进制数 <code>0111</code> + 1 得到二进制数 <code>1000</code> </li><li><code>1000</code> 表示十进制数 <code>8</code></li><li>再将十进制数 <code>8</code> 取反，得到负数 <code>-8</code></li><li>所以二进制数 <code>1000</code> 对应的十进制数为 <code>-8</code></li></ul></li></ul><p><strong><code>1000</code> 在无符号二进制数中表示 <code>8</code>，在有符号二进制数中表示 <code>-8</code> 。</strong></p><p><strong>上面的方法，都是使用负数的补码进行运算的，<code>1001</code>、<code>1000</code> 都是补码</strong></p><h2 id="6、Java如何定义一个二进制数"><a href="#6、Java如何定义一个二进制数" class="headerlink" title="6、Java如何定义一个二进制数"></a>6、Java如何定义一个二进制数</h2><pre><code class="highlight java"><span class="type">int</span> <span class="variable">c</span> <span class="operator">=</span> <span class="number">0b0000101110</span>; <span class="comment">// 使用 0b 开头，后面是 0和1 定义一个二进制数</span>System.out.println(c);</code></pre><p>16进制数字定义使用 <code>0x</code> 开头，例如：0x4e</p><h2 id="7、二进制数转十六进制数"><a href="#7、二进制数转十六进制数" class="headerlink" title="7、二进制数转十六进制数"></a>7、二进制数转十六进制数</h2><ul><li><p>概念：</p><ul><li>二进制是由数字0和1组成，十六进制是由：[ 0、1、2、3、4、5、6、7、8、9、a、b、c、d、e、f ]  共16个数字和字母组成，逢十六进一。</li></ul></li><li><p>二进制数与十六进制数的对照关系</p><ul><li>二进制数 –&gt; 十六进制数</li></ul><table><thead><tr><th>二进制数</th><th>十六进制数</th></tr></thead><tbody><tr><td>0000</td><td>0</td></tr><tr><td>0001</td><td>1</td></tr><tr><td>0010</td><td>2</td></tr><tr><td>0011</td><td>3</td></tr><tr><td>0100</td><td>4</td></tr><tr><td>0101</td><td>5</td></tr><tr><td>0110</td><td>6</td></tr><tr><td>0111</td><td>7</td></tr><tr><td>1000</td><td>8</td></tr><tr><td>1001</td><td>9</td></tr><tr><td>1010</td><td>a</td></tr><tr><td>1011</td><td>b</td></tr><tr><td>1100</td><td>c</td></tr><tr><td>1101</td><td>d</td></tr><tr><td>1110</td><td>e</td></tr><tr><td>1111</td><td>f</td></tr></tbody></table></li></ul><p>由上表可以进下面具体的进制转换了，举例说明。</p><ul><li>二进制数：<code>0b01100111</code><ul><li><code>0b</code> 表示这是一个二进制数</li><li>前四位 <code>0110</code> 对应十六进制数 <code>6</code></li><li>后四位 <code>0111</code> 对应十六进制数 <code>7</code></li><li>所以这个二进制数对应十六进制数为 <code>0x67</code>， <code>0x</code> 表示这是一个十六进制数</li></ul></li><li>二进制数：<code>0b01101111</code><ul><li><code>0b</code> 表示这是一个二进制数</li><li>前四位 <code>0110</code> 对应十六进制数 <code>6</code></li><li>后四位 <code>1111</code> 对应十六进制数 <code>f</code></li><li>所以这个二进制数对应十六进制数为 <code>0x6f </code> , <code>0x</code> 表示这是一个十六进制数</li></ul></li></ul><h1 id="二、位运算基础"><a href="#二、位运算基础" class="headerlink" title="二、位运算基础"></a>二、位运算基础</h1><h2 id="1、相反数"><a href="#1、相反数" class="headerlink" title="1、相反数"></a>1、相反数</h2><ul><li>概念：相反数是一个数学术语，指绝对值相等，正负号相反的两个数互为相反数。</li><li>举例：1 的相反数是 -1，78 的相反数是 -78</li></ul><h3 id="1-1、如何得到一个数的相反数？"><a href="#1-1、如何得到一个数的相反数？" class="headerlink" title="1.1、如何得到一个数的相反数？"></a>1.1、如何得到一个数的相反数？</h3><p>答案：需要对一个数进行 <strong>取反 ，再加1</strong> 即可得到一个数的相反数。</p><pre><code class="highlight java"><span class="comment">// ~、相反数</span>System.out.println(a); <span class="comment">// 打印结果：78</span>printBinary(a); <span class="comment">// 打印结果：00000000000000000000000001001110</span>printBinary(~a); <span class="comment">// 打印结果：11111111111111111111111110110001</span><span class="type">int</span> <span class="variable">e</span> <span class="operator">=</span> ~a + <span class="number">1</span>;System.out.println(e); <span class="comment">// 打印结果：-78</span>printBinary(e); <span class="comment">// 打印结果：11111111111111111111111110110010</span>System.out.println(<span class="string">&quot;===e===&quot;</span>);</code></pre><p><strong>注意：int、long的最小值，取相反数、绝对值，都是自己</strong></p><h2 id="2、常见的位运算-、-、-、-、、"><a href="#2、常见的位运算-、-、-、-、、" class="headerlink" title="2、常见的位运算(|、&amp;、^、~、&lt;&lt;、&gt;&gt;、&gt;&gt;&gt;)"></a>2、常见的位运算(|、&amp;、^、~、&lt;&lt;、&gt;&gt;、&gt;&gt;&gt;)</h2><h3 id="2-1、按位或运算符-I"><a href="#2-1、按位或运算符-I" class="headerlink" title="2.1、按位或运算符(I)"></a>2.1、按位或运算符(I)</h3><ul><li><p>参加运算的两个对象，按二进制位进行“或”运算。</p></li><li><p>运算规则:0|0&#x3D;0；0|1&#x3D;1；1|0&#x3D;1；1|1&#x3D;1。</p><ul><li>即:参加运算的两个对象只要有一个为1，其值为1.</li><li>例如:3|5 即 0000 0011 | 0000 0101&#x3D;0000 0111 因此，3|5的值得7.</li></ul><p><strong>负数按补码形式参加按位或运算。</strong></p></li></ul><h3 id="2-2、按位与运算符"><a href="#2-2、按位与运算符" class="headerlink" title="2.2、按位与运算符(&amp;)"></a>2.2、按位与运算符(&amp;)</h3><ul><li><p>参加运算的两个数据，按二进制位进行“与”运算。</p></li><li><p>运算规则:0&amp;0&#x3D;0;0&amp;1&#x3D;0;1&amp;0&#x3D;0;1&amp;1&#x3D;1;</p><ul><li>即:两位同时为“1”，结果才为“1”，否则为0</li><li>例如:3&amp;5 即 0000 0011 &amp; 0000 0101 &#x3D; 0000 0001 因此，3&amp;5的值得1.</li></ul><p><strong>负数按补码形式参加按位与运算。</strong></p></li></ul><h3 id="2-3、按位异或运算符"><a href="#2-3、按位异或运算符" class="headerlink" title="2.3、按位异或运算符(^)"></a>2.3、按位异或运算符(^)</h3><ul><li>参加运算的两个数据，按二进制位进行“异或”运算</li><li>运算规则:0^0&#x3D;0; 0^1&#x3D;1; 1^0&#x3D;1; 1^1&#x3D;0;<ul><li>即:参加运算的两个对象，如果两个相应位为“异”(值不同)，则该位结果为1，否则为0.</li><li>例如:3&amp;5 即 0000 0011 ^ 0000 0101 &#x3D; 0000 0110 因此，3^5的值得6.</li></ul></li><li>任何数与0异或都等于自身</li><li>任何数与自己异或都为0</li></ul><p><strong>负数按补码形式参加按位与运算。</strong></p><h3 id="2-4、按位取反"><a href="#2-4、按位取反" class="headerlink" title="2.4、按位取反(~)"></a>2.4、按位取反(~)</h3><ul><li>运算规则：按照二进制位是0则变为1，是1则变成0<ul><li>即：~1 &#x3D; 0     ~0 &#x3D; 1</li><li>符号位也取反</li></ul></li><li>举例<ul><li>78 的二进制表示：00000000000000000000000001001110</li><li>取反后二进制表示：11111111111111111111111110110001</li></ul></li></ul><h3 id="2-5、左移"><a href="#2-5、左移" class="headerlink" title="2.5、左移(&lt;&lt;)"></a>2.5、左移(&lt;&lt;)</h3><ul><li>左移表示的是某数的各二进位全部左移若干位，高位丢弃，低位补0</li></ul><pre><code class="highlight java"><span class="comment">// 举例:</span>print(<span class="number">123</span>);<span class="comment">// 00000000000000000000000001111011</span>print(<span class="number">123</span> &lt;&lt; <span class="number">1</span>);<span class="comment">// 00000000000000000000000011110110</span><span class="comment">// 整体左移1位，高位丢弃，低位补0</span></code></pre><ul><li>应用</li></ul><pre><code class="highlight java"><span class="comment">// 左移1位相当于在原数的基础上乘以2</span>System.out.println(<span class="number">123</span>);<span class="comment">// 123</span>System.out.println(<span class="number">123</span>&lt;&lt;<span class="number">1</span>);<span class="comment">// 246</span><span class="comment">// 左移2位相当于在原数的基础上乘以4</span>System.out.println(<span class="number">2</span>);<span class="comment">// 2</span>System.out.println(<span class="number">2</span>&lt;&lt;<span class="number">2</span>);<span class="comment">// 8</span><span class="comment">// 左移3位、4位...以此类推</span></code></pre><h3 id="2-6、带符号右移"><a href="#2-6、带符号右移" class="headerlink" title="2.6、带符号右移(&gt;&gt;)"></a>2.6、带符号右移(&gt;&gt;)</h3><ul><li><strong>带符号右移（&gt;&gt;）</strong>指的是各二进位全部右移若干位，低位丢弃，高位补为符号位</li></ul><pre><code class="highlight java"><span class="comment">// 举例</span>printBinary(<span class="number">8</span>); <span class="comment">// 00000000000000000000000000001000</span>System.out.println(<span class="number">8</span>&gt;&gt;<span class="number">1</span>); <span class="comment">// 4</span>printBinary(<span class="number">8</span>&gt;&gt;<span class="number">1</span>); <span class="comment">// 00000000000000000000000000000100</span></code></pre><ul><li>应用</li></ul><pre><code class="highlight java">System.out.println(<span class="number">8</span>);<span class="comment">// 8</span>System.out.println(<span class="number">8</span>&gt;&gt;<span class="number">1</span>);<span class="comment">// 4</span><span class="comment">// 无符号右移2位相当于在原数的基础上除以4</span>System.out.println(<span class="number">8</span>);<span class="comment">// 8</span>System.out.println(<span class="number">8</span>&gt;&gt;<span class="number">2</span>);<span class="comment">// 2</span><span class="comment">// 负数右移规则也适用</span>System.out.println(-<span class="number">8</span>&gt;&gt;<span class="number">1</span>); <span class="comment">// -4</span><span class="comment">// 右移3位、4位...以此类推</span></code></pre><h3 id="2-7、无符号右移"><a href="#2-7、无符号右移" class="headerlink" title="2.7、无符号右移(&gt;&gt;&gt;)"></a>2.7、无符号右移(&gt;&gt;&gt;)</h3><ul><li><strong>无符号右移（&gt;&gt;&gt;）</strong>指的是各二进位全部右移若干位，低位丢弃，高位补0</li><li>如果是<strong>负数进行无符号右移，需要使用负数的二进制补码</strong>进行运算。</li><li>如果是正数进行无符号右移，则与 &gt;&gt; 规则相同，右移n位，就相当于除以 2<sup>n</sup></li></ul><pre><code class="highlight java"><span class="comment">// 正数无符号右移</span>System.out.println(<span class="number">8</span>&gt;&gt;&gt;<span class="number">1</span>);printBinary(<span class="number">8</span>);printBinary(<span class="number">8</span>&gt;&gt;&gt;<span class="number">1</span>);<span class="comment">// 负数无符号右移</span>System.out.println(-<span class="number">8</span>&gt;&gt;&gt;<span class="number">1</span>); <span class="comment">// 2147483644</span>printBinary(-<span class="number">8</span>); <span class="comment">// 二进制补码：11111111111111111111111111111000</span>printBinary(-<span class="number">8</span>&gt;&gt;&gt;<span class="number">1</span>); <span class="comment">// 01111111111111111111111111111100</span>System.out.println(<span class="string">&quot;=== &gt;&gt;&gt;无符号右移 ===&quot;</span>);</code></pre><h1 id="三、二进制如此设计的原因"><a href="#三、二进制如此设计的原因" class="headerlink" title="三、二进制如此设计的原因"></a>三、二进制如此设计的原因</h1><p>这么设计二进制是为了保证加法的逻辑是一套逻辑，没有条件转移。</p><p>也就是说无论是 正数+正数、正数+负数、负数加负数 都是遵循同一套逻辑，可以提高计算机的运行效率。</p><h1 id="四、解析二进制打印函数"><a href="#四、解析二进制打印函数" class="headerlink" title="四、解析二进制打印函数"></a>四、解析二进制打印函数</h1><h2 id="1、二进制打印函数如下"><a href="#1、二进制打印函数如下" class="headerlink" title="1、二进制打印函数如下"></a>1、二进制打印函数如下</h2><pre><code class="highlight java"><span class="comment">/**</span><span class="comment">  * 打印一个int类型的数字，32位进制的状态</span><span class="comment">  * 左侧是高位，右侧是低位</span><span class="comment">  * 这里打印的是num的二进制补码。</span><span class="comment">  * <span class="doctag">@param</span> num 十进制数值</span><span class="comment">  */</span><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">printBinary</span><span class="params">(<span class="type">int</span> num)</span> &#123;    <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">31</span>; i &gt;= <span class="number">0</span>; i--) &#123;        <span class="comment">// 下面这句写法，可以改成 :</span>        <span class="comment">// System.out.print((a &amp; (1 &lt;&lt; i)) != 0 ? &quot;1&quot; : &quot;0&quot;);</span>        <span class="comment">// 但不可以改成 :</span>        <span class="comment">// System.out.print((a &amp; (1 &lt;&lt; i)) == 1 ? &quot;1&quot; : &quot;0&quot;);</span>        <span class="comment">// 因为a如果第i位有1，那么(a &amp; (1 &lt;&lt; i))是2的i次方，而不一定是1</span>        <span class="comment">// 比如，a = 0010011</span>        <span class="comment">// a的第0位是1，第1位是1，第4位是1</span>        <span class="comment">// (a &amp; (1&lt;&lt;4)) == 16（不是1），说明a的第4位是1状态</span>        System.out.print((num &amp; (<span class="number">1</span> &lt;&lt; i)) == <span class="number">0</span> ? <span class="string">&quot;0&quot;</span> : <span class="string">&quot;1&quot;</span>);    &#125;    System.out.println();&#125;</code></pre><h2 id="2、解析"><a href="#2、解析" class="headerlink" title="2、解析"></a>2、解析</h2><ul><li>一个int类型的数在java中有32位，如果需要打印它的二进制表示，就需要知道它在二进制数中，每一位是0还是1。</li><li>根据位运算符 按位&amp; 的特点，相同位都为1，按位&amp;计算为1，否则为0的特点来实现这一需求。</li><li><code>1 &lt;&lt; i</code> 表示打印第 i 位上的二进制数<ul><li>例如：num等于8，那么它的二进制表示为：00000000000000000000000000001000</li><li>i 从高位(31) 到低位(0) 依次打印。</li><li>i 等于31时，1 &lt;&lt; 31 的值表示的二进制为：10000000000000000000000000000000</li><li>此时 <code>num &amp; (1 &lt;&lt; i)</code> 的值就是0，所以 num 的二进制值，在第31位上为0。</li><li>i 递减，依次往后打印出 num 每一位二进制数。</li></ul></li><li>如果num是一个负数，这个函数打印的就是负数二进制数的表示的补码。<ul><li>例如：num等于 -8 ，此函数打印出它的二进制补码为：11111111111111111111111111111000</li></ul></li></ul><p><strong>正数的二进制 原码、反码、补码是相同的。</strong></p>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;一、二进制基础&quot;&gt;&lt;a href=&quot;#一、二进制基础&quot; class=&quot;headerlink&quot; title=&quot;一、二进制基础&quot;&gt;&lt;/a&gt;一、二进制基础&lt;/h1&gt;&lt;h2 id=&quot;1、二进制与十进制的转换&quot;&gt;&lt;a href=&quot;#1、二进制与十进制的转换&quot; class=&quot;</summary>
      
    
    
    
    <category term="算法" scheme="https://georgechan95.github.io/categories/%E7%AE%97%E6%B3%95/"/>
    
    
    <category term="算法" scheme="https://georgechan95.github.io/tags/%E7%AE%97%E6%B3%95/"/>
    
    <category term="二进制" scheme="https://georgechan95.github.io/tags/%E4%BA%8C%E8%BF%9B%E5%88%B6/"/>
    
    <category term="位运算" scheme="https://georgechan95.github.io/tags/%E4%BD%8D%E8%BF%90%E7%AE%97/"/>
    
  </entry>
  
  <entry>
    <title>第十三章-垃圾回收相关概念</title>
    <link href="https://georgechan95.github.io/2024/01/14/jvm/%E7%AC%AC%E5%8D%81%E4%B8%89%E7%AB%A0-%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6%E7%9B%B8%E5%85%B3%E6%A6%82%E5%BF%B5/"/>
    <id>https://georgechan95.github.io/2024/01/14/jvm/%E7%AC%AC%E5%8D%81%E4%B8%89%E7%AB%A0-%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6%E7%9B%B8%E5%85%B3%E6%A6%82%E5%BF%B5/</id>
    <published>2024-01-14T06:27:00.000Z</published>
    <updated>2024-06-22T10:36:12.823Z</updated>
    
    <content type="html"><![CDATA[<h1 id="一、System-gc-的理解"><a href="#一、System-gc-的理解" class="headerlink" title="一、System.gc() 的理解"></a>一、System.gc() 的理解</h1><ul><li>在默认情况下，通过System.gc()者Runtime.getRuntime().gc() 的调用，<strong>会显式触发Full GC</strong>，同时对老年代和新生代进行回收，尝试释放被丢弃对象占用的内存。</li><li>然而System.gc()调用附带一个免责声明，无法保证对垃圾收集器的调用(不能确保立即生效)</li><li>JVM实现者可以通过System.gc() 调用来决定JVM的GC行为。而一般情况下，垃圾回收应该是自动进行的，<strong>无须手动触发，否则就太过于麻烦了。</strong>在一些特殊情况下，如我们正在编写一个性能基准，我们可以在运行之间调用System.gc()</li></ul><pre><code class="highlight java"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">SystemGCTest</span> &#123;    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;        <span class="keyword">new</span> <span class="title class_">SystemGCTest</span>();        System.gc();<span class="comment">//提醒jvm的垃圾回收器执行gc,但是不确定是否马上执行gc</span>        <span class="comment">//与Runtime.getRuntime().gc();的作用一样。</span><span class="comment">//        System.runFinalization();//强制调用使用引用的对象的finalize()方法</span>    &#125;    <span class="meta">@Override</span>    <span class="keyword">protected</span> <span class="keyword">void</span> <span class="title function_">finalize</span><span class="params">()</span> <span class="keyword">throws</span> Throwable &#123;        <span class="built_in">super</span>.finalize();        System.out.println(<span class="string">&quot;SystemGCTest 重写了finalize()&quot;</span>);    &#125;&#125;</code></pre><p>输出结果不确定：有时候会调用 finalize() 方法，有时候并不会调用</p><pre><code class="highlight plaintext">SystemGCTest 重写了finalize()或空</code></pre><h2 id="1-手动-GC-理解不可达对象的回收行为"><a href="#1-手动-GC-理解不可达对象的回收行为" class="headerlink" title="1. 手动 GC 理解不可达对象的回收行为"></a>1. 手动 GC 理解不可达对象的回收行为</h2><blockquote><p>示例代码：</p></blockquote><pre><code class="highlight java"><span class="comment">/**</span><span class="comment"> * -Xms256m -Xmx256m -XX:+PrintGCDetails -XX:PretenureSizeThreshold=15m</span><span class="comment"> *</span><span class="comment"> * 参数解析：</span><span class="comment"> *      -XX:PretenureSizeThreshold=15m  超过15M的大对象直接进入老年代</span><span class="comment"> */</span><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">LocalVarGC</span> &#123;    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">localvarGC1</span><span class="params">()</span> &#123;        <span class="type">byte</span>[] buffer = <span class="keyword">new</span> <span class="title class_">byte</span>[<span class="number">10</span> * <span class="number">1024</span> * <span class="number">1024</span>];<span class="comment">//10MB</span>        System.gc();    &#125;    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">localvarGC2</span><span class="params">()</span> &#123;        <span class="type">byte</span>[] buffer = <span class="keyword">new</span> <span class="title class_">byte</span>[<span class="number">10</span> * <span class="number">1024</span> * <span class="number">1024</span>];        buffer = <span class="literal">null</span>;        System.gc();    &#125;    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">localvarGC3</span><span class="params">()</span> &#123;        &#123;            <span class="type">byte</span>[] buffer = <span class="keyword">new</span> <span class="title class_">byte</span>[<span class="number">10</span> * <span class="number">1024</span> * <span class="number">1024</span>];        &#125;        System.gc();    &#125;    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">localvarGC4</span><span class="params">()</span> &#123;        &#123;            <span class="type">byte</span>[] buffer = <span class="keyword">new</span> <span class="title class_">byte</span>[<span class="number">10</span> * <span class="number">1024</span> * <span class="number">1024</span>];        &#125;        <span class="type">int</span> <span class="variable">value</span> <span class="operator">=</span> <span class="number">10</span>;        System.gc();    &#125;    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">localvarGC5</span><span class="params">()</span> &#123;        localvarGC1();        System.gc();    &#125;    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;        <span class="type">LocalVarGC</span> <span class="variable">local</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">LocalVarGC</span>();        local.localvarGC1();<span class="comment">//        local.localvarGC2();</span><span class="comment">//        local.localvarGC3();</span><span class="comment">//        local.localvarGC4();</span><span class="comment">//        local.localvarGC5();</span>    &#125;&#125;</code></pre><p><strong>1、调用 localvarGC1() 方法</strong></p><p>执行 System.gc() 仅仅是将年轻代的 buffer 数组对象放到了老年代，buffer对象仍然没有回收</p><blockquote><p>打印日志如下：</p></blockquote><pre><code class="highlight plaintext">[GC (System.gc()) [PSYoungGen: 15483K-&gt;10744K(76288K)] 15483K-&gt;10928K(251392K), 0.0043067 secs] [Times: user=0.00 sys=0.00, real=0.00 secs] [Full GC (System.gc()) [PSYoungGen: 10744K-&gt;0K(76288K)] [ParOldGen: 184K-&gt;10863K(175104K)] 10928K-&gt;10863K(251392K), [Metaspace: 3228K-&gt;3228K(1056768K)], 0.0051795 secs] [Times: user=0.05 sys=0.00, real=0.01 secs] Heap PSYoungGen      total 76288K, used 655K [0x00000000fab00000, 0x0000000100000000, 0x0000000100000000)  eden space 65536K, 1% used [0x00000000fab00000,0x00000000faba3ee8,0x00000000feb00000)  from space 10752K, 0% used [0x00000000feb00000,0x00000000feb00000,0x00000000ff580000)  to   space 10752K, 0% used [0x00000000ff580000,0x00000000ff580000,0x0000000100000000) ParOldGen       total 175104K, used 10863K [0x00000000f0000000, 0x00000000fab00000, 0x00000000fab00000)  object space 175104K, 6% used [0x00000000f0000000,0x00000000f0a9be78,0x00000000fab00000) Metaspace       used 3235K, capacity 4496K, committed 4864K, reserved 1056768K  class space    used 350K, capacity 388K, committed 512K, reserved 1048576K</code></pre><p><strong>2、调用 localvarGC2() 方法</strong></p><p>由于 buffer 数组对象没有引用指向它，执行 System.gc() 将被回收</p><blockquote><p>打印日志如下：</p></blockquote><pre><code class="highlight plaintext">[GC (System.gc()) [PSYoungGen: 15483K-&gt;680K(76288K)] 15483K-&gt;688K(251392K), 0.0006552 secs] [Times: user=0.00 sys=0.00, real=0.00 secs] [Full GC (System.gc()) [PSYoungGen: 680K-&gt;0K(76288K)] [ParOldGen: 8K-&gt;598K(175104K)] 688K-&gt;598K(251392K), [Metaspace: 3202K-&gt;3202K(1056768K)], 0.0035341 secs] [Times: user=0.00 sys=0.00, real=0.00 secs] Heap PSYoungGen      total 76288K, used 1966K [0x00000000fab00000, 0x0000000100000000, 0x0000000100000000)  eden space 65536K, 3% used [0x00000000fab00000,0x00000000faceb9e0,0x00000000feb00000)  from space 10752K, 0% used [0x00000000feb00000,0x00000000feb00000,0x00000000ff580000)  to   space 10752K, 0% used [0x00000000ff580000,0x00000000ff580000,0x0000000100000000) ParOldGen       total 175104K, used 598K [0x00000000f0000000, 0x00000000fab00000, 0x00000000fab00000)  object space 175104K, 0% used [0x00000000f0000000,0x00000000f00959b8,0x00000000fab00000) Metaspace       used 3219K, capacity 4496K, committed 4864K, reserved 1056768K  class space    used 348K, capacity 388K, committed 512K, reserved 1048576K</code></pre><p><strong>3、调用 localvarGC3() 方法</strong></p><p>虽然出了代码块的作用域，但是 buffer 数组对象并没有被回收</p><blockquote><p>打印日志如下：</p></blockquote><pre><code class="highlight plaintext">[GC (System.gc()) [PSYoungGen: 15483K-&gt;744K(76288K)] 15483K-&gt;10992K(251392K), 0.0044234 secs] [Times: user=0.02 sys=0.02, real=0.02 secs] [Full GC (System.gc()) [PSYoungGen: 744K-&gt;0K(76288K)] [ParOldGen: 10248K-&gt;10863K(175104K)] 10992K-&gt;10863K(251392K), [Metaspace: 3227K-&gt;3227K(1056768K)], 0.0049354 secs] [Times: user=0.00 sys=0.00, real=0.00 secs] Heap PSYoungGen      total 76288K, used 655K [0x00000000fab00000, 0x0000000100000000, 0x0000000100000000)  eden space 65536K, 1% used [0x00000000fab00000,0x00000000faba3ee8,0x00000000feb00000)  from space 10752K, 0% used [0x00000000feb00000,0x00000000feb00000,0x00000000ff580000)  to   space 10752K, 0% used [0x00000000ff580000,0x00000000ff580000,0x0000000100000000) ParOldGen       total 175104K, used 10863K [0x00000000f0000000, 0x00000000fab00000, 0x00000000fab00000)  object space 175104K, 6% used [0x00000000f0000000,0x00000000f0a9be78,0x00000000fab00000) Metaspace       used 3234K, capacity 4496K, committed 4864K, reserved 1056768K  class space    used 350K, capacity 388K, committed 512K, reserved 1048576K</code></pre><p><strong>原因：</strong> 变量 buffer在局部变量表中索引占用的位置，没有被其它变量占用过，即便是出了局部方法所在区域，buffer变量依然存在。</p><p>1、来看看字节码：局部变量表中索引0所在位置是：this</p><p><img src="https://raw.githubusercontent.com/GeorgeChan95/blogimg/master/img/2024/01/14/20240114-150438.png" alt="image-20240114150434293"></p><p>2、查看局部变量表最大长度是：2，但是局部变量表里只有一个索引为0的变量this，这是由于索引为1的位置是buffer在占用着，执行 System.gc() 时，栈中还有 buffer 变量指向堆中的字节数组，所以没有进行GC。</p><p>那么这种情况下该如何将buffer变量指向的内存回收掉呢？</p><p><img src="https://raw.githubusercontent.com/GeorgeChan95/blogimg/master/img/2024/01/14/20240114-150544.png" alt="image-20240114150543247"></p><p><strong>4、调用 localvarGC4() 方法</strong></p><blockquote><p>打印日志如下：</p></blockquote><pre><code class="highlight plaintext">[GC (System.gc()) [PSYoungGen: 15483K-&gt;744K(76288K)] 15483K-&gt;752K(251392K), 0.0008784 secs] [Times: user=0.00 sys=0.00, real=0.00 secs] [Full GC (System.gc()) [PSYoungGen: 744K-&gt;0K(76288K)] [ParOldGen: 8K-&gt;623K(175104K)] 752K-&gt;623K(251392K), [Metaspace: 3228K-&gt;3228K(1056768K)], 0.0034782 secs] [Times: user=0.02 sys=0.03, real=0.01 secs] Heap PSYoungGen      total 76288K, used 655K [0x00000000fab00000, 0x0000000100000000, 0x0000000100000000)  eden space 65536K, 1% used [0x00000000fab00000,0x00000000faba3ee8,0x00000000feb00000)  from space 10752K, 0% used [0x00000000feb00000,0x00000000feb00000,0x00000000ff580000)  to   space 10752K, 0% used [0x00000000ff580000,0x00000000ff580000,0x0000000100000000) ParOldGen       total 175104K, used 623K [0x00000000f0000000, 0x00000000fab00000, 0x00000000fab00000)  object space 175104K, 0% used [0x00000000f0000000,0x00000000f009be68,0x00000000fab00000) Metaspace       used 3235K, capacity 4496K, committed 4864K, reserved 1056768K  class space    used 350K, capacity 388K, committed 512K, reserved 1048576K</code></pre><p>Q：就多定义了一个局部变量 value ，就可以把字节数组回收了呢？</p><p>A：局部变量表长度为 2 ，这说明了出了代码块时，buffer 就出了其作用域范围，此时没有为 value 开启新的槽，value 变量直接占据了 buffer 变量的槽（Slot），导致堆中的字节数组没有引用再指向它，执行 System.gc() 时被回收。看，value 位于局部变量表中索引为 1 的位置。value这个局部变量把原本属于buffer的slot给占用了，这样栈上就没有buffer变量指向<code>new byte[10 * 1024 * 1024]</code>实例了。</p><blockquote><p>查看字节码</p></blockquote><p><img src="https://raw.githubusercontent.com/GeorgeChan95/blogimg/master/img/2024/01/14/20240114-151050.png" alt="image-20240114151048967"></p><p><img src="https://raw.githubusercontent.com/GeorgeChan95/blogimg/master/img/2024/01/14/20240114-151114.png" alt="image-20240114151112547"></p><p><strong>5、调用 localvarGC5() 方法</strong></p><p>局部变量出了方法所在范围就失效了，堆中的字节数组被回收。</p><blockquote><p>打印日志如下：</p></blockquote><pre><code class="highlight plaintext">[GC (System.gc()) [PSYoungGen: 15483K-&gt;10744K(76288K)] 15483K-&gt;10920K(251392K), 0.0052051 secs] [Times: user=0.00 sys=0.00, real=0.00 secs] [Full GC (System.gc()) [PSYoungGen: 10744K-&gt;0K(76288K)] [ParOldGen: 176K-&gt;10863K(175104K)] 10920K-&gt;10863K(251392K), [Metaspace: 3228K-&gt;3228K(1056768K)], 0.0075048 secs] [Times: user=0.00 sys=0.00, real=0.01 secs] [GC (System.gc()) [PSYoungGen: 0K-&gt;0K(76288K)] 10863K-&gt;10863K(251392K), 0.0008154 secs] [Times: user=0.00 sys=0.00, real=0.00 secs] [Full GC (System.gc()) [PSYoungGen: 0K-&gt;0K(76288K)] [ParOldGen: 10863K-&gt;622K(175104K)] 10863K-&gt;622K(251392K), [Metaspace: 3228K-&gt;3228K(1056768K)], 0.0072950 secs] [Times: user=0.03 sys=0.00, real=0.01 secs] Heap PSYoungGen      total 76288K, used 655K [0x00000000fab00000, 0x0000000100000000, 0x0000000100000000)  eden space 65536K, 1% used [0x00000000fab00000,0x00000000faba3ee8,0x00000000feb00000)  from space 10752K, 0% used [0x00000000ff580000,0x00000000ff580000,0x0000000100000000)  to   space 10752K, 0% used [0x00000000feb00000,0x00000000feb00000,0x00000000ff580000) ParOldGen       total 175104K, used 622K [0x00000000f0000000, 0x00000000fab00000, 0x00000000fab00000)  object space 175104K, 0% used [0x00000000f0000000,0x00000000f009bbe0,0x00000000fab00000) Metaspace       used 3234K, capacity 4496K, committed 4864K, reserved 1056768K  class space    used 350K, capacity 388K, committed 512K, reserved 1048576K</code></pre><h1 id="二、内存溢出与内存泄漏"><a href="#二、内存溢出与内存泄漏" class="headerlink" title="二、内存溢出与内存泄漏"></a>二、内存溢出与内存泄漏</h1><h2 id="1-内存溢出概述"><a href="#1-内存溢出概述" class="headerlink" title="1. 内存溢出概述"></a>1. 内存溢出概述</h2><ul><li>内存溢出相对于内存泄漏来说，尽管更容易被理解，但是同样的，内存溢出也是引发程序崩溃的罪魁祸首之一。</li><li>由于GC一直在发展，所有一般情况下，除非应用程序占用的内存增长速度非常快，造成垃圾回收已经跟不上内存消耗的速度，否则不太容易出现OOM的情况。</li><li>大多数情况下，GC会进行各种年龄段的垃圾回收，实在不行了就放大招，来一次独占式的Full GC操作，这时候会回收大量的内存，供应用程序继续使用。</li><li>Javadoc中对OutofMemoryError的解释是，没有空闲内存，并且垃圾收集器也无法提供更多内存。</li></ul><h2 id="2-内存溢出（OOM）原因分析"><a href="#2-内存溢出（OOM）原因分析" class="headerlink" title="2. 内存溢出（OOM）原因分析"></a>2. 内存溢出（OOM）原因分析</h2><p>首先说没有空闲内存的情况：说明Java虚拟机的堆内存不够。原因有二：</p><ol><li>Java虚拟机的堆内存设置不够。<ul><li>比如：可能存在内存泄漏问题；也很有可能就是堆的大小不合理，比如我们要处理比较可观的数据量，但是没有显式指定JVM堆大小或者指定数值偏小。我们可以通过参数-Xms 、-Xmx来调整。</li></ul></li><li>代码中创建了大量大对象，并且长时间不能被垃圾收集器收集（存在被引用）<ul><li>对于老版本的Oracle JDK，因为永久代的大小是有限的，并且JVM对永久代垃圾回收（如，常量池回收、卸载不再需要的类型）非常不积极，所以当我们不断添加新类型的时候，永久代出现OutOfMemoryError也非常多见。尤其是在运行时存在大量动态类型生成的场合；类似intern字符串缓存占用太多空间，也会导致OOM问题。对应的异常信息，会标记出来和永久代相关：“java.lang.OutOfMemoryError:PermGen space”。</li><li>随着元数据区的引入，方法区内存已经不再那么窘迫，所以相应的OOM有所改观，出现OOM，异常信息则变成了：“java.lang.OutofMemoryError:Metaspace”。直接内存不足，也会导致OOM。</li></ul></li></ol><ul><li>这里面隐含着一层意思是，在抛出OutofMemoryError之前，通常垃圾收集器会被触发，尽其所能去清理出空间。<ul><li>例如：在引用机制分析中，涉及到JVM会去尝试<strong>回收软引用指向的对象</strong>等。</li><li>在java.nio.Bits.reserveMemory()方法中，我们能清楚的看到，System.gc()会被调用，以清理空间。</li></ul></li><li>当然，也不是在任何情况下垃圾收集器都会被触发的<ul><li>比如，我们去分配一个超大对象，类似一个超大数组超过堆的最大值，JVM可以判断出垃圾收集并不能解决这个问题，所以直接抛出OutofMemoryError。</li></ul></li></ul><h2 id="3-内存泄漏概述"><a href="#3-内存泄漏概述" class="headerlink" title="3. 内存泄漏概述"></a>3. 内存泄漏概述</h2><ul><li>也称作“存储渗漏”。严格来说，<strong>只有对象不会再被程序用到了，但是GC又不能回收他们的情况，才叫内存泄漏。</strong></li><li>但实际情况很多时候一些不太好的实践（或疏忽）会导致对象的生命周期变得很长甚至导致OOM，也可以叫做宽泛意义上的“内存泄漏”。</li><li>尽管内存泄漏并不会立刻引起程序崩溃，但是一旦发生内存泄漏，程序中的可用内存就会被逐步蚕食，直至耗尽所有内存，最终出现OutofMemory异常，导致程序崩溃。</li><li>注意，这里的存储空间并不是指物理内存，而是指虚拟内存大小，这个虚拟内存大小取决于磁盘交换区设定的大小。</li></ul><h3 id="3-1-内存泄露官方例子"><a href="#3-1-内存泄露官方例子" class="headerlink" title="3.1 内存泄露官方例子"></a>3.1 内存泄露官方例子</h3><p>左边的图：Java使用可达性分析算法，最上面的数据不可达，就是需要被回收的对象。</p><p>右边的图：后期有一些对象不用了，按道理应该断开引用，但是存在一些链没有断开（图示中的Forgotten Reference Memory Leak），从而导致没有办法被回收。</p><p><img src="https://raw.githubusercontent.com/GeorgeChan95/blogimg/master/img/2024/01/14/20240114-152858.png" alt="内存泄露官方例子"></p><h3 id="3-2-内存泄漏常见例子"><a href="#3-2-内存泄漏常见例子" class="headerlink" title="3.2 内存泄漏常见例子"></a>3.2 内存泄漏常见例子</h3><ul><li>单例模式<ul><li>单例的生命周期和应用程序是一样长的，所以在单例程序中，如果持有对外部对象的引用的话，那么这个外部对象是不能被回收的，则会导致内存泄漏的产生。</li></ul></li><li>一些提供close()的资源未关闭导致内存泄漏<ul><li>数据库连接 dataSourse.getConnection()，网络连接socket和io连接必须手动close，否则是不能被回收的。</li></ul></li></ul><h1 id="三、-Stop-the-World"><a href="#三、-Stop-the-World" class="headerlink" title="三、 Stop the World"></a>三、 Stop the World</h1><h2 id="1-概念"><a href="#1-概念" class="headerlink" title="1. 概念"></a>1. 概念</h2><ul><li>Stop-the-World，简称STW，指的是GC事件发生过程中，会产生应用程序的停顿。<strong>停顿产生时整个应用程序线程都会被暂停，没有任何响应</strong>，有点像卡死的感觉，这个停顿称为STW。</li><li>可达性分析算法中枚举根节点（GC Roots）会导致所有Java执行线程停顿，为什么需要停顿所有 Java 执行线程呢？<ul><li>分析工作必须在一个能确保一致性的快照中进行</li><li>一致性指整个分析期间整个执行系统看起来像被冻结在某个时间点上</li><li><strong>如果出现分析过程中对象引用关系还在不断变化，则分析结果的准确性无法保证</strong></li></ul></li><li>被STW中断的应用程序线程会在完成GC之后恢复，频繁中断会让用户感觉像是网速不快造成电影卡带一样，所以我们需要减少STW的发生。</li></ul><p>STW事件和采用哪款GC无关，所有的GC都有这个事件。哪怕是G1也不能完全避免Stop-the-world情况发生，只能说垃圾回收器越来越优秀，回收效率越来越高，尽可能地缩短了暂停时间。</p><p>STW是JVM在后台自动发起和自动完成的。在用户不可见的情况下，把用户正常的工作线程全部停掉。</p><p>开发中不要用System.gc() ，这会导致Stop-the-World的发生。</p><h2 id="2-代码感受-Stop-the-World"><a href="#2-代码感受-Stop-the-World" class="headerlink" title="2. 代码感受 Stop the World"></a>2. 代码感受 Stop the World</h2><blockquote><p>示例代码</p></blockquote><pre><code class="highlight java"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">StopTheWorldDemo</span> &#123;    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">class</span> <span class="title class_">WorkThread</span> <span class="keyword">extends</span> <span class="title class_">Thread</span> &#123;        List&lt;<span class="type">byte</span>[]&gt; list = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;<span class="type">byte</span>[]&gt;();        <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span> &#123;            <span class="keyword">try</span> &#123;                <span class="keyword">while</span> (<span class="literal">true</span>) &#123;                    <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>;i &lt; <span class="number">1000</span>;i++)&#123;                        <span class="type">byte</span>[] buffer = <span class="keyword">new</span> <span class="title class_">byte</span>[<span class="number">1024</span>];                        list.add(buffer);                    &#125;                    <span class="keyword">if</span>(list.size() &gt; <span class="number">1000000</span>)&#123;                        list.clear();                        System.gc();<span class="comment">//会触发full gc，进而会出现STW事件</span>                    &#125;                &#125;            &#125; <span class="keyword">catch</span> (Exception ex) &#123;                ex.printStackTrace();            &#125;        &#125;    &#125;    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">class</span> <span class="title class_">PrintThread</span> <span class="keyword">extends</span> <span class="title class_">Thread</span> &#123;        <span class="keyword">public</span> <span class="keyword">final</span> <span class="type">long</span> <span class="variable">startTime</span> <span class="operator">=</span> System.currentTimeMillis();        <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span> &#123;            <span class="keyword">try</span> &#123;                <span class="keyword">while</span> (<span class="literal">true</span>) &#123;                    <span class="comment">// 每秒打印时间信息</span>                    <span class="type">long</span> <span class="variable">t</span> <span class="operator">=</span> System.currentTimeMillis() - startTime;                    System.out.println(t / <span class="number">1000</span> + <span class="string">&quot;.&quot;</span> + t % <span class="number">1000</span>);                    Thread.sleep(<span class="number">1000</span>);                &#125;            &#125; <span class="keyword">catch</span> (Exception ex) &#123;                ex.printStackTrace();            &#125;        &#125;    &#125;    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;        <span class="type">WorkThread</span> <span class="variable">w</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">WorkThread</span>();        <span class="type">PrintThread</span> <span class="variable">p</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">PrintThread</span>();        w.start();        p.start();    &#125;&#125;</code></pre><p>关闭工作线程 w ，观察输出：当前时间间隔与上次时间间隔<strong>基本</strong>是每隔1秒打印一次</p><pre><code class="highlight plaintext">0.11.142.163.184.195.226.227.298.519.5410.5611.58</code></pre><p>开启工作线程 w ，观察打印输出：当前时间间隔与上次时间间隔相差 1.5s ，可以明显感受到 Stop the World 的存在</p><pre><code class="highlight plaintext">0.21.792.813.894.3015.3026.4077.5598.7129.86911.3112.16913.31814.50715.62516.77817.91119.3620.17021.32022.47623.60924.74925.88727.528.140</code></pre><h1 id="四、垃圾回收的并行与并发"><a href="#四、垃圾回收的并行与并发" class="headerlink" title="四、垃圾回收的并行与并发"></a>四、垃圾回收的并行与并发</h1><h2 id="1-并发的概念"><a href="#1-并发的概念" class="headerlink" title="1. 并发的概念"></a>1. 并发的概念</h2><ul><li>在操作系统中，是指<strong>一个时间段</strong>中有几个程序都处于已启动运行到运行完毕之间，且这几个程序都是在同一个处理器上运行</li><li>并发不是真正意义上的“同时进行”，只是CPU把一个时间段划分成几个时间片段（时间区间），然后在这几个时间区间之间来回切换。由于CPU处理的速度非常快，只要时间间隔处理得当，即可让用户感觉是多个应用程序同时在进行</li></ul><p><img src="https://raw.githubusercontent.com/GeorgeChan95/blogimg/master/img/2024/01/14/20240114-154743.png" alt="理解并发"></p><h2 id="2-并行的概念"><a href="#2-并行的概念" class="headerlink" title="2. 并行的概念"></a>2. 并行的概念</h2><ul><li>当系统有一个以上CPU时，当一个CPU执行一个进程时，另一个CPU可以执行另一个进程，两个进程互不抢占CPU资源，可以<strong>同时</strong>进行，我们称之为并行（Parallel）</li><li>其实决定并行的因素不是CPU的数量，而是CPU的核心数量，比如一个CPU多个核也可以并行</li><li>适合科学计算，后台处理等弱交互场景</li></ul><p><img src="https://raw.githubusercontent.com/GeorgeChan95/blogimg/master/img/2024/01/14/20240114-154958.png" alt="理解并行"></p><h2 id="3-并发与并行的对比"><a href="#3-并发与并行的对比" class="headerlink" title="3. 并发与并行的对比"></a>3. 并发与并行的对比</h2><ul><li>并发，指的是多个事情，在同一时间段内同时发生了。</li><li>并行，指的是多个事情，在同一时间点上（或者说同一时刻）同时发生了。</li><li>并发的多个任务之间是互相抢占资源的。并行的多个任务之间是不互相抢占资源的。</li><li>只有在多CPU或者一个CPU多核的情况中，才会发生并行。否则，看似同时发生的事情，其实都是并发执行的。</li></ul><h2 id="4-垃圾回收的并发与并行"><a href="#4-垃圾回收的并发与并行" class="headerlink" title="4. 垃圾回收的并发与并行"></a>4. 垃圾回收的并发与并行</h2><ul><li>并行（Parallel）：指多条垃圾收集线程并行工作，但此时用户线程仍处于等待状态。<ul><li>如ParNew、Parallel Scavenge、Parallel Old</li></ul></li><li>串行（Serial）<ul><li>相较于并行的概念，单线程执行。</li><li>如果内存不够，则程序暂停，启动JVM垃圾回收器进行垃圾回收（单线程）</li></ul></li></ul><p><img src="https://raw.githubusercontent.com/GeorgeChan95/blogimg/master/img/2024/01/14/20240114-161201.png" alt="垃圾回收器的并行和串行"></p><p>并发和并行，在谈论垃圾收集器的上下文语境中，它们可以解释如下：</p><ul><li>并发（Concurrent）：指<strong>用户线程与垃圾收集线程同时执行</strong>（但不一定是并行的，可能会交替执行），垃圾回收线程在执行时不会停顿用户程序的运行。<ul><li>比如用户程序在继续运行，而垃圾收集程序线程运行于另一个CPU上；</li><li>典型垃圾回收器：CMS、G1</li></ul></li></ul><p><img src="https://raw.githubusercontent.com/GeorgeChan95/blogimg/master/img/2024/01/14/20240114-161342.png" alt="image-20240114161340589"></p><h1 id="五、HotSpot的算法实现细节"><a href="#五、HotSpot的算法实现细节" class="headerlink" title="五、HotSpot的算法实现细节"></a>五、HotSpot的算法实现细节</h1><h2 id="1-根节点枚举"><a href="#1-根节点枚举" class="headerlink" title="1. 根节点枚举"></a>1. 根节点枚举</h2><ul><li>固定可作为GC Roots的节点主要在全局性的引用（例如常量或类静态属性）与执行上下文（例如栈帧中的本地变量表）中，尽管目标明确，但查找过程要做到高效并非一件容易的事情，现在Java应用越做越庞大，光是方法区的大小就常有数百上千兆，里面的类、常量等更是恒河沙数，若要逐个检查以这里为起源的引用肯定得消耗不少时间。</li><li>迄今为止，<strong>所有收集器在根节点枚举这一步骤时都是必须暂停用户线程的</strong>，因此毫无疑问根节点 枚举与之前提及的整理内存碎片一样会面临相似的“Stop The World”的困扰。现在可达性分析算法耗时 最长的查找引用链的过程已经可以做到与用户线程一起并发，<strong>但根节点枚举始终还 是必须在一个能保障一致性的快照中才得以进行</strong>——这里“一致性”的意思是整个枚举期间执行子系统 看起来就像被冻结在某个时间点上，不会出现分析过程中，根节点集合的对象引用关系还在不断变化 的情况，若这点不能满足的话，分析结果准确性也就无法保证。这是导致垃圾收集过程必须停顿所有 用户线程的其中一个重要原因，即使是号称停顿时间可控，或者（几乎）不会发生停顿的CMS、G1、 ZGC等收集器，枚举根节点时也是必须要停顿的。</li><li>由于目前主流Java虚拟机使用的都是<strong>准确式垃圾收集</strong>，所以当用户线程停顿下来之后，其实并不需要一个不漏地检查完所有 执行上下文和全局的引用位置，虚拟机应当是有办法直接得到哪些地方存放着对象引用的。在HotSpot 的解决方案里，是使用一组称为<strong>OopMap的数据结构</strong>来达到这个目的。一旦类加载动作完成的时候， HotSpot就会把对象内什么偏移量上是什么类型的数据计算出来，在即时编译过程中，也会在特定的位置记录下栈里和寄存器里哪些位置是引用。这样收集器在扫描时就可以直接得知这些信 息了，<strong>并不需要真正一个不漏地从方法区等GC Roots开始查找</strong>。</li><li>Exact VM因它使用<strong>准确式内存管理</strong>（Exact Memory Management，也可以叫Non-Con- servative&#x2F;Accurate Memory Management）而得名。准确式内存管理是指虚拟机可以知道内存中某个位置的数据具体是什么类型。譬如内存中有一个32bit的整数123456，虚拟机将有能力分辨出它到底是一 个指向了123456的内存地址的引用类型还是一个数值为123456的整数，准确分辨出哪些内存是引用类型，这也是在垃圾收集时准确判断堆上的数据是否还可能被使用的前提。【<strong>这个不是特别重要，了解一下即可</strong>】</li></ul><p>常考面试：<strong>在OopMap的协助下，HotSpot可以快速准确地完成GC Roots枚举</strong></p><h2 id="2-安全点与安全区域"><a href="#2-安全点与安全区域" class="headerlink" title="2. 安全点与安全区域"></a>2. 安全点与安全区域</h2><h3 id="2-1-安全点（Safepoint）"><a href="#2-1-安全点（Safepoint）" class="headerlink" title="2.1 安全点（Safepoint）"></a>2.1 安全点（Safepoint）</h3><ul><li>程序执行时并非在所有地方都能停顿下来开始GC，只有在特定的位置才能停顿下来开始GC，这些位置称为“安全点（Safepoint）”。</li><li>Safe Point的选择很重要，<strong>如果太少可能导致GC等待的时间太长，如果太频繁可能导致运行时的性能问题</strong>。大部分指令的执行时间都非常短暂，通常会根据“<strong>是否具有让程序长时间执行的特征</strong>”为标准。比如：选择一些执行时间较长的指令作为Safe Point，<strong>如方法调用、循环跳转和异常跳转等</strong>。</li></ul><p><strong>如何在GC发生时，检查所有线程都跑到最近的安全点停顿下来呢？</strong></p><ul><li>抢先式中断：（目前没有虚拟机采用了）首先中断所有线程。如果还有线程不在安全点，就恢复线程，让线程跑到安全点。</li><li>主动式中断：设置一个中断标志，各个线程运行到Safe Point的时候<strong>主动轮询</strong>这个标志，如果中断标志为真，则将自己进行中断挂起。</li></ul><h3 id="2-2-安全区域（Safe-Region）"><a href="#2-2-安全区域（Safe-Region）" class="headerlink" title="2.2 安全区域（Safe Region）"></a>2.2 安全区域（Safe Region）</h3><ul><li>Safepoint 机制保证了程序执行时，在不太长的时间内就会遇到可进入GC的Safepoint。但是，程序“不执行”的时候呢？</li><li>例如线程处于Sleep状态或Blocked 状态，这时候线程无法响应JVM的中断请求，“走”到安全点去中断挂起，JVM也不太可能等待线程被唤醒。对于这种情况，就需要安全区域（Safe Region）来解决。</li><li><strong>安全区域是指在一段代码片段中，对象的引用关系不会发生变化，在这个区域中的任何位置开始GC都是安全的</strong>。我们也可以把Safe Region看做是被扩展了的Safepoint。</li></ul><h3 id="2-3-安全区域的执行流程"><a href="#2-3-安全区域的执行流程" class="headerlink" title="2.3 安全区域的执行流程"></a>2.3 安全区域的执行流程</h3><ul><li>当线程运行到Safe Region的代码时，首先标识已经进入了Safe Region，如果这段时间内发生GC，JVM会忽略标识为Safe Region状态的线程</li><li>当线程即将离开Safe Region时，会检查JVM是否已经完成根节点枚举（即GC Roots的枚举），如果完成了，则继续运行，否则线程必须等待直到收到可以安全离开Safe Region的信号为止；</li></ul><h2 id="3-记忆集与卡表"><a href="#3-记忆集与卡表" class="headerlink" title="3. 记忆集与卡表"></a>3. 记忆集与卡表</h2><h3 id="3-1-什么是跨代引用？"><a href="#3-1-什么是跨代引用？" class="headerlink" title="3.1 什么是跨代引用？"></a>3.1 什么是跨代引用？</h3><p>一般的垃圾回收算法至少会划分出两个年代，年轻代和老年代。但是单纯的分代理论在垃圾回收的时候存在一个巨大的缺陷：为了找到年轻代中的存活对象，却不得不遍历整个老年代，反过来也是一样的。</p><p><img src="https://raw.githubusercontent.com/GeorgeChan95/blogimg/master/img/2024/01/15/20240115-190528.png" alt="跨代引用"></p><ul><li>如果我们从年轻代开始遍历，那么可以断定N, S, P, Q都是存活对象。但是，V却不会被认为是存活对象，其占据的内存会被回收了。这就是一个惊天的大漏洞！因为U本身是老年代对象，而且有外部引用指向它，也就是说U是存活对象，而U指向了V，也就是说V也应该是存活对象才是！而这都是因为我们只遍历年轻代对象！</li><li>所以，为了解决这种跨代引用的问题，最笨的办法就是遍历老年代的对象，找出这些跨代引用来。这种方案存在极大的性能浪费。因为从两个分代假说里面，其实隐含了一个推论：跨代引用是极少的。也就是为了找出那么一点点跨代引用，我们却得遍历整个老年代！从上图来说，很显然的是，我们根本不必遍历R。</li><li>因此，为了避免这种遍历老年代的性能开销，通常的分代垃圾回收器会引入一种称为<strong>记忆集</strong>的技术。<strong>简单来说，记忆集就是用来记录跨代引用的表。</strong></li></ul><h3 id="3-2-记忆集与卡表"><a href="#3-2-记忆集与卡表" class="headerlink" title="3.2 记忆集与卡表"></a>3.2 记忆集与卡表</h3><ul><li><p>为解决对象跨代引用所带来的问题，垃圾收集器在新生代中建 立了名为<strong>记忆集（Remembered Set）的数据结构</strong>，用以避免把整个老年代加进GC Roots扫描范围。事实上并不只是新生代、老年代之间才有跨代引用的问题，所有涉及部分区域收集（Partial GC）行为的 垃圾收集器，典型的如G1、ZGC和Shenandoah收集器，都会面临相同的问题，因此我们有必要进一步 理清记忆集的原理和实现方式，以便在后续章节里介绍几款最新的收集器相关知识时能更好地理解。</p></li><li><p>记忆集是一种用于记录<strong>从非收集区域指向收集区域的指针集合的抽象数据结构</strong>。如果我们不考虑效率和成本的话，最简单的实现可以用非收集区域中所有含跨代引用的对象数组来实现这个数据结构。</p><p>比如说我们有老年代（非收集区域）和年轻代（收集区域）的对象之间有一条引用链</p></li><li><p>这种记录全部含跨代引用对象的实现方案，无论是空间占用还是维护成本都相当高昂。而在垃圾收集的场景中，收集器只需要通过记忆集判断出某一块非收集区域是否存在有指向了收集区域的指针就可以了，并不需要了解这些跨代指针的全部细节。那设计者在实现记忆集的时候，便可以选择更为 粗犷的记录粒度来节省记忆集的存储和维护成本，下面列举了一些可供选择（当然也可以选择这个范 围以外的）的记录精度：</p><ul><li>字长精度：每个记录精确到一个机器字长（就是处理器的寻址位数，如常见的32位或64位，这个 精度决定了机器访问物理内存地址的指针长度），该字包含跨代指针。</li><li>对象精度：每个记录精确到一个对象，该对象里有字段含有跨代指针。</li><li>卡精度：每个记录精确到一块内存区域，该区域内有对象含有跨代指针。</li></ul></li><li><p>其中，第三种“卡精度”所指的是用一种称为“卡表”（Card Table）的方式去实现记忆集，这也是 目前最常用的一种记忆集实现形式，一些资料中甚至直接把它和记忆集混为一谈。前面定义中提到记 忆集其实是一种“抽象”的数据结构，抽象的意思是只定义了记忆集的行为意图，并没有定义其行为的 具体实现。卡表就是记忆集的一种具体实现，它定义了记忆集的记录精度、与堆内存的映射关系等。 关于卡表与记忆集的关系，读者不妨按照Java语言中HashMap与Map的关系来类比理解。 卡表最简单的形式可以只是一个字节数组，而HotSpot虚拟机确实也是这样做的</p></li></ul><blockquote><p>更多关于记忆集与卡表，见：<a href="https://developer.aliyun.com/article/1097566">https://developer.aliyun.com/article/1097566</a></p></blockquote><h1 id="六、再谈引用概述"><a href="#六、再谈引用概述" class="headerlink" title="六、再谈引用概述"></a>六、再谈引用概述</h1><ul><li>我们希望能描述这样一类对象：当内存空间还足够时，则能保留在内存中；如果内存空间在进行垃圾收集后还是很紧张，则可以抛弃这些对象。</li><li>既偏门又非常高频的面试题：强引用、软引用、弱引用、虚引用有什么区别？具体使用场景是什么？</li><li>在JDK1.2版之后，Java对引用的概念进行了扩充，将引用分为：<ul><li>强引用（Strong Reference）</li><li>软引用（Soft Reference）</li><li>弱引用（Weak Reference）</li><li>虚引用（Phantom Reference）</li></ul></li><li>这4种引用强度依次逐渐减弱。除强引用外，其他3种引用均可以在java.lang.ref包中找到它们的身影。如下图，显示了这3种引用类型对应的类，开发人员可以在应用程序中直接使用它们。</li></ul><p><img src="https://raw.githubusercontent.com/GeorgeChan95/blogimg/master/img/2024/01/15/20240115-192923.png" alt="Reference"></p><p>Reference子类中只有终结器引用是包内可见的，其他3种引用类型均为public，可以在应用程序中直接使用</p><ul><li>强引用（StrongReference）：最传统的“引用”的定义，是指在程序代码之中普遍存在的引用赋值，即类似“<code>object obj=new Object()</code>”这种引用关系。无论任何情况下，只要强引用关系还存在，垃圾收集器就永远不会回收掉被引用的对象。宁可报OOM，也不会GC强引用</li><li>软引用（SoftReference）：在系统将要发生内存溢出之前，将会把这些对象列入回收范围之中进行第二次回收。如果这次回收后还没有足够的内存，才会抛出内存溢出异常。</li><li>弱引用（WeakReference）：被弱引用关联的对象只能生存到下一次垃圾收集之前。当垃圾收集器工作时，无论内存空间是否足够，都会回收掉被弱引用关联的对象。</li><li>虚引用（PhantomReference）：一个对象是否有虚引用的存在，完全不会对其生存时间构成影响，也无法通过虚引用来获得一个对象的实例。为一个对象设置虚引用关联的唯一目的就是能在这个对象被收集器回收时收到一个系统通知。</li></ul><h1 id="七、再谈引用：强引用"><a href="#七、再谈引用：强引用" class="headerlink" title="七、再谈引用：强引用"></a>七、再谈引用：强引用</h1><ul><li>在Java程序中，最常见的引用类型是强引用（普通系统99%以上都是强引用），也就是我们最常见的普通对象引用，<strong>也是默认的引用类型</strong>。</li><li>当在Java语言中使用new操作符创建一个新的对象，并将其赋值给一个变量的时候，这个变量就成为指向该对象的一个强引用。</li><li><strong>只要强引用的对象是可触及的，垃圾收集器就永远不会回收掉被引用的对象。</strong>只要强引用的对象是可达的，jvm宁可报OOM，也不会回收强引用。</li><li>对于一个普通的对象，如果没有其他的引用关系，只要超过了引用的作用域或者显式地将相应（强）引用赋值为null，就是可以当做垃圾被收集了，当然具体回收时机还是要看垃圾收集策略。</li><li>相对的，软引用、弱引用和虚引用的对象是软可触及、弱可触及和虚可触及的，在一定条件下，都是可以被回收的。所以，强引用是造成Java内存泄漏的主要原因之一。</li></ul><blockquote><p>代码示例：</p></blockquote><pre><code class="highlight java"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">StrongReferenceTest</span> &#123;    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;        <span class="type">StringBuffer</span> <span class="variable">str</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">StringBuffer</span> (<span class="string">&quot;Hello,尚硅谷&quot;</span>);        <span class="type">StringBuffer</span> <span class="variable">str1</span> <span class="operator">=</span> str;        str = <span class="literal">null</span>;        System.gc();        <span class="keyword">try</span> &#123;            Thread.sleep(<span class="number">3000</span>);        &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;            e.printStackTrace();        &#125;        System.out.println(str1);    &#125;&#125;</code></pre><blockquote><p>执行结果</p></blockquote><pre><code class="highlight plaintext">Hello,尚硅谷</code></pre><p>局部变量str指向stringBuffer实例所在堆空间，通过str可以操作该实例，那么str就是stringBuffer实例的强引用对应内存结构：</p><p><code>StringBuffer str = new StringBuffer(&quot;hello,尚硅谷&quot;);</code></p><p><img src="https://raw.githubusercontent.com/GeorgeChan95/blogimg/master/img/2024/01/15/20240115-193647.png" alt="image-20240115193646523"></p><p><strong>总结</strong></p><p>本例中的两个引用，都是强引用，强引用具备以下特点：</p><ul><li>强引用可以直接访问目标对象。</li><li>强引用所指向的对象在任何时候都不会被系统回收，虚拟机宁愿抛出OOM异常，也不会回收强引用所指向对象。</li><li>强引用可能导致内存泄漏。</li></ul><h1 id="八、再谈引用：软引用"><a href="#八、再谈引用：软引用" class="headerlink" title="八、再谈引用：软引用"></a>八、再谈引用：软引用</h1><p><strong>软引用（Soft Reference）：内存不足即回收</strong></p><ul><li>软引用是用来描述一些还有用，但非必需的对象。只被软引用关联着的对象，在系统将要发生内存溢出异常前，会把这些对象列进回收范围之中进行第二次回收，如果这次回收还没有足够的内存，才会抛出内存溢出异常。注意，这里的第一次回收是不可达的对象</li><li>软引用通常用来实现内存敏感的缓存。比如：高速缓存就有用到软引用。如果还有空闲内存，就可以暂时保留缓存，当内存不足时清理掉，这样就保证了使用缓存的同时，不会耗尽内存。</li><li>垃圾回收器在某个时刻决定回收软可达的对象的时候，会清理软引用，并可选地把引用存放到一个引用队列（Reference Queue）。</li><li>类似弱引用，只不过Java虚拟机会尽量让软引用的存活时间长一些，迫不得已才清理。</li><li>一句话概括：当内存足够时，不会回收软引用可达的对象。内存不够时，会回收软引用的可达对象</li></ul><p>在JDK1.2版之后提供了SoftReference类来实现软引用</p><pre><code class="highlight java"><span class="type">Object</span> <span class="variable">obj</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Object</span>();<span class="comment">// 声明强引用</span>SoftReference&lt;Object&gt; sf = <span class="keyword">new</span> <span class="title class_">SoftReference</span>&lt;&gt;(obj);obj = <span class="literal">null</span>; <span class="comment">//销毁强引用</span></code></pre><blockquote><p>代码示例</p></blockquote><pre><code class="highlight java"><span class="comment">/**</span><span class="comment"> * 软引用的测试：内存不足即回收</span><span class="comment"> * -Xms10m -Xmx10m</span><span class="comment"> */</span><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">SoftReferenceTest</span> &#123;    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">class</span> <span class="title class_">User</span> &#123;        <span class="keyword">public</span> <span class="title function_">User</span><span class="params">(<span class="type">int</span> id, String name)</span> &#123;            <span class="built_in">this</span>.id = id;            <span class="built_in">this</span>.name = name;        &#125;        <span class="keyword">public</span> <span class="type">int</span> id;        <span class="keyword">public</span> String name;        <span class="meta">@Override</span>        <span class="keyword">public</span> String <span class="title function_">toString</span><span class="params">()</span> &#123;            <span class="keyword">return</span> <span class="string">&quot;[id=&quot;</span> + id + <span class="string">&quot;, name=&quot;</span> + name + <span class="string">&quot;] &quot;</span>;        &#125;    &#125;    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;        <span class="comment">//创建对象，建立软引用</span><span class="comment">//        SoftReference&lt;User&gt; userSoftRef = new SoftReference&lt;User&gt;(new User(1, &quot;songhk&quot;));</span>        <span class="comment">//上面的一行代码，等价于如下的三行代码</span>        <span class="type">User</span> <span class="variable">u1</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">User</span>(<span class="number">1</span>,<span class="string">&quot;songhk&quot;</span>);        SoftReference&lt;User&gt; userSoftRef = <span class="keyword">new</span> <span class="title class_">SoftReference</span>&lt;User&gt;(u1);        u1 = <span class="literal">null</span>;<span class="comment">//取消强引用</span>        <span class="comment">//从软引用中重新获得强引用对象</span>        System.out.println(userSoftRef.get());        System.gc();        System.out.println(<span class="string">&quot;After GC:&quot;</span>);<span class="comment">//        //垃圾回收之后获得软引用中的对象</span>        System.out.println(userSoftRef.get());<span class="comment">//由于堆空间内存足够，所有不会回收软引用的可达对象。</span><span class="comment">//</span>        <span class="keyword">try</span> &#123;            <span class="comment">//让系统认为内存资源紧张、不够</span>            <span class="type">byte</span>[] b = <span class="keyword">new</span> <span class="title class_">byte</span>[<span class="number">1024</span> * <span class="number">7168</span> - <span class="number">580</span> * <span class="number">1024</span>];        &#125; <span class="keyword">catch</span> (Throwable e) &#123;            e.printStackTrace();        &#125; <span class="keyword">finally</span> &#123;            <span class="comment">//再次从软引用中获取数据</span>            System.out.println(userSoftRef.get());<span class="comment">//在报OOM之前，垃圾回收器会回收软引用的可达对象。</span>        &#125;    &#125;&#125;</code></pre><blockquote><p>JVM参数：-Xms10m -Xmx10m</p></blockquote><p>在 JVM 内存不足时，会清理软引用对象</p><blockquote><p>输出结果</p></blockquote><pre><code class="highlight plaintext">[id=1, name=songhk] After GC:[id=1, name=songhk] nulljava.lang.OutOfMemoryError: Java heap spaceat com.atguigu.java1.SoftReferenceTest.main(SoftReferenceTest.java:44)</code></pre><h1 id="九、再谈引用：弱引用"><a href="#九、再谈引用：弱引用" class="headerlink" title="九、再谈引用：弱引用"></a>九、再谈引用：弱引用</h1><p><strong>弱引用（Weak Reference）发现即回收</strong></p><ul><li>弱引用也是用来描述那些非必需对象，<strong>只被弱引用关联的对象只能生存到下一次垃圾收集发生为止。在系统GC时，只要发现弱引用，不管系统堆空间使用是否充足，都会回收掉只被弱引用关联的对象</strong>。</li><li>但是，由于垃圾回收器的线程通常优先级很低，因此，并不一定能很快地发现持有弱引用的对象。在这种情况下，弱引用对象可以存在较长的时间。</li><li>弱引用和软引用一样，在构造弱引用时，也可以指定一个引用队列，当弱引用对象被回收时，就会加入指定的引用队列，通过这个队列可以跟踪对象的回收情况。</li><li>软引用、弱引用都非常适合来保存那些可有可无的缓存数据。如果这么做，当系统内存不足时，这些缓存数据会被回收，不会导致内存溢出。而当内存资源充足时，这些缓存数据又可以存在相当长的时间，从而起到加速系统的作用。</li></ul><p>在JDK1.2版之后提供了WeakReference类来实现弱引用</p><pre><code class="highlight java"><span class="comment">// 声明强引用</span><span class="type">Object</span> <span class="variable">obj</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Object</span>();WeakReference&lt;Object&gt; sf = <span class="keyword">new</span> <span class="title class_">WeakReference</span>&lt;&gt;(obj);obj = <span class="literal">null</span>; <span class="comment">//销毁强引用</span></code></pre><p>弱引用对象与软引用对象的最大不同就在于，当GC在进行回收时，需要通过算法检查是否回收软引用对象，而对于弱引用对象，GC总是进行回收。弱引用对象更容易、更快被GC回收。</p><blockquote><p>代码示例</p></blockquote><pre><code class="highlight java"><span class="comment">/**</span><span class="comment"> * 弱引用的测试</span><span class="comment"> */</span><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">WeakReferenceTest</span> &#123;    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">class</span> <span class="title class_">User</span> &#123;        <span class="keyword">public</span> <span class="title function_">User</span><span class="params">(<span class="type">int</span> id, String name)</span> &#123;            <span class="built_in">this</span>.id = id;            <span class="built_in">this</span>.name = name;        &#125;        <span class="keyword">public</span> <span class="type">int</span> id;        <span class="keyword">public</span> String name;        <span class="meta">@Override</span>        <span class="keyword">public</span> String <span class="title function_">toString</span><span class="params">()</span> &#123;            <span class="keyword">return</span> <span class="string">&quot;[id=&quot;</span> + id + <span class="string">&quot;, name=&quot;</span> + name + <span class="string">&quot;] &quot;</span>;        &#125;    &#125;    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;        <span class="comment">//构造了弱引用</span>        WeakReference&lt;User&gt; userWeakRef = <span class="keyword">new</span> <span class="title class_">WeakReference</span>&lt;User&gt;(<span class="keyword">new</span> <span class="title class_">User</span>(<span class="number">1</span>, <span class="string">&quot;songhk&quot;</span>));        <span class="comment">//从弱引用中重新获取对象</span>        System.out.println(userWeakRef.get());        System.gc();        <span class="comment">// 不管当前内存空间足够与否，都会回收它的内存</span>        System.out.println(<span class="string">&quot;After GC:&quot;</span>);        <span class="comment">//重新尝试从弱引用中获取对象</span>        System.out.println(userWeakRef.get());    &#125;&#125;</code></pre><p>执行垃圾回收后，软引用对象必定被清除</p><blockquote><p>输出结果</p></blockquote><pre><code class="highlight plaintext">[id=1, name=songhk] After GC:null</code></pre><h1 id="十、再谈引用：虚引用"><a href="#十、再谈引用：虚引用" class="headerlink" title="十、再谈引用：虚引用"></a>十、再谈引用：虚引用</h1><p><strong>虚引用（Phantom Reference）：对象回收跟踪</strong></p><ul><li>也称为“幽灵引用”或者“幻影引用”，是所有引用类型中最弱的一个</li><li>一个对象是否有虚引用的存在，完全不会决定对象的生命周期。如果一个对象仅持有虚引用，那么它和没有引用几乎是一样的，随时都可能被垃圾回收器回收。</li><li>它不能单独使用，也无法通过虚引用来获取被引用的对象。当试图通过虚引用的get()方法取得对象时，总是null 。<strong>即通过虚引用无法获取到我们的数据</strong></li><li><strong>为一个对象设置虚引用关联的唯一目的在于跟踪垃圾回收过程。比如：能在这个对象被收集器回收时收到一个系统通知。</strong></li><li>虚引用必须和引用队列一起使用。虚引用在创建时必须提供一个引用队列作为参数。当垃圾回收器准备回收一个对象时，如果发现它还有虚引用，就会在回收对象后，将这个虚引用加入引用队列，以通知应用程序对象的回收情况。</li><li>由于虚引用可以跟踪对象的回收时间，因此，也可以将一些资源释放操作放置在虚引用中执行和记录。</li></ul><p>在JDK1.2版之后提供了PhantomReference类来实现虚引用。</p><pre><code class="highlight java"><span class="comment">// 声明强引用</span><span class="type">Object</span> <span class="variable">obj</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Object</span>();<span class="comment">// 声明引用队列</span><span class="type">ReferenceQueue</span> <span class="variable">phantomQueue</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ReferenceQueue</span>();<span class="comment">// 声明虚引用（还需要传入引用队列）</span>PhantomReference&lt;Object&gt; sf = <span class="keyword">new</span> <span class="title class_">PhantomReference</span>&lt;&gt;(obj, phantomQueue);obj = <span class="literal">null</span>;</code></pre><blockquote><p>代码示例</p></blockquote><pre><code class="highlight java"><span class="comment">/**</span><span class="comment"> * 虚引用的测试</span><span class="comment"> */</span><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">PhantomReferenceTest</span> &#123;    <span class="keyword">public</span> <span class="keyword">static</span> PhantomReferenceTest obj;<span class="comment">//当前类对象的声明</span>    <span class="keyword">static</span> ReferenceQueue&lt;PhantomReferenceTest&gt; phantomQueue = <span class="literal">null</span>;<span class="comment">//引用队列</span>    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">class</span> <span class="title class_">CheckRefQueue</span> <span class="keyword">extends</span> <span class="title class_">Thread</span> &#123;        <span class="meta">@Override</span>        <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span> &#123;            <span class="keyword">while</span> (<span class="literal">true</span>) &#123;                <span class="keyword">if</span> (phantomQueue != <span class="literal">null</span>) &#123;                    PhantomReference&lt;PhantomReferenceTest&gt; objt = <span class="literal">null</span>;                    <span class="keyword">try</span> &#123;                        objt = (PhantomReference&lt;PhantomReferenceTest&gt;) phantomQueue.remove();                    &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;                        e.printStackTrace();                    &#125;                    <span class="keyword">if</span> (objt != <span class="literal">null</span>) &#123;                        System.out.println(<span class="string">&quot;追踪垃圾回收过程：PhantomReferenceTest实例被GC了&quot;</span>);                    &#125;                &#125;            &#125;        &#125;    &#125;    <span class="meta">@Override</span>    <span class="keyword">protected</span> <span class="keyword">void</span> <span class="title function_">finalize</span><span class="params">()</span> <span class="keyword">throws</span> Throwable &#123; <span class="comment">//finalize()方法只能被调用一次！</span>        <span class="built_in">super</span>.finalize();        System.out.println(<span class="string">&quot;调用当前类的finalize()方法&quot;</span>);        obj = <span class="built_in">this</span>;    &#125;    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;        <span class="type">Thread</span> <span class="variable">t</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">CheckRefQueue</span>();        t.setDaemon(<span class="literal">true</span>);<span class="comment">//设置为守护线程：当程序中没有非守护线程时，守护线程也就执行结束。</span>        t.start();        phantomQueue = <span class="keyword">new</span> <span class="title class_">ReferenceQueue</span>&lt;PhantomReferenceTest&gt;();        obj = <span class="keyword">new</span> <span class="title class_">PhantomReferenceTest</span>();        <span class="comment">//构造了 PhantomReferenceTest 对象的虚引用，并指定了引用队列</span>        PhantomReference&lt;PhantomReferenceTest&gt; phantomRef = <span class="keyword">new</span> <span class="title class_">PhantomReference</span>&lt;PhantomReferenceTest&gt;(obj, phantomQueue);        <span class="keyword">try</span> &#123;            <span class="comment">//不可获取虚引用中的对象</span>            System.out.println(phantomRef.get());            <span class="comment">//将强引用去除</span>            obj = <span class="literal">null</span>;            <span class="comment">//第一次进行GC,由于对象可复活，GC无法回收该对象</span>            System.gc();            Thread.sleep(<span class="number">1000</span>);            <span class="keyword">if</span> (obj == <span class="literal">null</span>) &#123;                System.out.println(<span class="string">&quot;obj 是 null&quot;</span>);            &#125; <span class="keyword">else</span> &#123;                System.out.println(<span class="string">&quot;obj 可用&quot;</span>);            &#125;            System.out.println(<span class="string">&quot;第 2 次 gc&quot;</span>);            obj = <span class="literal">null</span>;            System.gc(); <span class="comment">//一旦将obj对象回收，就会将此虚引用存放到引用队列中。</span>            Thread.sleep(<span class="number">1000</span>);            <span class="keyword">if</span> (obj == <span class="literal">null</span>) &#123;                System.out.println(<span class="string">&quot;obj 是 null&quot;</span>);            &#125; <span class="keyword">else</span> &#123;                System.out.println(<span class="string">&quot;obj 可用&quot;</span>);            &#125;        &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;            e.printStackTrace();        &#125;    &#125;&#125;</code></pre><p>1、第一次尝试获取虚引用的值，发现无法获取的，这是因为虚引用是无法直接获取对象的值，然后进行第一次GC，因为会调用finalize方法，将对象复活了，所以对象没有被回收</p><p>2、但是调用第二次GC操作的时候，因为finalize方法只能执行一次，所以就触发了GC操作，将对象回收了，同时将会触发第二个操作就是将待回收的对象存入到引用队列中。</p><blockquote><p>输出结果</p></blockquote><pre><code class="highlight plaintext">null调用当前类的finalize()方法obj 可用第 2 次 gc追踪垃圾回收过程：PhantomReferenceTest实例被GC了obj 是 null</code></pre><h1 id="十一、再谈引用：终结器引用（了解）"><a href="#十一、再谈引用：终结器引用（了解）" class="headerlink" title="十一、再谈引用：终结器引用（了解）"></a>十一、再谈引用：终结器引用（了解）</h1><ul><li>它用于实现对象的finalize() 方法，也可以称为终结器引用</li><li>无需手动编码，其内部配合引用队列使用</li><li>在GC时，终结器引用入队。由Finalizer线程通过终结器引用找到被引用对象调用它的finalize()方法，第二次GC时才回收被引用的对象</li></ul><h1 id="参考链接"><a href="#参考链接" class="headerlink" title="参考链接"></a>参考链接</h1><blockquote><p>安全点和安全区域：</p><ul><li><a href="https://zhuanlan.zhihu.com/p/461298916">https://zhuanlan.zhihu.com/p/461298916</a></li><li><a href="https://www.cnblogs.com/chenchuxin/p/15259439.html">https://www.cnblogs.com/chenchuxin/p/15259439.html</a></li></ul><p>记忆集与卡表：</p><ul><li><a href="https://developer.aliyun.com/article/1097566">https://developer.aliyun.com/article/1097566</a></li></ul></blockquote>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;一、System-gc-的理解&quot;&gt;&lt;a href=&quot;#一、System-gc-的理解&quot; class=&quot;headerlink&quot; title=&quot;一、System.gc() 的理解&quot;&gt;&lt;/a&gt;一、System.gc() 的理解&lt;/h1&gt;&lt;ul&gt;
&lt;li&gt;在默认情况下，通</summary>
      
    
    
    
    <category term="JVM" scheme="https://georgechan95.github.io/categories/JVM/"/>
    
    
    <category term="jvm" scheme="https://georgechan95.github.io/tags/jvm/"/>
    
    <category term="java" scheme="https://georgechan95.github.io/tags/java/"/>
    
  </entry>
  
  <entry>
    <title>第十二章-垃圾回收概述和相关算法</title>
    <link href="https://georgechan95.github.io/2024/01/06/jvm/%E7%AC%AC%E5%8D%81%E4%BA%8C%E7%AB%A0-%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6%E6%A6%82%E8%BF%B0/"/>
    <id>https://georgechan95.github.io/2024/01/06/jvm/%E7%AC%AC%E5%8D%81%E4%BA%8C%E7%AB%A0-%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6%E6%A6%82%E8%BF%B0/</id>
    <published>2024-01-06T08:28:00.000Z</published>
    <updated>2024-06-22T10:36:12.823Z</updated>
    
    <content type="html"><![CDATA[<h1 id="一、垃圾回收概述"><a href="#一、垃圾回收概述" class="headerlink" title="一、垃圾回收概述"></a>一、垃圾回收概述</h1><p>​<img src="https://raw.githubusercontent.com/GeorgeChan95/blogimg/master/img/2024/01/08/20240108-132239.png" alt="image-20240108132235061"></p><ul><li>Java 和 C++ 语言的区别，就在于垃圾收集技术和内存动态分配上，C++语言没有垃圾收集技术，需要程序员手动的收集。</li><li>垃圾收集，不是Java语言的伴生产物。早在1960年，第一门开始使用内存动态分配和垃圾收集技术的Lisp语言诞生。</li><li>关于垃圾收集有三个经典问题：<ul><li>哪些内存需要回收？</li><li>什么时候回收？</li><li>如何回收？</li></ul></li><li>垃圾收集机制是Java的招牌能力，极大地提高了开发效率。如今，垃圾收集几乎成为现代语言的标配，即使经过如此长时间的发展，Java的垃圾收集机制仍然在不断的演进中，不同大小的设备、不同特征的应用场景，对垃圾收集提出了新的挑战，这当然也是面试的热点。</li></ul><h2 id="1-什么是垃圾？"><a href="#1-什么是垃圾？" class="headerlink" title="1. 什么是垃圾？"></a>1. 什么是垃圾？</h2><ul><li>垃圾是指<strong>在运行程序中没有任何指针指向的对象</strong>，这个对象就是需要被回收的垃圾。</li><li>如果不及时对内存中的垃圾进行清理，那么，这些垃圾对象所占的内存空间会一直保留到应用程序结束，被保留的空间无法被其他对象使用。甚至可能导致内存溢出。</li></ul><h2 id="2-为什么需要GC？"><a href="#2-为什么需要GC？" class="headerlink" title="2. 为什么需要GC？"></a>2. 为什么需要GC？</h2><p><strong>想要学习GC，首先需要理解为什么需要GC？</strong></p><ul><li>对于高级语言来说，一个基本认知是如果不进行垃圾回收，<strong>内存迟早都会被消耗完</strong>，因为不断地分配内存空间而不进行回收，就好像不停地生产生活垃圾而从来不打扫一样。</li><li>除了释放没用的对象，垃圾回收也可以清除内存里的记录碎片。碎片整理将所占用的堆内存移到堆的一端，<strong>以便JVM将整理出的内存分配给新的对象</strong>。</li><li>随着应用程序所应付的业务越来越庞大、复杂，用户越来越多，<strong>没有GC就不能保证应用程序的正常进行</strong>。而经常造成STW的GC又跟不上实际的需求，所以才会不断地尝试对GC进行优化。</li></ul><h2 id="3-早期垃圾回收"><a href="#3-早期垃圾回收" class="headerlink" title="3. 早期垃圾回收"></a>3. 早期垃圾回收</h2><ul><li><p>在早期的C&#x2F;C++时代，垃圾回收基本上是手工进行的。开发人员可以使用new关键字进行内存申请，并使用delete关键字进行内存释放。比如以下代码：</p><pre><code class="highlight c++">MibBridge *pBridge= <span class="keyword">new</span> cmBaseGroupBridge（）；<span class="comment">//如果注册失败，使用Delete释放该对象所占内存区域</span><span class="keyword">if</span>（pBridge-&gt;Register（kDestroy）！=NO ERROR）<span class="keyword">delete</span> pBridge；</code></pre></li><li><p>这种方式可以灵活控制内存释放的时间，但是会给开发人员带来<strong>频繁申请和释放内存的管理负担</strong>。倘若有一处内存区间由于程序员编码的问题忘记被回收，那么就会产生<strong>内存泄漏</strong>，垃圾对象永远无法被清除，随着系统运行时间的不断增长，垃圾对象所耗内存可能持续上升，直到出现内存溢出并造成<strong>应用程序崩溃</strong>。</p></li><li><p>有了垃圾回收机制后，上述代码极有可能变成这样</p><pre><code class="highlight c++">MibBridge *pBridge=<span class="keyword">new</span> <span class="built_in">cmBaseGroupBridge</span>(); pBridge-&gt;<span class="built_in">Register</span>(kDestroy);</code></pre></li><li><p>现在，除了Java以外，C#、Python、Ruby等语言都使用了自动垃圾回收的思想，也是未来发展趋势，可以说这种自动化的内存分配和回收方式已经成为了现代开发语言必备的标准。</p></li></ul><h2 id="4-Java-垃圾回收机制"><a href="#4-Java-垃圾回收机制" class="headerlink" title="4. Java 垃圾回收机制"></a>4. Java 垃圾回收机制</h2><h3 id="4-1-自动内存管理"><a href="#4-1-自动内存管理" class="headerlink" title="4.1 自动内存管理"></a>4.1 自动内存管理</h3><blockquote><p>官网介绍：<a href="https://docs.oracle.com/javase/8/docs/technotes/guides/vm/gctuning/toc.html">https://docs.oracle.com/javase/8/docs/technotes/guides/vm/gctuning/toc.html</a></p></blockquote><p><strong>自动内存管理的优点</strong></p><ul><li>自动内存管理，无需开发人员手动参与内存的分配与回收，这样降低内存泄漏和内存溢出的风险</li><li>没有垃圾回收器，java也会和cpp一样，各种悬垂指针，野指针，泄露问题让你头疼不已。</li><li>自动内存管理机制，将程序员从繁重的内存管理中释放出来，可以更专心地专注于业务开发</li></ul><p><strong>关于自动内存管理的担忧</strong></p><ul><li>对于Java开发人员而言，自动内存管理就像是一个黑匣子，如果过度依赖于“自动”，那么这将会是一场灾难，最严重的就会<strong>弱化Java开发人员在程序出现内存溢出时定位问题和解决问题的能力</strong>。</li><li>此时，了解JVM的自动内存分配和内存回收原理就显得非常重要，只有在真正了解JVM是如何管理内存后，我们才能够在遇见OutofMemoryError时，快速地根据错误异常日志定位问题和解决问题。</li><li>当需要排查各种内存溢出、内存泄漏问题时，当垃圾收集成为系统达到更高并发量的瓶颈时，我们就必须对这些“自动化”的技术<strong>实施必要的监控和调节</strong>。</li></ul><h3 id="4-2-应该关心哪些区域的回收？"><a href="#4-2-应该关心哪些区域的回收？" class="headerlink" title="4.2 应该关心哪些区域的回收？"></a>4.2 应该关心哪些区域的回收？</h3><p><img src="https://raw.githubusercontent.com/GeorgeChan95/blogimg/master/img/2024/01/08/20240108-141026.png" alt="image-20240108141024844"></p><ul><li>垃圾收集器可以对年轻代回收，也可以对老年代回收，甚至是全栈和方法区的回收，其中，<strong>Java堆是垃圾收集器的工作重点</strong></li><li>从次数上讲：<ul><li>频繁收集Young区</li><li>较少收集Old区</li><li>基本不收集Perm区（元空间）</li></ul></li></ul><h1 id="二、垃圾回收相关算法"><a href="#二、垃圾回收相关算法" class="headerlink" title="二、垃圾回收相关算法"></a>二、垃圾回收相关算法</h1><h2 id="1-标记阶段：引用计数算法"><a href="#1-标记阶段：引用计数算法" class="headerlink" title="1. 标记阶段：引用计数算法"></a>1. 标记阶段：引用计数算法</h2><h3 id="1-1-标记阶段的目的"><a href="#1-1-标记阶段的目的" class="headerlink" title="1.1 标记阶段的目的"></a>1.1 标记阶段的目的</h3><p><strong>垃圾标记阶段：主要是为了判断对象是否存活</strong></p><ul><li>在堆里存放着几乎所有的Java对象实例，在GC执行垃圾回收之前，首先<strong>需要区分出内存中哪些是存活对象，哪些是已经死亡的对象。</strong>只有被标记为己经死亡的对象，GC才会在执行垃圾回收时，释放掉其所占用的内存空间，因此这个过程我们可以称为<strong>垃圾标记阶段</strong>。</li><li>那么在JVM中究竟是如何标记一个死亡对象呢？简单来说，当一个对象已经不再被任何的存活对象继续引用时，就可以宣判为已经死亡。</li><li>判断对象存活一般有两种方式：<strong>引用计数算法</strong>和<strong>可达性分析算法</strong>。</li></ul><h3 id="1-2-引用计数算法"><a href="#1-2-引用计数算法" class="headerlink" title="1.2 引用计数算法"></a>1.2 引用计数算法</h3><ul><li>引用计数算法（Reference Counting）比较简单，对每个对象保存一个整型的引用计数器属性。用于记录对象被引用的情况。</li><li>对于一个对象A，只要有任何一个对象引用了A，则A的引用计数器就加1；当引用失效时，引用计数器就减1。只要对象A的引用计数器的值为0，即表示对象A不可能再被使用，可进行回收。</li><li>优点：实现简单，垃圾对象便于辨识；判定效率高，回收没有延迟性。</li><li>缺点：<ul><li>它需要单独的字段存储计数器，这样的做法增加了<strong>存储空间的开销</strong>。</li><li>每次赋值都需要更新计数器，伴随着加法和减法操作，这增加了<strong>时间开销</strong>。</li><li>引用计数器有一个严重的问题，即<strong>无法处理循环引用</strong>的情况。这是一条致命缺陷，导致在Java的垃圾回收器中没有使用这类算法。</li></ul></li></ul><h3 id="1-3-循环引用"><a href="#1-3-循环引用" class="headerlink" title="1.3 循环引用"></a>1.3 循环引用</h3><p>当p的指针断开的时候，内部的引用形成一个循环，计数器都还算1，无法被回收，这就是循环引用，从而造成内存泄漏</p><p><img src="https://raw.githubusercontent.com/GeorgeChan95/blogimg/master/img/2024/01/08/20240108-142409.png" alt="image-20240108142407770"></p><h3 id="1-4-小结"><a href="#1-4-小结" class="headerlink" title="1.4 小结"></a>1.4 小结</h3><ul><li>引用计数算法，是很多语言的资源回收选择，例如因人工智能而更加火热的Python，它更是同时支持引用计数和垃圾收集机制。</li><li>具体哪种最优是要看场景的，业界有大规模实践中仅保留引用计数机制，以提高吞吐量的尝试。</li><li>Java并没有选择引用计数，是因为其存在一个基本的难题，也就是很难处理循环引用关系。</li><li>Python如何解决循环引用？<ul><li>手动解除：很好理解，就是在合适的时机，解除引用关系。</li><li>使用弱引用weakref，weakref是Python提供的标准库，旨在解决循环引用。</li></ul></li></ul><h2 id="2-标记阶段：可达性分析算法"><a href="#2-标记阶段：可达性分析算法" class="headerlink" title="2. 标记阶段：可达性分析算法"></a>2. 标记阶段：可达性分析算法</h2><p><strong>可达性分析算法：也可以称为根搜索算法、追踪性垃圾收集</strong></p><ul><li>相对于引用计数算法而言，可达性分析算法不仅同样具备实现简单和执行高效等特点，更重要的是该算法可以有效地<strong>解决在引用计数算法中循环引用的问题，防止内存泄漏的发生</strong>。</li><li>相较于引用计数算法，这里的可达性分析就是Java、C#选择的。这种类型的垃圾收集通常也叫作<strong>追踪性垃圾收集</strong>（Tracing Garbage Collection）</li></ul><h3 id="2-1-可达性分析实现思路"><a href="#2-1-可达性分析实现思路" class="headerlink" title="2.1 可达性分析实现思路"></a>2.1 可达性分析实现思路</h3><ul><li>所谓”GCRoots”根集合就是一组必须活跃的引用</li><li>其基本思路如下：<ul><li>可达性分析算法是以根对象集合（GCRoots）为起始点，按照从上至下的方式<strong>搜索被根对象集合所连接的目标对象是否可达。</strong></li><li>使用可达性分析算法后，内存中的存活对象都会被根对象集合直接或间接连接着，搜索所走过的路径称为<strong>引用链</strong>（Reference Chain）</li><li>如果目标对象没有任何引用链相连，则是不可达的，就意味着该对象己经死亡，可以标记为垃圾对象。</li><li>在可达性分析算法中，只有能够被根对象集合直接或者间接连接的对象才是存活对象。</li></ul></li></ul><p><img src="https://raw.githubusercontent.com/GeorgeChan95/blogimg/master/img/2024/01/08/20240108-143822.png" alt="image-20240108143820878"></p><h3 id="2-2-GC-Roots可以是哪些元素？"><a href="#2-2-GC-Roots可以是哪些元素？" class="headerlink" title="2.2 GC Roots可以是哪些元素？"></a>2.2 GC Roots可以是哪些元素？</h3><ol><li>虚拟机栈中引用的对象（栈帧中的本地变量表）<ol><li>比如：各个线程被调用的方法中使用到的参数、局部变量等。</li></ol></li><li>本地方法栈内JNI（通常说的本地方法）引用的对象</li><li>法区中类静态属性引用的对象<ol><li>比如：Java类的引用类型静态变量</li></ol></li><li>方法区中常量引用的对象<ol><li>比如：字符串常量池（StringTable）里的引用</li></ol></li><li>所有被同步锁synchronized持有的对象</li><li>Java虚拟机内部的引用。<ol><li>基本数据类型对应的Class对象，一些常驻的异常对象（如：NullPointerException、OutofMemoryError），系统类加载器。</li></ol></li><li>反映java虚拟机内部情况的JMXBean、JVMTI中注册的回调、本地代码缓存等。</li></ol><p>除了这些固定的GC Roots集合以外，根据用户所选用的垃圾收集器以及当前回收的内存区域不同，还可以有其他对象“临时性”地加入，共同构成完整GC Roots集合。比如：<strong>分代收集</strong>和局部回收（PartialGC）。</p><p>如果只针对Java堆中的某一块区域进行垃圾回收（比如：典型的只针对新生代），必须考虑到内存区域是虚拟机自己的实现细节，更不是孤立封闭的，这个区域的对象完全有可能被其他区域的对象所引用，这时候就需要一并将关联的区域对象也加入GC Roots集合中去考虑，才能保证可达性分析的准确性。</p><p><strong>小技巧</strong></p><p>由于Java采用栈方式存放变量和指针，所以如果一个指针，它保存了堆内存里面的对象，但是自己又不存放在堆内存里面，那它就是一个Root。</p><h3 id="2-3-注意"><a href="#2-3-注意" class="headerlink" title="2.3 注意"></a>2.3 注意</h3><ul><li>如果要使用可达性分析算法来判断内存是否可回收，那么分析工作必须在一个能保障一致性的快照中进行。这点不满足的话分析结果的准确性就无法保证。</li><li>这点也是导致GC进行时必须“Stop The World”的一个重要原因。即使是号称（几乎）不会发生停顿的CMS收集器中，枚举根节点时也是必须要停顿的。</li></ul><h2 id="3-对象的-finalization-机制"><a href="#3-对象的-finalization-机制" class="headerlink" title="3. 对象的 finalization 机制"></a>3. 对象的 finalization 机制</h2><h3 id="3-1-finalize-方法机制"><a href="#3-1-finalize-方法机制" class="headerlink" title="3.1 finalize() 方法机制"></a>3.1 finalize() 方法机制</h3><p><strong>对象销毁前的回调函数：finalize()</strong></p><ul><li>Java语言提供了对象终止（finalization）机制来允许开发人员提供<strong>对象被销毁之前的自定义处理逻辑</strong>。</li><li>当垃圾回收器发现没有引用指向一个对象，即：垃圾回收此对象之前，总会先调用这个对象的finalize()方法。</li><li>finalize() 方法允许在子类中被重写，<strong>用于在对象被回收时进行资源释放</strong>。通常在这个方法中进行一些资源释放和清理的工作，比如关闭文件、套接字和数据库连接等。</li></ul><p><strong>Object 类中 finalize() 源码</strong></p><pre><code class="highlight plaintext">// 等待被重写protected void finalize() throws Throwable &#123; &#125;</code></pre><ul><li>永远不要主动调用某个对象的finalize()方法，应该交给垃圾回收机制调用。理由包括下面三点：<ul><li>在finalize()时可能会导致对象复活。</li><li>finalize()方法的执行时间是没有保障的，它完全由GC线程决定，极端情况下，若不发生GC，则finalize()方法将没有执行机会。</li><li>一个糟糕的finalize()会严重影响GC的性能。比如finalize是个死循环</li></ul></li><li>从功能上来说，finalize()方法与C++中的析构函数比较相似，但是Java采用的是基于垃圾回收器的自动内存管理机制，所以finalize()方法在<strong>本质上不同于C++中的析构函数</strong>。</li><li>finalize()方法对应了一个finalize线程，因为优先级比较低，即使主动调用该方法，也不会因此就直接进行回收</li></ul><h3 id="3-2-虚拟机中对象的状态"><a href="#3-2-虚拟机中对象的状态" class="headerlink" title="3.2 虚拟机中对象的状态"></a>3.2 虚拟机中对象的状态</h3><p>由于finalize()方法的存在，<strong>虚拟机中的对象一般处于三种可能的状态。</strong></p><ul><li>如果从所有的根节点都无法访问到某个对象，说明对象己经不再使用了。一般来说，此对象需要被回收。但事实上，也并非是“非死不可”的，这时候它们暂时处于“缓刑”阶段。<strong>一个无法触及的对象有可能在某一个条件下“复活”自己</strong>，如果这样，那么对它立即进行回收就是不合理的。为此，定义虚拟机中的对象可能的三种状态。如下：<ul><li>可触及的：从根节点开始，可以到达这个对象。</li><li>可复活的：对象的所有引用都被释放，但是对象有可能在finalize()中复活。</li><li>不可触及的：对象的finalize()被调用，并且没有复活，那么就会进入不可触及状态。不可触及的对象不可能被复活，<strong>因为finalize()只会被调用一次</strong>。</li></ul></li></ul><p>以上3种状态中，是由于finalize()方法的存在，进行的区分。只有在对象不可触及时才可以被回收。</p><h3 id="3-3-具体过程"><a href="#3-3-具体过程" class="headerlink" title="3.3 具体过程"></a>3.3 具体过程</h3><p>判定一个对象objA是否可回收，至少要经历两次标记过程：</p><ul><li>如果对象objA到GC Roots没有引用链，则进行第一次标记。</li><li>进行筛选，判断此对象是否有必要执行finalize()方法<ul><li>如果对象objA没有重写finalize()方法，或者finalize()方法已经被虚拟机调用过，则虚拟机视为“没有必要执行”，objA被判定为不可触及的。</li><li>如果对象objA重写了finalize()方法，且还未执行过，那么objA会被插入到F-Queue队列中，由一个虚拟机自动创建的、低优先级的Finalizer线程触发其finalize()方法执行。</li><li>finalize()方法是对象逃脱死亡的最后机会，稍后GC会对F-Queue队列中的对象进行第二次标记。如果objA在finalize()方法中与引用链上的任何一个对象建立了联系，那么在第二次标记时，objA会被移出“即将回收”集合。之后，对象会再次出现没有引用存在的情况。在这个情况下，finalize()方法不会被再次调用，对象会直接变成不可触及的状态，也就是说，一个对象的finalize()方法只会被调用一次。</li></ul></li></ul><p><strong>通过 JVisual VM 查看 Finalizer 线程</strong></p><p><img src="https://raw.githubusercontent.com/GeorgeChan95/blogimg/master/img/2024/01/08/20240108-155703.png" alt="image-20240108155701519"></p><h3 id="3-4-代码演示-finalize-方法可复活对象"><a href="#3-4-代码演示-finalize-方法可复活对象" class="headerlink" title="3.4 代码演示 finalize() 方法可复活对象"></a>3.4 代码演示 finalize() 方法可复活对象</h3><p>我们重写 CanReliveObj 类的 finalize()方法，在调用其 finalize()方法时，将 obj 指向当前类对象 this 。</p><blockquote><p>代码</p></blockquote><pre><code class="highlight java"><span class="comment">/**</span><span class="comment"> * 测试Object类中finalize()方法，即对象的finalization机制。</span><span class="comment"> */</span><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">CanReliveObj</span> &#123;    <span class="keyword">public</span> <span class="keyword">static</span> CanReliveObj obj;<span class="comment">//类变量，属于 GC Root</span>    <span class="comment">//此方法只能被调用一次</span>    <span class="meta">@Override</span>    <span class="keyword">protected</span> <span class="keyword">void</span> <span class="title function_">finalize</span><span class="params">()</span> <span class="keyword">throws</span> Throwable &#123;        <span class="built_in">super</span>.finalize();        System.out.println(<span class="string">&quot;调用当前类重写的finalize()方法&quot;</span>);        obj = <span class="built_in">this</span>;<span class="comment">//当前待回收的对象在finalize()方法中与引用链上的一个对象obj建立了联系</span>    &#125;    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;        <span class="keyword">try</span> &#123;            obj = <span class="keyword">new</span> <span class="title class_">CanReliveObj</span>();            <span class="comment">// 对象第一次成功拯救自己</span>            obj = <span class="literal">null</span>;            System.gc();<span class="comment">//调用垃圾回收器</span>            System.out.println(<span class="string">&quot;第1次 gc&quot;</span>);            <span class="comment">// 因为Finalizer线程优先级很低，暂停2秒，以等待它</span>            Thread.sleep(<span class="number">2000</span>);            <span class="keyword">if</span> (obj == <span class="literal">null</span>) &#123;                System.out.println(<span class="string">&quot;obj is dead&quot;</span>);            &#125; <span class="keyword">else</span> &#123;                System.out.println(<span class="string">&quot;obj is still alive&quot;</span>);            &#125;            System.out.println(<span class="string">&quot;第2次 gc&quot;</span>);            <span class="comment">// 下面这段代码与上面的完全相同，但是这次自救却失败了</span>            obj = <span class="literal">null</span>;            System.gc();            <span class="comment">// 因为Finalizer线程优先级很低，暂停2秒，以等待它</span>            Thread.sleep(<span class="number">2000</span>);            <span class="keyword">if</span> (obj == <span class="literal">null</span>) &#123;                System.out.println(<span class="string">&quot;obj is dead&quot;</span>);            &#125; <span class="keyword">else</span> &#123;                System.out.println(<span class="string">&quot;obj is still alive&quot;</span>);            &#125;        &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;            e.printStackTrace();        &#125;    &#125;&#125;</code></pre><p><strong>如果注释掉finalize()方法</strong></p><pre><code class="highlight java"><span class="comment">//此方法只能被调用一次</span><span class="meta">@Override</span><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title function_">finalize</span><span class="params">()</span> <span class="keyword">throws</span> Throwable &#123;    <span class="built_in">super</span>.finalize();    System.out.println(<span class="string">&quot;调用当前类重写的finalize()方法&quot;</span>);    obj = <span class="built_in">this</span>;<span class="comment">//当前待回收的对象在finalize()方法中与引用链上的一个对象obj建立了联系</span>&#125;</code></pre><p>输出结果：</p><pre><code class="highlight plaintext">第1次 gcobj is dead第2次 gcobj is dead</code></pre><p><strong>放开finalize()方法</strong></p><p>输出结果：</p><pre><code class="highlight plaintext">调用当前类重写的finalize()方法第1次 gcobj is still alive第2次 gcobj is dead</code></pre><p>第一次自救成功，但由于 finalize() 方法只会执行一次，所以第二次自救失败</p><h2 id="4-MAT与JProfiler的GC-Roots溯源"><a href="#4-MAT与JProfiler的GC-Roots溯源" class="headerlink" title="4. MAT与JProfiler的GC Roots溯源"></a>4. MAT与JProfiler的GC Roots溯源</h2><blockquote><p>官网：<a href="https://eclipse.dev/mat/">https://eclipse.dev/mat/</a></p><p>下载地址：<a href="https://eclipse.dev/mat/previousReleases.php">https://eclipse.dev/mat/previousReleases.php</a></p><ul><li>JDK 1.8版本，使用MAT 1.6.0或1.6.1版本</li></ul></blockquote><h3 id="4-1-MAT-介绍"><a href="#4-1-MAT-介绍" class="headerlink" title="4.1 MAT 介绍"></a>4.1 MAT 介绍</h3><ul><li>MAT是Memory Analyzer的简称，它是一款功能强大的Java堆内存分析器。用于查找内存泄漏以及查看内存消耗情况。</li><li>MAT是基于Eclipse开发的，是一款免费的性能分析工具。</li><li>虽然Jvisualvm很强大，但是在内存分析方面，还是MAT更好用一些。</li></ul><h3 id="4-2-获取-dump-文件方式"><a href="#4-2-获取-dump-文件方式" class="headerlink" title="4.2 获取 dump 文件方式"></a>4.2 获取 dump 文件方式</h3><h4 id="4-2-1-方式一：命令行使用-jmap"><a href="#4-2-1-方式一：命令行使用-jmap" class="headerlink" title="4.2.1 方式一：命令行使用 jmap"></a>4.2.1 方式一：命令行使用 jmap</h4><pre><code class="highlight shell"><span class="meta prompt_"># </span><span class="language-bash">格式</span>jmap -dump:format=b,file=文件名.hprof 进程号<span class="meta prompt_"></span><span class="meta prompt_"># </span><span class="language-bash">示例</span>C:\Users\George&gt;jps3312 Jps23636 Launcher11912 Main19048 GCRootsTest6872C:\Users\George&gt;jmap -dump:format=b,file=heap.hprof 19048Dumping heap to C:\Users\George\heap.hprof ...Heap dump file created</code></pre><p><img src="https://raw.githubusercontent.com/GeorgeChan95/blogimg/master/img/2024/01/08/20240108-161544.png" alt="image-20240108161542861"></p><h4 id="4-2-2-方式二：使用JVisualVM"><a href="#4-2-2-方式二：使用JVisualVM" class="headerlink" title="4.2.2 方式二：使用JVisualVM"></a>4.2.2 方式二：使用JVisualVM</h4><p>使用JVisualVM捕获的heap dump文件是一个临时文件，关闭JVisualVM后自动删除，若要保留，需要将其另存为文件。</p><blockquote><p>示例代码</p></blockquote><p>numList 和 birth 在第一次捕捉内存快照的时候，为 GC Roots, 之后 numList 和 birth 置为 null ，对应的引用对象被回收，在第二次捕捉内存快照的时候，就不再是 GC Roots。</p><pre><code class="highlight java"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">GCRootsTest</span> &#123;    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;        List&lt;Object&gt; numList = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();        <span class="type">Date</span> <span class="variable">birth</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Date</span>();        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; <span class="number">100</span>; i++) &#123;            numList.add(String.valueOf(i));            <span class="keyword">try</span> &#123;                Thread.sleep(<span class="number">10</span>);            &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;                e.printStackTrace();            &#125;        &#125;        System.out.println(<span class="string">&quot;数据添加完毕，请操作：&quot;</span>);        <span class="keyword">new</span> <span class="title class_">Scanner</span>(System.in).next();        numList = <span class="literal">null</span>;        birth = <span class="literal">null</span>;        System.out.println(<span class="string">&quot;numList、birth已置空，请操作：&quot;</span>);        <span class="keyword">new</span> <span class="title class_">Scanner</span>(System.in).next();        System.out.println(<span class="string">&quot;结束&quot;</span>);    &#125;&#125;</code></pre><p><strong>捕捉堆内存快照具体步骤：</strong></p><p>1、先执行第一步，然后停下来，去生成此步骤dump文件</p><p><img src="https://raw.githubusercontent.com/GeorgeChan95/blogimg/master/img/2024/01/08/20240108-162524.png" alt="image-20240108162522593"></p><p>2、 点击 <strong><code>堆 Dump</code></strong></p><img src="https://raw.githubusercontent.com/GeorgeChan95/blogimg/master/img/2024/01/08/20240108-162647.png" alt="image-20240108162645837" style="zoom:50%;" /><p>3、右键 –&gt;  <strong><code>另存为</code></strong></p><img src="https://raw.githubusercontent.com/GeorgeChan95/blogimg/master/img/2024/01/08/20240108-163235.png" alt="image-20240108163233880" style="zoom:50%;" /><p>4、输入命令，继续执行程序</p><p><img src="https://raw.githubusercontent.com/GeorgeChan95/blogimg/master/img/2024/01/08/20240108-163318.png" alt="image-20240108163317374"></p><p>5、接着捕获第二张堆内存快照</p><img src="https://raw.githubusercontent.com/GeorgeChan95/blogimg/master/img/2024/01/08/20240108-163414.png" alt="image-20240108163412814" style="zoom:50%;" /><h3 id="4-3-使用-MAT-查看堆内存快照"><a href="#4-3-使用-MAT-查看堆内存快照" class="headerlink" title="4.3 使用 MAT 查看堆内存快照"></a>4.3 使用 MAT 查看堆内存快照</h3><p>1、打开 MAT ，选择 File –&gt; Open File，打开刚刚的两个dump文件，<strong>我们先打开第一个dump文件</strong></p><p><strong>点击Open Heap Dump也行</strong></p><img src="https://raw.githubusercontent.com/GeorgeChan95/blogimg/master/img/2024/01/08/20240108-170337.png" alt="image-20240108170336266" style="zoom:50%;" /><p>2、选择Java Basics –&gt; GC Roots</p><p><img src="https://raw.githubusercontent.com/GeorgeChan95/blogimg/master/img/2024/01/08/20240108-170440.png" alt="image-20240108170438718"></p><p><img src="https://raw.githubusercontent.com/GeorgeChan95/blogimg/master/img/2024/01/08/20240108-170609.png" alt="image-20240108170608489"></p><p>3、第一次捕捉堆内存快照时，GC Roots 中包含我们定义的两个局部变量，类型分别为 ArrayList 和 Date，Total:21</p><p><img src="https://raw.githubusercontent.com/GeorgeChan95/blogimg/master/img/2024/01/08/20240108-170741.png" alt="image-20240108170740417"></p><p>4、打开第二个dump文件，第二次捕获内存快照时，由于两个局部变量引用的对象被释放，所以这两个局部变量不再作为 GC Roots ，从 Total Entries &#x3D; 19 也可以看出（少了两个 GC Roots）</p><p><img src="https://raw.githubusercontent.com/GeorgeChan95/blogimg/master/img/2024/01/08/20240108-170912.png" alt="image-20240108170910579"></p><h3 id="4-4-JProfiler-GC-Roots-溯源"><a href="#4-4-JProfiler-GC-Roots-溯源" class="headerlink" title="4.4 JProfiler GC Roots 溯源"></a>4.4 JProfiler GC Roots 溯源</h3><blockquote><p>JProfiler下载地址：<a href="https://www.ej-technologies.com/download/jprofiler/files">https://www.ej-technologies.com/download/jprofiler/files</a></p></blockquote><p>在实际开发中，我们很少会查看所有的GC Roots。一般都是查看某一个或几个对象的GC Root是哪个，这个过程叫<strong>GC Roots 溯源</strong>。下面我们使用使用 JProfiler 进行 GC Roots 溯源演示</p><blockquote><p>演示代码</p></blockquote><pre><code class="highlight java"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">GCRootsTest</span> &#123;    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;        List&lt;Object&gt; numList = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();        <span class="type">Date</span> <span class="variable">birth</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Date</span>();        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; <span class="number">100</span>; i++) &#123;            numList.add(String.valueOf(i));            <span class="keyword">try</span> &#123;                Thread.sleep(<span class="number">10</span>);            &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;                e.printStackTrace();            &#125;        &#125;        System.out.println(<span class="string">&quot;数据添加完毕，请操作：&quot;</span>);        <span class="keyword">new</span> <span class="title class_">Scanner</span>(System.in).next();        numList = <span class="literal">null</span>;        birth = <span class="literal">null</span>;        System.out.println(<span class="string">&quot;numList、birth已置空，请操作：&quot;</span>);        <span class="keyword">new</span> <span class="title class_">Scanner</span>(System.in).next();        System.out.println(<span class="string">&quot;结束&quot;</span>);    &#125;&#125;</code></pre><p><strong>1、JProfiler 会话首页</strong></p><p><img src="https://raw.githubusercontent.com/GeorgeChan95/blogimg/master/img/2024/01/08/20240108-172221.png" alt="image-20240108172219593"></p><p>2、标记当前值</p><p><img src="https://raw.githubusercontent.com/GeorgeChan95/blogimg/master/img/2024/01/08/20240108-172315.png" alt="image-20240108172313546"></p><p>可以发现颜色变绿了，可以动态的看变化</p><p><img src="https://raw.githubusercontent.com/GeorgeChan95/blogimg/master/img/2024/01/08/20240108-172408.png" alt="image-20240108172407266"></p><p>3、右击对象，选择 Show Selection In Heap Walker，单独的查看某个对象</p><p><img src="https://raw.githubusercontent.com/GeorgeChan95/blogimg/master/img/2024/01/08/20240108-172535.png" alt="image-20240108172534459"></p><p><img src="https://raw.githubusercontent.com/GeorgeChan95/blogimg/master/img/2024/01/08/20240108-172600.png" alt="image-20240108172559364"></p><p>4、选择Incoming References，表示追寻 GC Roots 的源头</p><p>点击Show Paths To GC Roots，在弹出界面中选择默认设置即可</p><p><img src="https://raw.githubusercontent.com/GeorgeChan95/blogimg/master/img/2024/01/08/20240108-172709.png" alt="image-20240108172708358"></p><p><img src="https://raw.githubusercontent.com/GeorgeChan95/blogimg/master/img/2024/01/08/20240108-172802.png" alt="image-20240108172801303"></p><p><img src="https://raw.githubusercontent.com/GeorgeChan95/blogimg/master/img/2024/01/08/20240108-172825.png" alt="image-20240108172824459"></p><p><img src="https://raw.githubusercontent.com/GeorgeChan95/blogimg/master/img/2024/01/08/20240108-172855.png" alt="image-20240108172853434"></p><h3 id="4-5-JProfiler-分析-OOM"><a href="#4-5-JProfiler-分析-OOM" class="headerlink" title="4.5 JProfiler 分析 OOM"></a>4.5 JProfiler 分析 OOM</h3><blockquote><p>示例代码：注意配置 VM Options</p></blockquote><pre><code class="highlight java"><span class="comment">/**</span><span class="comment"> * -Xms8m -Xmx8m -XX:+HeapDumpOnOutOfMemoryError</span><span class="comment"> */</span><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">HeapOOM</span> &#123;    <span class="type">byte</span>[] buffer = <span class="keyword">new</span> <span class="title class_">byte</span>[<span class="number">1</span> * <span class="number">1024</span> * <span class="number">1024</span>];<span class="comment">//1MB</span>    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;        ArrayList&lt;HeapOOM&gt; list = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();        <span class="type">int</span> <span class="variable">count</span> <span class="operator">=</span> <span class="number">0</span>;        <span class="keyword">try</span>&#123;            <span class="keyword">while</span>(<span class="literal">true</span>)&#123;                list.add(<span class="keyword">new</span> <span class="title class_">HeapOOM</span>());                count++;            &#125;        &#125;<span class="keyword">catch</span> (Throwable e)&#123;            System.out.println(<span class="string">&quot;count = &quot;</span> + count);            e.printStackTrace();        &#125;    &#125;&#125;</code></pre><blockquote><p>程序输出日志</p></blockquote><pre><code class="highlight plaintext">java.lang.OutOfMemoryError: Java heap spaceDumping heap to java_pid20604.hprof ...Heap dump file created [7709884 bytes in 0.012 secs]count = 6java.lang.OutOfMemoryError: Java heap spaceat com.atguigu.java.HeapOOM.&lt;init&gt;(HeapOOM.java:9)at com.atguigu.java.HeapOOM.main(HeapOOM.java:17)</code></pre><p>打开这个dump文件</p><p>1、看这个超大对象</p><p><img src="https://raw.githubusercontent.com/GeorgeChan95/blogimg/master/img/2024/01/09/20240109-085219.png" alt="image-20240109085217582"></p><p>2、揪出 main() 线程中出问题的代码</p><p><img src="https://raw.githubusercontent.com/GeorgeChan95/blogimg/master/img/2024/01/09/20240109-085603.png" alt="image-20240109085601576"></p><p><img src="https://raw.githubusercontent.com/GeorgeChan95/blogimg/master/img/2024/01/09/20240109-085628.png" alt="image-20240109085626601"></p><h2 id="5-清除阶段：标记-清除算法"><a href="#5-清除阶段：标记-清除算法" class="headerlink" title="5. 清除阶段：标记-清除算法"></a>5. 清除阶段：标记-清除算法</h2><h3 id="5-1-垃圾清除阶段"><a href="#5-1-垃圾清除阶段" class="headerlink" title="5.1 垃圾清除阶段"></a>5.1 垃圾清除阶段</h3><p>当成功区分出内存中存活对象和死亡对象后，GC接下来的任务就是执行垃圾回收，释放掉无用对象所占用的内存空间，以便有足够的可用内存空间为新对象分配内存。目前在JVM中比较常见的三种垃圾收集算法是</p><ul><li>标记-清除算法（Mark-Sweep）</li><li>复制算法（Copying）</li><li>标记-压缩算法（Mark-Compact）</li></ul><h3 id="5-2-背景"><a href="#5-2-背景" class="headerlink" title="5.2 背景"></a>5.2 背景</h3><p>标记-清除算法（Mark-Sweep）是一种非常基础和常见的垃圾收集算法，该算法被 J.McCarthy 等人在1960年提出并并应用于Lisp语言。</p><h3 id="5-3-执行过程"><a href="#5-3-执行过程" class="headerlink" title="5.3 执行过程"></a>5.3 执行过程</h3><p>当堆中的有效内存空间（available memory）被耗尽的时候，就会停止整个程序（也被称为stop the world），然后进行两项工作，第一项则是标记，第二项则是清除。</p><ul><li>标记：Collector从引用根节点开始遍历，标记所有被引用的对象。一般是在对象的Header中记录为可达对象。<ul><li>注意：标记的是被引用的对象，也就是可达对象，并非标记的是即将被清除的垃圾对象</li></ul></li><li>清除：Collector对堆内存从头到尾进行线性的遍历，如果发现某个对象在其Header中没有标记为可达对象，则将其回收</li></ul><p> <img src="https://raw.githubusercontent.com/GeorgeChan95/blogimg/master/img/2024/01/09/20240109-100806.png" alt="image-20240109100805336"></p><h3 id="5-4-标记-清除算法的缺点"><a href="#5-4-标记-清除算法的缺点" class="headerlink" title="5.4 标记-清除算法的缺点"></a>5.4 标记-清除算法的缺点</h3><ul><li>标记清除算法的效率不算高</li><li>在进行GC的时候，需要停止整个应用程序，用户体验较差</li><li>这种方式清理出来的空闲内存是不连续的，产生内碎片，需要维护一个空闲列表</li></ul><p><strong>注意：何为清除？</strong></p><p>这里所谓的清除并不是真的置空，而是把需要清除的对象地址保存在空闲的地址列表里。下次有新对象需要加载时，判断垃圾的位置空间是否够，如果够，就存放（也就是覆盖原有的地址）。</p><p>关于空闲列表是在为对象分配内存的时候提过：</p><ul><li>如果内存规整，采用指针碰撞的方式进行内存分配</li><li>如果内存不规整，虚拟机需要维护一个空闲列表，采用空闲列表分配内存</li></ul><h2 id="6-清除阶段：复制算法"><a href="#6-清除阶段：复制算法" class="headerlink" title="6. 清除阶段：复制算法"></a>6. 清除阶段：复制算法</h2><h3 id="6-1-背景"><a href="#6-1-背景" class="headerlink" title="6.1 背景"></a>6.1 背景</h3><p>为了解决标记-清除算法在垃圾收集效率方面的缺陷，M.L.Minsky于1963年发表了著名的论文，“使用双存储区的Lisp语言垃圾收集器CA LISP Garbage Collector Algorithm Using Serial Secondary Storage）”。M.L.Minsky在该论文中描述的算法被人们称为复制（Copying）算法，它也被M.L.Minsky本人成功地引入到了Lisp语言的一个实现版本中。</p><h3 id="6-2-核心思想"><a href="#6-2-核心思想" class="headerlink" title="6.2 核心思想"></a>6.2 核心思想</h3><p>将活着的内存空间分为两块，每次只使用其中一块，在垃圾回收时将正在使用的内存中的存活对象复制到未被使用的内存块中，之后清除正在使用的内存块中的所有对象，交换两个内存的角色，最后完成垃圾回收</p><p><img src="https://raw.githubusercontent.com/GeorgeChan95/blogimg/master/img/2024/01/09/20240109-101622.png" alt="image-20240109101621409"></p><p><strong>新生代里面就用到了复制算法，Eden区和S0区存活对象整体复制到S1区</strong></p><h3 id="6-3-复制算法的优缺点"><a href="#6-3-复制算法的优缺点" class="headerlink" title="6.3 复制算法的优缺点"></a>6.3 复制算法的优缺点</h3><p><strong>优点</strong></p><ul><li>没有标记和清除过程，实现简单，运行高效</li><li>复制过去以后保证空间的连续性，不会出现“碎片”问题。</li></ul><p><strong>缺点</strong></p><ul><li>此算法的缺点也是很明显的，就是需要两倍的内存空间。</li><li>对于G1这种分拆成为大量region的GC，复制而不是移动，意味着GC需要维护region之间对象引用关系，不管是内存占用或者时间开销也不小</li></ul><h3 id="6-4-复制算法的应用场景"><a href="#6-4-复制算法的应用场景" class="headerlink" title="6.4 复制算法的应用场景"></a>6.4 复制算法的应用场景</h3><ul><li>如果系统中的垃圾对象很多，复制算法需要复制的存活对象数量并不会太大，效率较高</li><li>老年代大量的对象存活，那么复制的对象将会有很多，效率会很低</li><li>在新生代，对常规应用的垃圾回收，一次通常可以回收70% - 99% 的内存空间。回收性价比很高。所以现在的商业虚拟机都是用这种收集算法回收新生代。</li></ul><p><img src="https://raw.githubusercontent.com/GeorgeChan95/blogimg/master/img/2024/01/09/20240109-101943.png" alt="image-20240109101942056"></p><h2 id="7-清除阶段：标记-压缩算法"><a href="#7-清除阶段：标记-压缩算法" class="headerlink" title="7. 清除阶段：标记-压缩算法"></a>7. 清除阶段：标记-压缩算法</h2><p><strong>标记-压缩（或标记-整理、Mark - Compact）算法</strong></p><h3 id="7-1-背景"><a href="#7-1-背景" class="headerlink" title="7.1 背景"></a>7.1 背景</h3><ul><li>复制算法的高效性是建立在存活对象少、垃圾对象多的前提下的。这种情况在新生代经常发生，但是在老年代，更常见的情况是大部分对象都是存活对象。如果依然使用复制算法，由于存活对象较多，复制的成本也将很高。因此，<strong>基于老年代垃圾回收的特性，需要使用其他的算法。</strong></li><li>标记-清除算法的确可以应用在老年代中，但是该算法不仅执行效率低下，而且在执行完内存回收后还会产生内存碎片，所以JVM的设计者需要在此基础之上进行改进。标记-压缩（Mark-Compact）算法由此诞生。</li><li>1970年前后，G.L.Steele、C.J.Chene和D.s.Wise等研究者发布标记-压缩算法。在许多现代的垃圾收集器中，人们都使用了标记-压缩算法或其改进版本。</li></ul><h3 id="7-2-执行过程"><a href="#7-2-执行过程" class="headerlink" title="7.2 执行过程"></a>7.2 执行过程</h3><ul><li>第一阶段和标记清除算法一样，从根节点开始标记所有被引用对象</li><li>第二阶段将所有的存活对象压缩到内存的一端，按顺序排放。之后，清理边界外所有的空间。</li></ul><p><img src="https://raw.githubusercontent.com/GeorgeChan95/blogimg/master/img/2024/01/09/20240109-102715.png" alt="image-20240109102714067"></p><h3 id="7-3-标记-压缩算法与标记-清除算法的比较"><a href="#7-3-标记-压缩算法与标记-清除算法的比较" class="headerlink" title="7.3 标记-压缩算法与标记-清除算法的比较"></a>7.3 标记-压缩算法与标记-清除算法的比较</h3><ul><li>标记-压缩算法的最终效果等同于标记-清除算法执行完成后，再进行一次内存碎片整理，因此，也可以把它称为标记-清除-压缩（Mark-Sweep-Compact）算法。</li><li>二者的本质差异在于标记-清除算法是一种<strong>非移动式的回收算法</strong>，标记-压缩是<strong>移动式的</strong>。是否移动回收后的存活对象是一项优缺点并存的风险决策。</li><li>可以看到，标记的存活对象将会被整理，按照内存地址依次排列，而未被标记的内存会被清理掉。如此一来，当我们需要给新对象分配内存时，JVM只需要持有一个内存的起始地址即可，这比维护一个空闲列表显然少了许多开销。</li></ul><h3 id="7-4-标记-压缩算法的优缺点"><a href="#7-4-标记-压缩算法的优缺点" class="headerlink" title="7.4 标记-压缩算法的优缺点"></a>7.4 标记-压缩算法的优缺点</h3><p><strong>优点</strong></p><ul><li>消除了标记-清除算法当中，内存区域分散的缺点，我们需要给新对象分配内存时，JVM只需要持有一个内存的起始地址即可。</li><li>消除了复制算法当中，内存减半的高额代价。</li></ul><p><strong>缺点</strong></p><ul><li>移动对象的同时，如果对象被其他对象引用，则还需要调整引用的地址（因为HotSpot虚拟机采用的不是句柄池的方式，而是直接指针）</li><li>移动过程中，需要全程暂停用户应用程序。即：STW</li></ul><h2 id="8-垃圾回收算法小结"><a href="#8-垃圾回收算法小结" class="headerlink" title="8. 垃圾回收算法小结"></a>8. 垃圾回收算法小结</h2><p><strong>对比三种清除阶段的算法</strong></p><ul><li>效率上来说，复制算法是当之无愧的老大，但是却浪费了太多内存。</li><li>而为了尽量兼顾上面提到的三个指标，标记-整理算法相对来说更平滑一些，但是效率上不尽如人意，它比复制算法多了一个标记的阶段，比标记-清除多了一个整理内存的阶段。</li></ul><table><thead><tr><th></th><th>标记清除</th><th>标记整理</th><th>复制</th></tr></thead><tbody><tr><td><strong>速率</strong></td><td>中等</td><td>最慢</td><td>最快</td></tr><tr><td><strong>空间开销</strong></td><td>少（但会堆积碎片）</td><td>少（不堆积碎片）</td><td>通常需要活对象的2倍空间（不堆积碎片）</td></tr><tr><td><strong>移动对象</strong></td><td>否</td><td>是</td><td>是</td></tr></tbody></table><h2 id="9-分代收集算法"><a href="#9-分代收集算法" class="headerlink" title="9. 分代收集算法"></a>9. 分代收集算法</h2><p>Q：难道就没有一种最优的算法吗？</p><p>A：无，没有最好的算法，只有最合适的算法</p><p><strong>为什么要使用分代收集算法</strong></p><ul><li>前面所有这些算法中，并没有一种算法可以完全替代其他算法，它们都具有自己独特的优势和特点。分代收集算法应运而生。</li><li>分代收集算法，是基于这样一个事实：<strong>不同的对象的生命周期是不一样的。因此，不同生命周期的对象可以采取不同的收集方式，以便提高回收效率。</strong>一般是把Java堆分为新生代和老年代，这样就可以根据各个年代的特点使用不同的回收算法，以提高垃圾回收的效率。</li><li>在Java程序运行的过程中，会产生大量的对象，其中有些对象是与业务信息相关:<ul><li>比如Http请求中的Session对象、线程、Socket连接，这类对象跟业务直接挂钩，因此生命周期比较长。</li><li>但是还有一些对象，主要是程序运行过程中生成的临时变量，这些对象生命周期会比较短，比如：String对象，由于其不变类的特性，系统会产生大量的这些对象，有些对象甚至只用一次即可回收。</li></ul></li></ul><p><strong>目前几乎所有的GC都采用分代收集算法执行垃圾回收的</strong></p><p>在HotSpot中，基于分代的概念，GC所使用的内存回收算法必须结合年轻代和老年代各自的特点。</p><ul><li><p>年轻代（Young Gen）</p><ul><li>年轻代特点：区域相对老年代较小，对象生命周期短、存活率低，回收频繁。</li><li>这种情况复制算法的回收整理，速度是最快的。复制算法的效率只和当前存活对象大小有关，因此很适用于年轻代的回收。而复制算法内存利用率不高的问题，通过hotspot中的两个survivor的设计得到缓解。</li></ul></li><li><p>老年代（Tenured Gen）</p><ul><li>老年代特点：区域较大，对象生命周期长、存活率高，回收不及年轻代频繁。</li><li>这种情况存在大量存活率高的对象，复制算法明显变得不合适。一般是由标记-清除或者是标记-清除与标记-整理的混合实现。<ul><li>Mark阶段的开销与存活对象的数量成正比。</li><li>Sweep阶段的开销与所管理区域的大小成正相关。</li><li>Compact阶段的开销与存活对象的数据成正比。</li></ul></li></ul></li><li><p>以HotSpot中的CMS回收器为例，CMS是基于Mark-Sweep实现的，对于对象的回收效率很高。对于碎片问题，CMS采用基于Mark-Compact算法的Serial Old回收器作为补偿措施：当内存回收不佳（碎片导致的Concurrent Mode Failure时），将采用Serial Old执行Full GC以达到对老年代内存的整理。</p></li><li><p>分代的思想被现有的虚拟机广泛使用。几乎所有的垃圾回收器都区分新生代和老年代</p></li></ul><h2 id="10-增量收集算法和分区算法"><a href="#10-增量收集算法和分区算法" class="headerlink" title="10. 增量收集算法和分区算法"></a>10. 增量收集算法和分区算法</h2><h3 id="10-1-增量收集算法"><a href="#10-1-增量收集算法" class="headerlink" title="10.1 增量收集算法"></a>10.1 增量收集算法</h3><p>上述现有的算法，在垃圾回收过程中，应用软件将处于一种Stop the World的状态。在<strong>Stop the World</strong>状态下，应用程序所有的线程都会挂起，暂停一切正常的工作，等待垃圾回收的完成。如果垃圾回收时间过长，应用程序会被挂起很久，将严重影响用户体验或者系统的稳定性。为了解决这个问题，即对实时垃圾收集算法的研究直接导致了增量收集（Incremental Collecting）算法的诞生。</p><h4 id="10-1-1-增量收集算法基本思想"><a href="#10-1-1-增量收集算法基本思想" class="headerlink" title="10.1.1 增量收集算法基本思想"></a>10.1.1 增量收集算法基本思想</h4><p>如果一次性将所有的垃圾进行处理，需要造成系统长时间的停顿，那么就可以让垃圾收集线程和应用程序线程交替执行。<strong>每次，垃圾收集线程只收集一小片区域的内存空间，接着切换到应用程序线程。依次反复，直到垃圾收集完成。</strong></p><p>总的来说，增量收集算法的基础仍是传统的标记-清除和复制算法。增量收集算法通过<strong>对线程间冲突的妥善处理，允许垃圾收集线程以分阶段的方式完成标记、清理或复制工作</strong></p><p><strong>增量收集算法的缺点</strong></p><p>使用这种方式，由于在垃圾回收过程中，间断性地还执行了应用程序代码，所以能减少系统的停顿时间。但是，因为线程切换和上下文转换的消耗，会使得垃圾回收的总体成本上升，<strong>造成系统吞吐量的下降</strong>。</p><h3 id="10-2-分区算法"><a href="#10-2-分区算法" class="headerlink" title="10.2 分区算法"></a>10.2 分区算法</h3><blockquote><p>主要针对G1收集器来说的</p></blockquote><ul><li>一般来说，在相同条件下，堆空间越大，一次GC时所需要的时间就越长，有关GC产生的停顿也越长。为了更好地控制GC产生的停顿时间，将一块大的内存区域分割成多个小块，根据目标的停顿时间，每次合理地回收若干个小区间，而不是整个堆空间，从而减少一次GC所产生的停顿。</li><li>分代算法将按照对象的生命周期长短划分成两个部分，分区算法将整个堆空间划分成连续的不同小区间。每一个小区间都独立使用，独立回收。这种算法的好处是可以控制一次回收多少个小区间。</li></ul><p><img src="https://raw.githubusercontent.com/GeorgeChan95/blogimg/master/img/2024/01/09/20240109-110825.png" alt="image-20240109110824025"></p><p><strong>注意，这些只是基本的算法思路，实际GC实现过程要复杂的多，目前还在发展中的前沿GC都是复合算法，并且并行和并发兼备。</strong></p><h1 id="参考链接"><a href="#参考链接" class="headerlink" title="参考链接"></a>参考链接</h1><blockquote><p>关于GC roots ：<a href="https://blog.csdn.net/weixin_41910694/article/details/90706652">https://blog.csdn.net/weixin_41910694/article/details/90706652</a></p><p>MAT内存分析工具下载地址：<a href="https://eclipse.dev/mat/downloads.php">https://eclipse.dev/mat/downloads.php</a> 使用 1.6.0 或 1.6.1 版本</p><p>Jprofile 下载：<a href="https://www.ej-technologies.com/download/jprofiler/files">https://www.ej-technologies.com/download/jprofiler/files</a></p></blockquote>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;一、垃圾回收概述&quot;&gt;&lt;a href=&quot;#一、垃圾回收概述&quot; class=&quot;headerlink&quot; title=&quot;一、垃圾回收概述&quot;&gt;&lt;/a&gt;一、垃圾回收概述&lt;/h1&gt;&lt;p&gt;​	&lt;img src=&quot;https://raw.githubusercontent.com/</summary>
      
    
    
    
    <category term="JVM" scheme="https://georgechan95.github.io/categories/JVM/"/>
    
    
    <category term="jvm" scheme="https://georgechan95.github.io/tags/jvm/"/>
    
    <category term="java" scheme="https://georgechan95.github.io/tags/java/"/>
    
  </entry>
  
  <entry>
    <title>Jenkins的安装和搭建自动化部署平台</title>
    <link href="https://georgechan95.github.io/2024/01/05/linux/Jenkins%E7%9A%84%E5%AE%89%E8%A3%85%E5%92%8C%E5%9F%BA%E7%A1%80%E4%BD%BF%E7%94%A8/"/>
    <id>https://georgechan95.github.io/2024/01/05/linux/Jenkins%E7%9A%84%E5%AE%89%E8%A3%85%E5%92%8C%E5%9F%BA%E7%A1%80%E4%BD%BF%E7%94%A8/</id>
    <published>2024-01-05T08:00:00.000Z</published>
    <updated>2024-06-22T10:36:12.823Z</updated>
    
    <content type="html"><![CDATA[<h1 style="text-align: center;">Jenkins的安装和搭建自动化部署平台</h1><h1 id="环境"><a href="#环境" class="headerlink" title="环境"></a>环境</h1><blockquote><p>操作系统：Ubuntu 18.04.6 LTS</p><p>内核版本：5.4.0-149-generic</p><p>Docker版本：24.0.2</p><p>Docker Compose 版本：v2.18.0</p><p>Jenkins 版本：2.393-alpine</p><p>JDK 版本：java 11.0.19 2023-04-18 LTS</p><p>Git 版本：2.28.0</p><p>Maven 版本：3.6.3</p><p>Node JS 版本：16.16.0</p><p>Jenkins主节点：192.168.6.92</p><p>Jenkins agent节点：192.168.6.91</p></blockquote><h1 id="一、Jenkins官网"><a href="#一、Jenkins官网" class="headerlink" title="一、Jenkins官网"></a>一、Jenkins官网</h1><ul><li>英文官网<ul><li><a href="https://www.jenkins.io/">https://www.jenkins.io/</a></li></ul></li><li>英文官方文档<ul><li><a href="https://www.jenkins.io/doc/">https://www.jenkins.io/doc/</a></li></ul></li><li>中文官网<ul><li><a href="https://www.jenkins.io/zh/">https://www.jenkins.io/zh/</a></li></ul></li><li>中文官方文档<ul><li><a href="https://www.jenkins.io/zh/doc/">https://www.jenkins.io/zh/doc/</a></li></ul></li><li>Docker Hub网址 (存放Jenkins官方镜像)<ul><li><a href="https://hub.docker.com/r/jenkins/jenkins">https://hub.docker.com/r/jenkins/jenkins</a></li></ul></li></ul><h1 id="二、Jenkins概述"><a href="#二、Jenkins概述" class="headerlink" title="二、Jenkins概述"></a>二、Jenkins概述</h1><p>持续集成（CI）是一种开发实践，其中开发人员经常（最好每天几次）将代码集成到共享存储库中。然后可以通过自动构建和自动测试来验证每个集成。尽管自动化测试不是严格意义上的CI的一部分，但通常隐含了它。</p><p>定期集成的主要好处之一是，您可以快速检测到错误并更轻松地定位它们。由于引入的每个更改通常很小，因此可以快速查明引入缺陷的特定更改。</p><p>近年来，CI已成为软件开发的最佳实践，并遵循一系列关键原则。其中包括版本控制，构建自动化和自动化测试。</p><p>此外，持续部署和持续交付已成为<strong>最佳实践</strong>，可让您随时随地部署应用程序，甚至在每次引入新更改时甚至将主代码库自动推入生产环境。这使您的团队可以快速行动，同时保持可以自动检查的高质量标准。</p><p><img src="https://raw.githubusercontent.com/GeorgeChan95/blogimg/master/img/2024/01/05/20240105-155739.png" alt="image-20240105155737704"></p><p>CI&#x2F;CD应用场景：</p><ul><li>开发人员将本地代码上传gitlab版本服务器</li><li>jenkins通过webhook插件自动到gitlab服务器拉取最新代码</li><li>通过docker-maven-plugin插件自动编译代码</li><li>将自定义镜像上传docker私服仓库</li><li>k8s集群自动拉取最新版本镜像</li><li>自动化部署整个项目</li><li>用户通过nginx负载均衡访问整个项目</li></ul><p><img src="https://raw.githubusercontent.com/GeorgeChan95/blogimg/master/img/2024/01/05/20240105-155828.png" alt="image-20240105155826829"></p><h1 id="三、Jenkins的部署"><a href="#三、Jenkins的部署" class="headerlink" title="三、Jenkins的部署"></a>三、Jenkins的部署</h1><h2 id="使用Docker部署Jenkins"><a href="#使用Docker部署Jenkins" class="headerlink" title="使用Docker部署Jenkins"></a>使用Docker部署Jenkins</h2><pre><code class="highlight shell"><span class="meta prompt_"># </span><span class="language-bash">拉取镜像</span>docker pull jenkins/jenkins:2.393-alpine<span class="meta prompt_"></span><span class="meta prompt_"># </span><span class="language-bash">创建映射目录，并给目录授权</span>mkdir -p /data/jenkins &amp;&amp; chown -R 1000:1000 /data/jenkins<span class="meta prompt_"></span><span class="meta prompt_"></span><span class="meta prompt_"># </span><span class="language-bash">运行容器</span>docker run -itd \    --name jenkins \-p 8080:8080 \-p 50000:50000 \-u root \-e JAVA_OPTS=-Duser.timezone=Asia/Shanghai \--restart always \-v /data/jenkins/:/var/jenkins_home/ \    jenkins/jenkins:2.393-alpine    <span class="meta prompt_"># </span><span class="language-bash">查看容器启动日志并找到jenkins初始化密码</span>docker logs -f jenkins</code></pre><p><img src="https://raw.githubusercontent.com/GeorgeChan95/blogimg/master/img/2024/01/04/20240104-104424.png" alt="image-20240104104421050"></p><h2 id="浏览器访问Jenkins"><a href="#浏览器访问Jenkins" class="headerlink" title="浏览器访问Jenkins"></a>浏览器访问Jenkins</h2><p><img src="https://raw.githubusercontent.com/GeorgeChan95/blogimg/master/img/2024/01/04/20240104-104613.png" alt="image-20240104104612435"></p><h2 id="安装Jenkins插件"><a href="#安装Jenkins插件" class="headerlink" title="安装Jenkins插件"></a>安装Jenkins插件</h2><p><img src="https://raw.githubusercontent.com/GeorgeChan95/blogimg/master/img/2024/01/04/20240104-104738.png" alt="image-20240104104736736"></p><p><img src="https://raw.githubusercontent.com/GeorgeChan95/blogimg/master/img/2024/01/04/20240104-104809.png" alt="image-20240104104807803"></p><p><strong>插件安装完成</strong></p><p><img src="https://raw.githubusercontent.com/GeorgeChan95/blogimg/master/img/2024/01/04/20240104-105110.png" alt="image-20240104105108610"></p><h2 id="创建管理员账户"><a href="#创建管理员账户" class="headerlink" title="创建管理员账户"></a>创建管理员账户</h2><p><img src="https://raw.githubusercontent.com/GeorgeChan95/blogimg/master/img/2024/01/04/20240104-105201.png" alt="image-20240104105159836"></p><h2 id="配置实例"><a href="#配置实例" class="headerlink" title="配置实例"></a>配置实例</h2><p><img src="https://raw.githubusercontent.com/GeorgeChan95/blogimg/master/img/2024/01/04/20240104-105233.png" alt="image-20240104105231800"></p><h2 id="安装完成"><a href="#安装完成" class="headerlink" title="安装完成"></a><strong>安装完成</strong></h2><p><img src="https://raw.githubusercontent.com/GeorgeChan95/blogimg/master/img/2024/01/04/20240104-105249.png" alt="image-20240104105247735"></p><h1 id="四、Jenkins设置中文支持"><a href="#四、Jenkins设置中文支持" class="headerlink" title="四、Jenkins设置中文支持"></a>四、Jenkins设置中文支持</h1><h2 id="1-点击-Manage-Jenkins"><a href="#1-点击-Manage-Jenkins" class="headerlink" title="1. 点击 Manage Jenkins"></a>1. 点击 Manage Jenkins</h2><p><img src="https://raw.githubusercontent.com/GeorgeChan95/blogimg/master/img/2024/01/04/20240104-110445.png" alt="image-20240104110443683"></p><h2 id="2-点击Manage-Plugins"><a href="#2-点击Manage-Plugins" class="headerlink" title="2. 点击Manage Plugins"></a>2. 点击Manage Plugins</h2><p><img src="https://raw.githubusercontent.com/GeorgeChan95/blogimg/master/img/2024/01/04/20240104-110500.png" alt="image-20240104110458889"></p><h2 id="3-搜索并安装-locale-插件"><a href="#3-搜索并安装-locale-插件" class="headerlink" title="3. 搜索并安装 locale 插件"></a>3. 搜索并安装 locale 插件</h2><p><img src="https://raw.githubusercontent.com/GeorgeChan95/blogimg/master/img/2024/01/04/20240104-110604.png" alt="image-20240104110602657"></p><h2 id="4-安装完成后重启-Jenkins"><a href="#4-安装完成后重启-Jenkins" class="headerlink" title="4. 安装完成后重启 Jenkins"></a>4. 安装完成后重启 Jenkins</h2><p><img src="https://raw.githubusercontent.com/GeorgeChan95/blogimg/master/img/2024/01/04/20240104-110720.png" alt="image-20240104110719409"></p><pre><code class="highlight shell"><span class="meta prompt_"># </span><span class="language-bash">重启Jenkins</span>docker restart jenkins</code></pre><h2 id="5-验证"><a href="#5-验证" class="headerlink" title="5. 验证"></a>5. 验证</h2><p><strong>此时再次重新登录Jenkins，发现已变成中文了，这是由于Locale插件自动根据浏览器语言设置，切换对应的语言支持。</strong></p><p><img src="https://raw.githubusercontent.com/GeorgeChan95/blogimg/master/img/2024/01/04/20240104-111024.png" alt="image-20240104111022563"></p><h1 id="五、Jenkins初体验"><a href="#五、Jenkins初体验" class="headerlink" title="五、Jenkins初体验"></a>五、Jenkins初体验</h1><h2 id="1-自由风格项目"><a href="#1-自由风格项目" class="headerlink" title="1. 自由风格项目"></a>1. 自由风格项目</h2><ol><li>点击 <code>新建任务</code></li></ol><p><img src="https://raw.githubusercontent.com/GeorgeChan95/blogimg/master/img/2024/01/04/20240104-135232.png" alt="image-20240104135230836"></p><ol><li>填写 <code>任务名称</code></li><li>选择 <code>构建一个自由风格的软件项目</code></li><li>点击 <code>确定</code></li></ol><p><img src="https://raw.githubusercontent.com/GeorgeChan95/blogimg/master/img/2024/01/04/20240104-135331.png" alt="image-20240104135329889"></p><ul><li>添加构建步骤，选择 执行shell</li><li>填写shell命令</li><li>点击 保存</li></ul><p><img src="https://raw.githubusercontent.com/GeorgeChan95/blogimg/master/img/2024/01/04/20240104-152628.png" alt="image-20240104152627088"></p><ul><li>点击 立即构建 ，查看执行结果</li></ul><p><img src="https://raw.githubusercontent.com/GeorgeChan95/blogimg/master/img/2024/01/04/20240104-143757.png" alt="image-20240104143756241"></p><p><img src="https://raw.githubusercontent.com/GeorgeChan95/blogimg/master/img/2024/01/04/20240104-152825.png" alt="image-20240104152823887"></p><ul><li>查看控制台输出</li></ul><p><img src="https://raw.githubusercontent.com/GeorgeChan95/blogimg/master/img/2024/01/04/20240104-152843.png" alt="image-20240104152841553"></p><p>这里需要了解一点：</p><p>之所以可以执行 <code>java --version </code> 和 <code>git --version</code> 指令，是因为Jenkins容器内部已安装了该工具，没有安装了工具，执行就会报错，比如：<code>mvn --version</code>, Jenkins容器内部默认是没有安装Maven的。</p><h2 id="2-流水线项目"><a href="#2-流水线项目" class="headerlink" title="2. 流水线项目"></a>2. 流水线项目</h2><h3 id="2-1-安装插件"><a href="#2-1-安装插件" class="headerlink" title="2.1 安装插件"></a>2.1 安装插件</h3><p>流水线任务需要**<code>Pipeline插件</code>**的支持，在创建流水线任务之前，先确保Jenkins已安装 <code>Pipeline插件</code> 。</p><p>具体在：Dashboard –&gt; 系统管理 –&gt; 插件管理 中安装</p><p><img src="https://raw.githubusercontent.com/GeorgeChan95/blogimg/master/img/2024/01/04/20240104-154146.png" alt="image-20240104154145155"></p><h3 id="2-2-配置流水线任务"><a href="#2-2-配置流水线任务" class="headerlink" title="2.2 配置流水线任务"></a>2.2 配置流水线任务</h3><ol><li>填写 <code>任务名称</code></li><li>选择 <code>构建一个Pipeline项目</code></li><li>点击 <code>确定</code></li></ol><p><img src="https://raw.githubusercontent.com/GeorgeChan95/blogimg/master/img/2024/01/04/20240104-154701.png" alt="image-20240104154700551"></p><pre><code class="highlight plaintext"></code></pre><ul><li>编辑脚本，点击 <code>保存</code></li></ul><p><img src="https://raw.githubusercontent.com/GeorgeChan95/blogimg/master/img/2024/01/04/20240104-154520.png" alt="image-20240104154518639"></p><ul><li>运行任务，查看运行结果</li></ul><p><img src="https://raw.githubusercontent.com/GeorgeChan95/blogimg/master/img/2024/01/04/20240104-154549.png" alt="image-20240104154548082"></p><h1 id="六、Jenkins部署运维后端代码"><a href="#六、Jenkins部署运维后端代码" class="headerlink" title="六、Jenkins部署运维后端代码"></a>六、Jenkins部署运维后端代码</h1><blockquote><p><strong>操作步骤</strong></p><ul><li>指定部署节点<ul><li>部署节点为Jenkins服务所在节点的从节点，也叫：代理节点</li><li>主节点与代理节点之间通过SSH方式连接</li></ul></li><li>代理节点拉取代码<ul><li>代理节点需要安装Git</li></ul></li><li>代理节点将打包打成jar包<ul><li>代理节点需要安装Maven、JDK</li></ul></li><li>代理节点将Jar包制作成Docker镜像<ul><li>代理节点需要安装Docker</li></ul></li><li>代理节点运行docker镜像<ul><li>通过shell命令行</li></ul></li></ul></blockquote><h2 id="1-代理节点配置软连接"><a href="#1-代理节点配置软连接" class="headerlink" title="1. 代理节点配置软连接"></a>1. 代理节点配置软连接</h2><p>master节点ssh连接agent节点时需要&#x2F;usr&#x2F;bin&#x2F;有java命令。配置java的软连接、同理配置maven、git的软连接。如果软件是yum安装的，则需要检查&#x2F;usr&#x2F;bin中是否有相关命令。如果没有,也需要做软连接。</p><pre><code class="highlight shell">ln -s /opt/module/jdk-11.0.19/bin/java /usr/bin/ln -s /opt/module/apache-maven-3.6.3/bin/mvn /usr/bin/ln -s /opt/module/git/bin/git /usr/bin/</code></pre><h2 id="2-添加代理节点"><a href="#2-添加代理节点" class="headerlink" title="2. 添加代理节点"></a>2. 添加代理节点</h2><h3 id="2-1-进入节点列表页面"><a href="#2-1-进入节点列表页面" class="headerlink" title="2.1 进入节点列表页面"></a>2.1 进入节点列表页面</h3><ul><li>点击 <strong>系统管理</strong></li><li>点击 <strong>节点列表</strong></li></ul><p><img src="https://raw.githubusercontent.com/GeorgeChan95/blogimg/master/img/2024/01/04/20240104-160922.png" alt="image-20240104160920865"></p><h3 id="2-2-添加节点"><a href="#2-2-添加节点" class="headerlink" title="2.2 添加节点"></a>2.2 添加节点</h3><ul><li>点击 <strong>新建节点</strong></li></ul><p><img src="https://raw.githubusercontent.com/GeorgeChan95/blogimg/master/img/2024/01/04/20240104-161402.png" alt="20240104-161007"></p><h3 id="2-3-编辑节点名称和属性"><a href="#2-3-编辑节点名称和属性" class="headerlink" title="2.3 编辑节点名称和属性"></a>2.3 编辑节点名称和属性</h3><ul><li>填写 <strong>节点名称</strong></li><li>选择 <strong>固定节点</strong></li><li>点击 <strong>创建</strong></li></ul><p><img src="https://raw.githubusercontent.com/GeorgeChan95/blogimg/master/img/2024/01/04/20240104-161048.png" alt="image-20240104161046707"></p><h3 id="2-4-配置节点"><a href="#2-4-配置节点" class="headerlink" title="2.4 配置节点"></a>2.4 配置节点</h3><ul><li><p>名称：填写节点名称，用于展示</p></li><li><p>描述：填写节点描述，可不填</p></li><li><p>执行器数量：最小是1，建议跟服务器内核数一致。</p></li><li><p>远程工作目录：Jenkins运行的目录，提前在代理服务器上创建好</p><pre><code class="highlight shell"><span class="meta prompt_"># </span><span class="language-bash">在代理节点上创建工作目录</span>mkdir -p /data/workspaces</code></pre></li><li><p>标签：代理节点的标签，也是代理节点的唯一标识</p></li><li><p>用法：选择 仅在此节点上运行</p></li><li><p>启动方式：选择 <code>Launch agents via SSH</code></p><ul><li>主机：代理节点IP</li><li>凭据：选择给代理节点配置的凭据，没有则点击下方的 <code>添加</code> 按钮创建凭据</li><li>主机验证方式：选择 <code>Non verifying Verification Strategy</code></li></ul></li><li><p>可用性：选择 <code>尽可能在此节点上运行</code></p></li><li><p>点击 <code>保存</code></p></li></ul><p><img src="https://raw.githubusercontent.com/GeorgeChan95/blogimg/master/img/2024/01/05/20240105-094026.png" alt="image-20240105094022222"></p><p><img src="https://raw.githubusercontent.com/GeorgeChan95/blogimg/master/img/2024/01/05/20240105-094041.png" alt="image-20240105094040027"></p><h3 id="2-5-添加凭据"><a href="#2-5-添加凭据" class="headerlink" title="2.5 添加凭据"></a>2.5 添加凭据</h3><ol><li><p>在节点配置页面点击 <code>添加</code> 按钮</p><p><img src="https://raw.githubusercontent.com/GeorgeChan95/blogimg/master/img/2024/01/05/20240105-095652.png" alt="image-20240105095650742"></p></li><li><p>点击 <code>Jenkins</code> 进入凭据配置页面</p><ol><li><p>作用域：选择 <code>全局凭据</code></p></li><li><p>类型：选择 <code>SSH Username with private key</code></p></li><li><p>范围：全局</p></li><li><p>ID：不用填，配置完成保存后会自动生成</p></li><li><p>描述：凭据的描述，可不填</p></li><li><p>Username：代理节点的root用户密码</p></li><li><p>Private Key：对应的就是Jenkins主节点生成的私钥信息</p><ol><li><p>勾选 <code>Enter directly</code></p></li><li><p>输入Jenkins主节点完整的私钥信息</p></li><li><p>这里首先要配置主节点与代理节点的免密登录，具体方式如下：</p><pre><code class="highlight shell"><span class="meta prompt_"># </span><span class="language-bash">在master节点生成密钥</span>ssh-keygen -t rsa<span class="meta prompt_"></span><span class="meta prompt_"># </span><span class="language-bash">复制公钥到agent节点</span>ssh-copy-id -i /root/.ssh/id_rsa.pub root@192.168.6.91<span class="meta prompt_"></span><span class="meta prompt_"># </span><span class="language-bash">免密登录测试</span>ssh 192.168.6.91<span class="meta prompt_"></span><span class="meta prompt_"># </span><span class="language-bash">查看私钥信息(主节点执行)</span>cat /root/.ssh/id_rsa</code></pre></li></ol></li><li><p>密码：填写代理服务器root用户登录密码</p></li></ol><p><img src="https://raw.githubusercontent.com/GeorgeChan95/blogimg/master/img/2024/01/05/20240105-100853.png" alt="image-20240105100852505"></p><p><img src="https://raw.githubusercontent.com/GeorgeChan95/blogimg/master/img/2024/01/05/20240105-100910.png" alt="image-20240105100909305"></p></li><li><p>点击 <code>添加</code>，保存凭据</p><p>此时在 代理节点配置页面，就可以勾选刚才配置的凭据信息了</p><p><img src="https://raw.githubusercontent.com/GeorgeChan95/blogimg/master/img/2024/01/05/20240105-101018.png" alt="image-20240105101017536"></p></li></ol><h2 id="3-配置Gitlab凭据"><a href="#3-配置Gitlab凭据" class="headerlink" title="3. 配置Gitlab凭据"></a>3. 配置Gitlab凭据</h2><p>Jenkins工作台 –&gt; 系统管理 –&gt; credentials –&gt; 在Stores scoped to Jenkins下的’全局’ –&gt; 添加凭据</p><ul><li>类型：Username with password </li><li>范围：全局</li><li>用户名：登录Gitlab的用户名 </li><li>密码：登录Gitlab的密码 </li><li>ID：不用填，自动生成 </li><li>描述：可不填</li></ul><p><img src="https://raw.githubusercontent.com/GeorgeChan95/blogimg/master/img/2024/01/05/20240105-104816.png" alt="image-20240105104814964"></p><p><img src="https://raw.githubusercontent.com/GeorgeChan95/blogimg/master/img/2024/01/05/20240105-104854.png" alt="image-20240105104853462"></p><p><img src="https://raw.githubusercontent.com/GeorgeChan95/blogimg/master/img/2024/01/05/20240105-105426.png" alt="image-20240105105424488"></p><h2 id="4-配置Pipeline流水线任务"><a href="#4-配置Pipeline流水线任务" class="headerlink" title="4. 配置Pipeline流水线任务"></a>4. 配置Pipeline流水线任务</h2><h3 id="4-1-新建任务"><a href="#4-1-新建任务" class="headerlink" title="4.1 新建任务"></a>4.1 新建任务</h3><p><img src="https://raw.githubusercontent.com/GeorgeChan95/blogimg/master/img/2024/01/05/20240105-110053.png" alt="image-20240105110052243"></p><h3 id="4-2-配置任务"><a href="#4-2-配置任务" class="headerlink" title="4.2 配置任务"></a>4.2 配置任务</h3><ul><li><p>定义：选择 <code>Pipeline script from SCM</code></p><ul><li>SCM: 选择 Git</li><li>Repository URL：填写项目Git地址</li><li>凭据：选择gitlab登录凭据，没有则添加</li><li>构建分支：默认Master分支</li><li>源码库浏览器：自动</li></ul></li><li><p>脚本路径：Jenkinsfile (名称不要改，使用默认的)</p><p><img src="https://raw.githubusercontent.com/GeorgeChan95/blogimg/master/img/2024/01/05/20240105-135233.png" alt="image-20240105135231905"></p><p><img src="https://raw.githubusercontent.com/GeorgeChan95/blogimg/master/img/2024/01/05/20240105-135247.png" alt="image-20240105135246088"></p></li><li><p>添加Gitlab凭据</p><ul><li><p>任务配置页面，<code>凭据</code> 下点击 <code>添加</code>  </p></li><li><p>凭据页面配置如下：</p><ul><li>Domain：全局</li><li>类型：Username with password</li><li>范围：全局</li><li>用户名：root</li><li>密码：root用户密码</li><li>ID：不用填，会自动生成</li><li>描述：可不填</li></ul><p><img src="https://raw.githubusercontent.com/GeorgeChan95/blogimg/master/img/2024/01/05/20240105-135134.png" alt="image-20240105135133467"></p><p><img src="https://raw.githubusercontent.com/GeorgeChan95/blogimg/master/img/2024/01/05/20240105-135150.png" alt="image-20240105135149397"></p></li></ul></li></ul><h2 id="5-编辑-Jenkinsfile-文件"><a href="#5-编辑-Jenkinsfile-文件" class="headerlink" title="5. 编辑 Jenkinsfile 文件"></a>5. 编辑 Jenkinsfile 文件</h2><ul><li>该文件名称必须为 Jenkinsfile ,大小写要完全一致</li><li>该文件要在项目的根路径下</li><li>文件内容使用按照流水线格式，采用Groovy语法编写，可使用 <code>流水线语法</code> 生成器生成片段</li></ul><h3 id="5-1-流水线语法生成器"><a href="#5-1-流水线语法生成器" class="headerlink" title="5.1 流水线语法生成器"></a>5.1 流水线语法生成器</h3><p>在流水线任务配置页面，下拉到页面最下方，点击 <code>流水线语法</code> ，打开流水线语法生成页面。</p><p><img src="https://raw.githubusercontent.com/GeorgeChan95/blogimg/master/img/2024/01/05/20240105-135904.png" alt="image-20240105135903283"></p><p><img src="https://raw.githubusercontent.com/GeorgeChan95/blogimg/master/img/2024/01/05/20240105-135919.png" alt="image-20240105135918483"></p><h4 id="5-1-1-实例：生成git-拉取代码指令"><a href="#5-1-1-实例：生成git-拉取代码指令" class="headerlink" title="5.1.1 实例：生成git 拉取代码指令"></a>5.1.1 实例：生成git 拉取代码指令</h4><p><img src="https://raw.githubusercontent.com/GeorgeChan95/blogimg/master/img/2024/01/05/20240105-140209.png" alt="image-20240105140207616"></p><p><img src="https://raw.githubusercontent.com/GeorgeChan95/blogimg/master/img/2024/01/05/20240105-140254.png" alt="image-20240105140253107"></p><h3 id="5-2-Jenkinsfile-内容如下"><a href="#5-2-Jenkinsfile-内容如下" class="headerlink" title="5.2 Jenkinsfile 内容如下"></a>5.2 Jenkinsfile 内容如下</h3><pre><code class="highlight groovy">pipeline &#123;    agent &#123;        label <span class="string">&#x27;agent-6-91&#x27;</span>    &#125;    stages &#123;        stage(<span class="string">&#x27;检测环境&#x27;</span>) &#123;            steps &#123;                echo <span class="string">&#x27;开始检测环境&#x27;</span>                sh <span class="string">&#x27;&#x27;&#x27;java -version</span><span class="string">                mvn -v</span><span class="string">                docker -v</span><span class="string">                git version&#x27;&#x27;&#x27;</span>            &#125;        &#125;        stage(<span class="string">&#x27;拉取代码&#x27;</span>) &#123;            steps &#123;                echo <span class="string">&#x27;开始拉取代码&#x27;</span>                checkout scmGit(<span class="attr">branches:</span> [[<span class="attr">name:</span> <span class="string">&#x27;*/master&#x27;</span>]], <span class="attr">extensions:</span> [], <span class="attr">userRemoteConfigs:</span> [[<span class="attr">credentialsId:</span> <span class="string">&#x27;5c2185ef-6204-4c3b-b6dc-92b0ea5e55a1&#x27;</span>, <span class="attr">url:</span> <span class="string">&#x27;http://192.168.6.211:3060/GeorgeChan/ioms-test.git&#x27;</span>]])            &#125;        &#125;        stage(<span class="string">&#x27;编译构建&#x27;</span>) &#123;            steps &#123;                echo <span class="string">&#x27;开始执行代码编译&#x27;</span>sh <span class="string">&#x27;mvn clean package -pl ioms-eureka -am -Dmaven.test.skip=true -Ddockerfile.skip=true&#x27;</span>            &#125;        &#125;stage(<span class="string">&#x27;登录Harbor&#x27;</span>) &#123;            steps &#123;                echo <span class="string">&#x27;开始执行登录Harbor&#x27;</span>                sh <span class="string">&#x27;docker login -u admin -p Harbor12345 192.168.6.201:5000&#x27;</span>            &#125;        &#125;        stage(<span class="string">&#x27;运行ioms-eureka&#x27;</span>) &#123;            steps &#123;                echo <span class="string">&#x27;开始执行ioms-eureka模块的镜像构建、容器运行&#x27;</span>                script &#123;                    <span class="comment">// 定义当前工作空间变量</span>                    <span class="keyword">def</span> currentWorkspace = env.WORKSPACE                    echo <span class="string">&quot;当前工作空间：$&#123;currentWorkspace&#125;&quot;</span>                    <span class="keyword">def</span> currentModule = <span class="string">&quot;ioms-eureka&quot;</span>                    <span class="comment">// 删除容器</span>                    sh <span class="string">&quot;&quot;&quot;</span><span class="string">                        echo &quot;检查容器 $&#123;currentModule&#125; 是否存在&quot;</span><span class="string">                        containerid=\$(docker ps -a | grep -w $&#123;currentModule&#125; | awk &#x27;&#123;print \$1&#125;&#x27;)</span><span class="string">                        if [ &quot;\$containerid&quot; != &quot;&quot; ]; then</span><span class="string">                            echo &#x27;容器存在，停止容器&#x27;</span><span class="string">                            docker stop \$containerid</span><span class="string">                            echo &#x27;删除容器&#x27;</span><span class="string">                            docker rm \$containerid</span><span class="string">                        fi</span><span class="string">                    &quot;&quot;&quot;</span>                    <span class="comment">// 删除镜像</span>                    sh <span class="string">&quot;&quot;&quot;</span><span class="string">                        echo &quot;检查镜像 $&#123;currentModule&#125; 是否存在&quot;</span><span class="string">                        imageid=\$(docker images | grep $&#123;currentModule&#125; | awk &#x27;&#123;print \$3&#125;&#x27;)</span><span class="string">                        if [ &quot;\$imageid&quot; != &quot;&quot; ]; then</span><span class="string">                             echo &#x27;删除镜像&#x27;</span><span class="string">                             docker rmi -f \$imageid</span><span class="string">                        fi</span><span class="string">                    &quot;&quot;&quot;</span>                    <span class="comment">// 执行 mvn dockerfile:build 命令</span>                    <span class="comment">// 构建镜像，并获取日志输出</span>                    <span class="keyword">def</span> buildOutput = sh(<span class="attr">returnStdout:</span> <span class="literal">true</span>, <span class="attr">script:</span> <span class="string">&quot;mvn dockerfile:build -pl ioms-eureka -DdockerfileDirectory=$&#123;currentWorkspace&#125;/$&#123;currentModule&#125;&quot;</span>)                    <span class="keyword">def</span> imageName = <span class="string">&quot;&quot;</span>                    <span class="keyword">def</span> tag = <span class="string">&quot;&quot;</span>                    <span class="comment">// 将日志用换行符切分</span>                    <span class="keyword">def</span> lines = buildOutput.split(<span class="string">&#x27;\n&#x27;</span>)                    <span class="comment">// 遍历日志，获取构建的镜像的名称</span>                    lines.each &#123; line -&gt;                        <span class="keyword">def</span> lineStr = line.toString()  <span class="comment">// 将列表元素转换为字符串</span><span class="comment">//                        echo lineStr</span>                        <span class="keyword">if</span> (lineStr.startsWith(<span class="string">&quot;[INFO] Successfully tagged&quot;</span>)) &#123;                            imageName = lineStr.substring(lineStr.indexOf(<span class="string">&quot;[INFO] Successfully tagged&quot;</span>) + <span class="string">&quot;[INFO] Successfully tagged&quot;</span>.length()).trim()                            <span class="comment">// 192.168.6.201:5000/ioms-hf/ioms-eureka:1.0-SNAPSHOT</span>                            tag = imageName.split(<span class="string">&quot;:&quot;</span>)[<span class="number">2</span>];                        &#125;                    &#125;                    echo <span class="string">&quot;生成的镜像名称：$&#123;imageName&#125;&quot;</span>                    echo <span class="string">&quot;生成的镜像Tag：$&#123;tag&#125;&quot;</span>                    echo <span class="string">&quot;开始执行运行$&#123;currentModule&#125;容器&quot;</span>                    sh <span class="string">&quot;docker-compose up -d $&#123;currentModule&#125;&quot;</span>                &#125;            &#125;        &#125;        stage(<span class="string">&#x27;构建结束&#x27;</span>) &#123;            steps &#123;                echo <span class="string">&#x27;已成功构建所有模块&#x27;</span>            &#125;        &#125;    &#125;&#125;</code></pre><h2 id="6-运行Pipeline任务"><a href="#6-运行Pipeline任务" class="headerlink" title="6. 运行Pipeline任务"></a>6. 运行Pipeline任务</h2><h3 id="6-1-立即构建"><a href="#6-1-立即构建" class="headerlink" title="6.1 立即构建"></a>6.1 立即构建</h3><p><img src="https://raw.githubusercontent.com/GeorgeChan95/blogimg/master/img/2024/01/05/20240105-143447.png" alt="image-20240105143445338"></p><h3 id="6-2-查看构建过程"><a href="#6-2-查看构建过程" class="headerlink" title="6.2 查看构建过程"></a>6.2 查看构建过程</h3><p><img src="https://raw.githubusercontent.com/GeorgeChan95/blogimg/master/img/2024/01/05/20240105-143514.png" alt="image-20240105143512649"></p><p><img src="https://raw.githubusercontent.com/GeorgeChan95/blogimg/master/img/2024/01/05/20240105-143528.png" alt="image-20240105143526531"></p><h3 id="6-3-验证结果"><a href="#6-3-验证结果" class="headerlink" title="6.3 验证结果"></a>6.3 验证结果</h3><p>浏览器打开eureka访问页面</p><p><a href="http://192.168.6.91:8761/">http://192.168.6.91:8761/</a></p><p><img src="https://raw.githubusercontent.com/GeorgeChan95/blogimg/master/img/2024/01/05/20240105-143710.png" alt="image-20240105143708987"></p><h2 id="7-其它"><a href="#7-其它" class="headerlink" title="7. 其它"></a>7. 其它</h2><ul><li>上述所有操作的前提是，要在代理节点安装JDK、Git、Maven，并正确配置环境变量。这些都比较基础，自行补充，这里不再重复。</li><li>Jenkins的中文支持，有时候重启会失效，这个不影响操作。</li></ul><h1 id="七、Jenkins部署运维系统前端代码"><a href="#七、Jenkins部署运维系统前端代码" class="headerlink" title="七、Jenkins部署运维系统前端代码"></a>七、Jenkins部署运维系统前端代码</h1><h2 id="1-安装插件"><a href="#1-安装插件" class="headerlink" title="1. 安装插件"></a>1. 安装插件</h2><p>Jenkins要部署前端代码，需要安装两个必要的插件</p><ul><li>Publish Over SSH  用于登录远程服务器，和向远程服务器发送文件</li><li>NodeJs  用于代码的打包</li></ul><p><img src="https://raw.githubusercontent.com/GeorgeChan95/blogimg/master/img/2024/01/05/20240105-145120.png" alt="image-20240105145119424"></p><p><img src="https://raw.githubusercontent.com/GeorgeChan95/blogimg/master/img/2024/01/05/20240105-145257.png" alt="image-20240105145255475"></p><h2 id="2-配置远程服务器的连接"><a href="#2-配置远程服务器的连接" class="headerlink" title="2. 配置远程服务器的连接"></a>2. 配置远程服务器的连接</h2><p>1、打开“系统管理”–“系统设置” 找到 “Publish over SSH” 项 , 配置SSH Server</p><ul><li>Name：给要配置的服务器起个名字</li><li>Hostname：服务器IP</li><li>Username：登录用户名</li><li>Remote Directory：登陆成功后默认进入的目录</li><li>Password：登录用户密码</li></ul><p><img src="https://raw.githubusercontent.com/GeorgeChan95/blogimg/master/img/2024/01/05/20240105-145822.png" alt="image-20240105145821255"></p><p>2、点击 Test Configuration 按钮测试连接是否成功</p><p><img src="https://raw.githubusercontent.com/GeorgeChan95/blogimg/master/img/2024/01/05/20240105-150137.png" alt="image-20240105150135367"></p><h2 id="3-配置NodeJS"><a href="#3-配置NodeJS" class="headerlink" title="3. 配置NodeJS"></a>3. 配置NodeJS</h2><p>打开“系统管理” –&gt; “全局工具配置”， 找到NodeJS， 新增NodeJS</p><ul><li>别名：NodeJS名称</li><li>版本：选择适用的NodeJS版本</li></ul><p><img src="https://raw.githubusercontent.com/GeorgeChan95/blogimg/master/img/2024/01/05/20240105-150653.png" alt="image-20240105150651858"></p><h2 id="4-新建流水线任务"><a href="#4-新建流水线任务" class="headerlink" title="4. 新建流水线任务"></a>4. 新建流水线任务</h2><h3 id="3-1-新建一个自由风格项目"><a href="#3-1-新建一个自由风格项目" class="headerlink" title="3.1 新建一个自由风格项目"></a>3.1 新建一个自由风格项目</h3><p><img src="https://raw.githubusercontent.com/GeorgeChan95/blogimg/master/img/2024/01/05/20240105-153628.png" alt="image-20240105153627066"></p><h3 id="3-2-配置任务"><a href="#3-2-配置任务" class="headerlink" title="3.2 配置任务"></a>3.2 配置任务</h3><ul><li><p>限制项目的运行节点：选择要部署的服务器</p></li><li><p>源码管理：选择Git</p><ul><li>Repository URL：前端代码Git地址</li><li>Credentials：Gitlab登录凭证</li><li>Branches to build：Git拉取的代码分支，默认Master</li></ul></li><li><p>构建环境</p><ul><li>Provide Node &amp; npm bin&#x2F; folder to PATH：选择适配的NodeJS版本</li></ul></li><li><p>Build Steps</p><ul><li><p>选择 <code>执行Shell</code></p></li><li><p>内容如下：</p><pre><code class="highlight shell"><span class="meta prompt_"># </span><span class="language-bash">进入Jenkins工作空间下hxkj项目目录</span>cd /data/workspaces/workspace/ioms-html<span class="meta prompt_"></span><span class="meta prompt_">#</span><span class="language-bash"><span class="comment">##</span></span><span class="meta prompt_"># </span><span class="language-bash">npm切换为淘宝源</span>npm config set registry http://registry.npm.taobao.org/<span class="meta prompt_"></span><span class="meta prompt_"># </span><span class="language-bash">删除已有的构建包</span>rm -rf ./dist/rm -rf dist.tar.gz<span class="meta prompt_"></span><span class="meta prompt_"># </span><span class="language-bash">安装依赖，跳过安全审计</span>npm --no-audit i --force<span class="meta prompt_"></span><span class="meta prompt_"># </span><span class="language-bash">构建项目</span>npm run test<span class="meta prompt_"></span><span class="meta prompt_"># </span><span class="language-bash">压缩方便移动到项目部署目录</span>tar -zcvf dist.tar.gz dist</code></pre></li></ul></li><li><p>构建后操作</p><ul><li><p>配置SSH Server</p><ul><li><p>Name：选择部署的服务器</p></li><li><p>Transfer Set Source files：前端打包后的文件名</p></li><li><p>Remove prefix：要去除的文件前缀</p></li><li><p>Remote directory：要进入的远程服务器的文件夹路径</p></li><li><p>Exec command：进入文件夹后，执行的shell命令</p><pre><code class="highlight shell">cd /usr/local/docker/data/nginx/html/dist-white/echo &quot;工作路径：&quot; $(pwd)mv ./dist ./dist$(date +&#x27;%Y%m%d%H%M&#x27;)tar -zxvf dist.tar.gz -C ./docker restart ioms-nginxrm -rf dist.tar.gz</code></pre></li></ul></li></ul></li></ul><h2 id="5-执行构建任务"><a href="#5-执行构建任务" class="headerlink" title="5. 执行构建任务"></a>5. 执行构建任务</h2><h3 id="5-1-立即构建"><a href="#5-1-立即构建" class="headerlink" title="5.1 立即构建"></a>5.1 立即构建</h3><p><img src="https://raw.githubusercontent.com/GeorgeChan95/blogimg/master/img/2024/01/05/20240105-154823.png" alt="image-20240105154821435"></p><h3 id="5-2-查看构建过程"><a href="#5-2-查看构建过程" class="headerlink" title="5.2 查看构建过程"></a>5.2 查看构建过程</h3><p><img src="https://raw.githubusercontent.com/GeorgeChan95/blogimg/master/img/2024/01/05/20240105-154937.png" alt="image-20240105154935476"></p><p><img src="https://raw.githubusercontent.com/GeorgeChan95/blogimg/master/img/2024/01/05/20240105-154947.png" alt="image-20240105154945457"></p><h3 id="5-3-验证结果"><a href="#5-3-验证结果" class="headerlink" title="5.3 验证结果"></a>5.3 验证结果</h3><p><img src="https://raw.githubusercontent.com/GeorgeChan95/blogimg/master/img/2024/01/05/20240105-155023.png" alt="image-20240105155022077"></p>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 style=&quot;text-align: center;&quot;&gt;Jenkins的安装和搭建自动化部署平台&lt;/h1&gt;



&lt;h1 id=&quot;环境&quot;&gt;&lt;a href=&quot;#环境&quot; class=&quot;headerlink&quot; title=&quot;环境&quot;&gt;&lt;/a&gt;环境&lt;/h1&gt;&lt;blockquote&gt;</summary>
      
    
    
    
    <category term="linux" scheme="https://georgechan95.github.io/categories/linux/"/>
    
    
    <category term="linux" scheme="https://georgechan95.github.io/tags/linux/"/>
    
    <category term="jenkins" scheme="https://georgechan95.github.io/tags/jenkins/"/>
    
  </entry>
  
  <entry>
    <title>第十一章-StringTable(字符串常量池)</title>
    <link href="https://georgechan95.github.io/2023/12/25/jvm/%E7%AC%AC%E5%8D%81%E4%B8%80%E7%AB%A0-StringTable/"/>
    <id>https://georgechan95.github.io/2023/12/25/jvm/%E7%AC%AC%E5%8D%81%E4%B8%80%E7%AB%A0-StringTable/</id>
    <published>2023-12-25T09:27:06.000Z</published>
    <updated>2024-06-22T10:36:12.823Z</updated>
    
    <content type="html"><![CDATA[<h1 id="环境"><a href="#环境" class="headerlink" title="环境"></a>环境</h1><blockquote><p>系统 : Windows 10<br>JDK : 1.8</p></blockquote><h1 id="一、String的基本特性"><a href="#一、String的基本特性" class="headerlink" title="一、String的基本特性"></a>一、String的基本特性</h1><ul><li><p>String：字符串，使用一对 “ ” 引起来表示</p></li><li><p>String被声明为final的，不可被继承</p></li><li><p>String实现了Serializable接口：表示字符串是支持序列化的。实现了Comparable接口：表示String可以比较大小</p></li><li><p>String在jdk8及以前内部定义了 <code>final char value[]</code> 用于存储字符串数据。JDK9时改为 <code>byte[]</code></p></li></ul><h1 id="二、为什么-JDK9-改变了-String-的结构"><a href="#二、为什么-JDK9-改变了-String-的结构" class="headerlink" title="二、为什么 JDK9 改变了 String 的结构"></a>二、为什么 JDK9 改变了 String 的结构</h1><blockquote><p>官方解释：<a href="https://openjdk.org/jeps/254">https://openjdk.org/jeps/254</a></p></blockquote><p><strong>为什么改为 byte[] 存储？</strong></p><ul><li>String类的当前实现将字符存储在char数组中，每个字符使用两个字节(16位)。</li><li>从许多不同的应用程序收集的数据表明，字符串是堆使用的主要组成部分，而且大多数字符串对象只包含拉丁字符（Latin-1）。这些字符只需要一个字节的存储空间，因此这些字符串对象的内部char数组中有一半的空间将不会使用，产生了大量浪费。</li><li>之前 String 类使用 UTF-16 的 char[] 数组存储，现在改为 byte[] 数组 外加一个编码标识存储。该编码表示如果你的字符是ISO-8859-1或者Latin-1，那么只需要一个字节存。如果你是其它字符集，比如UTF-8，你仍然用两个字节存.</li><li>结论：String再也不用char[] 来存储了，改成了byte [] 加上编码标记，节约了一些空间</li><li>同时基于String的数据结构，例如StringBuffer和StringBuilder也同样做了修改</li></ul><pre><code class="highlight java"><span class="comment">// 之前</span><span class="keyword">private</span> <span class="keyword">final</span> <span class="type">char</span> value[];<span class="comment">// 之后</span><span class="keyword">private</span> <span class="keyword">final</span> <span class="type">byte</span>[] value</code></pre><h2 id="1-String-的基本特性"><a href="#1-String-的基本特性" class="headerlink" title="1. String 的基本特性"></a>1. String 的基本特性</h2><ul><li>String：代表不可变的字符序列。简称：不可变性。<ul><li>当对字符串重新赋值时，需要重写指定内存区域赋值，不能使用原有的value进行赋值。</li><li>当对现有的字符串进行连接操作时，也需要重新指定内存区域赋值，不能使用原有的value进行赋值。</li><li>当调用String的replace()方法修改指定字符或字符串时，也需要重新指定内存区域赋值，不能使用原有的value进行赋值。</li></ul></li><li>通过字面量的方式（区别于new）给一个字符串赋值，此时的字符串值声明在字符串常量池中。</li></ul><p><strong>特性1：当对字符串重新赋值时，需要重写指定内存区域赋值，不能使用原有的value进行赋值</strong></p><blockquote><p>JAVA代码</p></blockquote><pre><code class="highlight java"><span class="meta">@Test</span><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">test1</span><span class="params">()</span> &#123;    <span class="type">String</span> <span class="variable">s1</span> <span class="operator">=</span> <span class="string">&quot;abc&quot;</span>;<span class="comment">//字面量定义的方式，&quot;abc&quot;存储在字符串常量池中</span>    <span class="type">String</span> <span class="variable">s2</span> <span class="operator">=</span> <span class="string">&quot;abc&quot;</span>;    s1 = <span class="string">&quot;hello&quot;</span>;    System.out.println(s1 == s2);<span class="comment">//判断地址：true  --&gt; false</span>    System.out.println(s1);<span class="comment">//</span>    System.out.println(s2);<span class="comment">//abc</span>&#125;</code></pre><blockquote><p>字节码</p></blockquote><pre><code class="highlight plaintext"> 0 ldc #2 &lt;abc&gt; 2 astore_1 3 ldc #2 &lt;abc&gt; 5 astore_2 6 ldc #3 &lt;hello&gt; 8 astore_1 9 getstatic #4 &lt;java/lang/System.out : Ljava/io/PrintStream;&gt;12 aload_113 aload_214 if_acmpne 21 (+7)17 iconst_118 goto 22 (+4)21 iconst_022 invokevirtual #5 &lt;java/io/PrintStream.println : (Z)V&gt;25 getstatic #4 &lt;java/lang/System.out : Ljava/io/PrintStream;&gt;28 aload_129 invokevirtual #6 &lt;java/io/PrintStream.println : (Ljava/lang/String;)V&gt;32 getstatic #4 &lt;java/lang/System.out : Ljava/io/PrintStream;&gt;35 aload_236 invokevirtual #6 &lt;java/io/PrintStream.println : (Ljava/lang/String;)V&gt;39 return</code></pre><p>可以看出：</p><ul><li>取字符串 “abc” 时，使用的是同一个符号引用：#2</li><li>取字符串 “hello” 时，使用的是另一个符号引用：#3</li></ul><p><strong>特性2：当对现有的字符串进行连接操作时，也需要重新指定内存区域赋值，不能使用原有的value进行赋值</strong></p><blockquote><p>示例</p></blockquote><pre><code class="highlight java"><span class="meta">@Test</span><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">test2</span><span class="params">()</span> &#123;    <span class="type">String</span> <span class="variable">s1</span> <span class="operator">=</span> <span class="string">&quot;abc&quot;</span>;    <span class="type">String</span> <span class="variable">s2</span> <span class="operator">=</span> <span class="string">&quot;abc&quot;</span>;    s2 += <span class="string">&quot;def&quot;</span>;    System.out.println(s2);<span class="comment">//abcdef</span>    System.out.println(s1);<span class="comment">//abc</span>&#125;</code></pre><p><strong>特性3：当调用string的replace()方法修改指定字符或字符串时，也需要重新指定内存区域赋值，不能使用原有的value进行赋值</strong></p><blockquote><p>示例</p></blockquote><pre><code class="highlight java"><span class="meta">@Test</span><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">test3</span><span class="params">()</span> &#123;    <span class="type">String</span> <span class="variable">s1</span> <span class="operator">=</span> <span class="string">&quot;abc&quot;</span>;    <span class="type">String</span> <span class="variable">s2</span> <span class="operator">=</span> s1.replace(<span class="string">&#x27;a&#x27;</span>, <span class="string">&#x27;m&#x27;</span>);    System.out.println(s1);<span class="comment">//abc</span>    System.out.println(s2);<span class="comment">//mbc</span>&#125;</code></pre><h2 id="练习题"><a href="#练习题" class="headerlink" title="练习题"></a>练习题</h2><pre><code class="highlight java"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">StringExer</span> &#123;    <span class="type">String</span> <span class="variable">str</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">String</span>(<span class="string">&quot;good&quot;</span>);    <span class="type">char</span>[] ch = &#123;<span class="string">&#x27;t&#x27;</span>, <span class="string">&#x27;e&#x27;</span>, <span class="string">&#x27;s&#x27;</span>, <span class="string">&#x27;t&#x27;</span>&#125;;    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">change</span><span class="params">(String str, <span class="type">char</span> ch[])</span> &#123;        str = <span class="string">&quot;test ok&quot;</span>;        ch[<span class="number">0</span>] = <span class="string">&#x27;b&#x27;</span>;    &#125;    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;        <span class="type">StringExer</span> <span class="variable">ex</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">StringExer</span>();        ex.change(ex.str, ex.ch);        System.out.println(ex.str);<span class="comment">//good</span>        System.out.println(ex.ch);<span class="comment">//best</span>    &#125;&#125;</code></pre><p>str 的内容并没有变：“test ok” 位于字符串常量池中的另一个区域（地址），进行赋值操作并没有修改原来 str 指向的引用的内容</p><h2 id="2-String-的底层结构"><a href="#2-String-的底层结构" class="headerlink" title="2. String 的底层结构"></a>2. String 的底层结构</h2><p><strong>字符串常量池中，每个对象都是唯一的，不会存储两个相同内容的字符串</strong></p><ul><li>String 的 String Pool（字符串常量池）是一个固定大小的Hashtable，默认值大小长度是1009。如果放进String Pool的String非常多，就会造成Hash冲突严重，从而导致链表会很长，而链表长了后直接会造成的影响就是当调用String.intern()方法时性能会大幅下降。</li><li>使用 <code>-XX:StringTablesize</code> 可设置StringTable的长度</li><li>在JDK6中StringTable是固定的，就是1009的长度，所以如果常量池中的字符串过多就会导致效率下降很快，StringTablesize设置没有要求</li><li>在JDK7中，StringTable的长度默认值是60013，StringTablesize设置没有要求</li><li>在JDK8中，StringTable的长度默认值是60013，StringTable可以设置的最小值为1009</li></ul><p><img src="https://raw.githubusercontent.com/GeorgeChan95/blogimg/master/img/2023/12/27/20231227-205050.png" alt="JDK8的StringTableSize"></p><h3 id="2-1-测试不同-StringTable-长度下，程序的性能"><a href="#2-1-测试不同-StringTable-长度下，程序的性能" class="headerlink" title="2.1 测试不同 StringTable 长度下，程序的性能"></a>2.1 测试不同 StringTable 长度下，程序的性能</h3><blockquote><p>代码，生成测试文件</p></blockquote><pre><code class="highlight java"><span class="comment">/**</span><span class="comment"> * 产生10万个长度不超过10的字符串，包含a-z,A-Z</span><span class="comment"> */</span><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">GenerateString</span> &#123;    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> IOException &#123;        <span class="type">FileWriter</span> <span class="variable">fw</span> <span class="operator">=</span>  <span class="keyword">new</span> <span class="title class_">FileWriter</span>(<span class="string">&quot;words.txt&quot;</span>);        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; <span class="number">100000</span>; i++) &#123;            <span class="comment">//1 - 10</span>           <span class="type">int</span> <span class="variable">length</span> <span class="operator">=</span> (<span class="type">int</span>)(Math.random() * (<span class="number">10</span> - <span class="number">1</span> + <span class="number">1</span>) + <span class="number">1</span>);            fw.write(getString(length) + <span class="string">&quot;\n&quot;</span>);        &#125;        fw.close();    &#125;    <span class="keyword">public</span> <span class="keyword">static</span> String <span class="title function_">getString</span><span class="params">(<span class="type">int</span> length)</span>&#123;        <span class="type">String</span> <span class="variable">str</span> <span class="operator">=</span> <span class="string">&quot;&quot;</span>;        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; length; i++) &#123;            <span class="comment">//65 - 90, 97-122</span>            <span class="type">int</span> <span class="variable">num</span> <span class="operator">=</span> (<span class="type">int</span>)(Math.random() * (<span class="number">90</span> - <span class="number">65</span> + <span class="number">1</span>) + <span class="number">65</span>) + (<span class="type">int</span>)(Math.random() * <span class="number">2</span>) * <span class="number">32</span>;            str += (<span class="type">char</span>)num;        &#125;        <span class="keyword">return</span> str;    &#125;&#125;</code></pre><blockquote><p>测试代码，配置VM option参数，测试StringTable对程序性能的影响</p></blockquote><pre><code class="highlight java"><span class="comment">/**</span><span class="comment"> *  -XX:StringTableSize=1009</span><span class="comment"> *  -XX:StringTableSize=100009</span><span class="comment"> */</span><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">StringTest2</span> &#123;    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;        <span class="comment">//测试StringTableSize参数</span><span class="comment">//        System.out.println(&quot;我来打个酱油&quot;);</span><span class="comment">//        try &#123;</span><span class="comment">//            Thread.sleep(1000000);</span><span class="comment">//        &#125; catch (InterruptedException e) &#123;</span><span class="comment">//            e.printStackTrace();</span><span class="comment">//        &#125;</span>        <span class="type">BufferedReader</span> <span class="variable">br</span> <span class="operator">=</span> <span class="literal">null</span>;        <span class="keyword">try</span> &#123;            br = <span class="keyword">new</span> <span class="title class_">BufferedReader</span>(<span class="keyword">new</span> <span class="title class_">FileReader</span>(<span class="string">&quot;words.txt&quot;</span>));            <span class="type">long</span> <span class="variable">start</span> <span class="operator">=</span> System.currentTimeMillis();            String data;            <span class="keyword">while</span>((data = br.readLine()) != <span class="literal">null</span>)&#123;                data.intern(); <span class="comment">//如果字符串常量池中没有对应data的字符串的话，则在常量池中生成</span>            &#125;            <span class="type">long</span> <span class="variable">end</span> <span class="operator">=</span> System.currentTimeMillis();            System.out.println(<span class="string">&quot;花费的时间为：&quot;</span> + (end - start));<span class="comment">//1009:152ms  100009:32ms</span>        &#125; <span class="keyword">catch</span> (IOException e) &#123;            e.printStackTrace();        &#125; <span class="keyword">finally</span> &#123;            <span class="keyword">if</span>(br != <span class="literal">null</span>)&#123;                <span class="keyword">try</span> &#123;                    br.close();                &#125; <span class="keyword">catch</span> (IOException e) &#123;                    e.printStackTrace();                &#125;            &#125;        &#125;    &#125;&#125;</code></pre><blockquote><p>测试结果</p></blockquote><ul><li>-XX:StringTableSize&#x3D;1009<ul><li>用时：152ms</li></ul></li><li>-XX:StringTableSize&#x3D;100009<ul><li>用时：32ms</li></ul></li></ul><h1 id="三、String-的内存分配"><a href="#三、String-的内存分配" class="headerlink" title="三、String 的内存分配"></a>三、String 的内存分配</h1><ul><li><p>在Java语言中有8种基本数据类型和一种比较特殊的类型String。这些类型为了使它们在运行过程中速度更快、更节省内存，都提供了一种常量池的概念。</p></li><li><p>常量池就类似一个Java系统级别提供的缓存。8种基本数据类型的常量池都是系统协调的，String类型的常量池比较特殊。它的主要使用方法有两种。</p><ul><li>直接使用双引号声明出来的String对象会直接存储在常量池中。比如：<code>String info=&quot;atguigu.com&quot;;</code></li><li>如果不是用双引号声明的String对象，可以使用String提供的 <code>intern()</code> 方法。</li></ul></li><li><p>Java 6及以前，字符串常量池存放在永久代</p></li><li><p>Java 7中 Oracle的工程师对字符串池的逻辑做了很大的改变，即将字符串常量池的位置调整到Java堆内</p><ul><li>所有的字符串都保存在堆（Heap）中，和其他普通对象一样，这样可以让你在进行调优应用时仅需要调整堆大小就可以了。</li><li>字符串常量池概念原本使用得比较多，但是这个改动使得我们有足够的理由让我们重新考虑在Java 7中使用String.intern()。</li></ul></li><li><p>Java8元空间，字符串常量在堆</p></li></ul><p><img src="https://raw.githubusercontent.com/GeorgeChan95/blogimg/master/img/2023/12/28/20231228-094121.png" alt="image-20231228094120058"></p><p><img src="https://raw.githubusercontent.com/GeorgeChan95/blogimg/master/img/2023/12/28/20231228-094414.png" alt="image-20231228094205567"></p><h2 id="1-StringTable-为什么要调整？"><a href="#1-StringTable-为什么要调整？" class="headerlink" title="1. StringTable 为什么要调整？"></a>1. StringTable 为什么要调整？</h2><blockquote><p><strong>官方文档：</strong><a href="https://www.oracle.com/java/technologies/javase/jdk7-relnotes.html#jdk7changes">https://www.oracle.com/java/technologies/javase/jdk7-relnotes.html#jdk7changes</a></p></blockquote><ul><li>为什么要调整位置？<ul><li>永久代的默认空间大小比较小</li><li>永久代垃圾回收频率低，大量的字符串无法及时回收，容易进行Full GC产生STW或者容易产生OOM：PermGen Space</li><li>堆中空间足够大，字符串可被及时回收</li></ul></li><li>在JDK 7中，interned字符串不再在Java堆的永久代中分配，而是在Java堆的主要部分（称为年轻代和年老代）中分配，与应用程序创建的其他对象一起分配。</li><li>此更改将导致驻留在主Java堆中的数据更多，驻留在永久生成中的数据更少，因此可能需要调整堆大小。</li></ul><blockquote><p>代码演示验证(JDK8)</p></blockquote><pre><code class="highlight java"><span class="comment">/**</span><span class="comment"> * jdk6中：</span><span class="comment"> * -XX:PermSize=6m -XX:MaxPermSize=6m -Xms6m -Xmx6m</span><span class="comment"> *</span><span class="comment"> * jdk8中：</span><span class="comment"> * -XX:MetaspaceSize=60m -XX:MaxMetaspaceSize=60m -Xms60m -Xmx60m</span><span class="comment"> */</span><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">StringTest3</span> &#123;    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;        <span class="comment">//使用Set保持着常量池引用，避免full gc回收常量池行为</span>        Set&lt;String&gt; set = <span class="keyword">new</span> <span class="title class_">HashSet</span>&lt;String&gt;();        <span class="comment">//在short可以取值的范围内足以让6MB的PermSize或heap产生OOM了。</span>        <span class="type">long</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>;        <span class="keyword">while</span>(<span class="literal">true</span>)&#123;            set.add(String.valueOf(i++).intern());        &#125;    &#125;&#125;</code></pre><blockquote><p>输出结果</p></blockquote><pre><code class="highlight plaintext">Exception in thread &quot;main&quot; java.lang.OutOfMemoryError: Java heap spaceat java.util.HashMap.newNode(HashMap.java:1750)at java.util.HashMap.putVal(HashMap.java:631)at java.util.HashMap.put(HashMap.java:612)at java.util.HashSet.add(HashSet.java:220)at com.atguigu.java.StringTest3.main(StringTest3.java:20)</code></pre><p><strong>结论：JDK8中字符串常量池在堆中</strong></p><h1 id="四、String-的基本操作"><a href="#四、String-的基本操作" class="headerlink" title="四、String 的基本操作"></a>四、String 的基本操作</h1><p>Java语言规范里要求完全相同的字符串字面量，应该包含同样的Unicode字符序列（包含同一份码点序列的常量），并且必须是指向同一个String类实例。</p><h2 id="1-示例1"><a href="#1-示例1" class="headerlink" title="1. 示例1"></a>1. 示例1</h2><ul><li>程序启动，已加载字符串常量 2126个</li></ul><img src="https://raw.githubusercontent.com/GeorgeChan95/blogimg/master/img/2023/12/28/20231228-103807.png" alt="image-20231228103806343" style="zoom: 80%;" /><ul><li>加载了一个换行符（println），字符串常量池加1</li></ul><img src="https://raw.githubusercontent.com/GeorgeChan95/blogimg/master/img/2023/12/28/20231228-104024.png" alt="image-20231228104023119" style="zoom:80%;" /><ul><li>加载了字符串常量 “1”~“9”</li></ul><img src="https://raw.githubusercontent.com/GeorgeChan95/blogimg/master/img/2023/12/28/20231228-104101.png" alt="image-20231228104100167" style="zoom:80%;" /><ul><li>加载字符串常量 “10”</li></ul><img src="https://raw.githubusercontent.com/GeorgeChan95/blogimg/master/img/2023/12/28/20231228-104138.png" alt="image-20231228104137366" style="zoom:80%;" /><ul><li>之后的字符串”1” 到 “10”不会再次加载</li></ul><img src="https://raw.githubusercontent.com/GeorgeChan95/blogimg/master/img/2023/12/28/20231228-104222.png" alt="image-20231228104220348" style="zoom:80%;" /><h1 id="五、字符串拼接操作"><a href="#五、字符串拼接操作" class="headerlink" title="五、字符串拼接操作"></a>五、字符串拼接操作</h1><h2 id="1-结论"><a href="#1-结论" class="headerlink" title="1. 结论"></a>1. 结论</h2><ul><li>常量与常量的拼接结果在常量池，原理是编译期优化</li><li>常量池中不会存在相同内容的变量</li><li>拼接前后，只要其中有一个是变量，结果就在堆中。变量拼接的原理是StringBuilder</li><li>如果拼接的结果调用intern()方法，根据该字符串是否在常量池中存在，分为：<ul><li>如果存在，则返回字符串在常量池中的地址</li><li>如果字符串常量池中不存在该字符串，则在常量池中创建一份，并返回此对象的地址</li></ul></li></ul><h2 id="2-结论解析"><a href="#2-结论解析" class="headerlink" title="2. 结论解析"></a>2. 结论解析</h2><ul><li><strong>常量与常量的拼接结果在常量池，原理是编译期优化</strong></li></ul><blockquote><p>代码</p></blockquote><pre><code class="highlight java"><span class="meta">@Test</span><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">test1</span><span class="params">()</span>&#123;    <span class="type">String</span> <span class="variable">s1</span> <span class="operator">=</span> <span class="string">&quot;a&quot;</span> + <span class="string">&quot;b&quot;</span> + <span class="string">&quot;c&quot;</span>;<span class="comment">//编译期优化：等同于&quot;abc&quot;</span>    <span class="type">String</span> <span class="variable">s2</span> <span class="operator">=</span> <span class="string">&quot;abc&quot;</span>; <span class="comment">//&quot;abc&quot;一定是放在字符串常量池中，将此地址赋给s2</span>    <span class="comment">/*</span><span class="comment">     * 最终.java编译成.class,再执行.class</span><span class="comment">     * String s1 = &quot;abc&quot;;</span><span class="comment">     * String s2 = &quot;abc&quot;</span><span class="comment">     */</span>    <span class="comment">//  ==：比较的是两个字符串内存地址（堆内存）的数值是否相等，属于数值比较；</span>    System.out.println(s1 == s2); <span class="comment">//true</span>    <span class="comment">// equals()：比较的是两个字符串的内容，属于内容比较。</span>    System.out.println(s1.equals(s2)); <span class="comment">//true</span>&#125;</code></pre><blockquote><p>字节码</p><p>从字节码指令看出：编译器做了优化，将 “a” + “b” + “c” 优化成了 “abc”</p></blockquote><pre><code class="highlight plaintext"> 0 ldc #2 &lt;abc&gt; 2 astore_1 3 ldc #2 &lt;abc&gt; 5 astore_2 6 getstatic #3 &lt;java/lang/System.out : Ljava/io/PrintStream;&gt; 9 aload_110 aload_211 if_acmpne 18 (+7)14 iconst_115 goto 19 (+4)18 iconst_019 invokevirtual #4 &lt;java/io/PrintStream.println : (Z)V&gt;22 getstatic #3 &lt;java/lang/System.out : Ljava/io/PrintStream;&gt;25 aload_126 aload_227 invokevirtual #5 &lt;java/lang/String.equals : (Ljava/lang/Object;)Z&gt;30 invokevirtual #4 &lt;java/io/PrintStream.println : (Z)V&gt;33 return</code></pre><blockquote><p>反编译代码</p><p>IDEA 反编译 class 文件后，来看这个问题</p></blockquote><pre><code class="highlight java"><span class="meta">@Test</span><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">test1</span><span class="params">()</span> &#123;    <span class="type">String</span> <span class="variable">s1</span> <span class="operator">=</span> <span class="string">&quot;abc&quot;</span>;    <span class="type">String</span> <span class="variable">s2</span> <span class="operator">=</span> <span class="string">&quot;abc&quot;</span>;    System.out.println(s1 == s2);    System.out.println(s1.equals(s2));&#125;</code></pre><p>通过反编译的代码确实可以看到IDEA将 “a” + “b” + “c” 优化成了 “abc”</p><ul><li><strong>拼接前后，只要其中有一个是变量，结果就在堆中</strong></li></ul><p><strong>调用 intern() 方法，则主动将字符串对象存入字符串常量池中，并将其地址返回</strong></p><blockquote><p>JAVA代码</p></blockquote><pre><code class="highlight java"><span class="meta">@Test</span><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">test2</span><span class="params">()</span>&#123;    <span class="type">String</span> <span class="variable">s1</span> <span class="operator">=</span> <span class="string">&quot;javaEE&quot;</span>;    <span class="type">String</span> <span class="variable">s2</span> <span class="operator">=</span> <span class="string">&quot;hadoop&quot;</span>;    <span class="type">String</span> <span class="variable">s3</span> <span class="operator">=</span> <span class="string">&quot;javaEEhadoop&quot;</span>;    <span class="type">String</span> <span class="variable">s4</span> <span class="operator">=</span> <span class="string">&quot;javaEE&quot;</span> + <span class="string">&quot;hadoop&quot;</span>;<span class="comment">// 编译期优化</span>    <span class="comment">// 如果拼接符号的前后出现了变量，则相当于在堆空间中new String()，具体的内容为拼接的结果：javaEEhadoop</span>    <span class="type">String</span> <span class="variable">s5</span> <span class="operator">=</span> s1 + <span class="string">&quot;hadoop&quot;</span>;    <span class="type">String</span> <span class="variable">s6</span> <span class="operator">=</span> <span class="string">&quot;javaEE&quot;</span> + s2;    <span class="type">String</span> <span class="variable">s7</span> <span class="operator">=</span> s1 + s2;    System.out.println(s3 == s4);<span class="comment">//true</span>    System.out.println(s3 == s5);<span class="comment">//false</span>    System.out.println(s3 == s6);<span class="comment">//false</span>    System.out.println(s3 == s7);<span class="comment">//false</span>    System.out.println(s5 == s6);<span class="comment">//false</span>    System.out.println(s5 == s7);<span class="comment">//false</span>    System.out.println(s6 == s7);<span class="comment">//false</span>    <span class="comment">// intern():判断字符串常量池中是否存在javaEEhadoop值，如果存在，则返回常量池中javaEEhadoop的地址；</span>    <span class="comment">// 如果字符串常量池中不存在javaEEhadoop，则在常量池中加载一份javaEEhadoop，并返回次对象的地址。</span>    <span class="type">String</span> <span class="variable">s8</span> <span class="operator">=</span> s6.intern();    System.out.println(s3 == s8);<span class="comment">//true</span>&#125;</code></pre><blockquote><p>字节码</p></blockquote><pre><code class="highlight plaintext">  0 ldc #6 &lt;javaEE&gt;  2 astore_1  3 ldc #7 &lt;hadoop&gt;  5 astore_2  6 ldc #8 &lt;javaEEhadoop&gt;  8 astore_3  9 ldc #8 &lt;javaEEhadoop&gt; 11 astore 4 13 new #9 &lt;java/lang/StringBuilder&gt; 16 dup 17 invokespecial #10 &lt;java/lang/StringBuilder.&lt;init&gt; : ()V&gt; 20 aload_1 21 invokevirtual #11 &lt;java/lang/StringBuilder.append : (Ljava/lang/String;)Ljava/lang/StringBuilder;&gt; 24 ldc #7 &lt;hadoop&gt; 26 invokevirtual #11 &lt;java/lang/StringBuilder.append : (Ljava/lang/String;)Ljava/lang/StringBuilder;&gt; 29 invokevirtual #12 &lt;java/lang/StringBuilder.toString : ()Ljava/lang/String;&gt; 32 astore 5 34 new #9 &lt;java/lang/StringBuilder&gt; 37 dup 38 invokespecial #10 &lt;java/lang/StringBuilder.&lt;init&gt; : ()V&gt; 41 ldc #6 &lt;javaEE&gt; 43 invokevirtual #11 &lt;java/lang/StringBuilder.append : (Ljava/lang/String;)Ljava/lang/StringBuilder;&gt; 46 aload_2 47 invokevirtual #11 &lt;java/lang/StringBuilder.append : (Ljava/lang/String;)Ljava/lang/StringBuilder;&gt; 50 invokevirtual #12 &lt;java/lang/StringBuilder.toString : ()Ljava/lang/String;&gt; 53 astore 6 55 new #9 &lt;java/lang/StringBuilder&gt; 58 dup 59 invokespecial #10 &lt;java/lang/StringBuilder.&lt;init&gt; : ()V&gt; 62 aload_1 63 invokevirtual #11 &lt;java/lang/StringBuilder.append : (Ljava/lang/String;)Ljava/lang/StringBuilder;&gt; 66 aload_2 67 invokevirtual #11 &lt;java/lang/StringBuilder.append : (Ljava/lang/String;)Ljava/lang/StringBuilder;&gt; 70 invokevirtual #12 &lt;java/lang/StringBuilder.toString : ()Ljava/lang/String;&gt; 73 astore 7 75 getstatic #3 &lt;java/lang/System.out : Ljava/io/PrintStream;&gt; 78 aload_3 79 aload 4 81 if_acmpne 88 (+7) 84 iconst_1 85 goto 89 (+4) 88 iconst_0 89 invokevirtual #4 &lt;java/io/PrintStream.println : (Z)V&gt; 92 getstatic #3 &lt;java/lang/System.out : Ljava/io/PrintStream;&gt; 95 aload_3 96 aload 5 98 if_acmpne 105 (+7)101 iconst_1102 goto 106 (+4)105 iconst_0106 invokevirtual #4 &lt;java/io/PrintStream.println : (Z)V&gt;109 getstatic #3 &lt;java/lang/System.out : Ljava/io/PrintStream;&gt;112 aload_3113 aload 6115 if_acmpne 122 (+7)118 iconst_1119 goto 123 (+4)122 iconst_0123 invokevirtual #4 &lt;java/io/PrintStream.println : (Z)V&gt;126 getstatic #3 &lt;java/lang/System.out : Ljava/io/PrintStream;&gt;129 aload_3130 aload 7132 if_acmpne 139 (+7)135 iconst_1136 goto 140 (+4)139 iconst_0140 invokevirtual #4 &lt;java/io/PrintStream.println : (Z)V&gt;143 getstatic #3 &lt;java/lang/System.out : Ljava/io/PrintStream;&gt;146 aload 5148 aload 6150 if_acmpne 157 (+7)153 iconst_1154 goto 158 (+4)157 iconst_0158 invokevirtual #4 &lt;java/io/PrintStream.println : (Z)V&gt;161 getstatic #3 &lt;java/lang/System.out : Ljava/io/PrintStream;&gt;164 aload 5166 aload 7168 if_acmpne 175 (+7)171 iconst_1172 goto 176 (+4)175 iconst_0176 invokevirtual #4 &lt;java/io/PrintStream.println : (Z)V&gt;179 getstatic #3 &lt;java/lang/System.out : Ljava/io/PrintStream;&gt;182 aload 6184 aload 7186 if_acmpne 193 (+7)189 iconst_1190 goto 194 (+4)193 iconst_0194 invokevirtual #4 &lt;java/io/PrintStream.println : (Z)V&gt;197 aload 6199 invokevirtual #13 &lt;java/lang/String.intern : ()Ljava/lang/String;&gt;202 astore 8204 getstatic #3 &lt;java/lang/System.out : Ljava/io/PrintStream;&gt;207 aload_3208 aload 8210 if_acmpne 217 (+7)213 iconst_1214 goto 218 (+4)217 iconst_0218 invokevirtual #4 &lt;java/io/PrintStream.println : (Z)V&gt;221 return</code></pre><h2 id="3-字符串拼接的底层细节"><a href="#3-字符串拼接的底层细节" class="headerlink" title="3. 字符串拼接的底层细节"></a>3. 字符串拼接的底层细节</h2><h3 id="示例1：StringBuilder"><a href="#示例1：StringBuilder" class="headerlink" title="示例1：StringBuilder"></a>示例1：StringBuilder</h3><p>字符串拼接中存在对象，则使用的是StringBuilder，拼接生成新的对象，对象存储在堆中。</p><blockquote><p>代码</p></blockquote><pre><code class="highlight java"><span class="meta">@Test</span><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">test3</span><span class="params">()</span>&#123;    <span class="type">String</span> <span class="variable">s1</span> <span class="operator">=</span> <span class="string">&quot;a&quot;</span>;    <span class="type">String</span> <span class="variable">s2</span> <span class="operator">=</span> <span class="string">&quot;b&quot;</span>;    <span class="type">String</span> <span class="variable">s3</span> <span class="operator">=</span> <span class="string">&quot;ab&quot;</span>;    <span class="comment">/*</span><span class="comment">        如下的s1 + s2 的执行细节：(变量s是我临时定义的）</span><span class="comment">        ① StringBuilder s = new StringBuilder();</span><span class="comment">        ② s.append(&quot;a&quot;)</span><span class="comment">        ③ s.append(&quot;b&quot;)</span><span class="comment">        ④ s.toString()  --&gt; 约等于 new String(&quot;ab&quot;)</span><span class="comment"></span><span class="comment">        补充：在jdk5.0之后使用的是StringBuilder,在jdk5.0之前使用的是StringBuffer</span><span class="comment">         */</span>    <span class="type">String</span> <span class="variable">s4</span> <span class="operator">=</span> s1 + s2;<span class="comment">//</span>    System.out.println(s3 == s4);<span class="comment">//false</span>&#125;</code></pre><blockquote><p>字节码</p></blockquote><pre><code class="highlight plaintext"> 0 ldc #14 &lt;a&gt; 2 astore_1 3 ldc #15 &lt;b&gt; 5 astore_2 6 ldc #16 &lt;ab&gt; 8 astore_3 9 new #9 &lt;java/lang/StringBuilder&gt;12 dup13 invokespecial #10 &lt;java/lang/StringBuilder.&lt;init&gt; : ()V&gt;16 aload_117 invokevirtual #11 &lt;java/lang/StringBuilder.append : (Ljava/lang/String;)Ljava/lang/StringBuilder;&gt;20 aload_221 invokevirtual #11 &lt;java/lang/StringBuilder.append : (Ljava/lang/String;)Ljava/lang/StringBuilder;&gt;24 invokevirtual #12 &lt;java/lang/StringBuilder.toString : ()Ljava/lang/String;&gt;27 astore 429 getstatic #3 &lt;java/lang/System.out : Ljava/io/PrintStream;&gt;32 aload_333 aload 435 if_acmpne 42 (+7)38 iconst_139 goto 43 (+4)42 iconst_043 invokevirtual #4 &lt;java/io/PrintStream.println : (Z)V&gt;46 return</code></pre><h3 id="示例2：final修饰字符串"><a href="#示例2：final修饰字符串" class="headerlink" title="示例2：final修饰字符串"></a>示例2：final修饰字符串</h3><ul><li>如果拼接符号左右两边都是字符串常量或常量引用，则仍然使用编译期优化，即非StringBuilder的方式。</li><li><strong>final修饰的字符串变量</strong>在拼接过程中依然使用的是编译器优化，拼接结果存储在常量池中。</li></ul><blockquote><p>代码</p></blockquote><pre><code class="highlight java"><span class="comment">/*</span><span class="comment">1. 字符串拼接操作不一定使用的是StringBuilder!</span><span class="comment">   如果拼接符号左右两边都是字符串常量或常量引用，则仍然使用编译期优化，即非StringBuilder的方式。</span><span class="comment">2. 针对于final修饰类、方法、基本数据类型、引用数据类型的量的结构时，能使用上final的时候建议使用上。</span><span class="comment"> */</span><span class="meta">@Test</span><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">test4</span><span class="params">()</span>&#123;    <span class="keyword">final</span> <span class="type">String</span> <span class="variable">s1</span> <span class="operator">=</span> <span class="string">&quot;a&quot;</span>;    <span class="keyword">final</span> <span class="type">String</span> <span class="variable">s2</span> <span class="operator">=</span> <span class="string">&quot;b&quot;</span>;    <span class="type">String</span> <span class="variable">s3</span> <span class="operator">=</span> <span class="string">&quot;ab&quot;</span>;    <span class="type">String</span> <span class="variable">s4</span> <span class="operator">=</span> s1 + s2;    System.out.println(s3 == s4);<span class="comment">//true</span>&#125;</code></pre><blockquote><p>字节码</p><p>从字节码角度来看：为变量 s4 赋值时，直接使用 #16 符号引用，即字符串常量 “ab”</p></blockquote><pre><code class="highlight plaintext"> 0 ldc #14 &lt;a&gt; 2 astore_1 3 ldc #15 &lt;b&gt; 5 astore_2 6 ldc #16 &lt;ab&gt; 8 astore_3 9 ldc #16 &lt;ab&gt;11 astore 413 getstatic #3 &lt;java/lang/System.out : Ljava/io/PrintStream;&gt;16 aload_317 aload 419 if_acmpne 26 (+7)22 iconst_123 goto 27 (+4)26 iconst_027 invokevirtual #4 &lt;java/io/PrintStream.println : (Z)V&gt;30 return</code></pre><h3 id="示例3：字符串拼接与append-效率对比"><a href="#示例3：字符串拼接与append-效率对比" class="headerlink" title="示例3：字符串拼接与append()效率对比"></a>示例3：字符串拼接与append()效率对比</h3><ul><li>append() 的效率要远高于字符串拼接</li></ul><blockquote><p>代码</p></blockquote><pre><code class="highlight java"><span class="comment">/*</span><span class="comment">体会执行效率：通过StringBuilder的append()的方式添加字符串的效率要远高于使用String的字符串拼接方式！</span><span class="comment">详情：① StringBuilder的append()的方式：自始至终中只创建过一个StringBuilder的对象</span><span class="comment">      使用String的字符串拼接方式：创建过多个StringBuilder和String的对象</span><span class="comment">     ② 使用String的字符串拼接方式：内存中由于创建了较多的StringBuilder和String的对象，内存占用更大；如果进行GC，需要花费额外的时间。</span><span class="comment"></span><span class="comment"> 改进的空间：在实际开发中，如果基本确定要前前后后添加的字符串长度不高于某个限定值highLevel的情况下,建议使用构造器实例化：</span><span class="comment">           StringBuilder s = new StringBuilder(highLevel);//new char[highLevel]</span><span class="comment"> */</span><span class="meta">@Test</span><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">test6</span><span class="params">()</span>&#123;    <span class="type">long</span> <span class="variable">start</span> <span class="operator">=</span> System.currentTimeMillis();<span class="comment">//        method1(100000);//4014</span>    method2(<span class="number">100000</span>);<span class="comment">//7</span>    <span class="type">long</span> <span class="variable">end</span> <span class="operator">=</span> System.currentTimeMillis();    System.out.println(<span class="string">&quot;花费的时间为：&quot;</span> + (end - start));&#125;<span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">method1</span><span class="params">(<span class="type">int</span> highLevel)</span>&#123;    <span class="type">String</span> <span class="variable">src</span> <span class="operator">=</span> <span class="string">&quot;&quot;</span>;    <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>;i &lt; highLevel;i++)&#123;        src = src + <span class="string">&quot;a&quot;</span>;<span class="comment">//每次循环都会创建一个StringBuilder、String</span>    &#125;<span class="comment">//        System.out.println(src);</span>&#125;<span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">method2</span><span class="params">(<span class="type">int</span> highLevel)</span>&#123;    <span class="comment">//只需要创建一个StringBuilder</span>    <span class="type">StringBuilder</span> <span class="variable">src</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">StringBuilder</span>();    <span class="comment">// 优化，通过构造器指定长度</span><span class="comment">//        StringBuilder src = new StringBuilder(100000);</span>    <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; highLevel; i++) &#123;        src.append(<span class="string">&quot;a&quot;</span>);    &#125;<span class="comment">//        System.out.println(src);</span>&#125;</code></pre><ul><li>体会执行效率：通过StringBuilder的append()的方式添加字符串的效率要远高于使用String的字符串拼接方式！</li><li>原因：<ul><li>StringBuilder的append()的方式：自始至终中只创建过一个StringBuilder的对象</li><li>使用String的字符串拼接方式：<ul><li>创建过多个StringBuilder和String（调的toString方法）的对象，内存占用更大；</li><li>如果进行GC，需要花费额外的时间（在拼接的过程中产生的一些中间字符串可能永远也用不到，会产生大量垃圾字符串）。</li></ul></li></ul></li><li>改进的空间：<ul><li>在实际开发中，如果基本确定要前前后后添加的字符串长度不高于某个限定值highLevel的情况下，建议使用构造器实例化：<ul><li>StringBuilder s &#x3D; new StringBuilder(highLevel); &#x2F;&#x2F;new char[highLevel] , 这样可以避免频繁扩容</li></ul></li></ul></li></ul><h1 id="六、intern-的使用"><a href="#六、intern-的使用" class="headerlink" title="六、intern() 的使用"></a>六、intern() 的使用</h1><h2 id="1-intern-方法的说明"><a href="#1-intern-方法的说明" class="headerlink" title="1. intern() 方法的说明"></a>1. intern() 方法的说明</h2><pre><code class="highlight java"><span class="keyword">public</span> <span class="keyword">native</span> String <span class="title function_">intern</span><span class="params">()</span>;</code></pre><ul><li><p>intern是一个native方法，调用的是底层C的方法</p></li><li><p>字符串常量池池最初是空的，由String类私有地维护。在调用intern方法时，如果池中已经包含了由equals(object)方法确定的与该字符串内容相等的字符串，则返回池中的字符串地址。否则，该字符串对象将被添加到池中，并返回对该字符串对象的地址。（这是源码里的大概翻译）</p></li><li><p>如果不是用双引号声明的String对象，可以使用String提供的intern方法：intern方法会从字符串常量池中查询当前字符串是否存在，若不存在就会将当前字符串放入常量池中。比如：</p><pre><code class="highlight java"><span class="type">String</span> <span class="variable">myInfo</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">string</span>(<span class="string">&quot;china&quot;</span>).intern();</code></pre></li><li><p>也就是说，如果在任意字符串上调用String.intern方法，那么其返回结果所指向的那个类实例，必须和直接以常量形式出现的字符串实例完全相同。因此，下列表达式的值必定是true</p><pre><code class="highlight java">(<span class="string">&quot;a&quot;</span>+<span class="string">&quot;b&quot;</span>+<span class="string">&quot;c&quot;</span>).intern()==<span class="string">&quot;abc&quot;</span></code></pre></li><li><p>通俗点讲，Interned String 就是确保字符串在内存里只有一份拷贝，这样可以节约内存空间，加快字符串操作任务的执行速度。注意，这个值会被存放在字符串内部池（String Intern Pool）</p></li></ul><h2 id="2-new-String-的说明"><a href="#2-new-String-的说明" class="headerlink" title="2. new String() 的说明"></a>2. new String() 的说明</h2><h3 id="2-1-问题1：new-String-“ab”-会创建几个对象？"><a href="#2-1-问题1：new-String-“ab”-会创建几个对象？" class="headerlink" title="2.1 问题1：new String(“ab”)会创建几个对象？"></a>2.1 问题1：new String(“ab”)会创建几个对象？</h3><pre><code class="highlight java"><span class="type">String</span> <span class="variable">str</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">String</span>(<span class="string">&quot;ab&quot;</span>);</code></pre><blockquote><p>字节码</p></blockquote><pre><code class="highlight plaintext">0 new #2 &lt;java/lang/String&gt;3 dup4 ldc #3 &lt;ab&gt;6 invokespecial #4 &lt;java/lang/String.&lt;init&gt;&gt;9 astore_110 return</code></pre><ul><li><code>0 new #2 &lt;java/lang/String&gt;</code>：在堆中创建了一个 String 对象</li><li><code>4 ldc #3 &lt;ab&gt;</code> ：在字符串常量池中放入 “ab”（如果之前字符串常量池中没有 “ab” 的话）</li></ul><p><strong>注意：</strong></p><p>这里并不表示 str 直接指向常量池中的 ab , 仅仅是str的引用地址指向堆中的一个String对象， 而这个String对象的内容又指向了另一个字符串常量池地址 ab</p><p><img src="https://raw.githubusercontent.com/GeorgeChan95/blogimg/master/img/2023/12/29/20231229-112453.png" alt="image-20231229112448923"></p><h3 id="2-2-问题2：new-String-“a”-new-String-“b”-会创建几个对象？"><a href="#2-2-问题2：new-String-“a”-new-String-“b”-会创建几个对象？" class="headerlink" title="2.2 问题2：new String(“a”) + new String(“b”) 会创建几个对象？"></a>2.2 问题2：new String(“a”) + new String(“b”) 会创建几个对象？</h3><pre><code class="highlight java"><span class="type">String</span> <span class="variable">str3</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">String</span>(<span class="string">&quot;a&quot;</span>) + <span class="keyword">new</span> <span class="title class_">String</span>(<span class="string">&quot;b&quot;</span>);</code></pre><blockquote><p>字节码</p></blockquote><pre><code class="highlight plaintext">0 new #2 &lt;java/lang/StringBuilder&gt;3 dup4 invokespecial #3 &lt;java/lang/StringBuilder.&lt;init&gt;&gt;7 new #4 &lt;java/lang/String&gt;10 dup11 ldc #5 &lt;a&gt;13 invokespecial #6 &lt;java/lang/String.&lt;init&gt;&gt;16 invokevirtual #7 &lt;java/lang/StringBuilder.append&gt;19 new #4 &lt;java/lang/String&gt;22 dup23 ldc #8 &lt;b&gt;25 invokespecial #6 &lt;java/lang/String.&lt;init&gt;&gt;28 invokevirtual #7 &lt;java/lang/StringBuilder.append&gt;31 invokevirtual #9 &lt;java/lang/StringBuilder.toString&gt;34 astore_135 return</code></pre><p><strong>答案是4个或5个或6个</strong></p><p>字节码指令分析：</p><ul><li><code>0 new #2 &lt;java/lang/StringBuilder&gt;</code> ：拼接字符串会创建一个 StringBuilder 对象</li><li><code>7 new #4 &lt;java/lang/String&gt;</code> ：创建 String 对象，对应于 new String(“a”)</li><li><code>11 ldc #5 &lt;a&gt;</code> ：在字符串常量池中放入 “a”（如果之前字符串常量池中没有 “a” 的话）</li><li><code>19 new #4 &lt;java/lang/String&gt;</code> ：创建 String 对象，对应于 new String(“b”)</li><li><code>23 ldc #8 &lt;b&gt;</code> ：在字符串常量池中放入 “b”（如果之前字符串常量池中没有 “b” 的话）</li><li><code>31 invokevirtual #9 &lt;java/lang/StringBuilder.toString&gt;</code> ：调用 StringBuilder 的 toString() 方法，会生成一个 String 对象</li></ul><p><strong>强调一下，toString()的调用，在字符串常量池中，没有生成”ab”</strong></p><h2 id="3-面试题"><a href="#3-面试题" class="headerlink" title="3. 面试题"></a>3. 面试题</h2><pre><code class="highlight plaintext">/** * 如何保证变量s指向的是字符串常量池中的数据呢？ * 有两种方式： * 方式一： String s = &quot;shkstart&quot;;//字面量定义的方式 * 方式二： 调用intern() *         String s = new String(&quot;shkstart&quot;).intern(); *         String s = new StringBuilder(&quot;shkstart&quot;).toString().intern(); */public class StringIntern &#123;    public static void main(String[] args) &#123;        String s = new String(&quot;1&quot;);        s.intern();//调用此方法之前，字符串常量池中已经存在了&quot;1&quot;        String s2 = &quot;1&quot;;        System.out.println(s == s2);//jdk6：false   jdk7/8：false        String s3 = new String(&quot;1&quot;) + new String(&quot;1&quot;);//s3变量记录的地址为：new String(&quot;11&quot;)        //执行完上一行代码以后，字符串常量池中，是否存在&quot;11&quot;呢？答案：不存在！！        s3.intern();//在字符串常量池中生成&quot;11&quot;。如何理解：jdk6:创建了一个新的对象&quot;11&quot;,也就有新的地址。                                            //         jdk7:此时常量中并没有创建&quot;11&quot;,而是创建一个指向堆空间中new String(&quot;11&quot;)的地址        String s4 = &quot;11&quot;;//s4变量记录的地址：使用的是上一行代码代码执行时，在常量池中生成的&quot;11&quot;的地址        /**         * 先执行         *      s3.intern();         * 再执行         *      String s4 = &quot;11&quot;;         * 则   s3 == s4 为：true         * 如果执行顺序相反，则结果为false。         * 原因：先执行 s3.intern(); 则将s3的指向的对象[11]放入到了字符串常量池，常量地址值就是s3的内存地址值。         *      此时再执行 String s4 = &quot;11&quot;; 会优先从常量池查找是否有字符串为 11 的常量，有则返回常量的地址，         *      所以此时 s3 == s4 为：true         */        System.out.println(s3 == s4);//jdk6：false  jdk7/8：true    &#125;&#125;</code></pre><h3 id="打印结果"><a href="#打印结果" class="headerlink" title="打印结果"></a>打印结果</h3><ul><li>jdk6 下<code>false false</code></li><li>jdk7 下<code>false true</code></li></ul><h3 id="JDK6的解释"><a href="#JDK6的解释" class="headerlink" title="JDK6的解释"></a>JDK6的解释</h3><p><img src="https://raw.githubusercontent.com/GeorgeChan95/blogimg/master/img/2023/12/29/20231229-120054.png" alt="jdk6图"></p><p>注：图中绿色线条代表 string 对象的内容指向。 黑色线条代表地址指向。</p><p>如上图所示。首先说一下 jdk6中的情况，在 jdk6中上述的所有打印都是 false 的，因为 jdk6中的常量池是放在 Perm 区中的，Perm 区和正常的 JAVA Heap 区域是完全分开的。上面说过如果是使用引号声明的字符串都是会直接在字符串常量池中生成，而 new 出来的 String 对象是放在 JAVA Heap 区域。所以拿一个 JAVA Heap 区域的对象地址和字符串常量池的对象地址进行比较肯定是不相同的，即使调用<code>String.intern</code>方法也是没有任何关系的。</p><h3 id="jdk7中的解释"><a href="#jdk7中的解释" class="headerlink" title="jdk7中的解释"></a>jdk7中的解释</h3><p>再说说 jdk7 中的情况。这里要明确一点的是，在 Jdk6 以及以前的版本中，字符串的常量池是放在堆的 Perm 区的，Perm 区是一个类静态的区域，主要存储一些加载类的信息，常量池，方法片段等内容，默认大小只有4m，一旦常量池中大量使用 intern 是会直接产生<code>java.lang.OutOfMemoryError: PermGen space</code>错误的。 所以在 jdk7 的版本中，字符串常量池已经从 Perm 区移到正常的 Java Heap 区域了。为什么要移动，Perm 区域太小是一个主要原因，当然据消息称 jdk8 已经直接取消了 Perm 区域，而新建立了一个元区域。应该是 jdk 开发者认为 Perm 区域已经不适合现在 JAVA 的发展了。</p><p>正式因为字符串常量池移动到 JAVA Heap 区域后，再来解释为什么会有上述的打印结果。</p><p><img src="https://raw.githubusercontent.com/GeorgeChan95/blogimg/master/img/2023/12/29/20231229-120212.png" alt="jdk7图1"></p><ul><li>在第一段代码中，先看 s3和s4字符串。<code>String s3 = new String(&quot;1&quot;) + new String(&quot;1&quot;);</code>，这句代码中现在生成了2最终个对象，是字符串常量池中的“1” 和 JAVA Heap 中的 s3引用指向的对象。中间还有2个匿名的<code>new String(&quot;1&quot;)</code>我们不去讨论它们。此时s3引用对象内容是”11”，但此时常量池中是没有 “11”对象的。</li><li>接下来<code>s3.intern();</code>这一句代码，是将 s3中的“11”字符串放入 String 常量池中，因为此时常量池中不存在“11”字符串，因此常规做法是跟 jdk6 图中表示的那样，在常量池中生成一个 “11” 的对象，关键点是 jdk7 中常量池不在 Perm 区域了，这块做了调整。常量池中不需要再存储一份对象了，可以直接存储堆中的引用。这份引用指向 s3 引用的对象。 也就是说引用地址是相同的。</li><li>最后<code>String s4 = &quot;11&quot;;</code> 这句代码中”11”是显示声明的，因此会直接去常量池中创建，创建的时候发现已经有这个对象了，此时也就是指向 s3 引用对象的一个引用。所以 s4 引用就指向和 s3 一样了。因此最后的比较 <code>s3 == s4</code> 是 true。</li></ul><p><strong>完整的解析见：参考链接</strong></p><h2 id="4-intern-方法的练习"><a href="#4-intern-方法的练习" class="headerlink" title="4. intern() 方法的练习"></a>4. intern() 方法的练习</h2><h3 id="4-1-练习-1"><a href="#4-1-练习-1" class="headerlink" title="4.1 练习 1"></a>4.1 练习 1</h3><pre><code class="highlight java"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">StringExer1</span> &#123;    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;        <span class="type">String</span> <span class="variable">s</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">String</span>(<span class="string">&quot;a&quot;</span>) + <span class="keyword">new</span> <span class="title class_">String</span>(<span class="string">&quot;b&quot;</span>);<span class="comment">//new String(&quot;ab&quot;)</span>        <span class="comment">//在上一行代码执行完以后，字符串常量池中并没有&quot;ab&quot;</span>        <span class="type">String</span> <span class="variable">s2</span> <span class="operator">=</span> s.intern();<span class="comment">//jdk6中：在串池中创建一个字符串&quot;ab&quot;</span>                               <span class="comment">//jdk8中：串池中没有创建字符串&quot;ab&quot;,而是创建一个引用，指向new String(&quot;ab&quot;)，将此引用返回</span>        System.out.println(s2 == <span class="string">&quot;ab&quot;</span>);<span class="comment">//jdk6:true  jdk8:true</span>        System.out.println(s == <span class="string">&quot;ab&quot;</span>);<span class="comment">//jdk6:false  jdk8:true</span>    &#125;&#125;</code></pre><h4 id="JDK6"><a href="#JDK6" class="headerlink" title="JDK6"></a>JDK6</h4><img src="https://raw.githubusercontent.com/GeorgeChan95/blogimg/master/img/2023/12/29/20231229-125241.png" alt="image-20231229125239603" style="zoom:67%;" /><h4 id="JDK7-8"><a href="#JDK7-8" class="headerlink" title="JDK7&#x2F;8"></a>JDK7&#x2F;8</h4><img src="https://raw.githubusercontent.com/GeorgeChan95/blogimg/master/img/2023/12/29/20231229-125345.png" alt="image-20231229125322439" style="zoom:67%;" /><h3 id="4-2-练习2"><a href="#4-2-练习2" class="headerlink" title="4.2 练习2"></a>4.2 练习2</h3><pre><code class="highlight java"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">StringExer1</span> &#123;    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;        <span class="type">String</span> <span class="variable">x</span> <span class="operator">=</span> <span class="string">&quot;ab&quot;</span>;        <span class="type">String</span> <span class="variable">s</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">String</span>(<span class="string">&quot;a&quot;</span>) + <span class="keyword">new</span> <span class="title class_">String</span>(<span class="string">&quot;b&quot;</span>);<span class="comment">//new String(&quot;ab&quot;)</span>        <span class="comment">//在上一行代码执行完以后，字符串常量池中并没有&quot;ab&quot;</span>        <span class="type">String</span> <span class="variable">s2</span> <span class="operator">=</span> s.intern();<span class="comment">//jdk6中：在串池中创建一个字符串&quot;ab&quot;</span>                               <span class="comment">//jdk8中：串池中没有创建字符串&quot;ab&quot;,而是创建一个引用，指向new String(&quot;ab&quot;)，将此引用返回</span>        System.out.println(s2 == x);<span class="comment">//jdk6:true  jdk8:true</span>        System.out.println(s == x);<span class="comment">//jdk6:false  jdk8:false</span>    &#125;&#125;</code></pre><img src="https://raw.githubusercontent.com/GeorgeChan95/blogimg/master/img/2023/12/29/20231229-131153.png" alt="image-20231229131124299" style="zoom:67%;" /><h3 id="4-3-练习3"><a href="#4-3-练习3" class="headerlink" title="4.3 练习3"></a>4.3 练习3</h3><blockquote><p>代码</p></blockquote><pre><code class="highlight java"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">StringExer2</span> &#123;    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;        <span class="type">String</span> <span class="variable">s1</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">String</span>(<span class="string">&quot;ab&quot;</span>);<span class="comment">//执行完以后，会在字符串常量池中会生成&quot;ab&quot;</span>        s1.intern();        <span class="type">String</span> <span class="variable">s2</span> <span class="operator">=</span> <span class="string">&quot;ab&quot;</span>;        System.out.println(s1 == s2); <span class="comment">// false</span>        System.out.println(<span class="string">&quot;======================================================&quot;</span>);        <span class="type">String</span> <span class="variable">s3</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">String</span>(<span class="string">&quot;x&quot;</span>) + <span class="keyword">new</span> <span class="title class_">String</span>(<span class="string">&quot;y&quot;</span>);<span class="comment">// 执行完以后，不会在字符串常量池中会生成&quot;xy&quot;</span>        s3.intern();        <span class="type">String</span> <span class="variable">s4</span> <span class="operator">=</span> <span class="string">&quot;xy&quot;</span>;        System.out.println(s3 == s4); <span class="comment">// true</span>    &#125;&#125;</code></pre><blockquote><p>验证</p></blockquote><pre><code class="highlight java"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">StringExer2</span> &#123;    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;        <span class="type">String</span> <span class="variable">s1</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">String</span>(<span class="string">&quot;ab&quot;</span>);<span class="comment">//执行完以后，会在字符串常量池中会生成&quot;ab&quot;</span><span class="comment">//        String s1 = new String(&quot;a&quot;) + new String(&quot;b&quot;);</span>        System.out.println(System.identityHashCode(s1));        s1.intern();        System.out.println(System.identityHashCode(s1));        <span class="type">String</span> <span class="variable">s2</span> <span class="operator">=</span> <span class="string">&quot;ab&quot;</span>;        System.out.println(System.identityHashCode(s2));        System.out.println(s1 == s2); <span class="comment">// false</span>        System.out.println(<span class="string">&quot;======================================================&quot;</span>);        <span class="type">String</span> <span class="variable">s3</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">String</span>(<span class="string">&quot;x&quot;</span>) + <span class="keyword">new</span> <span class="title class_">String</span>(<span class="string">&quot;y&quot;</span>); <span class="comment">//执行完以后，不会在字符串常量池中会生成&quot;xy&quot;</span>        System.out.println(System.identityHashCode(s3));        s3.intern();        System.out.println(System.identityHashCode(s3));        <span class="type">String</span> <span class="variable">s4</span> <span class="operator">=</span> <span class="string">&quot;xy&quot;</span>;        System.out.println(System.identityHashCode(s4));        System.out.println(s3 == s4);    &#125;&#125;</code></pre><blockquote><p>打印结果</p></blockquote><pre><code class="highlight plaintext">1735600054173560005421685669false======================================================213392700221339270022133927002true</code></pre><h2 id="5-intern-的效率测试（空间角度）"><a href="#5-intern-的效率测试（空间角度）" class="headerlink" title="5. intern() 的效率测试（空间角度）"></a>5. intern() 的效率测试（空间角度）</h2><pre><code class="highlight java"><span class="comment">/**</span><span class="comment"> * 使用intern()测试执行效率：空间使用上</span><span class="comment"> * 结论：对于程序中大量存在存在的字符串，尤其其中存在很多重复字符串时，使用intern()可以节省内存空间。</span><span class="comment"> */</span><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">StringIntern2</span> &#123;    <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">int</span> <span class="variable">MAX_COUNT</span> <span class="operator">=</span> <span class="number">1000</span> * <span class="number">10000</span>;    <span class="keyword">static</span> <span class="keyword">final</span> String[] arr = <span class="keyword">new</span> <span class="title class_">String</span>[MAX_COUNT];    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;        Integer[] data = <span class="keyword">new</span> <span class="title class_">Integer</span>[]&#123;<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>,<span class="number">6</span>,<span class="number">7</span>,<span class="number">8</span>,<span class="number">9</span>,<span class="number">10</span>&#125;;        <span class="type">long</span> <span class="variable">start</span> <span class="operator">=</span> System.currentTimeMillis();        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; MAX_COUNT; i++) &#123;            arr[i] = <span class="keyword">new</span> <span class="title class_">String</span>(String.valueOf(data[i % data.length])); <span class="comment">// 花费的时间为：4568</span>            arr[i] = <span class="keyword">new</span> <span class="title class_">String</span>(String.valueOf(data[i % data.length])).intern(); <span class="comment">// 花费的时间为：1050</span>        &#125;        <span class="type">long</span> <span class="variable">end</span> <span class="operator">=</span> System.currentTimeMillis();        System.out.println(<span class="string">&quot;花费的时间为：&quot;</span> + (end - start));        <span class="keyword">try</span> &#123;            Thread.sleep(<span class="number">1000000</span>);        &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;            e.printStackTrace();        &#125;        System.gc();    &#125;&#125;</code></pre><ul><li><p>直接 new String ：由于每个 String 对象都是 new 出来的，所以程序需要维护大量存放在堆空间中的 String 实例，程序内存占用也会变高</p><pre><code class="highlight java">arr[i] = <span class="keyword">new</span> <span class="title class_">String</span>(String.valueOf(data[i % data.length])); <span class="comment">// 花费的时间为：4568</span></code></pre></li></ul><img src="https://raw.githubusercontent.com/GeorgeChan95/blogimg/master/img/2023/12/29/20231229-143312.png" alt="image-20231229143310962" style="zoom:50%;" /><ul><li><p>使用 intern() 方法：由于数组中字符串的引用都指向字符串常量池中的字符串，所以程序需要维护的 String 对象更少，内存占用也更低。</p><pre><code class="highlight java"><span class="comment">// 调用了intern()方法使用了字符串常量池里的字符串，那么前面堆里的字符串便会被GC掉，这也是intern省内存的关键原因</span>arr[i] = <span class="keyword">new</span> <span class="title class_">String</span>(String.valueOf(data[i % data.length])).intern(); <span class="comment">// 花费的时间为：1050</span></code></pre></li></ul><img src="https://raw.githubusercontent.com/GeorgeChan95/blogimg/master/img/2023/12/29/20231229-143837.png" alt="image-20231229143836136" style="zoom:50%;" /><p><strong>结论</strong>：</p><ul><li>对于程序中大量使用存在的字符串时，尤其存在很多已经重复的字符串时，使用intern()方法能够节省很大的内存空间。</li><li>大的网站平台，需要内存中存储大量的字符串。比如社交网站，很多人都存储：北京市、海淀区等信息。这时候如果字符串都调用intern() 方法，就会很明显降低内存的大小。</li></ul><h1 id="七、StringTable-的垃圾回收"><a href="#七、StringTable-的垃圾回收" class="headerlink" title="七、StringTable 的垃圾回收"></a>七、StringTable 的垃圾回收</h1><blockquote><p>示例代码</p></blockquote><pre><code class="highlight java"><span class="comment">/**</span><span class="comment"> * String的垃圾回收:</span><span class="comment"> * -Xms15m -Xmx15m -XX:+PrintStringTableStatistics -XX:+PrintGCDetails</span><span class="comment"> */</span><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">StringGCTest</span> &#123;    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> <span class="number">0</span>; j &lt; <span class="number">100000</span>; j++) &#123;            String.valueOf(j).intern();        &#125;    &#125;&#125;</code></pre><blockquote><p>输出结果：</p></blockquote><ul><li>在 PSYoungGen 区发生了垃圾回收</li><li>Number of entries 和 Number of literals 明显没有 100000</li><li>以上两点均说明 StringTable 区发生了垃圾回收</li></ul><p><img src="https://raw.githubusercontent.com/GeorgeChan95/blogimg/master/img/2023/12/29/20231229-145743.png" alt="image-20231229145741545"></p><h1 id="八、G1-中的-String-去重操作"><a href="#八、G1-中的-String-去重操作" class="headerlink" title="八、G1 中的 String 去重操作"></a>八、G1 中的 String 去重操作</h1><blockquote><p>官方文档：<a href="https://openjdk.org/jeps/192">https://openjdk.org/jeps/192</a></p></blockquote><h2 id="1-String去重操作的背景"><a href="#1-String去重操作的背景" class="headerlink" title="1. String去重操作的背景"></a>1. String去重操作的背景</h2><blockquote><p>注意不是字符串常量池的去重操作，字符串常量池本身就没有重复的</p></blockquote><ul><li>背景：对许多Java应用（有大的也有小的）做的测试得出以下结果：<ul><li>堆存活数据集合里面String对象占了25%</li><li>堆存活数据集合里面重复的String对象有13.5%</li><li>String对象的平均长度是45</li></ul></li><li>许多大规模的Java应用的瓶颈在于内存，测试表明，在这些类型的应用里面，Java堆中存活的数据集合差不多25%是String对象。更进一步，这里面差不多一半String对象是重复的，重复的意思是说：<code>str1.equals(str2)= true</code>。堆上存在重复的String对象必然是一种内存的浪费。这个项目将在G1垃圾收集器中实现自动持续对重复的String对象进行去重，这样就能避免浪费内存。</li></ul><h2 id="2-String-去重的的实现"><a href="#2-String-去重的的实现" class="headerlink" title="2. String 去重的的实现"></a>2. String 去重的的实现</h2><ul><li>当垃圾收集器工作的时候，会访问堆上存活的对象。对每一个访问的对象都会检查是否是候选的要去重的String对象。</li><li>如果是，把这个对象的一个引用插入到队列中等待后续的处理。一个去重的线程在后台运行，处理这个队列。处理队列的一个元素意味着从队列删除这个元素，然后尝试去重它引用的String对象。</li><li>使用一个Hashtable来记录所有的被String对象使用的不重复的char数组。当去重的时候，会查这个Hashtable，来看堆上是否已经存在一个一模一样的char数组。</li><li>如果存在，String对象会被调整引用那个数组，释放对原来的数组的引用，最终会被垃圾收集器回收掉。</li><li>如果查找失败，char数组会被插入到Hashtable，这样以后的时候就可以共享这个数组了。</li></ul><h2 id="3-命令行选项"><a href="#3-命令行选项" class="headerlink" title="3. 命令行选项"></a>3. 命令行选项</h2><ul><li>UseStringDeduplication(bool) ：开启String去重，默认是不开启的，需要手动开启。</li><li>PrintStringDeduplicationStatistics(bool) ：打印详细的去重统计信息</li><li>stringDeduplicationAgeThreshold(uintx) ：达到这个年龄的String对象被认为是去重的候选对象</li></ul><h1 id="参考链接"><a href="#参考链接" class="headerlink" title="参考链接"></a>参考链接</h1><blockquote><p>深入解析String#intern：<a href="https://tech.meituan.com/2014/03/06/in-depth-understanding-string-intern.html">https://tech.meituan.com/2014/03/06/in-depth-understanding-string-intern.html</a></p></blockquote>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;环境&quot;&gt;&lt;a href=&quot;#环境&quot; class=&quot;headerlink&quot; title=&quot;环境&quot;&gt;&lt;/a&gt;环境&lt;/h1&gt;&lt;blockquote&gt;
&lt;p&gt;系统 : Windows 10&lt;br&gt;JDK : 1.8&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h1 id=&quot;一、</summary>
      
    
    
    
    <category term="JVM" scheme="https://georgechan95.github.io/categories/JVM/"/>
    
    
    <category term="jvm" scheme="https://georgechan95.github.io/tags/jvm/"/>
    
    <category term="java" scheme="https://georgechan95.github.io/tags/java/"/>
    
  </entry>
  
  <entry>
    <title>第十章-执行引擎</title>
    <link href="https://georgechan95.github.io/2023/12/23/jvm/%E7%AC%AC%E5%8D%81%E7%AB%A0-%E6%89%A7%E8%A1%8C%E5%BC%95%E6%93%8E/"/>
    <id>https://georgechan95.github.io/2023/12/23/jvm/%E7%AC%AC%E5%8D%81%E7%AB%A0-%E6%89%A7%E8%A1%8C%E5%BC%95%E6%93%8E/</id>
    <published>2023-12-23T12:03:00.000Z</published>
    <updated>2024-06-22T10:36:12.823Z</updated>
    
    <content type="html"><![CDATA[<h1 id="环境"><a href="#环境" class="headerlink" title="环境"></a>环境</h1><blockquote><p>系统 : Windows 10<br>JDK : 1.8</p></blockquote><h1 id="一、执行引擎"><a href="#一、执行引擎" class="headerlink" title="一、执行引擎"></a>一、执行引擎</h1><p><img src="https://raw.githubusercontent.com/GeorgeChan95/blogimg/master/img/2023/12/21/20231221-194101.png" alt="image-20231221194038014"></p><h2 id="1-执行引擎概述"><a href="#1-执行引擎概述" class="headerlink" title="1. 执行引擎概述"></a>1. 执行引擎概述</h2><ul><li>执行引擎是Java虚拟机核心的组成部分之一。</li><li>“虚拟机”是一个相对于“物理机”的概念，这两种机器都有代码执行能力，其区别是物理机的执行引擎是直接建立在处理器、缓存、指令集和操作系统层面上的，而<strong>虚拟机的执行引擎则是由软件自行实现的</strong>，因此可以不受物理条件制约地定制指令集与执行引擎的结构体系，<strong>能够执行那些不被硬件直接支持的指令集格式</strong>。</li><li>JVM的主要任务是负责<strong>装载字节码到其内部</strong>，但字节码并不能够直接运行在操作系统之上，因为字节码指令并非等价于本地机器指令，它内部包含的仅仅只是一些能够被JVM所识别的字节码指令、符号表，以及其他辅助信息。</li><li>那么，如果想要让一个Java程序运行起来，执行引擎（Execution Engine）的任务就是<strong>将字节码指令解释&#x2F;编译为对应平台上的本地机器指令才可以</strong>。简单来说，JVM中的执行引擎充当了将高级语言翻译为机器语言的译者。</li></ul><p><img src="https://raw.githubusercontent.com/GeorgeChan95/blogimg/master/img/2023/12/23/20231223-201545.jpg" alt="Java语言的跨平台性"></p><ul><li>前端编译：从Java程序员-字节码文件的这个过程叫前端编译</li><li>执行引擎这里有两种行为：一种是解释执行，一种是编译执行（这里的是后端编译）。</li></ul><h2 id="2-执行引擎工作过程"><a href="#2-执行引擎工作过程" class="headerlink" title="2. 执行引擎工作过程"></a>2. 执行引擎工作过程</h2><ul><li>执行引擎在执行的过程中究竟需要执行什么样的字节码指令完全依赖于PC寄存器。</li><li>每当执行完一项指令操作后，PC寄存器就会更新下一条需要被执行的指令地址。</li><li>当然方法在执行的过程中，执行引擎有可能会通过存储在局部变量表中的对象引用准确定位到存储在Java堆区中的对象实例信息，以及通过对象头中的元数据指针定位到目标对象的类型信息。</li><li>从外观上来看，所有的Java虚拟机的执行引擎输入、处理、输出都是一致的：输入的是字节码二进制流，处理过程是字节码解析执行、即时编译的等效过程，输出的是执行过程。</li></ul><img src="https://raw.githubusercontent.com/GeorgeChan95/blogimg/master/img/2023/12/24/20231224-124745.jpg" alt="执行引擎的工作过程" style="zoom:67%;" /><h1 id="二、Java代码编译和执行过程"><a href="#二、Java代码编译和执行过程" class="headerlink" title="二、Java代码编译和执行过程"></a>二、Java代码编译和执行过程</h1><h2 id="1-解释执行和即时编译"><a href="#1-解释执行和即时编译" class="headerlink" title="1. 解释执行和即时编译"></a>1. 解释执行和即时编译</h2><p>大部分的程序代码转换成物理机的目标代码或虚拟机能执行的指令集之前，都需要经过下图中的各个步骤：</p><ul><li>前面橙色部分是编译生成生成字节码文件的过程（javac编译器来完成，也就是前端编译器），和JVM没有关系。</li><li>后面绿色（解释执行）和蓝色（即时编译）才是JVM需要考虑的过程</li></ul><p><img src="https://raw.githubusercontent.com/GeorgeChan95/blogimg/master/img/2023/12/24/20231224-130031.jpg" alt="程序执行过程"></p><ul><li><p>javac编译器（前端编译器）流程图如下所示：</p><p><img src="https://raw.githubusercontent.com/GeorgeChan95/blogimg/master/img/2023/12/24/20231224-130716.png" alt="image-20231224130715139"></p></li><li><p>Java字节码的执行是由JVM执行引擎来完成，流程图如下所示</p></li></ul><p><img src="https://raw.githubusercontent.com/GeorgeChan95/blogimg/master/img/2023/12/24/20231224-131223.png" alt="image-20231224131221760"></p><h2 id="2-什么是解释器？什么是JIT编译器？"><a href="#2-什么是解释器？什么是JIT编译器？" class="headerlink" title="2. 什么是解释器？什么是JIT编译器？"></a>2. 什么是解释器？什么是JIT编译器？</h2><ul><li>解释器：当Java虚拟机启动时会根据预定义的规范对字节码采用<strong>逐行</strong>解释的方式<strong>执行</strong>，将每条字节码文件中的内容“翻译”为对应平台的本地机器指令执行。</li><li>JIT（Just In Time Compiler）编译器：就是虚拟机将源代码<strong>一次性直接</strong>编译成和本地机器平台相关的机器语言，<strong>但并不是马上执行</strong>。</li></ul><h3 id="2-1-为什么Java是半编译半解释型语言？"><a href="#2-1-为什么Java是半编译半解释型语言？" class="headerlink" title="2.1 为什么Java是半编译半解释型语言？"></a>2.1 为什么Java是半编译半解释型语言？</h3><ul><li>JDK1.0时代，将Java语言定位为“解释执行”还是比较准确的。再后来，Java也发展出可以直接生成本地代码的编译器。</li><li>现在JVM在执行Java代码的时候，通常都会将解释执行与编译执行二者结合起来进行。</li><li>JIT编译器将字节码翻译成本地代码后，就可以做一个缓存操作，存储在方法区的<strong>JIT 代码缓存</strong>中（执行效率更高了），并且在翻译成本地代码的过程中可以做优化。</li></ul><p><img src="https://raw.githubusercontent.com/GeorgeChan95/blogimg/master/img/2023/12/24/20231224-132552.jpg" alt="理解执行引擎"></p><h1 id="三、机器码、指令、汇编语言"><a href="#三、机器码、指令、汇编语言" class="headerlink" title="三、机器码、指令、汇编语言"></a>三、机器码、指令、汇编语言</h1><h2 id="1-机器码"><a href="#1-机器码" class="headerlink" title="1. 机器码"></a>1. 机器码</h2><ul><li>各种用二进制编码方式表示的指令，叫做机器指令码。开始，人们就用它采编写程序，这就是机器语言。</li><li>机器语言虽然能够被计算机理解和接受，但和人们的语言差别太大，不易被人们理解和记忆，并且用它编程容易出差错。</li><li>用它编写的程序一经输入计算机，CPU直接读取运行，因此和其他语言编的程序相比，执行速度最快。</li><li>机器指令与CPU紧密相关，所以不同种类的CPU所对应的机器指令也就不同。</li></ul><h2 id="2-指令和指令集"><a href="#2-指令和指令集" class="headerlink" title="2. 指令和指令集"></a>2. 指令和指令集</h2><h3 id="2-1-指令"><a href="#2-1-指令" class="headerlink" title="2.1 指令"></a>2.1 指令</h3><ul><li>由于机器码是由0和1组成的二进制序列，可读性实在太差，于是人们发明了指令。</li><li>指令就是把机器码中特定的0和1序列，简化成对应的指令（一般为英文简写，如mov，inc等），可读性稍好</li><li>由于不同的硬件平台，执行同一个操作，对应的机器码可能不同，所以不同的硬件平台的同一种指令（比如mov），对应的机器码也可能不同。</li></ul><h3 id="2-2-指令集"><a href="#2-2-指令集" class="headerlink" title="2.2 指令集"></a>2.2 指令集</h3><p>不同的硬件平台，各自支持的指令，是有差别的。因此每个平台所支持的指令，称之为对应平台的指令集。如常见的</p><ul><li>x86指令集，对应的是x86架构的平台</li><li>ARM指令集，对应的是ARM架构的平台</li></ul><h2 id="3-汇编语言"><a href="#3-汇编语言" class="headerlink" title="3. 汇编语言"></a>3. 汇编语言</h2><ul><li>由于指令的可读性还是太差，于是人们又发明了汇编语言。</li><li>在汇编语言中，用助记符（Mnemonics）代替机器指令的操作码，用地址符号（Symbol）或标号（Label）代替指令或操作数的地址。</li><li>在不同的硬件平台，汇编语言对应着不同的机器语言指令集，通过汇编过程转换成机器指令。</li><li>由于计算机只认识指令码，所以用汇编语言编写的程序还必须翻译（汇编）成机器指令码，计算机才能识别和执行。</li></ul><h2 id="4-高级语言"><a href="#4-高级语言" class="headerlink" title="4. 高级语言"></a>4. 高级语言</h2><ul><li>为了使计算机用户编程序更容易些，后来就出现了各种高级计算机语言。高级语言比机器语言、汇编语言更接近人的语言</li><li>当计算机执行高级语言编写的程序时，仍然需要把程序解释和编译成机器的指令码。完成这个过程的程序就叫做解释程序或编译程序。</li></ul><p><img src="https://raw.githubusercontent.com/GeorgeChan95/blogimg/master/img/2023/12/24/20231224-134433.jpg" alt="机器语言、汇编、高级语言"></p><h2 id="5-字节码"><a href="#5-字节码" class="headerlink" title="5. 字节码"></a>5. 字节码</h2><ul><li>字节码是一种中间状态（中间码）的二进制代码（文件），它比机器码更抽象，需要直译器转译后才能成为机器码</li><li>字节码主要为了实现特定软件运行和软件环境、与硬件环境无关。</li><li>字节码的实现方式是通过编译器和虚拟机器。编译器将源码编译成字节码，特定平台上的虚拟机器将字节码转译为可以直接执行的指令。</li><li>字节码典型的应用为：Java bytecode</li></ul><h2 id="6-C、C-源程序执行过程"><a href="#6-C、C-源程序执行过程" class="headerlink" title="6. C、C++源程序执行过程"></a>6. C、C++源程序执行过程</h2><p><strong>编译过程又可以分成两个阶段：编译和汇编。</strong></p><ul><li>编译过程：是读取源程序（字符流），对之进行词法和语法的分析，将高级语言指令转换为功能等效的汇编代码</li><li>汇编过程：实际上指把汇编语言代码翻译成目标机器指令的过程。</li></ul><p><img src="https://raw.githubusercontent.com/GeorgeChan95/blogimg/master/img/2023/12/24/20231224-134804.png" alt="image-20231224134803020"></p><h1 id="四、解释器"><a href="#四、解释器" class="headerlink" title="四、解释器"></a>四、解释器</h1><h2 id="1-为什么要有解释器"><a href="#1-为什么要有解释器" class="headerlink" title="1. 为什么要有解释器"></a>1. 为什么要有解释器</h2><ul><li>JVM设计者们的初衷仅仅只是单纯地为了满足Java程序实现跨平台特性，因此避免采用静态编译的方式由高级语言直接生成本地机器指令，从而诞生了实现解释器在运行时采用逐行解释字节码执行程序的想法（也就是产生了一个中间产品<strong>字节码</strong>）。</li><li>解释器真正意义上所承担的角色就是一个运行时“翻译者”，将字节码文件中的内容“翻译”为对应平台的本地机器指令执行。</li><li>当一条字节码指令被解释执行完成后，接着再根据PC寄存器中记录的下一条需要被执行的字节码指令执行解释操作。</li></ul><p><img src="https://raw.githubusercontent.com/GeorgeChan95/blogimg/master/img/2023/12/24/20231224-135813.jpg" alt="第12章理解中间过程"></p><h2 id="2-解释器的分类"><a href="#2-解释器的分类" class="headerlink" title="2. 解释器的分类"></a>2. 解释器的分类</h2><ul><li>在Java的发展历史里，一共有两套解释执行器，即古老的<strong>字节码解释器</strong>、现在普遍使用的<strong>模板解释器</strong>。<ul><li>字节码解释器在执行时通过纯软件代码模拟字节码的执行，效率非常低下。</li><li>而模板解释器将每一条字节码和一个模板函数相关联，模板函数中直接产生这条字节码执行时的机器码，从而很大程度上提高了解释器的性能。</li></ul></li><li>在HotSpot VM中，解释器主要由Interpreter模块和Code模块构成。<ul><li>Interpreter模块：实现了解释器的核心功能</li><li>Code模块：用于管理HotSpot VM在运行时生成的本地机器指令</li></ul></li></ul><h2 id="3-解释器的现状"><a href="#3-解释器的现状" class="headerlink" title="3. 解释器的现状"></a>3. 解释器的现状</h2><ul><li>由于解释器在设计和实现上非常简单，因此除了Java语言之外，还有许多高级语言同样也是基于解释器执行的，比如Python、Perl、Ruby等。但是在今天，基于解释器执行已经沦落为低效的代名词，并且时常被一些C&#x2F;C++程序员所调侃。</li><li>为了解决这个问题，JVM平台支持一种叫作即时编译的技术。即时编译的目的是避免函数被解释执行，而是将整个函数体编译成为机器码，每次函数执行时，只执行编译后的机器码即可，这种方式可以使执行效率大幅度提升。</li><li>不过无论如何，基于解释器的执行模式仍然为中间语言的发展做出了不可磨灭的贡献。</li></ul><h1 id="五、JIT编译器"><a href="#五、JIT编译器" class="headerlink" title="五、JIT编译器"></a>五、JIT编译器</h1><h2 id="1-Java-代码执行的分类"><a href="#1-Java-代码执行的分类" class="headerlink" title="1. Java 代码执行的分类"></a>1. Java 代码执行的分类</h2><ol><li>第一种是将源代码编译成字节码文件，然后在运行时通过解释器将字节码文件转为机器码执行。</li><li>第二种是编译执行（直接编译成机器码）。现代虚拟机为了提高执行效率，会使用即时编译技术（JIT，Just In Time）将方法编译成机器码后再执行。</li></ol><ul><li>HotSpot VM是目前市面上高性能虚拟机的代表作之一。<strong>它采用解释器与即时编译器并存的架构</strong>。在Java虚拟机运行时，解释器和即时编译器能够相互协作，各自取长补短，尽力去选择最合适的方式来权衡编译本地代码的时间和直接解释执行代码的时间。</li><li>在今天，Java程序的运行性能早已脱胎换骨，已经达到了可以和C&#x2F;C++ 程序一较高下的地步。</li></ul><h2 id="2-为什么我们还需要解释器呢？"><a href="#2-为什么我们还需要解释器呢？" class="headerlink" title="2. 为什么我们还需要解释器呢？"></a>2. 为什么我们还需要解释器呢？</h2><ul><li>有些开发人员会感觉到诧异，既然HotSpot VM中已经内置JIT编译器了，那么为什么还需要再使用解释器来“拖累”程序的执行性能呢？比如JRockit VM内部就不包含解释器，字节码全部都依靠即时编译器编译后执行。</li><li>JRockit虚拟机是砍掉了解释器，也就是只采及时编译器。那是因为呢JRockit只部署在服务器上，一般已经有时间让他进行指令编译的过程了，对于响应来说要求不高，等及时编译器的编译完成后，就会提供更好的性能</li></ul><p><strong>首先明确两点：</strong></p><ol><li>当程序启动后，解释器可以马上发挥作用，<strong>响应速度快</strong>，省去编译的时间，立即执行。</li><li>编译器要想发挥作用，把代码编译成本地代码，<strong>需要一定的执行时间</strong>，但编译为本地代码后，执行效率高。</li></ol><p><strong>所以：</strong></p><ol><li>尽管JRockit VM中程序的执行性能会非常高效，但程序在启动时必然需要花费更长的时间来进行编译。对于服务端应用来说，启动时间并非是关注重点，但对于那些看中启动时间的应用场景而言，或许就需要采用解释器与即时编译器并存的架构来换取一个平衡点。</li><li>在此模式下，在Java虚拟器启动时，解释器可以首先发挥作用，而不必等待即时编译器全部编译完成后再执行，这样可以省去许多不必要的编译时间。随着时间的推移，编译器发挥作用，把越来越多的代码编译成本地代码，获得更高的执行效率。</li><li>同时，解释执行在编译器进行激进优化不成立的时候，作为编译器的“逃生门”（后备方案）。</li></ol><h2 id="3-案例"><a href="#3-案例" class="headerlink" title="3. 案例"></a>3. 案例</h2><ul><li>当虚拟机启动的时候，解释器可以首先发挥作用，而不必等待即时编译器全部编译完成再执行，这样可以省去许多不必要的编译时间。随着程序运行时间的推移，即时编译器逐渐发挥作用，根据热点探测功能，将有价值的字节码编译为本地机器指令，以换取更高的程序执行效率。</li><li>注意解释执行与编译执行在线上环境微妙的辩证关系。<strong>机器在热机状态（已经运行了一段时间叫热机状态）可以承受的负载要大于冷机状态（刚启动的时候叫冷机状态）</strong>。如果以热机状态时的流量进行切流，可能使处于冷机状态的服务器因无法承载流量而假死。</li><li>在生产环境发布过程中，以分批的方式进行发布，根据机器数量划分成多个批次，每个批次的机器数至多占到整个集群的1&#x2F;8。曾经有这样的故障案例：某程序员在发布平台进行分批发布，在输入发布总批数时，误填写成分为两批发布。如果是热机状态，在正常情况下一半的机器可以勉强承载流量，但由于刚启动的JVM均是解释执行，还没有进行热点代码统计和JIT动态编译，导致机器启动之后，当前1&#x2F;2发布成功的服务器马上全部宕机，此故障说明了JIT的存在。—<strong>阿里团队</strong></li></ul><p><img src="https://raw.githubusercontent.com/GeorgeChan95/blogimg/master/img/2023/12/24/20231224-141543.png" alt="image-20231224141541886"></p><h2 id="4-JIT编译器相关概念"><a href="#4-JIT编译器相关概念" class="headerlink" title="4. JIT编译器相关概念"></a>4. JIT编译器相关概念</h2><ul><li>Java 语言的“编译期”其实是一段“不确定”的操作过程，因为它可能是指一个前端编译器（其实叫“编译器的前端”更准确一些）把.java文件转变成.class文件的过程。</li><li>也可能是指虚拟机的后端运行期编译器（JIT编译器，Just In Time Compiler）把字节码转变成机器码的过程。</li><li>还可能是指使用静态提前编译器（AOT编译器，Ahead of Time Compiler）直接把.java文件编译成本地机器代码的过程。（可能是后续发展的趋势）</li></ul><p><strong>典型的编译器：</strong></p><ul><li>前端编译器：Sun的javac、Eclipse JDT中的增量式编译器（ECJ）。</li><li>JIT编译器：HotSpot VM的C1、C2编译器。</li><li>AOT 编译器：GNU Compiler for the Java（GCJ）、Excelsior JET。</li></ul><h2 id="5-热点代码及探测方式"><a href="#5-热点代码及探测方式" class="headerlink" title="5. 热点代码及探测方式"></a>5. 热点代码及探测方式</h2><ol><li>当然是否需要启动JIT编译器将字节码直接编译为对应平台的本地机器指令，则需要根据代码被调用<strong>执行的频率</strong>而定。</li><li>关于那些需要被编译为本地代码的字节码，也被称之为<strong>“热点代码”</strong>，JIT编译器在运行时会针对那些频繁被调用的“热点代码”做出<strong>深度优化</strong>，将其直接编译为对应平台的本地机器指令，以此提升Java程序的执行性能。</li><li>一个被多次调用的方法，或者是一-个方法体内部循环次数较多的循环体都可以被称之为“热点代码”，因此都可以通过JIT编译器编译为本地机器指令。由于这种编译方式发生在方法的执行过程中，因此也被称之为栈上替换，或简称为OSR (On StackReplacement)编译。</li><li>一个方法究竟要被调用多少次，或者一个循环体究竟需要执行多少次循环才可以达到这个标准？必然需要一个明确的阈值，JIT编译器才会将这些“热点代码”编译为本地机器指令执行。这里主要依靠热点探测功能。</li><li><strong>目前HotSpot VM所采用的热点探测方式是基于计数器的热点探测</strong>。</li><li>采用基于计数器的热点探测，HotSpot VM将会为每一个方法都建立2个不同类型的计数器，分别为方法调用计数器（Invocation Counter）和回边计数器（Back Edge Counter）。<ol><li>方法调用计数器用于统计方法的调用次数</li><li>回边计数器则用于统计循环体执行的循环次数</li></ol></li></ol><h3 id="5-1-方法调用计数器"><a href="#5-1-方法调用计数器" class="headerlink" title="5.1 方法调用计数器"></a>5.1 方法调用计数器</h3><ul><li>这个计数器就用于统计方法被调用的次数，它的默认阀值在Client模式下是1500次，在Server模式下是10000次。超过这个阈值，就会触发JIT编译。</li><li>这个阀值可以通过虚拟机参数 -XX:CompileThreshold 来人为设定。</li><li>当一个方法被调用时，会先检查该方法是否存在被JIT编译过的版本<ul><li>如果存在，则优先使用编译后的本地代码来执行</li><li>如果不存在已被编译过的版本，则将此方法的调用计数器值加1，然后判断方法调用计数器与回边计数器值之和是否超过方法调用计数器的阀值。<ul><li>如果已超过阈值，那么将会向即时编译器提交一个该方法的代码编译请求。</li><li>如果未超过阈值，则使用解释器对字节码文件解释执行</li></ul></li></ul></li></ul><img src="https://raw.githubusercontent.com/GeorgeChan95/blogimg/master/img/2023/12/24/20231224-144350.jpg" alt="第12方法调用计数器" style="zoom: 50%;" /><h3 id="5-2-热度衰减"><a href="#5-2-热度衰减" class="headerlink" title="5.2 热度衰减"></a>5.2 热度衰减</h3><ul><li>如果不做任何设置，方法调用计数器统计的并不是方法被调用的绝对次数，而是一个相对的执行频率，即<strong>一段时间之内方法被调用的次数</strong>。当超过一定的时间限度，如果方法的调用次数仍然不足以让它提交给即时编译器编译，那这个方法的调用计数器就会被减少一半，这个过程称为方法调用计数器热度的衰减（Counter Decay），而这段时间就称为此方法统计的半衰周期（Counter Half Life Time）（半衰周期是化学中的概念，比如出土的文物通过查看C60来获得文物的年龄）</li><li>进行热度衰减的动作是在虚拟机进行垃圾收集时顺便进行的，可以使用虚拟机参数 -XX:-UseCounterDecay 来关闭热度衰减，让方法计数器统计方法调用的绝对次数，这样的话，只要系统运行时间足够长，绝大部分方法都会被编译成本地代码。</li><li>另外，可以使用-XX:CounterHalfLifeTime参数设置半衰周期的时间，单位是秒。</li></ul><h3 id="5-3-回边计数器"><a href="#5-3-回边计数器" class="headerlink" title="5.3 回边计数器"></a>5.3 回边计数器</h3><p>它的作用是统计一个方法中循环体代码执行的次数，在字节码中遇到控制流向后跳转的指令称为“回边”（Back Edge）。显然，建立回边计数器统计的目的就是为了触发OSR编译。</p><img src="https://raw.githubusercontent.com/GeorgeChan95/blogimg/master/img/2023/12/24/20231224-144816.jpg" alt="回边计数器" style="zoom:50%;" /><h1 id="六、HotSpotVM可以设置程序执行方法"><a href="#六、HotSpotVM可以设置程序执行方法" class="headerlink" title="六、HotSpotVM可以设置程序执行方法"></a>六、HotSpotVM可以设置程序执行方法</h1><p>缺省情况下HotSpot VM是采用解释器与即时编译器并存的架构，当然开发人员可以根据具体的应用场景，通过命令显式地为Java虚拟机指定在运行时到底是完全采用解释器执行，还是完全采用即时编译器执行。如下所示：</p><ul><li>Xint：完全采用解释器模式执行程序；</li><li>-Xcomp：完全采用即时编译器模式执行程序。如果即时编译出现问题，解释器会介入执行</li><li>-Xmixed：采用解释器+即时编译器的混合模式共同执行程序。</li></ul><p><img src="https://raw.githubusercontent.com/GeorgeChan95/blogimg/master/img/2023/12/24/20231224-145125.png" alt="image-20231224145124164"></p><h2 id="1-代码测试"><a href="#1-代码测试" class="headerlink" title="1. 代码测试"></a>1. 代码测试</h2><pre><code class="highlight java"><span class="comment">/**</span><span class="comment"> * 测试解释器模式和JIT编译模式</span><span class="comment"> *  -Xint  : 6520ms</span><span class="comment"> *  -Xcomp : 950ms</span><span class="comment"> *  -Xmixed : 936ms</span><span class="comment"> */</span><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">IntCompTest</span> &#123;    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;        <span class="type">long</span> <span class="variable">start</span> <span class="operator">=</span> System.currentTimeMillis();        testPrimeNumber(<span class="number">1000000</span>);        <span class="type">long</span> <span class="variable">end</span> <span class="operator">=</span> System.currentTimeMillis();        System.out.println(<span class="string">&quot;花费的时间为：&quot;</span> + (end - start));    &#125;    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">testPrimeNumber</span><span class="params">(<span class="type">int</span> count)</span>&#123;        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; count; i++) &#123;            <span class="comment">//计算100以内的质数</span>            label:<span class="keyword">for</span>(<span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> <span class="number">2</span>;j &lt;= <span class="number">100</span>;j++)&#123;                <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">k</span> <span class="operator">=</span> <span class="number">2</span>;k &lt;= Math.sqrt(j);k++)&#123;                    <span class="keyword">if</span>(j % k == <span class="number">0</span>)&#123;                        <span class="keyword">continue</span> label;                    &#125;                &#125;                <span class="comment">//System.out.println(j);</span>            &#125;        &#125;    &#125;&#125;</code></pre><p><strong>结论：</strong></p><ul><li>纯解释器执行效率最低</li><li>纯编译器和编译器与解释器混合执行的效率较好。</li></ul><h1 id="七、HotSpotVM-JIT-分类"><a href="#七、HotSpotVM-JIT-分类" class="headerlink" title="七、HotSpotVM JIT 分类"></a>七、HotSpotVM JIT 分类</h1><h2 id="1-相关概念"><a href="#1-相关概念" class="headerlink" title="1. 相关概念"></a>1. 相关概念</h2><p>在HotSpot VM中内嵌有两个JIT编译器，分别为Client Compiler和Server Compiler，但大多数情况下我们简称为C1编译器 和 C2编译器。开发人员可以通过如下命令显式指定Java虚拟机在运行时到底使用哪一种即时编译器，如下所示：</p><ul><li>-client：指定Java虚拟机运行在Client模式下，并使用C1编译器；<ul><li>C1编译器会对字节码进行简单和可靠的优化，耗时短，以达到更快的编译速度。</li></ul></li><li>-server：指定Java虚拟机运行在server模式下，并使用C2编译器<ul><li>C2进行耗时较长的优化，以及激进优化，但优化的代码执行效率更高。（使用C++）</li></ul></li></ul><h2 id="2-C1和C2编译器不同的优化策略"><a href="#2-C1和C2编译器不同的优化策略" class="headerlink" title="2. C1和C2编译器不同的优化策略"></a>2. C1和C2编译器不同的优化策略</h2><ul><li><p>在不同的编译器上有不同的优化策略，C1编译器上主要有方法内联，去虚拟化、元余消除。</p><ul><li>方法内联：将引用的函数代码编译到引用点处，这样可以减少栈帧的生成，减少参数传递以及跳转过程</li><li>去虚拟化：对唯一的实现进行内联</li><li>冗余消除：在运行期间把一些不会执行的代码折叠掉</li></ul></li><li><p>C2的优化主要是在全局层面，逃逸分析是优化的基础。基于逃逸分析在C2上有如下几种优化：</p><ul><li>标量替换：用标量值代替聚合对象的属性值</li><li>栈上分配：对于未逃逸的对象分配对象在栈而不是堆</li><li>同步消除：清除同步操作，通常指synchronized</li></ul></li></ul><h2 id="3-分层编译策略"><a href="#3-分层编译策略" class="headerlink" title="3. 分层编译策略"></a>3. 分层编译策略</h2><ul><li>分层编译（Tiered Compilation）策略：程序解释执行（不开启性能监控）可以触发C1编译，将字节码编译成机器码，可以进行简单优化，也可以加上性能监控，C2编译会根据性能监控信息进行激进优化。</li><li>不过在Java7版本之后，一旦开发人员在程序中显式指定命令“-server”时，默认将会开启分层编译策略，由C1编译器和C2编译器相互协作共同来执行编译任务。</li><li>一般来讲，JIT编译出来的机器码性能比解释器解释执行的性能高</li><li>C2编译器启动时长比C1慢，系统稳定执行以后，C2编译器执行速度远快于C1编译器</li></ul><h3 id="3-1-Graal-编译器"><a href="#3-1-Graal-编译器" class="headerlink" title="3.1 Graal 编译器"></a>3.1 Graal 编译器</h3><ul><li>自JDK10起，HotSpot又加入了一个全新的即时编译器：Graal编译器</li><li>编译效果短短几年时间就追平了G2编译器，未来可期（对应还出现了Graal虚拟机，是有可能替代Hotspot的虚拟机的）</li><li>目前，带着实验状态标签，需要使用开关参数去激活才能使用</li></ul><pre><code class="highlight shell">-XX:+UnlockExperimentalvMOptions -XX:+UseJVMCICompiler</code></pre><h3 id="3-2-AOT编译器"><a href="#3-2-AOT编译器" class="headerlink" title="3.2 AOT编译器"></a>3.2 AOT编译器</h3><ul><li>jdk9引入了AoT编译器（静态提前编译器，Ahead of Time Compiler）</li><li>Java 9引入了实验性AOT编译工具jaotc。它借助了Graal编译器，将所输入的Java类文件转换为机器码，并存放至生成的动态共享库之中。</li><li>所谓AOT编译，是与即时编译相对立的一个概念。我们知道，即时编译指的是<strong>在程序的运行过程中</strong>，将字节码转换为可在硬件上直接运行的机器码，并部署至托管环境中的过程。而AOT编译指的则是，<strong>在程序运行之前</strong>，便将字节码转换为机器码的过程。<ul><li>.java -&gt; .class -&gt; (使用jaotc) -&gt; .so</li></ul></li></ul><h4 id="3-2-1-AOT编译器编译器的优缺点"><a href="#3-2-1-AOT编译器编译器的优缺点" class="headerlink" title="3.2.1 AOT编译器编译器的优缺点"></a>3.2.1 AOT编译器编译器的优缺点</h4><ul><li><strong>优点：</strong><ul><li>Java虚拟机加载已经预编译成二进制库，可以直接执行。</li><li>不必等待即时编译器的预热，减少Java应用给人带来“第一次运行慢” 的不良体验</li></ul></li><li><strong>缺点：</strong><ul><li>破坏了 java “ 一次编译，到处运行”，必须为每个不同的硬件，OS编译对应的发行包</li><li>降低了Java链接过程的动态性，加载的代码在编译器就必须全部已知。</li><li>还需要继续优化中，最初只支持Linux X64 java base</li></ul></li></ul><h1 id="参考链接"><a href="#参考链接" class="headerlink" title="参考链接"></a>参考链接</h1><blockquote><p>Java即时编译器原理解析及实践：<a href="https://tech.meituan.com/2020/10/22/java-jit-practice-in-meituan.html">https://tech.meituan.com/2020/10/22/java-jit-practice-in-meituan.html</a></p></blockquote>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;环境&quot;&gt;&lt;a href=&quot;#环境&quot; class=&quot;headerlink&quot; title=&quot;环境&quot;&gt;&lt;/a&gt;环境&lt;/h1&gt;&lt;blockquote&gt;
&lt;p&gt;系统 : Windows 10&lt;br&gt;JDK : 1.8&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h1 id=&quot;一、</summary>
      
    
    
    
    <category term="JVM" scheme="https://georgechan95.github.io/categories/JVM/"/>
    
    
    <category term="jvm" scheme="https://georgechan95.github.io/tags/jvm/"/>
    
    <category term="java" scheme="https://georgechan95.github.io/tags/java/"/>
    
  </entry>
  
</feed>
