<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>George&#39;s Blog</title>
  
  <subtitle>个人邮箱：george_95@126.com</subtitle>
  <link href="https://georgechan95.github.io/atom.xml" rel="self"/>
  
  <link href="https://georgechan95.github.io/"/>
  <updated>2024-07-05T12:00:12.790Z</updated>
  <id>https://georgechan95.github.io/</id>
  
  <author>
    <name>George</name>
    
  </author>
  
  <generator uri="https://hexo.io/">Hexo</generator>
  
  <entry>
    <title>链表反转</title>
    <link href="https://georgechan95.github.io/2024/07/05/algorithm/%E9%93%BE%E8%A1%A8%E5%8F%8D%E8%BD%AC/"/>
    <id>https://georgechan95.github.io/2024/07/05/algorithm/%E9%93%BE%E8%A1%A8%E5%8F%8D%E8%BD%AC/</id>
    <published>2024-07-05T11:45:45.000Z</published>
    <updated>2024-07-05T12:00:12.790Z</updated>
    
    <content type="html"><![CDATA[<h1 id="1-单向链表反转"><a href="#1-单向链表反转" class="headerlink" title="1. 单向链表反转"></a>1. 单向链表反转</h1><h2 id="1-1-题目要求"><a href="#1-1-题目要求" class="headerlink" title="1.1 题目要求"></a>1.1 题目要求</h2><p>给你单链表的头节点 <code>head</code> ，请你反转链表，并返回反转后的链表。</p><p><strong>示例1:</strong></p><p><img src="https://raw.githubusercontent.com/GeorgeChan95/blogimg/master/img/2024/07/05/20240705-194718.jpg" alt="img"></p><blockquote><p><strong>输入：</strong>head &#x3D; [1,2,3,4,5]</p><p><strong>输出：</strong>[5,4,3,2,1]</p></blockquote><p><strong>示例2:</strong></p><p><img src="https://raw.githubusercontent.com/GeorgeChan95/blogimg/master/img/2024/07/05/20240705-195131.jpg" alt="img"></p><blockquote><p>输入：head &#x3D; [1,2]<br>输出：[2,1]</p></blockquote><p><strong>示例3:</strong></p><blockquote><p>输入：head &#x3D; []<br>输出：[]</p></blockquote><h2 id="1-2-思路分析"><a href="#1-2-思路分析" class="headerlink" title="1.2 思路分析"></a>1.2 思路分析</h2><p>假设链表为 1→2→3→∅，我们想要把它改成 ∅←1←2←3。</p><p>在遍历链表时，将当前节点的 next 指针改为指向前一个节点。由于节点没有引用其前一个节点，因此必须事先存储其前一个节点。在更改引用之前，还需要存储后一个节点。最后返回新的头引用。</p><h2 id="1-3-关键代码"><a href="#1-3-关键代码" class="headerlink" title="1.3 关键代码"></a>1.3 关键代码</h2><pre><code class="highlight java"><span class="comment">/**</span><span class="comment"> * 单向节点</span><span class="comment"> */</span><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">SinglyNode</span> &#123;    <span class="keyword">public</span> <span class="type">int</span> val;    <span class="comment">/**</span><span class="comment">     * 下一个节点</span><span class="comment">     */</span>    <span class="keyword">public</span> SinglyNode next;    <span class="keyword">public</span> <span class="title function_">SinglyNode</span><span class="params">(<span class="type">int</span> val)</span> &#123;        <span class="built_in">this</span>.val = val;    &#125;    <span class="keyword">public</span> <span class="title function_">SinglyNode</span><span class="params">(<span class="type">int</span> val, SinglyNode next)</span> &#123;        <span class="built_in">this</span>.val = val;        <span class="built_in">this</span>.next = next;    &#125;&#125;<span class="comment">/**</span><span class="comment"> * 单向链表反转</span><span class="comment"> * <span class="doctag">@param</span> head 头节点</span><span class="comment"> * <span class="doctag">@return</span></span><span class="comment"> */</span><span class="keyword">public</span> <span class="keyword">static</span> SinglyNode <span class="title function_">reverseSinglyList</span><span class="params">(SinglyNode head)</span> &#123;    <span class="type">SinglyNode</span> <span class="variable">pre</span> <span class="operator">=</span> <span class="literal">null</span>; <span class="comment">// 当前节点的前一个节点,默认是null</span>    <span class="type">SinglyNode</span> <span class="variable">next</span> <span class="operator">=</span> <span class="literal">null</span>; <span class="comment">// 当前节点的下一个节点,默认是null</span>    <span class="keyword">while</span> (head != <span class="literal">null</span>) &#123;        next = head.next; <span class="comment">// 获取当前节点的下一个节点</span>        head.next = pre; <span class="comment">// 当前节点的前一个节点变成当前的下一个节点(方向反转)</span>        pre = head; <span class="comment">// 当前节点赋值给pre,指针后移</span>        head = next; <span class="comment">// 指针移动到next节点,继续循环</span>    &#125;    <span class="keyword">return</span> pre; <span class="comment">// 最后头节点的引用</span>&#125;</code></pre><p>完整测试代码见: <a href="https://github.com/GeorgeChan95/algorithm/blob/master/src/main/java/com/george/reverseList/ReverseSingleList.java">https://github.com/GeorgeChan95/algorithm/blob/master/src/main/java/com/george/reverseList/ReverseSingleList.java</a></p><h1 id="2-双向链表反转"><a href="#2-双向链表反转" class="headerlink" title="2. 双向链表反转"></a>2. 双向链表反转</h1><h2 id="2-1-关键代码"><a href="#2-1-关键代码" class="headerlink" title="2.1 关键代码"></a>2.1 关键代码</h2><pre><code class="highlight java"><span class="comment">/**</span><span class="comment"> * 双向链表节点</span><span class="comment"> */</span><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">DoubleListNode</span> &#123;    <span class="keyword">public</span> <span class="type">int</span> value;    <span class="comment">/**</span><span class="comment">     * 前一个节点</span><span class="comment">     */</span>    <span class="keyword">public</span> DoubleListNode last;    <span class="comment">/**</span><span class="comment">     * 下一个节点</span><span class="comment">     */</span>    <span class="keyword">public</span> DoubleListNode next;    <span class="keyword">public</span> <span class="title function_">DoubleListNode</span><span class="params">(<span class="type">int</span> value)</span> &#123;        <span class="built_in">this</span>.value = value;    &#125;&#125;<span class="comment">/**</span><span class="comment"> * 双向链表反转</span><span class="comment"> * <span class="doctag">@param</span> head 头节点</span><span class="comment"> * <span class="doctag">@return</span></span><span class="comment"> */</span><span class="keyword">public</span> <span class="keyword">static</span> DoubleListNode <span class="title function_">reverseList</span><span class="params">(DoubleListNode head)</span> &#123;    <span class="type">DoubleListNode</span> <span class="variable">last</span> <span class="operator">=</span> <span class="literal">null</span>; <span class="comment">// 前一个节点</span>    <span class="type">DoubleListNode</span> <span class="variable">next</span> <span class="operator">=</span> <span class="literal">null</span>; <span class="comment">// 下一个节点</span>    <span class="keyword">while</span> (head != <span class="literal">null</span>) &#123;        next = head.next; <span class="comment">// 获取当前节点的下一个节点</span>        head.next = last; <span class="comment">// 前一个节点变成当前节点的下一个节点(链表方向反转)[原来头节点的last节点为空,反转后在链表末尾,next节点为空]</span>        head.last = next; <span class="comment">// 下一个节点变成当前节点的前一个节点(方向反转)[原链表末尾节next节点为空,反转后变成头节点,last节点为空]</span>        last = head; <span class="comment">// 当前节点变成前一个节点,指针后移</span>        head = next; <span class="comment">// 指针指向下一个节点,进入下一轮循环.</span>    &#125;    <span class="keyword">return</span> last; <span class="comment">// 返回反转后的头节点的引用</span>&#125;</code></pre>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;1-单向链表反转&quot;&gt;&lt;a href=&quot;#1-单向链表反转&quot; class=&quot;headerlink&quot; title=&quot;1. 单向链表反转&quot;&gt;&lt;/a&gt;1. 单向链表反转&lt;/h1&gt;&lt;h2 id=&quot;1-1-题目要求&quot;&gt;&lt;a href=&quot;#1-1-题目要求&quot; class=&quot;he</summary>
      
    
    
    
    <category term="算法" scheme="https://georgechan95.github.io/categories/%E7%AE%97%E6%B3%95/"/>
    
    
    <category term="算法" scheme="https://georgechan95.github.io/tags/%E7%AE%97%E6%B3%95/"/>
    
    <category term="链表" scheme="https://georgechan95.github.io/tags/%E9%93%BE%E8%A1%A8/"/>
    
  </entry>
  
  <entry>
    <title>选择-冒泡-插入排序</title>
    <link href="https://georgechan95.github.io/2024/07/03/algorithm/%E9%80%89%E6%8B%A9-%E5%86%92%E6%B3%A1-%E6%8F%92%E5%85%A5%E6%8E%92%E5%BA%8F/"/>
    <id>https://georgechan95.github.io/2024/07/03/algorithm/%E9%80%89%E6%8B%A9-%E5%86%92%E6%B3%A1-%E6%8F%92%E5%85%A5%E6%8E%92%E5%BA%8F/</id>
    <published>2024-07-03T03:02:16.000Z</published>
    <updated>2024-07-03T07:17:03.424Z</updated>
    
    <content type="html"><![CDATA[<h1 id="一-选择排序"><a href="#一-选择排序" class="headerlink" title="一. 选择排序"></a>一. 选择排序</h1><h2 id="1-算法步骤"><a href="#1-算法步骤" class="headerlink" title="1. 算法步骤"></a>1. 算法步骤</h2><ul><li>首先在未排序序列中找到最小（大）元素，存放到排序序列的起始位置。</li><li>再从剩余未排序元素中继续寻找最小（大）元素，然后放到已排序序列的末尾。</li><li>重复第二步，直到所有元素均排序完毕。</li></ul><h2 id="2-动图演示"><a href="#2-动图演示" class="headerlink" title="2. 动图演示"></a>2. 动图演示</h2><p><img src="https://www.runoob.com/wp-content/uploads/2019/03/selectionSort.gif" alt="选择排序"></p><h2 id="3-代码实现"><a href="#3-代码实现" class="headerlink" title="3. 代码实现"></a>3. 代码实现</h2><pre><code class="highlight java"><span class="comment">/**</span><span class="comment"> * 选择排序</span><span class="comment"> * <span class="doctag">@param</span> arr 无序数组</span><span class="comment"> */</span><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">selectSort</span><span class="params">(<span class="type">int</span>[] arr)</span> &#123;    <span class="keyword">if</span> (arr == <span class="literal">null</span> || arr.length &lt; <span class="number">2</span>) &#123; <span class="comment">// 极值判断</span>        <span class="keyword">return</span>;    &#125;    <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; arr.length; i++) &#123; <span class="comment">// 外层循环,每次循环找到一个最小值,并将它排序,数组中有多少元素,就需要循环排序多少次</span>        <span class="type">int</span> <span class="variable">minIndex</span> <span class="operator">=</span> i; <span class="comment">// 每一次循环中,先初始化一个最小值的位置索引,在后面的循环中再更新这个索引,直到找到最小值所在位置</span>        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> i+<span class="number">1</span>; j &lt; arr.length; j++) &#123; <span class="comment">// 内层循环目的是:找到数组元素中最小的值所在位置的索引.</span>            <span class="keyword">if</span> (arr[minIndex] &gt; arr[j]) &#123; <span class="comment">// 如果发现了比minIndex位置的值更小的值,就更新minIndex,这样就保证了minIndex始终是最小元素的索引</span>                minIndex = j;            &#125;        &#125;        <span class="comment">// 找到外层循环中最小的值后,交换i位置和minIndex位置的值,目的是将最小的值往前放,在下一轮循环中不再遍历它了</span>        swap(arr, minIndex, i);    &#125;&#125;</code></pre><h1 id="二-冒泡排序"><a href="#二-冒泡排序" class="headerlink" title="二. 冒泡排序"></a>二. 冒泡排序</h1><h2 id="1-算法步骤-1"><a href="#1-算法步骤-1" class="headerlink" title="1. 算法步骤"></a>1. 算法步骤</h2><ul><li>比较相邻的元素。如果第一个比第二个大，就交换他们两个。</li><li>对每一对相邻元素作同样的工作，从开始第一对到结尾的最后一对。这步做完后，最后的元素会是最大的数。</li><li>针对所有的元素重复以上的步骤，除了最后一个。</li><li>持续每次对越来越少的元素重复上面的步骤，直到没有任何一对数字需要比较。</li></ul><h2 id="2-动图演示-1"><a href="#2-动图演示-1" class="headerlink" title="2. 动图演示"></a>2. 动图演示</h2><p><img src="https://www.runoob.com/wp-content/uploads/2019/03/bubbleSort.gif" alt="冒泡排序"></p><h2 id="3-代码实现-1"><a href="#3-代码实现-1" class="headerlink" title="3. 代码实现"></a>3. 代码实现</h2><pre><code class="highlight java"><span class="comment">/**</span><span class="comment"> * 冒泡排序</span><span class="comment"> *</span><span class="comment"> * <span class="doctag">@param</span> arr</span><span class="comment"> */</span><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">bubbleSort</span><span class="params">(<span class="type">int</span>[] arr)</span> &#123;    <span class="keyword">if</span> (arr == <span class="literal">null</span> || arr.length &lt; <span class="number">2</span>) &#123; <span class="comment">// 极值判断,无需排序</span>        <span class="keyword">return</span>;    &#125;    <span class="comment">// 外层循环,从后往前遍历,目的是将数组按照从小到大的顺利排列</span>    <span class="comment">// 使用 i&gt;0 而不是 i&gt;=0,是因为这是从后往前遍历,当后面的元素全部已经排好序之后,最后一个元素无需再比较,它只能是最小的那个.</span>    <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> arr.length - <span class="number">1</span>; i &gt; <span class="number">0</span>; i--) &#123;        <span class="comment">// 内存循环逐个比较当前元素与后一个元素的大小,如果当前元素大于后一个元素,则交换位置</span>        <span class="comment">// i是数组的元素的个数,使用 j&lt;i,而不是j&lt;=i是因为要把j与j后面的元素比较大小和交换位置,无需遍历到最后一个元素.</span>        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> <span class="number">0</span>; j &lt; i; j++) &#123;            <span class="comment">// 如果j大j+1的值,则将j与j+1位置交换</span>            <span class="comment">// 在交换位置后,有开始下一轮for循环,再往后比较和交换每一个值,重复下去,直到找到最大的值放到数组右边</span>            <span class="keyword">if</span> (arr[j] &gt; arr[j + <span class="number">1</span>]) &#123;                swap(arr, j, j + <span class="number">1</span>);            &#125;        &#125;    &#125;&#125;</code></pre><h1 id="三-插入排序"><a href="#三-插入排序" class="headerlink" title="三. 插入排序"></a>三. 插入排序</h1><h2 id="1-算法步骤-2"><a href="#1-算法步骤-2" class="headerlink" title="1. 算法步骤"></a>1. 算法步骤</h2><ul><li>将数组中的第一个元素看做一个有序序列，把第二个元素到最后一个元素当成是未排序序列。</li><li>从头到尾依次扫描未排序序列，将扫描到的每个元素插入有序序列的适当位置。（如果待插入的元素与有序序列中的某个元素相等，则将待插入元素插入到相等元素的后面。）</li></ul><h2 id="2-动图演示-2"><a href="#2-动图演示-2" class="headerlink" title="2. 动图演示"></a>2. 动图演示</h2><p><img src="https://www.runoob.com/wp-content/uploads/2019/03/insertionSort.gif" alt="插入排序"></p><h2 id="3-代码实现-2"><a href="#3-代码实现-2" class="headerlink" title="3. 代码实现"></a>3. 代码实现</h2><pre><code class="highlight java"><span class="comment">/**</span><span class="comment"> * 插入排序</span><span class="comment"> *</span><span class="comment"> * <span class="doctag">@param</span> arr</span><span class="comment"> */</span><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">insertSort</span><span class="params">(<span class="type">int</span>[] arr)</span> &#123;    <span class="keyword">if</span> (arr == <span class="literal">null</span> || arr.length &lt; <span class="number">2</span>) &#123; <span class="comment">// 极值判断</span>        <span class="keyword">return</span>;    &#125;    <span class="comment">// 将arr数组的第0个元素看作是一个有序数组(就一个元素肯定有序),第1个元素到第arr.length-1个元素看作是无序数组,</span>    <span class="comment">// 外层循环就是遍历这个无序数组,将它们逐个向有序数组中插入.</span>    <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">1</span>; i &lt; arr.length; i++) &#123;        <span class="comment">// arr数组中i-1位置到0位置是有序的,i位置(也就是j+1)就是本轮内层循环要比较插入的数</span>        <span class="comment">// 内层循环从后向前(从大到小)遍历有序数组的每一个元素与j+1的数进行比较,如果j+1的数小,就往前插</span>        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> i - <span class="number">1</span>; j &gt;= <span class="number">0</span> &amp;&amp; arr[j] &gt; arr[j + <span class="number">1</span>]; j--) &#123;            swap(arr, j, j + <span class="number">1</span>);        &#125;    &#125;&#125;</code></pre><p>完整测试代码: <a href="https://github.com/GeorgeChan95/algorithm/blob/master/src/main/java/com/george/baseSort/SelectBubbleInsert.java">https://github.com/GeorgeChan95/algorithm/blob/master/src/main/java/com/george/baseSort/SelectBubbleInsert.java</a></p><blockquote><p><strong>参考链接</strong></p></blockquote><p>[菜鸟教程]: <a href="https://www.runoob.com/w3cnote/insertion-sort.html">https://www.runoob.com/w3cnote/insertion-sort.html</a>“插入排序”<br>[菜鸟教程]: <a href="https://www.runoob.com/w3cnote/bubble-sort.html">https://www.runoob.com/w3cnote/bubble-sort.html</a>“冒泡排序”<br>[菜鸟教程]: <a href="https://www.runoob.com/w3cnote/selection-sort.html">https://www.runoob.com/w3cnote/selection-sort.html</a>“选择排序”</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;一-选择排序&quot;&gt;&lt;a href=&quot;#一-选择排序&quot; class=&quot;headerlink&quot; title=&quot;一. 选择排序&quot;&gt;&lt;/a&gt;一. 选择排序&lt;/h1&gt;&lt;h2 id=&quot;1-算法步骤&quot;&gt;&lt;a href=&quot;#1-算法步骤&quot; class=&quot;headerlink&quot; ti</summary>
      
    
    
    
    <category term="算法" scheme="https://georgechan95.github.io/categories/%E7%AE%97%E6%B3%95/"/>
    
    
    <category term="算法" scheme="https://georgechan95.github.io/tags/%E7%AE%97%E6%B3%95/"/>
    
    <category term="选择排序" scheme="https://georgechan95.github.io/tags/%E9%80%89%E6%8B%A9%E6%8E%92%E5%BA%8F/"/>
    
    <category term="冒泡排序" scheme="https://georgechan95.github.io/tags/%E5%86%92%E6%B3%A1%E6%8E%92%E5%BA%8F/"/>
    
    <category term="插入排序" scheme="https://georgechan95.github.io/tags/%E6%8F%92%E5%85%A5%E6%8E%92%E5%BA%8F/"/>
    
  </entry>
  
  <entry>
    <title>二分搜索</title>
    <link href="https://georgechan95.github.io/2024/06/29/algorithm/%E4%BA%8C%E5%88%86%E6%90%9C%E7%B4%A2/"/>
    <id>https://georgechan95.github.io/2024/06/29/algorithm/%E4%BA%8C%E5%88%86%E6%90%9C%E7%B4%A2/</id>
    <published>2024-06-29T02:04:10.000Z</published>
    <updated>2024-07-03T03:00:38.633Z</updated>
    
    <content type="html"><![CDATA[<h1 id="1-二分搜索的概念"><a href="#1-二分搜索的概念" class="headerlink" title="1. 二分搜索的概念"></a>1. 二分搜索的概念</h1><ul><li><p>二分查找是一种在有序数组中查找某一特定元素的搜索算法。</p></li><li><p>二分查找的原理是，将目标元素和查找范围的中间值做比较，如果目标元素等于中间值，则查找结束；如果目标元素大于或小于中间元素，则在数组大于或小于中间元素的那一半中查找，而且跟开始一样从中间元素开始比较。这样每一次比较都使搜索范围缩小一半。</p></li></ul><h1 id="2-在有序数组中查找-num-是否存在"><a href="#2-在有序数组中查找-num-是否存在" class="headerlink" title="2. 在有序数组中查找 num 是否存在"></a>2. 在有序数组中查找 num 是否存在</h1><ul><li><p>需求</p><p>给定一个有序数组 <code>arr</code> , 给定一个目标值 <code>target</code> , 查找 <code>target</code> 在 <code>arr</code> 中是否存在.</p></li><li><p>思路</p><p>对于有序数组中的数值查找, 首先想到使用二分法实现.</p></li><li><p>关键代码</p><pre><code class="highlight java"><span class="comment">/**</span><span class="comment"> * 查找target在arr中是否存在</span><span class="comment"> *</span><span class="comment"> * <span class="doctag">@param</span> arr    有序数组</span><span class="comment"> * <span class="doctag">@param</span> target 目标值</span><span class="comment"> * <span class="doctag">@return</span> true:表示target在arr中存在, false表示不存在</span><span class="comment"> */</span><span class="keyword">public</span> <span class="keyword">static</span> <span class="type">boolean</span> <span class="title function_">exist</span><span class="params">(<span class="type">int</span>[] arr, <span class="type">int</span> target)</span> &#123;    <span class="keyword">if</span> (arr == <span class="literal">null</span> || arr.length == <span class="number">0</span>) &#123; <span class="comment">// 当数组为空时,无需查找,返回false.</span>        <span class="keyword">return</span> <span class="literal">false</span>;    &#125;    <span class="type">int</span> <span class="variable">L</span> <span class="operator">=</span> <span class="number">0</span>; <span class="comment">// 查找范围区间左侧的元素的下标,从0开始</span>    <span class="type">int</span> <span class="variable">R</span> <span class="operator">=</span> arr.length - <span class="number">1</span>; <span class="comment">// 查找范围区间右侧元素的下标,从arr的末尾开始</span>    <span class="type">int</span> <span class="variable">M</span> <span class="operator">=</span> <span class="number">0</span>; <span class="comment">// 中间元素的位置,默认是0</span>    <span class="comment">// &lt;= 表示这是一个 [左闭,右闭] 的区间范围.</span>    <span class="comment">// 不使用 &lt; 是考虑到在查找的过程中会动态调整L和R的值,有可能出现 L和R 重合的情况,即区间范围只有一个值的情况.</span>    <span class="keyword">while</span> (L &lt;= R) &#123;        M = (L + R) / <span class="number">2</span>; <span class="comment">// 获取查询区间的中点</span>        <span class="comment">// 下面这种方式计算结果与上面相同,但是可以避免 L + R 溢出的问题</span>        <span class="comment">// M = L + ((R-L)&gt;&gt;1);</span>        <span class="keyword">if</span> (arr[M] == target) &#123; <span class="comment">// 中点的值正好等于target,找找到了该元素,返回true.</span>            <span class="keyword">return</span> <span class="literal">true</span>;        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (arr[M] &lt; target) &#123; <span class="comment">// 目标值大于中点的值,则从中点+1的位置往右查找</span>            L = M + <span class="number">1</span>;        &#125; <span class="keyword">else</span> &#123; <span class="comment">// 目标值小于中点的值,则从中点-1的位置往左查找</span>            R = M - <span class="number">1</span>;        &#125;    &#125;    <span class="comment">// 如果while循环没有找到target,则返回false;</span>    <span class="keyword">return</span> <span class="literal">false</span>;&#125;</code></pre></li><li><p>完整测试代码</p><p><a href="https://github.com/GeorgeChan95/algorithm/blob/master/src/main/java/com/george/binarySearch/FindNumber.java">https://github.com/GeorgeChan95/algorithm/blob/master/src/main/java/com/george/binarySearch/FindNumber.java</a></p></li></ul><h1 id="3-在有序数组中查找-num-的最左位置"><a href="#3-在有序数组中查找-num-的最左位置" class="headerlink" title="3. 在有序数组中查找 &gt;&#x3D;num 的最左位置"></a>3. 在有序数组中查找 &gt;&#x3D;num 的最左位置</h1><ul><li><p>需求</p><p>给定一个从小到大的有序数组 arr, 给定一个目标值 target, 查找在这个数组中 &gt;&#x3D;target的 最左侧的元素的下标值.</p></li><li><p>实现思路</p><ul><li>有序数组中的操作,首先考虑二分查找.找到数组中间位置的数据,比较中间值是否大于等于目标值, 如果是则表明目标值一定在中间元素的左边.此时就需要向左查找.</li><li>如果中间值小于目标值,则表明目标值在中间值的右边,此时就需要往右查找.</li></ul></li><li><p>关键代码</p><pre><code class="highlight java"><span class="comment">/**</span><span class="comment"> * 使用二分查找法,获取 &gt;=target 的最左边的数的下标</span><span class="comment"> *</span><span class="comment"> * <span class="doctag">@param</span> arr    目标数组, 例如: [1,2,3,4,5,6,7,8,9]</span><span class="comment"> * <span class="doctag">@param</span> target 目标值, 例如: 2</span><span class="comment"> * <span class="doctag">@return</span></span><span class="comment"> */</span><span class="keyword">public</span> <span class="keyword">static</span> <span class="type">int</span> <span class="title function_">findLeft</span><span class="params">(<span class="type">int</span>[] arr, <span class="type">int</span> target)</span> &#123;    <span class="type">int</span> <span class="variable">L</span> <span class="operator">=</span> <span class="number">0</span>; <span class="comment">// 查找范围区间左侧的元素的下标,从0开始</span>    <span class="type">int</span> <span class="variable">R</span> <span class="operator">=</span> arr.length - <span class="number">1</span>; <span class="comment">// 查找范围区间右侧元素的下标,从arr的末尾开始</span>    <span class="type">int</span> <span class="variable">M</span> <span class="operator">=</span> <span class="number">0</span>; <span class="comment">// 中间元素的位置,默认是0</span>    <span class="type">int</span> <span class="variable">ans</span> <span class="operator">=</span> -<span class="number">1</span>; <span class="comment">// 查找到的目标值的下标,没有找到则返回-1</span>    <span class="keyword">if</span> (arr == <span class="literal">null</span> || arr.length == <span class="number">0</span>) &#123; <span class="comment">// 当数组为空时,无需查找,返回 -1.</span>        <span class="keyword">return</span> ans;    &#125;    <span class="keyword">while</span> (L &lt;= R) &#123; <span class="comment">// 确保查找范围区间元素数量 &gt;=1 个</span>        M = (L + R) / <span class="number">2</span>; <span class="comment">// 获取查询区间的中点</span>        <span class="comment">// 下面这种方式计算结果与上面相同,但是可以避免 L + R 溢出的问题</span>        <span class="comment">// M = L + ((R-L)&gt;&gt;1);</span>        <span class="keyword">if</span> (arr[M] &gt;= target) &#123; <span class="comment">// 如果中点元素值 &gt;=target 说明中点往左可能还有别的数也 &gt;=target,此时记录下标值,继续向中点左侧找,直到找到最左边 &gt;=target 的值.</span>            R = M - <span class="number">1</span>; <span class="comment">// 区间往左搜小</span>            ans = M; <span class="comment">// 记录当前下标值</span>        &#125; <span class="keyword">else</span> &#123; <span class="comment">// 如果中点元素值 &lt;target, 说明目标元素在中点往右的位置,则需要向右查找</span>            L = M + <span class="number">1</span>;        &#125;    &#125;    <span class="comment">// &gt;=target最左边的数的下标</span>    <span class="keyword">return</span> ans;&#125;</code></pre></li><li><p>完整测试代码</p><p><a href="https://github.com/GeorgeChan95/algorithm/blob/master/src/main/java/com/george/binarySearch/FindLeft.java">https://github.com/GeorgeChan95/algorithm/blob/master/src/main/java/com/george/binarySearch/FindLeft.java</a></p></li></ul><h1 id="4-在有序数组中查找"><a href="#4-在有序数组中查找" class="headerlink" title="4. 在有序数组中查找 &lt;&#x3D;num 的最右位置"></a>4. 在有序数组中查找 &lt;&#x3D;num 的最右位置</h1><ul><li><p>需求</p><p>给定一个从小到大的有序数组 arr, 给定一个目标值 target, 查找在arr数组中 &lt;&#x3D;target 的最右侧(最大)的元素的下标值.</p></li><li><p>思路</p><ul><li>有序数组中的操作,首先考虑二分查找.找到数组中间位置的数据,比较中间值是否小于等于目标值, 如果是则表明目标值一定在中间元素的右边.此时就需要向右查找.</li><li>如果中间值大于目标值,则表明目标值在中间值的左边,此时就需要往左查找.</li></ul></li><li><p>关键代码</p><pre><code class="highlight java"><span class="comment">/**</span><span class="comment">  * 使用二分查找，数组arr中 &lt;=num 最右边的数的下标值</span><span class="comment">  *</span><span class="comment">  * <span class="doctag">@param</span> arr    从小到大的有序数组</span><span class="comment">  * <span class="doctag">@param</span> target 要查询的目标值</span><span class="comment">  * <span class="doctag">@return</span></span><span class="comment">  */</span><span class="keyword">public</span> <span class="keyword">static</span> <span class="type">int</span> <span class="title function_">findRight</span><span class="params">(<span class="type">int</span>[] arr, <span class="type">int</span> target)</span> &#123;    <span class="type">int</span> <span class="variable">L</span> <span class="operator">=</span> <span class="number">0</span>; <span class="comment">// 数组中查找的左侧区间范围，从0开始</span>    <span class="type">int</span> <span class="variable">R</span> <span class="operator">=</span> arr.length - <span class="number">1</span>; <span class="comment">// 数组中查找的右侧区间范围,从数组的末尾开始</span>    <span class="type">int</span> <span class="variable">M</span> <span class="operator">=</span> <span class="number">0</span>; <span class="comment">// 初始中间位置</span>    <span class="type">int</span> <span class="variable">ans</span> <span class="operator">=</span> -<span class="number">1</span>; <span class="comment">// 响应结果,-1表示没有找到该元素</span>    <span class="keyword">if</span> (arr == <span class="literal">null</span> || arr.length == <span class="number">0</span>) &#123; <span class="comment">// 数组为空,不再继续查找</span>        <span class="keyword">return</span> ans;    &#125;    <span class="keyword">while</span> (L &lt;= R) &#123; <span class="comment">// 确保查找范围区间元素数量 &gt;=1 个</span>        M = L + (R - L) / <span class="number">2</span>; <span class="comment">// 获取中间位置</span>        <span class="keyword">if</span> (arr[M] &lt;= target) &#123; <span class="comment">// 中间值与目标值进行比较,如果&lt;=target,则标记下当前位置,继续向右查找,如果 &gt;target则向左继续查找</span>            ans = M; <span class="comment">// 标记当前下标</span>            L = M + <span class="number">1</span>; <span class="comment">// 左侧查询区间移动到 M+1 位置,继续往右查找</span>        &#125; <span class="keyword">else</span> &#123;            R = M - <span class="number">1</span>; <span class="comment">// 右侧查询区间移动到 M-1 位置,继续往左查找</span>        &#125;    &#125;    <span class="comment">// 返回查询结果</span>    <span class="keyword">return</span> ans;&#125;</code></pre></li><li><p>完整测试代码</p><p><a href="https://github.com/GeorgeChan95/algorithm/blob/master/src/main/java/com/george/binarySearch/FindRight.java">https://github.com/GeorgeChan95/algorithm/blob/master/src/main/java/com/george/binarySearch/FindRight.java</a></p></li></ul><h1 id="5-无序数组使用二分法寻找峰值"><a href="#5-无序数组使用二分法寻找峰值" class="headerlink" title="5. 无序数组使用二分法寻找峰值"></a>5. 无序数组使用二分法寻找峰值</h1><ul><li><p><strong>题目描述</strong></p><ul><li><p>峰值元素是指其值严格大于左右相邻值的元素。</p></li><li><p>给你一个整数数组 <code>nums</code>，找到峰值元素并返回其索引。数组可能包含多个峰值，在这种情况下，返回 <strong>任何一个峰值</strong> 所在位置即可。</p></li><li><p>你可以假设 <code>nums[-1] = nums[n] = -∞</code> 。</p></li><li><p>你必须实现时间复杂度为 <code>O(log n)</code> 的算法来解决此问题。</p></li></ul></li><li><p><strong>示例 1：</strong></p><ul><li>输入：nums &#x3D; [1,2,3,1]</li><li>输出：2</li><li>解释：3 是峰值元素，你的函数应该返回其索引 2。</li></ul></li><li><p><strong>示例 2：</strong></p><ul><li>输入：nums &#x3D; [1,2,1,3,5,6,4]</li><li>输出：1 或 5 </li><li>解释：你的函数可以返回索引 1，其峰值元素为 2；<br> 或者返回索引 5， 其峰值元素为 6。</li></ul></li><li><p><strong>提示：</strong></p><ul><li>1 &lt;&#x3D; nums.length &lt;&#x3D; 1000 (数组长度在 1~1000范围内)</li><li>-2<sup>31</sup>  &lt;&#x3D; nums[i]  &lt;&#x3D; 2<sup>31-1</sup>  (数组元素值不超过int最大值)</li><li>对于所有有效的 i 都有 nums[i] !&#x3D; nums[i + 1] (数组中任意相邻的两个数不相等)</li></ul></li><li><p><strong>思路</strong></p><ul><li><p>虽然寻找峰值这样的题目,不是在有序数组中,但具体题目的要求,依然可以使用二分查找解决这个问题.</p></li><li><p>如果一个数组中存在峰值,那么从这个数组的第0个位置到最后一个位置所经过的数值,连成线一定是时高时低(想象着把数值连城折线图). </p></li><li><p>可以先从中间位置开始找峰值, 如果中间位置的数比左右两侧的数都要大,则找到峰值.</p></li><li><p>如果中间位置比左侧的数据小,则表示在左边一定至少存在一个峰值. 因为哪怕是最极端的情况, 从0位置到中间位置数据是逐个减小的,那么0位置就是峰值. 所以至少会有一个峰值. 按照这个思路继续使用二分法向左边查找峰值,直到找到一个峰值.</p></li><li><p>如果中间位置比右侧的数据小,则表示在右边至少存在一个峰值,理由和上一条相同.</p></li></ul></li><li><p><strong>关键代码</strong></p><pre><code class="highlight java"><span class="comment">/**</span><span class="comment">  * 使用二分查找,找到数组中的峰值</span><span class="comment">  * <span class="doctag">@param</span> arr 数组</span><span class="comment">  * <span class="doctag">@return</span></span><span class="comment">  */</span><span class="keyword">public</span> <span class="keyword">static</span> <span class="type">int</span> <span class="title function_">findPeak</span><span class="params">(<span class="type">int</span>[] arr)</span> &#123;    <span class="type">int</span> <span class="variable">n</span> <span class="operator">=</span> arr.length; <span class="comment">// 数组的长度</span>    <span class="keyword">if</span> (n == <span class="number">1</span>) &#123; <span class="comment">// 数组长度为1,那么这个元素就是峰值,因为: arr[-1] = arr[n] = 无穷小</span>        <span class="keyword">return</span> <span class="number">0</span>;    &#125;    <span class="keyword">if</span> (arr[<span class="number">0</span>] &gt; arr[<span class="number">1</span>]) &#123; <span class="comment">// 满足条件: arr[-1] = 无穷小</span>        <span class="keyword">return</span> <span class="number">0</span>;    &#125;    <span class="keyword">if</span> (arr[n - <span class="number">1</span>] &gt; arr[n - <span class="number">2</span>]) &#123; <span class="comment">// 满足条件: arr[n] = 无穷小</span>        <span class="keyword">return</span> n - <span class="number">1</span>;    &#125;    <span class="type">int</span> <span class="variable">L</span> <span class="operator">=</span> <span class="number">1</span>; <span class="comment">// 二分查找的左侧区间范围, 从 1 开始</span>    <span class="type">int</span> <span class="variable">R</span> <span class="operator">=</span> n - <span class="number">2</span>; <span class="comment">// 二分查找的右侧区间范围, 从 n-2 开始</span>    <span class="type">int</span> <span class="variable">M</span> <span class="operator">=</span> <span class="number">0</span>; <span class="comment">// 中间索引,默认:0</span>    <span class="type">int</span> <span class="variable">ans</span> <span class="operator">=</span> -<span class="number">1</span>; <span class="comment">// 峰值所在位置索引</span>    <span class="keyword">while</span> (L &lt;= R) &#123;        M = L + ((R - L) / <span class="number">2</span>); <span class="comment">// 计算中间值索引</span>        <span class="keyword">if</span> (arr[M + <span class="number">1</span>] &gt; arr[M]) &#123; <span class="comment">// M到n-1区域一定存在峰值,向右查找</span>            L = M + <span class="number">1</span>;        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (arr[M - <span class="number">1</span>] &gt; arr[M]) &#123; <span class="comment">// 0到M区域一定存在峰值,向左查找</span>            R = M - <span class="number">1</span>;        &#125; <span class="keyword">else</span> &#123;            ans = M; <span class="comment">// 找到峰值, 跳出循环</span>            <span class="keyword">break</span>;        &#125;    &#125;    <span class="keyword">return</span> ans;&#125;</code></pre></li><li><p>测试地址</p><p><a href="https://leetcode.cn/problems/find-peak-element/">https://leetcode.cn/problems/find-peak-element/</a></p></li></ul><h1 id="6-技巧"><a href="#6-技巧" class="headerlink" title="6. 技巧"></a>6. 技巧</h1><ul><li>二分查找需要根据左右两个查询区间找到中间位置的下标, 但是当查询范围特别大时,比如数组长度: 2<sup>31</sup> , 左右区间相加就会溢出,导致计算出错. 为了避免数值溢出, 不能使用 <code>(L+R)/2</code> 的方式计算中间值, 需要用 <code>L+(R-L)/2</code> 的方式.</li><li>L + ((R-L) &gt;&gt; 1) 也等同于 L+(R-L)&#x2F;2 , 样做是利用了位运算 &gt;&gt; 的特点, 右移1位, 就等于除以2</li></ul>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;1-二分搜索的概念&quot;&gt;&lt;a href=&quot;#1-二分搜索的概念&quot; class=&quot;headerlink&quot; title=&quot;1. 二分搜索的概念&quot;&gt;&lt;/a&gt;1. 二分搜索的概念&lt;/h1&gt;&lt;ul&gt;
&lt;li&gt;&lt;p&gt;二分查找是一种在有序数组中查找某一特定元素的搜索算法。&lt;/p&gt;</summary>
      
    
    
    
    <category term="算法" scheme="https://georgechan95.github.io/categories/%E7%AE%97%E6%B3%95/"/>
    
    
    <category term="算法" scheme="https://georgechan95.github.io/tags/%E7%AE%97%E6%B3%95/"/>
    
    <category term="二分法" scheme="https://georgechan95.github.io/tags/%E4%BA%8C%E5%88%86%E6%B3%95/"/>
    
  </entry>
  
  <entry>
    <title>二进制和位运算</title>
    <link href="https://georgechan95.github.io/2024/06/20/algorithm/%E4%BA%8C%E8%BF%9B%E5%88%B6%E5%92%8C%E4%BD%8D%E8%BF%90%E7%AE%97/"/>
    <id>https://georgechan95.github.io/2024/06/20/algorithm/%E4%BA%8C%E8%BF%9B%E5%88%B6%E5%92%8C%E4%BD%8D%E8%BF%90%E7%AE%97/</id>
    <published>2024-06-20T00:04:00.000Z</published>
    <updated>2024-06-29T01:23:57.157Z</updated>
    
    <content type="html"><![CDATA[<h1 id="一、二进制基础"><a href="#一、二进制基础" class="headerlink" title="一、二进制基础"></a>一、二进制基础</h1><h2 id="1、二进制与十进制的转换"><a href="#1、二进制与十进制的转换" class="headerlink" title="1、二进制与十进制的转换"></a>1、二进制与十进制的转换</h2><ul><li><p>举例：<code>0101</code> –&gt; <code>5</code></p><p>二进制[0101] 表示:  0 * 2<sup>3</sup> + 1 * 2<sup>2</sup> + 0 * 2<sup>1</sup> + 1 * 2<sup>0</sup> &#x3D; 5</p></li></ul><p>计算结果正好等于十进制数：5</p><p>上面的计算使用的是4位二进制数来表示的，<strong>4位二进制数可表示的10进制数有 2<sup>4</sup> &#x3D; 16 个，表示十进制数的范围是 0 ~ 2<sup>4</sup> -1 ，即：0 ~ 15 。</strong></p><h2 id="2、有符号数与无符号数"><a href="#2、有符号数与无符号数" class="headerlink" title="2、有符号数与无符号数"></a>2、有符号数与无符号数</h2><ul><li><p>无符号数</p><p>一个二进制数上的所有 0 和 1 都表示数字。</p></li><li><p>有符号数</p><p>二进制数上最左边的数字表示：<strong>符号位</strong></p><ul><li>0：表示该二进制为正数</li><li>1：表示该二进制为负数</li></ul></li></ul><p><strong>举例说明：</strong></p><p>比如一个4位长度的二进制数，它能表示的十进制数依然有 2<sup>4</sup> &#x3D; 16 个，表示的正数只有 2<sup>3</sup> 个，负数也是 2<sup>3</sup>,即：</p><ul><li><p>正数：0000 ~ 0111 </p><p>十进制表示：0 ~ 7</p></li><li><p>负数：1111 ~ 1000 【计算机中负数的表示，与正数不同】</p><p>十进制表示：-1 ~ -8</p></li></ul><h2 id="3、源码、反码与补码"><a href="#3、源码、反码与补码" class="headerlink" title="3、源码、反码与补码"></a>3、源码、反码与补码</h2><ul><li><p>应用范围：源码、补码、反码只能应用在整数中：正整数、负整数</p></li><li><p>在正整数中：源码 &#x3D;反码 &#x3D;补码</p></li><li><p>在负整数中：如果是负数，将源码的符号位不变，其余各位取反，得到反码。</p><ul><li>如果是负数，将反码加1，得到补码</li></ul></li><li><p>举例：int a &#x3D; 3 ;</p></li></ul><pre><code class="highlight java"><span class="type">int</span> <span class="variable">a</span> <span class="operator">=</span> <span class="number">3</span> ; <span class="comment">// int整型为4字节，32个bit位</span><span class="comment">//源码：00000000 00000000 00000000 00000011</span><span class="comment">//反码：00000000 00000000 00000000 00000011</span><span class="comment">//补码：00000000 00000000 00000000 00000011</span><span class="comment">//因为是正整数所以 源码=反码=补码</span></code></pre><ul><li>举例：int a &#x3D; -3 ;</li></ul><pre><code class="highlight java"><span class="type">int</span> <span class="variable">a</span> <span class="operator">=</span> -<span class="number">3</span> ; <span class="comment">// int 为整型4个字节32个bit位</span><span class="comment">//因为是负数，所以最高位是 1</span><span class="comment">//源码：10000000 00000000 00000000 00000011</span><span class="comment">//源码符号位不变，其余各个位按位取反，得到反码</span><span class="comment">//反码：11111111 11111111 11111111 11111100</span><span class="comment">//反码+1，得到补码</span><span class="comment">//补码：11111111 11111111 11111111 11111101</span></code></pre><ul><li>工具：<a href="https://www.lddgo.net/convert/number-binary-code">在线转换：源码、反码、补码</a></li></ul><h2 id="4、十进制负数如何转换成二进制数"><a href="#4、十进制负数如何转换成二进制数" class="headerlink" title="4、十进制负数如何转换成二进制数"></a>4、十进制负数如何转换成二进制数</h2><p>十进制负数转成二进制数的转换逻辑大致是，先将负数取正，转成二进制数，再减1，然后取反。下面举例说明转换过程：</p><ul><li><em>示例1，十进制数：<code>-1</code></em><ul><li>先将 <code>-1</code> 转成 正数 <code>1</code>，并得到正数 <code>1</code> 的二进制数 <code>0001</code> </li><li>再将二进制数 <code>0001</code> 减去 <code>1</code> ，得到二进制数 <code>0000</code></li><li>然后将二进制数 <code>0000</code> 取反，得到 二进制数 <code>1111</code></li><li>此时就得到了 -1 的 二进制表示：<code>1111</code></li></ul></li><li><em>示例2，十进制数：<code>-7</code></em><ul><li>先将 <code>-7</code> 转成 正数 <code>7</code>，并得到正数 <code>7</code> 的二进制数 <code>0111</code> </li><li>再将二进制数 <code>0111</code> 减去 <code>1</code> ，得到二进制数 <code>0110</code></li><li>然后将二进制数 <code>0110</code> 取反，得到 二进制数 <code>1001</code></li><li>此时就得到了 -7 的 二进制表示：<code>1001</code></li></ul></li><li><em>示例3，十进制数：<code>-8</code></em><ul><li>先将 <code>-8</code> 转成 正数 <code>8</code>，并得到正数 <code>8</code> 的二进制数 <code>1000</code> </li><li>再将二进制数 <code>1000</code> 减去 <code>1</code> ，得到二进制数 <code>0111</code></li><li>然后将二进制数 <code>0111</code> 取反，得到 二进制数 <code>1000</code></li><li>此时就得到了 -8 的 二进制表示：<code>1000</code></li></ul></li></ul><p><strong>注意：上面的方法得到的都是对应负数的二进制补码。</strong></p><h2 id="5、负数二进制数如何转成十进制数"><a href="#5、负数二进制数如何转成十进制数" class="headerlink" title="5、负数二进制数如何转成十进制数"></a>5、负数二进制数如何转成十进制数</h2><p>根据有符号数的定义：如果一个二进制数表示一个负数，那么在这个二进制数中，最左侧的数一定是1。确定符号位是否为负数，是后面进行转换的前提。</p><p>负数二进制数转十进制数 与 负数十进制数转二进制的过程正好相反，转换逻辑大致是，先将负数二进制数整体取反，然后再加1，得到十进制数的二进制表示，转成十进制数，再将10进制数取反，得到负的十进制数。</p><ul><li>示例1，二进制数：<code>1001</code><ul><li>首位是1，表示它是一个负数</li><li>先将二进制数 <code>1001</code> 整体取反得到 <code>0110</code></li><li>再将取反后的二进制数 <code>0110</code> + 1 得到二进制数 <code>0111</code> </li><li><code>0111</code> 表示十进制数 <code>7</code></li><li>再将十进制数 <code>7</code> 取反，得到负数 <code>-7</code></li><li>所以二进制数 <code>1001</code> 对应的十进制数为 <code>-7</code></li></ul></li><li>示例2，二进制数：<code>1000</code><ul><li>首位是1，表示它是一个负数</li><li>先将二进制数 <code>1000</code> 整体取反得到 <code>0111</code></li><li>再将取反后的二进制数 <code>0111</code> + 1 得到二进制数 <code>1000</code> </li><li><code>1000</code> 表示十进制数 <code>8</code></li><li>再将十进制数 <code>8</code> 取反，得到负数 <code>-8</code></li><li>所以二进制数 <code>1000</code> 对应的十进制数为 <code>-8</code></li></ul></li></ul><p><strong><code>1000</code> 在无符号二进制数中表示 <code>8</code>，在有符号二进制数中表示 <code>-8</code> 。</strong></p><p><strong>上面的方法，都是使用负数的补码进行运算的，<code>1001</code>、<code>1000</code> 都是补码</strong></p><h2 id="6、Java如何定义一个二进制数"><a href="#6、Java如何定义一个二进制数" class="headerlink" title="6、Java如何定义一个二进制数"></a>6、Java如何定义一个二进制数</h2><pre><code class="highlight java"><span class="type">int</span> <span class="variable">c</span> <span class="operator">=</span> <span class="number">0b0000101110</span>; <span class="comment">// 使用 0b 开头，后面是 0和1 定义一个二进制数</span>System.out.println(c);</code></pre><p>16进制数字定义使用 <code>0x</code> 开头，例如：0x4e</p><h2 id="7、二进制数转十六进制数"><a href="#7、二进制数转十六进制数" class="headerlink" title="7、二进制数转十六进制数"></a>7、二进制数转十六进制数</h2><ul><li><p>概念：</p><ul><li>二进制是由数字0和1组成，十六进制是由：[ 0、1、2、3、4、5、6、7、8、9、a、b、c、d、e、f ]  共16个数字和字母组成，逢十六进一。</li></ul></li><li><p>二进制数与十六进制数的对照关系</p><ul><li>二进制数 –&gt; 十六进制数</li></ul><table><thead><tr><th>二进制数</th><th>十六进制数</th></tr></thead><tbody><tr><td>0000</td><td>0</td></tr><tr><td>0001</td><td>1</td></tr><tr><td>0010</td><td>2</td></tr><tr><td>0011</td><td>3</td></tr><tr><td>0100</td><td>4</td></tr><tr><td>0101</td><td>5</td></tr><tr><td>0110</td><td>6</td></tr><tr><td>0111</td><td>7</td></tr><tr><td>1000</td><td>8</td></tr><tr><td>1001</td><td>9</td></tr><tr><td>1010</td><td>a</td></tr><tr><td>1011</td><td>b</td></tr><tr><td>1100</td><td>c</td></tr><tr><td>1101</td><td>d</td></tr><tr><td>1110</td><td>e</td></tr><tr><td>1111</td><td>f</td></tr></tbody></table></li></ul><p>由上表可以进下面具体的进制转换了，举例说明。</p><ul><li>二进制数：<code>0b01100111</code><ul><li><code>0b</code> 表示这是一个二进制数</li><li>前四位 <code>0110</code> 对应十六进制数 <code>6</code></li><li>后四位 <code>0111</code> 对应十六进制数 <code>7</code></li><li>所以这个二进制数对应十六进制数为 <code>0x67</code>， <code>0x</code> 表示这是一个十六进制数</li></ul></li><li>二进制数：<code>0b01101111</code><ul><li><code>0b</code> 表示这是一个二进制数</li><li>前四位 <code>0110</code> 对应十六进制数 <code>6</code></li><li>后四位 <code>1111</code> 对应十六进制数 <code>f</code></li><li>所以这个二进制数对应十六进制数为 <code>0x6f </code> , <code>0x</code> 表示这是一个十六进制数</li></ul></li></ul><h1 id="二、位运算基础"><a href="#二、位运算基础" class="headerlink" title="二、位运算基础"></a>二、位运算基础</h1><h2 id="1、相反数"><a href="#1、相反数" class="headerlink" title="1、相反数"></a>1、相反数</h2><ul><li>概念：相反数是一个数学术语，指绝对值相等，正负号相反的两个数互为相反数。</li><li>举例：1 的相反数是 -1，78 的相反数是 -78</li></ul><h3 id="1-1、如何得到一个数的相反数？"><a href="#1-1、如何得到一个数的相反数？" class="headerlink" title="1.1、如何得到一个数的相反数？"></a>1.1、如何得到一个数的相反数？</h3><p>答案：需要对一个数进行 <strong>取反 ，再加1</strong> 即可得到一个数的相反数。</p><pre><code class="highlight java"><span class="comment">// ~、相反数</span>System.out.println(a); <span class="comment">// 打印结果：78</span>printBinary(a); <span class="comment">// 打印结果：00000000000000000000000001001110</span>printBinary(~a); <span class="comment">// 打印结果：11111111111111111111111110110001</span><span class="type">int</span> <span class="variable">e</span> <span class="operator">=</span> ~a + <span class="number">1</span>;System.out.println(e); <span class="comment">// 打印结果：-78</span>printBinary(e); <span class="comment">// 打印结果：11111111111111111111111110110010</span>System.out.println(<span class="string">&quot;===e===&quot;</span>);</code></pre><p><strong>注意：int、long的最小值，取相反数、绝对值，都是自己</strong></p><h2 id="2、常见的位运算-、-、-、-、、"><a href="#2、常见的位运算-、-、-、-、、" class="headerlink" title="2、常见的位运算(|、&amp;、^、~、&lt;&lt;、&gt;&gt;、&gt;&gt;&gt;)"></a>2、常见的位运算(|、&amp;、^、~、&lt;&lt;、&gt;&gt;、&gt;&gt;&gt;)</h2><h3 id="2-1、按位或运算符-I"><a href="#2-1、按位或运算符-I" class="headerlink" title="2.1、按位或运算符(I)"></a>2.1、按位或运算符(I)</h3><ul><li><p>参加运算的两个对象，按二进制位进行“或”运算。</p></li><li><p>运算规则:0|0&#x3D;0；0|1&#x3D;1；1|0&#x3D;1；1|1&#x3D;1。</p><ul><li>即:参加运算的两个对象只要有一个为1，其值为1.</li><li>例如:3|5 即 0000 0011 | 0000 0101&#x3D;0000 0111 因此，3|5的值得7.</li></ul><p><strong>负数按补码形式参加按位或运算。</strong></p></li></ul><h3 id="2-2、按位与运算符"><a href="#2-2、按位与运算符" class="headerlink" title="2.2、按位与运算符(&amp;)"></a>2.2、按位与运算符(&amp;)</h3><ul><li><p>参加运算的两个数据，按二进制位进行“与”运算。</p></li><li><p>运算规则:0&amp;0&#x3D;0;0&amp;1&#x3D;0;1&amp;0&#x3D;0;1&amp;1&#x3D;1;</p><ul><li>即:两位同时为“1”，结果才为“1”，否则为0</li><li>例如:3&amp;5 即 0000 0011 &amp; 0000 0101 &#x3D; 0000 0001 因此，3&amp;5的值得1.</li></ul><p><strong>负数按补码形式参加按位与运算。</strong></p></li></ul><h3 id="2-3、按位异或运算符"><a href="#2-3、按位异或运算符" class="headerlink" title="2.3、按位异或运算符(^)"></a>2.3、按位异或运算符(^)</h3><ul><li>参加运算的两个数据，按二进制位进行“异或”运算</li><li>运算规则:0^0&#x3D;0; 0^1&#x3D;1; 1^0&#x3D;1; 1^1&#x3D;0;<ul><li>即:参加运算的两个对象，如果两个相应位为“异”(值不同)，则该位结果为1，否则为0.</li><li>例如:3&amp;5 即 0000 0011 ^ 0000 0101 &#x3D; 0000 0110 因此，3^5的值得6.</li></ul></li><li>任何数与0异或都等于自身</li><li>任何数与自己异或都为0</li></ul><p><strong>负数按补码形式参加按位与运算。</strong></p><h3 id="2-4、按位取反"><a href="#2-4、按位取反" class="headerlink" title="2.4、按位取反(~)"></a>2.4、按位取反(~)</h3><ul><li>运算规则：按照二进制位是0则变为1，是1则变成0<ul><li>即：~1 &#x3D; 0     ~0 &#x3D; 1</li><li>符号位也取反</li></ul></li><li>举例<ul><li>78 的二进制表示：00000000000000000000000001001110</li><li>取反后二进制表示：11111111111111111111111110110001</li></ul></li></ul><h3 id="2-5、左移"><a href="#2-5、左移" class="headerlink" title="2.5、左移(&lt;&lt;)"></a>2.5、左移(&lt;&lt;)</h3><ul><li>左移表示的是某数的各二进位全部左移若干位，高位丢弃，低位补0</li></ul><pre><code class="highlight java"><span class="comment">// 举例:</span>print(<span class="number">123</span>);<span class="comment">// 00000000000000000000000001111011</span>print(<span class="number">123</span> &lt;&lt; <span class="number">1</span>);<span class="comment">// 00000000000000000000000011110110</span><span class="comment">// 整体左移1位，高位丢弃，低位补0</span></code></pre><ul><li>应用</li></ul><pre><code class="highlight java"><span class="comment">// 左移1位相当于在原数的基础上乘以2</span>System.out.println(<span class="number">123</span>);<span class="comment">// 123</span>System.out.println(<span class="number">123</span>&lt;&lt;<span class="number">1</span>);<span class="comment">// 246</span><span class="comment">// 左移2位相当于在原数的基础上乘以4</span>System.out.println(<span class="number">2</span>);<span class="comment">// 2</span>System.out.println(<span class="number">2</span>&lt;&lt;<span class="number">2</span>);<span class="comment">// 8</span><span class="comment">// 左移3位、4位...以此类推</span></code></pre><h3 id="2-6、带符号右移"><a href="#2-6、带符号右移" class="headerlink" title="2.6、带符号右移(&gt;&gt;)"></a>2.6、带符号右移(&gt;&gt;)</h3><ul><li><strong>带符号右移（&gt;&gt;）</strong>指的是各二进位全部右移若干位，低位丢弃，高位补为符号位</li></ul><pre><code class="highlight java"><span class="comment">// 举例</span>printBinary(<span class="number">8</span>); <span class="comment">// 00000000000000000000000000001000</span>System.out.println(<span class="number">8</span>&gt;&gt;<span class="number">1</span>); <span class="comment">// 4</span>printBinary(<span class="number">8</span>&gt;&gt;<span class="number">1</span>); <span class="comment">// 00000000000000000000000000000100</span></code></pre><ul><li>应用</li></ul><pre><code class="highlight java">System.out.println(<span class="number">8</span>);<span class="comment">// 8</span>System.out.println(<span class="number">8</span>&gt;&gt;<span class="number">1</span>);<span class="comment">// 4</span><span class="comment">// 无符号右移2位相当于在原数的基础上除以4</span>System.out.println(<span class="number">8</span>);<span class="comment">// 8</span>System.out.println(<span class="number">8</span>&gt;&gt;<span class="number">2</span>);<span class="comment">// 2</span><span class="comment">// 负数右移规则也适用</span>System.out.println(-<span class="number">8</span>&gt;&gt;<span class="number">1</span>); <span class="comment">// -4</span><span class="comment">// 右移3位、4位...以此类推</span></code></pre><h3 id="2-7、无符号右移"><a href="#2-7、无符号右移" class="headerlink" title="2.7、无符号右移(&gt;&gt;&gt;)"></a>2.7、无符号右移(&gt;&gt;&gt;)</h3><ul><li><strong>无符号右移（&gt;&gt;&gt;）</strong>指的是各二进位全部右移若干位，低位丢弃，高位补0</li><li>如果是<strong>负数进行无符号右移，需要使用负数的二进制补码</strong>进行运算。</li><li>如果是正数进行无符号右移，则与 &gt;&gt; 规则相同，右移n位，就相当于除以 2<sup>n</sup></li></ul><pre><code class="highlight java"><span class="comment">// 正数无符号右移</span>System.out.println(<span class="number">8</span>&gt;&gt;&gt;<span class="number">1</span>);printBinary(<span class="number">8</span>);printBinary(<span class="number">8</span>&gt;&gt;&gt;<span class="number">1</span>);<span class="comment">// 负数无符号右移</span>System.out.println(-<span class="number">8</span>&gt;&gt;&gt;<span class="number">1</span>); <span class="comment">// 2147483644</span>printBinary(-<span class="number">8</span>); <span class="comment">// 二进制补码：11111111111111111111111111111000</span>printBinary(-<span class="number">8</span>&gt;&gt;&gt;<span class="number">1</span>); <span class="comment">// 01111111111111111111111111111100</span>System.out.println(<span class="string">&quot;=== &gt;&gt;&gt;无符号右移 ===&quot;</span>);</code></pre><h1 id="三、二进制如此设计的原因"><a href="#三、二进制如此设计的原因" class="headerlink" title="三、二进制如此设计的原因"></a>三、二进制如此设计的原因</h1><p>这么设计二进制是为了保证加法的逻辑是一套逻辑，没有条件转移。</p><p>也就是说无论是 正数+正数、正数+负数、负数加负数 都是遵循同一套逻辑，可以提高计算机的运行效率。</p><h1 id="四、解析二进制打印函数"><a href="#四、解析二进制打印函数" class="headerlink" title="四、解析二进制打印函数"></a>四、解析二进制打印函数</h1><h2 id="1、二进制打印函数如下"><a href="#1、二进制打印函数如下" class="headerlink" title="1、二进制打印函数如下"></a>1、二进制打印函数如下</h2><pre><code class="highlight java"><span class="comment">/**</span><span class="comment">  * 打印一个int类型的数字，32位进制的状态</span><span class="comment">  * 左侧是高位，右侧是低位</span><span class="comment">  * 这里打印的是num的二进制补码。</span><span class="comment">  * <span class="doctag">@param</span> num 十进制数值</span><span class="comment">  */</span><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">printBinary</span><span class="params">(<span class="type">int</span> num)</span> &#123;    <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">31</span>; i &gt;= <span class="number">0</span>; i--) &#123;        <span class="comment">// 下面这句写法，可以改成 :</span>        <span class="comment">// System.out.print((a &amp; (1 &lt;&lt; i)) != 0 ? &quot;1&quot; : &quot;0&quot;);</span>        <span class="comment">// 但不可以改成 :</span>        <span class="comment">// System.out.print((a &amp; (1 &lt;&lt; i)) == 1 ? &quot;1&quot; : &quot;0&quot;);</span>        <span class="comment">// 因为a如果第i位有1，那么(a &amp; (1 &lt;&lt; i))是2的i次方，而不一定是1</span>        <span class="comment">// 比如，a = 0010011</span>        <span class="comment">// a的第0位是1，第1位是1，第4位是1</span>        <span class="comment">// (a &amp; (1&lt;&lt;4)) == 16（不是1），说明a的第4位是1状态</span>        System.out.print((num &amp; (<span class="number">1</span> &lt;&lt; i)) == <span class="number">0</span> ? <span class="string">&quot;0&quot;</span> : <span class="string">&quot;1&quot;</span>);    &#125;    System.out.println();&#125;</code></pre><h2 id="2、解析"><a href="#2、解析" class="headerlink" title="2、解析"></a>2、解析</h2><ul><li>一个int类型的数在java中有32位，如果需要打印它的二进制表示，就需要知道它在二进制数中，每一位是0还是1。</li><li>根据位运算符 按位&amp; 的特点，相同位都为1，按位&amp;计算为1，否则为0的特点来实现这一需求。</li><li><code>1 &lt;&lt; i</code> 表示打印第 i 位上的二进制数<ul><li>例如：num等于8，那么它的二进制表示为：00000000000000000000000000001000</li><li>i 从高位(31) 到低位(0) 依次打印。</li><li>i 等于31时，1 &lt;&lt; 31 的值表示的二进制为：10000000000000000000000000000000</li><li>此时 <code>num &amp; (1 &lt;&lt; i)</code> 的值就是0，所以 num 的二进制值，在第31位上为0。</li><li>i 递减，依次往后打印出 num 每一位二进制数。</li></ul></li><li>如果num是一个负数，这个函数打印的就是负数二进制数的表示的补码。<ul><li>例如：num等于 -8 ，此函数打印出它的二进制补码为：11111111111111111111111111111000</li></ul></li></ul><p><strong>正数的二进制 原码、反码、补码是相同的。</strong></p>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;一、二进制基础&quot;&gt;&lt;a href=&quot;#一、二进制基础&quot; class=&quot;headerlink&quot; title=&quot;一、二进制基础&quot;&gt;&lt;/a&gt;一、二进制基础&lt;/h1&gt;&lt;h2 id=&quot;1、二进制与十进制的转换&quot;&gt;&lt;a href=&quot;#1、二进制与十进制的转换&quot; class=&quot;</summary>
      
    
    
    
    <category term="算法" scheme="https://georgechan95.github.io/categories/%E7%AE%97%E6%B3%95/"/>
    
    
    <category term="算法" scheme="https://georgechan95.github.io/tags/%E7%AE%97%E6%B3%95/"/>
    
    <category term="二进制" scheme="https://georgechan95.github.io/tags/%E4%BA%8C%E8%BF%9B%E5%88%B6/"/>
    
    <category term="位运算" scheme="https://georgechan95.github.io/tags/%E4%BD%8D%E8%BF%90%E7%AE%97/"/>
    
  </entry>
  
  <entry>
    <title>第十三章-垃圾回收相关概念</title>
    <link href="https://georgechan95.github.io/2024/01/14/jvm/%E7%AC%AC%E5%8D%81%E4%B8%89%E7%AB%A0-%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6%E7%9B%B8%E5%85%B3%E6%A6%82%E5%BF%B5/"/>
    <id>https://georgechan95.github.io/2024/01/14/jvm/%E7%AC%AC%E5%8D%81%E4%B8%89%E7%AB%A0-%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6%E7%9B%B8%E5%85%B3%E6%A6%82%E5%BF%B5/</id>
    <published>2024-01-14T06:27:00.000Z</published>
    <updated>2024-06-22T10:36:12.823Z</updated>
    
    <content type="html"><![CDATA[<h1 id="一、System-gc-的理解"><a href="#一、System-gc-的理解" class="headerlink" title="一、System.gc() 的理解"></a>一、System.gc() 的理解</h1><ul><li>在默认情况下，通过System.gc()者Runtime.getRuntime().gc() 的调用，<strong>会显式触发Full GC</strong>，同时对老年代和新生代进行回收，尝试释放被丢弃对象占用的内存。</li><li>然而System.gc()调用附带一个免责声明，无法保证对垃圾收集器的调用(不能确保立即生效)</li><li>JVM实现者可以通过System.gc() 调用来决定JVM的GC行为。而一般情况下，垃圾回收应该是自动进行的，<strong>无须手动触发，否则就太过于麻烦了。</strong>在一些特殊情况下，如我们正在编写一个性能基准，我们可以在运行之间调用System.gc()</li></ul><pre><code class="highlight java"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">SystemGCTest</span> &#123;    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;        <span class="keyword">new</span> <span class="title class_">SystemGCTest</span>();        System.gc();<span class="comment">//提醒jvm的垃圾回收器执行gc,但是不确定是否马上执行gc</span>        <span class="comment">//与Runtime.getRuntime().gc();的作用一样。</span><span class="comment">//        System.runFinalization();//强制调用使用引用的对象的finalize()方法</span>    &#125;    <span class="meta">@Override</span>    <span class="keyword">protected</span> <span class="keyword">void</span> <span class="title function_">finalize</span><span class="params">()</span> <span class="keyword">throws</span> Throwable &#123;        <span class="built_in">super</span>.finalize();        System.out.println(<span class="string">&quot;SystemGCTest 重写了finalize()&quot;</span>);    &#125;&#125;</code></pre><p>输出结果不确定：有时候会调用 finalize() 方法，有时候并不会调用</p><pre><code class="highlight plaintext">SystemGCTest 重写了finalize()或空</code></pre><h2 id="1-手动-GC-理解不可达对象的回收行为"><a href="#1-手动-GC-理解不可达对象的回收行为" class="headerlink" title="1. 手动 GC 理解不可达对象的回收行为"></a>1. 手动 GC 理解不可达对象的回收行为</h2><blockquote><p>示例代码：</p></blockquote><pre><code class="highlight java"><span class="comment">/**</span><span class="comment"> * -Xms256m -Xmx256m -XX:+PrintGCDetails -XX:PretenureSizeThreshold=15m</span><span class="comment"> *</span><span class="comment"> * 参数解析：</span><span class="comment"> *      -XX:PretenureSizeThreshold=15m  超过15M的大对象直接进入老年代</span><span class="comment"> */</span><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">LocalVarGC</span> &#123;    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">localvarGC1</span><span class="params">()</span> &#123;        <span class="type">byte</span>[] buffer = <span class="keyword">new</span> <span class="title class_">byte</span>[<span class="number">10</span> * <span class="number">1024</span> * <span class="number">1024</span>];<span class="comment">//10MB</span>        System.gc();    &#125;    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">localvarGC2</span><span class="params">()</span> &#123;        <span class="type">byte</span>[] buffer = <span class="keyword">new</span> <span class="title class_">byte</span>[<span class="number">10</span> * <span class="number">1024</span> * <span class="number">1024</span>];        buffer = <span class="literal">null</span>;        System.gc();    &#125;    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">localvarGC3</span><span class="params">()</span> &#123;        &#123;            <span class="type">byte</span>[] buffer = <span class="keyword">new</span> <span class="title class_">byte</span>[<span class="number">10</span> * <span class="number">1024</span> * <span class="number">1024</span>];        &#125;        System.gc();    &#125;    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">localvarGC4</span><span class="params">()</span> &#123;        &#123;            <span class="type">byte</span>[] buffer = <span class="keyword">new</span> <span class="title class_">byte</span>[<span class="number">10</span> * <span class="number">1024</span> * <span class="number">1024</span>];        &#125;        <span class="type">int</span> <span class="variable">value</span> <span class="operator">=</span> <span class="number">10</span>;        System.gc();    &#125;    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">localvarGC5</span><span class="params">()</span> &#123;        localvarGC1();        System.gc();    &#125;    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;        <span class="type">LocalVarGC</span> <span class="variable">local</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">LocalVarGC</span>();        local.localvarGC1();<span class="comment">//        local.localvarGC2();</span><span class="comment">//        local.localvarGC3();</span><span class="comment">//        local.localvarGC4();</span><span class="comment">//        local.localvarGC5();</span>    &#125;&#125;</code></pre><p><strong>1、调用 localvarGC1() 方法</strong></p><p>执行 System.gc() 仅仅是将年轻代的 buffer 数组对象放到了老年代，buffer对象仍然没有回收</p><blockquote><p>打印日志如下：</p></blockquote><pre><code class="highlight plaintext">[GC (System.gc()) [PSYoungGen: 15483K-&gt;10744K(76288K)] 15483K-&gt;10928K(251392K), 0.0043067 secs] [Times: user=0.00 sys=0.00, real=0.00 secs] [Full GC (System.gc()) [PSYoungGen: 10744K-&gt;0K(76288K)] [ParOldGen: 184K-&gt;10863K(175104K)] 10928K-&gt;10863K(251392K), [Metaspace: 3228K-&gt;3228K(1056768K)], 0.0051795 secs] [Times: user=0.05 sys=0.00, real=0.01 secs] Heap PSYoungGen      total 76288K, used 655K [0x00000000fab00000, 0x0000000100000000, 0x0000000100000000)  eden space 65536K, 1% used [0x00000000fab00000,0x00000000faba3ee8,0x00000000feb00000)  from space 10752K, 0% used [0x00000000feb00000,0x00000000feb00000,0x00000000ff580000)  to   space 10752K, 0% used [0x00000000ff580000,0x00000000ff580000,0x0000000100000000) ParOldGen       total 175104K, used 10863K [0x00000000f0000000, 0x00000000fab00000, 0x00000000fab00000)  object space 175104K, 6% used [0x00000000f0000000,0x00000000f0a9be78,0x00000000fab00000) Metaspace       used 3235K, capacity 4496K, committed 4864K, reserved 1056768K  class space    used 350K, capacity 388K, committed 512K, reserved 1048576K</code></pre><p><strong>2、调用 localvarGC2() 方法</strong></p><p>由于 buffer 数组对象没有引用指向它，执行 System.gc() 将被回收</p><blockquote><p>打印日志如下：</p></blockquote><pre><code class="highlight plaintext">[GC (System.gc()) [PSYoungGen: 15483K-&gt;680K(76288K)] 15483K-&gt;688K(251392K), 0.0006552 secs] [Times: user=0.00 sys=0.00, real=0.00 secs] [Full GC (System.gc()) [PSYoungGen: 680K-&gt;0K(76288K)] [ParOldGen: 8K-&gt;598K(175104K)] 688K-&gt;598K(251392K), [Metaspace: 3202K-&gt;3202K(1056768K)], 0.0035341 secs] [Times: user=0.00 sys=0.00, real=0.00 secs] Heap PSYoungGen      total 76288K, used 1966K [0x00000000fab00000, 0x0000000100000000, 0x0000000100000000)  eden space 65536K, 3% used [0x00000000fab00000,0x00000000faceb9e0,0x00000000feb00000)  from space 10752K, 0% used [0x00000000feb00000,0x00000000feb00000,0x00000000ff580000)  to   space 10752K, 0% used [0x00000000ff580000,0x00000000ff580000,0x0000000100000000) ParOldGen       total 175104K, used 598K [0x00000000f0000000, 0x00000000fab00000, 0x00000000fab00000)  object space 175104K, 0% used [0x00000000f0000000,0x00000000f00959b8,0x00000000fab00000) Metaspace       used 3219K, capacity 4496K, committed 4864K, reserved 1056768K  class space    used 348K, capacity 388K, committed 512K, reserved 1048576K</code></pre><p><strong>3、调用 localvarGC3() 方法</strong></p><p>虽然出了代码块的作用域，但是 buffer 数组对象并没有被回收</p><blockquote><p>打印日志如下：</p></blockquote><pre><code class="highlight plaintext">[GC (System.gc()) [PSYoungGen: 15483K-&gt;744K(76288K)] 15483K-&gt;10992K(251392K), 0.0044234 secs] [Times: user=0.02 sys=0.02, real=0.02 secs] [Full GC (System.gc()) [PSYoungGen: 744K-&gt;0K(76288K)] [ParOldGen: 10248K-&gt;10863K(175104K)] 10992K-&gt;10863K(251392K), [Metaspace: 3227K-&gt;3227K(1056768K)], 0.0049354 secs] [Times: user=0.00 sys=0.00, real=0.00 secs] Heap PSYoungGen      total 76288K, used 655K [0x00000000fab00000, 0x0000000100000000, 0x0000000100000000)  eden space 65536K, 1% used [0x00000000fab00000,0x00000000faba3ee8,0x00000000feb00000)  from space 10752K, 0% used [0x00000000feb00000,0x00000000feb00000,0x00000000ff580000)  to   space 10752K, 0% used [0x00000000ff580000,0x00000000ff580000,0x0000000100000000) ParOldGen       total 175104K, used 10863K [0x00000000f0000000, 0x00000000fab00000, 0x00000000fab00000)  object space 175104K, 6% used [0x00000000f0000000,0x00000000f0a9be78,0x00000000fab00000) Metaspace       used 3234K, capacity 4496K, committed 4864K, reserved 1056768K  class space    used 350K, capacity 388K, committed 512K, reserved 1048576K</code></pre><p><strong>原因：</strong> 变量 buffer在局部变量表中索引占用的位置，没有被其它变量占用过，即便是出了局部方法所在区域，buffer变量依然存在。</p><p>1、来看看字节码：局部变量表中索引0所在位置是：this</p><p><img src="https://raw.githubusercontent.com/GeorgeChan95/blogimg/master/img/2024/01/14/20240114-150438.png" alt="image-20240114150434293"></p><p>2、查看局部变量表最大长度是：2，但是局部变量表里只有一个索引为0的变量this，这是由于索引为1的位置是buffer在占用着，执行 System.gc() 时，栈中还有 buffer 变量指向堆中的字节数组，所以没有进行GC。</p><p>那么这种情况下该如何将buffer变量指向的内存回收掉呢？</p><p><img src="https://raw.githubusercontent.com/GeorgeChan95/blogimg/master/img/2024/01/14/20240114-150544.png" alt="image-20240114150543247"></p><p><strong>4、调用 localvarGC4() 方法</strong></p><blockquote><p>打印日志如下：</p></blockquote><pre><code class="highlight plaintext">[GC (System.gc()) [PSYoungGen: 15483K-&gt;744K(76288K)] 15483K-&gt;752K(251392K), 0.0008784 secs] [Times: user=0.00 sys=0.00, real=0.00 secs] [Full GC (System.gc()) [PSYoungGen: 744K-&gt;0K(76288K)] [ParOldGen: 8K-&gt;623K(175104K)] 752K-&gt;623K(251392K), [Metaspace: 3228K-&gt;3228K(1056768K)], 0.0034782 secs] [Times: user=0.02 sys=0.03, real=0.01 secs] Heap PSYoungGen      total 76288K, used 655K [0x00000000fab00000, 0x0000000100000000, 0x0000000100000000)  eden space 65536K, 1% used [0x00000000fab00000,0x00000000faba3ee8,0x00000000feb00000)  from space 10752K, 0% used [0x00000000feb00000,0x00000000feb00000,0x00000000ff580000)  to   space 10752K, 0% used [0x00000000ff580000,0x00000000ff580000,0x0000000100000000) ParOldGen       total 175104K, used 623K [0x00000000f0000000, 0x00000000fab00000, 0x00000000fab00000)  object space 175104K, 0% used [0x00000000f0000000,0x00000000f009be68,0x00000000fab00000) Metaspace       used 3235K, capacity 4496K, committed 4864K, reserved 1056768K  class space    used 350K, capacity 388K, committed 512K, reserved 1048576K</code></pre><p>Q：就多定义了一个局部变量 value ，就可以把字节数组回收了呢？</p><p>A：局部变量表长度为 2 ，这说明了出了代码块时，buffer 就出了其作用域范围，此时没有为 value 开启新的槽，value 变量直接占据了 buffer 变量的槽（Slot），导致堆中的字节数组没有引用再指向它，执行 System.gc() 时被回收。看，value 位于局部变量表中索引为 1 的位置。value这个局部变量把原本属于buffer的slot给占用了，这样栈上就没有buffer变量指向<code>new byte[10 * 1024 * 1024]</code>实例了。</p><blockquote><p>查看字节码</p></blockquote><p><img src="https://raw.githubusercontent.com/GeorgeChan95/blogimg/master/img/2024/01/14/20240114-151050.png" alt="image-20240114151048967"></p><p><img src="https://raw.githubusercontent.com/GeorgeChan95/blogimg/master/img/2024/01/14/20240114-151114.png" alt="image-20240114151112547"></p><p><strong>5、调用 localvarGC5() 方法</strong></p><p>局部变量出了方法所在范围就失效了，堆中的字节数组被回收。</p><blockquote><p>打印日志如下：</p></blockquote><pre><code class="highlight plaintext">[GC (System.gc()) [PSYoungGen: 15483K-&gt;10744K(76288K)] 15483K-&gt;10920K(251392K), 0.0052051 secs] [Times: user=0.00 sys=0.00, real=0.00 secs] [Full GC (System.gc()) [PSYoungGen: 10744K-&gt;0K(76288K)] [ParOldGen: 176K-&gt;10863K(175104K)] 10920K-&gt;10863K(251392K), [Metaspace: 3228K-&gt;3228K(1056768K)], 0.0075048 secs] [Times: user=0.00 sys=0.00, real=0.01 secs] [GC (System.gc()) [PSYoungGen: 0K-&gt;0K(76288K)] 10863K-&gt;10863K(251392K), 0.0008154 secs] [Times: user=0.00 sys=0.00, real=0.00 secs] [Full GC (System.gc()) [PSYoungGen: 0K-&gt;0K(76288K)] [ParOldGen: 10863K-&gt;622K(175104K)] 10863K-&gt;622K(251392K), [Metaspace: 3228K-&gt;3228K(1056768K)], 0.0072950 secs] [Times: user=0.03 sys=0.00, real=0.01 secs] Heap PSYoungGen      total 76288K, used 655K [0x00000000fab00000, 0x0000000100000000, 0x0000000100000000)  eden space 65536K, 1% used [0x00000000fab00000,0x00000000faba3ee8,0x00000000feb00000)  from space 10752K, 0% used [0x00000000ff580000,0x00000000ff580000,0x0000000100000000)  to   space 10752K, 0% used [0x00000000feb00000,0x00000000feb00000,0x00000000ff580000) ParOldGen       total 175104K, used 622K [0x00000000f0000000, 0x00000000fab00000, 0x00000000fab00000)  object space 175104K, 0% used [0x00000000f0000000,0x00000000f009bbe0,0x00000000fab00000) Metaspace       used 3234K, capacity 4496K, committed 4864K, reserved 1056768K  class space    used 350K, capacity 388K, committed 512K, reserved 1048576K</code></pre><h1 id="二、内存溢出与内存泄漏"><a href="#二、内存溢出与内存泄漏" class="headerlink" title="二、内存溢出与内存泄漏"></a>二、内存溢出与内存泄漏</h1><h2 id="1-内存溢出概述"><a href="#1-内存溢出概述" class="headerlink" title="1. 内存溢出概述"></a>1. 内存溢出概述</h2><ul><li>内存溢出相对于内存泄漏来说，尽管更容易被理解，但是同样的，内存溢出也是引发程序崩溃的罪魁祸首之一。</li><li>由于GC一直在发展，所有一般情况下，除非应用程序占用的内存增长速度非常快，造成垃圾回收已经跟不上内存消耗的速度，否则不太容易出现OOM的情况。</li><li>大多数情况下，GC会进行各种年龄段的垃圾回收，实在不行了就放大招，来一次独占式的Full GC操作，这时候会回收大量的内存，供应用程序继续使用。</li><li>Javadoc中对OutofMemoryError的解释是，没有空闲内存，并且垃圾收集器也无法提供更多内存。</li></ul><h2 id="2-内存溢出（OOM）原因分析"><a href="#2-内存溢出（OOM）原因分析" class="headerlink" title="2. 内存溢出（OOM）原因分析"></a>2. 内存溢出（OOM）原因分析</h2><p>首先说没有空闲内存的情况：说明Java虚拟机的堆内存不够。原因有二：</p><ol><li>Java虚拟机的堆内存设置不够。<ul><li>比如：可能存在内存泄漏问题；也很有可能就是堆的大小不合理，比如我们要处理比较可观的数据量，但是没有显式指定JVM堆大小或者指定数值偏小。我们可以通过参数-Xms 、-Xmx来调整。</li></ul></li><li>代码中创建了大量大对象，并且长时间不能被垃圾收集器收集（存在被引用）<ul><li>对于老版本的Oracle JDK，因为永久代的大小是有限的，并且JVM对永久代垃圾回收（如，常量池回收、卸载不再需要的类型）非常不积极，所以当我们不断添加新类型的时候，永久代出现OutOfMemoryError也非常多见。尤其是在运行时存在大量动态类型生成的场合；类似intern字符串缓存占用太多空间，也会导致OOM问题。对应的异常信息，会标记出来和永久代相关：“java.lang.OutOfMemoryError:PermGen space”。</li><li>随着元数据区的引入，方法区内存已经不再那么窘迫，所以相应的OOM有所改观，出现OOM，异常信息则变成了：“java.lang.OutofMemoryError:Metaspace”。直接内存不足，也会导致OOM。</li></ul></li></ol><ul><li>这里面隐含着一层意思是，在抛出OutofMemoryError之前，通常垃圾收集器会被触发，尽其所能去清理出空间。<ul><li>例如：在引用机制分析中，涉及到JVM会去尝试<strong>回收软引用指向的对象</strong>等。</li><li>在java.nio.Bits.reserveMemory()方法中，我们能清楚的看到，System.gc()会被调用，以清理空间。</li></ul></li><li>当然，也不是在任何情况下垃圾收集器都会被触发的<ul><li>比如，我们去分配一个超大对象，类似一个超大数组超过堆的最大值，JVM可以判断出垃圾收集并不能解决这个问题，所以直接抛出OutofMemoryError。</li></ul></li></ul><h2 id="3-内存泄漏概述"><a href="#3-内存泄漏概述" class="headerlink" title="3. 内存泄漏概述"></a>3. 内存泄漏概述</h2><ul><li>也称作“存储渗漏”。严格来说，<strong>只有对象不会再被程序用到了，但是GC又不能回收他们的情况，才叫内存泄漏。</strong></li><li>但实际情况很多时候一些不太好的实践（或疏忽）会导致对象的生命周期变得很长甚至导致OOM，也可以叫做宽泛意义上的“内存泄漏”。</li><li>尽管内存泄漏并不会立刻引起程序崩溃，但是一旦发生内存泄漏，程序中的可用内存就会被逐步蚕食，直至耗尽所有内存，最终出现OutofMemory异常，导致程序崩溃。</li><li>注意，这里的存储空间并不是指物理内存，而是指虚拟内存大小，这个虚拟内存大小取决于磁盘交换区设定的大小。</li></ul><h3 id="3-1-内存泄露官方例子"><a href="#3-1-内存泄露官方例子" class="headerlink" title="3.1 内存泄露官方例子"></a>3.1 内存泄露官方例子</h3><p>左边的图：Java使用可达性分析算法，最上面的数据不可达，就是需要被回收的对象。</p><p>右边的图：后期有一些对象不用了，按道理应该断开引用，但是存在一些链没有断开（图示中的Forgotten Reference Memory Leak），从而导致没有办法被回收。</p><p><img src="https://raw.githubusercontent.com/GeorgeChan95/blogimg/master/img/2024/01/14/20240114-152858.png" alt="内存泄露官方例子"></p><h3 id="3-2-内存泄漏常见例子"><a href="#3-2-内存泄漏常见例子" class="headerlink" title="3.2 内存泄漏常见例子"></a>3.2 内存泄漏常见例子</h3><ul><li>单例模式<ul><li>单例的生命周期和应用程序是一样长的，所以在单例程序中，如果持有对外部对象的引用的话，那么这个外部对象是不能被回收的，则会导致内存泄漏的产生。</li></ul></li><li>一些提供close()的资源未关闭导致内存泄漏<ul><li>数据库连接 dataSourse.getConnection()，网络连接socket和io连接必须手动close，否则是不能被回收的。</li></ul></li></ul><h1 id="三、-Stop-the-World"><a href="#三、-Stop-the-World" class="headerlink" title="三、 Stop the World"></a>三、 Stop the World</h1><h2 id="1-概念"><a href="#1-概念" class="headerlink" title="1. 概念"></a>1. 概念</h2><ul><li>Stop-the-World，简称STW，指的是GC事件发生过程中，会产生应用程序的停顿。<strong>停顿产生时整个应用程序线程都会被暂停，没有任何响应</strong>，有点像卡死的感觉，这个停顿称为STW。</li><li>可达性分析算法中枚举根节点（GC Roots）会导致所有Java执行线程停顿，为什么需要停顿所有 Java 执行线程呢？<ul><li>分析工作必须在一个能确保一致性的快照中进行</li><li>一致性指整个分析期间整个执行系统看起来像被冻结在某个时间点上</li><li><strong>如果出现分析过程中对象引用关系还在不断变化，则分析结果的准确性无法保证</strong></li></ul></li><li>被STW中断的应用程序线程会在完成GC之后恢复，频繁中断会让用户感觉像是网速不快造成电影卡带一样，所以我们需要减少STW的发生。</li></ul><p>STW事件和采用哪款GC无关，所有的GC都有这个事件。哪怕是G1也不能完全避免Stop-the-world情况发生，只能说垃圾回收器越来越优秀，回收效率越来越高，尽可能地缩短了暂停时间。</p><p>STW是JVM在后台自动发起和自动完成的。在用户不可见的情况下，把用户正常的工作线程全部停掉。</p><p>开发中不要用System.gc() ，这会导致Stop-the-World的发生。</p><h2 id="2-代码感受-Stop-the-World"><a href="#2-代码感受-Stop-the-World" class="headerlink" title="2. 代码感受 Stop the World"></a>2. 代码感受 Stop the World</h2><blockquote><p>示例代码</p></blockquote><pre><code class="highlight java"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">StopTheWorldDemo</span> &#123;    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">class</span> <span class="title class_">WorkThread</span> <span class="keyword">extends</span> <span class="title class_">Thread</span> &#123;        List&lt;<span class="type">byte</span>[]&gt; list = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;<span class="type">byte</span>[]&gt;();        <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span> &#123;            <span class="keyword">try</span> &#123;                <span class="keyword">while</span> (<span class="literal">true</span>) &#123;                    <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>;i &lt; <span class="number">1000</span>;i++)&#123;                        <span class="type">byte</span>[] buffer = <span class="keyword">new</span> <span class="title class_">byte</span>[<span class="number">1024</span>];                        list.add(buffer);                    &#125;                    <span class="keyword">if</span>(list.size() &gt; <span class="number">1000000</span>)&#123;                        list.clear();                        System.gc();<span class="comment">//会触发full gc，进而会出现STW事件</span>                    &#125;                &#125;            &#125; <span class="keyword">catch</span> (Exception ex) &#123;                ex.printStackTrace();            &#125;        &#125;    &#125;    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">class</span> <span class="title class_">PrintThread</span> <span class="keyword">extends</span> <span class="title class_">Thread</span> &#123;        <span class="keyword">public</span> <span class="keyword">final</span> <span class="type">long</span> <span class="variable">startTime</span> <span class="operator">=</span> System.currentTimeMillis();        <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span> &#123;            <span class="keyword">try</span> &#123;                <span class="keyword">while</span> (<span class="literal">true</span>) &#123;                    <span class="comment">// 每秒打印时间信息</span>                    <span class="type">long</span> <span class="variable">t</span> <span class="operator">=</span> System.currentTimeMillis() - startTime;                    System.out.println(t / <span class="number">1000</span> + <span class="string">&quot;.&quot;</span> + t % <span class="number">1000</span>);                    Thread.sleep(<span class="number">1000</span>);                &#125;            &#125; <span class="keyword">catch</span> (Exception ex) &#123;                ex.printStackTrace();            &#125;        &#125;    &#125;    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;        <span class="type">WorkThread</span> <span class="variable">w</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">WorkThread</span>();        <span class="type">PrintThread</span> <span class="variable">p</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">PrintThread</span>();        w.start();        p.start();    &#125;&#125;</code></pre><p>关闭工作线程 w ，观察输出：当前时间间隔与上次时间间隔<strong>基本</strong>是每隔1秒打印一次</p><pre><code class="highlight plaintext">0.11.142.163.184.195.226.227.298.519.5410.5611.58</code></pre><p>开启工作线程 w ，观察打印输出：当前时间间隔与上次时间间隔相差 1.5s ，可以明显感受到 Stop the World 的存在</p><pre><code class="highlight plaintext">0.21.792.813.894.3015.3026.4077.5598.7129.86911.3112.16913.31814.50715.62516.77817.91119.3620.17021.32022.47623.60924.74925.88727.528.140</code></pre><h1 id="四、垃圾回收的并行与并发"><a href="#四、垃圾回收的并行与并发" class="headerlink" title="四、垃圾回收的并行与并发"></a>四、垃圾回收的并行与并发</h1><h2 id="1-并发的概念"><a href="#1-并发的概念" class="headerlink" title="1. 并发的概念"></a>1. 并发的概念</h2><ul><li>在操作系统中，是指<strong>一个时间段</strong>中有几个程序都处于已启动运行到运行完毕之间，且这几个程序都是在同一个处理器上运行</li><li>并发不是真正意义上的“同时进行”，只是CPU把一个时间段划分成几个时间片段（时间区间），然后在这几个时间区间之间来回切换。由于CPU处理的速度非常快，只要时间间隔处理得当，即可让用户感觉是多个应用程序同时在进行</li></ul><p><img src="https://raw.githubusercontent.com/GeorgeChan95/blogimg/master/img/2024/01/14/20240114-154743.png" alt="理解并发"></p><h2 id="2-并行的概念"><a href="#2-并行的概念" class="headerlink" title="2. 并行的概念"></a>2. 并行的概念</h2><ul><li>当系统有一个以上CPU时，当一个CPU执行一个进程时，另一个CPU可以执行另一个进程，两个进程互不抢占CPU资源，可以<strong>同时</strong>进行，我们称之为并行（Parallel）</li><li>其实决定并行的因素不是CPU的数量，而是CPU的核心数量，比如一个CPU多个核也可以并行</li><li>适合科学计算，后台处理等弱交互场景</li></ul><p><img src="https://raw.githubusercontent.com/GeorgeChan95/blogimg/master/img/2024/01/14/20240114-154958.png" alt="理解并行"></p><h2 id="3-并发与并行的对比"><a href="#3-并发与并行的对比" class="headerlink" title="3. 并发与并行的对比"></a>3. 并发与并行的对比</h2><ul><li>并发，指的是多个事情，在同一时间段内同时发生了。</li><li>并行，指的是多个事情，在同一时间点上（或者说同一时刻）同时发生了。</li><li>并发的多个任务之间是互相抢占资源的。并行的多个任务之间是不互相抢占资源的。</li><li>只有在多CPU或者一个CPU多核的情况中，才会发生并行。否则，看似同时发生的事情，其实都是并发执行的。</li></ul><h2 id="4-垃圾回收的并发与并行"><a href="#4-垃圾回收的并发与并行" class="headerlink" title="4. 垃圾回收的并发与并行"></a>4. 垃圾回收的并发与并行</h2><ul><li>并行（Parallel）：指多条垃圾收集线程并行工作，但此时用户线程仍处于等待状态。<ul><li>如ParNew、Parallel Scavenge、Parallel Old</li></ul></li><li>串行（Serial）<ul><li>相较于并行的概念，单线程执行。</li><li>如果内存不够，则程序暂停，启动JVM垃圾回收器进行垃圾回收（单线程）</li></ul></li></ul><p><img src="https://raw.githubusercontent.com/GeorgeChan95/blogimg/master/img/2024/01/14/20240114-161201.png" alt="垃圾回收器的并行和串行"></p><p>并发和并行，在谈论垃圾收集器的上下文语境中，它们可以解释如下：</p><ul><li>并发（Concurrent）：指<strong>用户线程与垃圾收集线程同时执行</strong>（但不一定是并行的，可能会交替执行），垃圾回收线程在执行时不会停顿用户程序的运行。<ul><li>比如用户程序在继续运行，而垃圾收集程序线程运行于另一个CPU上；</li><li>典型垃圾回收器：CMS、G1</li></ul></li></ul><p><img src="https://raw.githubusercontent.com/GeorgeChan95/blogimg/master/img/2024/01/14/20240114-161342.png" alt="image-20240114161340589"></p><h1 id="五、HotSpot的算法实现细节"><a href="#五、HotSpot的算法实现细节" class="headerlink" title="五、HotSpot的算法实现细节"></a>五、HotSpot的算法实现细节</h1><h2 id="1-根节点枚举"><a href="#1-根节点枚举" class="headerlink" title="1. 根节点枚举"></a>1. 根节点枚举</h2><ul><li>固定可作为GC Roots的节点主要在全局性的引用（例如常量或类静态属性）与执行上下文（例如栈帧中的本地变量表）中，尽管目标明确，但查找过程要做到高效并非一件容易的事情，现在Java应用越做越庞大，光是方法区的大小就常有数百上千兆，里面的类、常量等更是恒河沙数，若要逐个检查以这里为起源的引用肯定得消耗不少时间。</li><li>迄今为止，<strong>所有收集器在根节点枚举这一步骤时都是必须暂停用户线程的</strong>，因此毫无疑问根节点 枚举与之前提及的整理内存碎片一样会面临相似的“Stop The World”的困扰。现在可达性分析算法耗时 最长的查找引用链的过程已经可以做到与用户线程一起并发，<strong>但根节点枚举始终还 是必须在一个能保障一致性的快照中才得以进行</strong>——这里“一致性”的意思是整个枚举期间执行子系统 看起来就像被冻结在某个时间点上，不会出现分析过程中，根节点集合的对象引用关系还在不断变化 的情况，若这点不能满足的话，分析结果准确性也就无法保证。这是导致垃圾收集过程必须停顿所有 用户线程的其中一个重要原因，即使是号称停顿时间可控，或者（几乎）不会发生停顿的CMS、G1、 ZGC等收集器，枚举根节点时也是必须要停顿的。</li><li>由于目前主流Java虚拟机使用的都是<strong>准确式垃圾收集</strong>，所以当用户线程停顿下来之后，其实并不需要一个不漏地检查完所有 执行上下文和全局的引用位置，虚拟机应当是有办法直接得到哪些地方存放着对象引用的。在HotSpot 的解决方案里，是使用一组称为<strong>OopMap的数据结构</strong>来达到这个目的。一旦类加载动作完成的时候， HotSpot就会把对象内什么偏移量上是什么类型的数据计算出来，在即时编译过程中，也会在特定的位置记录下栈里和寄存器里哪些位置是引用。这样收集器在扫描时就可以直接得知这些信 息了，<strong>并不需要真正一个不漏地从方法区等GC Roots开始查找</strong>。</li><li>Exact VM因它使用<strong>准确式内存管理</strong>（Exact Memory Management，也可以叫Non-Con- servative&#x2F;Accurate Memory Management）而得名。准确式内存管理是指虚拟机可以知道内存中某个位置的数据具体是什么类型。譬如内存中有一个32bit的整数123456，虚拟机将有能力分辨出它到底是一 个指向了123456的内存地址的引用类型还是一个数值为123456的整数，准确分辨出哪些内存是引用类型，这也是在垃圾收集时准确判断堆上的数据是否还可能被使用的前提。【<strong>这个不是特别重要，了解一下即可</strong>】</li></ul><p>常考面试：<strong>在OopMap的协助下，HotSpot可以快速准确地完成GC Roots枚举</strong></p><h2 id="2-安全点与安全区域"><a href="#2-安全点与安全区域" class="headerlink" title="2. 安全点与安全区域"></a>2. 安全点与安全区域</h2><h3 id="2-1-安全点（Safepoint）"><a href="#2-1-安全点（Safepoint）" class="headerlink" title="2.1 安全点（Safepoint）"></a>2.1 安全点（Safepoint）</h3><ul><li>程序执行时并非在所有地方都能停顿下来开始GC，只有在特定的位置才能停顿下来开始GC，这些位置称为“安全点（Safepoint）”。</li><li>Safe Point的选择很重要，<strong>如果太少可能导致GC等待的时间太长，如果太频繁可能导致运行时的性能问题</strong>。大部分指令的执行时间都非常短暂，通常会根据“<strong>是否具有让程序长时间执行的特征</strong>”为标准。比如：选择一些执行时间较长的指令作为Safe Point，<strong>如方法调用、循环跳转和异常跳转等</strong>。</li></ul><p><strong>如何在GC发生时，检查所有线程都跑到最近的安全点停顿下来呢？</strong></p><ul><li>抢先式中断：（目前没有虚拟机采用了）首先中断所有线程。如果还有线程不在安全点，就恢复线程，让线程跑到安全点。</li><li>主动式中断：设置一个中断标志，各个线程运行到Safe Point的时候<strong>主动轮询</strong>这个标志，如果中断标志为真，则将自己进行中断挂起。</li></ul><h3 id="2-2-安全区域（Safe-Region）"><a href="#2-2-安全区域（Safe-Region）" class="headerlink" title="2.2 安全区域（Safe Region）"></a>2.2 安全区域（Safe Region）</h3><ul><li>Safepoint 机制保证了程序执行时，在不太长的时间内就会遇到可进入GC的Safepoint。但是，程序“不执行”的时候呢？</li><li>例如线程处于Sleep状态或Blocked 状态，这时候线程无法响应JVM的中断请求，“走”到安全点去中断挂起，JVM也不太可能等待线程被唤醒。对于这种情况，就需要安全区域（Safe Region）来解决。</li><li><strong>安全区域是指在一段代码片段中，对象的引用关系不会发生变化，在这个区域中的任何位置开始GC都是安全的</strong>。我们也可以把Safe Region看做是被扩展了的Safepoint。</li></ul><h3 id="2-3-安全区域的执行流程"><a href="#2-3-安全区域的执行流程" class="headerlink" title="2.3 安全区域的执行流程"></a>2.3 安全区域的执行流程</h3><ul><li>当线程运行到Safe Region的代码时，首先标识已经进入了Safe Region，如果这段时间内发生GC，JVM会忽略标识为Safe Region状态的线程</li><li>当线程即将离开Safe Region时，会检查JVM是否已经完成根节点枚举（即GC Roots的枚举），如果完成了，则继续运行，否则线程必须等待直到收到可以安全离开Safe Region的信号为止；</li></ul><h2 id="3-记忆集与卡表"><a href="#3-记忆集与卡表" class="headerlink" title="3. 记忆集与卡表"></a>3. 记忆集与卡表</h2><h3 id="3-1-什么是跨代引用？"><a href="#3-1-什么是跨代引用？" class="headerlink" title="3.1 什么是跨代引用？"></a>3.1 什么是跨代引用？</h3><p>一般的垃圾回收算法至少会划分出两个年代，年轻代和老年代。但是单纯的分代理论在垃圾回收的时候存在一个巨大的缺陷：为了找到年轻代中的存活对象，却不得不遍历整个老年代，反过来也是一样的。</p><p><img src="https://raw.githubusercontent.com/GeorgeChan95/blogimg/master/img/2024/01/15/20240115-190528.png" alt="跨代引用"></p><ul><li>如果我们从年轻代开始遍历，那么可以断定N, S, P, Q都是存活对象。但是，V却不会被认为是存活对象，其占据的内存会被回收了。这就是一个惊天的大漏洞！因为U本身是老年代对象，而且有外部引用指向它，也就是说U是存活对象，而U指向了V，也就是说V也应该是存活对象才是！而这都是因为我们只遍历年轻代对象！</li><li>所以，为了解决这种跨代引用的问题，最笨的办法就是遍历老年代的对象，找出这些跨代引用来。这种方案存在极大的性能浪费。因为从两个分代假说里面，其实隐含了一个推论：跨代引用是极少的。也就是为了找出那么一点点跨代引用，我们却得遍历整个老年代！从上图来说，很显然的是，我们根本不必遍历R。</li><li>因此，为了避免这种遍历老年代的性能开销，通常的分代垃圾回收器会引入一种称为<strong>记忆集</strong>的技术。<strong>简单来说，记忆集就是用来记录跨代引用的表。</strong></li></ul><h3 id="3-2-记忆集与卡表"><a href="#3-2-记忆集与卡表" class="headerlink" title="3.2 记忆集与卡表"></a>3.2 记忆集与卡表</h3><ul><li><p>为解决对象跨代引用所带来的问题，垃圾收集器在新生代中建 立了名为<strong>记忆集（Remembered Set）的数据结构</strong>，用以避免把整个老年代加进GC Roots扫描范围。事实上并不只是新生代、老年代之间才有跨代引用的问题，所有涉及部分区域收集（Partial GC）行为的 垃圾收集器，典型的如G1、ZGC和Shenandoah收集器，都会面临相同的问题，因此我们有必要进一步 理清记忆集的原理和实现方式，以便在后续章节里介绍几款最新的收集器相关知识时能更好地理解。</p></li><li><p>记忆集是一种用于记录<strong>从非收集区域指向收集区域的指针集合的抽象数据结构</strong>。如果我们不考虑效率和成本的话，最简单的实现可以用非收集区域中所有含跨代引用的对象数组来实现这个数据结构。</p><p>比如说我们有老年代（非收集区域）和年轻代（收集区域）的对象之间有一条引用链</p></li><li><p>这种记录全部含跨代引用对象的实现方案，无论是空间占用还是维护成本都相当高昂。而在垃圾收集的场景中，收集器只需要通过记忆集判断出某一块非收集区域是否存在有指向了收集区域的指针就可以了，并不需要了解这些跨代指针的全部细节。那设计者在实现记忆集的时候，便可以选择更为 粗犷的记录粒度来节省记忆集的存储和维护成本，下面列举了一些可供选择（当然也可以选择这个范 围以外的）的记录精度：</p><ul><li>字长精度：每个记录精确到一个机器字长（就是处理器的寻址位数，如常见的32位或64位，这个 精度决定了机器访问物理内存地址的指针长度），该字包含跨代指针。</li><li>对象精度：每个记录精确到一个对象，该对象里有字段含有跨代指针。</li><li>卡精度：每个记录精确到一块内存区域，该区域内有对象含有跨代指针。</li></ul></li><li><p>其中，第三种“卡精度”所指的是用一种称为“卡表”（Card Table）的方式去实现记忆集，这也是 目前最常用的一种记忆集实现形式，一些资料中甚至直接把它和记忆集混为一谈。前面定义中提到记 忆集其实是一种“抽象”的数据结构，抽象的意思是只定义了记忆集的行为意图，并没有定义其行为的 具体实现。卡表就是记忆集的一种具体实现，它定义了记忆集的记录精度、与堆内存的映射关系等。 关于卡表与记忆集的关系，读者不妨按照Java语言中HashMap与Map的关系来类比理解。 卡表最简单的形式可以只是一个字节数组，而HotSpot虚拟机确实也是这样做的</p></li></ul><blockquote><p>更多关于记忆集与卡表，见：<a href="https://developer.aliyun.com/article/1097566">https://developer.aliyun.com/article/1097566</a></p></blockquote><h1 id="六、再谈引用概述"><a href="#六、再谈引用概述" class="headerlink" title="六、再谈引用概述"></a>六、再谈引用概述</h1><ul><li>我们希望能描述这样一类对象：当内存空间还足够时，则能保留在内存中；如果内存空间在进行垃圾收集后还是很紧张，则可以抛弃这些对象。</li><li>既偏门又非常高频的面试题：强引用、软引用、弱引用、虚引用有什么区别？具体使用场景是什么？</li><li>在JDK1.2版之后，Java对引用的概念进行了扩充，将引用分为：<ul><li>强引用（Strong Reference）</li><li>软引用（Soft Reference）</li><li>弱引用（Weak Reference）</li><li>虚引用（Phantom Reference）</li></ul></li><li>这4种引用强度依次逐渐减弱。除强引用外，其他3种引用均可以在java.lang.ref包中找到它们的身影。如下图，显示了这3种引用类型对应的类，开发人员可以在应用程序中直接使用它们。</li></ul><p><img src="https://raw.githubusercontent.com/GeorgeChan95/blogimg/master/img/2024/01/15/20240115-192923.png" alt="Reference"></p><p>Reference子类中只有终结器引用是包内可见的，其他3种引用类型均为public，可以在应用程序中直接使用</p><ul><li>强引用（StrongReference）：最传统的“引用”的定义，是指在程序代码之中普遍存在的引用赋值，即类似“<code>object obj=new Object()</code>”这种引用关系。无论任何情况下，只要强引用关系还存在，垃圾收集器就永远不会回收掉被引用的对象。宁可报OOM，也不会GC强引用</li><li>软引用（SoftReference）：在系统将要发生内存溢出之前，将会把这些对象列入回收范围之中进行第二次回收。如果这次回收后还没有足够的内存，才会抛出内存溢出异常。</li><li>弱引用（WeakReference）：被弱引用关联的对象只能生存到下一次垃圾收集之前。当垃圾收集器工作时，无论内存空间是否足够，都会回收掉被弱引用关联的对象。</li><li>虚引用（PhantomReference）：一个对象是否有虚引用的存在，完全不会对其生存时间构成影响，也无法通过虚引用来获得一个对象的实例。为一个对象设置虚引用关联的唯一目的就是能在这个对象被收集器回收时收到一个系统通知。</li></ul><h1 id="七、再谈引用：强引用"><a href="#七、再谈引用：强引用" class="headerlink" title="七、再谈引用：强引用"></a>七、再谈引用：强引用</h1><ul><li>在Java程序中，最常见的引用类型是强引用（普通系统99%以上都是强引用），也就是我们最常见的普通对象引用，<strong>也是默认的引用类型</strong>。</li><li>当在Java语言中使用new操作符创建一个新的对象，并将其赋值给一个变量的时候，这个变量就成为指向该对象的一个强引用。</li><li><strong>只要强引用的对象是可触及的，垃圾收集器就永远不会回收掉被引用的对象。</strong>只要强引用的对象是可达的，jvm宁可报OOM，也不会回收强引用。</li><li>对于一个普通的对象，如果没有其他的引用关系，只要超过了引用的作用域或者显式地将相应（强）引用赋值为null，就是可以当做垃圾被收集了，当然具体回收时机还是要看垃圾收集策略。</li><li>相对的，软引用、弱引用和虚引用的对象是软可触及、弱可触及和虚可触及的，在一定条件下，都是可以被回收的。所以，强引用是造成Java内存泄漏的主要原因之一。</li></ul><blockquote><p>代码示例：</p></blockquote><pre><code class="highlight java"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">StrongReferenceTest</span> &#123;    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;        <span class="type">StringBuffer</span> <span class="variable">str</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">StringBuffer</span> (<span class="string">&quot;Hello,尚硅谷&quot;</span>);        <span class="type">StringBuffer</span> <span class="variable">str1</span> <span class="operator">=</span> str;        str = <span class="literal">null</span>;        System.gc();        <span class="keyword">try</span> &#123;            Thread.sleep(<span class="number">3000</span>);        &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;            e.printStackTrace();        &#125;        System.out.println(str1);    &#125;&#125;</code></pre><blockquote><p>执行结果</p></blockquote><pre><code class="highlight plaintext">Hello,尚硅谷</code></pre><p>局部变量str指向stringBuffer实例所在堆空间，通过str可以操作该实例，那么str就是stringBuffer实例的强引用对应内存结构：</p><p><code>StringBuffer str = new StringBuffer(&quot;hello,尚硅谷&quot;);</code></p><p><img src="https://raw.githubusercontent.com/GeorgeChan95/blogimg/master/img/2024/01/15/20240115-193647.png" alt="image-20240115193646523"></p><p><strong>总结</strong></p><p>本例中的两个引用，都是强引用，强引用具备以下特点：</p><ul><li>强引用可以直接访问目标对象。</li><li>强引用所指向的对象在任何时候都不会被系统回收，虚拟机宁愿抛出OOM异常，也不会回收强引用所指向对象。</li><li>强引用可能导致内存泄漏。</li></ul><h1 id="八、再谈引用：软引用"><a href="#八、再谈引用：软引用" class="headerlink" title="八、再谈引用：软引用"></a>八、再谈引用：软引用</h1><p><strong>软引用（Soft Reference）：内存不足即回收</strong></p><ul><li>软引用是用来描述一些还有用，但非必需的对象。只被软引用关联着的对象，在系统将要发生内存溢出异常前，会把这些对象列进回收范围之中进行第二次回收，如果这次回收还没有足够的内存，才会抛出内存溢出异常。注意，这里的第一次回收是不可达的对象</li><li>软引用通常用来实现内存敏感的缓存。比如：高速缓存就有用到软引用。如果还有空闲内存，就可以暂时保留缓存，当内存不足时清理掉，这样就保证了使用缓存的同时，不会耗尽内存。</li><li>垃圾回收器在某个时刻决定回收软可达的对象的时候，会清理软引用，并可选地把引用存放到一个引用队列（Reference Queue）。</li><li>类似弱引用，只不过Java虚拟机会尽量让软引用的存活时间长一些，迫不得已才清理。</li><li>一句话概括：当内存足够时，不会回收软引用可达的对象。内存不够时，会回收软引用的可达对象</li></ul><p>在JDK1.2版之后提供了SoftReference类来实现软引用</p><pre><code class="highlight java"><span class="type">Object</span> <span class="variable">obj</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Object</span>();<span class="comment">// 声明强引用</span>SoftReference&lt;Object&gt; sf = <span class="keyword">new</span> <span class="title class_">SoftReference</span>&lt;&gt;(obj);obj = <span class="literal">null</span>; <span class="comment">//销毁强引用</span></code></pre><blockquote><p>代码示例</p></blockquote><pre><code class="highlight java"><span class="comment">/**</span><span class="comment"> * 软引用的测试：内存不足即回收</span><span class="comment"> * -Xms10m -Xmx10m</span><span class="comment"> */</span><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">SoftReferenceTest</span> &#123;    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">class</span> <span class="title class_">User</span> &#123;        <span class="keyword">public</span> <span class="title function_">User</span><span class="params">(<span class="type">int</span> id, String name)</span> &#123;            <span class="built_in">this</span>.id = id;            <span class="built_in">this</span>.name = name;        &#125;        <span class="keyword">public</span> <span class="type">int</span> id;        <span class="keyword">public</span> String name;        <span class="meta">@Override</span>        <span class="keyword">public</span> String <span class="title function_">toString</span><span class="params">()</span> &#123;            <span class="keyword">return</span> <span class="string">&quot;[id=&quot;</span> + id + <span class="string">&quot;, name=&quot;</span> + name + <span class="string">&quot;] &quot;</span>;        &#125;    &#125;    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;        <span class="comment">//创建对象，建立软引用</span><span class="comment">//        SoftReference&lt;User&gt; userSoftRef = new SoftReference&lt;User&gt;(new User(1, &quot;songhk&quot;));</span>        <span class="comment">//上面的一行代码，等价于如下的三行代码</span>        <span class="type">User</span> <span class="variable">u1</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">User</span>(<span class="number">1</span>,<span class="string">&quot;songhk&quot;</span>);        SoftReference&lt;User&gt; userSoftRef = <span class="keyword">new</span> <span class="title class_">SoftReference</span>&lt;User&gt;(u1);        u1 = <span class="literal">null</span>;<span class="comment">//取消强引用</span>        <span class="comment">//从软引用中重新获得强引用对象</span>        System.out.println(userSoftRef.get());        System.gc();        System.out.println(<span class="string">&quot;After GC:&quot;</span>);<span class="comment">//        //垃圾回收之后获得软引用中的对象</span>        System.out.println(userSoftRef.get());<span class="comment">//由于堆空间内存足够，所有不会回收软引用的可达对象。</span><span class="comment">//</span>        <span class="keyword">try</span> &#123;            <span class="comment">//让系统认为内存资源紧张、不够</span>            <span class="type">byte</span>[] b = <span class="keyword">new</span> <span class="title class_">byte</span>[<span class="number">1024</span> * <span class="number">7168</span> - <span class="number">580</span> * <span class="number">1024</span>];        &#125; <span class="keyword">catch</span> (Throwable e) &#123;            e.printStackTrace();        &#125; <span class="keyword">finally</span> &#123;            <span class="comment">//再次从软引用中获取数据</span>            System.out.println(userSoftRef.get());<span class="comment">//在报OOM之前，垃圾回收器会回收软引用的可达对象。</span>        &#125;    &#125;&#125;</code></pre><blockquote><p>JVM参数：-Xms10m -Xmx10m</p></blockquote><p>在 JVM 内存不足时，会清理软引用对象</p><blockquote><p>输出结果</p></blockquote><pre><code class="highlight plaintext">[id=1, name=songhk] After GC:[id=1, name=songhk] nulljava.lang.OutOfMemoryError: Java heap spaceat com.atguigu.java1.SoftReferenceTest.main(SoftReferenceTest.java:44)</code></pre><h1 id="九、再谈引用：弱引用"><a href="#九、再谈引用：弱引用" class="headerlink" title="九、再谈引用：弱引用"></a>九、再谈引用：弱引用</h1><p><strong>弱引用（Weak Reference）发现即回收</strong></p><ul><li>弱引用也是用来描述那些非必需对象，<strong>只被弱引用关联的对象只能生存到下一次垃圾收集发生为止。在系统GC时，只要发现弱引用，不管系统堆空间使用是否充足，都会回收掉只被弱引用关联的对象</strong>。</li><li>但是，由于垃圾回收器的线程通常优先级很低，因此，并不一定能很快地发现持有弱引用的对象。在这种情况下，弱引用对象可以存在较长的时间。</li><li>弱引用和软引用一样，在构造弱引用时，也可以指定一个引用队列，当弱引用对象被回收时，就会加入指定的引用队列，通过这个队列可以跟踪对象的回收情况。</li><li>软引用、弱引用都非常适合来保存那些可有可无的缓存数据。如果这么做，当系统内存不足时，这些缓存数据会被回收，不会导致内存溢出。而当内存资源充足时，这些缓存数据又可以存在相当长的时间，从而起到加速系统的作用。</li></ul><p>在JDK1.2版之后提供了WeakReference类来实现弱引用</p><pre><code class="highlight java"><span class="comment">// 声明强引用</span><span class="type">Object</span> <span class="variable">obj</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Object</span>();WeakReference&lt;Object&gt; sf = <span class="keyword">new</span> <span class="title class_">WeakReference</span>&lt;&gt;(obj);obj = <span class="literal">null</span>; <span class="comment">//销毁强引用</span></code></pre><p>弱引用对象与软引用对象的最大不同就在于，当GC在进行回收时，需要通过算法检查是否回收软引用对象，而对于弱引用对象，GC总是进行回收。弱引用对象更容易、更快被GC回收。</p><blockquote><p>代码示例</p></blockquote><pre><code class="highlight java"><span class="comment">/**</span><span class="comment"> * 弱引用的测试</span><span class="comment"> */</span><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">WeakReferenceTest</span> &#123;    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">class</span> <span class="title class_">User</span> &#123;        <span class="keyword">public</span> <span class="title function_">User</span><span class="params">(<span class="type">int</span> id, String name)</span> &#123;            <span class="built_in">this</span>.id = id;            <span class="built_in">this</span>.name = name;        &#125;        <span class="keyword">public</span> <span class="type">int</span> id;        <span class="keyword">public</span> String name;        <span class="meta">@Override</span>        <span class="keyword">public</span> String <span class="title function_">toString</span><span class="params">()</span> &#123;            <span class="keyword">return</span> <span class="string">&quot;[id=&quot;</span> + id + <span class="string">&quot;, name=&quot;</span> + name + <span class="string">&quot;] &quot;</span>;        &#125;    &#125;    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;        <span class="comment">//构造了弱引用</span>        WeakReference&lt;User&gt; userWeakRef = <span class="keyword">new</span> <span class="title class_">WeakReference</span>&lt;User&gt;(<span class="keyword">new</span> <span class="title class_">User</span>(<span class="number">1</span>, <span class="string">&quot;songhk&quot;</span>));        <span class="comment">//从弱引用中重新获取对象</span>        System.out.println(userWeakRef.get());        System.gc();        <span class="comment">// 不管当前内存空间足够与否，都会回收它的内存</span>        System.out.println(<span class="string">&quot;After GC:&quot;</span>);        <span class="comment">//重新尝试从弱引用中获取对象</span>        System.out.println(userWeakRef.get());    &#125;&#125;</code></pre><p>执行垃圾回收后，软引用对象必定被清除</p><blockquote><p>输出结果</p></blockquote><pre><code class="highlight plaintext">[id=1, name=songhk] After GC:null</code></pre><h1 id="十、再谈引用：虚引用"><a href="#十、再谈引用：虚引用" class="headerlink" title="十、再谈引用：虚引用"></a>十、再谈引用：虚引用</h1><p><strong>虚引用（Phantom Reference）：对象回收跟踪</strong></p><ul><li>也称为“幽灵引用”或者“幻影引用”，是所有引用类型中最弱的一个</li><li>一个对象是否有虚引用的存在，完全不会决定对象的生命周期。如果一个对象仅持有虚引用，那么它和没有引用几乎是一样的，随时都可能被垃圾回收器回收。</li><li>它不能单独使用，也无法通过虚引用来获取被引用的对象。当试图通过虚引用的get()方法取得对象时，总是null 。<strong>即通过虚引用无法获取到我们的数据</strong></li><li><strong>为一个对象设置虚引用关联的唯一目的在于跟踪垃圾回收过程。比如：能在这个对象被收集器回收时收到一个系统通知。</strong></li><li>虚引用必须和引用队列一起使用。虚引用在创建时必须提供一个引用队列作为参数。当垃圾回收器准备回收一个对象时，如果发现它还有虚引用，就会在回收对象后，将这个虚引用加入引用队列，以通知应用程序对象的回收情况。</li><li>由于虚引用可以跟踪对象的回收时间，因此，也可以将一些资源释放操作放置在虚引用中执行和记录。</li></ul><p>在JDK1.2版之后提供了PhantomReference类来实现虚引用。</p><pre><code class="highlight java"><span class="comment">// 声明强引用</span><span class="type">Object</span> <span class="variable">obj</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Object</span>();<span class="comment">// 声明引用队列</span><span class="type">ReferenceQueue</span> <span class="variable">phantomQueue</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ReferenceQueue</span>();<span class="comment">// 声明虚引用（还需要传入引用队列）</span>PhantomReference&lt;Object&gt; sf = <span class="keyword">new</span> <span class="title class_">PhantomReference</span>&lt;&gt;(obj, phantomQueue);obj = <span class="literal">null</span>;</code></pre><blockquote><p>代码示例</p></blockquote><pre><code class="highlight java"><span class="comment">/**</span><span class="comment"> * 虚引用的测试</span><span class="comment"> */</span><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">PhantomReferenceTest</span> &#123;    <span class="keyword">public</span> <span class="keyword">static</span> PhantomReferenceTest obj;<span class="comment">//当前类对象的声明</span>    <span class="keyword">static</span> ReferenceQueue&lt;PhantomReferenceTest&gt; phantomQueue = <span class="literal">null</span>;<span class="comment">//引用队列</span>    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">class</span> <span class="title class_">CheckRefQueue</span> <span class="keyword">extends</span> <span class="title class_">Thread</span> &#123;        <span class="meta">@Override</span>        <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span> &#123;            <span class="keyword">while</span> (<span class="literal">true</span>) &#123;                <span class="keyword">if</span> (phantomQueue != <span class="literal">null</span>) &#123;                    PhantomReference&lt;PhantomReferenceTest&gt; objt = <span class="literal">null</span>;                    <span class="keyword">try</span> &#123;                        objt = (PhantomReference&lt;PhantomReferenceTest&gt;) phantomQueue.remove();                    &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;                        e.printStackTrace();                    &#125;                    <span class="keyword">if</span> (objt != <span class="literal">null</span>) &#123;                        System.out.println(<span class="string">&quot;追踪垃圾回收过程：PhantomReferenceTest实例被GC了&quot;</span>);                    &#125;                &#125;            &#125;        &#125;    &#125;    <span class="meta">@Override</span>    <span class="keyword">protected</span> <span class="keyword">void</span> <span class="title function_">finalize</span><span class="params">()</span> <span class="keyword">throws</span> Throwable &#123; <span class="comment">//finalize()方法只能被调用一次！</span>        <span class="built_in">super</span>.finalize();        System.out.println(<span class="string">&quot;调用当前类的finalize()方法&quot;</span>);        obj = <span class="built_in">this</span>;    &#125;    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;        <span class="type">Thread</span> <span class="variable">t</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">CheckRefQueue</span>();        t.setDaemon(<span class="literal">true</span>);<span class="comment">//设置为守护线程：当程序中没有非守护线程时，守护线程也就执行结束。</span>        t.start();        phantomQueue = <span class="keyword">new</span> <span class="title class_">ReferenceQueue</span>&lt;PhantomReferenceTest&gt;();        obj = <span class="keyword">new</span> <span class="title class_">PhantomReferenceTest</span>();        <span class="comment">//构造了 PhantomReferenceTest 对象的虚引用，并指定了引用队列</span>        PhantomReference&lt;PhantomReferenceTest&gt; phantomRef = <span class="keyword">new</span> <span class="title class_">PhantomReference</span>&lt;PhantomReferenceTest&gt;(obj, phantomQueue);        <span class="keyword">try</span> &#123;            <span class="comment">//不可获取虚引用中的对象</span>            System.out.println(phantomRef.get());            <span class="comment">//将强引用去除</span>            obj = <span class="literal">null</span>;            <span class="comment">//第一次进行GC,由于对象可复活，GC无法回收该对象</span>            System.gc();            Thread.sleep(<span class="number">1000</span>);            <span class="keyword">if</span> (obj == <span class="literal">null</span>) &#123;                System.out.println(<span class="string">&quot;obj 是 null&quot;</span>);            &#125; <span class="keyword">else</span> &#123;                System.out.println(<span class="string">&quot;obj 可用&quot;</span>);            &#125;            System.out.println(<span class="string">&quot;第 2 次 gc&quot;</span>);            obj = <span class="literal">null</span>;            System.gc(); <span class="comment">//一旦将obj对象回收，就会将此虚引用存放到引用队列中。</span>            Thread.sleep(<span class="number">1000</span>);            <span class="keyword">if</span> (obj == <span class="literal">null</span>) &#123;                System.out.println(<span class="string">&quot;obj 是 null&quot;</span>);            &#125; <span class="keyword">else</span> &#123;                System.out.println(<span class="string">&quot;obj 可用&quot;</span>);            &#125;        &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;            e.printStackTrace();        &#125;    &#125;&#125;</code></pre><p>1、第一次尝试获取虚引用的值，发现无法获取的，这是因为虚引用是无法直接获取对象的值，然后进行第一次GC，因为会调用finalize方法，将对象复活了，所以对象没有被回收</p><p>2、但是调用第二次GC操作的时候，因为finalize方法只能执行一次，所以就触发了GC操作，将对象回收了，同时将会触发第二个操作就是将待回收的对象存入到引用队列中。</p><blockquote><p>输出结果</p></blockquote><pre><code class="highlight plaintext">null调用当前类的finalize()方法obj 可用第 2 次 gc追踪垃圾回收过程：PhantomReferenceTest实例被GC了obj 是 null</code></pre><h1 id="十一、再谈引用：终结器引用（了解）"><a href="#十一、再谈引用：终结器引用（了解）" class="headerlink" title="十一、再谈引用：终结器引用（了解）"></a>十一、再谈引用：终结器引用（了解）</h1><ul><li>它用于实现对象的finalize() 方法，也可以称为终结器引用</li><li>无需手动编码，其内部配合引用队列使用</li><li>在GC时，终结器引用入队。由Finalizer线程通过终结器引用找到被引用对象调用它的finalize()方法，第二次GC时才回收被引用的对象</li></ul><h1 id="参考链接"><a href="#参考链接" class="headerlink" title="参考链接"></a>参考链接</h1><blockquote><p>安全点和安全区域：</p><ul><li><a href="https://zhuanlan.zhihu.com/p/461298916">https://zhuanlan.zhihu.com/p/461298916</a></li><li><a href="https://www.cnblogs.com/chenchuxin/p/15259439.html">https://www.cnblogs.com/chenchuxin/p/15259439.html</a></li></ul><p>记忆集与卡表：</p><ul><li><a href="https://developer.aliyun.com/article/1097566">https://developer.aliyun.com/article/1097566</a></li></ul></blockquote>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;一、System-gc-的理解&quot;&gt;&lt;a href=&quot;#一、System-gc-的理解&quot; class=&quot;headerlink&quot; title=&quot;一、System.gc() 的理解&quot;&gt;&lt;/a&gt;一、System.gc() 的理解&lt;/h1&gt;&lt;ul&gt;
&lt;li&gt;在默认情况下，通</summary>
      
    
    
    
    <category term="JVM" scheme="https://georgechan95.github.io/categories/JVM/"/>
    
    
    <category term="jvm" scheme="https://georgechan95.github.io/tags/jvm/"/>
    
    <category term="java" scheme="https://georgechan95.github.io/tags/java/"/>
    
  </entry>
  
  <entry>
    <title>第十二章-垃圾回收概述和相关算法</title>
    <link href="https://georgechan95.github.io/2024/01/06/jvm/%E7%AC%AC%E5%8D%81%E4%BA%8C%E7%AB%A0-%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6%E6%A6%82%E8%BF%B0/"/>
    <id>https://georgechan95.github.io/2024/01/06/jvm/%E7%AC%AC%E5%8D%81%E4%BA%8C%E7%AB%A0-%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6%E6%A6%82%E8%BF%B0/</id>
    <published>2024-01-06T08:28:00.000Z</published>
    <updated>2024-06-22T10:36:12.823Z</updated>
    
    <content type="html"><![CDATA[<h1 id="一、垃圾回收概述"><a href="#一、垃圾回收概述" class="headerlink" title="一、垃圾回收概述"></a>一、垃圾回收概述</h1><p>​<img src="https://raw.githubusercontent.com/GeorgeChan95/blogimg/master/img/2024/01/08/20240108-132239.png" alt="image-20240108132235061"></p><ul><li>Java 和 C++ 语言的区别，就在于垃圾收集技术和内存动态分配上，C++语言没有垃圾收集技术，需要程序员手动的收集。</li><li>垃圾收集，不是Java语言的伴生产物。早在1960年，第一门开始使用内存动态分配和垃圾收集技术的Lisp语言诞生。</li><li>关于垃圾收集有三个经典问题：<ul><li>哪些内存需要回收？</li><li>什么时候回收？</li><li>如何回收？</li></ul></li><li>垃圾收集机制是Java的招牌能力，极大地提高了开发效率。如今，垃圾收集几乎成为现代语言的标配，即使经过如此长时间的发展，Java的垃圾收集机制仍然在不断的演进中，不同大小的设备、不同特征的应用场景，对垃圾收集提出了新的挑战，这当然也是面试的热点。</li></ul><h2 id="1-什么是垃圾？"><a href="#1-什么是垃圾？" class="headerlink" title="1. 什么是垃圾？"></a>1. 什么是垃圾？</h2><ul><li>垃圾是指<strong>在运行程序中没有任何指针指向的对象</strong>，这个对象就是需要被回收的垃圾。</li><li>如果不及时对内存中的垃圾进行清理，那么，这些垃圾对象所占的内存空间会一直保留到应用程序结束，被保留的空间无法被其他对象使用。甚至可能导致内存溢出。</li></ul><h2 id="2-为什么需要GC？"><a href="#2-为什么需要GC？" class="headerlink" title="2. 为什么需要GC？"></a>2. 为什么需要GC？</h2><p><strong>想要学习GC，首先需要理解为什么需要GC？</strong></p><ul><li>对于高级语言来说，一个基本认知是如果不进行垃圾回收，<strong>内存迟早都会被消耗完</strong>，因为不断地分配内存空间而不进行回收，就好像不停地生产生活垃圾而从来不打扫一样。</li><li>除了释放没用的对象，垃圾回收也可以清除内存里的记录碎片。碎片整理将所占用的堆内存移到堆的一端，<strong>以便JVM将整理出的内存分配给新的对象</strong>。</li><li>随着应用程序所应付的业务越来越庞大、复杂，用户越来越多，<strong>没有GC就不能保证应用程序的正常进行</strong>。而经常造成STW的GC又跟不上实际的需求，所以才会不断地尝试对GC进行优化。</li></ul><h2 id="3-早期垃圾回收"><a href="#3-早期垃圾回收" class="headerlink" title="3. 早期垃圾回收"></a>3. 早期垃圾回收</h2><ul><li><p>在早期的C&#x2F;C++时代，垃圾回收基本上是手工进行的。开发人员可以使用new关键字进行内存申请，并使用delete关键字进行内存释放。比如以下代码：</p><pre><code class="highlight c++">MibBridge *pBridge= <span class="keyword">new</span> cmBaseGroupBridge（）；<span class="comment">//如果注册失败，使用Delete释放该对象所占内存区域</span><span class="keyword">if</span>（pBridge-&gt;Register（kDestroy）！=NO ERROR）<span class="keyword">delete</span> pBridge；</code></pre></li><li><p>这种方式可以灵活控制内存释放的时间，但是会给开发人员带来<strong>频繁申请和释放内存的管理负担</strong>。倘若有一处内存区间由于程序员编码的问题忘记被回收，那么就会产生<strong>内存泄漏</strong>，垃圾对象永远无法被清除，随着系统运行时间的不断增长，垃圾对象所耗内存可能持续上升，直到出现内存溢出并造成<strong>应用程序崩溃</strong>。</p></li><li><p>有了垃圾回收机制后，上述代码极有可能变成这样</p><pre><code class="highlight c++">MibBridge *pBridge=<span class="keyword">new</span> <span class="built_in">cmBaseGroupBridge</span>(); pBridge-&gt;<span class="built_in">Register</span>(kDestroy);</code></pre></li><li><p>现在，除了Java以外，C#、Python、Ruby等语言都使用了自动垃圾回收的思想，也是未来发展趋势，可以说这种自动化的内存分配和回收方式已经成为了现代开发语言必备的标准。</p></li></ul><h2 id="4-Java-垃圾回收机制"><a href="#4-Java-垃圾回收机制" class="headerlink" title="4. Java 垃圾回收机制"></a>4. Java 垃圾回收机制</h2><h3 id="4-1-自动内存管理"><a href="#4-1-自动内存管理" class="headerlink" title="4.1 自动内存管理"></a>4.1 自动内存管理</h3><blockquote><p>官网介绍：<a href="https://docs.oracle.com/javase/8/docs/technotes/guides/vm/gctuning/toc.html">https://docs.oracle.com/javase/8/docs/technotes/guides/vm/gctuning/toc.html</a></p></blockquote><p><strong>自动内存管理的优点</strong></p><ul><li>自动内存管理，无需开发人员手动参与内存的分配与回收，这样降低内存泄漏和内存溢出的风险</li><li>没有垃圾回收器，java也会和cpp一样，各种悬垂指针，野指针，泄露问题让你头疼不已。</li><li>自动内存管理机制，将程序员从繁重的内存管理中释放出来，可以更专心地专注于业务开发</li></ul><p><strong>关于自动内存管理的担忧</strong></p><ul><li>对于Java开发人员而言，自动内存管理就像是一个黑匣子，如果过度依赖于“自动”，那么这将会是一场灾难，最严重的就会<strong>弱化Java开发人员在程序出现内存溢出时定位问题和解决问题的能力</strong>。</li><li>此时，了解JVM的自动内存分配和内存回收原理就显得非常重要，只有在真正了解JVM是如何管理内存后，我们才能够在遇见OutofMemoryError时，快速地根据错误异常日志定位问题和解决问题。</li><li>当需要排查各种内存溢出、内存泄漏问题时，当垃圾收集成为系统达到更高并发量的瓶颈时，我们就必须对这些“自动化”的技术<strong>实施必要的监控和调节</strong>。</li></ul><h3 id="4-2-应该关心哪些区域的回收？"><a href="#4-2-应该关心哪些区域的回收？" class="headerlink" title="4.2 应该关心哪些区域的回收？"></a>4.2 应该关心哪些区域的回收？</h3><p><img src="https://raw.githubusercontent.com/GeorgeChan95/blogimg/master/img/2024/01/08/20240108-141026.png" alt="image-20240108141024844"></p><ul><li>垃圾收集器可以对年轻代回收，也可以对老年代回收，甚至是全栈和方法区的回收，其中，<strong>Java堆是垃圾收集器的工作重点</strong></li><li>从次数上讲：<ul><li>频繁收集Young区</li><li>较少收集Old区</li><li>基本不收集Perm区（元空间）</li></ul></li></ul><h1 id="二、垃圾回收相关算法"><a href="#二、垃圾回收相关算法" class="headerlink" title="二、垃圾回收相关算法"></a>二、垃圾回收相关算法</h1><h2 id="1-标记阶段：引用计数算法"><a href="#1-标记阶段：引用计数算法" class="headerlink" title="1. 标记阶段：引用计数算法"></a>1. 标记阶段：引用计数算法</h2><h3 id="1-1-标记阶段的目的"><a href="#1-1-标记阶段的目的" class="headerlink" title="1.1 标记阶段的目的"></a>1.1 标记阶段的目的</h3><p><strong>垃圾标记阶段：主要是为了判断对象是否存活</strong></p><ul><li>在堆里存放着几乎所有的Java对象实例，在GC执行垃圾回收之前，首先<strong>需要区分出内存中哪些是存活对象，哪些是已经死亡的对象。</strong>只有被标记为己经死亡的对象，GC才会在执行垃圾回收时，释放掉其所占用的内存空间，因此这个过程我们可以称为<strong>垃圾标记阶段</strong>。</li><li>那么在JVM中究竟是如何标记一个死亡对象呢？简单来说，当一个对象已经不再被任何的存活对象继续引用时，就可以宣判为已经死亡。</li><li>判断对象存活一般有两种方式：<strong>引用计数算法</strong>和<strong>可达性分析算法</strong>。</li></ul><h3 id="1-2-引用计数算法"><a href="#1-2-引用计数算法" class="headerlink" title="1.2 引用计数算法"></a>1.2 引用计数算法</h3><ul><li>引用计数算法（Reference Counting）比较简单，对每个对象保存一个整型的引用计数器属性。用于记录对象被引用的情况。</li><li>对于一个对象A，只要有任何一个对象引用了A，则A的引用计数器就加1；当引用失效时，引用计数器就减1。只要对象A的引用计数器的值为0，即表示对象A不可能再被使用，可进行回收。</li><li>优点：实现简单，垃圾对象便于辨识；判定效率高，回收没有延迟性。</li><li>缺点：<ul><li>它需要单独的字段存储计数器，这样的做法增加了<strong>存储空间的开销</strong>。</li><li>每次赋值都需要更新计数器，伴随着加法和减法操作，这增加了<strong>时间开销</strong>。</li><li>引用计数器有一个严重的问题，即<strong>无法处理循环引用</strong>的情况。这是一条致命缺陷，导致在Java的垃圾回收器中没有使用这类算法。</li></ul></li></ul><h3 id="1-3-循环引用"><a href="#1-3-循环引用" class="headerlink" title="1.3 循环引用"></a>1.3 循环引用</h3><p>当p的指针断开的时候，内部的引用形成一个循环，计数器都还算1，无法被回收，这就是循环引用，从而造成内存泄漏</p><p><img src="https://raw.githubusercontent.com/GeorgeChan95/blogimg/master/img/2024/01/08/20240108-142409.png" alt="image-20240108142407770"></p><h3 id="1-4-小结"><a href="#1-4-小结" class="headerlink" title="1.4 小结"></a>1.4 小结</h3><ul><li>引用计数算法，是很多语言的资源回收选择，例如因人工智能而更加火热的Python，它更是同时支持引用计数和垃圾收集机制。</li><li>具体哪种最优是要看场景的，业界有大规模实践中仅保留引用计数机制，以提高吞吐量的尝试。</li><li>Java并没有选择引用计数，是因为其存在一个基本的难题，也就是很难处理循环引用关系。</li><li>Python如何解决循环引用？<ul><li>手动解除：很好理解，就是在合适的时机，解除引用关系。</li><li>使用弱引用weakref，weakref是Python提供的标准库，旨在解决循环引用。</li></ul></li></ul><h2 id="2-标记阶段：可达性分析算法"><a href="#2-标记阶段：可达性分析算法" class="headerlink" title="2. 标记阶段：可达性分析算法"></a>2. 标记阶段：可达性分析算法</h2><p><strong>可达性分析算法：也可以称为根搜索算法、追踪性垃圾收集</strong></p><ul><li>相对于引用计数算法而言，可达性分析算法不仅同样具备实现简单和执行高效等特点，更重要的是该算法可以有效地<strong>解决在引用计数算法中循环引用的问题，防止内存泄漏的发生</strong>。</li><li>相较于引用计数算法，这里的可达性分析就是Java、C#选择的。这种类型的垃圾收集通常也叫作<strong>追踪性垃圾收集</strong>（Tracing Garbage Collection）</li></ul><h3 id="2-1-可达性分析实现思路"><a href="#2-1-可达性分析实现思路" class="headerlink" title="2.1 可达性分析实现思路"></a>2.1 可达性分析实现思路</h3><ul><li>所谓”GCRoots”根集合就是一组必须活跃的引用</li><li>其基本思路如下：<ul><li>可达性分析算法是以根对象集合（GCRoots）为起始点，按照从上至下的方式<strong>搜索被根对象集合所连接的目标对象是否可达。</strong></li><li>使用可达性分析算法后，内存中的存活对象都会被根对象集合直接或间接连接着，搜索所走过的路径称为<strong>引用链</strong>（Reference Chain）</li><li>如果目标对象没有任何引用链相连，则是不可达的，就意味着该对象己经死亡，可以标记为垃圾对象。</li><li>在可达性分析算法中，只有能够被根对象集合直接或者间接连接的对象才是存活对象。</li></ul></li></ul><p><img src="https://raw.githubusercontent.com/GeorgeChan95/blogimg/master/img/2024/01/08/20240108-143822.png" alt="image-20240108143820878"></p><h3 id="2-2-GC-Roots可以是哪些元素？"><a href="#2-2-GC-Roots可以是哪些元素？" class="headerlink" title="2.2 GC Roots可以是哪些元素？"></a>2.2 GC Roots可以是哪些元素？</h3><ol><li>虚拟机栈中引用的对象（栈帧中的本地变量表）<ol><li>比如：各个线程被调用的方法中使用到的参数、局部变量等。</li></ol></li><li>本地方法栈内JNI（通常说的本地方法）引用的对象</li><li>法区中类静态属性引用的对象<ol><li>比如：Java类的引用类型静态变量</li></ol></li><li>方法区中常量引用的对象<ol><li>比如：字符串常量池（StringTable）里的引用</li></ol></li><li>所有被同步锁synchronized持有的对象</li><li>Java虚拟机内部的引用。<ol><li>基本数据类型对应的Class对象，一些常驻的异常对象（如：NullPointerException、OutofMemoryError），系统类加载器。</li></ol></li><li>反映java虚拟机内部情况的JMXBean、JVMTI中注册的回调、本地代码缓存等。</li></ol><p>除了这些固定的GC Roots集合以外，根据用户所选用的垃圾收集器以及当前回收的内存区域不同，还可以有其他对象“临时性”地加入，共同构成完整GC Roots集合。比如：<strong>分代收集</strong>和局部回收（PartialGC）。</p><p>如果只针对Java堆中的某一块区域进行垃圾回收（比如：典型的只针对新生代），必须考虑到内存区域是虚拟机自己的实现细节，更不是孤立封闭的，这个区域的对象完全有可能被其他区域的对象所引用，这时候就需要一并将关联的区域对象也加入GC Roots集合中去考虑，才能保证可达性分析的准确性。</p><p><strong>小技巧</strong></p><p>由于Java采用栈方式存放变量和指针，所以如果一个指针，它保存了堆内存里面的对象，但是自己又不存放在堆内存里面，那它就是一个Root。</p><h3 id="2-3-注意"><a href="#2-3-注意" class="headerlink" title="2.3 注意"></a>2.3 注意</h3><ul><li>如果要使用可达性分析算法来判断内存是否可回收，那么分析工作必须在一个能保障一致性的快照中进行。这点不满足的话分析结果的准确性就无法保证。</li><li>这点也是导致GC进行时必须“Stop The World”的一个重要原因。即使是号称（几乎）不会发生停顿的CMS收集器中，枚举根节点时也是必须要停顿的。</li></ul><h2 id="3-对象的-finalization-机制"><a href="#3-对象的-finalization-机制" class="headerlink" title="3. 对象的 finalization 机制"></a>3. 对象的 finalization 机制</h2><h3 id="3-1-finalize-方法机制"><a href="#3-1-finalize-方法机制" class="headerlink" title="3.1 finalize() 方法机制"></a>3.1 finalize() 方法机制</h3><p><strong>对象销毁前的回调函数：finalize()</strong></p><ul><li>Java语言提供了对象终止（finalization）机制来允许开发人员提供<strong>对象被销毁之前的自定义处理逻辑</strong>。</li><li>当垃圾回收器发现没有引用指向一个对象，即：垃圾回收此对象之前，总会先调用这个对象的finalize()方法。</li><li>finalize() 方法允许在子类中被重写，<strong>用于在对象被回收时进行资源释放</strong>。通常在这个方法中进行一些资源释放和清理的工作，比如关闭文件、套接字和数据库连接等。</li></ul><p><strong>Object 类中 finalize() 源码</strong></p><pre><code class="highlight plaintext">// 等待被重写protected void finalize() throws Throwable &#123; &#125;</code></pre><ul><li>永远不要主动调用某个对象的finalize()方法，应该交给垃圾回收机制调用。理由包括下面三点：<ul><li>在finalize()时可能会导致对象复活。</li><li>finalize()方法的执行时间是没有保障的，它完全由GC线程决定，极端情况下，若不发生GC，则finalize()方法将没有执行机会。</li><li>一个糟糕的finalize()会严重影响GC的性能。比如finalize是个死循环</li></ul></li><li>从功能上来说，finalize()方法与C++中的析构函数比较相似，但是Java采用的是基于垃圾回收器的自动内存管理机制，所以finalize()方法在<strong>本质上不同于C++中的析构函数</strong>。</li><li>finalize()方法对应了一个finalize线程，因为优先级比较低，即使主动调用该方法，也不会因此就直接进行回收</li></ul><h3 id="3-2-虚拟机中对象的状态"><a href="#3-2-虚拟机中对象的状态" class="headerlink" title="3.2 虚拟机中对象的状态"></a>3.2 虚拟机中对象的状态</h3><p>由于finalize()方法的存在，<strong>虚拟机中的对象一般处于三种可能的状态。</strong></p><ul><li>如果从所有的根节点都无法访问到某个对象，说明对象己经不再使用了。一般来说，此对象需要被回收。但事实上，也并非是“非死不可”的，这时候它们暂时处于“缓刑”阶段。<strong>一个无法触及的对象有可能在某一个条件下“复活”自己</strong>，如果这样，那么对它立即进行回收就是不合理的。为此，定义虚拟机中的对象可能的三种状态。如下：<ul><li>可触及的：从根节点开始，可以到达这个对象。</li><li>可复活的：对象的所有引用都被释放，但是对象有可能在finalize()中复活。</li><li>不可触及的：对象的finalize()被调用，并且没有复活，那么就会进入不可触及状态。不可触及的对象不可能被复活，<strong>因为finalize()只会被调用一次</strong>。</li></ul></li></ul><p>以上3种状态中，是由于finalize()方法的存在，进行的区分。只有在对象不可触及时才可以被回收。</p><h3 id="3-3-具体过程"><a href="#3-3-具体过程" class="headerlink" title="3.3 具体过程"></a>3.3 具体过程</h3><p>判定一个对象objA是否可回收，至少要经历两次标记过程：</p><ul><li>如果对象objA到GC Roots没有引用链，则进行第一次标记。</li><li>进行筛选，判断此对象是否有必要执行finalize()方法<ul><li>如果对象objA没有重写finalize()方法，或者finalize()方法已经被虚拟机调用过，则虚拟机视为“没有必要执行”，objA被判定为不可触及的。</li><li>如果对象objA重写了finalize()方法，且还未执行过，那么objA会被插入到F-Queue队列中，由一个虚拟机自动创建的、低优先级的Finalizer线程触发其finalize()方法执行。</li><li>finalize()方法是对象逃脱死亡的最后机会，稍后GC会对F-Queue队列中的对象进行第二次标记。如果objA在finalize()方法中与引用链上的任何一个对象建立了联系，那么在第二次标记时，objA会被移出“即将回收”集合。之后，对象会再次出现没有引用存在的情况。在这个情况下，finalize()方法不会被再次调用，对象会直接变成不可触及的状态，也就是说，一个对象的finalize()方法只会被调用一次。</li></ul></li></ul><p><strong>通过 JVisual VM 查看 Finalizer 线程</strong></p><p><img src="https://raw.githubusercontent.com/GeorgeChan95/blogimg/master/img/2024/01/08/20240108-155703.png" alt="image-20240108155701519"></p><h3 id="3-4-代码演示-finalize-方法可复活对象"><a href="#3-4-代码演示-finalize-方法可复活对象" class="headerlink" title="3.4 代码演示 finalize() 方法可复活对象"></a>3.4 代码演示 finalize() 方法可复活对象</h3><p>我们重写 CanReliveObj 类的 finalize()方法，在调用其 finalize()方法时，将 obj 指向当前类对象 this 。</p><blockquote><p>代码</p></blockquote><pre><code class="highlight java"><span class="comment">/**</span><span class="comment"> * 测试Object类中finalize()方法，即对象的finalization机制。</span><span class="comment"> */</span><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">CanReliveObj</span> &#123;    <span class="keyword">public</span> <span class="keyword">static</span> CanReliveObj obj;<span class="comment">//类变量，属于 GC Root</span>    <span class="comment">//此方法只能被调用一次</span>    <span class="meta">@Override</span>    <span class="keyword">protected</span> <span class="keyword">void</span> <span class="title function_">finalize</span><span class="params">()</span> <span class="keyword">throws</span> Throwable &#123;        <span class="built_in">super</span>.finalize();        System.out.println(<span class="string">&quot;调用当前类重写的finalize()方法&quot;</span>);        obj = <span class="built_in">this</span>;<span class="comment">//当前待回收的对象在finalize()方法中与引用链上的一个对象obj建立了联系</span>    &#125;    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;        <span class="keyword">try</span> &#123;            obj = <span class="keyword">new</span> <span class="title class_">CanReliveObj</span>();            <span class="comment">// 对象第一次成功拯救自己</span>            obj = <span class="literal">null</span>;            System.gc();<span class="comment">//调用垃圾回收器</span>            System.out.println(<span class="string">&quot;第1次 gc&quot;</span>);            <span class="comment">// 因为Finalizer线程优先级很低，暂停2秒，以等待它</span>            Thread.sleep(<span class="number">2000</span>);            <span class="keyword">if</span> (obj == <span class="literal">null</span>) &#123;                System.out.println(<span class="string">&quot;obj is dead&quot;</span>);            &#125; <span class="keyword">else</span> &#123;                System.out.println(<span class="string">&quot;obj is still alive&quot;</span>);            &#125;            System.out.println(<span class="string">&quot;第2次 gc&quot;</span>);            <span class="comment">// 下面这段代码与上面的完全相同，但是这次自救却失败了</span>            obj = <span class="literal">null</span>;            System.gc();            <span class="comment">// 因为Finalizer线程优先级很低，暂停2秒，以等待它</span>            Thread.sleep(<span class="number">2000</span>);            <span class="keyword">if</span> (obj == <span class="literal">null</span>) &#123;                System.out.println(<span class="string">&quot;obj is dead&quot;</span>);            &#125; <span class="keyword">else</span> &#123;                System.out.println(<span class="string">&quot;obj is still alive&quot;</span>);            &#125;        &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;            e.printStackTrace();        &#125;    &#125;&#125;</code></pre><p><strong>如果注释掉finalize()方法</strong></p><pre><code class="highlight java"><span class="comment">//此方法只能被调用一次</span><span class="meta">@Override</span><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title function_">finalize</span><span class="params">()</span> <span class="keyword">throws</span> Throwable &#123;    <span class="built_in">super</span>.finalize();    System.out.println(<span class="string">&quot;调用当前类重写的finalize()方法&quot;</span>);    obj = <span class="built_in">this</span>;<span class="comment">//当前待回收的对象在finalize()方法中与引用链上的一个对象obj建立了联系</span>&#125;</code></pre><p>输出结果：</p><pre><code class="highlight plaintext">第1次 gcobj is dead第2次 gcobj is dead</code></pre><p><strong>放开finalize()方法</strong></p><p>输出结果：</p><pre><code class="highlight plaintext">调用当前类重写的finalize()方法第1次 gcobj is still alive第2次 gcobj is dead</code></pre><p>第一次自救成功，但由于 finalize() 方法只会执行一次，所以第二次自救失败</p><h2 id="4-MAT与JProfiler的GC-Roots溯源"><a href="#4-MAT与JProfiler的GC-Roots溯源" class="headerlink" title="4. MAT与JProfiler的GC Roots溯源"></a>4. MAT与JProfiler的GC Roots溯源</h2><blockquote><p>官网：<a href="https://eclipse.dev/mat/">https://eclipse.dev/mat/</a></p><p>下载地址：<a href="https://eclipse.dev/mat/previousReleases.php">https://eclipse.dev/mat/previousReleases.php</a></p><ul><li>JDK 1.8版本，使用MAT 1.6.0或1.6.1版本</li></ul></blockquote><h3 id="4-1-MAT-介绍"><a href="#4-1-MAT-介绍" class="headerlink" title="4.1 MAT 介绍"></a>4.1 MAT 介绍</h3><ul><li>MAT是Memory Analyzer的简称，它是一款功能强大的Java堆内存分析器。用于查找内存泄漏以及查看内存消耗情况。</li><li>MAT是基于Eclipse开发的，是一款免费的性能分析工具。</li><li>虽然Jvisualvm很强大，但是在内存分析方面，还是MAT更好用一些。</li></ul><h3 id="4-2-获取-dump-文件方式"><a href="#4-2-获取-dump-文件方式" class="headerlink" title="4.2 获取 dump 文件方式"></a>4.2 获取 dump 文件方式</h3><h4 id="4-2-1-方式一：命令行使用-jmap"><a href="#4-2-1-方式一：命令行使用-jmap" class="headerlink" title="4.2.1 方式一：命令行使用 jmap"></a>4.2.1 方式一：命令行使用 jmap</h4><pre><code class="highlight shell"><span class="meta prompt_"># </span><span class="language-bash">格式</span>jmap -dump:format=b,file=文件名.hprof 进程号<span class="meta prompt_"></span><span class="meta prompt_"># </span><span class="language-bash">示例</span>C:\Users\George&gt;jps3312 Jps23636 Launcher11912 Main19048 GCRootsTest6872C:\Users\George&gt;jmap -dump:format=b,file=heap.hprof 19048Dumping heap to C:\Users\George\heap.hprof ...Heap dump file created</code></pre><p><img src="https://raw.githubusercontent.com/GeorgeChan95/blogimg/master/img/2024/01/08/20240108-161544.png" alt="image-20240108161542861"></p><h4 id="4-2-2-方式二：使用JVisualVM"><a href="#4-2-2-方式二：使用JVisualVM" class="headerlink" title="4.2.2 方式二：使用JVisualVM"></a>4.2.2 方式二：使用JVisualVM</h4><p>使用JVisualVM捕获的heap dump文件是一个临时文件，关闭JVisualVM后自动删除，若要保留，需要将其另存为文件。</p><blockquote><p>示例代码</p></blockquote><p>numList 和 birth 在第一次捕捉内存快照的时候，为 GC Roots, 之后 numList 和 birth 置为 null ，对应的引用对象被回收，在第二次捕捉内存快照的时候，就不再是 GC Roots。</p><pre><code class="highlight java"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">GCRootsTest</span> &#123;    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;        List&lt;Object&gt; numList = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();        <span class="type">Date</span> <span class="variable">birth</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Date</span>();        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; <span class="number">100</span>; i++) &#123;            numList.add(String.valueOf(i));            <span class="keyword">try</span> &#123;                Thread.sleep(<span class="number">10</span>);            &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;                e.printStackTrace();            &#125;        &#125;        System.out.println(<span class="string">&quot;数据添加完毕，请操作：&quot;</span>);        <span class="keyword">new</span> <span class="title class_">Scanner</span>(System.in).next();        numList = <span class="literal">null</span>;        birth = <span class="literal">null</span>;        System.out.println(<span class="string">&quot;numList、birth已置空，请操作：&quot;</span>);        <span class="keyword">new</span> <span class="title class_">Scanner</span>(System.in).next();        System.out.println(<span class="string">&quot;结束&quot;</span>);    &#125;&#125;</code></pre><p><strong>捕捉堆内存快照具体步骤：</strong></p><p>1、先执行第一步，然后停下来，去生成此步骤dump文件</p><p><img src="https://raw.githubusercontent.com/GeorgeChan95/blogimg/master/img/2024/01/08/20240108-162524.png" alt="image-20240108162522593"></p><p>2、 点击 <strong><code>堆 Dump</code></strong></p><img src="https://raw.githubusercontent.com/GeorgeChan95/blogimg/master/img/2024/01/08/20240108-162647.png" alt="image-20240108162645837" style="zoom:50%;" /><p>3、右键 –&gt;  <strong><code>另存为</code></strong></p><img src="https://raw.githubusercontent.com/GeorgeChan95/blogimg/master/img/2024/01/08/20240108-163235.png" alt="image-20240108163233880" style="zoom:50%;" /><p>4、输入命令，继续执行程序</p><p><img src="https://raw.githubusercontent.com/GeorgeChan95/blogimg/master/img/2024/01/08/20240108-163318.png" alt="image-20240108163317374"></p><p>5、接着捕获第二张堆内存快照</p><img src="https://raw.githubusercontent.com/GeorgeChan95/blogimg/master/img/2024/01/08/20240108-163414.png" alt="image-20240108163412814" style="zoom:50%;" /><h3 id="4-3-使用-MAT-查看堆内存快照"><a href="#4-3-使用-MAT-查看堆内存快照" class="headerlink" title="4.3 使用 MAT 查看堆内存快照"></a>4.3 使用 MAT 查看堆内存快照</h3><p>1、打开 MAT ，选择 File –&gt; Open File，打开刚刚的两个dump文件，<strong>我们先打开第一个dump文件</strong></p><p><strong>点击Open Heap Dump也行</strong></p><img src="https://raw.githubusercontent.com/GeorgeChan95/blogimg/master/img/2024/01/08/20240108-170337.png" alt="image-20240108170336266" style="zoom:50%;" /><p>2、选择Java Basics –&gt; GC Roots</p><p><img src="https://raw.githubusercontent.com/GeorgeChan95/blogimg/master/img/2024/01/08/20240108-170440.png" alt="image-20240108170438718"></p><p><img src="https://raw.githubusercontent.com/GeorgeChan95/blogimg/master/img/2024/01/08/20240108-170609.png" alt="image-20240108170608489"></p><p>3、第一次捕捉堆内存快照时，GC Roots 中包含我们定义的两个局部变量，类型分别为 ArrayList 和 Date，Total:21</p><p><img src="https://raw.githubusercontent.com/GeorgeChan95/blogimg/master/img/2024/01/08/20240108-170741.png" alt="image-20240108170740417"></p><p>4、打开第二个dump文件，第二次捕获内存快照时，由于两个局部变量引用的对象被释放，所以这两个局部变量不再作为 GC Roots ，从 Total Entries &#x3D; 19 也可以看出（少了两个 GC Roots）</p><p><img src="https://raw.githubusercontent.com/GeorgeChan95/blogimg/master/img/2024/01/08/20240108-170912.png" alt="image-20240108170910579"></p><h3 id="4-4-JProfiler-GC-Roots-溯源"><a href="#4-4-JProfiler-GC-Roots-溯源" class="headerlink" title="4.4 JProfiler GC Roots 溯源"></a>4.4 JProfiler GC Roots 溯源</h3><blockquote><p>JProfiler下载地址：<a href="https://www.ej-technologies.com/download/jprofiler/files">https://www.ej-technologies.com/download/jprofiler/files</a></p></blockquote><p>在实际开发中，我们很少会查看所有的GC Roots。一般都是查看某一个或几个对象的GC Root是哪个，这个过程叫<strong>GC Roots 溯源</strong>。下面我们使用使用 JProfiler 进行 GC Roots 溯源演示</p><blockquote><p>演示代码</p></blockquote><pre><code class="highlight java"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">GCRootsTest</span> &#123;    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;        List&lt;Object&gt; numList = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();        <span class="type">Date</span> <span class="variable">birth</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Date</span>();        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; <span class="number">100</span>; i++) &#123;            numList.add(String.valueOf(i));            <span class="keyword">try</span> &#123;                Thread.sleep(<span class="number">10</span>);            &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;                e.printStackTrace();            &#125;        &#125;        System.out.println(<span class="string">&quot;数据添加完毕，请操作：&quot;</span>);        <span class="keyword">new</span> <span class="title class_">Scanner</span>(System.in).next();        numList = <span class="literal">null</span>;        birth = <span class="literal">null</span>;        System.out.println(<span class="string">&quot;numList、birth已置空，请操作：&quot;</span>);        <span class="keyword">new</span> <span class="title class_">Scanner</span>(System.in).next();        System.out.println(<span class="string">&quot;结束&quot;</span>);    &#125;&#125;</code></pre><p><strong>1、JProfiler 会话首页</strong></p><p><img src="https://raw.githubusercontent.com/GeorgeChan95/blogimg/master/img/2024/01/08/20240108-172221.png" alt="image-20240108172219593"></p><p>2、标记当前值</p><p><img src="https://raw.githubusercontent.com/GeorgeChan95/blogimg/master/img/2024/01/08/20240108-172315.png" alt="image-20240108172313546"></p><p>可以发现颜色变绿了，可以动态的看变化</p><p><img src="https://raw.githubusercontent.com/GeorgeChan95/blogimg/master/img/2024/01/08/20240108-172408.png" alt="image-20240108172407266"></p><p>3、右击对象，选择 Show Selection In Heap Walker，单独的查看某个对象</p><p><img src="https://raw.githubusercontent.com/GeorgeChan95/blogimg/master/img/2024/01/08/20240108-172535.png" alt="image-20240108172534459"></p><p><img src="https://raw.githubusercontent.com/GeorgeChan95/blogimg/master/img/2024/01/08/20240108-172600.png" alt="image-20240108172559364"></p><p>4、选择Incoming References，表示追寻 GC Roots 的源头</p><p>点击Show Paths To GC Roots，在弹出界面中选择默认设置即可</p><p><img src="https://raw.githubusercontent.com/GeorgeChan95/blogimg/master/img/2024/01/08/20240108-172709.png" alt="image-20240108172708358"></p><p><img src="https://raw.githubusercontent.com/GeorgeChan95/blogimg/master/img/2024/01/08/20240108-172802.png" alt="image-20240108172801303"></p><p><img src="https://raw.githubusercontent.com/GeorgeChan95/blogimg/master/img/2024/01/08/20240108-172825.png" alt="image-20240108172824459"></p><p><img src="https://raw.githubusercontent.com/GeorgeChan95/blogimg/master/img/2024/01/08/20240108-172855.png" alt="image-20240108172853434"></p><h3 id="4-5-JProfiler-分析-OOM"><a href="#4-5-JProfiler-分析-OOM" class="headerlink" title="4.5 JProfiler 分析 OOM"></a>4.5 JProfiler 分析 OOM</h3><blockquote><p>示例代码：注意配置 VM Options</p></blockquote><pre><code class="highlight java"><span class="comment">/**</span><span class="comment"> * -Xms8m -Xmx8m -XX:+HeapDumpOnOutOfMemoryError</span><span class="comment"> */</span><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">HeapOOM</span> &#123;    <span class="type">byte</span>[] buffer = <span class="keyword">new</span> <span class="title class_">byte</span>[<span class="number">1</span> * <span class="number">1024</span> * <span class="number">1024</span>];<span class="comment">//1MB</span>    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;        ArrayList&lt;HeapOOM&gt; list = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();        <span class="type">int</span> <span class="variable">count</span> <span class="operator">=</span> <span class="number">0</span>;        <span class="keyword">try</span>&#123;            <span class="keyword">while</span>(<span class="literal">true</span>)&#123;                list.add(<span class="keyword">new</span> <span class="title class_">HeapOOM</span>());                count++;            &#125;        &#125;<span class="keyword">catch</span> (Throwable e)&#123;            System.out.println(<span class="string">&quot;count = &quot;</span> + count);            e.printStackTrace();        &#125;    &#125;&#125;</code></pre><blockquote><p>程序输出日志</p></blockquote><pre><code class="highlight plaintext">java.lang.OutOfMemoryError: Java heap spaceDumping heap to java_pid20604.hprof ...Heap dump file created [7709884 bytes in 0.012 secs]count = 6java.lang.OutOfMemoryError: Java heap spaceat com.atguigu.java.HeapOOM.&lt;init&gt;(HeapOOM.java:9)at com.atguigu.java.HeapOOM.main(HeapOOM.java:17)</code></pre><p>打开这个dump文件</p><p>1、看这个超大对象</p><p><img src="https://raw.githubusercontent.com/GeorgeChan95/blogimg/master/img/2024/01/09/20240109-085219.png" alt="image-20240109085217582"></p><p>2、揪出 main() 线程中出问题的代码</p><p><img src="https://raw.githubusercontent.com/GeorgeChan95/blogimg/master/img/2024/01/09/20240109-085603.png" alt="image-20240109085601576"></p><p><img src="https://raw.githubusercontent.com/GeorgeChan95/blogimg/master/img/2024/01/09/20240109-085628.png" alt="image-20240109085626601"></p><h2 id="5-清除阶段：标记-清除算法"><a href="#5-清除阶段：标记-清除算法" class="headerlink" title="5. 清除阶段：标记-清除算法"></a>5. 清除阶段：标记-清除算法</h2><h3 id="5-1-垃圾清除阶段"><a href="#5-1-垃圾清除阶段" class="headerlink" title="5.1 垃圾清除阶段"></a>5.1 垃圾清除阶段</h3><p>当成功区分出内存中存活对象和死亡对象后，GC接下来的任务就是执行垃圾回收，释放掉无用对象所占用的内存空间，以便有足够的可用内存空间为新对象分配内存。目前在JVM中比较常见的三种垃圾收集算法是</p><ul><li>标记-清除算法（Mark-Sweep）</li><li>复制算法（Copying）</li><li>标记-压缩算法（Mark-Compact）</li></ul><h3 id="5-2-背景"><a href="#5-2-背景" class="headerlink" title="5.2 背景"></a>5.2 背景</h3><p>标记-清除算法（Mark-Sweep）是一种非常基础和常见的垃圾收集算法，该算法被 J.McCarthy 等人在1960年提出并并应用于Lisp语言。</p><h3 id="5-3-执行过程"><a href="#5-3-执行过程" class="headerlink" title="5.3 执行过程"></a>5.3 执行过程</h3><p>当堆中的有效内存空间（available memory）被耗尽的时候，就会停止整个程序（也被称为stop the world），然后进行两项工作，第一项则是标记，第二项则是清除。</p><ul><li>标记：Collector从引用根节点开始遍历，标记所有被引用的对象。一般是在对象的Header中记录为可达对象。<ul><li>注意：标记的是被引用的对象，也就是可达对象，并非标记的是即将被清除的垃圾对象</li></ul></li><li>清除：Collector对堆内存从头到尾进行线性的遍历，如果发现某个对象在其Header中没有标记为可达对象，则将其回收</li></ul><p> <img src="https://raw.githubusercontent.com/GeorgeChan95/blogimg/master/img/2024/01/09/20240109-100806.png" alt="image-20240109100805336"></p><h3 id="5-4-标记-清除算法的缺点"><a href="#5-4-标记-清除算法的缺点" class="headerlink" title="5.4 标记-清除算法的缺点"></a>5.4 标记-清除算法的缺点</h3><ul><li>标记清除算法的效率不算高</li><li>在进行GC的时候，需要停止整个应用程序，用户体验较差</li><li>这种方式清理出来的空闲内存是不连续的，产生内碎片，需要维护一个空闲列表</li></ul><p><strong>注意：何为清除？</strong></p><p>这里所谓的清除并不是真的置空，而是把需要清除的对象地址保存在空闲的地址列表里。下次有新对象需要加载时，判断垃圾的位置空间是否够，如果够，就存放（也就是覆盖原有的地址）。</p><p>关于空闲列表是在为对象分配内存的时候提过：</p><ul><li>如果内存规整，采用指针碰撞的方式进行内存分配</li><li>如果内存不规整，虚拟机需要维护一个空闲列表，采用空闲列表分配内存</li></ul><h2 id="6-清除阶段：复制算法"><a href="#6-清除阶段：复制算法" class="headerlink" title="6. 清除阶段：复制算法"></a>6. 清除阶段：复制算法</h2><h3 id="6-1-背景"><a href="#6-1-背景" class="headerlink" title="6.1 背景"></a>6.1 背景</h3><p>为了解决标记-清除算法在垃圾收集效率方面的缺陷，M.L.Minsky于1963年发表了著名的论文，“使用双存储区的Lisp语言垃圾收集器CA LISP Garbage Collector Algorithm Using Serial Secondary Storage）”。M.L.Minsky在该论文中描述的算法被人们称为复制（Copying）算法，它也被M.L.Minsky本人成功地引入到了Lisp语言的一个实现版本中。</p><h3 id="6-2-核心思想"><a href="#6-2-核心思想" class="headerlink" title="6.2 核心思想"></a>6.2 核心思想</h3><p>将活着的内存空间分为两块，每次只使用其中一块，在垃圾回收时将正在使用的内存中的存活对象复制到未被使用的内存块中，之后清除正在使用的内存块中的所有对象，交换两个内存的角色，最后完成垃圾回收</p><p><img src="https://raw.githubusercontent.com/GeorgeChan95/blogimg/master/img/2024/01/09/20240109-101622.png" alt="image-20240109101621409"></p><p><strong>新生代里面就用到了复制算法，Eden区和S0区存活对象整体复制到S1区</strong></p><h3 id="6-3-复制算法的优缺点"><a href="#6-3-复制算法的优缺点" class="headerlink" title="6.3 复制算法的优缺点"></a>6.3 复制算法的优缺点</h3><p><strong>优点</strong></p><ul><li>没有标记和清除过程，实现简单，运行高效</li><li>复制过去以后保证空间的连续性，不会出现“碎片”问题。</li></ul><p><strong>缺点</strong></p><ul><li>此算法的缺点也是很明显的，就是需要两倍的内存空间。</li><li>对于G1这种分拆成为大量region的GC，复制而不是移动，意味着GC需要维护region之间对象引用关系，不管是内存占用或者时间开销也不小</li></ul><h3 id="6-4-复制算法的应用场景"><a href="#6-4-复制算法的应用场景" class="headerlink" title="6.4 复制算法的应用场景"></a>6.4 复制算法的应用场景</h3><ul><li>如果系统中的垃圾对象很多，复制算法需要复制的存活对象数量并不会太大，效率较高</li><li>老年代大量的对象存活，那么复制的对象将会有很多，效率会很低</li><li>在新生代，对常规应用的垃圾回收，一次通常可以回收70% - 99% 的内存空间。回收性价比很高。所以现在的商业虚拟机都是用这种收集算法回收新生代。</li></ul><p><img src="https://raw.githubusercontent.com/GeorgeChan95/blogimg/master/img/2024/01/09/20240109-101943.png" alt="image-20240109101942056"></p><h2 id="7-清除阶段：标记-压缩算法"><a href="#7-清除阶段：标记-压缩算法" class="headerlink" title="7. 清除阶段：标记-压缩算法"></a>7. 清除阶段：标记-压缩算法</h2><p><strong>标记-压缩（或标记-整理、Mark - Compact）算法</strong></p><h3 id="7-1-背景"><a href="#7-1-背景" class="headerlink" title="7.1 背景"></a>7.1 背景</h3><ul><li>复制算法的高效性是建立在存活对象少、垃圾对象多的前提下的。这种情况在新生代经常发生，但是在老年代，更常见的情况是大部分对象都是存活对象。如果依然使用复制算法，由于存活对象较多，复制的成本也将很高。因此，<strong>基于老年代垃圾回收的特性，需要使用其他的算法。</strong></li><li>标记-清除算法的确可以应用在老年代中，但是该算法不仅执行效率低下，而且在执行完内存回收后还会产生内存碎片，所以JVM的设计者需要在此基础之上进行改进。标记-压缩（Mark-Compact）算法由此诞生。</li><li>1970年前后，G.L.Steele、C.J.Chene和D.s.Wise等研究者发布标记-压缩算法。在许多现代的垃圾收集器中，人们都使用了标记-压缩算法或其改进版本。</li></ul><h3 id="7-2-执行过程"><a href="#7-2-执行过程" class="headerlink" title="7.2 执行过程"></a>7.2 执行过程</h3><ul><li>第一阶段和标记清除算法一样，从根节点开始标记所有被引用对象</li><li>第二阶段将所有的存活对象压缩到内存的一端，按顺序排放。之后，清理边界外所有的空间。</li></ul><p><img src="https://raw.githubusercontent.com/GeorgeChan95/blogimg/master/img/2024/01/09/20240109-102715.png" alt="image-20240109102714067"></p><h3 id="7-3-标记-压缩算法与标记-清除算法的比较"><a href="#7-3-标记-压缩算法与标记-清除算法的比较" class="headerlink" title="7.3 标记-压缩算法与标记-清除算法的比较"></a>7.3 标记-压缩算法与标记-清除算法的比较</h3><ul><li>标记-压缩算法的最终效果等同于标记-清除算法执行完成后，再进行一次内存碎片整理，因此，也可以把它称为标记-清除-压缩（Mark-Sweep-Compact）算法。</li><li>二者的本质差异在于标记-清除算法是一种<strong>非移动式的回收算法</strong>，标记-压缩是<strong>移动式的</strong>。是否移动回收后的存活对象是一项优缺点并存的风险决策。</li><li>可以看到，标记的存活对象将会被整理，按照内存地址依次排列，而未被标记的内存会被清理掉。如此一来，当我们需要给新对象分配内存时，JVM只需要持有一个内存的起始地址即可，这比维护一个空闲列表显然少了许多开销。</li></ul><h3 id="7-4-标记-压缩算法的优缺点"><a href="#7-4-标记-压缩算法的优缺点" class="headerlink" title="7.4 标记-压缩算法的优缺点"></a>7.4 标记-压缩算法的优缺点</h3><p><strong>优点</strong></p><ul><li>消除了标记-清除算法当中，内存区域分散的缺点，我们需要给新对象分配内存时，JVM只需要持有一个内存的起始地址即可。</li><li>消除了复制算法当中，内存减半的高额代价。</li></ul><p><strong>缺点</strong></p><ul><li>移动对象的同时，如果对象被其他对象引用，则还需要调整引用的地址（因为HotSpot虚拟机采用的不是句柄池的方式，而是直接指针）</li><li>移动过程中，需要全程暂停用户应用程序。即：STW</li></ul><h2 id="8-垃圾回收算法小结"><a href="#8-垃圾回收算法小结" class="headerlink" title="8. 垃圾回收算法小结"></a>8. 垃圾回收算法小结</h2><p><strong>对比三种清除阶段的算法</strong></p><ul><li>效率上来说，复制算法是当之无愧的老大，但是却浪费了太多内存。</li><li>而为了尽量兼顾上面提到的三个指标，标记-整理算法相对来说更平滑一些，但是效率上不尽如人意，它比复制算法多了一个标记的阶段，比标记-清除多了一个整理内存的阶段。</li></ul><table><thead><tr><th></th><th>标记清除</th><th>标记整理</th><th>复制</th></tr></thead><tbody><tr><td><strong>速率</strong></td><td>中等</td><td>最慢</td><td>最快</td></tr><tr><td><strong>空间开销</strong></td><td>少（但会堆积碎片）</td><td>少（不堆积碎片）</td><td>通常需要活对象的2倍空间（不堆积碎片）</td></tr><tr><td><strong>移动对象</strong></td><td>否</td><td>是</td><td>是</td></tr></tbody></table><h2 id="9-分代收集算法"><a href="#9-分代收集算法" class="headerlink" title="9. 分代收集算法"></a>9. 分代收集算法</h2><p>Q：难道就没有一种最优的算法吗？</p><p>A：无，没有最好的算法，只有最合适的算法</p><p><strong>为什么要使用分代收集算法</strong></p><ul><li>前面所有这些算法中，并没有一种算法可以完全替代其他算法，它们都具有自己独特的优势和特点。分代收集算法应运而生。</li><li>分代收集算法，是基于这样一个事实：<strong>不同的对象的生命周期是不一样的。因此，不同生命周期的对象可以采取不同的收集方式，以便提高回收效率。</strong>一般是把Java堆分为新生代和老年代，这样就可以根据各个年代的特点使用不同的回收算法，以提高垃圾回收的效率。</li><li>在Java程序运行的过程中，会产生大量的对象，其中有些对象是与业务信息相关:<ul><li>比如Http请求中的Session对象、线程、Socket连接，这类对象跟业务直接挂钩，因此生命周期比较长。</li><li>但是还有一些对象，主要是程序运行过程中生成的临时变量，这些对象生命周期会比较短，比如：String对象，由于其不变类的特性，系统会产生大量的这些对象，有些对象甚至只用一次即可回收。</li></ul></li></ul><p><strong>目前几乎所有的GC都采用分代收集算法执行垃圾回收的</strong></p><p>在HotSpot中，基于分代的概念，GC所使用的内存回收算法必须结合年轻代和老年代各自的特点。</p><ul><li><p>年轻代（Young Gen）</p><ul><li>年轻代特点：区域相对老年代较小，对象生命周期短、存活率低，回收频繁。</li><li>这种情况复制算法的回收整理，速度是最快的。复制算法的效率只和当前存活对象大小有关，因此很适用于年轻代的回收。而复制算法内存利用率不高的问题，通过hotspot中的两个survivor的设计得到缓解。</li></ul></li><li><p>老年代（Tenured Gen）</p><ul><li>老年代特点：区域较大，对象生命周期长、存活率高，回收不及年轻代频繁。</li><li>这种情况存在大量存活率高的对象，复制算法明显变得不合适。一般是由标记-清除或者是标记-清除与标记-整理的混合实现。<ul><li>Mark阶段的开销与存活对象的数量成正比。</li><li>Sweep阶段的开销与所管理区域的大小成正相关。</li><li>Compact阶段的开销与存活对象的数据成正比。</li></ul></li></ul></li><li><p>以HotSpot中的CMS回收器为例，CMS是基于Mark-Sweep实现的，对于对象的回收效率很高。对于碎片问题，CMS采用基于Mark-Compact算法的Serial Old回收器作为补偿措施：当内存回收不佳（碎片导致的Concurrent Mode Failure时），将采用Serial Old执行Full GC以达到对老年代内存的整理。</p></li><li><p>分代的思想被现有的虚拟机广泛使用。几乎所有的垃圾回收器都区分新生代和老年代</p></li></ul><h2 id="10-增量收集算法和分区算法"><a href="#10-增量收集算法和分区算法" class="headerlink" title="10. 增量收集算法和分区算法"></a>10. 增量收集算法和分区算法</h2><h3 id="10-1-增量收集算法"><a href="#10-1-增量收集算法" class="headerlink" title="10.1 增量收集算法"></a>10.1 增量收集算法</h3><p>上述现有的算法，在垃圾回收过程中，应用软件将处于一种Stop the World的状态。在<strong>Stop the World</strong>状态下，应用程序所有的线程都会挂起，暂停一切正常的工作，等待垃圾回收的完成。如果垃圾回收时间过长，应用程序会被挂起很久，将严重影响用户体验或者系统的稳定性。为了解决这个问题，即对实时垃圾收集算法的研究直接导致了增量收集（Incremental Collecting）算法的诞生。</p><h4 id="10-1-1-增量收集算法基本思想"><a href="#10-1-1-增量收集算法基本思想" class="headerlink" title="10.1.1 增量收集算法基本思想"></a>10.1.1 增量收集算法基本思想</h4><p>如果一次性将所有的垃圾进行处理，需要造成系统长时间的停顿，那么就可以让垃圾收集线程和应用程序线程交替执行。<strong>每次，垃圾收集线程只收集一小片区域的内存空间，接着切换到应用程序线程。依次反复，直到垃圾收集完成。</strong></p><p>总的来说，增量收集算法的基础仍是传统的标记-清除和复制算法。增量收集算法通过<strong>对线程间冲突的妥善处理，允许垃圾收集线程以分阶段的方式完成标记、清理或复制工作</strong></p><p><strong>增量收集算法的缺点</strong></p><p>使用这种方式，由于在垃圾回收过程中，间断性地还执行了应用程序代码，所以能减少系统的停顿时间。但是，因为线程切换和上下文转换的消耗，会使得垃圾回收的总体成本上升，<strong>造成系统吞吐量的下降</strong>。</p><h3 id="10-2-分区算法"><a href="#10-2-分区算法" class="headerlink" title="10.2 分区算法"></a>10.2 分区算法</h3><blockquote><p>主要针对G1收集器来说的</p></blockquote><ul><li>一般来说，在相同条件下，堆空间越大，一次GC时所需要的时间就越长，有关GC产生的停顿也越长。为了更好地控制GC产生的停顿时间，将一块大的内存区域分割成多个小块，根据目标的停顿时间，每次合理地回收若干个小区间，而不是整个堆空间，从而减少一次GC所产生的停顿。</li><li>分代算法将按照对象的生命周期长短划分成两个部分，分区算法将整个堆空间划分成连续的不同小区间。每一个小区间都独立使用，独立回收。这种算法的好处是可以控制一次回收多少个小区间。</li></ul><p><img src="https://raw.githubusercontent.com/GeorgeChan95/blogimg/master/img/2024/01/09/20240109-110825.png" alt="image-20240109110824025"></p><p><strong>注意，这些只是基本的算法思路，实际GC实现过程要复杂的多，目前还在发展中的前沿GC都是复合算法，并且并行和并发兼备。</strong></p><h1 id="参考链接"><a href="#参考链接" class="headerlink" title="参考链接"></a>参考链接</h1><blockquote><p>关于GC roots ：<a href="https://blog.csdn.net/weixin_41910694/article/details/90706652">https://blog.csdn.net/weixin_41910694/article/details/90706652</a></p><p>MAT内存分析工具下载地址：<a href="https://eclipse.dev/mat/downloads.php">https://eclipse.dev/mat/downloads.php</a> 使用 1.6.0 或 1.6.1 版本</p><p>Jprofile 下载：<a href="https://www.ej-technologies.com/download/jprofiler/files">https://www.ej-technologies.com/download/jprofiler/files</a></p></blockquote>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;一、垃圾回收概述&quot;&gt;&lt;a href=&quot;#一、垃圾回收概述&quot; class=&quot;headerlink&quot; title=&quot;一、垃圾回收概述&quot;&gt;&lt;/a&gt;一、垃圾回收概述&lt;/h1&gt;&lt;p&gt;​	&lt;img src=&quot;https://raw.githubusercontent.com/</summary>
      
    
    
    
    <category term="JVM" scheme="https://georgechan95.github.io/categories/JVM/"/>
    
    
    <category term="jvm" scheme="https://georgechan95.github.io/tags/jvm/"/>
    
    <category term="java" scheme="https://georgechan95.github.io/tags/java/"/>
    
  </entry>
  
  <entry>
    <title>Jenkins的安装和搭建自动化部署平台</title>
    <link href="https://georgechan95.github.io/2024/01/05/linux/Jenkins%E7%9A%84%E5%AE%89%E8%A3%85%E5%92%8C%E5%9F%BA%E7%A1%80%E4%BD%BF%E7%94%A8/"/>
    <id>https://georgechan95.github.io/2024/01/05/linux/Jenkins%E7%9A%84%E5%AE%89%E8%A3%85%E5%92%8C%E5%9F%BA%E7%A1%80%E4%BD%BF%E7%94%A8/</id>
    <published>2024-01-05T08:00:00.000Z</published>
    <updated>2024-06-22T10:36:12.823Z</updated>
    
    <content type="html"><![CDATA[<h1 style="text-align: center;">Jenkins的安装和搭建自动化部署平台</h1><h1 id="环境"><a href="#环境" class="headerlink" title="环境"></a>环境</h1><blockquote><p>操作系统：Ubuntu 18.04.6 LTS</p><p>内核版本：5.4.0-149-generic</p><p>Docker版本：24.0.2</p><p>Docker Compose 版本：v2.18.0</p><p>Jenkins 版本：2.393-alpine</p><p>JDK 版本：java 11.0.19 2023-04-18 LTS</p><p>Git 版本：2.28.0</p><p>Maven 版本：3.6.3</p><p>Node JS 版本：16.16.0</p><p>Jenkins主节点：192.168.6.92</p><p>Jenkins agent节点：192.168.6.91</p></blockquote><h1 id="一、Jenkins官网"><a href="#一、Jenkins官网" class="headerlink" title="一、Jenkins官网"></a>一、Jenkins官网</h1><ul><li>英文官网<ul><li><a href="https://www.jenkins.io/">https://www.jenkins.io/</a></li></ul></li><li>英文官方文档<ul><li><a href="https://www.jenkins.io/doc/">https://www.jenkins.io/doc/</a></li></ul></li><li>中文官网<ul><li><a href="https://www.jenkins.io/zh/">https://www.jenkins.io/zh/</a></li></ul></li><li>中文官方文档<ul><li><a href="https://www.jenkins.io/zh/doc/">https://www.jenkins.io/zh/doc/</a></li></ul></li><li>Docker Hub网址 (存放Jenkins官方镜像)<ul><li><a href="https://hub.docker.com/r/jenkins/jenkins">https://hub.docker.com/r/jenkins/jenkins</a></li></ul></li></ul><h1 id="二、Jenkins概述"><a href="#二、Jenkins概述" class="headerlink" title="二、Jenkins概述"></a>二、Jenkins概述</h1><p>持续集成（CI）是一种开发实践，其中开发人员经常（最好每天几次）将代码集成到共享存储库中。然后可以通过自动构建和自动测试来验证每个集成。尽管自动化测试不是严格意义上的CI的一部分，但通常隐含了它。</p><p>定期集成的主要好处之一是，您可以快速检测到错误并更轻松地定位它们。由于引入的每个更改通常很小，因此可以快速查明引入缺陷的特定更改。</p><p>近年来，CI已成为软件开发的最佳实践，并遵循一系列关键原则。其中包括版本控制，构建自动化和自动化测试。</p><p>此外，持续部署和持续交付已成为<strong>最佳实践</strong>，可让您随时随地部署应用程序，甚至在每次引入新更改时甚至将主代码库自动推入生产环境。这使您的团队可以快速行动，同时保持可以自动检查的高质量标准。</p><p><img src="https://raw.githubusercontent.com/GeorgeChan95/blogimg/master/img/2024/01/05/20240105-155739.png" alt="image-20240105155737704"></p><p>CI&#x2F;CD应用场景：</p><ul><li>开发人员将本地代码上传gitlab版本服务器</li><li>jenkins通过webhook插件自动到gitlab服务器拉取最新代码</li><li>通过docker-maven-plugin插件自动编译代码</li><li>将自定义镜像上传docker私服仓库</li><li>k8s集群自动拉取最新版本镜像</li><li>自动化部署整个项目</li><li>用户通过nginx负载均衡访问整个项目</li></ul><p><img src="https://raw.githubusercontent.com/GeorgeChan95/blogimg/master/img/2024/01/05/20240105-155828.png" alt="image-20240105155826829"></p><h1 id="三、Jenkins的部署"><a href="#三、Jenkins的部署" class="headerlink" title="三、Jenkins的部署"></a>三、Jenkins的部署</h1><h2 id="使用Docker部署Jenkins"><a href="#使用Docker部署Jenkins" class="headerlink" title="使用Docker部署Jenkins"></a>使用Docker部署Jenkins</h2><pre><code class="highlight shell"><span class="meta prompt_"># </span><span class="language-bash">拉取镜像</span>docker pull jenkins/jenkins:2.393-alpine<span class="meta prompt_"></span><span class="meta prompt_"># </span><span class="language-bash">创建映射目录，并给目录授权</span>mkdir -p /data/jenkins &amp;&amp; chown -R 1000:1000 /data/jenkins<span class="meta prompt_"></span><span class="meta prompt_"></span><span class="meta prompt_"># </span><span class="language-bash">运行容器</span>docker run -itd \    --name jenkins \-p 8080:8080 \-p 50000:50000 \-u root \-e JAVA_OPTS=-Duser.timezone=Asia/Shanghai \--restart always \-v /data/jenkins/:/var/jenkins_home/ \    jenkins/jenkins:2.393-alpine    <span class="meta prompt_"># </span><span class="language-bash">查看容器启动日志并找到jenkins初始化密码</span>docker logs -f jenkins</code></pre><p><img src="https://raw.githubusercontent.com/GeorgeChan95/blogimg/master/img/2024/01/04/20240104-104424.png" alt="image-20240104104421050"></p><h2 id="浏览器访问Jenkins"><a href="#浏览器访问Jenkins" class="headerlink" title="浏览器访问Jenkins"></a>浏览器访问Jenkins</h2><p><img src="https://raw.githubusercontent.com/GeorgeChan95/blogimg/master/img/2024/01/04/20240104-104613.png" alt="image-20240104104612435"></p><h2 id="安装Jenkins插件"><a href="#安装Jenkins插件" class="headerlink" title="安装Jenkins插件"></a>安装Jenkins插件</h2><p><img src="https://raw.githubusercontent.com/GeorgeChan95/blogimg/master/img/2024/01/04/20240104-104738.png" alt="image-20240104104736736"></p><p><img src="https://raw.githubusercontent.com/GeorgeChan95/blogimg/master/img/2024/01/04/20240104-104809.png" alt="image-20240104104807803"></p><p><strong>插件安装完成</strong></p><p><img src="https://raw.githubusercontent.com/GeorgeChan95/blogimg/master/img/2024/01/04/20240104-105110.png" alt="image-20240104105108610"></p><h2 id="创建管理员账户"><a href="#创建管理员账户" class="headerlink" title="创建管理员账户"></a>创建管理员账户</h2><p><img src="https://raw.githubusercontent.com/GeorgeChan95/blogimg/master/img/2024/01/04/20240104-105201.png" alt="image-20240104105159836"></p><h2 id="配置实例"><a href="#配置实例" class="headerlink" title="配置实例"></a>配置实例</h2><p><img src="https://raw.githubusercontent.com/GeorgeChan95/blogimg/master/img/2024/01/04/20240104-105233.png" alt="image-20240104105231800"></p><h2 id="安装完成"><a href="#安装完成" class="headerlink" title="安装完成"></a><strong>安装完成</strong></h2><p><img src="https://raw.githubusercontent.com/GeorgeChan95/blogimg/master/img/2024/01/04/20240104-105249.png" alt="image-20240104105247735"></p><h1 id="四、Jenkins设置中文支持"><a href="#四、Jenkins设置中文支持" class="headerlink" title="四、Jenkins设置中文支持"></a>四、Jenkins设置中文支持</h1><h2 id="1-点击-Manage-Jenkins"><a href="#1-点击-Manage-Jenkins" class="headerlink" title="1. 点击 Manage Jenkins"></a>1. 点击 Manage Jenkins</h2><p><img src="https://raw.githubusercontent.com/GeorgeChan95/blogimg/master/img/2024/01/04/20240104-110445.png" alt="image-20240104110443683"></p><h2 id="2-点击Manage-Plugins"><a href="#2-点击Manage-Plugins" class="headerlink" title="2. 点击Manage Plugins"></a>2. 点击Manage Plugins</h2><p><img src="https://raw.githubusercontent.com/GeorgeChan95/blogimg/master/img/2024/01/04/20240104-110500.png" alt="image-20240104110458889"></p><h2 id="3-搜索并安装-locale-插件"><a href="#3-搜索并安装-locale-插件" class="headerlink" title="3. 搜索并安装 locale 插件"></a>3. 搜索并安装 locale 插件</h2><p><img src="https://raw.githubusercontent.com/GeorgeChan95/blogimg/master/img/2024/01/04/20240104-110604.png" alt="image-20240104110602657"></p><h2 id="4-安装完成后重启-Jenkins"><a href="#4-安装完成后重启-Jenkins" class="headerlink" title="4. 安装完成后重启 Jenkins"></a>4. 安装完成后重启 Jenkins</h2><p><img src="https://raw.githubusercontent.com/GeorgeChan95/blogimg/master/img/2024/01/04/20240104-110720.png" alt="image-20240104110719409"></p><pre><code class="highlight shell"><span class="meta prompt_"># </span><span class="language-bash">重启Jenkins</span>docker restart jenkins</code></pre><h2 id="5-验证"><a href="#5-验证" class="headerlink" title="5. 验证"></a>5. 验证</h2><p><strong>此时再次重新登录Jenkins，发现已变成中文了，这是由于Locale插件自动根据浏览器语言设置，切换对应的语言支持。</strong></p><p><img src="https://raw.githubusercontent.com/GeorgeChan95/blogimg/master/img/2024/01/04/20240104-111024.png" alt="image-20240104111022563"></p><h1 id="五、Jenkins初体验"><a href="#五、Jenkins初体验" class="headerlink" title="五、Jenkins初体验"></a>五、Jenkins初体验</h1><h2 id="1-自由风格项目"><a href="#1-自由风格项目" class="headerlink" title="1. 自由风格项目"></a>1. 自由风格项目</h2><ol><li>点击 <code>新建任务</code></li></ol><p><img src="https://raw.githubusercontent.com/GeorgeChan95/blogimg/master/img/2024/01/04/20240104-135232.png" alt="image-20240104135230836"></p><ol><li>填写 <code>任务名称</code></li><li>选择 <code>构建一个自由风格的软件项目</code></li><li>点击 <code>确定</code></li></ol><p><img src="https://raw.githubusercontent.com/GeorgeChan95/blogimg/master/img/2024/01/04/20240104-135331.png" alt="image-20240104135329889"></p><ul><li>添加构建步骤，选择 执行shell</li><li>填写shell命令</li><li>点击 保存</li></ul><p><img src="https://raw.githubusercontent.com/GeorgeChan95/blogimg/master/img/2024/01/04/20240104-152628.png" alt="image-20240104152627088"></p><ul><li>点击 立即构建 ，查看执行结果</li></ul><p><img src="https://raw.githubusercontent.com/GeorgeChan95/blogimg/master/img/2024/01/04/20240104-143757.png" alt="image-20240104143756241"></p><p><img src="https://raw.githubusercontent.com/GeorgeChan95/blogimg/master/img/2024/01/04/20240104-152825.png" alt="image-20240104152823887"></p><ul><li>查看控制台输出</li></ul><p><img src="https://raw.githubusercontent.com/GeorgeChan95/blogimg/master/img/2024/01/04/20240104-152843.png" alt="image-20240104152841553"></p><p>这里需要了解一点：</p><p>之所以可以执行 <code>java --version </code> 和 <code>git --version</code> 指令，是因为Jenkins容器内部已安装了该工具，没有安装了工具，执行就会报错，比如：<code>mvn --version</code>, Jenkins容器内部默认是没有安装Maven的。</p><h2 id="2-流水线项目"><a href="#2-流水线项目" class="headerlink" title="2. 流水线项目"></a>2. 流水线项目</h2><h3 id="2-1-安装插件"><a href="#2-1-安装插件" class="headerlink" title="2.1 安装插件"></a>2.1 安装插件</h3><p>流水线任务需要**<code>Pipeline插件</code>**的支持，在创建流水线任务之前，先确保Jenkins已安装 <code>Pipeline插件</code> 。</p><p>具体在：Dashboard –&gt; 系统管理 –&gt; 插件管理 中安装</p><p><img src="https://raw.githubusercontent.com/GeorgeChan95/blogimg/master/img/2024/01/04/20240104-154146.png" alt="image-20240104154145155"></p><h3 id="2-2-配置流水线任务"><a href="#2-2-配置流水线任务" class="headerlink" title="2.2 配置流水线任务"></a>2.2 配置流水线任务</h3><ol><li>填写 <code>任务名称</code></li><li>选择 <code>构建一个Pipeline项目</code></li><li>点击 <code>确定</code></li></ol><p><img src="https://raw.githubusercontent.com/GeorgeChan95/blogimg/master/img/2024/01/04/20240104-154701.png" alt="image-20240104154700551"></p><pre><code class="highlight plaintext"></code></pre><ul><li>编辑脚本，点击 <code>保存</code></li></ul><p><img src="https://raw.githubusercontent.com/GeorgeChan95/blogimg/master/img/2024/01/04/20240104-154520.png" alt="image-20240104154518639"></p><ul><li>运行任务，查看运行结果</li></ul><p><img src="https://raw.githubusercontent.com/GeorgeChan95/blogimg/master/img/2024/01/04/20240104-154549.png" alt="image-20240104154548082"></p><h1 id="六、Jenkins部署运维后端代码"><a href="#六、Jenkins部署运维后端代码" class="headerlink" title="六、Jenkins部署运维后端代码"></a>六、Jenkins部署运维后端代码</h1><blockquote><p><strong>操作步骤</strong></p><ul><li>指定部署节点<ul><li>部署节点为Jenkins服务所在节点的从节点，也叫：代理节点</li><li>主节点与代理节点之间通过SSH方式连接</li></ul></li><li>代理节点拉取代码<ul><li>代理节点需要安装Git</li></ul></li><li>代理节点将打包打成jar包<ul><li>代理节点需要安装Maven、JDK</li></ul></li><li>代理节点将Jar包制作成Docker镜像<ul><li>代理节点需要安装Docker</li></ul></li><li>代理节点运行docker镜像<ul><li>通过shell命令行</li></ul></li></ul></blockquote><h2 id="1-代理节点配置软连接"><a href="#1-代理节点配置软连接" class="headerlink" title="1. 代理节点配置软连接"></a>1. 代理节点配置软连接</h2><p>master节点ssh连接agent节点时需要&#x2F;usr&#x2F;bin&#x2F;有java命令。配置java的软连接、同理配置maven、git的软连接。如果软件是yum安装的，则需要检查&#x2F;usr&#x2F;bin中是否有相关命令。如果没有,也需要做软连接。</p><pre><code class="highlight shell">ln -s /opt/module/jdk-11.0.19/bin/java /usr/bin/ln -s /opt/module/apache-maven-3.6.3/bin/mvn /usr/bin/ln -s /opt/module/git/bin/git /usr/bin/</code></pre><h2 id="2-添加代理节点"><a href="#2-添加代理节点" class="headerlink" title="2. 添加代理节点"></a>2. 添加代理节点</h2><h3 id="2-1-进入节点列表页面"><a href="#2-1-进入节点列表页面" class="headerlink" title="2.1 进入节点列表页面"></a>2.1 进入节点列表页面</h3><ul><li>点击 <strong>系统管理</strong></li><li>点击 <strong>节点列表</strong></li></ul><p><img src="https://raw.githubusercontent.com/GeorgeChan95/blogimg/master/img/2024/01/04/20240104-160922.png" alt="image-20240104160920865"></p><h3 id="2-2-添加节点"><a href="#2-2-添加节点" class="headerlink" title="2.2 添加节点"></a>2.2 添加节点</h3><ul><li>点击 <strong>新建节点</strong></li></ul><p><img src="https://raw.githubusercontent.com/GeorgeChan95/blogimg/master/img/2024/01/04/20240104-161402.png" alt="20240104-161007"></p><h3 id="2-3-编辑节点名称和属性"><a href="#2-3-编辑节点名称和属性" class="headerlink" title="2.3 编辑节点名称和属性"></a>2.3 编辑节点名称和属性</h3><ul><li>填写 <strong>节点名称</strong></li><li>选择 <strong>固定节点</strong></li><li>点击 <strong>创建</strong></li></ul><p><img src="https://raw.githubusercontent.com/GeorgeChan95/blogimg/master/img/2024/01/04/20240104-161048.png" alt="image-20240104161046707"></p><h3 id="2-4-配置节点"><a href="#2-4-配置节点" class="headerlink" title="2.4 配置节点"></a>2.4 配置节点</h3><ul><li><p>名称：填写节点名称，用于展示</p></li><li><p>描述：填写节点描述，可不填</p></li><li><p>执行器数量：最小是1，建议跟服务器内核数一致。</p></li><li><p>远程工作目录：Jenkins运行的目录，提前在代理服务器上创建好</p><pre><code class="highlight shell"><span class="meta prompt_"># </span><span class="language-bash">在代理节点上创建工作目录</span>mkdir -p /data/workspaces</code></pre></li><li><p>标签：代理节点的标签，也是代理节点的唯一标识</p></li><li><p>用法：选择 仅在此节点上运行</p></li><li><p>启动方式：选择 <code>Launch agents via SSH</code></p><ul><li>主机：代理节点IP</li><li>凭据：选择给代理节点配置的凭据，没有则点击下方的 <code>添加</code> 按钮创建凭据</li><li>主机验证方式：选择 <code>Non verifying Verification Strategy</code></li></ul></li><li><p>可用性：选择 <code>尽可能在此节点上运行</code></p></li><li><p>点击 <code>保存</code></p></li></ul><p><img src="https://raw.githubusercontent.com/GeorgeChan95/blogimg/master/img/2024/01/05/20240105-094026.png" alt="image-20240105094022222"></p><p><img src="https://raw.githubusercontent.com/GeorgeChan95/blogimg/master/img/2024/01/05/20240105-094041.png" alt="image-20240105094040027"></p><h3 id="2-5-添加凭据"><a href="#2-5-添加凭据" class="headerlink" title="2.5 添加凭据"></a>2.5 添加凭据</h3><ol><li><p>在节点配置页面点击 <code>添加</code> 按钮</p><p><img src="https://raw.githubusercontent.com/GeorgeChan95/blogimg/master/img/2024/01/05/20240105-095652.png" alt="image-20240105095650742"></p></li><li><p>点击 <code>Jenkins</code> 进入凭据配置页面</p><ol><li><p>作用域：选择 <code>全局凭据</code></p></li><li><p>类型：选择 <code>SSH Username with private key</code></p></li><li><p>范围：全局</p></li><li><p>ID：不用填，配置完成保存后会自动生成</p></li><li><p>描述：凭据的描述，可不填</p></li><li><p>Username：代理节点的root用户密码</p></li><li><p>Private Key：对应的就是Jenkins主节点生成的私钥信息</p><ol><li><p>勾选 <code>Enter directly</code></p></li><li><p>输入Jenkins主节点完整的私钥信息</p></li><li><p>这里首先要配置主节点与代理节点的免密登录，具体方式如下：</p><pre><code class="highlight shell"><span class="meta prompt_"># </span><span class="language-bash">在master节点生成密钥</span>ssh-keygen -t rsa<span class="meta prompt_"></span><span class="meta prompt_"># </span><span class="language-bash">复制公钥到agent节点</span>ssh-copy-id -i /root/.ssh/id_rsa.pub root@192.168.6.91<span class="meta prompt_"></span><span class="meta prompt_"># </span><span class="language-bash">免密登录测试</span>ssh 192.168.6.91<span class="meta prompt_"></span><span class="meta prompt_"># </span><span class="language-bash">查看私钥信息(主节点执行)</span>cat /root/.ssh/id_rsa</code></pre></li></ol></li><li><p>密码：填写代理服务器root用户登录密码</p></li></ol><p><img src="https://raw.githubusercontent.com/GeorgeChan95/blogimg/master/img/2024/01/05/20240105-100853.png" alt="image-20240105100852505"></p><p><img src="https://raw.githubusercontent.com/GeorgeChan95/blogimg/master/img/2024/01/05/20240105-100910.png" alt="image-20240105100909305"></p></li><li><p>点击 <code>添加</code>，保存凭据</p><p>此时在 代理节点配置页面，就可以勾选刚才配置的凭据信息了</p><p><img src="https://raw.githubusercontent.com/GeorgeChan95/blogimg/master/img/2024/01/05/20240105-101018.png" alt="image-20240105101017536"></p></li></ol><h2 id="3-配置Gitlab凭据"><a href="#3-配置Gitlab凭据" class="headerlink" title="3. 配置Gitlab凭据"></a>3. 配置Gitlab凭据</h2><p>Jenkins工作台 –&gt; 系统管理 –&gt; credentials –&gt; 在Stores scoped to Jenkins下的’全局’ –&gt; 添加凭据</p><ul><li>类型：Username with password </li><li>范围：全局</li><li>用户名：登录Gitlab的用户名 </li><li>密码：登录Gitlab的密码 </li><li>ID：不用填，自动生成 </li><li>描述：可不填</li></ul><p><img src="https://raw.githubusercontent.com/GeorgeChan95/blogimg/master/img/2024/01/05/20240105-104816.png" alt="image-20240105104814964"></p><p><img src="https://raw.githubusercontent.com/GeorgeChan95/blogimg/master/img/2024/01/05/20240105-104854.png" alt="image-20240105104853462"></p><p><img src="https://raw.githubusercontent.com/GeorgeChan95/blogimg/master/img/2024/01/05/20240105-105426.png" alt="image-20240105105424488"></p><h2 id="4-配置Pipeline流水线任务"><a href="#4-配置Pipeline流水线任务" class="headerlink" title="4. 配置Pipeline流水线任务"></a>4. 配置Pipeline流水线任务</h2><h3 id="4-1-新建任务"><a href="#4-1-新建任务" class="headerlink" title="4.1 新建任务"></a>4.1 新建任务</h3><p><img src="https://raw.githubusercontent.com/GeorgeChan95/blogimg/master/img/2024/01/05/20240105-110053.png" alt="image-20240105110052243"></p><h3 id="4-2-配置任务"><a href="#4-2-配置任务" class="headerlink" title="4.2 配置任务"></a>4.2 配置任务</h3><ul><li><p>定义：选择 <code>Pipeline script from SCM</code></p><ul><li>SCM: 选择 Git</li><li>Repository URL：填写项目Git地址</li><li>凭据：选择gitlab登录凭据，没有则添加</li><li>构建分支：默认Master分支</li><li>源码库浏览器：自动</li></ul></li><li><p>脚本路径：Jenkinsfile (名称不要改，使用默认的)</p><p><img src="https://raw.githubusercontent.com/GeorgeChan95/blogimg/master/img/2024/01/05/20240105-135233.png" alt="image-20240105135231905"></p><p><img src="https://raw.githubusercontent.com/GeorgeChan95/blogimg/master/img/2024/01/05/20240105-135247.png" alt="image-20240105135246088"></p></li><li><p>添加Gitlab凭据</p><ul><li><p>任务配置页面，<code>凭据</code> 下点击 <code>添加</code>  </p></li><li><p>凭据页面配置如下：</p><ul><li>Domain：全局</li><li>类型：Username with password</li><li>范围：全局</li><li>用户名：root</li><li>密码：root用户密码</li><li>ID：不用填，会自动生成</li><li>描述：可不填</li></ul><p><img src="https://raw.githubusercontent.com/GeorgeChan95/blogimg/master/img/2024/01/05/20240105-135134.png" alt="image-20240105135133467"></p><p><img src="https://raw.githubusercontent.com/GeorgeChan95/blogimg/master/img/2024/01/05/20240105-135150.png" alt="image-20240105135149397"></p></li></ul></li></ul><h2 id="5-编辑-Jenkinsfile-文件"><a href="#5-编辑-Jenkinsfile-文件" class="headerlink" title="5. 编辑 Jenkinsfile 文件"></a>5. 编辑 Jenkinsfile 文件</h2><ul><li>该文件名称必须为 Jenkinsfile ,大小写要完全一致</li><li>该文件要在项目的根路径下</li><li>文件内容使用按照流水线格式，采用Groovy语法编写，可使用 <code>流水线语法</code> 生成器生成片段</li></ul><h3 id="5-1-流水线语法生成器"><a href="#5-1-流水线语法生成器" class="headerlink" title="5.1 流水线语法生成器"></a>5.1 流水线语法生成器</h3><p>在流水线任务配置页面，下拉到页面最下方，点击 <code>流水线语法</code> ，打开流水线语法生成页面。</p><p><img src="https://raw.githubusercontent.com/GeorgeChan95/blogimg/master/img/2024/01/05/20240105-135904.png" alt="image-20240105135903283"></p><p><img src="https://raw.githubusercontent.com/GeorgeChan95/blogimg/master/img/2024/01/05/20240105-135919.png" alt="image-20240105135918483"></p><h4 id="5-1-1-实例：生成git-拉取代码指令"><a href="#5-1-1-实例：生成git-拉取代码指令" class="headerlink" title="5.1.1 实例：生成git 拉取代码指令"></a>5.1.1 实例：生成git 拉取代码指令</h4><p><img src="https://raw.githubusercontent.com/GeorgeChan95/blogimg/master/img/2024/01/05/20240105-140209.png" alt="image-20240105140207616"></p><p><img src="https://raw.githubusercontent.com/GeorgeChan95/blogimg/master/img/2024/01/05/20240105-140254.png" alt="image-20240105140253107"></p><h3 id="5-2-Jenkinsfile-内容如下"><a href="#5-2-Jenkinsfile-内容如下" class="headerlink" title="5.2 Jenkinsfile 内容如下"></a>5.2 Jenkinsfile 内容如下</h3><pre><code class="highlight groovy">pipeline &#123;    agent &#123;        label <span class="string">&#x27;agent-6-91&#x27;</span>    &#125;    stages &#123;        stage(<span class="string">&#x27;检测环境&#x27;</span>) &#123;            steps &#123;                echo <span class="string">&#x27;开始检测环境&#x27;</span>                sh <span class="string">&#x27;&#x27;&#x27;java -version</span><span class="string">                mvn -v</span><span class="string">                docker -v</span><span class="string">                git version&#x27;&#x27;&#x27;</span>            &#125;        &#125;        stage(<span class="string">&#x27;拉取代码&#x27;</span>) &#123;            steps &#123;                echo <span class="string">&#x27;开始拉取代码&#x27;</span>                checkout scmGit(<span class="attr">branches:</span> [[<span class="attr">name:</span> <span class="string">&#x27;*/master&#x27;</span>]], <span class="attr">extensions:</span> [], <span class="attr">userRemoteConfigs:</span> [[<span class="attr">credentialsId:</span> <span class="string">&#x27;5c2185ef-6204-4c3b-b6dc-92b0ea5e55a1&#x27;</span>, <span class="attr">url:</span> <span class="string">&#x27;http://192.168.6.211:3060/GeorgeChan/ioms-test.git&#x27;</span>]])            &#125;        &#125;        stage(<span class="string">&#x27;编译构建&#x27;</span>) &#123;            steps &#123;                echo <span class="string">&#x27;开始执行代码编译&#x27;</span>sh <span class="string">&#x27;mvn clean package -pl ioms-eureka -am -Dmaven.test.skip=true -Ddockerfile.skip=true&#x27;</span>            &#125;        &#125;stage(<span class="string">&#x27;登录Harbor&#x27;</span>) &#123;            steps &#123;                echo <span class="string">&#x27;开始执行登录Harbor&#x27;</span>                sh <span class="string">&#x27;docker login -u admin -p Harbor12345 192.168.6.201:5000&#x27;</span>            &#125;        &#125;        stage(<span class="string">&#x27;运行ioms-eureka&#x27;</span>) &#123;            steps &#123;                echo <span class="string">&#x27;开始执行ioms-eureka模块的镜像构建、容器运行&#x27;</span>                script &#123;                    <span class="comment">// 定义当前工作空间变量</span>                    <span class="keyword">def</span> currentWorkspace = env.WORKSPACE                    echo <span class="string">&quot;当前工作空间：$&#123;currentWorkspace&#125;&quot;</span>                    <span class="keyword">def</span> currentModule = <span class="string">&quot;ioms-eureka&quot;</span>                    <span class="comment">// 删除容器</span>                    sh <span class="string">&quot;&quot;&quot;</span><span class="string">                        echo &quot;检查容器 $&#123;currentModule&#125; 是否存在&quot;</span><span class="string">                        containerid=\$(docker ps -a | grep -w $&#123;currentModule&#125; | awk &#x27;&#123;print \$1&#125;&#x27;)</span><span class="string">                        if [ &quot;\$containerid&quot; != &quot;&quot; ]; then</span><span class="string">                            echo &#x27;容器存在，停止容器&#x27;</span><span class="string">                            docker stop \$containerid</span><span class="string">                            echo &#x27;删除容器&#x27;</span><span class="string">                            docker rm \$containerid</span><span class="string">                        fi</span><span class="string">                    &quot;&quot;&quot;</span>                    <span class="comment">// 删除镜像</span>                    sh <span class="string">&quot;&quot;&quot;</span><span class="string">                        echo &quot;检查镜像 $&#123;currentModule&#125; 是否存在&quot;</span><span class="string">                        imageid=\$(docker images | grep $&#123;currentModule&#125; | awk &#x27;&#123;print \$3&#125;&#x27;)</span><span class="string">                        if [ &quot;\$imageid&quot; != &quot;&quot; ]; then</span><span class="string">                             echo &#x27;删除镜像&#x27;</span><span class="string">                             docker rmi -f \$imageid</span><span class="string">                        fi</span><span class="string">                    &quot;&quot;&quot;</span>                    <span class="comment">// 执行 mvn dockerfile:build 命令</span>                    <span class="comment">// 构建镜像，并获取日志输出</span>                    <span class="keyword">def</span> buildOutput = sh(<span class="attr">returnStdout:</span> <span class="literal">true</span>, <span class="attr">script:</span> <span class="string">&quot;mvn dockerfile:build -pl ioms-eureka -DdockerfileDirectory=$&#123;currentWorkspace&#125;/$&#123;currentModule&#125;&quot;</span>)                    <span class="keyword">def</span> imageName = <span class="string">&quot;&quot;</span>                    <span class="keyword">def</span> tag = <span class="string">&quot;&quot;</span>                    <span class="comment">// 将日志用换行符切分</span>                    <span class="keyword">def</span> lines = buildOutput.split(<span class="string">&#x27;\n&#x27;</span>)                    <span class="comment">// 遍历日志，获取构建的镜像的名称</span>                    lines.each &#123; line -&gt;                        <span class="keyword">def</span> lineStr = line.toString()  <span class="comment">// 将列表元素转换为字符串</span><span class="comment">//                        echo lineStr</span>                        <span class="keyword">if</span> (lineStr.startsWith(<span class="string">&quot;[INFO] Successfully tagged&quot;</span>)) &#123;                            imageName = lineStr.substring(lineStr.indexOf(<span class="string">&quot;[INFO] Successfully tagged&quot;</span>) + <span class="string">&quot;[INFO] Successfully tagged&quot;</span>.length()).trim()                            <span class="comment">// 192.168.6.201:5000/ioms-hf/ioms-eureka:1.0-SNAPSHOT</span>                            tag = imageName.split(<span class="string">&quot;:&quot;</span>)[<span class="number">2</span>];                        &#125;                    &#125;                    echo <span class="string">&quot;生成的镜像名称：$&#123;imageName&#125;&quot;</span>                    echo <span class="string">&quot;生成的镜像Tag：$&#123;tag&#125;&quot;</span>                    echo <span class="string">&quot;开始执行运行$&#123;currentModule&#125;容器&quot;</span>                    sh <span class="string">&quot;docker-compose up -d $&#123;currentModule&#125;&quot;</span>                &#125;            &#125;        &#125;        stage(<span class="string">&#x27;构建结束&#x27;</span>) &#123;            steps &#123;                echo <span class="string">&#x27;已成功构建所有模块&#x27;</span>            &#125;        &#125;    &#125;&#125;</code></pre><h2 id="6-运行Pipeline任务"><a href="#6-运行Pipeline任务" class="headerlink" title="6. 运行Pipeline任务"></a>6. 运行Pipeline任务</h2><h3 id="6-1-立即构建"><a href="#6-1-立即构建" class="headerlink" title="6.1 立即构建"></a>6.1 立即构建</h3><p><img src="https://raw.githubusercontent.com/GeorgeChan95/blogimg/master/img/2024/01/05/20240105-143447.png" alt="image-20240105143445338"></p><h3 id="6-2-查看构建过程"><a href="#6-2-查看构建过程" class="headerlink" title="6.2 查看构建过程"></a>6.2 查看构建过程</h3><p><img src="https://raw.githubusercontent.com/GeorgeChan95/blogimg/master/img/2024/01/05/20240105-143514.png" alt="image-20240105143512649"></p><p><img src="https://raw.githubusercontent.com/GeorgeChan95/blogimg/master/img/2024/01/05/20240105-143528.png" alt="image-20240105143526531"></p><h3 id="6-3-验证结果"><a href="#6-3-验证结果" class="headerlink" title="6.3 验证结果"></a>6.3 验证结果</h3><p>浏览器打开eureka访问页面</p><p><a href="http://192.168.6.91:8761/">http://192.168.6.91:8761/</a></p><p><img src="https://raw.githubusercontent.com/GeorgeChan95/blogimg/master/img/2024/01/05/20240105-143710.png" alt="image-20240105143708987"></p><h2 id="7-其它"><a href="#7-其它" class="headerlink" title="7. 其它"></a>7. 其它</h2><ul><li>上述所有操作的前提是，要在代理节点安装JDK、Git、Maven，并正确配置环境变量。这些都比较基础，自行补充，这里不再重复。</li><li>Jenkins的中文支持，有时候重启会失效，这个不影响操作。</li></ul><h1 id="七、Jenkins部署运维系统前端代码"><a href="#七、Jenkins部署运维系统前端代码" class="headerlink" title="七、Jenkins部署运维系统前端代码"></a>七、Jenkins部署运维系统前端代码</h1><h2 id="1-安装插件"><a href="#1-安装插件" class="headerlink" title="1. 安装插件"></a>1. 安装插件</h2><p>Jenkins要部署前端代码，需要安装两个必要的插件</p><ul><li>Publish Over SSH  用于登录远程服务器，和向远程服务器发送文件</li><li>NodeJs  用于代码的打包</li></ul><p><img src="https://raw.githubusercontent.com/GeorgeChan95/blogimg/master/img/2024/01/05/20240105-145120.png" alt="image-20240105145119424"></p><p><img src="https://raw.githubusercontent.com/GeorgeChan95/blogimg/master/img/2024/01/05/20240105-145257.png" alt="image-20240105145255475"></p><h2 id="2-配置远程服务器的连接"><a href="#2-配置远程服务器的连接" class="headerlink" title="2. 配置远程服务器的连接"></a>2. 配置远程服务器的连接</h2><p>1、打开“系统管理”–“系统设置” 找到 “Publish over SSH” 项 , 配置SSH Server</p><ul><li>Name：给要配置的服务器起个名字</li><li>Hostname：服务器IP</li><li>Username：登录用户名</li><li>Remote Directory：登陆成功后默认进入的目录</li><li>Password：登录用户密码</li></ul><p><img src="https://raw.githubusercontent.com/GeorgeChan95/blogimg/master/img/2024/01/05/20240105-145822.png" alt="image-20240105145821255"></p><p>2、点击 Test Configuration 按钮测试连接是否成功</p><p><img src="https://raw.githubusercontent.com/GeorgeChan95/blogimg/master/img/2024/01/05/20240105-150137.png" alt="image-20240105150135367"></p><h2 id="3-配置NodeJS"><a href="#3-配置NodeJS" class="headerlink" title="3. 配置NodeJS"></a>3. 配置NodeJS</h2><p>打开“系统管理” –&gt; “全局工具配置”， 找到NodeJS， 新增NodeJS</p><ul><li>别名：NodeJS名称</li><li>版本：选择适用的NodeJS版本</li></ul><p><img src="https://raw.githubusercontent.com/GeorgeChan95/blogimg/master/img/2024/01/05/20240105-150653.png" alt="image-20240105150651858"></p><h2 id="4-新建流水线任务"><a href="#4-新建流水线任务" class="headerlink" title="4. 新建流水线任务"></a>4. 新建流水线任务</h2><h3 id="3-1-新建一个自由风格项目"><a href="#3-1-新建一个自由风格项目" class="headerlink" title="3.1 新建一个自由风格项目"></a>3.1 新建一个自由风格项目</h3><p><img src="https://raw.githubusercontent.com/GeorgeChan95/blogimg/master/img/2024/01/05/20240105-153628.png" alt="image-20240105153627066"></p><h3 id="3-2-配置任务"><a href="#3-2-配置任务" class="headerlink" title="3.2 配置任务"></a>3.2 配置任务</h3><ul><li><p>限制项目的运行节点：选择要部署的服务器</p></li><li><p>源码管理：选择Git</p><ul><li>Repository URL：前端代码Git地址</li><li>Credentials：Gitlab登录凭证</li><li>Branches to build：Git拉取的代码分支，默认Master</li></ul></li><li><p>构建环境</p><ul><li>Provide Node &amp; npm bin&#x2F; folder to PATH：选择适配的NodeJS版本</li></ul></li><li><p>Build Steps</p><ul><li><p>选择 <code>执行Shell</code></p></li><li><p>内容如下：</p><pre><code class="highlight shell"><span class="meta prompt_"># </span><span class="language-bash">进入Jenkins工作空间下hxkj项目目录</span>cd /data/workspaces/workspace/ioms-html<span class="meta prompt_"></span><span class="meta prompt_">#</span><span class="language-bash"><span class="comment">##</span></span><span class="meta prompt_"># </span><span class="language-bash">npm切换为淘宝源</span>npm config set registry http://registry.npm.taobao.org/<span class="meta prompt_"></span><span class="meta prompt_"># </span><span class="language-bash">删除已有的构建包</span>rm -rf ./dist/rm -rf dist.tar.gz<span class="meta prompt_"></span><span class="meta prompt_"># </span><span class="language-bash">安装依赖，跳过安全审计</span>npm --no-audit i --force<span class="meta prompt_"></span><span class="meta prompt_"># </span><span class="language-bash">构建项目</span>npm run test<span class="meta prompt_"></span><span class="meta prompt_"># </span><span class="language-bash">压缩方便移动到项目部署目录</span>tar -zcvf dist.tar.gz dist</code></pre></li></ul></li><li><p>构建后操作</p><ul><li><p>配置SSH Server</p><ul><li><p>Name：选择部署的服务器</p></li><li><p>Transfer Set Source files：前端打包后的文件名</p></li><li><p>Remove prefix：要去除的文件前缀</p></li><li><p>Remote directory：要进入的远程服务器的文件夹路径</p></li><li><p>Exec command：进入文件夹后，执行的shell命令</p><pre><code class="highlight shell">cd /usr/local/docker/data/nginx/html/dist-white/echo &quot;工作路径：&quot; $(pwd)mv ./dist ./dist$(date +&#x27;%Y%m%d%H%M&#x27;)tar -zxvf dist.tar.gz -C ./docker restart ioms-nginxrm -rf dist.tar.gz</code></pre></li></ul></li></ul></li></ul><h2 id="5-执行构建任务"><a href="#5-执行构建任务" class="headerlink" title="5. 执行构建任务"></a>5. 执行构建任务</h2><h3 id="5-1-立即构建"><a href="#5-1-立即构建" class="headerlink" title="5.1 立即构建"></a>5.1 立即构建</h3><p><img src="https://raw.githubusercontent.com/GeorgeChan95/blogimg/master/img/2024/01/05/20240105-154823.png" alt="image-20240105154821435"></p><h3 id="5-2-查看构建过程"><a href="#5-2-查看构建过程" class="headerlink" title="5.2 查看构建过程"></a>5.2 查看构建过程</h3><p><img src="https://raw.githubusercontent.com/GeorgeChan95/blogimg/master/img/2024/01/05/20240105-154937.png" alt="image-20240105154935476"></p><p><img src="https://raw.githubusercontent.com/GeorgeChan95/blogimg/master/img/2024/01/05/20240105-154947.png" alt="image-20240105154945457"></p><h3 id="5-3-验证结果"><a href="#5-3-验证结果" class="headerlink" title="5.3 验证结果"></a>5.3 验证结果</h3><p><img src="https://raw.githubusercontent.com/GeorgeChan95/blogimg/master/img/2024/01/05/20240105-155023.png" alt="image-20240105155022077"></p>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 style=&quot;text-align: center;&quot;&gt;Jenkins的安装和搭建自动化部署平台&lt;/h1&gt;



&lt;h1 id=&quot;环境&quot;&gt;&lt;a href=&quot;#环境&quot; class=&quot;headerlink&quot; title=&quot;环境&quot;&gt;&lt;/a&gt;环境&lt;/h1&gt;&lt;blockquote&gt;</summary>
      
    
    
    
    <category term="linux" scheme="https://georgechan95.github.io/categories/linux/"/>
    
    
    <category term="linux" scheme="https://georgechan95.github.io/tags/linux/"/>
    
    <category term="jenkins" scheme="https://georgechan95.github.io/tags/jenkins/"/>
    
  </entry>
  
  <entry>
    <title>第十一章-StringTable(字符串常量池)</title>
    <link href="https://georgechan95.github.io/2023/12/25/jvm/%E7%AC%AC%E5%8D%81%E4%B8%80%E7%AB%A0-StringTable/"/>
    <id>https://georgechan95.github.io/2023/12/25/jvm/%E7%AC%AC%E5%8D%81%E4%B8%80%E7%AB%A0-StringTable/</id>
    <published>2023-12-25T09:27:06.000Z</published>
    <updated>2024-06-22T10:36:12.823Z</updated>
    
    <content type="html"><![CDATA[<h1 id="环境"><a href="#环境" class="headerlink" title="环境"></a>环境</h1><blockquote><p>系统 : Windows 10<br>JDK : 1.8</p></blockquote><h1 id="一、String的基本特性"><a href="#一、String的基本特性" class="headerlink" title="一、String的基本特性"></a>一、String的基本特性</h1><ul><li><p>String：字符串，使用一对 “ ” 引起来表示</p></li><li><p>String被声明为final的，不可被继承</p></li><li><p>String实现了Serializable接口：表示字符串是支持序列化的。实现了Comparable接口：表示String可以比较大小</p></li><li><p>String在jdk8及以前内部定义了 <code>final char value[]</code> 用于存储字符串数据。JDK9时改为 <code>byte[]</code></p></li></ul><h1 id="二、为什么-JDK9-改变了-String-的结构"><a href="#二、为什么-JDK9-改变了-String-的结构" class="headerlink" title="二、为什么 JDK9 改变了 String 的结构"></a>二、为什么 JDK9 改变了 String 的结构</h1><blockquote><p>官方解释：<a href="https://openjdk.org/jeps/254">https://openjdk.org/jeps/254</a></p></blockquote><p><strong>为什么改为 byte[] 存储？</strong></p><ul><li>String类的当前实现将字符存储在char数组中，每个字符使用两个字节(16位)。</li><li>从许多不同的应用程序收集的数据表明，字符串是堆使用的主要组成部分，而且大多数字符串对象只包含拉丁字符（Latin-1）。这些字符只需要一个字节的存储空间，因此这些字符串对象的内部char数组中有一半的空间将不会使用，产生了大量浪费。</li><li>之前 String 类使用 UTF-16 的 char[] 数组存储，现在改为 byte[] 数组 外加一个编码标识存储。该编码表示如果你的字符是ISO-8859-1或者Latin-1，那么只需要一个字节存。如果你是其它字符集，比如UTF-8，你仍然用两个字节存.</li><li>结论：String再也不用char[] 来存储了，改成了byte [] 加上编码标记，节约了一些空间</li><li>同时基于String的数据结构，例如StringBuffer和StringBuilder也同样做了修改</li></ul><pre><code class="highlight java"><span class="comment">// 之前</span><span class="keyword">private</span> <span class="keyword">final</span> <span class="type">char</span> value[];<span class="comment">// 之后</span><span class="keyword">private</span> <span class="keyword">final</span> <span class="type">byte</span>[] value</code></pre><h2 id="1-String-的基本特性"><a href="#1-String-的基本特性" class="headerlink" title="1. String 的基本特性"></a>1. String 的基本特性</h2><ul><li>String：代表不可变的字符序列。简称：不可变性。<ul><li>当对字符串重新赋值时，需要重写指定内存区域赋值，不能使用原有的value进行赋值。</li><li>当对现有的字符串进行连接操作时，也需要重新指定内存区域赋值，不能使用原有的value进行赋值。</li><li>当调用String的replace()方法修改指定字符或字符串时，也需要重新指定内存区域赋值，不能使用原有的value进行赋值。</li></ul></li><li>通过字面量的方式（区别于new）给一个字符串赋值，此时的字符串值声明在字符串常量池中。</li></ul><p><strong>特性1：当对字符串重新赋值时，需要重写指定内存区域赋值，不能使用原有的value进行赋值</strong></p><blockquote><p>JAVA代码</p></blockquote><pre><code class="highlight java"><span class="meta">@Test</span><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">test1</span><span class="params">()</span> &#123;    <span class="type">String</span> <span class="variable">s1</span> <span class="operator">=</span> <span class="string">&quot;abc&quot;</span>;<span class="comment">//字面量定义的方式，&quot;abc&quot;存储在字符串常量池中</span>    <span class="type">String</span> <span class="variable">s2</span> <span class="operator">=</span> <span class="string">&quot;abc&quot;</span>;    s1 = <span class="string">&quot;hello&quot;</span>;    System.out.println(s1 == s2);<span class="comment">//判断地址：true  --&gt; false</span>    System.out.println(s1);<span class="comment">//</span>    System.out.println(s2);<span class="comment">//abc</span>&#125;</code></pre><blockquote><p>字节码</p></blockquote><pre><code class="highlight plaintext"> 0 ldc #2 &lt;abc&gt; 2 astore_1 3 ldc #2 &lt;abc&gt; 5 astore_2 6 ldc #3 &lt;hello&gt; 8 astore_1 9 getstatic #4 &lt;java/lang/System.out : Ljava/io/PrintStream;&gt;12 aload_113 aload_214 if_acmpne 21 (+7)17 iconst_118 goto 22 (+4)21 iconst_022 invokevirtual #5 &lt;java/io/PrintStream.println : (Z)V&gt;25 getstatic #4 &lt;java/lang/System.out : Ljava/io/PrintStream;&gt;28 aload_129 invokevirtual #6 &lt;java/io/PrintStream.println : (Ljava/lang/String;)V&gt;32 getstatic #4 &lt;java/lang/System.out : Ljava/io/PrintStream;&gt;35 aload_236 invokevirtual #6 &lt;java/io/PrintStream.println : (Ljava/lang/String;)V&gt;39 return</code></pre><p>可以看出：</p><ul><li>取字符串 “abc” 时，使用的是同一个符号引用：#2</li><li>取字符串 “hello” 时，使用的是另一个符号引用：#3</li></ul><p><strong>特性2：当对现有的字符串进行连接操作时，也需要重新指定内存区域赋值，不能使用原有的value进行赋值</strong></p><blockquote><p>示例</p></blockquote><pre><code class="highlight java"><span class="meta">@Test</span><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">test2</span><span class="params">()</span> &#123;    <span class="type">String</span> <span class="variable">s1</span> <span class="operator">=</span> <span class="string">&quot;abc&quot;</span>;    <span class="type">String</span> <span class="variable">s2</span> <span class="operator">=</span> <span class="string">&quot;abc&quot;</span>;    s2 += <span class="string">&quot;def&quot;</span>;    System.out.println(s2);<span class="comment">//abcdef</span>    System.out.println(s1);<span class="comment">//abc</span>&#125;</code></pre><p><strong>特性3：当调用string的replace()方法修改指定字符或字符串时，也需要重新指定内存区域赋值，不能使用原有的value进行赋值</strong></p><blockquote><p>示例</p></blockquote><pre><code class="highlight java"><span class="meta">@Test</span><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">test3</span><span class="params">()</span> &#123;    <span class="type">String</span> <span class="variable">s1</span> <span class="operator">=</span> <span class="string">&quot;abc&quot;</span>;    <span class="type">String</span> <span class="variable">s2</span> <span class="operator">=</span> s1.replace(<span class="string">&#x27;a&#x27;</span>, <span class="string">&#x27;m&#x27;</span>);    System.out.println(s1);<span class="comment">//abc</span>    System.out.println(s2);<span class="comment">//mbc</span>&#125;</code></pre><h2 id="练习题"><a href="#练习题" class="headerlink" title="练习题"></a>练习题</h2><pre><code class="highlight java"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">StringExer</span> &#123;    <span class="type">String</span> <span class="variable">str</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">String</span>(<span class="string">&quot;good&quot;</span>);    <span class="type">char</span>[] ch = &#123;<span class="string">&#x27;t&#x27;</span>, <span class="string">&#x27;e&#x27;</span>, <span class="string">&#x27;s&#x27;</span>, <span class="string">&#x27;t&#x27;</span>&#125;;    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">change</span><span class="params">(String str, <span class="type">char</span> ch[])</span> &#123;        str = <span class="string">&quot;test ok&quot;</span>;        ch[<span class="number">0</span>] = <span class="string">&#x27;b&#x27;</span>;    &#125;    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;        <span class="type">StringExer</span> <span class="variable">ex</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">StringExer</span>();        ex.change(ex.str, ex.ch);        System.out.println(ex.str);<span class="comment">//good</span>        System.out.println(ex.ch);<span class="comment">//best</span>    &#125;&#125;</code></pre><p>str 的内容并没有变：“test ok” 位于字符串常量池中的另一个区域（地址），进行赋值操作并没有修改原来 str 指向的引用的内容</p><h2 id="2-String-的底层结构"><a href="#2-String-的底层结构" class="headerlink" title="2. String 的底层结构"></a>2. String 的底层结构</h2><p><strong>字符串常量池中，每个对象都是唯一的，不会存储两个相同内容的字符串</strong></p><ul><li>String 的 String Pool（字符串常量池）是一个固定大小的Hashtable，默认值大小长度是1009。如果放进String Pool的String非常多，就会造成Hash冲突严重，从而导致链表会很长，而链表长了后直接会造成的影响就是当调用String.intern()方法时性能会大幅下降。</li><li>使用 <code>-XX:StringTablesize</code> 可设置StringTable的长度</li><li>在JDK6中StringTable是固定的，就是1009的长度，所以如果常量池中的字符串过多就会导致效率下降很快，StringTablesize设置没有要求</li><li>在JDK7中，StringTable的长度默认值是60013，StringTablesize设置没有要求</li><li>在JDK8中，StringTable的长度默认值是60013，StringTable可以设置的最小值为1009</li></ul><p><img src="https://raw.githubusercontent.com/GeorgeChan95/blogimg/master/img/2023/12/27/20231227-205050.png" alt="JDK8的StringTableSize"></p><h3 id="2-1-测试不同-StringTable-长度下，程序的性能"><a href="#2-1-测试不同-StringTable-长度下，程序的性能" class="headerlink" title="2.1 测试不同 StringTable 长度下，程序的性能"></a>2.1 测试不同 StringTable 长度下，程序的性能</h3><blockquote><p>代码，生成测试文件</p></blockquote><pre><code class="highlight java"><span class="comment">/**</span><span class="comment"> * 产生10万个长度不超过10的字符串，包含a-z,A-Z</span><span class="comment"> */</span><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">GenerateString</span> &#123;    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> IOException &#123;        <span class="type">FileWriter</span> <span class="variable">fw</span> <span class="operator">=</span>  <span class="keyword">new</span> <span class="title class_">FileWriter</span>(<span class="string">&quot;words.txt&quot;</span>);        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; <span class="number">100000</span>; i++) &#123;            <span class="comment">//1 - 10</span>           <span class="type">int</span> <span class="variable">length</span> <span class="operator">=</span> (<span class="type">int</span>)(Math.random() * (<span class="number">10</span> - <span class="number">1</span> + <span class="number">1</span>) + <span class="number">1</span>);            fw.write(getString(length) + <span class="string">&quot;\n&quot;</span>);        &#125;        fw.close();    &#125;    <span class="keyword">public</span> <span class="keyword">static</span> String <span class="title function_">getString</span><span class="params">(<span class="type">int</span> length)</span>&#123;        <span class="type">String</span> <span class="variable">str</span> <span class="operator">=</span> <span class="string">&quot;&quot;</span>;        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; length; i++) &#123;            <span class="comment">//65 - 90, 97-122</span>            <span class="type">int</span> <span class="variable">num</span> <span class="operator">=</span> (<span class="type">int</span>)(Math.random() * (<span class="number">90</span> - <span class="number">65</span> + <span class="number">1</span>) + <span class="number">65</span>) + (<span class="type">int</span>)(Math.random() * <span class="number">2</span>) * <span class="number">32</span>;            str += (<span class="type">char</span>)num;        &#125;        <span class="keyword">return</span> str;    &#125;&#125;</code></pre><blockquote><p>测试代码，配置VM option参数，测试StringTable对程序性能的影响</p></blockquote><pre><code class="highlight java"><span class="comment">/**</span><span class="comment"> *  -XX:StringTableSize=1009</span><span class="comment"> *  -XX:StringTableSize=100009</span><span class="comment"> */</span><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">StringTest2</span> &#123;    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;        <span class="comment">//测试StringTableSize参数</span><span class="comment">//        System.out.println(&quot;我来打个酱油&quot;);</span><span class="comment">//        try &#123;</span><span class="comment">//            Thread.sleep(1000000);</span><span class="comment">//        &#125; catch (InterruptedException e) &#123;</span><span class="comment">//            e.printStackTrace();</span><span class="comment">//        &#125;</span>        <span class="type">BufferedReader</span> <span class="variable">br</span> <span class="operator">=</span> <span class="literal">null</span>;        <span class="keyword">try</span> &#123;            br = <span class="keyword">new</span> <span class="title class_">BufferedReader</span>(<span class="keyword">new</span> <span class="title class_">FileReader</span>(<span class="string">&quot;words.txt&quot;</span>));            <span class="type">long</span> <span class="variable">start</span> <span class="operator">=</span> System.currentTimeMillis();            String data;            <span class="keyword">while</span>((data = br.readLine()) != <span class="literal">null</span>)&#123;                data.intern(); <span class="comment">//如果字符串常量池中没有对应data的字符串的话，则在常量池中生成</span>            &#125;            <span class="type">long</span> <span class="variable">end</span> <span class="operator">=</span> System.currentTimeMillis();            System.out.println(<span class="string">&quot;花费的时间为：&quot;</span> + (end - start));<span class="comment">//1009:152ms  100009:32ms</span>        &#125; <span class="keyword">catch</span> (IOException e) &#123;            e.printStackTrace();        &#125; <span class="keyword">finally</span> &#123;            <span class="keyword">if</span>(br != <span class="literal">null</span>)&#123;                <span class="keyword">try</span> &#123;                    br.close();                &#125; <span class="keyword">catch</span> (IOException e) &#123;                    e.printStackTrace();                &#125;            &#125;        &#125;    &#125;&#125;</code></pre><blockquote><p>测试结果</p></blockquote><ul><li>-XX:StringTableSize&#x3D;1009<ul><li>用时：152ms</li></ul></li><li>-XX:StringTableSize&#x3D;100009<ul><li>用时：32ms</li></ul></li></ul><h1 id="三、String-的内存分配"><a href="#三、String-的内存分配" class="headerlink" title="三、String 的内存分配"></a>三、String 的内存分配</h1><ul><li><p>在Java语言中有8种基本数据类型和一种比较特殊的类型String。这些类型为了使它们在运行过程中速度更快、更节省内存，都提供了一种常量池的概念。</p></li><li><p>常量池就类似一个Java系统级别提供的缓存。8种基本数据类型的常量池都是系统协调的，String类型的常量池比较特殊。它的主要使用方法有两种。</p><ul><li>直接使用双引号声明出来的String对象会直接存储在常量池中。比如：<code>String info=&quot;atguigu.com&quot;;</code></li><li>如果不是用双引号声明的String对象，可以使用String提供的 <code>intern()</code> 方法。</li></ul></li><li><p>Java 6及以前，字符串常量池存放在永久代</p></li><li><p>Java 7中 Oracle的工程师对字符串池的逻辑做了很大的改变，即将字符串常量池的位置调整到Java堆内</p><ul><li>所有的字符串都保存在堆（Heap）中，和其他普通对象一样，这样可以让你在进行调优应用时仅需要调整堆大小就可以了。</li><li>字符串常量池概念原本使用得比较多，但是这个改动使得我们有足够的理由让我们重新考虑在Java 7中使用String.intern()。</li></ul></li><li><p>Java8元空间，字符串常量在堆</p></li></ul><p><img src="https://raw.githubusercontent.com/GeorgeChan95/blogimg/master/img/2023/12/28/20231228-094121.png" alt="image-20231228094120058"></p><p><img src="https://raw.githubusercontent.com/GeorgeChan95/blogimg/master/img/2023/12/28/20231228-094414.png" alt="image-20231228094205567"></p><h2 id="1-StringTable-为什么要调整？"><a href="#1-StringTable-为什么要调整？" class="headerlink" title="1. StringTable 为什么要调整？"></a>1. StringTable 为什么要调整？</h2><blockquote><p><strong>官方文档：</strong><a href="https://www.oracle.com/java/technologies/javase/jdk7-relnotes.html#jdk7changes">https://www.oracle.com/java/technologies/javase/jdk7-relnotes.html#jdk7changes</a></p></blockquote><ul><li>为什么要调整位置？<ul><li>永久代的默认空间大小比较小</li><li>永久代垃圾回收频率低，大量的字符串无法及时回收，容易进行Full GC产生STW或者容易产生OOM：PermGen Space</li><li>堆中空间足够大，字符串可被及时回收</li></ul></li><li>在JDK 7中，interned字符串不再在Java堆的永久代中分配，而是在Java堆的主要部分（称为年轻代和年老代）中分配，与应用程序创建的其他对象一起分配。</li><li>此更改将导致驻留在主Java堆中的数据更多，驻留在永久生成中的数据更少，因此可能需要调整堆大小。</li></ul><blockquote><p>代码演示验证(JDK8)</p></blockquote><pre><code class="highlight java"><span class="comment">/**</span><span class="comment"> * jdk6中：</span><span class="comment"> * -XX:PermSize=6m -XX:MaxPermSize=6m -Xms6m -Xmx6m</span><span class="comment"> *</span><span class="comment"> * jdk8中：</span><span class="comment"> * -XX:MetaspaceSize=60m -XX:MaxMetaspaceSize=60m -Xms60m -Xmx60m</span><span class="comment"> */</span><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">StringTest3</span> &#123;    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;        <span class="comment">//使用Set保持着常量池引用，避免full gc回收常量池行为</span>        Set&lt;String&gt; set = <span class="keyword">new</span> <span class="title class_">HashSet</span>&lt;String&gt;();        <span class="comment">//在short可以取值的范围内足以让6MB的PermSize或heap产生OOM了。</span>        <span class="type">long</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>;        <span class="keyword">while</span>(<span class="literal">true</span>)&#123;            set.add(String.valueOf(i++).intern());        &#125;    &#125;&#125;</code></pre><blockquote><p>输出结果</p></blockquote><pre><code class="highlight plaintext">Exception in thread &quot;main&quot; java.lang.OutOfMemoryError: Java heap spaceat java.util.HashMap.newNode(HashMap.java:1750)at java.util.HashMap.putVal(HashMap.java:631)at java.util.HashMap.put(HashMap.java:612)at java.util.HashSet.add(HashSet.java:220)at com.atguigu.java.StringTest3.main(StringTest3.java:20)</code></pre><p><strong>结论：JDK8中字符串常量池在堆中</strong></p><h1 id="四、String-的基本操作"><a href="#四、String-的基本操作" class="headerlink" title="四、String 的基本操作"></a>四、String 的基本操作</h1><p>Java语言规范里要求完全相同的字符串字面量，应该包含同样的Unicode字符序列（包含同一份码点序列的常量），并且必须是指向同一个String类实例。</p><h2 id="1-示例1"><a href="#1-示例1" class="headerlink" title="1. 示例1"></a>1. 示例1</h2><ul><li>程序启动，已加载字符串常量 2126个</li></ul><img src="https://raw.githubusercontent.com/GeorgeChan95/blogimg/master/img/2023/12/28/20231228-103807.png" alt="image-20231228103806343" style="zoom: 80%;" /><ul><li>加载了一个换行符（println），字符串常量池加1</li></ul><img src="https://raw.githubusercontent.com/GeorgeChan95/blogimg/master/img/2023/12/28/20231228-104024.png" alt="image-20231228104023119" style="zoom:80%;" /><ul><li>加载了字符串常量 “1”~“9”</li></ul><img src="https://raw.githubusercontent.com/GeorgeChan95/blogimg/master/img/2023/12/28/20231228-104101.png" alt="image-20231228104100167" style="zoom:80%;" /><ul><li>加载字符串常量 “10”</li></ul><img src="https://raw.githubusercontent.com/GeorgeChan95/blogimg/master/img/2023/12/28/20231228-104138.png" alt="image-20231228104137366" style="zoom:80%;" /><ul><li>之后的字符串”1” 到 “10”不会再次加载</li></ul><img src="https://raw.githubusercontent.com/GeorgeChan95/blogimg/master/img/2023/12/28/20231228-104222.png" alt="image-20231228104220348" style="zoom:80%;" /><h1 id="五、字符串拼接操作"><a href="#五、字符串拼接操作" class="headerlink" title="五、字符串拼接操作"></a>五、字符串拼接操作</h1><h2 id="1-结论"><a href="#1-结论" class="headerlink" title="1. 结论"></a>1. 结论</h2><ul><li>常量与常量的拼接结果在常量池，原理是编译期优化</li><li>常量池中不会存在相同内容的变量</li><li>拼接前后，只要其中有一个是变量，结果就在堆中。变量拼接的原理是StringBuilder</li><li>如果拼接的结果调用intern()方法，根据该字符串是否在常量池中存在，分为：<ul><li>如果存在，则返回字符串在常量池中的地址</li><li>如果字符串常量池中不存在该字符串，则在常量池中创建一份，并返回此对象的地址</li></ul></li></ul><h2 id="2-结论解析"><a href="#2-结论解析" class="headerlink" title="2. 结论解析"></a>2. 结论解析</h2><ul><li><strong>常量与常量的拼接结果在常量池，原理是编译期优化</strong></li></ul><blockquote><p>代码</p></blockquote><pre><code class="highlight java"><span class="meta">@Test</span><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">test1</span><span class="params">()</span>&#123;    <span class="type">String</span> <span class="variable">s1</span> <span class="operator">=</span> <span class="string">&quot;a&quot;</span> + <span class="string">&quot;b&quot;</span> + <span class="string">&quot;c&quot;</span>;<span class="comment">//编译期优化：等同于&quot;abc&quot;</span>    <span class="type">String</span> <span class="variable">s2</span> <span class="operator">=</span> <span class="string">&quot;abc&quot;</span>; <span class="comment">//&quot;abc&quot;一定是放在字符串常量池中，将此地址赋给s2</span>    <span class="comment">/*</span><span class="comment">     * 最终.java编译成.class,再执行.class</span><span class="comment">     * String s1 = &quot;abc&quot;;</span><span class="comment">     * String s2 = &quot;abc&quot;</span><span class="comment">     */</span>    <span class="comment">//  ==：比较的是两个字符串内存地址（堆内存）的数值是否相等，属于数值比较；</span>    System.out.println(s1 == s2); <span class="comment">//true</span>    <span class="comment">// equals()：比较的是两个字符串的内容，属于内容比较。</span>    System.out.println(s1.equals(s2)); <span class="comment">//true</span>&#125;</code></pre><blockquote><p>字节码</p><p>从字节码指令看出：编译器做了优化，将 “a” + “b” + “c” 优化成了 “abc”</p></blockquote><pre><code class="highlight plaintext"> 0 ldc #2 &lt;abc&gt; 2 astore_1 3 ldc #2 &lt;abc&gt; 5 astore_2 6 getstatic #3 &lt;java/lang/System.out : Ljava/io/PrintStream;&gt; 9 aload_110 aload_211 if_acmpne 18 (+7)14 iconst_115 goto 19 (+4)18 iconst_019 invokevirtual #4 &lt;java/io/PrintStream.println : (Z)V&gt;22 getstatic #3 &lt;java/lang/System.out : Ljava/io/PrintStream;&gt;25 aload_126 aload_227 invokevirtual #5 &lt;java/lang/String.equals : (Ljava/lang/Object;)Z&gt;30 invokevirtual #4 &lt;java/io/PrintStream.println : (Z)V&gt;33 return</code></pre><blockquote><p>反编译代码</p><p>IDEA 反编译 class 文件后，来看这个问题</p></blockquote><pre><code class="highlight java"><span class="meta">@Test</span><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">test1</span><span class="params">()</span> &#123;    <span class="type">String</span> <span class="variable">s1</span> <span class="operator">=</span> <span class="string">&quot;abc&quot;</span>;    <span class="type">String</span> <span class="variable">s2</span> <span class="operator">=</span> <span class="string">&quot;abc&quot;</span>;    System.out.println(s1 == s2);    System.out.println(s1.equals(s2));&#125;</code></pre><p>通过反编译的代码确实可以看到IDEA将 “a” + “b” + “c” 优化成了 “abc”</p><ul><li><strong>拼接前后，只要其中有一个是变量，结果就在堆中</strong></li></ul><p><strong>调用 intern() 方法，则主动将字符串对象存入字符串常量池中，并将其地址返回</strong></p><blockquote><p>JAVA代码</p></blockquote><pre><code class="highlight java"><span class="meta">@Test</span><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">test2</span><span class="params">()</span>&#123;    <span class="type">String</span> <span class="variable">s1</span> <span class="operator">=</span> <span class="string">&quot;javaEE&quot;</span>;    <span class="type">String</span> <span class="variable">s2</span> <span class="operator">=</span> <span class="string">&quot;hadoop&quot;</span>;    <span class="type">String</span> <span class="variable">s3</span> <span class="operator">=</span> <span class="string">&quot;javaEEhadoop&quot;</span>;    <span class="type">String</span> <span class="variable">s4</span> <span class="operator">=</span> <span class="string">&quot;javaEE&quot;</span> + <span class="string">&quot;hadoop&quot;</span>;<span class="comment">// 编译期优化</span>    <span class="comment">// 如果拼接符号的前后出现了变量，则相当于在堆空间中new String()，具体的内容为拼接的结果：javaEEhadoop</span>    <span class="type">String</span> <span class="variable">s5</span> <span class="operator">=</span> s1 + <span class="string">&quot;hadoop&quot;</span>;    <span class="type">String</span> <span class="variable">s6</span> <span class="operator">=</span> <span class="string">&quot;javaEE&quot;</span> + s2;    <span class="type">String</span> <span class="variable">s7</span> <span class="operator">=</span> s1 + s2;    System.out.println(s3 == s4);<span class="comment">//true</span>    System.out.println(s3 == s5);<span class="comment">//false</span>    System.out.println(s3 == s6);<span class="comment">//false</span>    System.out.println(s3 == s7);<span class="comment">//false</span>    System.out.println(s5 == s6);<span class="comment">//false</span>    System.out.println(s5 == s7);<span class="comment">//false</span>    System.out.println(s6 == s7);<span class="comment">//false</span>    <span class="comment">// intern():判断字符串常量池中是否存在javaEEhadoop值，如果存在，则返回常量池中javaEEhadoop的地址；</span>    <span class="comment">// 如果字符串常量池中不存在javaEEhadoop，则在常量池中加载一份javaEEhadoop，并返回次对象的地址。</span>    <span class="type">String</span> <span class="variable">s8</span> <span class="operator">=</span> s6.intern();    System.out.println(s3 == s8);<span class="comment">//true</span>&#125;</code></pre><blockquote><p>字节码</p></blockquote><pre><code class="highlight plaintext">  0 ldc #6 &lt;javaEE&gt;  2 astore_1  3 ldc #7 &lt;hadoop&gt;  5 astore_2  6 ldc #8 &lt;javaEEhadoop&gt;  8 astore_3  9 ldc #8 &lt;javaEEhadoop&gt; 11 astore 4 13 new #9 &lt;java/lang/StringBuilder&gt; 16 dup 17 invokespecial #10 &lt;java/lang/StringBuilder.&lt;init&gt; : ()V&gt; 20 aload_1 21 invokevirtual #11 &lt;java/lang/StringBuilder.append : (Ljava/lang/String;)Ljava/lang/StringBuilder;&gt; 24 ldc #7 &lt;hadoop&gt; 26 invokevirtual #11 &lt;java/lang/StringBuilder.append : (Ljava/lang/String;)Ljava/lang/StringBuilder;&gt; 29 invokevirtual #12 &lt;java/lang/StringBuilder.toString : ()Ljava/lang/String;&gt; 32 astore 5 34 new #9 &lt;java/lang/StringBuilder&gt; 37 dup 38 invokespecial #10 &lt;java/lang/StringBuilder.&lt;init&gt; : ()V&gt; 41 ldc #6 &lt;javaEE&gt; 43 invokevirtual #11 &lt;java/lang/StringBuilder.append : (Ljava/lang/String;)Ljava/lang/StringBuilder;&gt; 46 aload_2 47 invokevirtual #11 &lt;java/lang/StringBuilder.append : (Ljava/lang/String;)Ljava/lang/StringBuilder;&gt; 50 invokevirtual #12 &lt;java/lang/StringBuilder.toString : ()Ljava/lang/String;&gt; 53 astore 6 55 new #9 &lt;java/lang/StringBuilder&gt; 58 dup 59 invokespecial #10 &lt;java/lang/StringBuilder.&lt;init&gt; : ()V&gt; 62 aload_1 63 invokevirtual #11 &lt;java/lang/StringBuilder.append : (Ljava/lang/String;)Ljava/lang/StringBuilder;&gt; 66 aload_2 67 invokevirtual #11 &lt;java/lang/StringBuilder.append : (Ljava/lang/String;)Ljava/lang/StringBuilder;&gt; 70 invokevirtual #12 &lt;java/lang/StringBuilder.toString : ()Ljava/lang/String;&gt; 73 astore 7 75 getstatic #3 &lt;java/lang/System.out : Ljava/io/PrintStream;&gt; 78 aload_3 79 aload 4 81 if_acmpne 88 (+7) 84 iconst_1 85 goto 89 (+4) 88 iconst_0 89 invokevirtual #4 &lt;java/io/PrintStream.println : (Z)V&gt; 92 getstatic #3 &lt;java/lang/System.out : Ljava/io/PrintStream;&gt; 95 aload_3 96 aload 5 98 if_acmpne 105 (+7)101 iconst_1102 goto 106 (+4)105 iconst_0106 invokevirtual #4 &lt;java/io/PrintStream.println : (Z)V&gt;109 getstatic #3 &lt;java/lang/System.out : Ljava/io/PrintStream;&gt;112 aload_3113 aload 6115 if_acmpne 122 (+7)118 iconst_1119 goto 123 (+4)122 iconst_0123 invokevirtual #4 &lt;java/io/PrintStream.println : (Z)V&gt;126 getstatic #3 &lt;java/lang/System.out : Ljava/io/PrintStream;&gt;129 aload_3130 aload 7132 if_acmpne 139 (+7)135 iconst_1136 goto 140 (+4)139 iconst_0140 invokevirtual #4 &lt;java/io/PrintStream.println : (Z)V&gt;143 getstatic #3 &lt;java/lang/System.out : Ljava/io/PrintStream;&gt;146 aload 5148 aload 6150 if_acmpne 157 (+7)153 iconst_1154 goto 158 (+4)157 iconst_0158 invokevirtual #4 &lt;java/io/PrintStream.println : (Z)V&gt;161 getstatic #3 &lt;java/lang/System.out : Ljava/io/PrintStream;&gt;164 aload 5166 aload 7168 if_acmpne 175 (+7)171 iconst_1172 goto 176 (+4)175 iconst_0176 invokevirtual #4 &lt;java/io/PrintStream.println : (Z)V&gt;179 getstatic #3 &lt;java/lang/System.out : Ljava/io/PrintStream;&gt;182 aload 6184 aload 7186 if_acmpne 193 (+7)189 iconst_1190 goto 194 (+4)193 iconst_0194 invokevirtual #4 &lt;java/io/PrintStream.println : (Z)V&gt;197 aload 6199 invokevirtual #13 &lt;java/lang/String.intern : ()Ljava/lang/String;&gt;202 astore 8204 getstatic #3 &lt;java/lang/System.out : Ljava/io/PrintStream;&gt;207 aload_3208 aload 8210 if_acmpne 217 (+7)213 iconst_1214 goto 218 (+4)217 iconst_0218 invokevirtual #4 &lt;java/io/PrintStream.println : (Z)V&gt;221 return</code></pre><h2 id="3-字符串拼接的底层细节"><a href="#3-字符串拼接的底层细节" class="headerlink" title="3. 字符串拼接的底层细节"></a>3. 字符串拼接的底层细节</h2><h3 id="示例1：StringBuilder"><a href="#示例1：StringBuilder" class="headerlink" title="示例1：StringBuilder"></a>示例1：StringBuilder</h3><p>字符串拼接中存在对象，则使用的是StringBuilder，拼接生成新的对象，对象存储在堆中。</p><blockquote><p>代码</p></blockquote><pre><code class="highlight java"><span class="meta">@Test</span><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">test3</span><span class="params">()</span>&#123;    <span class="type">String</span> <span class="variable">s1</span> <span class="operator">=</span> <span class="string">&quot;a&quot;</span>;    <span class="type">String</span> <span class="variable">s2</span> <span class="operator">=</span> <span class="string">&quot;b&quot;</span>;    <span class="type">String</span> <span class="variable">s3</span> <span class="operator">=</span> <span class="string">&quot;ab&quot;</span>;    <span class="comment">/*</span><span class="comment">        如下的s1 + s2 的执行细节：(变量s是我临时定义的）</span><span class="comment">        ① StringBuilder s = new StringBuilder();</span><span class="comment">        ② s.append(&quot;a&quot;)</span><span class="comment">        ③ s.append(&quot;b&quot;)</span><span class="comment">        ④ s.toString()  --&gt; 约等于 new String(&quot;ab&quot;)</span><span class="comment"></span><span class="comment">        补充：在jdk5.0之后使用的是StringBuilder,在jdk5.0之前使用的是StringBuffer</span><span class="comment">         */</span>    <span class="type">String</span> <span class="variable">s4</span> <span class="operator">=</span> s1 + s2;<span class="comment">//</span>    System.out.println(s3 == s4);<span class="comment">//false</span>&#125;</code></pre><blockquote><p>字节码</p></blockquote><pre><code class="highlight plaintext"> 0 ldc #14 &lt;a&gt; 2 astore_1 3 ldc #15 &lt;b&gt; 5 astore_2 6 ldc #16 &lt;ab&gt; 8 astore_3 9 new #9 &lt;java/lang/StringBuilder&gt;12 dup13 invokespecial #10 &lt;java/lang/StringBuilder.&lt;init&gt; : ()V&gt;16 aload_117 invokevirtual #11 &lt;java/lang/StringBuilder.append : (Ljava/lang/String;)Ljava/lang/StringBuilder;&gt;20 aload_221 invokevirtual #11 &lt;java/lang/StringBuilder.append : (Ljava/lang/String;)Ljava/lang/StringBuilder;&gt;24 invokevirtual #12 &lt;java/lang/StringBuilder.toString : ()Ljava/lang/String;&gt;27 astore 429 getstatic #3 &lt;java/lang/System.out : Ljava/io/PrintStream;&gt;32 aload_333 aload 435 if_acmpne 42 (+7)38 iconst_139 goto 43 (+4)42 iconst_043 invokevirtual #4 &lt;java/io/PrintStream.println : (Z)V&gt;46 return</code></pre><h3 id="示例2：final修饰字符串"><a href="#示例2：final修饰字符串" class="headerlink" title="示例2：final修饰字符串"></a>示例2：final修饰字符串</h3><ul><li>如果拼接符号左右两边都是字符串常量或常量引用，则仍然使用编译期优化，即非StringBuilder的方式。</li><li><strong>final修饰的字符串变量</strong>在拼接过程中依然使用的是编译器优化，拼接结果存储在常量池中。</li></ul><blockquote><p>代码</p></blockquote><pre><code class="highlight java"><span class="comment">/*</span><span class="comment">1. 字符串拼接操作不一定使用的是StringBuilder!</span><span class="comment">   如果拼接符号左右两边都是字符串常量或常量引用，则仍然使用编译期优化，即非StringBuilder的方式。</span><span class="comment">2. 针对于final修饰类、方法、基本数据类型、引用数据类型的量的结构时，能使用上final的时候建议使用上。</span><span class="comment"> */</span><span class="meta">@Test</span><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">test4</span><span class="params">()</span>&#123;    <span class="keyword">final</span> <span class="type">String</span> <span class="variable">s1</span> <span class="operator">=</span> <span class="string">&quot;a&quot;</span>;    <span class="keyword">final</span> <span class="type">String</span> <span class="variable">s2</span> <span class="operator">=</span> <span class="string">&quot;b&quot;</span>;    <span class="type">String</span> <span class="variable">s3</span> <span class="operator">=</span> <span class="string">&quot;ab&quot;</span>;    <span class="type">String</span> <span class="variable">s4</span> <span class="operator">=</span> s1 + s2;    System.out.println(s3 == s4);<span class="comment">//true</span>&#125;</code></pre><blockquote><p>字节码</p><p>从字节码角度来看：为变量 s4 赋值时，直接使用 #16 符号引用，即字符串常量 “ab”</p></blockquote><pre><code class="highlight plaintext"> 0 ldc #14 &lt;a&gt; 2 astore_1 3 ldc #15 &lt;b&gt; 5 astore_2 6 ldc #16 &lt;ab&gt; 8 astore_3 9 ldc #16 &lt;ab&gt;11 astore 413 getstatic #3 &lt;java/lang/System.out : Ljava/io/PrintStream;&gt;16 aload_317 aload 419 if_acmpne 26 (+7)22 iconst_123 goto 27 (+4)26 iconst_027 invokevirtual #4 &lt;java/io/PrintStream.println : (Z)V&gt;30 return</code></pre><h3 id="示例3：字符串拼接与append-效率对比"><a href="#示例3：字符串拼接与append-效率对比" class="headerlink" title="示例3：字符串拼接与append()效率对比"></a>示例3：字符串拼接与append()效率对比</h3><ul><li>append() 的效率要远高于字符串拼接</li></ul><blockquote><p>代码</p></blockquote><pre><code class="highlight java"><span class="comment">/*</span><span class="comment">体会执行效率：通过StringBuilder的append()的方式添加字符串的效率要远高于使用String的字符串拼接方式！</span><span class="comment">详情：① StringBuilder的append()的方式：自始至终中只创建过一个StringBuilder的对象</span><span class="comment">      使用String的字符串拼接方式：创建过多个StringBuilder和String的对象</span><span class="comment">     ② 使用String的字符串拼接方式：内存中由于创建了较多的StringBuilder和String的对象，内存占用更大；如果进行GC，需要花费额外的时间。</span><span class="comment"></span><span class="comment"> 改进的空间：在实际开发中，如果基本确定要前前后后添加的字符串长度不高于某个限定值highLevel的情况下,建议使用构造器实例化：</span><span class="comment">           StringBuilder s = new StringBuilder(highLevel);//new char[highLevel]</span><span class="comment"> */</span><span class="meta">@Test</span><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">test6</span><span class="params">()</span>&#123;    <span class="type">long</span> <span class="variable">start</span> <span class="operator">=</span> System.currentTimeMillis();<span class="comment">//        method1(100000);//4014</span>    method2(<span class="number">100000</span>);<span class="comment">//7</span>    <span class="type">long</span> <span class="variable">end</span> <span class="operator">=</span> System.currentTimeMillis();    System.out.println(<span class="string">&quot;花费的时间为：&quot;</span> + (end - start));&#125;<span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">method1</span><span class="params">(<span class="type">int</span> highLevel)</span>&#123;    <span class="type">String</span> <span class="variable">src</span> <span class="operator">=</span> <span class="string">&quot;&quot;</span>;    <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>;i &lt; highLevel;i++)&#123;        src = src + <span class="string">&quot;a&quot;</span>;<span class="comment">//每次循环都会创建一个StringBuilder、String</span>    &#125;<span class="comment">//        System.out.println(src);</span>&#125;<span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">method2</span><span class="params">(<span class="type">int</span> highLevel)</span>&#123;    <span class="comment">//只需要创建一个StringBuilder</span>    <span class="type">StringBuilder</span> <span class="variable">src</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">StringBuilder</span>();    <span class="comment">// 优化，通过构造器指定长度</span><span class="comment">//        StringBuilder src = new StringBuilder(100000);</span>    <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; highLevel; i++) &#123;        src.append(<span class="string">&quot;a&quot;</span>);    &#125;<span class="comment">//        System.out.println(src);</span>&#125;</code></pre><ul><li>体会执行效率：通过StringBuilder的append()的方式添加字符串的效率要远高于使用String的字符串拼接方式！</li><li>原因：<ul><li>StringBuilder的append()的方式：自始至终中只创建过一个StringBuilder的对象</li><li>使用String的字符串拼接方式：<ul><li>创建过多个StringBuilder和String（调的toString方法）的对象，内存占用更大；</li><li>如果进行GC，需要花费额外的时间（在拼接的过程中产生的一些中间字符串可能永远也用不到，会产生大量垃圾字符串）。</li></ul></li></ul></li><li>改进的空间：<ul><li>在实际开发中，如果基本确定要前前后后添加的字符串长度不高于某个限定值highLevel的情况下，建议使用构造器实例化：<ul><li>StringBuilder s &#x3D; new StringBuilder(highLevel); &#x2F;&#x2F;new char[highLevel] , 这样可以避免频繁扩容</li></ul></li></ul></li></ul><h1 id="六、intern-的使用"><a href="#六、intern-的使用" class="headerlink" title="六、intern() 的使用"></a>六、intern() 的使用</h1><h2 id="1-intern-方法的说明"><a href="#1-intern-方法的说明" class="headerlink" title="1. intern() 方法的说明"></a>1. intern() 方法的说明</h2><pre><code class="highlight java"><span class="keyword">public</span> <span class="keyword">native</span> String <span class="title function_">intern</span><span class="params">()</span>;</code></pre><ul><li><p>intern是一个native方法，调用的是底层C的方法</p></li><li><p>字符串常量池池最初是空的，由String类私有地维护。在调用intern方法时，如果池中已经包含了由equals(object)方法确定的与该字符串内容相等的字符串，则返回池中的字符串地址。否则，该字符串对象将被添加到池中，并返回对该字符串对象的地址。（这是源码里的大概翻译）</p></li><li><p>如果不是用双引号声明的String对象，可以使用String提供的intern方法：intern方法会从字符串常量池中查询当前字符串是否存在，若不存在就会将当前字符串放入常量池中。比如：</p><pre><code class="highlight java"><span class="type">String</span> <span class="variable">myInfo</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">string</span>(<span class="string">&quot;china&quot;</span>).intern();</code></pre></li><li><p>也就是说，如果在任意字符串上调用String.intern方法，那么其返回结果所指向的那个类实例，必须和直接以常量形式出现的字符串实例完全相同。因此，下列表达式的值必定是true</p><pre><code class="highlight java">(<span class="string">&quot;a&quot;</span>+<span class="string">&quot;b&quot;</span>+<span class="string">&quot;c&quot;</span>).intern()==<span class="string">&quot;abc&quot;</span></code></pre></li><li><p>通俗点讲，Interned String 就是确保字符串在内存里只有一份拷贝，这样可以节约内存空间，加快字符串操作任务的执行速度。注意，这个值会被存放在字符串内部池（String Intern Pool）</p></li></ul><h2 id="2-new-String-的说明"><a href="#2-new-String-的说明" class="headerlink" title="2. new String() 的说明"></a>2. new String() 的说明</h2><h3 id="2-1-问题1：new-String-“ab”-会创建几个对象？"><a href="#2-1-问题1：new-String-“ab”-会创建几个对象？" class="headerlink" title="2.1 问题1：new String(“ab”)会创建几个对象？"></a>2.1 问题1：new String(“ab”)会创建几个对象？</h3><pre><code class="highlight java"><span class="type">String</span> <span class="variable">str</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">String</span>(<span class="string">&quot;ab&quot;</span>);</code></pre><blockquote><p>字节码</p></blockquote><pre><code class="highlight plaintext">0 new #2 &lt;java/lang/String&gt;3 dup4 ldc #3 &lt;ab&gt;6 invokespecial #4 &lt;java/lang/String.&lt;init&gt;&gt;9 astore_110 return</code></pre><ul><li><code>0 new #2 &lt;java/lang/String&gt;</code>：在堆中创建了一个 String 对象</li><li><code>4 ldc #3 &lt;ab&gt;</code> ：在字符串常量池中放入 “ab”（如果之前字符串常量池中没有 “ab” 的话）</li></ul><p><strong>注意：</strong></p><p>这里并不表示 str 直接指向常量池中的 ab , 仅仅是str的引用地址指向堆中的一个String对象， 而这个String对象的内容又指向了另一个字符串常量池地址 ab</p><p><img src="https://raw.githubusercontent.com/GeorgeChan95/blogimg/master/img/2023/12/29/20231229-112453.png" alt="image-20231229112448923"></p><h3 id="2-2-问题2：new-String-“a”-new-String-“b”-会创建几个对象？"><a href="#2-2-问题2：new-String-“a”-new-String-“b”-会创建几个对象？" class="headerlink" title="2.2 问题2：new String(“a”) + new String(“b”) 会创建几个对象？"></a>2.2 问题2：new String(“a”) + new String(“b”) 会创建几个对象？</h3><pre><code class="highlight java"><span class="type">String</span> <span class="variable">str3</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">String</span>(<span class="string">&quot;a&quot;</span>) + <span class="keyword">new</span> <span class="title class_">String</span>(<span class="string">&quot;b&quot;</span>);</code></pre><blockquote><p>字节码</p></blockquote><pre><code class="highlight plaintext">0 new #2 &lt;java/lang/StringBuilder&gt;3 dup4 invokespecial #3 &lt;java/lang/StringBuilder.&lt;init&gt;&gt;7 new #4 &lt;java/lang/String&gt;10 dup11 ldc #5 &lt;a&gt;13 invokespecial #6 &lt;java/lang/String.&lt;init&gt;&gt;16 invokevirtual #7 &lt;java/lang/StringBuilder.append&gt;19 new #4 &lt;java/lang/String&gt;22 dup23 ldc #8 &lt;b&gt;25 invokespecial #6 &lt;java/lang/String.&lt;init&gt;&gt;28 invokevirtual #7 &lt;java/lang/StringBuilder.append&gt;31 invokevirtual #9 &lt;java/lang/StringBuilder.toString&gt;34 astore_135 return</code></pre><p><strong>答案是4个或5个或6个</strong></p><p>字节码指令分析：</p><ul><li><code>0 new #2 &lt;java/lang/StringBuilder&gt;</code> ：拼接字符串会创建一个 StringBuilder 对象</li><li><code>7 new #4 &lt;java/lang/String&gt;</code> ：创建 String 对象，对应于 new String(“a”)</li><li><code>11 ldc #5 &lt;a&gt;</code> ：在字符串常量池中放入 “a”（如果之前字符串常量池中没有 “a” 的话）</li><li><code>19 new #4 &lt;java/lang/String&gt;</code> ：创建 String 对象，对应于 new String(“b”)</li><li><code>23 ldc #8 &lt;b&gt;</code> ：在字符串常量池中放入 “b”（如果之前字符串常量池中没有 “b” 的话）</li><li><code>31 invokevirtual #9 &lt;java/lang/StringBuilder.toString&gt;</code> ：调用 StringBuilder 的 toString() 方法，会生成一个 String 对象</li></ul><p><strong>强调一下，toString()的调用，在字符串常量池中，没有生成”ab”</strong></p><h2 id="3-面试题"><a href="#3-面试题" class="headerlink" title="3. 面试题"></a>3. 面试题</h2><pre><code class="highlight plaintext">/** * 如何保证变量s指向的是字符串常量池中的数据呢？ * 有两种方式： * 方式一： String s = &quot;shkstart&quot;;//字面量定义的方式 * 方式二： 调用intern() *         String s = new String(&quot;shkstart&quot;).intern(); *         String s = new StringBuilder(&quot;shkstart&quot;).toString().intern(); */public class StringIntern &#123;    public static void main(String[] args) &#123;        String s = new String(&quot;1&quot;);        s.intern();//调用此方法之前，字符串常量池中已经存在了&quot;1&quot;        String s2 = &quot;1&quot;;        System.out.println(s == s2);//jdk6：false   jdk7/8：false        String s3 = new String(&quot;1&quot;) + new String(&quot;1&quot;);//s3变量记录的地址为：new String(&quot;11&quot;)        //执行完上一行代码以后，字符串常量池中，是否存在&quot;11&quot;呢？答案：不存在！！        s3.intern();//在字符串常量池中生成&quot;11&quot;。如何理解：jdk6:创建了一个新的对象&quot;11&quot;,也就有新的地址。                                            //         jdk7:此时常量中并没有创建&quot;11&quot;,而是创建一个指向堆空间中new String(&quot;11&quot;)的地址        String s4 = &quot;11&quot;;//s4变量记录的地址：使用的是上一行代码代码执行时，在常量池中生成的&quot;11&quot;的地址        /**         * 先执行         *      s3.intern();         * 再执行         *      String s4 = &quot;11&quot;;         * 则   s3 == s4 为：true         * 如果执行顺序相反，则结果为false。         * 原因：先执行 s3.intern(); 则将s3的指向的对象[11]放入到了字符串常量池，常量地址值就是s3的内存地址值。         *      此时再执行 String s4 = &quot;11&quot;; 会优先从常量池查找是否有字符串为 11 的常量，有则返回常量的地址，         *      所以此时 s3 == s4 为：true         */        System.out.println(s3 == s4);//jdk6：false  jdk7/8：true    &#125;&#125;</code></pre><h3 id="打印结果"><a href="#打印结果" class="headerlink" title="打印结果"></a>打印结果</h3><ul><li>jdk6 下<code>false false</code></li><li>jdk7 下<code>false true</code></li></ul><h3 id="JDK6的解释"><a href="#JDK6的解释" class="headerlink" title="JDK6的解释"></a>JDK6的解释</h3><p><img src="https://raw.githubusercontent.com/GeorgeChan95/blogimg/master/img/2023/12/29/20231229-120054.png" alt="jdk6图"></p><p>注：图中绿色线条代表 string 对象的内容指向。 黑色线条代表地址指向。</p><p>如上图所示。首先说一下 jdk6中的情况，在 jdk6中上述的所有打印都是 false 的，因为 jdk6中的常量池是放在 Perm 区中的，Perm 区和正常的 JAVA Heap 区域是完全分开的。上面说过如果是使用引号声明的字符串都是会直接在字符串常量池中生成，而 new 出来的 String 对象是放在 JAVA Heap 区域。所以拿一个 JAVA Heap 区域的对象地址和字符串常量池的对象地址进行比较肯定是不相同的，即使调用<code>String.intern</code>方法也是没有任何关系的。</p><h3 id="jdk7中的解释"><a href="#jdk7中的解释" class="headerlink" title="jdk7中的解释"></a>jdk7中的解释</h3><p>再说说 jdk7 中的情况。这里要明确一点的是，在 Jdk6 以及以前的版本中，字符串的常量池是放在堆的 Perm 区的，Perm 区是一个类静态的区域，主要存储一些加载类的信息，常量池，方法片段等内容，默认大小只有4m，一旦常量池中大量使用 intern 是会直接产生<code>java.lang.OutOfMemoryError: PermGen space</code>错误的。 所以在 jdk7 的版本中，字符串常量池已经从 Perm 区移到正常的 Java Heap 区域了。为什么要移动，Perm 区域太小是一个主要原因，当然据消息称 jdk8 已经直接取消了 Perm 区域，而新建立了一个元区域。应该是 jdk 开发者认为 Perm 区域已经不适合现在 JAVA 的发展了。</p><p>正式因为字符串常量池移动到 JAVA Heap 区域后，再来解释为什么会有上述的打印结果。</p><p><img src="https://raw.githubusercontent.com/GeorgeChan95/blogimg/master/img/2023/12/29/20231229-120212.png" alt="jdk7图1"></p><ul><li>在第一段代码中，先看 s3和s4字符串。<code>String s3 = new String(&quot;1&quot;) + new String(&quot;1&quot;);</code>，这句代码中现在生成了2最终个对象，是字符串常量池中的“1” 和 JAVA Heap 中的 s3引用指向的对象。中间还有2个匿名的<code>new String(&quot;1&quot;)</code>我们不去讨论它们。此时s3引用对象内容是”11”，但此时常量池中是没有 “11”对象的。</li><li>接下来<code>s3.intern();</code>这一句代码，是将 s3中的“11”字符串放入 String 常量池中，因为此时常量池中不存在“11”字符串，因此常规做法是跟 jdk6 图中表示的那样，在常量池中生成一个 “11” 的对象，关键点是 jdk7 中常量池不在 Perm 区域了，这块做了调整。常量池中不需要再存储一份对象了，可以直接存储堆中的引用。这份引用指向 s3 引用的对象。 也就是说引用地址是相同的。</li><li>最后<code>String s4 = &quot;11&quot;;</code> 这句代码中”11”是显示声明的，因此会直接去常量池中创建，创建的时候发现已经有这个对象了，此时也就是指向 s3 引用对象的一个引用。所以 s4 引用就指向和 s3 一样了。因此最后的比较 <code>s3 == s4</code> 是 true。</li></ul><p><strong>完整的解析见：参考链接</strong></p><h2 id="4-intern-方法的练习"><a href="#4-intern-方法的练习" class="headerlink" title="4. intern() 方法的练习"></a>4. intern() 方法的练习</h2><h3 id="4-1-练习-1"><a href="#4-1-练习-1" class="headerlink" title="4.1 练习 1"></a>4.1 练习 1</h3><pre><code class="highlight java"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">StringExer1</span> &#123;    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;        <span class="type">String</span> <span class="variable">s</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">String</span>(<span class="string">&quot;a&quot;</span>) + <span class="keyword">new</span> <span class="title class_">String</span>(<span class="string">&quot;b&quot;</span>);<span class="comment">//new String(&quot;ab&quot;)</span>        <span class="comment">//在上一行代码执行完以后，字符串常量池中并没有&quot;ab&quot;</span>        <span class="type">String</span> <span class="variable">s2</span> <span class="operator">=</span> s.intern();<span class="comment">//jdk6中：在串池中创建一个字符串&quot;ab&quot;</span>                               <span class="comment">//jdk8中：串池中没有创建字符串&quot;ab&quot;,而是创建一个引用，指向new String(&quot;ab&quot;)，将此引用返回</span>        System.out.println(s2 == <span class="string">&quot;ab&quot;</span>);<span class="comment">//jdk6:true  jdk8:true</span>        System.out.println(s == <span class="string">&quot;ab&quot;</span>);<span class="comment">//jdk6:false  jdk8:true</span>    &#125;&#125;</code></pre><h4 id="JDK6"><a href="#JDK6" class="headerlink" title="JDK6"></a>JDK6</h4><img src="https://raw.githubusercontent.com/GeorgeChan95/blogimg/master/img/2023/12/29/20231229-125241.png" alt="image-20231229125239603" style="zoom:67%;" /><h4 id="JDK7-8"><a href="#JDK7-8" class="headerlink" title="JDK7&#x2F;8"></a>JDK7&#x2F;8</h4><img src="https://raw.githubusercontent.com/GeorgeChan95/blogimg/master/img/2023/12/29/20231229-125345.png" alt="image-20231229125322439" style="zoom:67%;" /><h3 id="4-2-练习2"><a href="#4-2-练习2" class="headerlink" title="4.2 练习2"></a>4.2 练习2</h3><pre><code class="highlight java"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">StringExer1</span> &#123;    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;        <span class="type">String</span> <span class="variable">x</span> <span class="operator">=</span> <span class="string">&quot;ab&quot;</span>;        <span class="type">String</span> <span class="variable">s</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">String</span>(<span class="string">&quot;a&quot;</span>) + <span class="keyword">new</span> <span class="title class_">String</span>(<span class="string">&quot;b&quot;</span>);<span class="comment">//new String(&quot;ab&quot;)</span>        <span class="comment">//在上一行代码执行完以后，字符串常量池中并没有&quot;ab&quot;</span>        <span class="type">String</span> <span class="variable">s2</span> <span class="operator">=</span> s.intern();<span class="comment">//jdk6中：在串池中创建一个字符串&quot;ab&quot;</span>                               <span class="comment">//jdk8中：串池中没有创建字符串&quot;ab&quot;,而是创建一个引用，指向new String(&quot;ab&quot;)，将此引用返回</span>        System.out.println(s2 == x);<span class="comment">//jdk6:true  jdk8:true</span>        System.out.println(s == x);<span class="comment">//jdk6:false  jdk8:false</span>    &#125;&#125;</code></pre><img src="https://raw.githubusercontent.com/GeorgeChan95/blogimg/master/img/2023/12/29/20231229-131153.png" alt="image-20231229131124299" style="zoom:67%;" /><h3 id="4-3-练习3"><a href="#4-3-练习3" class="headerlink" title="4.3 练习3"></a>4.3 练习3</h3><blockquote><p>代码</p></blockquote><pre><code class="highlight java"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">StringExer2</span> &#123;    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;        <span class="type">String</span> <span class="variable">s1</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">String</span>(<span class="string">&quot;ab&quot;</span>);<span class="comment">//执行完以后，会在字符串常量池中会生成&quot;ab&quot;</span>        s1.intern();        <span class="type">String</span> <span class="variable">s2</span> <span class="operator">=</span> <span class="string">&quot;ab&quot;</span>;        System.out.println(s1 == s2); <span class="comment">// false</span>        System.out.println(<span class="string">&quot;======================================================&quot;</span>);        <span class="type">String</span> <span class="variable">s3</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">String</span>(<span class="string">&quot;x&quot;</span>) + <span class="keyword">new</span> <span class="title class_">String</span>(<span class="string">&quot;y&quot;</span>);<span class="comment">// 执行完以后，不会在字符串常量池中会生成&quot;xy&quot;</span>        s3.intern();        <span class="type">String</span> <span class="variable">s4</span> <span class="operator">=</span> <span class="string">&quot;xy&quot;</span>;        System.out.println(s3 == s4); <span class="comment">// true</span>    &#125;&#125;</code></pre><blockquote><p>验证</p></blockquote><pre><code class="highlight java"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">StringExer2</span> &#123;    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;        <span class="type">String</span> <span class="variable">s1</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">String</span>(<span class="string">&quot;ab&quot;</span>);<span class="comment">//执行完以后，会在字符串常量池中会生成&quot;ab&quot;</span><span class="comment">//        String s1 = new String(&quot;a&quot;) + new String(&quot;b&quot;);</span>        System.out.println(System.identityHashCode(s1));        s1.intern();        System.out.println(System.identityHashCode(s1));        <span class="type">String</span> <span class="variable">s2</span> <span class="operator">=</span> <span class="string">&quot;ab&quot;</span>;        System.out.println(System.identityHashCode(s2));        System.out.println(s1 == s2); <span class="comment">// false</span>        System.out.println(<span class="string">&quot;======================================================&quot;</span>);        <span class="type">String</span> <span class="variable">s3</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">String</span>(<span class="string">&quot;x&quot;</span>) + <span class="keyword">new</span> <span class="title class_">String</span>(<span class="string">&quot;y&quot;</span>); <span class="comment">//执行完以后，不会在字符串常量池中会生成&quot;xy&quot;</span>        System.out.println(System.identityHashCode(s3));        s3.intern();        System.out.println(System.identityHashCode(s3));        <span class="type">String</span> <span class="variable">s4</span> <span class="operator">=</span> <span class="string">&quot;xy&quot;</span>;        System.out.println(System.identityHashCode(s4));        System.out.println(s3 == s4);    &#125;&#125;</code></pre><blockquote><p>打印结果</p></blockquote><pre><code class="highlight plaintext">1735600054173560005421685669false======================================================213392700221339270022133927002true</code></pre><h2 id="5-intern-的效率测试（空间角度）"><a href="#5-intern-的效率测试（空间角度）" class="headerlink" title="5. intern() 的效率测试（空间角度）"></a>5. intern() 的效率测试（空间角度）</h2><pre><code class="highlight java"><span class="comment">/**</span><span class="comment"> * 使用intern()测试执行效率：空间使用上</span><span class="comment"> * 结论：对于程序中大量存在存在的字符串，尤其其中存在很多重复字符串时，使用intern()可以节省内存空间。</span><span class="comment"> */</span><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">StringIntern2</span> &#123;    <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">int</span> <span class="variable">MAX_COUNT</span> <span class="operator">=</span> <span class="number">1000</span> * <span class="number">10000</span>;    <span class="keyword">static</span> <span class="keyword">final</span> String[] arr = <span class="keyword">new</span> <span class="title class_">String</span>[MAX_COUNT];    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;        Integer[] data = <span class="keyword">new</span> <span class="title class_">Integer</span>[]&#123;<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>,<span class="number">6</span>,<span class="number">7</span>,<span class="number">8</span>,<span class="number">9</span>,<span class="number">10</span>&#125;;        <span class="type">long</span> <span class="variable">start</span> <span class="operator">=</span> System.currentTimeMillis();        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; MAX_COUNT; i++) &#123;            arr[i] = <span class="keyword">new</span> <span class="title class_">String</span>(String.valueOf(data[i % data.length])); <span class="comment">// 花费的时间为：4568</span>            arr[i] = <span class="keyword">new</span> <span class="title class_">String</span>(String.valueOf(data[i % data.length])).intern(); <span class="comment">// 花费的时间为：1050</span>        &#125;        <span class="type">long</span> <span class="variable">end</span> <span class="operator">=</span> System.currentTimeMillis();        System.out.println(<span class="string">&quot;花费的时间为：&quot;</span> + (end - start));        <span class="keyword">try</span> &#123;            Thread.sleep(<span class="number">1000000</span>);        &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;            e.printStackTrace();        &#125;        System.gc();    &#125;&#125;</code></pre><ul><li><p>直接 new String ：由于每个 String 对象都是 new 出来的，所以程序需要维护大量存放在堆空间中的 String 实例，程序内存占用也会变高</p><pre><code class="highlight java">arr[i] = <span class="keyword">new</span> <span class="title class_">String</span>(String.valueOf(data[i % data.length])); <span class="comment">// 花费的时间为：4568</span></code></pre></li></ul><img src="https://raw.githubusercontent.com/GeorgeChan95/blogimg/master/img/2023/12/29/20231229-143312.png" alt="image-20231229143310962" style="zoom:50%;" /><ul><li><p>使用 intern() 方法：由于数组中字符串的引用都指向字符串常量池中的字符串，所以程序需要维护的 String 对象更少，内存占用也更低。</p><pre><code class="highlight java"><span class="comment">// 调用了intern()方法使用了字符串常量池里的字符串，那么前面堆里的字符串便会被GC掉，这也是intern省内存的关键原因</span>arr[i] = <span class="keyword">new</span> <span class="title class_">String</span>(String.valueOf(data[i % data.length])).intern(); <span class="comment">// 花费的时间为：1050</span></code></pre></li></ul><img src="https://raw.githubusercontent.com/GeorgeChan95/blogimg/master/img/2023/12/29/20231229-143837.png" alt="image-20231229143836136" style="zoom:50%;" /><p><strong>结论</strong>：</p><ul><li>对于程序中大量使用存在的字符串时，尤其存在很多已经重复的字符串时，使用intern()方法能够节省很大的内存空间。</li><li>大的网站平台，需要内存中存储大量的字符串。比如社交网站，很多人都存储：北京市、海淀区等信息。这时候如果字符串都调用intern() 方法，就会很明显降低内存的大小。</li></ul><h1 id="七、StringTable-的垃圾回收"><a href="#七、StringTable-的垃圾回收" class="headerlink" title="七、StringTable 的垃圾回收"></a>七、StringTable 的垃圾回收</h1><blockquote><p>示例代码</p></blockquote><pre><code class="highlight java"><span class="comment">/**</span><span class="comment"> * String的垃圾回收:</span><span class="comment"> * -Xms15m -Xmx15m -XX:+PrintStringTableStatistics -XX:+PrintGCDetails</span><span class="comment"> */</span><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">StringGCTest</span> &#123;    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> <span class="number">0</span>; j &lt; <span class="number">100000</span>; j++) &#123;            String.valueOf(j).intern();        &#125;    &#125;&#125;</code></pre><blockquote><p>输出结果：</p></blockquote><ul><li>在 PSYoungGen 区发生了垃圾回收</li><li>Number of entries 和 Number of literals 明显没有 100000</li><li>以上两点均说明 StringTable 区发生了垃圾回收</li></ul><p><img src="https://raw.githubusercontent.com/GeorgeChan95/blogimg/master/img/2023/12/29/20231229-145743.png" alt="image-20231229145741545"></p><h1 id="八、G1-中的-String-去重操作"><a href="#八、G1-中的-String-去重操作" class="headerlink" title="八、G1 中的 String 去重操作"></a>八、G1 中的 String 去重操作</h1><blockquote><p>官方文档：<a href="https://openjdk.org/jeps/192">https://openjdk.org/jeps/192</a></p></blockquote><h2 id="1-String去重操作的背景"><a href="#1-String去重操作的背景" class="headerlink" title="1. String去重操作的背景"></a>1. String去重操作的背景</h2><blockquote><p>注意不是字符串常量池的去重操作，字符串常量池本身就没有重复的</p></blockquote><ul><li>背景：对许多Java应用（有大的也有小的）做的测试得出以下结果：<ul><li>堆存活数据集合里面String对象占了25%</li><li>堆存活数据集合里面重复的String对象有13.5%</li><li>String对象的平均长度是45</li></ul></li><li>许多大规模的Java应用的瓶颈在于内存，测试表明，在这些类型的应用里面，Java堆中存活的数据集合差不多25%是String对象。更进一步，这里面差不多一半String对象是重复的，重复的意思是说：<code>str1.equals(str2)= true</code>。堆上存在重复的String对象必然是一种内存的浪费。这个项目将在G1垃圾收集器中实现自动持续对重复的String对象进行去重，这样就能避免浪费内存。</li></ul><h2 id="2-String-去重的的实现"><a href="#2-String-去重的的实现" class="headerlink" title="2. String 去重的的实现"></a>2. String 去重的的实现</h2><ul><li>当垃圾收集器工作的时候，会访问堆上存活的对象。对每一个访问的对象都会检查是否是候选的要去重的String对象。</li><li>如果是，把这个对象的一个引用插入到队列中等待后续的处理。一个去重的线程在后台运行，处理这个队列。处理队列的一个元素意味着从队列删除这个元素，然后尝试去重它引用的String对象。</li><li>使用一个Hashtable来记录所有的被String对象使用的不重复的char数组。当去重的时候，会查这个Hashtable，来看堆上是否已经存在一个一模一样的char数组。</li><li>如果存在，String对象会被调整引用那个数组，释放对原来的数组的引用，最终会被垃圾收集器回收掉。</li><li>如果查找失败，char数组会被插入到Hashtable，这样以后的时候就可以共享这个数组了。</li></ul><h2 id="3-命令行选项"><a href="#3-命令行选项" class="headerlink" title="3. 命令行选项"></a>3. 命令行选项</h2><ul><li>UseStringDeduplication(bool) ：开启String去重，默认是不开启的，需要手动开启。</li><li>PrintStringDeduplicationStatistics(bool) ：打印详细的去重统计信息</li><li>stringDeduplicationAgeThreshold(uintx) ：达到这个年龄的String对象被认为是去重的候选对象</li></ul><h1 id="参考链接"><a href="#参考链接" class="headerlink" title="参考链接"></a>参考链接</h1><blockquote><p>深入解析String#intern：<a href="https://tech.meituan.com/2014/03/06/in-depth-understanding-string-intern.html">https://tech.meituan.com/2014/03/06/in-depth-understanding-string-intern.html</a></p></blockquote>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;环境&quot;&gt;&lt;a href=&quot;#环境&quot; class=&quot;headerlink&quot; title=&quot;环境&quot;&gt;&lt;/a&gt;环境&lt;/h1&gt;&lt;blockquote&gt;
&lt;p&gt;系统 : Windows 10&lt;br&gt;JDK : 1.8&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h1 id=&quot;一、</summary>
      
    
    
    
    <category term="JVM" scheme="https://georgechan95.github.io/categories/JVM/"/>
    
    
    <category term="jvm" scheme="https://georgechan95.github.io/tags/jvm/"/>
    
    <category term="java" scheme="https://georgechan95.github.io/tags/java/"/>
    
  </entry>
  
  <entry>
    <title>第十章-执行引擎</title>
    <link href="https://georgechan95.github.io/2023/12/23/jvm/%E7%AC%AC%E5%8D%81%E7%AB%A0-%E6%89%A7%E8%A1%8C%E5%BC%95%E6%93%8E/"/>
    <id>https://georgechan95.github.io/2023/12/23/jvm/%E7%AC%AC%E5%8D%81%E7%AB%A0-%E6%89%A7%E8%A1%8C%E5%BC%95%E6%93%8E/</id>
    <published>2023-12-23T12:03:00.000Z</published>
    <updated>2024-06-22T10:36:12.823Z</updated>
    
    <content type="html"><![CDATA[<h1 id="环境"><a href="#环境" class="headerlink" title="环境"></a>环境</h1><blockquote><p>系统 : Windows 10<br>JDK : 1.8</p></blockquote><h1 id="一、执行引擎"><a href="#一、执行引擎" class="headerlink" title="一、执行引擎"></a>一、执行引擎</h1><p><img src="https://raw.githubusercontent.com/GeorgeChan95/blogimg/master/img/2023/12/21/20231221-194101.png" alt="image-20231221194038014"></p><h2 id="1-执行引擎概述"><a href="#1-执行引擎概述" class="headerlink" title="1. 执行引擎概述"></a>1. 执行引擎概述</h2><ul><li>执行引擎是Java虚拟机核心的组成部分之一。</li><li>“虚拟机”是一个相对于“物理机”的概念，这两种机器都有代码执行能力，其区别是物理机的执行引擎是直接建立在处理器、缓存、指令集和操作系统层面上的，而<strong>虚拟机的执行引擎则是由软件自行实现的</strong>，因此可以不受物理条件制约地定制指令集与执行引擎的结构体系，<strong>能够执行那些不被硬件直接支持的指令集格式</strong>。</li><li>JVM的主要任务是负责<strong>装载字节码到其内部</strong>，但字节码并不能够直接运行在操作系统之上，因为字节码指令并非等价于本地机器指令，它内部包含的仅仅只是一些能够被JVM所识别的字节码指令、符号表，以及其他辅助信息。</li><li>那么，如果想要让一个Java程序运行起来，执行引擎（Execution Engine）的任务就是<strong>将字节码指令解释&#x2F;编译为对应平台上的本地机器指令才可以</strong>。简单来说，JVM中的执行引擎充当了将高级语言翻译为机器语言的译者。</li></ul><p><img src="https://raw.githubusercontent.com/GeorgeChan95/blogimg/master/img/2023/12/23/20231223-201545.jpg" alt="Java语言的跨平台性"></p><ul><li>前端编译：从Java程序员-字节码文件的这个过程叫前端编译</li><li>执行引擎这里有两种行为：一种是解释执行，一种是编译执行（这里的是后端编译）。</li></ul><h2 id="2-执行引擎工作过程"><a href="#2-执行引擎工作过程" class="headerlink" title="2. 执行引擎工作过程"></a>2. 执行引擎工作过程</h2><ul><li>执行引擎在执行的过程中究竟需要执行什么样的字节码指令完全依赖于PC寄存器。</li><li>每当执行完一项指令操作后，PC寄存器就会更新下一条需要被执行的指令地址。</li><li>当然方法在执行的过程中，执行引擎有可能会通过存储在局部变量表中的对象引用准确定位到存储在Java堆区中的对象实例信息，以及通过对象头中的元数据指针定位到目标对象的类型信息。</li><li>从外观上来看，所有的Java虚拟机的执行引擎输入、处理、输出都是一致的：输入的是字节码二进制流，处理过程是字节码解析执行、即时编译的等效过程，输出的是执行过程。</li></ul><img src="https://raw.githubusercontent.com/GeorgeChan95/blogimg/master/img/2023/12/24/20231224-124745.jpg" alt="执行引擎的工作过程" style="zoom:67%;" /><h1 id="二、Java代码编译和执行过程"><a href="#二、Java代码编译和执行过程" class="headerlink" title="二、Java代码编译和执行过程"></a>二、Java代码编译和执行过程</h1><h2 id="1-解释执行和即时编译"><a href="#1-解释执行和即时编译" class="headerlink" title="1. 解释执行和即时编译"></a>1. 解释执行和即时编译</h2><p>大部分的程序代码转换成物理机的目标代码或虚拟机能执行的指令集之前，都需要经过下图中的各个步骤：</p><ul><li>前面橙色部分是编译生成生成字节码文件的过程（javac编译器来完成，也就是前端编译器），和JVM没有关系。</li><li>后面绿色（解释执行）和蓝色（即时编译）才是JVM需要考虑的过程</li></ul><p><img src="https://raw.githubusercontent.com/GeorgeChan95/blogimg/master/img/2023/12/24/20231224-130031.jpg" alt="程序执行过程"></p><ul><li><p>javac编译器（前端编译器）流程图如下所示：</p><p><img src="https://raw.githubusercontent.com/GeorgeChan95/blogimg/master/img/2023/12/24/20231224-130716.png" alt="image-20231224130715139"></p></li><li><p>Java字节码的执行是由JVM执行引擎来完成，流程图如下所示</p></li></ul><p><img src="https://raw.githubusercontent.com/GeorgeChan95/blogimg/master/img/2023/12/24/20231224-131223.png" alt="image-20231224131221760"></p><h2 id="2-什么是解释器？什么是JIT编译器？"><a href="#2-什么是解释器？什么是JIT编译器？" class="headerlink" title="2. 什么是解释器？什么是JIT编译器？"></a>2. 什么是解释器？什么是JIT编译器？</h2><ul><li>解释器：当Java虚拟机启动时会根据预定义的规范对字节码采用<strong>逐行</strong>解释的方式<strong>执行</strong>，将每条字节码文件中的内容“翻译”为对应平台的本地机器指令执行。</li><li>JIT（Just In Time Compiler）编译器：就是虚拟机将源代码<strong>一次性直接</strong>编译成和本地机器平台相关的机器语言，<strong>但并不是马上执行</strong>。</li></ul><h3 id="2-1-为什么Java是半编译半解释型语言？"><a href="#2-1-为什么Java是半编译半解释型语言？" class="headerlink" title="2.1 为什么Java是半编译半解释型语言？"></a>2.1 为什么Java是半编译半解释型语言？</h3><ul><li>JDK1.0时代，将Java语言定位为“解释执行”还是比较准确的。再后来，Java也发展出可以直接生成本地代码的编译器。</li><li>现在JVM在执行Java代码的时候，通常都会将解释执行与编译执行二者结合起来进行。</li><li>JIT编译器将字节码翻译成本地代码后，就可以做一个缓存操作，存储在方法区的<strong>JIT 代码缓存</strong>中（执行效率更高了），并且在翻译成本地代码的过程中可以做优化。</li></ul><p><img src="https://raw.githubusercontent.com/GeorgeChan95/blogimg/master/img/2023/12/24/20231224-132552.jpg" alt="理解执行引擎"></p><h1 id="三、机器码、指令、汇编语言"><a href="#三、机器码、指令、汇编语言" class="headerlink" title="三、机器码、指令、汇编语言"></a>三、机器码、指令、汇编语言</h1><h2 id="1-机器码"><a href="#1-机器码" class="headerlink" title="1. 机器码"></a>1. 机器码</h2><ul><li>各种用二进制编码方式表示的指令，叫做机器指令码。开始，人们就用它采编写程序，这就是机器语言。</li><li>机器语言虽然能够被计算机理解和接受，但和人们的语言差别太大，不易被人们理解和记忆，并且用它编程容易出差错。</li><li>用它编写的程序一经输入计算机，CPU直接读取运行，因此和其他语言编的程序相比，执行速度最快。</li><li>机器指令与CPU紧密相关，所以不同种类的CPU所对应的机器指令也就不同。</li></ul><h2 id="2-指令和指令集"><a href="#2-指令和指令集" class="headerlink" title="2. 指令和指令集"></a>2. 指令和指令集</h2><h3 id="2-1-指令"><a href="#2-1-指令" class="headerlink" title="2.1 指令"></a>2.1 指令</h3><ul><li>由于机器码是由0和1组成的二进制序列，可读性实在太差，于是人们发明了指令。</li><li>指令就是把机器码中特定的0和1序列，简化成对应的指令（一般为英文简写，如mov，inc等），可读性稍好</li><li>由于不同的硬件平台，执行同一个操作，对应的机器码可能不同，所以不同的硬件平台的同一种指令（比如mov），对应的机器码也可能不同。</li></ul><h3 id="2-2-指令集"><a href="#2-2-指令集" class="headerlink" title="2.2 指令集"></a>2.2 指令集</h3><p>不同的硬件平台，各自支持的指令，是有差别的。因此每个平台所支持的指令，称之为对应平台的指令集。如常见的</p><ul><li>x86指令集，对应的是x86架构的平台</li><li>ARM指令集，对应的是ARM架构的平台</li></ul><h2 id="3-汇编语言"><a href="#3-汇编语言" class="headerlink" title="3. 汇编语言"></a>3. 汇编语言</h2><ul><li>由于指令的可读性还是太差，于是人们又发明了汇编语言。</li><li>在汇编语言中，用助记符（Mnemonics）代替机器指令的操作码，用地址符号（Symbol）或标号（Label）代替指令或操作数的地址。</li><li>在不同的硬件平台，汇编语言对应着不同的机器语言指令集，通过汇编过程转换成机器指令。</li><li>由于计算机只认识指令码，所以用汇编语言编写的程序还必须翻译（汇编）成机器指令码，计算机才能识别和执行。</li></ul><h2 id="4-高级语言"><a href="#4-高级语言" class="headerlink" title="4. 高级语言"></a>4. 高级语言</h2><ul><li>为了使计算机用户编程序更容易些，后来就出现了各种高级计算机语言。高级语言比机器语言、汇编语言更接近人的语言</li><li>当计算机执行高级语言编写的程序时，仍然需要把程序解释和编译成机器的指令码。完成这个过程的程序就叫做解释程序或编译程序。</li></ul><p><img src="https://raw.githubusercontent.com/GeorgeChan95/blogimg/master/img/2023/12/24/20231224-134433.jpg" alt="机器语言、汇编、高级语言"></p><h2 id="5-字节码"><a href="#5-字节码" class="headerlink" title="5. 字节码"></a>5. 字节码</h2><ul><li>字节码是一种中间状态（中间码）的二进制代码（文件），它比机器码更抽象，需要直译器转译后才能成为机器码</li><li>字节码主要为了实现特定软件运行和软件环境、与硬件环境无关。</li><li>字节码的实现方式是通过编译器和虚拟机器。编译器将源码编译成字节码，特定平台上的虚拟机器将字节码转译为可以直接执行的指令。</li><li>字节码典型的应用为：Java bytecode</li></ul><h2 id="6-C、C-源程序执行过程"><a href="#6-C、C-源程序执行过程" class="headerlink" title="6. C、C++源程序执行过程"></a>6. C、C++源程序执行过程</h2><p><strong>编译过程又可以分成两个阶段：编译和汇编。</strong></p><ul><li>编译过程：是读取源程序（字符流），对之进行词法和语法的分析，将高级语言指令转换为功能等效的汇编代码</li><li>汇编过程：实际上指把汇编语言代码翻译成目标机器指令的过程。</li></ul><p><img src="https://raw.githubusercontent.com/GeorgeChan95/blogimg/master/img/2023/12/24/20231224-134804.png" alt="image-20231224134803020"></p><h1 id="四、解释器"><a href="#四、解释器" class="headerlink" title="四、解释器"></a>四、解释器</h1><h2 id="1-为什么要有解释器"><a href="#1-为什么要有解释器" class="headerlink" title="1. 为什么要有解释器"></a>1. 为什么要有解释器</h2><ul><li>JVM设计者们的初衷仅仅只是单纯地为了满足Java程序实现跨平台特性，因此避免采用静态编译的方式由高级语言直接生成本地机器指令，从而诞生了实现解释器在运行时采用逐行解释字节码执行程序的想法（也就是产生了一个中间产品<strong>字节码</strong>）。</li><li>解释器真正意义上所承担的角色就是一个运行时“翻译者”，将字节码文件中的内容“翻译”为对应平台的本地机器指令执行。</li><li>当一条字节码指令被解释执行完成后，接着再根据PC寄存器中记录的下一条需要被执行的字节码指令执行解释操作。</li></ul><p><img src="https://raw.githubusercontent.com/GeorgeChan95/blogimg/master/img/2023/12/24/20231224-135813.jpg" alt="第12章理解中间过程"></p><h2 id="2-解释器的分类"><a href="#2-解释器的分类" class="headerlink" title="2. 解释器的分类"></a>2. 解释器的分类</h2><ul><li>在Java的发展历史里，一共有两套解释执行器，即古老的<strong>字节码解释器</strong>、现在普遍使用的<strong>模板解释器</strong>。<ul><li>字节码解释器在执行时通过纯软件代码模拟字节码的执行，效率非常低下。</li><li>而模板解释器将每一条字节码和一个模板函数相关联，模板函数中直接产生这条字节码执行时的机器码，从而很大程度上提高了解释器的性能。</li></ul></li><li>在HotSpot VM中，解释器主要由Interpreter模块和Code模块构成。<ul><li>Interpreter模块：实现了解释器的核心功能</li><li>Code模块：用于管理HotSpot VM在运行时生成的本地机器指令</li></ul></li></ul><h2 id="3-解释器的现状"><a href="#3-解释器的现状" class="headerlink" title="3. 解释器的现状"></a>3. 解释器的现状</h2><ul><li>由于解释器在设计和实现上非常简单，因此除了Java语言之外，还有许多高级语言同样也是基于解释器执行的，比如Python、Perl、Ruby等。但是在今天，基于解释器执行已经沦落为低效的代名词，并且时常被一些C&#x2F;C++程序员所调侃。</li><li>为了解决这个问题，JVM平台支持一种叫作即时编译的技术。即时编译的目的是避免函数被解释执行，而是将整个函数体编译成为机器码，每次函数执行时，只执行编译后的机器码即可，这种方式可以使执行效率大幅度提升。</li><li>不过无论如何，基于解释器的执行模式仍然为中间语言的发展做出了不可磨灭的贡献。</li></ul><h1 id="五、JIT编译器"><a href="#五、JIT编译器" class="headerlink" title="五、JIT编译器"></a>五、JIT编译器</h1><h2 id="1-Java-代码执行的分类"><a href="#1-Java-代码执行的分类" class="headerlink" title="1. Java 代码执行的分类"></a>1. Java 代码执行的分类</h2><ol><li>第一种是将源代码编译成字节码文件，然后在运行时通过解释器将字节码文件转为机器码执行。</li><li>第二种是编译执行（直接编译成机器码）。现代虚拟机为了提高执行效率，会使用即时编译技术（JIT，Just In Time）将方法编译成机器码后再执行。</li></ol><ul><li>HotSpot VM是目前市面上高性能虚拟机的代表作之一。<strong>它采用解释器与即时编译器并存的架构</strong>。在Java虚拟机运行时，解释器和即时编译器能够相互协作，各自取长补短，尽力去选择最合适的方式来权衡编译本地代码的时间和直接解释执行代码的时间。</li><li>在今天，Java程序的运行性能早已脱胎换骨，已经达到了可以和C&#x2F;C++ 程序一较高下的地步。</li></ul><h2 id="2-为什么我们还需要解释器呢？"><a href="#2-为什么我们还需要解释器呢？" class="headerlink" title="2. 为什么我们还需要解释器呢？"></a>2. 为什么我们还需要解释器呢？</h2><ul><li>有些开发人员会感觉到诧异，既然HotSpot VM中已经内置JIT编译器了，那么为什么还需要再使用解释器来“拖累”程序的执行性能呢？比如JRockit VM内部就不包含解释器，字节码全部都依靠即时编译器编译后执行。</li><li>JRockit虚拟机是砍掉了解释器，也就是只采及时编译器。那是因为呢JRockit只部署在服务器上，一般已经有时间让他进行指令编译的过程了，对于响应来说要求不高，等及时编译器的编译完成后，就会提供更好的性能</li></ul><p><strong>首先明确两点：</strong></p><ol><li>当程序启动后，解释器可以马上发挥作用，<strong>响应速度快</strong>，省去编译的时间，立即执行。</li><li>编译器要想发挥作用，把代码编译成本地代码，<strong>需要一定的执行时间</strong>，但编译为本地代码后，执行效率高。</li></ol><p><strong>所以：</strong></p><ol><li>尽管JRockit VM中程序的执行性能会非常高效，但程序在启动时必然需要花费更长的时间来进行编译。对于服务端应用来说，启动时间并非是关注重点，但对于那些看中启动时间的应用场景而言，或许就需要采用解释器与即时编译器并存的架构来换取一个平衡点。</li><li>在此模式下，在Java虚拟器启动时，解释器可以首先发挥作用，而不必等待即时编译器全部编译完成后再执行，这样可以省去许多不必要的编译时间。随着时间的推移，编译器发挥作用，把越来越多的代码编译成本地代码，获得更高的执行效率。</li><li>同时，解释执行在编译器进行激进优化不成立的时候，作为编译器的“逃生门”（后备方案）。</li></ol><h2 id="3-案例"><a href="#3-案例" class="headerlink" title="3. 案例"></a>3. 案例</h2><ul><li>当虚拟机启动的时候，解释器可以首先发挥作用，而不必等待即时编译器全部编译完成再执行，这样可以省去许多不必要的编译时间。随着程序运行时间的推移，即时编译器逐渐发挥作用，根据热点探测功能，将有价值的字节码编译为本地机器指令，以换取更高的程序执行效率。</li><li>注意解释执行与编译执行在线上环境微妙的辩证关系。<strong>机器在热机状态（已经运行了一段时间叫热机状态）可以承受的负载要大于冷机状态（刚启动的时候叫冷机状态）</strong>。如果以热机状态时的流量进行切流，可能使处于冷机状态的服务器因无法承载流量而假死。</li><li>在生产环境发布过程中，以分批的方式进行发布，根据机器数量划分成多个批次，每个批次的机器数至多占到整个集群的1&#x2F;8。曾经有这样的故障案例：某程序员在发布平台进行分批发布，在输入发布总批数时，误填写成分为两批发布。如果是热机状态，在正常情况下一半的机器可以勉强承载流量，但由于刚启动的JVM均是解释执行，还没有进行热点代码统计和JIT动态编译，导致机器启动之后，当前1&#x2F;2发布成功的服务器马上全部宕机，此故障说明了JIT的存在。—<strong>阿里团队</strong></li></ul><p><img src="https://raw.githubusercontent.com/GeorgeChan95/blogimg/master/img/2023/12/24/20231224-141543.png" alt="image-20231224141541886"></p><h2 id="4-JIT编译器相关概念"><a href="#4-JIT编译器相关概念" class="headerlink" title="4. JIT编译器相关概念"></a>4. JIT编译器相关概念</h2><ul><li>Java 语言的“编译期”其实是一段“不确定”的操作过程，因为它可能是指一个前端编译器（其实叫“编译器的前端”更准确一些）把.java文件转变成.class文件的过程。</li><li>也可能是指虚拟机的后端运行期编译器（JIT编译器，Just In Time Compiler）把字节码转变成机器码的过程。</li><li>还可能是指使用静态提前编译器（AOT编译器，Ahead of Time Compiler）直接把.java文件编译成本地机器代码的过程。（可能是后续发展的趋势）</li></ul><p><strong>典型的编译器：</strong></p><ul><li>前端编译器：Sun的javac、Eclipse JDT中的增量式编译器（ECJ）。</li><li>JIT编译器：HotSpot VM的C1、C2编译器。</li><li>AOT 编译器：GNU Compiler for the Java（GCJ）、Excelsior JET。</li></ul><h2 id="5-热点代码及探测方式"><a href="#5-热点代码及探测方式" class="headerlink" title="5. 热点代码及探测方式"></a>5. 热点代码及探测方式</h2><ol><li>当然是否需要启动JIT编译器将字节码直接编译为对应平台的本地机器指令，则需要根据代码被调用<strong>执行的频率</strong>而定。</li><li>关于那些需要被编译为本地代码的字节码，也被称之为<strong>“热点代码”</strong>，JIT编译器在运行时会针对那些频繁被调用的“热点代码”做出<strong>深度优化</strong>，将其直接编译为对应平台的本地机器指令，以此提升Java程序的执行性能。</li><li>一个被多次调用的方法，或者是一-个方法体内部循环次数较多的循环体都可以被称之为“热点代码”，因此都可以通过JIT编译器编译为本地机器指令。由于这种编译方式发生在方法的执行过程中，因此也被称之为栈上替换，或简称为OSR (On StackReplacement)编译。</li><li>一个方法究竟要被调用多少次，或者一个循环体究竟需要执行多少次循环才可以达到这个标准？必然需要一个明确的阈值，JIT编译器才会将这些“热点代码”编译为本地机器指令执行。这里主要依靠热点探测功能。</li><li><strong>目前HotSpot VM所采用的热点探测方式是基于计数器的热点探测</strong>。</li><li>采用基于计数器的热点探测，HotSpot VM将会为每一个方法都建立2个不同类型的计数器，分别为方法调用计数器（Invocation Counter）和回边计数器（Back Edge Counter）。<ol><li>方法调用计数器用于统计方法的调用次数</li><li>回边计数器则用于统计循环体执行的循环次数</li></ol></li></ol><h3 id="5-1-方法调用计数器"><a href="#5-1-方法调用计数器" class="headerlink" title="5.1 方法调用计数器"></a>5.1 方法调用计数器</h3><ul><li>这个计数器就用于统计方法被调用的次数，它的默认阀值在Client模式下是1500次，在Server模式下是10000次。超过这个阈值，就会触发JIT编译。</li><li>这个阀值可以通过虚拟机参数 -XX:CompileThreshold 来人为设定。</li><li>当一个方法被调用时，会先检查该方法是否存在被JIT编译过的版本<ul><li>如果存在，则优先使用编译后的本地代码来执行</li><li>如果不存在已被编译过的版本，则将此方法的调用计数器值加1，然后判断方法调用计数器与回边计数器值之和是否超过方法调用计数器的阀值。<ul><li>如果已超过阈值，那么将会向即时编译器提交一个该方法的代码编译请求。</li><li>如果未超过阈值，则使用解释器对字节码文件解释执行</li></ul></li></ul></li></ul><img src="https://raw.githubusercontent.com/GeorgeChan95/blogimg/master/img/2023/12/24/20231224-144350.jpg" alt="第12方法调用计数器" style="zoom: 50%;" /><h3 id="5-2-热度衰减"><a href="#5-2-热度衰减" class="headerlink" title="5.2 热度衰减"></a>5.2 热度衰减</h3><ul><li>如果不做任何设置，方法调用计数器统计的并不是方法被调用的绝对次数，而是一个相对的执行频率，即<strong>一段时间之内方法被调用的次数</strong>。当超过一定的时间限度，如果方法的调用次数仍然不足以让它提交给即时编译器编译，那这个方法的调用计数器就会被减少一半，这个过程称为方法调用计数器热度的衰减（Counter Decay），而这段时间就称为此方法统计的半衰周期（Counter Half Life Time）（半衰周期是化学中的概念，比如出土的文物通过查看C60来获得文物的年龄）</li><li>进行热度衰减的动作是在虚拟机进行垃圾收集时顺便进行的，可以使用虚拟机参数 -XX:-UseCounterDecay 来关闭热度衰减，让方法计数器统计方法调用的绝对次数，这样的话，只要系统运行时间足够长，绝大部分方法都会被编译成本地代码。</li><li>另外，可以使用-XX:CounterHalfLifeTime参数设置半衰周期的时间，单位是秒。</li></ul><h3 id="5-3-回边计数器"><a href="#5-3-回边计数器" class="headerlink" title="5.3 回边计数器"></a>5.3 回边计数器</h3><p>它的作用是统计一个方法中循环体代码执行的次数，在字节码中遇到控制流向后跳转的指令称为“回边”（Back Edge）。显然，建立回边计数器统计的目的就是为了触发OSR编译。</p><img src="https://raw.githubusercontent.com/GeorgeChan95/blogimg/master/img/2023/12/24/20231224-144816.jpg" alt="回边计数器" style="zoom:50%;" /><h1 id="六、HotSpotVM可以设置程序执行方法"><a href="#六、HotSpotVM可以设置程序执行方法" class="headerlink" title="六、HotSpotVM可以设置程序执行方法"></a>六、HotSpotVM可以设置程序执行方法</h1><p>缺省情况下HotSpot VM是采用解释器与即时编译器并存的架构，当然开发人员可以根据具体的应用场景，通过命令显式地为Java虚拟机指定在运行时到底是完全采用解释器执行，还是完全采用即时编译器执行。如下所示：</p><ul><li>Xint：完全采用解释器模式执行程序；</li><li>-Xcomp：完全采用即时编译器模式执行程序。如果即时编译出现问题，解释器会介入执行</li><li>-Xmixed：采用解释器+即时编译器的混合模式共同执行程序。</li></ul><p><img src="https://raw.githubusercontent.com/GeorgeChan95/blogimg/master/img/2023/12/24/20231224-145125.png" alt="image-20231224145124164"></p><h2 id="1-代码测试"><a href="#1-代码测试" class="headerlink" title="1. 代码测试"></a>1. 代码测试</h2><pre><code class="highlight java"><span class="comment">/**</span><span class="comment"> * 测试解释器模式和JIT编译模式</span><span class="comment"> *  -Xint  : 6520ms</span><span class="comment"> *  -Xcomp : 950ms</span><span class="comment"> *  -Xmixed : 936ms</span><span class="comment"> */</span><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">IntCompTest</span> &#123;    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;        <span class="type">long</span> <span class="variable">start</span> <span class="operator">=</span> System.currentTimeMillis();        testPrimeNumber(<span class="number">1000000</span>);        <span class="type">long</span> <span class="variable">end</span> <span class="operator">=</span> System.currentTimeMillis();        System.out.println(<span class="string">&quot;花费的时间为：&quot;</span> + (end - start));    &#125;    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">testPrimeNumber</span><span class="params">(<span class="type">int</span> count)</span>&#123;        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; count; i++) &#123;            <span class="comment">//计算100以内的质数</span>            label:<span class="keyword">for</span>(<span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> <span class="number">2</span>;j &lt;= <span class="number">100</span>;j++)&#123;                <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">k</span> <span class="operator">=</span> <span class="number">2</span>;k &lt;= Math.sqrt(j);k++)&#123;                    <span class="keyword">if</span>(j % k == <span class="number">0</span>)&#123;                        <span class="keyword">continue</span> label;                    &#125;                &#125;                <span class="comment">//System.out.println(j);</span>            &#125;        &#125;    &#125;&#125;</code></pre><p><strong>结论：</strong></p><ul><li>纯解释器执行效率最低</li><li>纯编译器和编译器与解释器混合执行的效率较好。</li></ul><h1 id="七、HotSpotVM-JIT-分类"><a href="#七、HotSpotVM-JIT-分类" class="headerlink" title="七、HotSpotVM JIT 分类"></a>七、HotSpotVM JIT 分类</h1><h2 id="1-相关概念"><a href="#1-相关概念" class="headerlink" title="1. 相关概念"></a>1. 相关概念</h2><p>在HotSpot VM中内嵌有两个JIT编译器，分别为Client Compiler和Server Compiler，但大多数情况下我们简称为C1编译器 和 C2编译器。开发人员可以通过如下命令显式指定Java虚拟机在运行时到底使用哪一种即时编译器，如下所示：</p><ul><li>-client：指定Java虚拟机运行在Client模式下，并使用C1编译器；<ul><li>C1编译器会对字节码进行简单和可靠的优化，耗时短，以达到更快的编译速度。</li></ul></li><li>-server：指定Java虚拟机运行在server模式下，并使用C2编译器<ul><li>C2进行耗时较长的优化，以及激进优化，但优化的代码执行效率更高。（使用C++）</li></ul></li></ul><h2 id="2-C1和C2编译器不同的优化策略"><a href="#2-C1和C2编译器不同的优化策略" class="headerlink" title="2. C1和C2编译器不同的优化策略"></a>2. C1和C2编译器不同的优化策略</h2><ul><li><p>在不同的编译器上有不同的优化策略，C1编译器上主要有方法内联，去虚拟化、元余消除。</p><ul><li>方法内联：将引用的函数代码编译到引用点处，这样可以减少栈帧的生成，减少参数传递以及跳转过程</li><li>去虚拟化：对唯一的实现进行内联</li><li>冗余消除：在运行期间把一些不会执行的代码折叠掉</li></ul></li><li><p>C2的优化主要是在全局层面，逃逸分析是优化的基础。基于逃逸分析在C2上有如下几种优化：</p><ul><li>标量替换：用标量值代替聚合对象的属性值</li><li>栈上分配：对于未逃逸的对象分配对象在栈而不是堆</li><li>同步消除：清除同步操作，通常指synchronized</li></ul></li></ul><h2 id="3-分层编译策略"><a href="#3-分层编译策略" class="headerlink" title="3. 分层编译策略"></a>3. 分层编译策略</h2><ul><li>分层编译（Tiered Compilation）策略：程序解释执行（不开启性能监控）可以触发C1编译，将字节码编译成机器码，可以进行简单优化，也可以加上性能监控，C2编译会根据性能监控信息进行激进优化。</li><li>不过在Java7版本之后，一旦开发人员在程序中显式指定命令“-server”时，默认将会开启分层编译策略，由C1编译器和C2编译器相互协作共同来执行编译任务。</li><li>一般来讲，JIT编译出来的机器码性能比解释器解释执行的性能高</li><li>C2编译器启动时长比C1慢，系统稳定执行以后，C2编译器执行速度远快于C1编译器</li></ul><h3 id="3-1-Graal-编译器"><a href="#3-1-Graal-编译器" class="headerlink" title="3.1 Graal 编译器"></a>3.1 Graal 编译器</h3><ul><li>自JDK10起，HotSpot又加入了一个全新的即时编译器：Graal编译器</li><li>编译效果短短几年时间就追平了G2编译器，未来可期（对应还出现了Graal虚拟机，是有可能替代Hotspot的虚拟机的）</li><li>目前，带着实验状态标签，需要使用开关参数去激活才能使用</li></ul><pre><code class="highlight shell">-XX:+UnlockExperimentalvMOptions -XX:+UseJVMCICompiler</code></pre><h3 id="3-2-AOT编译器"><a href="#3-2-AOT编译器" class="headerlink" title="3.2 AOT编译器"></a>3.2 AOT编译器</h3><ul><li>jdk9引入了AoT编译器（静态提前编译器，Ahead of Time Compiler）</li><li>Java 9引入了实验性AOT编译工具jaotc。它借助了Graal编译器，将所输入的Java类文件转换为机器码，并存放至生成的动态共享库之中。</li><li>所谓AOT编译，是与即时编译相对立的一个概念。我们知道，即时编译指的是<strong>在程序的运行过程中</strong>，将字节码转换为可在硬件上直接运行的机器码，并部署至托管环境中的过程。而AOT编译指的则是，<strong>在程序运行之前</strong>，便将字节码转换为机器码的过程。<ul><li>.java -&gt; .class -&gt; (使用jaotc) -&gt; .so</li></ul></li></ul><h4 id="3-2-1-AOT编译器编译器的优缺点"><a href="#3-2-1-AOT编译器编译器的优缺点" class="headerlink" title="3.2.1 AOT编译器编译器的优缺点"></a>3.2.1 AOT编译器编译器的优缺点</h4><ul><li><strong>优点：</strong><ul><li>Java虚拟机加载已经预编译成二进制库，可以直接执行。</li><li>不必等待即时编译器的预热，减少Java应用给人带来“第一次运行慢” 的不良体验</li></ul></li><li><strong>缺点：</strong><ul><li>破坏了 java “ 一次编译，到处运行”，必须为每个不同的硬件，OS编译对应的发行包</li><li>降低了Java链接过程的动态性，加载的代码在编译器就必须全部已知。</li><li>还需要继续优化中，最初只支持Linux X64 java base</li></ul></li></ul><h1 id="参考链接"><a href="#参考链接" class="headerlink" title="参考链接"></a>参考链接</h1><blockquote><p>Java即时编译器原理解析及实践：<a href="https://tech.meituan.com/2020/10/22/java-jit-practice-in-meituan.html">https://tech.meituan.com/2020/10/22/java-jit-practice-in-meituan.html</a></p></blockquote>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;环境&quot;&gt;&lt;a href=&quot;#环境&quot; class=&quot;headerlink&quot; title=&quot;环境&quot;&gt;&lt;/a&gt;环境&lt;/h1&gt;&lt;blockquote&gt;
&lt;p&gt;系统 : Windows 10&lt;br&gt;JDK : 1.8&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h1 id=&quot;一、</summary>
      
    
    
    
    <category term="JVM" scheme="https://georgechan95.github.io/categories/JVM/"/>
    
    
    <category term="jvm" scheme="https://georgechan95.github.io/tags/jvm/"/>
    
    <category term="java" scheme="https://georgechan95.github.io/tags/java/"/>
    
  </entry>
  
  <entry>
    <title>第九章-对象的实例化内存布局与访问定位</title>
    <link href="https://georgechan95.github.io/2023/12/21/jvm/%E7%AC%AC%E4%B9%9D%E7%AB%A0-%E5%AF%B9%E8%B1%A1%E7%9A%84%E5%AE%9E%E4%BE%8B%E5%8C%96%E5%86%85%E5%AD%98%E5%B8%83%E5%B1%80%E4%B8%8E%E8%AE%BF%E9%97%AE%E5%AE%9A%E4%BD%8D/"/>
    <id>https://georgechan95.github.io/2023/12/21/jvm/%E7%AC%AC%E4%B9%9D%E7%AB%A0-%E5%AF%B9%E8%B1%A1%E7%9A%84%E5%AE%9E%E4%BE%8B%E5%8C%96%E5%86%85%E5%AD%98%E5%B8%83%E5%B1%80%E4%B8%8E%E8%AE%BF%E9%97%AE%E5%AE%9A%E4%BD%8D/</id>
    <published>2023-12-21T03:50:00.000Z</published>
    <updated>2024-06-22T10:36:12.823Z</updated>
    
    <content type="html"><![CDATA[<h1 id="环境"><a href="#环境" class="headerlink" title="环境"></a>环境</h1><blockquote><p>系统 : Windows 10<br>JDK : 1.8</p></blockquote><h1 id="一、对象的实例化"><a href="#一、对象的实例化" class="headerlink" title="一、对象的实例化"></a>一、对象的实例化</h1><p><img src="https://raw.githubusercontent.com/GeorgeChan95/blogimg/master/img/2023/12/20/20231220-204059.jpg" alt="对象的实例化"></p><h2 id="1-对象创建的方式"><a href="#1-对象创建的方式" class="headerlink" title="1. 对象创建的方式"></a>1. 对象创建的方式</h2><ul><li>new：最常见的方式、单例类中调用getInstance的静态类方法，XxxBuilder&#x2F;XxxFactory的静态方法</li><li>Class的newInstance方法：在JDK9里面被标记为过时的方法，因为只能调用空参构造器，并且权限必须为 public</li><li>Constructor的newInstance(Xxxx)：反射的方式，可以调用空参的，或者带参的构造器</li><li>使用clone()：不调用任何的构造器，要求当前的类需要实现Cloneable接口中的clone方法</li><li>使用序列化：从文件中，从网络中获取一个对象的二进制流，序列化一般用于Socket的网络传输</li><li>第三方库 Objenesis</li></ul><h2 id="2-对象创建的步骤"><a href="#2-对象创建的步骤" class="headerlink" title="2. 对象创建的步骤"></a>2. 对象创建的步骤</h2><blockquote><p><strong>从字节码看待对象的创建过程</strong></p></blockquote><blockquote><p>Java代码</p></blockquote><pre><code class="highlight java"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ObjectTest</span> &#123;    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;        <span class="type">Object</span> <span class="variable">obj</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Object</span>();    &#125;&#125;</code></pre><blockquote><p>字节码</p></blockquote><pre><code class="highlight plaintext">Classfile /H:/code_test/JVMDemo/out/production/chapter10/com/atguigu/java/ObjectTest.class  Last modified 2023-11-28; size 456 bytes       MD5 checksum 04a948734154e10697a376f964f07df1  Compiled from &quot;ObjectTest.java&quot;public class com.atguigu.java.ObjectTest         minor version: 0  major version: 52  flags: ACC_PUBLIC, ACC_SUPERConstant pool:   #1 = Methodref          #2.#19         // java/lang/Object.&quot;&lt;init&gt;&quot;:()V   #2 = Class              #20            // java/lang/Object   #3 = Class              #21            // com/atguigu/java/ObjectTest   #4 = Utf8               &lt;init&gt;   #5 = Utf8               ()V   #6 = Utf8               Code   #7 = Utf8               LineNumberTable   #8 = Utf8               LocalVariableTable   #9 = Utf8               this  #10 = Utf8               Lcom/atguigu/java/ObjectTest;  #11 = Utf8               main  #12 = Utf8               ([Ljava/lang/String;)V  #13 = Utf8               args  #14 = Utf8               [Ljava/lang/String;  #15 = Utf8               obj  #16 = Utf8               Ljava/lang/Object;  #17 = Utf8               SourceFile  #18 = Utf8               ObjectTest.java  #19 = NameAndType        #4:#5          // &quot;&lt;init&gt;&quot;:()V  #20 = Utf8               java/lang/Object  #21 = Utf8               com/atguigu/java/ObjectTest&#123;  public com.atguigu.java.ObjectTest();    descriptor: ()V    flags: ACC_PUBLIC    Code:      stack=1, locals=1, args_size=1         0: aload_0         1: invokespecial #1                  // Method java/lang/Object.&quot;&lt;init&gt;&quot;:()V         4: return      LineNumberTable:        line 7: 0      LocalVariableTable:        Start  Length  Slot  Name   Signature            0       5     0  this   Lcom/atguigu/java/ObjectTest;  public static void main(java.lang.String[]);    descriptor: ([Ljava/lang/String;)V    flags: ACC_PUBLIC, ACC_STATIC    Code:      stack=2, locals=2, args_size=1         0: new           #2                  // class java/lang/Object         3: dup         4: invokespecial #1                  // Method java/lang/Object.&quot;&lt;init&gt;&quot;:()V         7: astore_1         8: return      LineNumberTable:        line 9: 0        line 10: 8      LocalVariableTable:        Start  Length  Slot  Name   Signature            0       9     0  args   [Ljava/lang/String;            8       1     1   obj   Ljava/lang/Object;&#125;SourceFile: &quot;ObjectTest.java&quot;</code></pre><h3 id="2-1-判断对象对应的类是否加载、链接、初始化"><a href="#2-1-判断对象对应的类是否加载、链接、初始化" class="headerlink" title="2.1 判断对象对应的类是否加载、链接、初始化"></a>2.1 判断对象对应的类是否加载、链接、初始化</h3><ul><li>虚拟机遇到一条new指令，首先去检查这个指令的参数能否在Metaspace的常量池中定位到一个类的符号引用，并且检查这个符号引用代表的类是否已经被加载，解析和初始化。（即判断类元信息是否存在）。</li><li>如果该类没有加载，那么在双亲委派模式下，使用当前类加载器以ClassLoader + 包名 + 类名为key进行查找对应的.class文件，如果没有找到文件，则抛出ClassNotFoundException异常，如果找到，则进行类加载，并生成对应的Class对象。</li></ul><h3 id="2-2-为对象分配内存"><a href="#2-2-为对象分配内存" class="headerlink" title="2.2 为对象分配内存"></a>2.2 为对象分配内存</h3><ul><li>首先计算对象占用空间的大小，接着在堆中划分一块内存给新对象。如果实例成员变量是引用变量，仅分配引用变量空间即可，即4个字节大小</li><li>如果内存规整：采用指针碰撞分配内存<ul><li>如果内存是规整的，那么虚拟机将采用的是指针碰撞法（Bump The Point）来为对象分配内存。</li><li>意思是所有用过的内存在一边，空闲的内存放另外一边，中间放着一个指针作为分界点的指示器，分配内存就仅仅是把指针往空闲内存那边挪动一段与对象大小相等的距离罢了。</li><li>如果垃圾收集器选择的是Serial ，ParNew这种基于压缩算法的，虚拟机采用这种分配方式。一般使用带Compact（整理）过程的收集器时，使用指针碰撞。</li><li>标记压缩（整理）算法会整理内存碎片，堆内存一存对象，另一边为空闲区域</li></ul></li><li>如果内存不规整<ul><li>如果内存不是规整的，已使用的内存和未使用的内存相互交错，那么虚拟机将采用的是空闲列表来为对象分配内存。</li><li>意思是虚拟机维护了一个列表，记录上哪些内存块是可用的，再分配的时候从列表中找到一块足够大的空间划分给对象实例，并更新列表上的内容。这种分配方式成为了 “空闲列表（Free List）”</li><li>选择哪种分配方式由Java堆是否规整所决定，而Java堆是否规整又由所采用的垃圾收集器是否带有压缩整理功能决定</li><li>标记清除算法清理过后的堆内存，就会存在很多内存碎片。</li></ul></li></ul><h3 id="2-3-处理并发问题"><a href="#2-3-处理并发问题" class="headerlink" title="2.3 处理并发问题"></a>2.3 处理并发问题</h3><ul><li>采用CAS+失败重试保证更新的原子性</li><li>每个线程预先分配TLAB - 通过设置 <code>-XX:+UseTLAB</code> 参数来设置（区域加锁机制）</li><li>在Eden区给每个线程分配一块区域</li></ul><h3 id="2-4-初始化分配到的空间"><a href="#2-4-初始化分配到的空间" class="headerlink" title="2.4 初始化分配到的空间"></a>2.4 初始化分配到的空间</h3><ul><li>所有属性设置默认值，保证对象实例字段在不赋值可以直接使用。</li><li>给对象属性赋值的顺序：<ul><li>属性的默认值初始化</li><li>显示初始化&#x2F;代码块初始化（并列关系，谁先谁后看代码编写的顺序）</li><li>构造器初始化</li></ul></li></ul><h3 id="2-5-设置对象的对象头"><a href="#2-5-设置对象的对象头" class="headerlink" title="2.5 设置对象的对象头"></a>2.5 设置对象的对象头</h3><p>将对象的所属类（即类的元数据信息）、对象的HashCode和对象的GC信息、锁信息等数据存储在对象的对象头中。这个过程的具体设置方式取决于JVM实现。</p><h3 id="2-6-执行init方法进行初始化"><a href="#2-6-执行init方法进行初始化" class="headerlink" title="2.6 执行init方法进行初始化"></a>2.6 执行init方法进行初始化</h3><ul><li>在Java程序的视角看来，初始化才正式开始。初始化成员变量，执行实例化代码块，调用类的构造方法，并把堆内对象的首地址赋值给引用变量</li><li>因此一般来说（由字节码中跟随invokespecial指令所决定），new指令之后会接着就是执行init方法，把对象按照程序员的意愿进行初始化，这样一个真正可用的对象才算完成创建出来。</li></ul><h4 id="2-6-1-从字节码角度看-init-方法"><a href="#2-6-1-从字节码角度看-init-方法" class="headerlink" title="2.6.1 从字节码角度看 init 方法"></a>2.6.1 从字节码角度看 init 方法</h4><blockquote><p>Java代码</p></blockquote><pre><code class="highlight java"><span class="comment">/**</span><span class="comment"> * 测试对象实例化的过程</span><span class="comment"> *  ① 加载类元信息 - ② 为对象分配内存 - ③ 处理并发问题  - ④ 属性的默认初始化（零值初始化）</span><span class="comment"> *  - ⑤ 设置对象头的信息 - ⑥ 属性的显式初始化、代码块中初始化、构造器中初始化</span><span class="comment"> *</span><span class="comment"> *  给对象的属性赋值的操作：</span><span class="comment"> *  ① 属性的默认初始化 - ② 显式初始化 / ③ 代码块中初始化 - ④ 构造器中初始化</span><span class="comment"> */</span><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Customer</span>&#123;    <span class="type">int</span> <span class="variable">id</span> <span class="operator">=</span> <span class="number">1001</span>;    String name;    Account acct;    &#123;        name = <span class="string">&quot;匿名客户&quot;</span>;    &#125;    <span class="keyword">public</span> <span class="title function_">Customer</span><span class="params">()</span>&#123;        acct = <span class="keyword">new</span> <span class="title class_">Account</span>();    &#125;&#125;<span class="keyword">class</span> <span class="title class_">Account</span>&#123;&#125;</code></pre><blockquote><p>Customer类的字节码</p></blockquote><pre><code class="highlight plaintext"> 0 aload_0 1 invokespecial #1 &lt;java/lang/Object.&lt;init&gt; : ()V&gt; 4 aload_0 5 sipush 1001 8 putfield #2 &lt;com/atguigu/java/Customer.id : I&gt;11 aload_012 ldc #3 &lt;匿名客户&gt;14 putfield #4 &lt;com/atguigu/java/Customer.name : Ljava/lang/String;&gt;17 aload_018 new #5 &lt;com/atguigu/java/Account&gt;21 dup22 invokespecial #6 &lt;com/atguigu/java/Account.&lt;init&gt; : ()V&gt;25 putfield #7 &lt;com/atguigu/java/Customer.acct : Lcom/atguigu/java/Account;&gt;28 return</code></pre><p><img src="https://raw.githubusercontent.com/GeorgeChan95/blogimg/master/img/2023/12/20/20231220-213216.png" alt="image-20231220213215486"></p><ul><li>init() 方法的字节码指令<ul><li>属性的默认值初始化：<code>id = 1001;</code></li><li>显示初始化&#x2F;代码块初始化：<code>name = &quot;匿名客户&quot;;</code></li><li>构造器初始化：<code>acct = new Account();</code></li></ul></li></ul><h1 id="二、对象的内存布局"><a href="#二、对象的内存布局" class="headerlink" title="二、对象的内存布局"></a>二、对象的内存布局</h1><p><img src="https://raw.githubusercontent.com/GeorgeChan95/blogimg/master/img/2023/12/20/20231220-213520.jpg" alt="内存布局"></p><p><img src="https://raw.githubusercontent.com/GeorgeChan95/blogimg/master/img/2023/12/21/20231221-132009.png" alt="对象内存布局"></p><h2 id="1-对象头-Header"><a href="#1-对象头-Header" class="headerlink" title="1. 对象头(Header)"></a>1. 对象头(Header)</h2><p>包含两部分：运行时元数据(Mark Word)、类型指针 </p><ul><li>运行时元数据<ul><li>哈希值 (HashCode)</li><li>GC分代年龄</li><li>锁状态标志</li><li>线程持有的锁</li><li>偏向线程ID</li><li>偏向时间戳</li></ul></li><li>指向类元数据InstanceKlass，确定该对象所属的类型</li><li>说明:如果是数组，还需记录数组的长度</li></ul><h2 id="2-实例数据-Instance-Data"><a href="#2-实例数据-Instance-Data" class="headerlink" title="2. 实例数据(Instance Data)"></a>2. 实例数据(Instance Data)</h2><ul><li>说明：它是对象真正存储的有效信息，包括程序代码中定义的各种类型的字段(包括从父类继承下来的和本身拥有的字段)</li><li>规则<ul><li>相同宽度的字段总是被分配在一起</li><li>父类中定义的变量会出现在子类之前</li><li>如果CompactFields参数为true(默认为true): 子类的窄变量可能插入到父类变量的空隙</li></ul></li></ul><p>进一步了解实例数据和指针压缩，看这篇博客：<a href="https://blog.csdn.net/qq_41929714/article/details/131421540">https://blog.csdn.net/qq_41929714/article/details/131421540</a></p><h2 id="3-对齐填充-Padding"><a href="#3-对齐填充-Padding" class="headerlink" title="3. 对齐填充(Padding)"></a>3. 对齐填充(Padding)</h2><ul><li>为了保证对象的大小为8字节的整数倍。将对象头和实例数据的大小相加，以8为倍数向上补齐就是这个对象的大小。即：对象头+实例数据&#x3D;30，则对齐填充，向上取8的倍数进行补齐，就是32，这个对象大小就是32。</li><li>不是必须的，也没特别含义，仅仅起到占位符的作用</li></ul><blockquote><p>代码示例</p></blockquote><pre><code class="highlight java"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Customer</span>&#123;    <span class="type">int</span> <span class="variable">id</span> <span class="operator">=</span> <span class="number">1001</span>;    String name;    Account acct;    &#123;        name = <span class="string">&quot;匿名客户&quot;</span>;    &#125;    <span class="keyword">public</span> <span class="title function_">Customer</span><span class="params">()</span>&#123;        acct = <span class="keyword">new</span> <span class="title class_">Account</span>();    &#125;&#125;<span class="keyword">class</span> <span class="title class_">Account</span>&#123;&#125;</code></pre><p><img src="https://raw.githubusercontent.com/GeorgeChan95/blogimg/master/img/2023/12/21/20231221-123059.jpg" alt="图示对象的内存布局"></p><h1 id="三、对象的访问定位"><a href="#三、对象的访问定位" class="headerlink" title="三、对象的访问定位"></a>三、对象的访问定位</h1><p>JVM是如何通过栈帧中的对象引用访问到其内部的对象实例呢？</p><p>答案：<strong>通过栈上reference访问</strong></p><p><img src="https://raw.githubusercontent.com/GeorgeChan95/blogimg/master/img/2023/12/21/20231221-125334.png" alt="image-20231221125332865"></p><p><strong>对象的两种访问方式：句柄访问和直接指针</strong></p><h2 id="1-句柄访问"><a href="#1-句柄访问" class="headerlink" title="1. 句柄访问"></a>1. 句柄访问</h2><p><img src="https://raw.githubusercontent.com/GeorgeChan95/blogimg/master/img/2023/12/21/20231221-125916.jpg" alt="句柄访问"></p><p>使用句柄访问对象，首先要了解句柄池是在堆中开辟的一块内存空间作为句柄池，句柄池中有很多很多的句柄，每个句柄之间又包含了：</p><ul><li>指向对象实例的指针：储存了对象实例数据，即属性值结构体的内存地址，对象实例数据一般也在heap中开辟。</li><li>指向对象类型数据的指针：访问类型数据的内存地址(类信息，方法类型信息)，对象类型数据一般储存在方法区中。</li></ul><p>当局部变量表中的引用类型reference指向句柄池，并且定位到句柄池中间目标对象的句柄，然后再根据该句柄中的句柄信息，找到对象。</p><ul><li><p>优点：reference存储的是稳定的句柄地址，在对象被移动(垃圾收集时移动对象是非常普遍的行为)时只会改变句柄中的实例数据指针，而reference本身不需要改变。</p></li><li><p>缺点：在堆空间中开辟了一块空间作为句柄池，句柄池本身也会占用空间；通过两次指针访问才能访问到堆中的对象，即会有两次IO操作，效率低</p></li></ul><h2 id="2-直接指针（HotSpot采用）"><a href="#2-直接指针（HotSpot采用）" class="headerlink" title="2. 直接指针（HotSpot采用）"></a>2. 直接指针（HotSpot采用）</h2><p><img src="https://raw.githubusercontent.com/GeorgeChan95/blogimg/master/img/2023/12/21/20231221-130250.jpg" alt="使用直接指针访问"></p><p>直接指针访问方式，局部变量表中的引用类型reference指向对象实例数据，对象实例数据中需要有额外的内存开销需要用来存放指向对象类型数据的指针(来存放对象在方法区的类信息地址)，也就是需要开辟出一个额外的空间来存放，这个空间就是Class Pointer。</p><ul><li>优点： 节省了一次指针定位的开销。即只有一次IO操作，比句柄池访问对象快一倍。</li><li>缺点： 在对象被移动时(如进行GC后的内存重新排列)，reference本身需要被修改。</li></ul><p><strong>hotsport用的就是直接指针访问的方式</strong>。<strong>对象的引用实际上就是对对象的直接引用，也称为指针</strong>。当我们声明一个引用变量时，它实际上是指向对象的指针。</p><p><strong>直接指针访问的方式是一种典型的空间换时间的方式，而hotsport大部分场景下用的都是这种场景</strong>。</p><h3 id="参考链接"><a href="#参考链接" class="headerlink" title="参考链接"></a>参考链接</h3><blockquote><p><a href="https://blog.csdn.net/qq_41929714/article/details/131421540">https://blog.csdn.net/qq_41929714/article/details/131421540</a></p></blockquote>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;环境&quot;&gt;&lt;a href=&quot;#环境&quot; class=&quot;headerlink&quot; title=&quot;环境&quot;&gt;&lt;/a&gt;环境&lt;/h1&gt;&lt;blockquote&gt;
&lt;p&gt;系统 : Windows 10&lt;br&gt;JDK : 1.8&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h1 id=&quot;一、</summary>
      
    
    
    
    <category term="JVM" scheme="https://georgechan95.github.io/categories/JVM/"/>
    
    
    <category term="jvm" scheme="https://georgechan95.github.io/tags/jvm/"/>
    
    <category term="java" scheme="https://georgechan95.github.io/tags/java/"/>
    
  </entry>
  
  <entry>
    <title>第八章-直接内存</title>
    <link href="https://georgechan95.github.io/2023/12/20/jvm/%E7%AC%AC%E5%85%AB%E7%AB%A0-%E7%9B%B4%E6%8E%A5%E5%86%85%E5%AD%98/"/>
    <id>https://georgechan95.github.io/2023/12/20/jvm/%E7%AC%AC%E5%85%AB%E7%AB%A0-%E7%9B%B4%E6%8E%A5%E5%86%85%E5%AD%98/</id>
    <published>2023-12-20T09:03:00.000Z</published>
    <updated>2024-06-22T10:36:12.823Z</updated>
    
    <content type="html"><![CDATA[<h1 id="环境"><a href="#环境" class="headerlink" title="环境"></a>环境</h1><blockquote><p>系统 : Windows 10<br>JDK : 1.8</p></blockquote><h1 id="一、直接内存概述"><a href="#一、直接内存概述" class="headerlink" title="一、直接内存概述"></a>一、直接内存概述</h1><ul><li>不是虚拟机运行时数据区的一部分，也不是《Java虚拟机规范》中定义的内存区域。</li><li>直接内存是在Java堆外的、直接向系统申请的内存区间。</li><li>来源于NIO，通过存在堆中的DirectByteBuffer操作Native内存</li><li>通常，访问直接内存的速度会优于Java堆。即读写性能高。<ul><li>因此出于性能考虑，读写频繁的场合可能会考虑使用直接内存。</li><li>Java的NIO库允许Java程序使用直接内存，用于数据缓冲区</li></ul></li></ul><blockquote><p>代码示例</p></blockquote><pre><code class="highlight java"><span class="comment">/**</span><span class="comment"> *  IO                  NIO (New IO / Non-Blocking IO)</span><span class="comment"> *  byte[] / char[]     Buffer</span><span class="comment"> *  Stream              Channel</span><span class="comment"> *</span><span class="comment"> * 查看直接内存的占用与释放</span><span class="comment"> */</span><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">BufferTest</span> &#123;    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">int</span> <span class="variable">BUFFER</span> <span class="operator">=</span> <span class="number">1024</span> * <span class="number">1024</span> * <span class="number">1024</span>;<span class="comment">//1GB</span>    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span>&#123;        <span class="comment">//直接分配本地内存空间</span>        <span class="type">ByteBuffer</span> <span class="variable">byteBuffer</span> <span class="operator">=</span> ByteBuffer.allocateDirect(BUFFER);        System.out.println(<span class="string">&quot;直接内存分配完毕，请求指示！&quot;</span>);        <span class="type">Scanner</span> <span class="variable">scanner</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Scanner</span>(System.in);        scanner.next();        System.out.println(<span class="string">&quot;直接内存开始释放！&quot;</span>);        byteBuffer = <span class="literal">null</span>;        System.gc();        scanner.next();    &#125;&#125;</code></pre><p>直接占用了 1G 的本地内存</p><p><img src="https://raw.githubusercontent.com/GeorgeChan95/blogimg/master/img/2023/12/20/20231220-193801.png" alt="image-20231220193601231"></p><h1 id="二、BIO-与-NIO"><a href="#二、BIO-与-NIO" class="headerlink" title="二、BIO 与 NIO"></a>二、BIO 与 NIO</h1><h2 id="1-非直接缓存区（BIO）"><a href="#1-非直接缓存区（BIO）" class="headerlink" title="1. 非直接缓存区（BIO）"></a>1. 非直接缓存区（BIO）</h2><p>原来采用BIO的架构，在读写本地文件时，我们需要从用户态切换成内核态</p><p><img src="https://raw.githubusercontent.com/GeorgeChan95/blogimg/master/img/2023/12/20/20231220-194244.png" alt="image-20231220194157794"></p><h2 id="2-直接缓冲区（NIO）"><a href="#2-直接缓冲区（NIO）" class="headerlink" title="2. 直接缓冲区（NIO）"></a>2. 直接缓冲区（NIO）</h2><p>NIO 直接操作物理磁盘，省去了中间过程</p><p><img src="https://raw.githubusercontent.com/GeorgeChan95/blogimg/master/img/2023/12/20/20231220-200818.png" alt="image-20231220200446807"></p><h2 id="3-直接内存与-OOM"><a href="#3-直接内存与-OOM" class="headerlink" title="3. 直接内存与 OOM"></a>3. 直接内存与 OOM</h2><ul><li>直接内存也可能导致OutofMemoryError异常</li><li>由于直接内存在Java堆外，因此它的大小不会直接受限于-Xmx指定的最大堆大小，但是系统内存是有限的，Java堆和直接内存的总和依然受限于操作系统能给出的最大内存。</li><li>直接内存的缺点为：<ul><li>分配回收成本较高</li><li>不受JVM内存回收管理</li></ul></li><li>直接内存大小可以通过 <code>-XX:MaxDirectMemorySize</code> 设置</li><li>如果不指定，默认与堆的最大值-Xmx参数值一致</li></ul><pre><code class="highlight java"><span class="comment">/**</span><span class="comment"> * 本地内存的OOM:  OutOfMemoryError: Direct buffer memory</span><span class="comment"> *</span><span class="comment"> */</span><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">BufferTest2</span> &#123;    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">int</span> <span class="variable">BUFFER</span> <span class="operator">=</span> <span class="number">1024</span> * <span class="number">1024</span> * <span class="number">20</span>;<span class="comment">//20MB</span>    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;        ArrayList&lt;ByteBuffer&gt; list = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();        <span class="type">int</span> <span class="variable">count</span> <span class="operator">=</span> <span class="number">0</span>;        <span class="keyword">try</span> &#123;            <span class="keyword">while</span>(<span class="literal">true</span>)&#123;                <span class="type">ByteBuffer</span> <span class="variable">byteBuffer</span> <span class="operator">=</span> ByteBuffer.allocateDirect(BUFFER);                list.add(byteBuffer);                count++;                <span class="keyword">try</span> &#123;                    Thread.sleep(<span class="number">100</span>);                &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;                    e.printStackTrace();                &#125;            &#125;        &#125; <span class="keyword">finally</span> &#123;            System.out.println(count);        &#125;    &#125;&#125;</code></pre><blockquote><p>控制台错误信息如下：</p><p>直接内存溢出</p></blockquote><pre><code class="highlight plaintext">Exception in thread &quot;main&quot; java.lang.OutOfMemoryError: Direct buffer memoryat java.nio.Bits.reserveMemory(Bits.java:694)at java.nio.DirectByteBuffer.&lt;init&gt;(DirectByteBuffer.java:123)at java.nio.ByteBuffer.allocateDirect(ByteBuffer.java:311)at com.atguigu.java.BufferTest2.main(BufferTest2.java:19)</code></pre>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;环境&quot;&gt;&lt;a href=&quot;#环境&quot; class=&quot;headerlink&quot; title=&quot;环境&quot;&gt;&lt;/a&gt;环境&lt;/h1&gt;&lt;blockquote&gt;
&lt;p&gt;系统 : Windows 10&lt;br&gt;JDK : 1.8&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h1 id=&quot;一、</summary>
      
    
    
    
    <category term="JVM" scheme="https://georgechan95.github.io/categories/JVM/"/>
    
    
    <category term="jvm" scheme="https://georgechan95.github.io/tags/jvm/"/>
    
    <category term="java" scheme="https://georgechan95.github.io/tags/java/"/>
    
  </entry>
  
  <entry>
    <title>第七章-方法区</title>
    <link href="https://georgechan95.github.io/2023/12/14/jvm/%E7%AC%AC%E4%B8%83%E7%AB%A0-%E6%96%B9%E6%B3%95%E5%8C%BA/"/>
    <id>https://georgechan95.github.io/2023/12/14/jvm/%E7%AC%AC%E4%B8%83%E7%AB%A0-%E6%96%B9%E6%B3%95%E5%8C%BA/</id>
    <published>2023-12-14T10:24:00.000Z</published>
    <updated>2024-06-22T10:36:12.823Z</updated>
    
    <content type="html"><![CDATA[<h1 id="环境"><a href="#环境" class="headerlink" title="环境"></a>环境</h1><blockquote><p>系统 : Windows 10<br>JDK : 1.8</p></blockquote><p><img src="https://raw.githubusercontent.com/GeorgeChan95/blogimg/master/img/2023/12/14/20231214-202129.png" alt="image-20231214202125161"></p><h1 id="一、栈、堆、方法区的交互关系"><a href="#一、栈、堆、方法区的交互关系" class="headerlink" title="一、栈、堆、方法区的交互关系"></a>一、栈、堆、方法区的交互关系</h1><p><img src="https://raw.githubusercontent.com/GeorgeChan95/blogimg/master/img/2023/12/14/20231214-202250.png" alt="image-20231214202248922"></p><ul><li>Person 类的 .class 信息存放在方法区中</li><li>person 变量存放在 Java 栈的局部变量表中</li><li>真正的 person 对象(new Person())存放在 Java 堆中</li><li>在 person 对象中，有个指针指向方法区中的 person 类型数据，表明这个 person 对象是用方法区中的 Person 类 new 出来的</li></ul><h1 id="二、方法区的理解"><a href="#二、方法区的理解" class="headerlink" title="二、方法区的理解"></a>二、方法区的理解</h1><blockquote><p>官方文档：<a href="https://docs.oracle.com/javase/specs/jvms/se8/html/jvms-2.html#jvms-2.5.4">https://docs.oracle.com/javase/specs/jvms/se8/html/jvms-2.html#jvms-2.5.4</a></p></blockquote><h2 id="1-方法区在哪里？"><a href="#1-方法区在哪里？" class="headerlink" title="1. 方法区在哪里？"></a>1. 方法区在哪里？</h2><ul><li>《Java虚拟机规范》中明确说明：尽管所有的方法区在逻辑上是属于堆的一部分，但一些简单的实现可能不会选择去进行垃圾收集或者进行压缩。但对于HotSpotJVM而言，方法区还有一个别名叫做Non-Heap（非堆），目的就是要和堆分开。</li><li>所以，方法区可以看作是一块独立于Java堆的内存空间。</li></ul><h2 id="2-方法区的基本理解"><a href="#2-方法区的基本理解" class="headerlink" title="2. 方法区的基本理解"></a>2. 方法区的基本理解</h2><p><strong>方法区主要存放的是 Class，而堆中主要存放的是实例化的对象</strong></p><ul><li>方法区（Method Area）与Java堆一样，是各个线程共享的内存区域。多个线程同时加载统一个类时，只能有一个线程能加载该类，其他线程只能等等待该线程加载完毕，然后直接使用该类，即类只能加载一次。</li><li>方法区在JVM启动的时候被创建，并且它的实际的物理内存空间中和Java堆区一样都可以是不连续的。</li><li>方法区的大小，跟堆空间一样，可以选择固定大小或者可扩展。</li><li>方法区的大小决定了系统可以保存多少个类，如果系统定义了太多的类，导致方法区溢出，虚拟机同样会抛出内存溢出错误：<code>java.lang.OutofMemoryError:PermGen space</code>或者<code>java.lang.OutOfMemoryError:Metaspace</code><ul><li>加载大量的第三方的jar包</li><li>Tomcat部署的工程过多（30~50个）</li><li>大量动态的生成反射类</li></ul></li><li>关闭JVM就会释放这个区域的内存。</li></ul><h3 id="2-1-代码示例"><a href="#2-1-代码示例" class="headerlink" title="2.1 代码示例"></a>2.1 代码示例</h3><pre><code class="highlight java"><span class="comment">/**</span><span class="comment"> *  测试设置方法区大小参数的默认值</span><span class="comment"> *</span><span class="comment"> *  jdk7及以前：</span><span class="comment"> *  -XX:PermSize=100m -XX:MaxPermSize=100m</span><span class="comment"> *</span><span class="comment"> *  jdk8及以后：</span><span class="comment"> *  -XX:MetaspaceSize=100m  -XX:MaxMetaspaceSize=100m</span><span class="comment"> */</span><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">MethodAreaDemo</span> &#123;    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;        System.out.println(<span class="string">&quot;start...&quot;</span>);        <span class="keyword">try</span> &#123;            Thread.sleep(<span class="number">1000000</span>);        &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;            e.printStackTrace();        &#125;        System.out.println(<span class="string">&quot;end...&quot;</span>);    &#125;&#125;</code></pre><p>简单的程序，加载了1600多个类</p><p><img src="https://raw.githubusercontent.com/GeorgeChan95/blogimg/master/img/2023/12/14/20231214-203755.png" alt="image-20231214203754303"></p><h2 id="3-HotSpot方法区演进"><a href="#3-HotSpot方法区演进" class="headerlink" title="3. HotSpot方法区演进"></a>3. HotSpot方法区演进</h2><ul><li>在 JDK7 及以前，习惯上把方法区，称为永久代。JDK8开始，使用元空间取代了永久代。我们可以将方法区类比为Java中的接口，将永久代或元空间类比为Java中具体的实现类</li><li>本质上，方法区和永久代并不等价。仅是对Hotspot而言的可以看作等价。《Java虚拟机规范》对如何实现方法区，不做统一要求。例如：BEAJRockit &#x2F; IBM J9 中不存在永久代的概念。<ul><li>现在来看，当年使用永久代，不是好的idea。导致Java程序更容易OOm（超过-XX:MaxPermsize上限）</li></ul></li><li>而到了JDK8，终于完全废弃了永久代的概念，改用与JRockit、J9一样在本地内存中实现的元空间（Metaspace）来代替</li><li>元空间的本质和永久代类似，都是对JVM规范中方法区的实现。不过元空间与永久代最大的区别在于：<strong>元空间不在虚拟机设置的内存中，而是使用本地内存</strong>。</li><li>永久代、元空间二者并不只是名字变了，内部结构也调整了</li><li>根据《Java虚拟机规范》的规定，如果方法区无法满足新的内存分配需求时，将抛出OOM异常</li></ul><img src="https://raw.githubusercontent.com/GeorgeChan95/blogimg/master/img/2023/12/15/20231215-152513.jpg" alt="堆和方法区图" style="zoom:50%;" /><h1 id="三、设置方法区大小与-OOM"><a href="#三、设置方法区大小与-OOM" class="headerlink" title="三、设置方法区大小与 OOM"></a>三、设置方法区大小与 OOM</h1><p>方法区的大小不必是固定的，JVM可以根据应用的需要动态调整。</p><h2 id="1-JDK7及以前-永久代"><a href="#1-JDK7及以前-永久代" class="headerlink" title="1. JDK7及以前(永久代)"></a>1. JDK7及以前(永久代)</h2><ul><li>通过 <code>-XX:Permsize</code> 来设置永久代初始分配空间。默认值是20.75M</li><li><code>-XX:MaxPermsize</code> 来设定永久代最大可分配空间。32位机器默认是64M，64位机器模式是82M</li><li>当JVM加载的类信息容量超过了这个值，会报异常 <strong>OutofMemoryError:PermGen space</strong>。</li></ul><h2 id="2-JDK8及以后-元空间"><a href="#2-JDK8及以后-元空间" class="headerlink" title="2. JDK8及以后(元空间)"></a>2. JDK8及以后(元空间)</h2><ul><li>元数据区大小可以使用参数 <code>-XX:MetaspaceSize</code> 和 <code>-XX:MaxMetaspaceSize</code> 指定</li><li>默认值依赖于平台，Windows下，<code>-XX:MetaspaceSize</code> 约为21M，<code>-XX:MaxMetaspaceSize</code> 的值是-1，即没有限制。</li><li>与永久代不同，如果不指定大小，默认情况下，虚拟机会耗尽所有的可用系统内存。如果元数据区发生溢出，虚拟机一样会抛出异常<strong>OutOfMemoryError:Metaspace</strong></li><li>-XX:MetaspaceSize：设置初始的元空间大小。对于一个 64位 的服务器端 JVM 来说，其默认的 -XX:MetaspaceSize值为21MB。这就是初始的高水位线，一旦触及这个水位线，Full GC将会被触发并卸载没用的类（即这些类对应的类加载器不再存活），然后这个高水位线将会重置。新的高水位线的值取决于GC后释放了多少元空间。如果释放的空间不足，那么在不超过MaxMetaspaceSize时，适当提高该值。如果释放空间过多，则适当降低该值。</li><li>如果初始化的高水位线设置过低，上述高水位线调整情况会发生很多次。通过垃圾回收器的日志可以观察到Full GC多次调用。为了避免频繁地GC，建议将-<code>XX:MetaspaceSize</code> 设置为一个相对较高的值。</li></ul><h2 id="3-方法区OOM"><a href="#3-方法区OOM" class="headerlink" title="3. 方法区OOM"></a>3. 方法区OOM</h2><h3 id="3-1-代码示例"><a href="#3-1-代码示例" class="headerlink" title="3.1 代码示例"></a>3.1 代码示例</h3><blockquote><p>代码：OOMTest 类继承 ClassLoader 类，获得 defineClass() 方法，可自己进行类的加载</p></blockquote><pre><code class="highlight java"><span class="comment">/**</span><span class="comment"> * jdk6/7中：</span><span class="comment"> * -XX:PermSize=10m -XX:MaxPermSize=10m</span><span class="comment"> *</span><span class="comment"> * jdk8中：</span><span class="comment"> * 配置一：默认开始指针压缩</span><span class="comment"> * -XX:MetaspaceSize=10m -XX:MaxMetaspaceSize=10m</span><span class="comment"> * 配置二：关闭指针压缩</span><span class="comment"> * -XX:MetaspaceSize=20m -XX:MaxMetaspaceSize=20m -XX:-UseCompressedClassPointers</span><span class="comment"> */</span><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">OOMTest</span> <span class="keyword">extends</span> <span class="title class_">ClassLoader</span> &#123;    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;        <span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> <span class="number">0</span>;        <span class="keyword">try</span> &#123;            <span class="type">OOMTest</span> <span class="variable">test</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">OOMTest</span>();            <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; <span class="number">100000</span>; i++) &#123;                <span class="comment">//创建ClassWriter对象，用于生成类的二进制字节码</span>                <span class="type">ClassWriter</span> <span class="variable">classWriter</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ClassWriter</span>(<span class="number">0</span>);                <span class="comment">//指明版本号，修饰符，类名，包名，父类，接口</span>                classWriter.visit(Opcodes.V1_6, Opcodes.ACC_PUBLIC, <span class="string">&quot;Class&quot;</span> + i, <span class="literal">null</span>, <span class="string">&quot;java/lang/Object&quot;</span>, <span class="literal">null</span>);                <span class="comment">//返回byte[]</span>                <span class="type">byte</span>[] code = classWriter.toByteArray();                <span class="comment">//类的加载</span>                test.defineClass(<span class="string">&quot;Class&quot;</span> + i, code, <span class="number">0</span>, code.length);<span class="comment">//Class对象</span>                j++;            &#125;        &#125; <span class="keyword">finally</span> &#123;            System.out.println(j);        &#125;    &#125;&#125;</code></pre><h3 id="3-2-不设置元空间的上限"><a href="#3-2-不设置元空间的上限" class="headerlink" title="3.2 不设置元空间的上限"></a>3.2 不设置元空间的上限</h3><p>使用默认的JVM配置，元空间最大值为系统最大内存。</p><blockquote><p>输出结果：</p></blockquote><pre><code class="highlight plaintext">100000</code></pre><h3 id="3-3-设置元空间的上限"><a href="#3-3-设置元空间的上限" class="headerlink" title="3.3 设置元空间的上限"></a>3.3 设置元空间的上限</h3><blockquote><p>JVM 参数：-XX:MetaspaceSize&#x3D;10m -XX:MaxMetaspaceSize&#x3D;10m</p></blockquote><blockquote><p>输出结果：</p></blockquote><pre><code class="highlight plaintext">3331Exception in thread &quot;main&quot; java.lang.OutOfMemoryError: Compressed class spaceat java.lang.ClassLoader.defineClass1(Native Method)at java.lang.ClassLoader.defineClass(ClassLoader.java:756)at java.lang.ClassLoader.defineClass(ClassLoader.java:635)at com.atguigu.java.OOMTest.main(OOMTest.java:29)</code></pre><p>与预期不一致，这是由于Hotspot虚拟机在64位操作系统上默认开启了指针压缩，关于指针压缩见：<a href="https://www.cnblogs.com/star95/p/17512212.html">https://www.cnblogs.com/star95/p/17512212.html</a></p><blockquote><p>修改JVM参数，关闭指针压缩</p><p>-XX:MetaspaceSize&#x3D;20m -XX:MaxMetaspaceSize&#x3D;20m -XX:-UseCompressedClassPointers</p></blockquote><blockquote><p>输出结果：</p></blockquote><pre><code class="highlight plaintext">25120Exception in thread &quot;main&quot; java.lang.OutOfMemoryError: Metaspaceat java.lang.ClassLoader.defineClass1(Native Method)at java.lang.ClassLoader.defineClass(ClassLoader.java:756)at java.lang.ClassLoader.defineClass(ClassLoader.java:635)at com.atguigu.java.OOMTest.main(OOMTest.java:29)</code></pre><h3 id="3-4-如何解决OOM"><a href="#3-4-如何解决OOM" class="headerlink" title="3.4 如何解决OOM"></a>3.4 如何解决OOM</h3><blockquote><p>这个属于调优的问题，这里先简单的说一下</p></blockquote><ul><li>要解决OOM异常或heap space的异常，一般的手段是首先通过内存映像分析工具（如Ec1ipse Memory Analyzer）对dump出来的堆转储快照进行分析，重点是确认内存中的对象是否是必要的，也就是要先分清楚到底是出现了内存泄漏（Memory Leak）还是内存溢出（Memory Overflow）</li><li>内存泄漏就是有大量的引用指向某些对象，但是这些对象以后不会使用了，但是因为它们还和GC ROOT有关联，所以导致以后这些对象也不会被回收，这就是内存泄漏的问题</li><li>如果是内存泄漏，可进一步通过工具查看泄漏对象到GC Roots的引用链。于是就能找到泄漏对象是通过怎样的路径与GC Roots相关联并导致垃圾收集器无法自动回收它们的。掌握了泄漏对象的类型信息，以及GC Roots引用链的信息，就可以比较准确地定位出泄漏代码的位置。</li><li>如果不存在内存泄漏，换句话说就是内存中的对象确实都还必须存活着，那就应当检查虚拟机的堆参数（-Xmx与-Xms），与机器物理内存对比看是否还可以调大，从代码上检查是否存在某些对象生命周期过长、持有状态时间过长的情况，尝试减少程序运行期的内存消耗。</li></ul><h1 id="四、方法区的内部结构"><a href="#四、方法区的内部结构" class="headerlink" title="四、方法区的内部结构"></a>四、方法区的内部结构</h1><h2 id="1-方法区存储什么？"><a href="#1-方法区存储什么？" class="headerlink" title="1. 方法区存储什么？"></a>1. 方法区存储什么？</h2><img src="https://raw.githubusercontent.com/GeorgeChan95/blogimg/master/img/2023/12/15/20231215-160446.png" alt="image-20231215160445011" style="zoom: 50%;" /><p>《深入理解Java虚拟机》书中对方法区（Method Area）存储内容描述如下：它用于存储已被虚拟机加载的 <strong>类型信息、常量、静态变量、即时编译器编译后的代码缓存</strong>等。</p><p><img src="https://raw.githubusercontent.com/GeorgeChan95/blogimg/master/img/2023/12/15/20231215-160703.png" alt="image-20231215160701845"></p><h3 id="1-1-类型信息"><a href="#1-1-类型信息" class="headerlink" title="1.1 类型信息"></a>1.1 类型信息</h3><p>对每个加载的类型（类class、接口interface、枚举enum、注解annotation），JVM必须在方法区中存储以下类型信息：</p><ul><li>这个类型的完整有效名称（全名&#x3D;包名.类名）</li><li>这个类型直接父类的完整有效名（对于interface或是java.lang.Object，都没有父类）</li><li>这个类型的修饰符（public，abstract，final的某个子集）</li><li>这个类型直接接口的一个有序列表</li></ul><h3 id="1-2-域（Field）信息"><a href="#1-2-域（Field）信息" class="headerlink" title="1.2 域（Field）信息"></a>1.2 域（Field）信息</h3><blockquote><p>也就是我们常说的成员变量，域信息是比较官方的称呼</p></blockquote><ul><li>JVM必须在方法区中保存类型的所有域的相关信息以及域的声明顺序。</li><li>域的相关信息包括：域名称，域类型，域修饰符（public，private，protected，static，final，volatile，transient的某个子集）</li></ul><h3 id="1-3-方法（Method）信息"><a href="#1-3-方法（Method）信息" class="headerlink" title="1.3 方法（Method）信息"></a>1.3 方法（Method）信息</h3><p>JVM必须保存所有方法的以下信息，同域信息一样包括声明顺序：</p><ul><li>方法名称</li><li>方法的返回类型（包括 void 返回类型），void 在 Java 中对应的为 void.class</li><li>方法参数的数量和类型（按顺序）</li><li>方法的修饰符（public，private，protected，static，final，synchronized，native，abstract的一个子集）</li><li>方法的字节码（bytecodes）、操作数栈、局部变量表及大小（abstract和native方法除外）</li><li>异常表（abstract和native方法除外），异常表记录每个异常处理的开始位置、结束位置、代码处理在程序计数器中的偏移地址、被捕获的异常类的常量池索引</li></ul><h3 id="1-4-代码示例解析"><a href="#1-4-代码示例解析" class="headerlink" title="1.4 代码示例解析"></a>1.4 代码示例解析</h3><blockquote><p>示例代码</p></blockquote><pre><code class="highlight java"><span class="comment">/**</span><span class="comment"> * 测试方法区的内部构成</span><span class="comment"> * <span class="doctag">@author</span> shkstart  shkstart@126.com</span><span class="comment"> * <span class="doctag">@create</span> 2020  23:39</span><span class="comment"> */</span><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">MethodInnerStrucTest</span> <span class="keyword">extends</span> <span class="title class_">Object</span> <span class="keyword">implements</span> <span class="title class_">Comparable</span>&lt;String&gt;,Serializable &#123;    <span class="comment">//属性</span>    <span class="keyword">public</span> <span class="type">int</span> <span class="variable">num</span> <span class="operator">=</span> <span class="number">10</span>;    <span class="keyword">private</span> <span class="keyword">static</span> <span class="type">String</span> <span class="variable">str</span> <span class="operator">=</span> <span class="string">&quot;测试方法的内部结构&quot;</span>;    <span class="comment">//构造器</span>    <span class="comment">//方法</span>    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">test1</span><span class="params">()</span>&#123;        <span class="type">int</span> <span class="variable">count</span> <span class="operator">=</span> <span class="number">20</span>;        System.out.println(<span class="string">&quot;count = &quot;</span> + count);    &#125;    <span class="keyword">public</span> <span class="keyword">static</span> <span class="type">int</span> <span class="title function_">test2</span><span class="params">(<span class="type">int</span> cal)</span>&#123;        <span class="type">int</span> <span class="variable">result</span> <span class="operator">=</span> <span class="number">0</span>;        <span class="keyword">try</span> &#123;            <span class="type">int</span> <span class="variable">value</span> <span class="operator">=</span> <span class="number">30</span>;            result = value / cal;        &#125; <span class="keyword">catch</span> (Exception e) &#123;            e.printStackTrace();        &#125;        <span class="keyword">return</span> result;    &#125;    <span class="meta">@Override</span>    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">compareTo</span><span class="params">(String o)</span> &#123;        <span class="keyword">return</span> <span class="number">0</span>;    &#125;&#125;</code></pre><blockquote><p>反编译字节码，输出到指定文件</p></blockquote><pre><code class="highlight plaintext">javap -v -p MethodInnerStrucTest.class &gt; test.txt</code></pre><ul><li>反编译字节码文件，并输出值文本文件中，便于查看。参数 -p 确保能查看 private 权限类型的字段或方法</li></ul><p>输出内容如下：</p><pre><code class="highlight plaintext">Classfile /H:/code_test/JVMDemo/out/production/chapter09/com/atguigu/java/MethodInnerStrucTest.class  Last modified 2023-12-13; size 1626 bytes  MD5 checksum 0d0fcb54854d4ce183063df985141ad0  Compiled from &quot;MethodInnerStrucTest.java&quot;  //类型信息public class com.atguigu.java.MethodInnerStrucTest extends java.lang.Object implements java.lang.Comparable&lt;java.lang.String&gt;, java.io.Serializable  minor version: 0  major version: 52  flags: ACC_PUBLIC, ACC_SUPERConstant pool:   #1 = Methodref          #18.#52        // java/lang/Object.&quot;&lt;init&gt;&quot;:()V   #2 = Fieldref           #17.#53        // com/atguigu/java/MethodInnerStrucTest.num:I   #3 = Fieldref           #54.#55        // java/lang/System.out:Ljava/io/PrintStream;   #4 = Class              #56            // java/lang/StringBuilder   #5 = Methodref          #4.#52         // java/lang/StringBuilder.&quot;&lt;init&gt;&quot;:()V   #6 = String             #57            // count =   #7 = Methodref          #4.#58         // java/lang/StringBuilder.append:(Ljava/lang/String;)Ljava/lang/StringBuilder;   #8 = Methodref          #4.#59         // java/lang/StringBuilder.append:(I)Ljava/lang/StringBuilder;   #9 = Methodref          #4.#60         // java/lang/StringBuilder.toString:()Ljava/lang/String;  #10 = Methodref          #61.#62        // java/io/PrintStream.println:(Ljava/lang/String;)V  #11 = Class              #63            // java/lang/Exception  #12 = Methodref          #11.#64        // java/lang/Exception.printStackTrace:()V  #13 = Class              #65            // java/lang/String  #14 = Methodref          #17.#66        // com/atguigu/java/MethodInnerStrucTest.compareTo:(Ljava/lang/String;)I  #15 = String             #67            // 测试方法的内部结构  #16 = Fieldref           #17.#68        // com/atguigu/java/MethodInnerStrucTest.str:Ljava/lang/String;  #17 = Class              #69            // com/atguigu/java/MethodInnerStrucTest  #18 = Class              #70            // java/lang/Object  #19 = Class              #71            // java/lang/Comparable  #20 = Class              #72            // java/io/Serializable  #21 = Utf8               num  #22 = Utf8               I  #23 = Utf8               str  #24 = Utf8               Ljava/lang/String;  #25 = Utf8               &lt;init&gt;  #26 = Utf8               ()V  #27 = Utf8               Code  #28 = Utf8               LineNumberTable  #29 = Utf8               LocalVariableTable  #30 = Utf8               this  #31 = Utf8               Lcom/atguigu/java/MethodInnerStrucTest;  #32 = Utf8               test1  #33 = Utf8               count  #34 = Utf8               test2  #35 = Utf8               (I)I  #36 = Utf8               value  #37 = Utf8               e  #38 = Utf8               Ljava/lang/Exception;  #39 = Utf8               cal  #40 = Utf8               result  #41 = Utf8               StackMapTable  #42 = Class              #63            // java/lang/Exception  #43 = Utf8               compareTo  #44 = Utf8               (Ljava/lang/String;)I  #45 = Utf8               o  #46 = Utf8               (Ljava/lang/Object;)I  #47 = Utf8               &lt;clinit&gt;  #48 = Utf8               Signature  #49 = Utf8               Ljava/lang/Object;Ljava/lang/Comparable&lt;Ljava/lang/String;&gt;;Ljava/io/Serializable;  #50 = Utf8               SourceFile  #51 = Utf8               MethodInnerStrucTest.java  #52 = NameAndType        #25:#26        // &quot;&lt;init&gt;&quot;:()V  #53 = NameAndType        #21:#22        // num:I  #54 = Class              #73            // java/lang/System  #55 = NameAndType        #74:#75        // out:Ljava/io/PrintStream;  #56 = Utf8               java/lang/StringBuilder  #57 = Utf8               count =  #58 = NameAndType        #76:#77        // append:(Ljava/lang/String;)Ljava/lang/StringBuilder;  #59 = NameAndType        #76:#78        // append:(I)Ljava/lang/StringBuilder;  #60 = NameAndType        #79:#80        // toString:()Ljava/lang/String;  #61 = Class              #81            // java/io/PrintStream  #62 = NameAndType        #82:#83        // println:(Ljava/lang/String;)V  #63 = Utf8               java/lang/Exception  #64 = NameAndType        #84:#26        // printStackTrace:()V  #65 = Utf8               java/lang/String  #66 = NameAndType        #43:#44        // compareTo:(Ljava/lang/String;)I  #67 = Utf8               测试方法的内部结构  #68 = NameAndType        #23:#24        // str:Ljava/lang/String;  #69 = Utf8               com/atguigu/java/MethodInnerStrucTest  #70 = Utf8               java/lang/Object  #71 = Utf8               java/lang/Comparable  #72 = Utf8               java/io/Serializable  #73 = Utf8               java/lang/System  #74 = Utf8               out  #75 = Utf8               Ljava/io/PrintStream;  #76 = Utf8               append  #77 = Utf8               (Ljava/lang/String;)Ljava/lang/StringBuilder;  #78 = Utf8               (I)Ljava/lang/StringBuilder;  #79 = Utf8               toString  #80 = Utf8               ()Ljava/lang/String;  #81 = Utf8               java/io/PrintStream  #82 = Utf8               println  #83 = Utf8               (Ljava/lang/String;)V  #84 = Utf8               printStackTrace&#123;  //域信息  public int num;    descriptor: I    flags: ACC_PUBLIC  // 静态变量  private static java.lang.String str;    descriptor: Ljava/lang/String;    flags: ACC_PRIVATE, ACC_STATIC  //方法信息  public com.atguigu.java.MethodInnerStrucTest();    descriptor: ()V    flags: ACC_PUBLIC    Code:      stack=2, locals=1, args_size=1         0: aload_0         1: invokespecial #1                  // Method java/lang/Object.&quot;&lt;init&gt;&quot;:()V         4: aload_0         5: bipush        10         7: putfield      #2                  // Field num:I        10: return      LineNumberTable:        line 10: 0        line 12: 4      LocalVariableTable:        Start  Length  Slot  Name   Signature            0      11     0  this   Lcom/atguigu/java/MethodInnerStrucTest;  //方法信息  public void test1();    descriptor: ()V    flags: ACC_PUBLIC    Code:      stack=3, locals=2, args_size=1         0: bipush        20         2: istore_1         3: getstatic     #3                  // Field java/lang/System.out:Ljava/io/PrintStream;         6: new           #4                  // class java/lang/StringBuilder         9: dup        10: invokespecial #5                  // Method java/lang/StringBuilder.&quot;&lt;init&gt;&quot;:()V        13: ldc           #6                  // String count =        15: invokevirtual #7                  // Method java/lang/StringBuilder.append:(Ljava/lang/String;)Ljava/lang/StringBuilder;        18: iload_1        19: invokevirtual #8                  // Method java/lang/StringBuilder.append:(I)Ljava/lang/StringBuilder;        22: invokevirtual #9                  // Method java/lang/StringBuilder.toString:()Ljava/lang/String;        25: invokevirtual #10                 // Method java/io/PrintStream.println:(Ljava/lang/String;)V        28: return      LineNumberTable:        line 17: 0        line 18: 3        line 19: 28      LocalVariableTable:        Start  Length  Slot  Name   Signature            0      29     0  this   Lcom/atguigu/java/MethodInnerStrucTest;            3      26     1 count   I  public static int test2(int);    descriptor: (I)I    flags: ACC_PUBLIC, ACC_STATIC    Code:      stack=2, locals=3, args_size=1         0: iconst_0         1: istore_1         2: bipush        30         4: istore_2         5: iload_2         6: iload_0         7: idiv         8: istore_1         9: goto          17        12: astore_2        13: aload_2        14: invokevirtual #12                 // Method java/lang/Exception.printStackTrace:()V        17: iload_1        18: ireturn      Exception table:         from    to  target type             2     9    12   Class java/lang/Exception      LineNumberTable:        line 21: 0        line 23: 2        line 24: 5        line 27: 9        line 25: 12        line 26: 13        line 28: 17      LocalVariableTable:        Start  Length  Slot  Name   Signature            5       4     2 value   I           13       4     2     e   Ljava/lang/Exception;            0      19     0   cal   I            2      17     1 result   I      StackMapTable: number_of_entries = 2        frame_type = 255 /* full_frame */          offset_delta = 12          locals = [ int, int ]          stack = [ class java/lang/Exception ]        frame_type = 4 /* same */  public int compareTo(java.lang.String);    descriptor: (Ljava/lang/String;)I    flags: ACC_PUBLIC    Code:      stack=1, locals=2, args_size=2         0: iconst_0         1: ireturn      LineNumberTable:        line 33: 0      LocalVariableTable:        Start  Length  Slot  Name   Signature            0       2     0  this   Lcom/atguigu/java/MethodInnerStrucTest;            0       2     1     o   Ljava/lang/String;  public int compareTo(java.lang.Object);    descriptor: (Ljava/lang/Object;)I    flags: ACC_PUBLIC, ACC_BRIDGE, ACC_SYNTHETIC    Code:      stack=2, locals=2, args_size=2         0: aload_0         1: aload_1         2: checkcast     #13                 // class java/lang/String         5: invokevirtual #14                 // Method compareTo:(Ljava/lang/String;)I         8: ireturn      LineNumberTable:        line 10: 0      LocalVariableTable:        Start  Length  Slot  Name   Signature            0       9     0  this   Lcom/atguigu/java/MethodInnerStrucTest;  static &#123;&#125;;    descriptor: ()V    flags: ACC_STATIC    Code:      stack=1, locals=0, args_size=0         0: ldc           #15                 // String 测试方法的内部结构         2: putstatic     #16                 // Field str:Ljava/lang/String;         5: return      LineNumberTable:        line 13: 0&#125;Signature: #49                          // Ljava/lang/Object;Ljava/lang/Comparable&lt;Ljava/lang/String;&gt;;Ljava/io/Serializable;SourceFile: &quot;MethodInnerStrucTest.java&quot;</code></pre><p><strong>类型信息</strong></p><p>在运行时方法区中，类信息中记录了哪个加载器加载了该类，同时类加载器也记录了它加载了哪些类</p><pre><code class="highlight plaintext">//类型信息public class com.atguigu.java.MethodInnerStrucTest extends java.lang.Object implements java.lang.Comparable&lt;java.lang.String&gt;, java.io.Serializable  minor version: 0  major version: 52  flags: ACC_PUBLIC, ACC_SUPER</code></pre><p><strong>域信息</strong></p><ul><li>descriptor: I 表示字段类型为 Integer</li><li>flags: ACC_PUBLIC 表示字段权限修饰符为 public</li></ul><pre><code class="highlight plaintext">//域信息public int num;  descriptor: I  flags: ACC_PUBLIC// 静态变量private static java.lang.String str;  descriptor: Ljava/lang/String;  flags: ACC_PRIVATE, ACC_STATIC</code></pre><p><strong>方法信息</strong></p><ul><li>descriptor: ()V 表示方法返回值类型为 void</li><li>flags: ACC_PUBLIC 表示方法权限修饰符为 public</li><li>stack&#x3D;3 表示操作数栈深度为 3</li><li>locals&#x3D;2 表示局部变量个数为 2 个（实力方法包含 this）</li><li>test1() 方法虽然没有参数，但是其 args_size&#x3D;1 ，这时因为将 this 作为了参数</li></ul><pre><code class="highlight plaintext">//方法信息public void test1();  descriptor: ()V  flags: ACC_PUBLIC  Code:    stack=3, locals=2, args_size=1       0: bipush        20       2: istore_1       3: getstatic     #3                  // Field java/lang/System.out:Ljava/io/PrintStream;       6: new           #4                  // class java/lang/StringBuilder       9: dup      10: invokespecial #5                  // Method java/lang/StringBuilder.&quot;&lt;init&gt;&quot;:()V      13: ldc           #6                  // String count =      15: invokevirtual #7                  // Method java/lang/StringBuilder.append:(Ljava/lang/String;)Ljava/lang/StringBuilder;      18: iload_1      19: invokevirtual #8                  // Method java/lang/StringBuilder.append:(I)Ljava/lang/StringBuilder;      22: invokevirtual #9                  // Method java/lang/StringBuilder.toString:()Ljava/lang/String;      25: invokevirtual #10                 // Method java/io/PrintStream.println:(Ljava/lang/String;)V      28: return    LineNumberTable:      line 17: 0      line 18: 3      line 19: 28    LocalVariableTable:      Start  Length  Slot  Name   Signature          0      29     0  this   Lcom/atguigu/java/MethodInnerStrucTest;          3      26     1 count   I</code></pre><h2 id="2-non-final-类型的类变量"><a href="#2-non-final-类型的类变量" class="headerlink" title="2. non-final 类型的类变量"></a>2. non-final 类型的类变量</h2><ul><li>静态变量和类关联在一起，随着类的加载而加载，他们成为类数据在逻辑上的一部分</li><li>类变量被类的所有实例共享，即使没有类实例时，你也可以访问它</li></ul><p><strong>举例</strong></p><p>如下代码所示，即使我们把order设置为null，也不会出现空指针异常。这更加表明了 static 类型的字段和方法随着类的加载而加载，并不属于特定的类实例。</p><blockquote><p>JAVA代码</p></blockquote><pre><code class="highlight java"><span class="comment">/**</span><span class="comment"> * non-final的类变量</span><span class="comment"> */</span><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">MethodAreaTest</span> &#123;    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;        <span class="type">Order</span> <span class="variable">order</span> <span class="operator">=</span> <span class="literal">null</span>;        order.hello();        System.out.println(order.count);        System.out.println(order.number);    &#125;&#125;<span class="keyword">class</span> <span class="title class_">Order</span> &#123;    <span class="keyword">public</span> <span class="keyword">static</span> <span class="type">int</span> <span class="variable">count</span> <span class="operator">=</span> <span class="number">1</span>;    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">int</span> <span class="variable">number</span> <span class="operator">=</span> <span class="number">2</span>;        <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">hello</span><span class="params">()</span> &#123;        System.out.println(<span class="string">&quot;hello!&quot;</span>);    &#125;&#125;</code></pre><blockquote><p>输出结果：</p></blockquote><pre><code class="highlight plaintext">hello!12</code></pre><h2 id="3-全局常量：static-final"><a href="#3-全局常量：static-final" class="headerlink" title="3. 全局常量：static final"></a>3. 全局常量：static final</h2><ul><li>全局常量就是使用 static final 进行修饰</li><li>被声明为final的类变量的处理方法则不同，每个全局常量在编译的时候就会被分配了。</li></ul><blockquote><p>Java代码</p></blockquote><pre><code class="highlight java"><span class="keyword">class</span> <span class="title class_">Order</span> &#123;    <span class="keyword">public</span> <span class="keyword">static</span> <span class="type">int</span> <span class="variable">count</span> <span class="operator">=</span> <span class="number">1</span>;    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">int</span> <span class="variable">number</span> <span class="operator">=</span> <span class="number">2</span>;&#125;</code></pre><blockquote><p>字节码</p></blockquote><pre><code class="highlight plaintext">public static int count;  descriptor: I  flags: ACC_PUBLIC, ACC_STATICpublic static final int number;  descriptor: I  flags: ACC_PUBLIC, ACC_STATIC, ACC_FINAL  ConstantValue: int 2</code></pre><p>可以发现 staitc和final同时修饰的number 的<strong>值在编译上的时候已经写死在字节码文件中了。</strong></p><h2 id="4-运行时常量池"><a href="#4-运行时常量池" class="headerlink" title="4. 运行时常量池"></a>4. 运行时常量池</h2><h3 id="4-1-运行时常量池-VS-常量池"><a href="#4-1-运行时常量池-VS-常量池" class="headerlink" title="4.1 运行时常量池 VS 常量池"></a>4.1 运行时常量池 VS 常量池</h3><blockquote><p>官方文档：<a href="https://docs.oracle.com/javase/specs/jvms/se8/html/jvms-4.html">https://docs.oracle.com/javase/specs/jvms/se8/html/jvms-4.html</a></p></blockquote><p><img src="https://raw.githubusercontent.com/GeorgeChan95/blogimg/master/img/2023/12/16/20231216-101422.png" alt="image-20231216101418999"></p><ul><li>方法区，内部包含了运行时常量池</li><li>字节码文件，内部包含了常量池。（之前的字节码文件中已经看到了很多Constant pool的东西，这个就是常量池）</li><li>要弄清楚方法区，需要理解清楚ClassFile，因为加载类的信息都在方法区。</li><li>要弄清楚方法区的运行时常量池，需要理解清楚ClassFile中的常量池。</li></ul><h4 id="4-1-1-常量池"><a href="#4-1-1-常量池" class="headerlink" title="4.1.1 常量池"></a>4.1.1 常量池</h4><ul><li>一个有效的字节码文件中除了包含类的版本信息、字段、方法以及接口等描述符信息外。还包含一项信息就是<strong>常量池表</strong>（<strong>Constant Pool Table</strong>），包括各种字面量和对类型、域和方法的符号引用。</li><li>字面量： <code>10</code> ， <code>“我是某某”</code> 这种数字和字符串都是字面量</li></ul><p><img src="https://raw.githubusercontent.com/GeorgeChan95/blogimg/master/img/2023/12/16/20231216-103632.png" alt="image-20231216103631531"></p><p><strong>通过Jclasslib看会更直观一些</strong></p><p><img src="https://raw.githubusercontent.com/GeorgeChan95/blogimg/master/img/2023/12/16/20231216-103753.png" alt="image-20231216103752338"></p><h5 id="为什么需要常量池？"><a href="#为什么需要常量池？" class="headerlink" title="为什么需要常量池？"></a>为什么需要常量池？</h5><p>一个java源文件中的类、接口，编译后产生一个字节码文件。而Java中的字节码需要数据支持，通常这种数据会很大以至于不能直接存到字节码里，换另一种方式，可以存到常量池。这个字节码包含了指向常量池的引用。在动态链接的时候会用到运行时常量池.</p><blockquote><p>比如：如下的代码</p></blockquote><pre><code class="highlight java"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">SimpleClass</span> &#123;    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">sayHello</span><span class="params">()</span> &#123;        System.out.println(<span class="string">&quot;hello&quot;</span>);    &#125;&#125;</code></pre><ul><li>虽然上述代码只有135字节，但是里面却使用了String、System、PrintStream及Object等结构。</li><li>比如说我们这个文件中有6个地方用到了”hello”这个字符串，如果不用常量池，就需要在6个地方全写一遍，造成臃肿。我们可以将”hello”等所需用到的结构信息记录在常量池中，并通过<strong>引用的方式</strong>，来加载、调用所需的结构</li><li>这里的代码量其实很少了，如果代码多的话，引用的结构将会更多，这里就需要用到常量池了。</li></ul><p><img src="https://raw.githubusercontent.com/GeorgeChan95/blogimg/master/img/2023/12/16/20231216-104611.png" alt="image-20231216104610257"></p><h5 id="常量池中有什么？"><a href="#常量池中有什么？" class="headerlink" title="常量池中有什么？"></a>常量池中有什么？</h5><ul><li>数量值</li><li>字符串值</li><li>类引用</li><li>字段引用</li><li>方法引用</li></ul><blockquote><p>MethodInnerStrucTest 的 test1方法的字节码</p></blockquote><pre><code class="highlight java"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">test1</span><span class="params">()</span>&#123;<span class="type">int</span> <span class="variable">count</span> <span class="operator">=</span> <span class="number">20</span>;System.out.println(<span class="string">&quot;count = &quot;</span> + count);&#125;</code></pre><pre><code class="highlight plaintext">public void test1();  descriptor: ()V  flags: ACC_PUBLIC  Code:    stack=3, locals=2, args_size=1       0: bipush        20       2: istore_1       3: getstatic     #3                  // Field java/lang/System.out:Ljava/io/PrintStream;       6: new           #4                  // class java/lang/StringBuilder       9: dup      10: invokespecial #5                  // Method java/lang/StringBuilder.&quot;&lt;init&gt;&quot;:()V      13: ldc           #6                  // String count =      15: invokevirtual #7                  // Method java/lang/StringBuilder.append:(Ljava/lang/String;)Ljava/lang/StringBuilder;      18: iload_1      19: invokevirtual #8                  // Method java/lang/StringBuilder.append:(I)Ljava/lang/StringBuilder;      22: invokevirtual #9                  // Method java/lang/StringBuilder.toString:()Ljava/lang/String;      25: invokevirtual #10                 // Method java/io/PrintStream.println:(Ljava/lang/String;)V      28: return    LineNumberTable:      line 17: 0      line 18: 3      line 19: 28    LocalVariableTable:      Start  Length  Slot  Name   Signature          0      29     0  this   Lcom/atguigu/java/MethodInnerStrucTest;          3      26     1 count   I</code></pre><p><strong>#3，#4，#5等等这些带# 的，都是引用了常量池。</strong></p><h5 id="常量池总结"><a href="#常量池总结" class="headerlink" title="常量池总结"></a>常量池总结</h5><p>常量池、可以看做是一张表，虚拟机指令根据这张常量表找到要执行的类名、方法名、参数类型、字面量等类型。</p><h4 id="4-2-运行时常量池"><a href="#4-2-运行时常量池" class="headerlink" title="4.2 运行时常量池"></a>4.2 运行时常量池</h4><ul><li>运行时常量池（Runtime Constant Pool）是方法区的一部分。</li><li>常量池表（Constant Pool Table）是Class字节码文件的一部分，用于存放编译期生成的各种字面量与符号引用，<strong>这部分内容将在类加载后存放到方法区的运行时常量池中</strong>。（运行时常量池就是常量池在程序运行时的称呼）</li><li>当虚拟机启动后，执行加载类和接口到虚拟机中，就会为类和接口创建对应的运行时常量池。</li><li>JVM为每个已加载的类型（类或接口）都维护一个常量池。池中的数据项像数组项一样，是通过索引访问的。</li><li>运行时常量池中包含多种不同的常量，包括编译期就已经明确的数值字面量，也包括到运行期解析后才能够获得的方法或者字段引用。<strong>此时不再是常量池中的符号地址了，这里换为真实地址</strong>。<ul><li>运行时常量池，相对于Class文件常量池的另一重要特征是：<strong>具备动态性</strong>。</li></ul></li><li>运行时常量池类似于传统编程语言中的符号表（symbol table），但是它所包含的数据却比符号表要更加丰富一些。</li><li>当创建类或接口的运行时常量池时，如果构造运行时常量池所需的内存空间超过了方法区所能提供的最大值，则JVM会抛OutofMemoryError异常。</li></ul><h1 id="五、方法区的使用举例"><a href="#五、方法区的使用举例" class="headerlink" title="五、方法区的使用举例"></a>五、方法区的使用举例</h1><blockquote><p>JAVA文件</p></blockquote><pre><code class="highlight java"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">MethodAreaDemo</span> &#123;    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;        <span class="type">int</span> <span class="variable">x</span> <span class="operator">=</span> <span class="number">500</span>;        <span class="type">int</span> <span class="variable">y</span> <span class="operator">=</span> <span class="number">100</span>;        <span class="type">int</span> <span class="variable">a</span> <span class="operator">=</span> x / y;        <span class="type">int</span> <span class="variable">b</span> <span class="operator">=</span> <span class="number">50</span>;        System.out.println(a + b);    &#125;&#125;</code></pre><blockquote><p>字节码文件</p></blockquote><pre><code class="highlight plaintext">Classfile /H:/code_test/JVMDemo/out/production/chapter09/com/atguigu/java1/MethodAreaDemo.class  Last modified 2023-11-28; size 640 bytes  MD5 checksum 2f156fd78400e995f4b15c88ce410334  Compiled from &quot;MethodAreaDemo.java&quot;public class com.atguigu.java1.MethodAreaDemo  minor version: 0  major version: 52  flags: ACC_PUBLIC, ACC_SUPERConstant pool:   #1 = Methodref          #5.#24         // java/lang/Object.&quot;&lt;init&gt;&quot;:()V   #2 = Fieldref           #25.#26        // java/lang/System.out:Ljava/io/PrintStream;   #3 = Methodref          #27.#28        // java/io/PrintStream.println:(I)V   #4 = Class              #29            // com/atguigu/java1/MethodAreaDemo   #5 = Class              #30            // java/lang/Object   #6 = Utf8               &lt;init&gt;   #7 = Utf8               ()V   #8 = Utf8               Code   #9 = Utf8               LineNumberTable  #10 = Utf8               LocalVariableTable  #11 = Utf8               this  #12 = Utf8               Lcom/atguigu/java1/MethodAreaDemo;  #13 = Utf8               main  #14 = Utf8               ([Ljava/lang/String;)V  #15 = Utf8               args  #16 = Utf8               [Ljava/lang/String;  #17 = Utf8               x  #18 = Utf8               I  #19 = Utf8               y  #20 = Utf8               a  #21 = Utf8               b  #22 = Utf8               SourceFile  #23 = Utf8               MethodAreaDemo.java  #24 = NameAndType        #6:#7          // &quot;&lt;init&gt;&quot;:()V  #25 = Class              #31            // java/lang/System  #26 = NameAndType        #32:#33        // out:Ljava/io/PrintStream;  #27 = Class              #34            // java/io/PrintStream  #28 = NameAndType        #35:#36        // println:(I)V  #29 = Utf8               com/atguigu/java1/MethodAreaDemo  #30 = Utf8               java/lang/Object  #31 = Utf8               java/lang/System  #32 = Utf8               out  #33 = Utf8               Ljava/io/PrintStream;  #34 = Utf8               java/io/PrintStream  #35 = Utf8               println  #36 = Utf8               (I)V&#123;  public com.atguigu.java1.MethodAreaDemo();    descriptor: ()V    flags: ACC_PUBLIC    Code:      stack=1, locals=1, args_size=1         0: aload_0         1: invokespecial #1                  // Method java/lang/Object.&quot;&lt;init&gt;&quot;:()V         4: return      LineNumberTable:        line 7: 0      LocalVariableTable:        Start  Length  Slot  Name   Signature            0       5     0  this   Lcom/atguigu/java1/MethodAreaDemo;  public static void main(java.lang.String[]);    descriptor: ([Ljava/lang/String;)V    flags: ACC_PUBLIC, ACC_STATIC    Code:      stack=3, locals=5, args_size=1         0: sipush        500         3: istore_1         4: bipush        100         6: istore_2         7: iload_1         8: iload_2         9: idiv        10: istore_3        11: bipush        50        13: istore        4        15: getstatic     #2                  // Field java/lang/System.out:Ljava/io/PrintStream;        18: iload_3        19: iload         4        21: iadd        22: invokevirtual #3                  // Method java/io/PrintStream.println:(I)V        25: return      LineNumberTable:        line 9: 0        line 10: 4        line 11: 7        line 12: 11        line 13: 15        line 14: 25      LocalVariableTable:        Start  Length  Slot  Name   Signature            0      26     0  args   [Ljava/lang/String;            4      22     1     x   I            7      19     2     y   I           11      15     3     a   I           15      11     4     b   I&#125;SourceFile: &quot;MethodAreaDemo.java&quot;</code></pre><h2 id="1-图解字节码指令执行流程"><a href="#1-图解字节码指令执行流程" class="headerlink" title="1. 图解字节码指令执行流程"></a>1. 图解字节码指令执行流程</h2><h3 id="1-1-初始状态"><a href="#1-1-初始状态" class="headerlink" title="1.1 初始状态"></a>1.1 初始状态</h3><p>局部变量表中仅有方法参数 <code>args</code></p><img src="https://raw.githubusercontent.com/GeorgeChan95/blogimg/master/img/2023/12/16/20231216-111725.png" alt="image-20231216111724483" style="zoom:67%;" /><h3 id="1-2-将字面量500压入操作数栈"><a href="#1-2-将字面量500压入操作数栈" class="headerlink" title="1.2 将字面量500压入操作数栈"></a>1.2 将字面量500压入操作数栈</h3><img src="https://raw.githubusercontent.com/GeorgeChan95/blogimg/master/img/2023/12/16/20231216-111942.png" alt="image-20231216111940436" style="zoom:67%;" /><h3 id="1-3-将500存入本地变量表"><a href="#1-3-将500存入本地变量表" class="headerlink" title="1.3 将500存入本地变量表"></a>1.3 将500存入本地变量表</h3><p>将操作数栈栈顶元素500弹出，存放到本地变量表索引为1的位置。</p><img src="https://raw.githubusercontent.com/GeorgeChan95/blogimg/master/img/2023/12/16/20231216-112123.png" alt="image-20231216112121985" style="zoom:67%;" /><h3 id="1-4-将字面量100压入操作数栈"><a href="#1-4-将字面量100压入操作数栈" class="headerlink" title="1.4 将字面量100压入操作数栈"></a>1.4 将字面量100压入操作数栈</h3><img src="https://raw.githubusercontent.com/GeorgeChan95/blogimg/master/img/2023/12/16/20231216-112212.png" alt="image-20231216112211467" style="zoom:67%;" /><h3 id="1-5-将100存入本地变量表"><a href="#1-5-将100存入本地变量表" class="headerlink" title="1.5 将100存入本地变量表"></a>1.5 将100存入本地变量表</h3><p>将操作数栈栈顶元素100弹出，存放到本地变量表索引为2的位置。</p><img src="https://raw.githubusercontent.com/GeorgeChan95/blogimg/master/img/2023/12/16/20231216-112309.png" alt="image-20231216112308146" style="zoom:67%;" /><h3 id="1-6-从本地变量获取数据，放入操作数栈中"><a href="#1-6-从本地变量获取数据，放入操作数栈中" class="headerlink" title="1.6 从本地变量获取数据，放入操作数栈中"></a>1.6 从本地变量获取数据，放入操作数栈中</h3><p>将本地变量表中下标为1的元素500，和下标为2的元素100复制放入操作数栈中</p><img src="https://raw.githubusercontent.com/GeorgeChan95/blogimg/master/img/2023/12/16/20231216-112524.png" alt="image-20231216112522942" style="zoom:67%;" /><img src="https://raw.githubusercontent.com/GeorgeChan95/blogimg/master/img/2023/12/16/20231216-112549.png" alt="image-20231216112548031" style="zoom:67%;" /><h3 id="1-7-栈顶元素相除，计算结果入栈"><a href="#1-7-栈顶元素相除，计算结果入栈" class="headerlink" title="1.7 栈顶元素相除，计算结果入栈"></a>1.7 栈顶元素相除，计算结果入栈</h3><p>将操作数栈中的元素500和100做除法操作，计算结果5压入操作数栈中。</p><img src="https://raw.githubusercontent.com/GeorgeChan95/blogimg/master/img/2023/12/16/20231216-113812.png" alt="image-20231216113811119" style="zoom:67%;" /><h3 id="1-8-将计算结果5存入本地变量表"><a href="#1-8-将计算结果5存入本地变量表" class="headerlink" title="1.8 将计算结果5存入本地变量表"></a>1.8 将计算结果5存入本地变量表</h3><p>将操作数栈中的计算结果5，存入到本地变量表中。</p><p>指令：istore_3</p><h3 id="1-9-将字面量50压入操作数栈，在存放到本地变量表中"><a href="#1-9-将字面量50压入操作数栈，在存放到本地变量表中" class="headerlink" title="1.9 将字面量50压入操作数栈，在存放到本地变量表中"></a>1.9 将字面量50压入操作数栈，在存放到本地变量表中</h3><p>将字面量50先压入操作数栈中，再从操作数栈中取出，存入到本地变量表下标为4的位置</p><img src="https://raw.githubusercontent.com/GeorgeChan95/blogimg/master/img/2023/12/16/20231216-114124.png" alt="image-20231216114121908" style="zoom:67%;" /><img src="https://raw.githubusercontent.com/GeorgeChan95/blogimg/master/img/2023/12/16/20231216-114157.png" alt="image-20231216114155493" style="zoom:67%;" /><h3 id="1-10-获取类或接口字段的值，存入操作数栈"><a href="#1-10-获取类或接口字段的值，存入操作数栈" class="headerlink" title="1.10 获取类或接口字段的值，存入操作数栈"></a>1.10 获取类或接口字段的值，存入操作数栈</h3><ul><li>#2 在字节码文件常量池中对应的类为：#2 &#x3D; Fieldref           #25.#26        &#x2F;&#x2F; java&#x2F;lang&#x2F;System.out:Ljava&#x2F;io&#x2F;PrintStream;<ul><li>即：System类 和 PrintStream 类</li></ul></li></ul><img src="https://raw.githubusercontent.com/GeorgeChan95/blogimg/master/img/2023/12/16/20231216-114546.png" alt="image-20231216114544615" style="zoom:67%;" /><p><strong>图标标注有误，应该是  #25.#26</strong></p><h3 id="1-11-将本地变量表元素复制到操作数栈"><a href="#1-11-将本地变量表元素复制到操作数栈" class="headerlink" title="1.11 将本地变量表元素复制到操作数栈"></a>1.11 将本地变量表元素复制到操作数栈</h3><p>从本地变量表中获取到下标为3和4的元素（5、50），复制，压入操作数栈中</p><img src="https://raw.githubusercontent.com/GeorgeChan95/blogimg/master/img/2023/12/16/20231216-114927.png" alt="image-20231216114925726" style="zoom:67%;" /><img src="https://raw.githubusercontent.com/GeorgeChan95/blogimg/master/img/2023/12/16/20231216-114942.png" alt="image-20231216114940920" style="zoom:67%;" /><h3 id="1-12-执行加法操作，结果入栈"><a href="#1-12-执行加法操作，结果入栈" class="headerlink" title="1.12 执行加法操作，结果入栈"></a>1.12 执行加法操作，结果入栈</h3><p>将栈顶的两个元素取出，执行相加操作，计算结果入栈。</p><img src="https://raw.githubusercontent.com/GeorgeChan95/blogimg/master/img/2023/12/16/20231216-115120.png" alt="image-20231216115119078" style="zoom:67%;" /><h3 id="1-13-调用实例方法"><a href="#1-13-调用实例方法" class="headerlink" title="1.13 调用实例方法"></a>1.13 调用实例方法</h3><ul><li><p>invokevirtual ：调用实例方法</p></li><li><p>#3 在字节码常量池中对应：#3 &#x3D; Methodref          #27.#28        &#x2F;&#x2F; java&#x2F;io&#x2F;PrintStream.println:(I)V</p><ul><li>即：println() 方法</li></ul></li><li><p>jvm会根据这个方法的描述，创建新栈帧，方法的参数从操作数栈中弹出来，压入虚拟机栈，然后虚拟机会开始执行虚拟机栈最上面的栈帧。执行完毕后，再执行main方法对应的栈帧。</p></li></ul><img src="https://raw.githubusercontent.com/GeorgeChan95/blogimg/master/img/2023/12/16/20231216-120143.png" alt="image-20231216120141720" style="zoom:67%;" /><h3 id="1-14-返回，执行结束"><a href="#1-14-返回，执行结束" class="headerlink" title="1.14 返回，执行结束"></a>1.14 返回，执行结束</h3><p><img src="https://raw.githubusercontent.com/GeorgeChan95/blogimg/master/img/2023/12/16/20231216-120402.png" alt="image-20231216120401266"></p><h2 id="2-符号引用-–-直接饮用"><a href="#2-符号引用-–-直接饮用" class="headerlink" title="2. 符号引用 –&gt; 直接饮用"></a>2. 符号引用 –&gt; 直接饮用</h2><ul><li>上面代码调用 System.out.println() 方法时，首先需要看看 System 类有没有加载，再看看 PrintStream 类有没有加载</li><li>如果没有加载，则执行加载，执行时，将常量池中的符号引用（字面量）转换为运行时常量池的直接引用（真正的地址值）</li></ul><h1 id="六、方法区演进细节"><a href="#六、方法区演进细节" class="headerlink" title="六、方法区演进细节"></a>六、方法区演进细节</h1><h2 id="1-永久代演进过程"><a href="#1-永久代演进过程" class="headerlink" title="1. 永久代演进过程"></a>1. 永久代演进过程</h2><ul><li>首先明确：只有Hotspot才有永久代。BEA JRockit、IBMJ9等来说，是不存在永久代的概念的。原则上如何实现方法区属于虚拟机实现细节，不受《Java虚拟机规范》管束，并不要求统一。</li><li>Hotspot中方法区的变化：</li></ul><table><thead><tr><th>版本</th><th>说明</th></tr></thead><tbody><tr><td>JDK1.6及以前</td><td>有永久代（permanent generation），静态变量存储在永久代上</td></tr><tr><td>JDK1.7</td><td>有永久代，但已经逐步 “去永久代”，字符串常量池，静态变量移除，保存在堆中</td></tr><tr><td>JDK1.8</td><td>无永久代，类型信息，字段，方法，常量保存在本地内存的元空间，但字符串常量池、静态变量仍然在堆中。</td></tr></tbody></table><h3 id="1-1-JDK6"><a href="#1-1-JDK6" class="headerlink" title="1.1 JDK6"></a>1.1 JDK6</h3><p>方法区由永久代实现，使用 JVM 虚拟机内存（虚拟的内存）</p><img src="https://raw.githubusercontent.com/GeorgeChan95/blogimg/master/img/2023/12/16/20231216-130757.jpeg" alt="jdk1.6方法区" style="zoom:50%;" /><h3 id="1-2-JDK1-7"><a href="#1-2-JDK1-7" class="headerlink" title="1.2 JDK1.7"></a>1.2 JDK1.7</h3><p>方法区由永久代实现，使用 JVM 虚拟机内存, 但 静态变量 和 字符串常量池 转移到了堆中。</p><p><img src="https://raw.githubusercontent.com/GeorgeChan95/blogimg/master/img/2023/12/17/20231217-122211.png" alt="image-20231217122208301"></p><h3 id="1-3-JDK8"><a href="#1-3-JDK8" class="headerlink" title="1.3 JDK8"></a>1.3 JDK8</h3><p>方法区由元空间实现，使用物理机本地内存。</p><p><img src="https://raw.githubusercontent.com/GeorgeChan95/blogimg/master/img/2023/12/17/20231217-122533.png" alt="image-20231217122532318"></p><h2 id="2-永久代为什么要被元空间替代？"><a href="#2-永久代为什么要被元空间替代？" class="headerlink" title="2. 永久代为什么要被元空间替代？"></a>2. 永久代为什么要被元空间替代？</h2><blockquote><p>官方文档：<a href="http://openjdk.java.net/jeps/122">http://openjdk.java.net/jeps/122</a></p></blockquote><ul><li>随着Java8的到来，HotSpot VM中再也见不到永久代了。但是这并不意味着类的元数据信息也消失了。这些数据被移到了一个与堆不相连的本地内存区域，这个区域叫做元空间（Metaspace）。</li><li>由于类的元数据分配在本地内存中，元空间的最大可分配空间就是系统可用内存空间。</li><li>这项改动是很有必要的，原因有：<ul><li>为永久代设置空间大小是很难确定的。在某些场景下，如果动态加载类过多，容易产生Perm区的OOM。比如某个实际Web工程中，因为功能点比较多，在运行过程中，要不断动态加载很多类，经常出现致命错误。<code>Exception in thread &#39;dubbo client x.x connector&#39; java.lang.OutOfMemoryError:PermGen space</code>而元空间和永久代之间最大的区别在于：元空间并不在虚拟机中，而是使用本地内存。 因此，默认情况下，元空间的大小仅受本地内存限制。</li><li>对永久代进行调优是很困难的。方法区的垃圾收集主要回收两部分内容：常量池中废弃的常量和不再用的类型，方法区的调优主要是为了降低<strong>Full GC</strong><ul><li>有些人认为方法区（如HotSpot虚拟机中的元空间或者永久代）是没有垃圾收集行为的，其实不然。《Java虚拟机规范》对方法区的约束是非常宽松的，提到过可以不要求虚拟机在方法区中实现垃圾收集。事实上也确实有未实现或未能完整实现方法区类型卸载的收集器存在（如JDK11时期的ZGC收集器就不支持类卸载）。</li><li>一般来说这个区域的回收效果比较难令人满意，尤其是类型的卸载，条件相当苛刻。但是这部分区域的回收有时又确实是必要的。以前Sun公司的Bug列表中，曾出现过的若干个严重的Bug就是由于低版本的HotSpot虚拟机对此区域未完全回收而导致内存泄漏。</li></ul></li></ul></li></ul><h2 id="3-字符串常量池"><a href="#3-字符串常量池" class="headerlink" title="3. 字符串常量池"></a>3. 字符串常量池</h2><p><strong>字符串常量池 StringTable 为什么要调整位置？</strong></p><ul><li>JDK7中将StringTable放到了堆空间中。因为永久代的回收效率很低，在Full GC的时候才会执行永久代的垃圾回收，而Full GC是老年代的空间不足、永久代不足时才会触发。</li><li>这就导致StringTable回收效率不高，而我们开发中会有大量的字符串被创建，回收效率低，导致永久代内存不足。放到堆里，能及时回收内存。</li></ul><h2 id="4-静态变量放在哪里"><a href="#4-静态变量放在哪里" class="headerlink" title="4. 静态变量放在哪里"></a>4. 静态变量放在哪里</h2><h3 id="4-1-对象实体在哪里放着？"><a href="#4-1-对象实体在哪里放着？" class="headerlink" title="4.1 对象实体在哪里放着？"></a>4.1 对象实体在哪里放着？</h3><ul><li>结论：静态引用对应的对象实体(也就是这个new byte[1024 * 1024 * 100])始终都存在堆空间,只是那个变量(相当于下面的arr变量名)在JDK6,JDK7,JDK8存放位置中有所变化.</li></ul><pre><code class="highlight java"><span class="comment">/**</span><span class="comment"> * 结论： 静态引用对应的对象实体始终都存在堆空间</span><span class="comment"> *</span><span class="comment"> * jdk7：</span><span class="comment"> * -Xms200m -Xmx200m -XX:PermSize=300m -XX:MaxPermSize=300m -XX:+PrintGCDetails</span><span class="comment"> * jdk 8：</span><span class="comment"> * -Xms200m -Xmx200m -XX:MetaspaceSize=300m -XX:MaxMetaspaceSize=300m -XX:+PrintGCDetails</span><span class="comment"> */</span><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">StaticFieldTest</span> &#123;    <span class="keyword">private</span> <span class="keyword">static</span> <span class="type">byte</span>[] arr = <span class="keyword">new</span> <span class="title class_">byte</span>[<span class="number">1024</span> * <span class="number">1024</span> * <span class="number">100</span>];<span class="comment">//100MB</span>    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;        System.out.println(StaticFieldTest.arr);        <span class="keyword">try</span> &#123;            Thread.sleep(<span class="number">1000000</span>);        &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;            e.printStackTrace();        &#125;    &#125;&#125;</code></pre><h4 id="4-1-1-JDK6环境下"><a href="#4-1-1-JDK6环境下" class="headerlink" title="4.1.1 JDK6环境下"></a>4.1.1 JDK6环境下</h4><p><img src="https://raw.githubusercontent.com/GeorgeChan95/blogimg/master/img/2023/12/20/20231220-125817.png" alt="image-20231220125816542"></p><h4 id="4-1-2-JDK7环境下"><a href="#4-1-2-JDK7环境下" class="headerlink" title="4.1.2 JDK7环境下"></a>4.1.2 JDK7环境下</h4><p><img src="https://raw.githubusercontent.com/GeorgeChan95/blogimg/master/img/2023/12/20/20231220-130104.png" alt="image-20231220130102768"></p><h4 id="4-1-3-JDK8环境下"><a href="#4-1-3-JDK8环境下" class="headerlink" title="4.1.3 JDK8环境下"></a>4.1.3 JDK8环境下</h4><p><img src="https://raw.githubusercontent.com/GeorgeChan95/blogimg/master/img/2023/12/20/20231220-130157.png" alt="image-20231220130156289"></p><h3 id="4-2-变量-名-存放在哪里？"><a href="#4-2-变量-名-存放在哪里？" class="headerlink" title="4.2 变量(名)存放在哪里？"></a>4.2 变量(名)存放在哪里？</h3><p>这个问题需要用JHSDB工具来进行分析，这个工具是JDK9开始自带的(JDK9以前没有)，在bin目录下可以找到。</p><pre><code class="highlight java"><span class="comment">/**</span><span class="comment"> * 《深入理解Java虚拟机》中的案例：</span><span class="comment"> * staticObj、instanceObj、localObj存放在哪里？</span><span class="comment"> */</span><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">StaticObjTest</span> &#123;    <span class="keyword">static</span> <span class="keyword">class</span> <span class="title class_">Test</span> &#123;        <span class="keyword">static</span> <span class="type">ObjectHolder</span> <span class="variable">staticObj</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ObjectHolder</span>();        <span class="type">ObjectHolder</span> <span class="variable">instanceObj</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ObjectHolder</span>();        <span class="keyword">void</span> <span class="title function_">foo</span><span class="params">()</span> &#123;            <span class="type">ObjectHolder</span> <span class="variable">localObj</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ObjectHolder</span>();            System.out.println(<span class="string">&quot;done&quot;</span>);        &#125;    &#125;    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">class</span> <span class="title class_">ObjectHolder</span> &#123;    &#125;    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;        <span class="type">Test</span> <span class="variable">test</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">StaticObjTest</span>.Test();        test.foo();    &#125;&#125;</code></pre><ul><li>staticObj随着Test的类型信息存放在方法区</li><li>instanceObj随着Test的对象实例存放在Java堆</li><li>localObject则是存放在foo()方法栈帧的局部变量表中。</li><li>测试发现：三个对象的数据在内存中的地址都落在Eden区范围内，所以结论：<strong>只要是对象实例必然会在Java堆中分配</strong>。</li></ul><p><img src="https://raw.githubusercontent.com/GeorgeChan95/blogimg/master/img/2023/12/20/20231220-135412.png" alt="image-20231220135411129"></p><p>1、0x00007f32c7800000(Eden区的起始地址) —- 0x00007f32c7b50000(Eden区的终止地址)</p><p>2、可以发现三个变量都在这个范围内</p><p>3、所以可以得到上面结论</p><ul><li><p>接着，找到了一个引用该staticObj对象的地方，是在一个java.lang.Class的实例里，并且给出了这个实例的地址，通过Inspector查看该对象实例，可以清楚看到这确实是一个java.lang.Class类型的对象实例，里面有一个名为staticobj的实例字段：</p><p><img src="https://raw.githubusercontent.com/GeorgeChan95/blogimg/master/img/2023/12/20/20231220-135459.png" alt="image-20231220135458225"></p></li></ul><p>从《Java虚拟机规范》所定义的概念模型来看，所有Class相关的信息都应该存放在方法区之中，但方法区该如何实现，《Java虚拟机规范》并未做出规定，这就成了一件允许不同虚拟机自己灵活把握的事情。JDK7及其以后版本的HotSpot虚拟机选择把静态变量与类型在Java语言一端的映射Class对象存放在一起，<strong>存储于Java堆之中</strong>，从我们的实验中也明确验证了这一点</p><h1 id="七、方法区的垃圾回收"><a href="#七、方法区的垃圾回收" class="headerlink" title="七、方法区的垃圾回收"></a>七、方法区的垃圾回收</h1><ul><li>有些人认为方法区（如Hotspot虚拟机中的元空间或者永久代）是没有垃圾收集行为的，其实不然。《Java虚拟机规范》对方法区的约束是非常宽松的，提到过可以不要求虚拟机在方法区中实现垃圾收集。事实上也确实有未实现或未能完整实现方法区<strong>类型卸载</strong>的收集器存在（如JDK11时期的ZGC收集器就不支持类卸载）。</li><li>一般来说这个区域的回收效果比较难令人满意，尤其是类型的卸载，条件相当苛刻。但是这部分区域的回收有时又确实是必要的。以前sun公司的Bug列表中，曾出现过的若干个严重的Bug就是由于低版本的HotSpot虚拟机对此区域未完全回收而导致内存泄漏。</li><li>方法区的垃圾收集主要回收两部分内容：<strong>常量池中废弃的常量和不再使用的类型</strong>。</li></ul><ol><li>先来说说方法区内常量池之中主要存放的两大类常量：<strong>字面量和符号引用</strong>。字面量比较接近Java语言层次的常量概念，如文本字符串、被声明为final的常量值等。而符号引用则属于编译原理方面的概念，包括下面三类常量：<ol><li>类和接口的全限定名</li><li>字段的名称和描述符</li><li>方法的名称和描述符</li></ol></li><li>HotSpot虚拟机对常量池的回收策略是很明确的，只要常量池中的常量没有被任何地方引用，就可以被回收。</li><li>回收废弃常量与回收Java堆中的对象非常类似。（关于常量的回收比较简单，重点是类的回收）</li></ol><p>下面也称作<strong>类卸载</strong></p><ol><li>判定一个常量是否“废弃”还是相对简单，而要判定一个类型是否属于“不再被使用的类”的条件就比较苛刻了。需要同时满足下面三个条件：<ol><li>该类所有的实例都已经被回收，也就是Java堆中不存在该类及其任何派生子类的实例。</li><li>加载该类的类加载器已经被回收，这个条件除非是经过精心设计的可替换类加载器的场景，如OSGi、JSP的重加载等，否则通常是很难达成的。</li><li>该类对应的java.lang.Class对象没有在任何地方被引用，无法在任何地方通过反射访问该类的方法。</li></ol></li><li>Java虚拟机被允许对满足上述三个条件的无用类进行回收，这里说的仅仅是“被允许”，而并不是和对象一样，没有引用了就必然会回收。关于是否要对类型进行回收，HotSpot虚拟机提供了<code>-Xnoclassgc</code>参数进行控制，还可以使用<code>-verbose:class</code> 以及 <code>-XX：+TraceClass-Loading</code>、<code>-XX：+TraceClassUnLoading</code>查看类加载和卸载信息</li><li>在大量使用反射、动态代理、CGLib等字节码框架，动态生成JSP以及OSGi这类频繁自定义类加载器的场景中，通常都需要Java虚拟机具备类型卸载的能力，以保证不会对方法区造成过大的内存压力。</li></ol><h1 id="八、运行时数据区总结"><a href="#八、运行时数据区总结" class="headerlink" title="八、运行时数据区总结"></a>八、运行时数据区总结</h1><p><img src="https://raw.githubusercontent.com/GeorgeChan95/blogimg/master/img/2023/12/20/20231220-141937.png" alt="运行时数据区"></p><p><img src="https://raw.githubusercontent.com/GeorgeChan95/blogimg/master/img/2023/12/20/20231220-142048.png" alt="image-20231220142047173"></p><h1 id="九、常见面试题"><a href="#九、常见面试题" class="headerlink" title="九、常见面试题"></a>九、常见面试题</h1><ol><li>百度<ul><li>三面：说一下JVM内存模型吧，有哪些区？分别干什么的？</li></ul></li><li>蚂蚁金服：<ul><li>Java8的内存分代改进</li><li>JVM内存分哪几个区，每个区的作用是什么？</li><li>一面：JVM内存分布&#x2F;内存结构？栈和堆的区别？堆的结构？为什么两个survivor区？</li><li>二面：Eden和survior的比例分配</li></ul></li><li>小米：<ul><li>jvm内存分区，为什么要有新生代和老年代</li></ul></li><li>字节跳动：<ul><li>二面：Java的内存分区</li><li>二面：讲讲vm运行时数据库区</li><li>什么时候对象会进入老年代？</li></ul></li><li>京东：<ul><li>JVM的内存结构，Eden和Survivor比例。</li><li>JVM内存为什么要分成新生代，老年代，持久代。新生代中为什么要分为Eden和survivor。</li></ul></li><li>天猫：<ul><li>一面：Jvm内存模型以及分区，需要详细到每个区放什么。</li><li>一面：JVM的内存模型，Java8做了什么改</li></ul></li><li>拼多多：<ul><li>JVM内存分哪几个区，每个区的作用是什么？</li></ul></li><li>美团：<ul><li>java内存分配</li><li>jvm的永久代中会发生垃圾回收吗？</li><li>一面：jvm内存分区，为什么要有新生代和老年代？</li></ul></li></ol>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;环境&quot;&gt;&lt;a href=&quot;#环境&quot; class=&quot;headerlink&quot; title=&quot;环境&quot;&gt;&lt;/a&gt;环境&lt;/h1&gt;&lt;blockquote&gt;
&lt;p&gt;系统 : Windows 10&lt;br&gt;JDK : 1.8&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;&lt;img sr</summary>
      
    
    
    
    <category term="JVM" scheme="https://georgechan95.github.io/categories/JVM/"/>
    
    
    <category term="jvm" scheme="https://georgechan95.github.io/tags/jvm/"/>
    
    <category term="java" scheme="https://georgechan95.github.io/tags/java/"/>
    
  </entry>
  
  <entry>
    <title>第六章-JVM堆</title>
    <link href="https://georgechan95.github.io/2023/12/02/jvm/%E7%AC%AC%E5%85%AD%E7%AB%A0-JVM%E5%A0%86/"/>
    <id>https://georgechan95.github.io/2023/12/02/jvm/%E7%AC%AC%E5%85%AD%E7%AB%A0-JVM%E5%A0%86/</id>
    <published>2023-12-02T00:01:00.000Z</published>
    <updated>2024-06-22T10:36:12.823Z</updated>
    
    <content type="html"><![CDATA[<h1 id="环境"><a href="#环境" class="headerlink" title="环境"></a>环境</h1><blockquote><p>系统 : Windows 10<br>JDK : 1.8</p></blockquote><h1 id="一、堆的核心概述"><a href="#一、堆的核心概述" class="headerlink" title="一、堆的核心概述"></a>一、堆的核心概述</h1><h2 id="1-堆与进程"><a href="#1-堆与进程" class="headerlink" title="1. 堆与进程"></a>1. 堆与进程</h2><ul><li>堆针对一个JVM进程来说是唯一的。也就是一个进程只有一个JVM实例，一个JVM实例中就有一个运行时数据区，一个运行时数据区只有一个堆和一个方法区。</li><li>但是<strong>进程包含多个线程，他们是共享同一堆空间的</strong>。</li></ul><p><img src="https://raw.githubusercontent.com/GeorgeChan95/blogimg/master/img/2023/12/02/20231202-101738" alt="img"></p><ul><li><p>一个JVM实例只存在一个堆内存，堆也是Java内存管理的核心区域。</p></li><li><p>Java堆区在JVM启动的时候即被创建，其空间大小也就确定了，堆是JVM管理的最大一块内存空间，并且堆内存的大小是可以调节的。</p></li><li><p>《Java虚拟机规范》规定，堆可以处于物理上不连续的内存空间中，但在逻辑上它应该被视为连续的。</p></li><li><p>所有的线程共享Java堆，在这里还可以划分线程私有的缓冲区（Thread Local Allocation Buffer，<strong>TLAB</strong>）。</p></li><li><p>《Java虚拟机规范》中对Java堆的描述是：<strong>所有的对象实例以及数组都应当在运行时分配在堆上</strong>。（The heap is the run-time data area from which memory for all class instances and arrays is allocated）</p><ul><li>从实际使用角度看：“几乎”所有的对象实例都在堆分配内存，但并非全部。因为还有一些对象是在栈上分配的（逃逸分析，标量替换）</li></ul></li><li><p>数组和对象可能永远不会存储在栈上（<strong>不一定</strong>），因为栈帧中保存引用，这个引用指向对象或者数组在堆中的位置。</p></li><li><p>在方法结束后，堆中的对象不会马上被移除，仅仅在垃圾收集的时候才会被移除。</p><ul><li>也就是触发了GC的时候，才会进行回收</li><li>如果堆中对象马上被回收，那么用户线程就会收到影响，因为有stop the word</li></ul></li><li><p>堆，是GC（Garbage Collection，垃圾收集器）执行垃圾回收的重点区域。</p></li></ul><pre><code class="highlight java"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">SimpleHeap</span> &#123;    <span class="keyword">private</span> <span class="type">int</span> id;<span class="comment">//属性、成员变量</span>    <span class="keyword">public</span> <span class="title function_">SimpleHeap</span><span class="params">(<span class="type">int</span> id)</span> &#123;        <span class="built_in">this</span>.id = id;    &#125;    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">show</span><span class="params">()</span> &#123;        System.out.println(<span class="string">&quot;My ID is &quot;</span> + id);    &#125;    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;        <span class="type">SimpleHeap</span> <span class="variable">sl</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">SimpleHeap</span>(<span class="number">1</span>);        <span class="type">SimpleHeap</span> <span class="variable">s2</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">SimpleHeap</span>(<span class="number">2</span>);        <span class="type">int</span>[] arr = <span class="keyword">new</span> <span class="title class_">int</span>[<span class="number">10</span>];        Object[] arr1 = <span class="keyword">new</span> <span class="title class_">Object</span>[<span class="number">10</span>];    &#125;&#125;</code></pre><p><img src="https://raw.githubusercontent.com/GeorgeChan95/blogimg/master/img/2023/12/02/20231202-103156.jpg" alt="Java栈、堆、方法区"></p><h2 id="2-堆内存细分"><a href="#2-堆内存细分" class="headerlink" title="2. 堆内存细分"></a>2. 堆内存细分</h2><p>现代垃圾收集器大部分都基于分代收集理论设计，堆空间细分为：</p><ul><li>Java7 及之前堆内存逻辑上分为三部分：新生区+养老区+永久区<ul><li>Young Generation Space 新生区 Young&#x2F;New<ul><li>又被划分为Eden区和Survivor区</li></ul></li><li>Old generation space 养老区 Old&#x2F;Tenure</li><li>Permanent Space 永久区 Perm</li></ul></li><li>Java 8及之后堆内存逻辑上分为三部分：新生区+养老区+元空间<ul><li>Young Generation Space 新生区，又被划分为Eden区和Survivor区</li><li>Old generation space 养老区</li><li>Meta Space 元空间 Meta</li></ul></li></ul><p><strong>约定：新生区 &lt;–&gt; 新生代 &lt;–&gt; 年轻代 、 养老区 &lt;–&gt; 老年区 &lt;–&gt; 老年代、 永久区 &lt;–&gt; 永久代</strong></p><h3 id="2-1-JDK-7-堆内存结构"><a href="#2-1-JDK-7-堆内存结构" class="headerlink" title="2.1 JDK 7 堆内存结构"></a>2.1 JDK 7 堆内存结构</h3><img src="https://raw.githubusercontent.com/GeorgeChan95/blogimg/master/img/2023/12/02/20231202-103929.PNG" alt="Java Heap JDK7" style="zoom: 67%;" /><h3 id="2-2-JDK-8-堆内存结构"><a href="#2-2-JDK-8-堆内存结构" class="headerlink" title="2.2 JDK 8 堆内存结构"></a>2.2 JDK 8 堆内存结构</h3><p><img src="https://raw.githubusercontent.com/GeorgeChan95/blogimg/master/img/2023/12/02/20231202-103801.png" alt="JDK 8 java heap"></p><h1 id="二、JVisualVM可视化查看堆内存"><a href="#二、JVisualVM可视化查看堆内存" class="headerlink" title="二、JVisualVM可视化查看堆内存"></a>二、JVisualVM可视化查看堆内存</h1><h2 id="1-打开-JVisual-VM"><a href="#1-打开-JVisual-VM" class="headerlink" title="1. 打开 JVisual VM"></a>1. 打开 JVisual VM</h2><h3 id="1-1-找到-jvisualvm-exe"><a href="#1-1-找到-jvisualvm-exe" class="headerlink" title="1.1 找到 jvisualvm.exe"></a>1.1 找到 jvisualvm.exe</h3><p>进入 <code>jdk安装目录</code> 下的 <code>bin目录</code> 找到 <code>jvisualvm.exe</code> ，双击打开</p><p><img src="https://raw.githubusercontent.com/GeorgeChan95/blogimg/master/img/2023/12/02/20231202-104816.png" alt="image-20231202104815600"></p><img src="https://raw.githubusercontent.com/GeorgeChan95/blogimg/master/img/2023/12/02/20231202-105310.png" alt="image-20231202104935890" style="zoom:50%;" /><h3 id="1-2-安装插件"><a href="#1-2-安装插件" class="headerlink" title="1.2 安装插件"></a>1.2 安装插件</h3><p>依次点击 <strong>工具</strong> —&gt; <strong>插件</strong> —&gt; <strong>可用插件</strong> —&gt; 选择 <strong>Visual GC</strong> —&gt; 点击 <strong>安装</strong> </p><p><img src="https://raw.githubusercontent.com/GeorgeChan95/blogimg/master/img/2023/12/02/20231202-105511.png" alt="image-20231202105510163"></p><p>安装成功后，再次点击 <strong>工具</strong> —&gt; <strong>插件</strong> —&gt; <strong>已安装</strong>  能够看到 <code>Visual GC</code> 已经被安装好了</p><p><img src="https://raw.githubusercontent.com/GeorgeChan95/blogimg/master/img/2023/12/02/20231202-105859.png" alt="image-20231202105857779"></p><h2 id="2-运行JAVA代码"><a href="#2-运行JAVA代码" class="headerlink" title="2. 运行JAVA代码"></a>2. 运行JAVA代码</h2><pre><code class="highlight java"><span class="comment">/**</span><span class="comment"> * -Xms10m -Xmx10m</span><span class="comment"> */</span><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">HeapDemo</span> &#123;    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;        System.out.println(<span class="string">&quot;start...&quot;</span>);        <span class="keyword">try</span> &#123;            Thread.sleep(<span class="number">1000000</span>);        &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;            e.printStackTrace();        &#125;        System.out.println(<span class="string">&quot;end...&quot;</span>);    &#125;&#125;</code></pre><h2 id="3-查看-JVisual-VM-控制台"><a href="#3-查看-JVisual-VM-控制台" class="headerlink" title="3. 查看 JVisual VM 控制台"></a>3. 查看 JVisual VM 控制台</h2><p>在Java程序运行期间，Jvisual VM 左侧菜单能到到运行中的Java类，右键 <strong>打开</strong> —&gt; 点击 <strong>Visual GC</strong> ，可以查看到实时堆内存的变化。</p><img src="https://raw.githubusercontent.com/GeorgeChan95/blogimg/master/img/2023/12/01/20231201-101723.png" alt="image-20231201101722494" style="zoom:50%;" /><h1 id="三、设置堆内存大小与-OOM"><a href="#三、设置堆内存大小与-OOM" class="headerlink" title="三、设置堆内存大小与 OOM"></a>三、设置堆内存大小与 OOM</h1><h2 id="1-设置堆内存"><a href="#1-设置堆内存" class="headerlink" title="1. 设置堆内存"></a>1. 设置堆内存</h2><ul><li>Java堆区用于存储Java对象实例，那么堆的大小在JVM启动时就已经设定好了，可以通过选项”-Xms”和”-Xmx”来进行设置。<ul><li><code>-Xms</code> 用于表示堆区的起始内存，等价于 <code>-XX:InitialHeapSize</code></li><li><code>-Xmx</code> 则用于表示堆区的最大内存，等价于 <code>-XX:MaxHeapSize</code></li></ul></li><li>一旦堆区中的内存大小超过“-Xmx”所指定的最大内存时，将会抛出OutofMemoryError异常。</li><li><strong>通常会将 -Xms 和 -Xmx 两个参数配置相同的值</strong><ul><li>原因：假设两个不一样，初始内存小，最大内存大。在运行期间如果堆内存不够用了，会一直扩容直到最大内存。如果内存够用且多了，也会不断的缩容释放。频繁的扩容和释放造成不必要的压力。将 -Xms 和 -Xmx 设置成相同的值，可以避免在GC之后调整堆内存给服务器带来压力。内存不够了就直接报OOM</li></ul></li><li>默认情况下:<ul><li>初始内存大小：物理电脑内存大小的 1&#x2F;64</li><li>最大内存大小：物理电脑内存大小的 1&#x2F;4</li></ul></li></ul><blockquote><p>代码示例</p></blockquote><pre><code class="highlight java"><span class="comment">/**</span><span class="comment"> * 1. 设置堆空间大小的参数</span><span class="comment"> * -Xms 用来设置堆空间（年轻代+老年代）的初始内存大小</span><span class="comment"> *      -X 是jvm的运行参数</span><span class="comment"> *      ms 是memory start</span><span class="comment"> * -Xmx 用来设置堆空间（年轻代+老年代）的最大内存大小</span><span class="comment"> *</span><span class="comment"> * 2. 默认堆空间的大小</span><span class="comment"> *    初始内存大小：物理电脑内存大小的 1 / 64</span><span class="comment"> *             最大内存大小：物理电脑内存大小的 1 / 4</span><span class="comment"> * 3. 手动设置：-Xms600m -Xmx600m</span><span class="comment"> *     开发中建议将初始堆内存和最大的堆内存设置成相同的值。</span><span class="comment"> *</span><span class="comment"> * 4. 查看设置的参数：方式一： jps   /  jstat -gc 进程id</span><span class="comment"> *                  方式二：-XX:+PrintGCDetails</span><span class="comment"> */</span><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">HeapSpaceInitial</span> &#123;    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;        <span class="comment">//返回Java虚拟机中的堆内存总量</span>        <span class="type">long</span> <span class="variable">initialMemory</span> <span class="operator">=</span> Runtime.getRuntime().totalMemory() / <span class="number">1024</span> / <span class="number">1024</span>;        <span class="comment">//返回Java虚拟机试图使用的最大堆内存量</span>        <span class="type">long</span> <span class="variable">maxMemory</span> <span class="operator">=</span> Runtime.getRuntime().maxMemory() / <span class="number">1024</span> / <span class="number">1024</span>;        System.out.println(<span class="string">&quot;-Xms : &quot;</span> + initialMemory + <span class="string">&quot;M&quot;</span>);        System.out.println(<span class="string">&quot;-Xmx : &quot;</span> + maxMemory + <span class="string">&quot;M&quot;</span>);        System.out.println(<span class="string">&quot;系统内存大小为：&quot;</span> + initialMemory * <span class="number">64.0</span> / <span class="number">1024</span> + <span class="string">&quot;G&quot;</span>);        System.out.println(<span class="string">&quot;系统内存大小为：&quot;</span> + maxMemory * <span class="number">4.0</span> / <span class="number">1024</span> + <span class="string">&quot;G&quot;</span>);        <span class="keyword">try</span> &#123;            Thread.sleep(<span class="number">1000000</span>);        &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;            e.printStackTrace();        &#125;    &#125;&#125;</code></pre><blockquote><p>运行后输出结果为：</p></blockquote><pre><code class="highlight plaintext">-Xms : 489M-Xmx : 7252M系统内存大小为：30.5625G系统内存大小为：28.328125G</code></pre><h3 id="1-1-手动设置堆内存"><a href="#1-1-手动设置堆内存" class="headerlink" title="1.1 手动设置堆内存"></a>1.1 手动设置堆内存</h3><p>在IDEA中添加 <code>VM Option</code> 参数，手动设置堆内存的大小。</p><ul><li>参数为：-Xms600m -Xmx600m<ul><li>限制最大堆内存为600M</li></ul></li></ul><img src="https://raw.githubusercontent.com/GeorgeChan95/blogimg/master/img/2023/12/02/20231202-111909.png" alt="image-20231202111908345" style="zoom: 80%;" /><p>重新运行程序，打印如下：</p><pre><code class="highlight plaintext">-Xms : 575M-Xmx : 575M</code></pre><p><strong>发现堆内存比设置的大小少了 25M</strong></p><h3 id="1-2-查看堆内存分配明细"><a href="#1-2-查看堆内存分配明细" class="headerlink" title="1.2 查看堆内存分配明细"></a>1.2 查看堆内存分配明细</h3><h4 id="1-2-1-方式一：通过命令行查看"><a href="#1-2-1-方式一：通过命令行查看" class="headerlink" title="1.2.1 方式一：通过命令行查看"></a>1.2.1 方式一：通过命令行查看</h4><p>打开CMD控制台，执行如下命令：</p><ol><li>jps<ol><li>查看运行中的Java进程</li></ol></li><li>jps -gc 进程id <ol><li>或者 jstat -gc 进程ID</li><li>打印堆内存分配细节</li></ol></li></ol><p><img src="https://raw.githubusercontent.com/GeorgeChan95/blogimg/master/img/2023/12/02/20231202-112847.png" alt="image-20231202112845712"></p><p><strong>打印列解析：</strong></p><ul><li>SOC: S0区总共容量</li><li>S1C: S1区总共容量</li><li>S0U: S0区使用的量</li><li>S1U: S1区使用的量</li><li>EC: 伊甸园区总共容量</li><li>EU: 伊甸园区使用的量</li><li>OC: 老年代总共容量</li><li>OU: 老年代使用的量</li></ul><p>从上面的打印结果可以发现：</p><ul><li>S0区总共容量(25600) + S1区总共容量(25600) + 伊甸园区总共容量(153600) + 老年代总共容量(409600) &#x3D; 600M</li><li>S0区总共容量(25600)  + 伊甸园区总共容量(153600) + 老年代总共容量(409600) &#x3D; 575M</li><li>S0区总共容量 与 S1区总共容量 相等</li></ul><p>这里可以回答上面的问题，为什么堆内存设置了 600M， 而程序获取到堆内存的大小只有 575M，这是因为 <strong>在同一时刻 S0区 和 S1区 只能有一个被使用</strong>。</p><h4 id="1-2-2-方式二：IDEA设置GC打印参数"><a href="#1-2-2-方式二：IDEA设置GC打印参数" class="headerlink" title="1.2.2 方式二：IDEA设置GC打印参数"></a>1.2.2 方式二：IDEA设置GC打印参数</h4><p>VM Option 添加参数 ：<code>-XX:+PrintGCDetails</code></p><p> <img src="https://raw.githubusercontent.com/GeorgeChan95/blogimg/master/img/2023/12/02/20231202-133245.png" alt="image-20231202133243698"></p><p>重新运行程序，打印结果如下：</p><pre><code class="highlight plaintext">-Xms : 575M-Xmx : 575MHeap PSYoungGen      total 179200K, used 18432K [0x00000000f3800000, 0x0000000100000000, 0x0000000100000000)  eden space 153600K, 12% used [0x00000000f3800000,0x00000000f4a00088,0x00000000fce00000)  from space 25600K, 0% used [0x00000000fe700000,0x00000000fe700000,0x0000000100000000)  to   space 25600K, 0% used [0x00000000fce00000,0x00000000fce00000,0x00000000fe700000) ParOldGen       total 409600K, used 0K [0x00000000da800000, 0x00000000f3800000, 0x00000000f3800000)  object space 409600K, 0% used [0x00000000da800000,0x00000000da800000,0x00000000f3800000) Metaspace       used 3741K, capacity 4536K, committed 4864K, reserved 1056768K  class space    used 411K, capacity 428K, committed 512K, reserved 1048576K</code></pre><h5 id="注意点："><a href="#注意点：" class="headerlink" title="注意点："></a>注意点：</h5><ul><li>年轻代的 <strong>from区</strong> 和 <strong>to区</strong> 对应的就是上面的 <strong>S0区</strong> 和 <strong>S1区</strong> </li><li>在同一时刻 <strong>S0区</strong> 和 <strong>S1区</strong> 只能有一个有数据，另一个是空的。</li><li>对应到 <strong>from区</strong> 和 <strong>to区</strong> 就是：谁空谁是 <strong>to区</strong></li></ul><h2 id="2-OOM"><a href="#2-OOM" class="headerlink" title="2. OOM"></a>2. OOM</h2><blockquote><p>代码</p></blockquote><pre><code class="highlight java"><span class="comment">/**</span><span class="comment"> * -Xms600m -Xmx600m -XX:+PrintGCDetails</span><span class="comment"> */</span><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">OOMTest</span> &#123;    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;        ArrayList&lt;Picture&gt; list = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();        <span class="keyword">while</span>(<span class="literal">true</span>)&#123;            <span class="keyword">try</span> &#123;                Thread.sleep(<span class="number">20</span>);            &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;                e.printStackTrace();            &#125;            list.add(<span class="keyword">new</span> <span class="title class_">Picture</span>(<span class="keyword">new</span> <span class="title class_">Random</span>().nextInt(<span class="number">1024</span> * <span class="number">1024</span>)));        &#125;    &#125;&#125;<span class="keyword">class</span> <span class="title class_">Picture</span>&#123;    <span class="keyword">private</span> <span class="type">byte</span>[] pixels;    <span class="keyword">public</span> <span class="title function_">Picture</span><span class="params">(<span class="type">int</span> length)</span> &#123;        <span class="built_in">this</span>.pixels = <span class="keyword">new</span> <span class="title class_">byte</span>[length];    &#125;&#125;</code></pre><blockquote><p>设置VM Option</p></blockquote><pre><code class="highlight plaintext">-Xms600m -Xmx600m -XX:+PrintGCDetails</code></pre><blockquote><p>执行程序，输出结果：</p></blockquote><pre><code class="highlight plaintext">[GC (Allocation Failure) [PSYoungGen: 153576K-&gt;25599K(179200K)] 153576K-&gt;119556K(588800K), 0.0186055 secs] [Times: user=0.00 sys=0.05, real=0.02 secs] [GC (Allocation Failure) [PSYoungGen: 179038K-&gt;25581K(179200K)] 272995K-&gt;266691K(588800K), 0.0278531 secs] [Times: user=0.00 sys=0.13, real=0.03 secs] [GC (Allocation Failure) [PSYoungGen: 178887K-&gt;25584K(179200K)] 419997K-&gt;415662K(588800K), 0.0242654 secs] [Times: user=0.00 sys=0.06, real=0.02 secs] [Full GC (Ergonomics) [PSYoungGen: 25584K-&gt;6102K(179200K)] [ParOldGen: 390078K-&gt;409463K(409600K)] 415662K-&gt;415565K(588800K), [Metaspace: 9527K-&gt;9527K(1058816K)], 0.0562392 secs] [Times: user=0.11 sys=0.00, real=0.06 secs] [Full GC (Ergonomics) [PSYoungGen: 159683K-&gt;156764K(179200K)] [ParOldGen: 409463K-&gt;409459K(409600K)] 569146K-&gt;566224K(588800K), [Metaspace: 9557K-&gt;9557K(1058816K)], 0.0217029 secs] [Times: user=0.08 sys=0.00, real=0.02 secs] [Full GC (Ergonomics) [PSYoungGen: 157057K-&gt;156927K(179200K)] [ParOldGen: 409459K-&gt;409459K(409600K)] 566517K-&gt;566387K(588800K), [Metaspace: 9557K-&gt;9557K(1058816K)], 0.0070024 secs] [Times: user=0.06 sys=0.00, real=0.01 secs] [Full GC (Allocation Failure) [PSYoungGen: 156927K-&gt;156927K(179200K)] [ParOldGen: 409459K-&gt;409091K(409600K)] 566387K-&gt;566018K(588800K), [Metaspace: 9557K-&gt;9413K(1058816K)], 0.0254829 secs] [Times: user=0.06 sys=0.00, real=0.02 secs] Heap PSYoungGen      total 179200K, used 157057K [0x00000000f3800000, 0x0000000100000000, 0x0000000100000000)  eden space 153600K, 100% used [0x00000000f3800000,0x00000000fce00000,0x00000000fce00000)  from space 25600K, 13% used [0x00000000fce00000,0x00000000fd1605f8,0x00000000fe700000)  to   space 25600K, 0% used [0x00000000fe700000,0x00000000fe700000,0x0000000100000000) ParOldGen       total 409600K, used 409099K [0x00000000da800000, 0x00000000f3800000, 0x00000000f3800000)  object space 409600K, 99% used [0x00000000da800000,0x00000000f3782cb8,0x00000000f3800000) Metaspace       used 9433K, capacity 9706K, committed 10240K, reserved 1058816K  class space    used 1074K, capacity 1151K, committed 1280K, reserved 1048576KException in thread &quot;main&quot; java.lang.OutOfMemoryError: Java heap spaceat com.atguigu.java.Picture.&lt;init&gt;(OOMTest.java:27)at com.atguigu.java.OOMTest.main(OOMTest.java:18)</code></pre><blockquote><p>查看堆内存的变化图</p></blockquote><img src="https://raw.githubusercontent.com/GeorgeChan95/blogimg/master/img/2023/12/02/20231202-135826.png" alt="image-20231202135825218" style="zoom:50%;" /><blockquote><p>原因：大对象导致堆内存溢出</p></blockquote><img src="https://raw.githubusercontent.com/GeorgeChan95/blogimg/master/img/2023/12/02/20231202-135904.png" alt="image-20231202135902953" style="zoom:50%;" /><h1 id="四、年轻代与老年代"><a href="#四、年轻代与老年代" class="headerlink" title="四、年轻代与老年代"></a>四、年轻代与老年代</h1><h2 id="1-概念"><a href="#1-概念" class="headerlink" title="1. 概念"></a>1. 概念</h2><ul><li>存储在JVM中的Java对象可以被划分为两类：<ul><li>一类是生命周期较短的瞬时对象，这类对象的创建和消亡都非常迅速</li><li>另外一类对象的生命周期却非常长，在某些极端的情况下还能够与JVM的生命周期保持一致</li></ul></li><li>Java堆区进一步细分的话，可以划分为年轻代（YoungGen）和老年代（oldGen）</li><li>其中年轻代又可以划分为Eden空间、Survivor0空间和Survivor1空间（有时也叫做from区、to区）</li></ul><img src="https://raw.githubusercontent.com/GeorgeChan95/blogimg/master/img/2023/12/02/20231202-140338.png" alt="img" style="zoom:50%;" /><h2 id="2-配置新生代与老年代在堆结构的占比"><a href="#2-配置新生代与老年代在堆结构的占比" class="headerlink" title="2. 配置新生代与老年代在堆结构的占比"></a>2. 配置新生代与老年代在堆结构的占比</h2><ul><li>默认 <code>-XX:NewRatio=2</code> ，表示新生代占1，老年代占2，新生代占整个堆的1&#x2F;3</li><li>可以修改 <code>-XX:NewRatio=4</code> ，表示新生代占1，老年代占4，新生代占整个堆的1&#x2F;5</li><li>在HotSpot中，Eden空间和另外两个survivor空间缺省所占的比例是8 : 1 : 1</li><li>开发人员可以通过选项 <code>-XX:SurvivorRatio</code> 调整这个空间比例。比如 <code>-XX:SurvivorRatio=8</code></li></ul><p><strong>其它</strong></p><ul><li>几乎所有的Java对象都是在Eden区被new出来的。</li><li>绝大部分的Java对象的销毁都在新生代进行了（有些大的对象在Eden区无法存储时候，将直接进入老年代），IBM公司的专门研究表明，新生代中80%的对象都是“朝生夕死”的。</li><li>可以使用选项 <strong><code>-Xmn</code></strong> 设置新生代最大内存大小，但这个参数一般使用默认值就可以了。</li></ul><p><img src="https://raw.githubusercontent.com/GeorgeChan95/blogimg/master/img/2023/12/02/20231202-141108.png" alt="堆"></p><h3 id="2-1-示例"><a href="#2-1-示例" class="headerlink" title="2.1 示例"></a>2.1 示例</h3><blockquote><p>代码</p></blockquote><pre><code class="highlight plaintext">/** * -Xms1000m -Xmx1000m * * -XX:NewRatio ： 设置新生代与老年代的比例。默认值是2. * -XX:SurvivorRatio ：设置新生代中Eden区与Survivor区的比例。默认值是8 * -XX:-UseAdaptiveSizePolicy ：关闭自适应的内存分配策略  （暂时用不到） * -Xmn:设置新生代的空间的大小。 （一般不设置） * * @author shkstart  shkstart@126.com * @create 2020  17:23 */public class EdenSurvivorTest &#123;    public static void main(String[] args) &#123;        System.out.println(&quot;我只是来打个酱油~&quot;);        try &#123;            Thread.sleep(1000000);        &#125; catch (InterruptedException e) &#123;            e.printStackTrace();        &#125;    &#125;&#125;</code></pre><blockquote><p>设置JVM参数</p></blockquote><pre><code class="highlight plaintext">-Xms1000m -Xmx1000m -XX:SurvivorRatio=5 -XX:NewRatio=4</code></pre><blockquote><p>查看JVM 内存分配效果</p></blockquote><p><img src="https://raw.githubusercontent.com/GeorgeChan95/blogimg/master/img/2023/12/02/20231202-141505.png" alt="image-20231202141504405"></p><h1 id="五、对象分配过程"><a href="#五、对象分配过程" class="headerlink" title="五、对象分配过程"></a>五、对象分配过程</h1><p>为新对象分配内存是一件非常严谨和复杂的任务，JVM的设计者们不仅需要考虑内存如何分配、在哪里分配等问题，并且由于内存分配算法与内存回收算法密切相关，所以还需要考虑GC执行完内存回收后是否会在内存空间中产生内存碎片。</p><h2 id="1-具体过程"><a href="#1-具体过程" class="headerlink" title="1. 具体过程"></a>1. 具体过程</h2><ul><li>new的对象先放伊甸园区。此区有大小限制。</li><li>当伊甸园的空间填满时，程序又需要创建对象，JVM的垃圾回收器将对伊甸园区进行垃圾回收（MinorGC），将伊甸园区中的不再被其他对象所引用的对象进行销毁。再加载新的对象放到伊甸园区。</li><li>然后将伊甸园中的剩余对象移动到幸存者0区，且对象的年龄计数器设置为1。</li><li>如果再次触发垃圾回收，此时上次幸存下来的放到幸存者0区的，如果本次也没有回收，就会放到幸存者1区，对象的年龄计数器加1。</li><li>如果再次经历垃圾回收，此时会重新放回幸存者0区，接着再去幸存者1区。</li><li>什么时候能去养老区呢？可以将对象的年龄计数器设置阈值，默认是15次。可以设置新生区进入养老区的年龄限制，<ul><li>设置 JVM 参数：<code>-XX:MaxTenuringThreshold=N</code> 进行设置</li></ul></li><li>在养老区，相对悠闲。当养老区内存不足时，再次触发GC：Major GC，进行养老区的内存清理</li><li>若养老区执行了Major GC之后，发现依然无法进行对象的保存，就会产生OOM异常。</li></ul><h2 id="2-图解对象分配（一般情况）"><a href="#2-图解对象分配（一般情况）" class="headerlink" title="2. 图解对象分配（一般情况）"></a>2. 图解对象分配（一般情况）</h2><p><img src="https://raw.githubusercontent.com/GeorgeChan95/blogimg/master/img/2023/12/02/20231202-152830.png" alt="堆对象分配"></p><ul><li>我们创建的对象，一般都是存放在Eden区的，<strong>当我们Eden区满了后，就会触发GC操作</strong>，一般被称为 YGC &#x2F; Minor GC操作</li><li>当进行一次垃圾收集后，红色的对象将会被回收，而绿色的独享还被占用着，存放在S0(Survivor From)区。同时我们给每个对象设置了一个年龄计数器，经过一次回收后还存在的对象，将其年龄加 1。</li><li>同时Eden区继续存放对象，当Eden区再次存满的时候，又会触发一个MinorGC操作，此时GC将会把 Eden和Survivor From中的对象进行一次垃圾收集，把存活的对象放到 Survivor To（S1）区，同时让存活的对象年龄 + 1<ul><li>下一次再进行GC的时候<ul><li>这一次的s0区为空，所以成为下一次GC的S1区</li><li>这一次的s1区则成为下一次GC的S0区</li><li>也就是说s0区和s1区在互相转换。</li></ul></li></ul></li><li>我们继续不断的进行对象生成和垃圾回收，当Survivor中的对象的年龄达到15的时候，将会触发一次 Promotion 晋升的操作，也就是将年轻代中的对象晋升到老年代中</li></ul><p><strong>关于垃圾回收：频繁在新生区收集，很少在养老区收集，几乎不在永久区&#x2F;元空间收集。</strong></p><h2 id="3-对象分配的特殊情况"><a href="#3-对象分配的特殊情况" class="headerlink" title="3. 对象分配的特殊情况"></a>3. 对象分配的特殊情况</h2><ul><li>如果来了一个新对象，先看看 Eden 是否放的下？<ul><li>如果 Eden 放得下，则直接放到 Eden 区</li><li>如果 Eden 放不下，则触发 YGC ，执行垃圾回收，看看还能不能放下？</li></ul></li><li>将对象放到老年区又有两种情况：<ul><li>如果 Eden 执行了 YGC 还是无法放不下该对象，那没得办法，只能说明是超大对象，只能直接放到老年代</li><li>那万一老年代都放不下，则先触发FullGC ，再看看能不能放下，放得下最好，但如果还是放不下，那只能报 OOM</li></ul></li><li>如果 Eden 区满了，将对象往幸存区拷贝时，发现幸存区放不下啦，那只能便宜了某些新对象，让他们直接晋升至老年区</li></ul><p><img src="https://raw.githubusercontent.com/GeorgeChan95/blogimg/master/img/2023/12/02/20231202-155735.png" alt="堆特殊情况"></p><h2 id="4-常用调优工具"><a href="#4-常用调优工具" class="headerlink" title="4. 常用调优工具"></a>4. 常用调优工具</h2><ul><li>JDK命令行</li><li>Eclipse：Memory Analyzer Tool</li><li>Jconsole</li><li>Visual VM（实时监控，推荐）</li><li>Jprofiler（IDEA插件）</li><li>Java Flight Recorder（实时监控）</li><li>GCViewer</li><li>GCEasy</li></ul><h1 id="六、GC分类"><a href="#六、GC分类" class="headerlink" title="六、GC分类"></a>六、GC分类</h1><ul><li><p>我们都知道，JVM的调优的一个环节，也就是垃圾收集，我们需要尽量的避免垃圾回收，因为在垃圾回收的过程中，容易出现STW（Stop the World）的问题，<strong>而 Major GC 和 Full GC出现STW的时间，是Minor GC的10倍以上</strong></p></li><li><p>JVM在进行GC时，并非每次都对上面三个内存区域一起回收的，大部分时候回收的都是指新生代。针对Hotspot VM的实现，它里面的GC按照回收区域又分为两大种类型：一种是部分收集（Partial GC），一种是整堆收集（FullGC）</p></li><li><p>部分收集：不是完整收集整个Java堆的垃圾收集。其中又分为：</p><ul><li><strong>新生代收集</strong>（Minor GC&#x2F;Young GC）：只是新生代（Eden，s0，s1）的垃圾收集</li><li><strong>老年代收集</strong>（Major GC&#x2F;Old GC）：只是老年代的圾收集。</li><li>目前，只有CMS GC会有单独收集老年代的行为。</li><li>注意，很多时候Major GC会和Full GC混淆使用，需要具体分辨是老年代回收还是整堆回收。</li><li>混合收集（Mixed GC）：收集整个新生代以及部分老年代的垃圾收集。目前，只有G1 GC会有这种行为</li></ul></li><li><p><strong>整堆收集</strong>（Full GC）：收集整个java堆和方法区的垃圾收集。</p></li></ul><h2 id="1-Young-GC"><a href="#1-Young-GC" class="headerlink" title="1. Young GC"></a>1. Young GC</h2><p><strong>年轻代 GC（Minor GC）触发机制</strong></p><ul><li>当年轻代空间不足时，就会触发Minor GC，这里的年轻代满指的是Eden区满。Survivor满不会主动引发GC，在Eden区满的时候，会顺带触发s0区的GC，也就是被动触发GC（每次Minor GC会清理年轻代的内存）</li><li>因为Java对象大多都具备朝生夕灭的特性，所以Minor GC非常频繁，一般回收速度也比较快。这一定义既清晰又易于理解。</li><li>Minor GC会引发STW（Stop The World），暂停其它用户的线程，等垃圾回收结束，用户线程才恢复运行</li></ul><p><img src="https://raw.githubusercontent.com/GeorgeChan95/blogimg/master/img/2023/12/02/20231202-160908.png" alt="image-20231202160907126"></p><h2 id="2-Major-Full-GC"><a href="#2-Major-Full-GC" class="headerlink" title="2. Major&#x2F;Full GC"></a>2. Major&#x2F;Full GC</h2><blockquote><p>Full GC有争议，后续详解两者区别，暂时先看着</p></blockquote><p><strong>老年代GC（MajorGC）触发机制</strong></p><ul><li>指发生在老年代的GC，对象从老年代消失时，我们说 “Major Gc” 或 “Full GC” 发生了</li><li>出现了MajorGc，经常会伴随至少一次的Minor GC。（但非绝对的，在Parallel Scavenge收集器的收集策略里就有直接进行MajorGC的策略选择过程）<ul><li>也就是在老年代空间不足时，会先尝试触发Minor GC（哈？我有点迷？），如果之后空间还不足，则触发Major GC</li></ul></li><li>Major GC的速度一般会比Minor GC慢10倍以上，STW的时间更长。</li><li>如果Major GC后，内存还不足，就报OOM了</li></ul><p><strong>Full GC 触发机制（后面细讲）</strong></p><p><strong>触发Full GC执行的情况有如下五种：</strong></p><ul><li>调用System.gc()时，系统建议执行FullGC，但是不必然执行</li><li>老年代空间不足</li><li>方法区空间不足</li><li>通过Minor GC后进入老年代的平均大小大于老年代的可用内存</li><li>由Eden区、survivor space0（From Space）区向survivor space1（To Space）区复制时，对象大小大于To Space可用内存，则把该对象转存到老年代，且老年代的可用内存小于该对象大小</li></ul><p>说明：Full GC 是开发或调优中尽量要避免的。这样STW时间会短一些</p><h2 id="3-GC日志分析"><a href="#3-GC日志分析" class="headerlink" title="3. GC日志分析"></a>3. GC日志分析</h2><blockquote><p>JAVA代码</p></blockquote><pre><code class="highlight java"><span class="comment">/**</span><span class="comment"> * 测试MinorGC 、 MajorGC、FullGC</span><span class="comment"> * -Xms9m -Xmx9m -XX:+PrintGCDetails</span><span class="comment"> */</span><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">GCTest</span> &#123;    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;        <span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>;        <span class="keyword">try</span> &#123;            List&lt;String&gt; list = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();            <span class="type">String</span> <span class="variable">a</span> <span class="operator">=</span> <span class="string">&quot;atguigu.com&quot;</span>;            <span class="keyword">while</span> (<span class="literal">true</span>) &#123;                list.add(a);                a = a + a;                i++;            &#125;        &#125; <span class="keyword">catch</span> (Throwable t) &#123;            t.printStackTrace();            System.out.println(<span class="string">&quot;遍历次数为：&quot;</span> + i);        &#125;    &#125;&#125;</code></pre><blockquote><p>设置JVM参数</p></blockquote><pre><code class="highlight plaintext">-Xms9m -Xmx9m -XX:+PrintGCDetails</code></pre><blockquote><p>日志输出：</p></blockquote><pre><code class="highlight plaintext">[GC (Allocation Failure) [PSYoungGen: 2036K-&gt;504K(2560K)] 2036K-&gt;704K(9728K), 0.0013253 secs] [Times: user=0.00 sys=0.00, real=0.00 secs] [GC (Allocation Failure) [PSYoungGen: 2215K-&gt;504K(2560K)] 2415K-&gt;1416K(9728K), 0.0010343 secs] [Times: user=0.00 sys=0.00, real=0.00 secs] [GC (Allocation Failure) [PSYoungGen: 2304K-&gt;494K(2560K)] 3216K-&gt;2110K(9728K), 0.0005839 secs] [Times: user=0.00 sys=0.00, real=0.00 secs] [GC (Allocation Failure) [PSYoungGen: 1238K-&gt;504K(2560K)] 7078K-&gt;6352K(9728K), 0.0004856 secs] [Times: user=0.03 sys=0.00, real=0.00 secs] [GC (Allocation Failure) [PSYoungGen: 504K-&gt;494K(2560K)] 6352K-&gt;6350K(9728K), 0.0004201 secs] [Times: user=0.00 sys=0.00, real=0.00 secs] [Full GC (Allocation Failure) [PSYoungGen: 494K-&gt;0K(2560K)] [ParOldGen: 5856K-&gt;4875K(7168K)] 6350K-&gt;4875K(9728K), [Metaspace: 3033K-&gt;3033K(1056768K)], 0.0032009 secs] [Times: user=0.00 sys=0.00, real=0.00 secs] [GC (Allocation Failure) [PSYoungGen: 0K-&gt;0K(1536K)] 4875K-&gt;4875K(8704K), 0.0002574 secs] [Times: user=0.00 sys=0.00, real=0.00 secs] [Full GC (Allocation Failure) [PSYoungGen: 0K-&gt;0K(1536K)] [ParOldGen: 4875K-&gt;4838K(7168K)] 4875K-&gt;4838K(8704K), [Metaspace: 3033K-&gt;3033K(1056768K)], 0.0046409 secs] [Times: user=0.00 sys=0.00, real=0.00 secs] 遍历次数为：16Heap PSYoungGen      total 1536K, used 61K [0x00000000ffd00000, 0x0000000100000000, 0x0000000100000000)  eden space 1024K, 6% used [0x00000000ffd00000,0x00000000ffd0f5f0,0x00000000ffe00000)  from space 512K, 0% used [0x00000000fff80000,0x00000000fff80000,0x0000000100000000)  to   space 1024K, 0% used [0x00000000ffe00000,0x00000000ffe00000,0x00000000fff00000) ParOldGen       total 7168K, used 4838K [0x00000000ff600000, 0x00000000ffd00000, 0x00000000ffd00000)  object space 7168K, 67% used [0x00000000ff600000,0x00000000ffab9940,0x00000000ffd00000) Metaspace       used 3050K, capacity 4486K, committed 4864K, reserved 1056768K  class space    used 324K, capacity 386K, committed 512K, reserved 1048576Kjava.lang.OutOfMemoryError: Java heap spaceat java.util.Arrays.copyOf(Arrays.java:3332)at java.lang.AbstractStringBuilder.ensureCapacityInternal(AbstractStringBuilder.java:124)at java.lang.AbstractStringBuilder.append(AbstractStringBuilder.java:448)at java.lang.StringBuilder.append(StringBuilder.java:136)at com.atguigu.java1.GCTest.main(GCTest.java:18)</code></pre><blockquote><p>解读：[PSYoungGen: 2036K-&gt;504K(2560K)] 2036K-&gt;704K(9728K), 0.0013253 secs]</p></blockquote><ul><li>[PSYoungGen: 2036K-&gt;504K(2560K)]：年轻代总空间为 2560K ，当前占用 2036K ，经过垃圾回收后剩余504K</li><li>2036K-&gt;704K(9728K)：堆内存总空间为 9728K ，当前占用2036K ，经过垃圾回收后剩余704K</li></ul><h1 id="七、堆空间分代思想"><a href="#七、堆空间分代思想" class="headerlink" title="七、堆空间分代思想"></a>七、堆空间分代思想</h1><p>为什么要把Java堆分代？不分代就不能正常工作了吗？经研究，不同对象的生命周期不同。70%-99%的对象是临时对象。</p><ul><li>新生代：有Eden、两块大小相同的survivor（又称为from&#x2F;to或s0&#x2F;s1）构成，to总为空。</li><li>老年代：存放新生代中经历多次GC仍然存活的对象。</li></ul><p><img src="https://raw.githubusercontent.com/GeorgeChan95/blogimg/master/img/2023/12/02/20231202-165656.png" alt="堆"></p><p>其实不分代完全可以，分代的唯一理由就是优化GC性能。</p><ul><li>如果没有分代，那所有的对象都在一块，就如同把一个学校的人都关在一个教室。GC的时候要找到哪些对象没用，这样就会对堆的所有区域进行扫描。（性能低）</li><li>而很多对象都是朝生夕死的，如果分代的话，把新创建的对象放到某一地方，当GC的时候先把这块存储“朝生夕死”对象的区域进行回收，这样就会腾出很大的空间出来。（多回收新生代，少回收老年代，性能会提高很多）</li></ul><h1 id="八、对象内存分配策略"><a href="#八、对象内存分配策略" class="headerlink" title="八、对象内存分配策略"></a>八、对象内存分配策略</h1><ul><li>如果对象在Eden出生并经过第一次Minor GC后仍然存活，并且能被Survivor容纳的话，将被移动到Survivor空间中，并将对象年龄设为1。</li><li>对象在Survivor区中每熬过一次 MinorGC，年龄就增加1岁，当它的年龄增加到一定程度（默认为15岁，其实每个JVM、每个GC都有所不同）时，就会被晋升到老年代</li><li>对象晋升老年代的年龄阀值，可以通过选项 <code>-XX:MaxTenuringThreshold</code> 来设置</li></ul><p><strong>针对不同年龄段的对象分配原则如下所示：</strong></p><ul><li><strong>优先分配到Eden</strong>：开发中比较长的字符串或者数组，会直接存在老年代，但是因为新创建的对象都是朝生夕死的，所以这个大对象可能也很快被回收，但是因为老年代触发Major GC的次数比 Minor GC要更少，因此可能回收起来就会比较慢</li><li><strong>大对象直接分配到老年代</strong>：尽量避免程序中出现过多的大对象</li><li><strong>长期存活的对象分配到老年代</strong></li><li><strong>动态对象年龄判断</strong>：如果Survivor区中相同年龄的所有对象大小的总和大于Survivor空间的一半，年龄大于或等于该年龄的对象可以直接进入老年代，无须等到MaxTenuringThreshold中要求的年龄。</li><li><strong>空间分配担保</strong>： -XX:HandlePromotionFailure 。</li></ul><blockquote><p>一些细节放在后面说</p></blockquote><h1 id="九、TLAB为对象分配内存（保证线程安全）"><a href="#九、TLAB为对象分配内存（保证线程安全）" class="headerlink" title="九、TLAB为对象分配内存（保证线程安全）"></a>九、TLAB为对象分配内存（保证线程安全）</h1><h2 id="1-为什么有-TLAB"><a href="#1-为什么有-TLAB" class="headerlink" title="1. 为什么有 TLAB"></a>1. 为什么有 TLAB</h2><ul><li>堆区是线程共享区域，任何线程都可以访问到堆区中的共享数据</li><li>由于对象实例的创建在JVM中非常频繁，因此在并发环境下从堆区中划分内存空间是线程不安全的</li><li>为避免多个线程操作同一地址，需要使用<strong>加锁等机制</strong>，进而影响分配速度。</li></ul><h2 id="2-什么是-TLAB"><a href="#2-什么是-TLAB" class="headerlink" title="2. 什么是 TLAB"></a>2. 什么是 TLAB</h2><p>TLAB（Thread Local Allocation Buffer）</p><ul><li>从内存模型而不是垃圾收集的角度，对Eden区域继续进行划分，<strong>JVM为每个线程分配了一个私有缓存区域，它包含在Eden空间内</strong>。</li><li>多线程同时分配内存时，使用TLAB可以避免一系列的非线程安全问题，同时还能够提升内存分配的吞吐量，因此我们可以将这种内存分配方式称之为<strong>快速分配策略</strong>。</li><li>据我所知所有OpenJDK衍生出来的JVM都提供了TLAB的设计。</li></ul><p><img src="https://raw.githubusercontent.com/GeorgeChan95/blogimg/master/img/2023/12/02/20231202-170752" alt="img"></p><ol><li>每个线程都有一个TLAB空间</li><li>当一个线程的TLAB存满时，可以使用公共区域（蓝色）的</li></ol><h2 id="3-TLAB再说明"><a href="#3-TLAB再说明" class="headerlink" title="3. TLAB再说明"></a>3. TLAB再说明</h2><ul><li>尽管不是所有的对象实例都能够在TLAB中成功分配内存，但<strong>JVM确实是将TLAB作为内存分配的首选</strong>。</li><li>在程序中，开发人员可以通过选项 <code>-XX:UseTLAB</code> 设置是否开启TLAB空间。</li><li>默认情况下，TLAB空间的内存非常小，仅占有整个Eden空间的1%，当然我们可以通过选项 <code>-XX:TLABWasteTargetPercen</code>t 设置TLAB空间所占用Eden空间的百分比大小。</li><li>一旦对象在TLAB空间分配内存失败时，JVM就会尝试着通过<strong>使用加锁机制确保数据操作的原子性</strong>，从而直接在Eden空间中分配内存。</li></ul><blockquote><p>解释</p></blockquote><ul><li>哪个线程要分配内存，就在哪个线程的本地缓冲区中分配，只有本地缓冲区用完 了，分配新的缓存区时才需要同步锁定 —-这是《深入理解JVM》–第三版里说的</li><li>和这里讲的有点不同。我猜测说的意思是某一次分配，如果TLAB用完了，那么<strong>这一次</strong>先在Eden区直接分配。空闲下来后再加锁分配新的TLAB（TLAB内存较大，分配时间应该较长）</li></ul><h2 id="4-TLAB-分配过程"><a href="#4-TLAB-分配过程" class="headerlink" title="4. TLAB 分配过程"></a>4. TLAB 分配过程</h2><p><img src="https://raw.githubusercontent.com/GeorgeChan95/blogimg/master/img/2023/12/01/20231201-152616.png" alt="TLAB分配"></p><h1 id="十、堆空间参数设置"><a href="#十、堆空间参数设置" class="headerlink" title="十、堆空间参数设置"></a>十、堆空间参数设置</h1><h2 id="1-常用参数设置"><a href="#1-常用参数设置" class="headerlink" title="1. 常用参数设置"></a>1. 常用参数设置</h2><p>官方文档：<a href="https://docs.oracle.com/javase/8/docs/technotes/tools/unix/java.html">https://docs.oracle.com/javase/8/docs/technotes/tools/unix/java.html</a></p><pre><code class="highlight java"><span class="comment">/**</span><span class="comment"> * 测试堆空间常用的jvm参数：</span><span class="comment"> * -XX:+PrintFlagsInitial : 查看所有的参数的默认初始值</span><span class="comment"> * -XX:+PrintFlagsFinal  ：查看所有的参数的最终值（可能会存在修改，不再是初始值）</span><span class="comment"> *      具体查看某个参数的指令： jps：查看当前运行中的进程</span><span class="comment"> *                             jinfo -flag SurvivorRatio 进程id</span><span class="comment"> *</span><span class="comment"> * -Xms：初始堆空间内存 （默认为物理内存的1/64）</span><span class="comment"> * -Xmx：最大堆空间内存（默认为物理内存的1/4）</span><span class="comment"> * -Xmn：设置新生代的大小。(初始值及最大值)</span><span class="comment"> * -XX:NewRatio：配置新生代与老年代在堆结构的占比</span><span class="comment"> * -XX:SurvivorRatio：设置新生代中Eden和S0/S1空间的比例</span><span class="comment"> * -XX:MaxTenuringThreshold：设置新生代垃圾的最大年龄</span><span class="comment"> * -XX:+PrintGCDetails：输出详细的GC处理日志</span><span class="comment"> * 打印gc简要信息：① -XX:+PrintGC   ② -verbose:gc</span><span class="comment"> * -XX:HandlePromotionFailure：是否设置空间分配担保</span><span class="comment"> */</span></code></pre><h2 id="2-空间分配担保"><a href="#2-空间分配担保" class="headerlink" title="2. 空间分配担保"></a>2. 空间分配担保</h2><ul><li>在发生Minor GC之前，虚拟机会检查老年代最大可用的连续空间是否大于新生代所有对象的总空间。<ul><li>如果大于，则此次Minor GC是安全的</li><li>如果小于，则虚拟机会查看 <code>-XX:HandlePromotionFailure</code> 设置值是否允担保失败。<ul><li>如果 HandlePromotionFailure&#x3D;true，那么会继续检查老年代最大可用连续空间是否大于历次晋升到老年代的对象的平均大小。<ul><li>如果大于，则尝试进行一次Minor GC，但这次Minor GC依然是有风险的；</li><li>如果小于，则进行一次Full GC。</li></ul></li><li>如果 HandlePromotionFailure&#x3D;false，则进行一次Full GC。</li></ul></li></ul></li></ul><p><strong>历史版本</strong></p><ul><li>在JDK6 Update 24之后，HandlePromotionFailure 参数不会再影响到虚拟机的空间分配担保策略，观察openJDK中的源码变化，虽然源码中还定义了HandlePromotionFailure 参数，但是在代码中已经不会再使用它。</li><li>JDK6 Update 24之后的规则变为<strong>只要老年代的连续空间大于新生代对象总大小或者历次晋升的平均大小就会进行Minor GC</strong>，否则将进行Full GC。即 HandlePromotionFailure&#x3D;true</li></ul><h1 id="十一、堆是分配对象的唯一选择么？"><a href="#十一、堆是分配对象的唯一选择么？" class="headerlink" title="十一、堆是分配对象的唯一选择么？"></a>十一、堆是分配对象的唯一选择么？</h1><p><strong>在《深入理解Java虚拟机》中关于Java堆内存有这样一段描述：</strong></p><ul><li>随着JIT编译期的发展与<strong>逃逸分析技术</strong>逐渐成熟，<strong>栈上分配、标量替换</strong>优化技术将会导致一些微妙的变化，所有的对象都分配到堆上也渐渐变得不那么“绝对”了。</li><li>在Java虚拟机中，对象是在Java堆中分配内存的，这是一个普遍的常识。但是，有一种特殊情况，那就是<strong>如果经过逃逸分析（Escape Analysis）后发现，一个对象并没有逃逸出方法的话，那么就可能被优化成栈上分配</strong>。这样就无需在堆上分配内存，也无须进行垃圾回收了。这也是最常见的堆外存储技术。</li><li>此外，前面提到的基于OpenJDK深度定制的TaoBao VM，其中创新的GCIH（GC invisible heap）技术实现off-heap，将生命周期较长的Java对象从heap中移至heap外，并且GC不能管理GCIH内部的Java对象，以此达到降低GC的回收频率和提升GC的回收效率的目的。</li></ul><h2 id="1-逃逸分析"><a href="#1-逃逸分析" class="headerlink" title="1. 逃逸分析"></a>1. 逃逸分析</h2><ul><li>如何将堆上的对象分配到栈，需要使用逃逸分析手段。</li><li>这是一种可以有效减少Java程序中同步负载和内存堆分配压力的跨函数全局数据流分析算法。</li><li>通过逃逸分析，Java Hotspot编译器能够分析出一个新的对象的引用的使用范围从而决定是否要将这个对象分配到堆上。</li><li>逃逸分析的基本行为就是分析对象动态作用域：<ul><li>当一个对象在方法中被定义后，对象只在方法内部使用，则认为没有发生逃逸。</li><li>当一个对象在方法中被定义后，它被外部方法所引用，则认为发生逃逸。例如作为调用参数传递到其他地方中。</li></ul></li></ul><h3 id="1-1-逃逸分析举例"><a href="#1-1-逃逸分析举例" class="headerlink" title="1.1 逃逸分析举例"></a>1.1 逃逸分析举例</h3><ul><li>没有发生逃逸的对象，则可以分配到栈（无线程安全问题）上，随着方法执行的结束，栈空间就被移除（也就无需GC）</li></ul><pre><code class="highlight java"><span class="comment">/*</span><span class="comment">对象的作用域仅在当前方法中有效，没有发生逃逸</span><span class="comment"> */</span><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">useEscapeAnalysis</span><span class="params">()</span>&#123;    <span class="type">EscapeAnalysis</span> <span class="variable">e</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">EscapeAnalysis</span>();&#125;</code></pre><ul><li>下面代码中的 StringBuffer sb 发生了逃逸，不能在栈上分配</li></ul><pre><code class="highlight java"><span class="keyword">public</span> <span class="keyword">static</span> StringBuffer <span class="title function_">createStringBuffer</span><span class="params">(String s1, String s2)</span> &#123;    <span class="type">StringBuffer</span> <span class="variable">sb</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">StringBuffer</span>();    sb.append(s1);    sb.append(s2);    <span class="keyword">return</span> sb;&#125;</code></pre><ul><li>如果想要StringBuffer sb不发生逃逸，可以这样写</li></ul><pre><code class="highlight java"><span class="keyword">public</span> <span class="keyword">static</span> String <span class="title function_">createStringBuffer</span><span class="params">(String s1, String s2)</span> &#123;    <span class="type">StringBuffer</span> <span class="variable">sb</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">StringBuffer</span>();    sb.append(s1);    sb.append(s2);    <span class="keyword">return</span> sb.toString();&#125;</code></pre><ul><li>如何快速的判断是否发生了逃逸分析，大家就看new的对象实体是否有可能在方法外被调用。</li></ul><pre><code class="highlight java"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">EscapeAnalysis</span> &#123;    <span class="keyword">public</span> EscapeAnalysis obj;    <span class="comment">/*</span><span class="comment">    方法返回EscapeAnalysis对象，发生逃逸</span><span class="comment">     */</span>    <span class="keyword">public</span> EscapeAnalysis <span class="title function_">getInstance</span><span class="params">()</span>&#123;        <span class="keyword">return</span> obj == <span class="literal">null</span>? <span class="keyword">new</span> <span class="title class_">EscapeAnalysis</span>() : obj;    &#125;    <span class="comment">/*</span><span class="comment">    为成员属性赋值，发生逃逸</span><span class="comment">     */</span>    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setObj</span><span class="params">()</span>&#123;        <span class="built_in">this</span>.obj = <span class="keyword">new</span> <span class="title class_">EscapeAnalysis</span>();    &#125;    <span class="comment">//思考：如果当前的obj引用声明为static的？仍然会发生逃逸。</span>    <span class="comment">/*</span><span class="comment">    对象的作用域仅在当前方法中有效，没有发生逃逸</span><span class="comment">     */</span>    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">useEscapeAnalysis</span><span class="params">()</span>&#123;        <span class="type">EscapeAnalysis</span> <span class="variable">e</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">EscapeAnalysis</span>();    &#125;    <span class="comment">/*</span><span class="comment">    引用成员变量的值，发生逃逸</span><span class="comment">     */</span>    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">useEscapeAnalysis1</span><span class="params">()</span>&#123;        <span class="type">EscapeAnalysis</span> <span class="variable">e</span> <span class="operator">=</span> getInstance();        <span class="comment">//getInstance().xxx()同样会发生逃逸</span>    &#125;&#125;</code></pre><h3 id="1-2-逃逸分析参数设置"><a href="#1-2-逃逸分析参数设置" class="headerlink" title="1.2 逃逸分析参数设置"></a>1.2 逃逸分析参数设置</h3><ul><li>在JDK 1.7 版本之后，HotSpot中默认就已经开启了逃逸分析</li><li>如果使用的是较早的版本，开发人员则可以通过：<ul><li>选项 <code>-XX:+DoEscapeAnalysis</code> 显式开启逃逸分析</li><li>通过选项 <code>-XX:+PrintEscapeAnalysis</code> 查看逃逸分析的筛选结果</li></ul></li></ul><p><strong>总结:</strong></p><p>开发中能使用局部变量的，就不要使用在方法外定义。</p><h2 id="2-代码优化"><a href="#2-代码优化" class="headerlink" title="2. 代码优化"></a>2. 代码优化</h2><p>使用逃逸分析，编译器可以对代码做如下优化：</p><ul><li>栈上分配：将堆分配转化为栈分配。如果一个对象在子程序中被分配，要使指向该对象的指针永远不会发生逃逸，对象可能是栈上分配的候选，而不是堆上分配</li><li><strong>同步省略</strong>：如果一个对象被发现只有一个线程被访问到，那么对于这个对象的操作可以不考虑同步。</li><li><strong>分离对象或标量替换</strong>：有的对象可能不需要作为一个连续的内存结构存在也可以被访问到，那么对象的部分（或全部）可以不存储在内存，而是存储在CPU寄存器中。</li></ul><h3 id="2-1-栈上分配"><a href="#2-1-栈上分配" class="headerlink" title="2.1 栈上分配"></a>2.1 栈上分配</h3><ul><li>JIT编译器在编译期间根据逃逸分析的结果，发现如果一个对象并没有逃逸出方法的话，就可能被优化成栈上分配。分配完成后，继续在调用栈内执行，最后线程结束，栈空间被回收，局部变量对象也被回收。这样就无须进行垃圾回收了。</li><li>常见的栈上分配的场景：在逃逸分析中，已经说明了，分别是给成员变量赋值、方法返回值、实例引用传递。</li></ul><h4 id="2-1-1-栈上分配举例"><a href="#2-1-1-栈上分配举例" class="headerlink" title="2.1.1 栈上分配举例"></a>2.1.1 栈上分配举例</h4><h5 id="不开启逃逸分析"><a href="#不开启逃逸分析" class="headerlink" title="不开启逃逸分析"></a>不开启逃逸分析</h5><blockquote><p>代码</p></blockquote><pre><code class="highlight java"><span class="comment">/**</span><span class="comment"> * 栈上分配测试</span><span class="comment"> * -Xmx128m -Xms128m -XX:-DoEscapeAnalysis -XX:+PrintGCDetails</span><span class="comment"> */</span><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">StackAllocation</span> &#123;    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;        <span class="type">long</span> <span class="variable">start</span> <span class="operator">=</span> System.currentTimeMillis();        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; <span class="number">10000000</span>; i++) &#123;            alloc();        &#125;        <span class="comment">// 查看执行时间</span>        <span class="type">long</span> <span class="variable">end</span> <span class="operator">=</span> System.currentTimeMillis();        System.out.println(<span class="string">&quot;花费的时间为： &quot;</span> + (end - start) + <span class="string">&quot; ms&quot;</span>);        <span class="comment">// 为了方便查看堆内存中对象个数，线程sleep</span>        <span class="keyword">try</span> &#123;            Thread.sleep(<span class="number">1000000</span>);        &#125; <span class="keyword">catch</span> (InterruptedException e1) &#123;            e1.printStackTrace();        &#125;    &#125;    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">alloc</span><span class="params">()</span> &#123;        <span class="type">User</span> <span class="variable">user</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">User</span>();<span class="comment">//未发生逃逸</span>    &#125;    <span class="keyword">static</span> <span class="keyword">class</span> <span class="title class_">User</span> &#123;    &#125;&#125;</code></pre><blockquote><p>设置JVM参数</p></blockquote><pre><code class="highlight plaintext">-Xmx128m -Xms128m -XX:-DoEscapeAnalysis -XX:+PrintGCDetails</code></pre><blockquote><p>运行输出结果</p></blockquote><pre><code class="highlight plaintext">[GC (Allocation Failure) [PSYoungGen: 33280K-&gt;712K(38400K)] 33280K-&gt;720K(125952K), 0.0008004 secs] [Times: user=0.00 sys=0.00, real=0.00 secs] [GC (Allocation Failure) [PSYoungGen: 33992K-&gt;728K(38400K)] 34000K-&gt;736K(125952K), 0.0006574 secs] [Times: user=0.00 sys=0.00, real=0.00 secs] [GC (Allocation Failure) [PSYoungGen: 34008K-&gt;680K(38400K)] 34016K-&gt;688K(125952K), 0.0005634 secs] [Times: user=0.00 sys=0.00, real=0.00 secs] [GC (Allocation Failure) [PSYoungGen: 33960K-&gt;712K(38400K)] 33968K-&gt;720K(125952K), 0.0005773 secs] [Times: user=0.00 sys=0.00, real=0.00 secs] 花费的时间为： 35 ms</code></pre><p>日志打印：发生了 GC ，耗时 35ms</p><h5 id="开启逃逸分析"><a href="#开启逃逸分析" class="headerlink" title="开启逃逸分析"></a>开启逃逸分析</h5><blockquote><p>设置JVM参数</p></blockquote><pre><code class="highlight plaintext">-Xmx128m -Xms128m -XX:+DoEscapeAnalysis -XX:+PrintGCDetails</code></pre><blockquote><p>运行输出结果</p></blockquote><pre><code class="highlight plaintext">花费的时间为： 5 ms</code></pre><p>日志打印：并没有发生 GC ，耗时5ms 。</p><h3 id="2-2-同步省略（同步消除）"><a href="#2-2-同步省略（同步消除）" class="headerlink" title="2.2 同步省略（同步消除）"></a>2.2 同步省略（同步消除）</h3><ul><li>线程同步的代价是相当高的，同步的后果是降低并发性和性能。</li><li>在动态编译同步块的时候，JIT编译器可以借助逃逸分析来<strong>判断同步块所使用的锁对象是否只能够被一个线程访问而没有被发布到其他线程</strong>。</li><li>如果没有，那么JIT编译器在编译这个同步块的时候就会取消对这部分代码的同步。这样就能大大提高并发性和性能。这个<strong>取消同步的过程就叫同步省略，也叫锁消除</strong>。</li></ul><p>例如下面的代码</p><pre><code class="highlight java"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">f</span><span class="params">()</span> &#123;    <span class="type">Object</span> <span class="variable">hollis</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Object</span>();    <span class="keyword">synchronized</span>(hollis) &#123;        System.out.println(hollis);    &#125;&#125;</code></pre><p>代码中对 hollis 这个对象加锁，但是hollis对象的生命周期只在f()方法中，并不会被其他线程所访问到，所以在JIT编译阶段就会被优化掉，优化成：</p><pre><code class="highlight java"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">f</span><span class="params">()</span> &#123;    <span class="type">Object</span> <span class="variable">hellis</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Object</span>();System.out.println(hellis);&#125;</code></pre><blockquote><p><strong>字节码分析</strong></p></blockquote><pre><code class="highlight plaintext"> 0 new #2 &lt;java/lang/Object&gt; 3 dup 4 invokespecial #1 &lt;java/lang/Object.&lt;init&gt;&gt; 7 astore_1 8 aload_1 9 dup10 astore_211 monitorenter12 getstatic #3 &lt;java/lang/System.out&gt;15 aload_116 invokevirtual #4 &lt;java/io/PrintStream.println&gt;19 aload_220 monitorexit21 goto 29 (+8)24 astore_325 aload_226 monitorexit27 aload_328 athrow29 return</code></pre><p>注意：字节码文件中并没有进行优化，可以看到加锁和释放锁的操作依然存在，<strong>同步省略操作是在解释运行时发生的</strong></p><h3 id="2-3-标量替换"><a href="#2-3-标量替换" class="headerlink" title="2.3 标量替换"></a>2.3 标量替换</h3><h4 id="2-3-1-分离对象或标量替换"><a href="#2-3-1-分离对象或标量替换" class="headerlink" title="2.3.1 分离对象或标量替换"></a>2.3.1 分离对象或标量替换</h4><ul><li>标量（scalar）是指一个无法再分解成更小的数据的数据。Java中的原始数据类型就是标量。</li><li>相对的，那些还可以分解的数据叫做聚合量（Aggregate），Java中的对象就是聚合量，因为他可以分解成其他聚合量和标量。</li><li>在JIT阶段，如果经过逃逸分析，发现一个对象不会被外界访问的话，那么经过JIT优化，就会把这个对象拆解成若干个其中包含的若干个成员变量来代替。这个过程就是标量替换。</li></ul><h4 id="2-3-2-标量替换举例"><a href="#2-3-2-标量替换举例" class="headerlink" title="2.3.2 标量替换举例"></a>2.3.2 标量替换举例</h4><blockquote><p>代码</p></blockquote><pre><code class="highlight java"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String args[])</span> &#123;    alloc();&#125;<span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">alloc</span><span class="params">()</span> &#123;    <span class="type">Point</span> <span class="variable">point</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Point</span>(<span class="number">1</span>,<span class="number">2</span>);    System.out.println(<span class="string">&quot;point.x&quot;</span> + point.x + <span class="string">&quot;;point.y&quot;</span> + point.y);&#125;<span class="keyword">class</span> <span class="title class_">Point</span> &#123;    <span class="keyword">private</span> <span class="type">int</span> x;    <span class="keyword">private</span> <span class="type">int</span> y;&#125;</code></pre><p>以上代码，经过标量替换后，就会变成</p><pre><code class="highlight java"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">alloc</span><span class="params">()</span> &#123;    <span class="type">int</span> <span class="variable">x</span> <span class="operator">=</span> <span class="number">1</span>;    <span class="type">int</span> <span class="variable">y</span> <span class="operator">=</span> <span class="number">2</span>;    System.out.println(<span class="string">&quot;point.x = &quot;</span> + x + <span class="string">&quot;; point.y=&quot;</span> + y);&#125;</code></pre><ul><li>可以看到，Point这个聚合量经过逃逸分析后，发现他并没有逃逸，就被替换成两个聚合量了。</li><li>那么标量替换有什么好处呢？就是可以大大减少堆内存的占用。因为一旦不需要创建对象了，那么就不再需要分配堆内存了。</li><li>标量替换为栈上分配提供了很好的基础。</li></ul><h4 id="2-3-3-标量替换参数设置"><a href="#2-3-3-标量替换参数设置" class="headerlink" title="2.3.3 标量替换参数设置"></a>2.3.3 标量替换参数设置</h4><p>参数 <code>-XX:+ElimilnateAllocations</code> ：开启了标量替换（默认打开），允许将对象打散分配在栈上。</p><blockquote><p>代码示例</p></blockquote><pre><code class="highlight java"><span class="comment">/**</span><span class="comment"> * 标量替换测试</span><span class="comment"> *  -Xmx100m -Xms100m -XX:+DoEscapeAnalysis -XX:+PrintGC -XX:-EliminateAllocations</span><span class="comment"> */</span><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ScalarReplace</span> &#123;    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">class</span> <span class="title class_">User</span> &#123;        <span class="keyword">public</span> <span class="type">int</span> id;        <span class="keyword">public</span> String name;    &#125;    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">alloc</span><span class="params">()</span> &#123;        <span class="type">User</span> <span class="variable">u</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">User</span>();<span class="comment">//未发生逃逸</span>        u.id = <span class="number">5</span>;        u.name = <span class="string">&quot;www.atguigu.com&quot;</span>;    &#125;    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;        <span class="type">long</span> <span class="variable">start</span> <span class="operator">=</span> System.currentTimeMillis();        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; <span class="number">10000000</span>; i++) &#123;            alloc();        &#125;        <span class="type">long</span> <span class="variable">end</span> <span class="operator">=</span> System.currentTimeMillis();        System.out.println(<span class="string">&quot;花费的时间为： &quot;</span> + (end - start) + <span class="string">&quot; ms&quot;</span>);    &#125;&#125;</code></pre><h5 id="未开启标量替换"><a href="#未开启标量替换" class="headerlink" title="未开启标量替换"></a>未开启标量替换</h5><blockquote><p>设置JVM参数</p></blockquote><pre><code class="highlight plaintext">-Xmx100m -Xms100m -XX:+DoEscapeAnalysis -XX:+PrintGC -XX:-EliminateAllocations</code></pre><blockquote><p>运行结果</p></blockquote><pre><code class="highlight plaintext">[GC (Allocation Failure)  25600K-&gt;784K(98304K), 0.0007896 secs][GC (Allocation Failure)  26384K-&gt;736K(98304K), 0.0006284 secs][GC (Allocation Failure)  26336K-&gt;688K(98304K), 0.0005706 secs][GC (Allocation Failure)  26288K-&gt;688K(98304K), 0.0005614 secs][GC (Allocation Failure)  26288K-&gt;672K(98304K), 0.0005780 secs][GC (Allocation Failure)  26272K-&gt;688K(101376K), 0.0006347 secs][GC (Allocation Failure)  32432K-&gt;636K(101376K), 0.0012266 secs][GC (Allocation Failure)  32380K-&gt;636K(101376K), 0.0003978 secs]花费的时间为： 49 ms</code></pre><h5 id="开启标量替换"><a href="#开启标量替换" class="headerlink" title="开启标量替换"></a>开启标量替换</h5><blockquote><p>设置JVM参数</p></blockquote><pre><code class="highlight plaintext">-Xmx100m -Xms100m -XX:+DoEscapeAnalysis -XX:+PrintGC -XX:+EliminateAllocations</code></pre><blockquote><p>运行结果</p></blockquote><pre><code class="highlight plaintext">花费的时间为： 3 ms</code></pre><p>日志：时间减少很多，且无GC</p><p>上述代码在主函数中调用了1亿次alloc()方法，进行对象创建由于User对象实例需要占据约16字节的空间，因此累计分配空间达到将近1.5GB。如果堆空间小于这个值，就必然会发生GC。使用如下参数运行上述代码：</p><pre><code class="highlight plaintext">-server -Xmx100m -Xms100m -XX:+DoEscapeAnalysis -XX:+PrintGC -XX:+EliminateAllocations</code></pre><p><strong>这里设置参数如下：</strong></p><ul><li>参数 -server：启动Server模式，因为在server模式下，才可以启用逃逸分析。</li><li>参数 -XX:+DoEscapeAnalysis：启用逃逸分析</li><li>参数 -Xmx10m：指定了堆空间最大为10MB</li><li>参数 -XX:+PrintGC：将打印GC日志。</li><li>参数 -XX:+EliminateAllocations：开启了标量替换（默认打开），允许将对象打散分配在栈上，比如对象拥有id和name两个字段，那么这两个字段将会被视为两个独立的局部变量进行分配</li></ul><h2 id="3-逃逸分析的不足"><a href="#3-逃逸分析的不足" class="headerlink" title="3. 逃逸分析的不足"></a>3. 逃逸分析的不足</h2><ul><li>关于逃逸分析的论文在1999年就已经发表了，但直到JDK1.6才有实现，而且这项技术到如今也并不是十分成熟的。</li><li>其根本原因就是无法保证逃逸分析的性能消耗一定能高于他的消耗。虽然经过逃逸分析可以做标量替换、栈上分配、和锁消除。但是逃逸分析自身也是需要进行一系列复杂的分析的，这其实也是一个相对耗时的过程。</li><li>一个极端的例子，就是经过逃逸分析之后，发现没有一个对象是不逃逸的。那这个逃逸分析的过程就白白浪费掉了。</li><li>虽然这项技术并不十分成熟，但是它也是即时编译器优化技术中一个十分重要的手段。</li><li>注意到有一些观点，认为通过逃逸分析，JVM会在栈上分配那些不会逃逸的对象，这在理论上是可行的，但是取决于JVM设计者的选择。据我所知，<strong>Oracle Hotspot JVM中并未这么做</strong>（刚刚演示的效果，是因为HotSpot实现了标量替换），这一点在逃逸分析相关的文档里已经说明，<strong>所以可以明确在HotSpot虚拟机上，所有的对象实例都是创建在堆上</strong>。</li><li>目前很多书籍还是基于JDK7以前的版本，JDK已经发生了很大变化，intern字符串的缓存和静态变量曾经都被分配在永久代上，而永久代已经被元数据区取代。但是<strong>intern字符串缓存和静态变量并不是被转移到元数据区，而是直接在堆上分配</strong>，<strong>所以这一点同样符合前面一点的结论：对象实例都是分配在堆上</strong>。</li></ul><p><strong>总结：</strong></p><p><strong>堆是分配对象的唯一选择么？</strong></p><p>综上：<strong>对象实例都是分配在堆上</strong>。</p><h1 id="十二、小结"><a href="#十二、小结" class="headerlink" title="十二、小结"></a>十二、小结</h1><ol><li>年轻代是对象的诞生、成长、消亡的区域，一个对象在这里产生、应用，最后被垃圾回收器收集、结束生命。</li><li>老年代放置长生命周期的对象，通常都是从Survivor区域筛选拷贝过来的Java对象。</li><li>当然，也有特殊情况，我们知道普通的对象可能会被分配在TLAB上；</li><li>如果对象较大，无法分配在 TLAB 上，则JVM会试图直接分配在Eden其他位置上；</li><li>如果对象太大，完全无法在新生代找到足够长的连续空闲空间，JVM就会直接分配到老年代。</li><li>当GC只发生在年轻代中，回收年轻代对象的行为被称为Minor GC。</li><li>当GC发生在老年代时则被称为Major GC或者Full GC。</li><li>一般的，Minor GC的发生频率要比Major GC高很多，即老年代中垃圾回收发生的频率将大大低于年轻代。</li></ol>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;环境&quot;&gt;&lt;a href=&quot;#环境&quot; class=&quot;headerlink&quot; title=&quot;环境&quot;&gt;&lt;/a&gt;环境&lt;/h1&gt;&lt;blockquote&gt;
&lt;p&gt;系统 : Windows 10&lt;br&gt;JDK : 1.8&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h1 id=&quot;一、</summary>
      
    
    
    
    <category term="JVM" scheme="https://georgechan95.github.io/categories/JVM/"/>
    
    
    <category term="jvm" scheme="https://georgechan95.github.io/tags/jvm/"/>
    
    <category term="java" scheme="https://georgechan95.github.io/tags/java/"/>
    
  </entry>
  
  <entry>
    <title>第五章-本地方法接口</title>
    <link href="https://georgechan95.github.io/2023/11/30/jvm/%E7%AC%AC%E4%BA%94%E7%AB%A0-%E6%9C%AC%E5%9C%B0%E6%96%B9%E6%B3%95%E6%8E%A5%E5%8F%A3/"/>
    <id>https://georgechan95.github.io/2023/11/30/jvm/%E7%AC%AC%E4%BA%94%E7%AB%A0-%E6%9C%AC%E5%9C%B0%E6%96%B9%E6%B3%95%E6%8E%A5%E5%8F%A3/</id>
    <published>2023-11-30T09:55:00.000Z</published>
    <updated>2024-06-22T10:36:12.823Z</updated>
    
    <content type="html"><![CDATA[<h1 id="环境"><a href="#环境" class="headerlink" title="环境"></a>环境</h1><blockquote><p>系统 : Windows 10<br>JDK : 1.8</p></blockquote><h1 id="一、什么是本地方法"><a href="#一、什么是本地方法" class="headerlink" title="一、什么是本地方法"></a>一、什么是本地方法</h1><img src="https://raw.githubusercontent.com/GeorgeChan95/blogimg/master/img/2023/11/30/20231130-195918.png" alt="image-20231130195914842" style="zoom:67%;" /><ul><li>简单地讲，<strong>一个Native Method是一个Java调用非Java代码的接囗</strong>一个Native Method是这样一个Java方法：该方法的实现由非Java语言实现，比如C。这个特征并非Java所特有，很多其它的编程语言都有这一机制，比如在C++中，你可以用extern 告知C++编译器去调用一个C的函数。</li><li>“A native method is a Java method whose implementation is provided by non-java code.”（本地方法是一个非Java的方法，它的具体实现是非Java代码的实现）</li><li>在定义一个native method时，并不提供实现体（有些像定义一个Java interface），因为其实现体是由非java语言在外面实现的。</li><li>本地接口的作用是融合不同的编程语言为Java所用，它的初衷是融合C&#x2F;C++程序。</li></ul><img src="https://raw.githubusercontent.com/GeorgeChan95/blogimg/master/img/2023/11/30/20231130-172423.png" alt="本地方法接口" style="zoom: 67%;" /><blockquote><p>示例</p></blockquote><p>需要注意的是：标识符native可以与其它java标识符连用，但是abstract除外</p><pre><code class="highlight java"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">IHaveNatives</span> &#123;    <span class="keyword">public</span> <span class="keyword">native</span> <span class="keyword">void</span> <span class="title function_">Native1</span><span class="params">(<span class="type">int</span> x)</span>;    <span class="keyword">public</span> <span class="keyword">native</span> <span class="keyword">static</span> <span class="type">long</span> <span class="title function_">Native2</span><span class="params">()</span>;    <span class="keyword">private</span> <span class="keyword">native</span> <span class="keyword">synchronized</span> <span class="type">float</span> <span class="title function_">Native3</span><span class="params">(Object o)</span>;    <span class="keyword">native</span> <span class="keyword">void</span> <span class="title function_">Native4</span><span class="params">(<span class="type">int</span>[] ary)</span> <span class="keyword">throws</span> Exception;&#125;</code></pre><h1 id="二、为什么要使用-Native-Method"><a href="#二、为什么要使用-Native-Method" class="headerlink" title="二、为什么要使用 Native Method"></a>二、为什么要使用 Native Method</h1><p>Java使用起来非常方便，当某些任务使用Java实现比较困难，或者对性能有更高的要求是，使用Native Method 会更合适。</p><h2 id="1-与Java环境外交互"><a href="#1-与Java环境外交互" class="headerlink" title="1. 与Java环境外交互"></a>1. 与Java环境外交互</h2><p><strong>有时Java应用需要与Java外面的硬件环境交互，这是本地方法存在的主要原因</strong>。你可以想想Java需要与一些<strong>底层系统</strong>，如操作系统或某些硬件交换信息时的情况。本地方法正是这样一种交流机制：它为我们提供了一个非常简洁的接口，而且我们无需去了解Java应用之外的繁琐的细节。</p><h2 id="2-与操作系统的交互"><a href="#2-与操作系统的交互" class="headerlink" title="2. 与操作系统的交互"></a>2. 与操作系统的交互</h2><p>JVM 支持着 Java 语言本身和运行时库，它是 Java 程序赖以生存的平台，它由一个解释器（解释字节码）和一些连接到本地代码的库组成。然而不管怎样，它毕竟不是一个完整的系统，它经常依赖于一些底层系统的支持。这些底层系统常常是强大的操作系统。<strong>通过使用本地方法，我们得以用 Java 实现了 jre 与底层系统的交互，甚至 JVM 的一些部分就是用 C 写的。</strong>还有，如果我们要使用一些 Java 语言本身没有提供封装的操作系统的特性时，我们也需要使用本地方法。</p><h2 id="3-Sun’s-Java"><a href="#3-Sun’s-Java" class="headerlink" title="3. Sun’s Java"></a>3. Sun’s Java</h2><p>Sun的解释器是用C实现的，这使得它能像一些普通的C一样与外部交互。jre大部分是用Java实现的，它也通过一些本地方法与外界交互。</p><p>例如：类java.lang.Thread的setPriority()方法是用Java实现的，但是它实现调用的是该类里的本地方法setPriority0()。这个本地方法是用C实现的，并被植入JVM内部在Windows 95的平台上，这个本地方法最终将调用Win32 setpriority() API。这是一个本地方法的具体实现由JVM直接提供，更多的情况是本地方法由外部的动态链接库（external dynamic link library）提供，然后被JVM调用。</p><h2 id="4-本地方法的现状"><a href="#4-本地方法的现状" class="headerlink" title="4. 本地方法的现状"></a>4. 本地方法的现状</h2><p>目前该方法使用的越来越少了，除非是与硬件有关的应用，比如通过Java程序驱动打印机或者Java系统管理生产设备，在企业级应用中已经比较少见。因为现在的异构领域间的通信很发达，比如可以使用Socket通信，也可以使用Web Service等等。</p><h1 id="三、本地方法栈"><a href="#三、本地方法栈" class="headerlink" title="三、本地方法栈"></a>三、本地方法栈</h1><ul><li><strong>Java虚拟机栈于管理Java方法的调用，而本地方法栈用于管理本地方法的调用</strong>。</li><li>本地方法栈，也是线程私有的。</li><li>允许被实现成固定或者是可动态扩展的内存大小（在内存溢出方面和虚拟机栈相同）<ul><li>如果线程请求分配的栈容量超过本地方法栈允许的最大容量，Java虚拟机将会抛出一个stackoverflowError 异常。</li><li>如果本地方法栈可以动态扩展，并且在尝试扩展的时候无法申请到足够的内存，或者在创建新的线程时没有足够的内存去创建对应的本地方法栈，那么Java虚拟机将会抛出一个outofMemoryError异常。</li></ul></li><li>本地方法一般是使用C语言或C++语言实现的。</li><li>具体做法是Native Method Stack中登记native方法，在Execution Engine 执行时加载本地方法库。</li></ul><p><img src="https://raw.githubusercontent.com/GeorgeChan95/blogimg/master/img/2023/11/30/20231130-201221.png" alt="image-20231130201219877"></p><h1 id="四、JVM怎样使Native-Method跑起来"><a href="#四、JVM怎样使Native-Method跑起来" class="headerlink" title="四、JVM怎样使Native Method跑起来"></a>四、JVM怎样使Native Method跑起来</h1><p> 我们知道，当一个类第一次被使用到时，这个类的字节码会被加载到内存，并且只会回载一次。在这个被加载的字节码的入口维持着一个该类所有方法描述符的 list，这些方法描述符包含这样一些信息：方法代码存于何处，它有哪些参数，方法的描述符（public之类）等等。</p><p> 如果一个方法描述符内有 native，这个描述符块将有一个指向该方法的实现的指针。这些实现在一些DLL文件内，但是它们会被操作系统加载到java程序的地址空间。当一个带有本地方法的类被加载时，其相关的DLL并未被加载，因此指向方法实现的指针并不会被设置。当本地方法被调用之前，这些DLL才会被加载，这是通过调用<code>java.system.loadLibrary()</code> 实现的。</p><h1 id="五、注意事项"><a href="#五、注意事项" class="headerlink" title="五、注意事项"></a>五、注意事项</h1><ul><li>当某个线程调用一个本地方法时，它就进入了一个全新的并且不再受虚拟机限制的世界。它和虚拟机拥有同样的权限。<ul><li>本地方法可以通过本地方法接口来访问虚拟机内部的运行时数据区</li><li>它甚至可以直接使用本地处理器中的寄存器</li><li>直接从本地内存的堆中分配任意数量的内存</li></ul></li><li>并不是所有的JVM都支持本地方法。因为Java虚拟机规范并没有明确要求本地方法栈的使用语言、具体实现方式、数据结构等。如果JVM产品不打算支持native方法，也可以无需实现本地方法栈。</li><li>在Hotspot JVM中，直接将本地方法栈和虚拟机栈合二为一。</li></ul>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;环境&quot;&gt;&lt;a href=&quot;#环境&quot; class=&quot;headerlink&quot; title=&quot;环境&quot;&gt;&lt;/a&gt;环境&lt;/h1&gt;&lt;blockquote&gt;
&lt;p&gt;系统 : Windows 10&lt;br&gt;JDK : 1.8&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h1 id=&quot;一、</summary>
      
    
    
    
    <category term="JVM" scheme="https://georgechan95.github.io/categories/JVM/"/>
    
    
    <category term="jvm" scheme="https://georgechan95.github.io/tags/jvm/"/>
    
    <category term="java" scheme="https://georgechan95.github.io/tags/java/"/>
    
  </entry>
  
  <entry>
    <title>第四章-虚拟机栈</title>
    <link href="https://georgechan95.github.io/2023/11/28/jvm/%E7%AC%AC%E5%9B%9B%E7%AB%A0-%E8%99%9A%E6%8B%9F%E6%9C%BA%E6%A0%88/"/>
    <id>https://georgechan95.github.io/2023/11/28/jvm/%E7%AC%AC%E5%9B%9B%E7%AB%A0-%E8%99%9A%E6%8B%9F%E6%9C%BA%E6%A0%88/</id>
    <published>2023-11-28T12:55:00.000Z</published>
    <updated>2024-06-22T10:36:12.823Z</updated>
    
    <content type="html"><![CDATA[<h1 id="环境"><a href="#环境" class="headerlink" title="环境"></a>环境</h1><blockquote><p>系统 : Windows 10<br>JDK : 1.8</p></blockquote><h1 id="一、简介"><a href="#一、简介" class="headerlink" title="一、简介"></a>一、简介</h1><h2 id="1-虚拟机栈的出现背景"><a href="#1-虚拟机栈的出现背景" class="headerlink" title="1. 虚拟机栈的出现背景"></a>1. 虚拟机栈的出现背景</h2><ul><li>由于跨平台性的设计，Java的指令都是根据栈来设计的。不同平台CPU架构不同，所以不能设计为基于寄存器的【如果设计成基于寄存器的，耦合度高，性能会有所提升，因为可以对具体的CPU架构进行优化，但是跨平台性大大降低】。</li><li>基于栈设计优点是跨平台，指令集小，编译器容易实现，缺点是性能下降，实现同样的功能需要更多的指令。</li></ul><h2 id="2-内存中的栈与堆"><a href="#2-内存中的栈与堆" class="headerlink" title="2. 内存中的栈与堆"></a>2. 内存中的栈与堆</h2><ul><li>首先栈是运行时的单位，而堆是存储的单位。</li><li>即：栈解决程序的运行问题，即程序如何执行，或者说如何处理数据。堆解决的是数据存储的问题，即数据怎么放，放哪里</li></ul><p><img src="https://raw.githubusercontent.com/GeorgeChan95/blogimg/master/img/2023/11/29/20231129-093805.png" alt="堆和栈"></p><h2 id="3-虚拟机栈基本内容"><a href="#3-虚拟机栈基本内容" class="headerlink" title="3. 虚拟机栈基本内容"></a>3. 虚拟机栈基本内容</h2><ul><li>Java虚拟机栈是什么？<ul><li>Java虚拟机栈（Java Virtual Machine Stack），早期也叫Java栈。每个线程在创建时都会创建一个虚拟机栈，其内部保存一个个的栈帧（Stack Frame），<strong>对应着一次次的Java方法调用，栈是线程私有的</strong>。</li></ul></li></ul><pre><code class="highlight java"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">StackTest</span> &#123;    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;        <span class="type">StackTest</span> <span class="variable">test</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">StackTest</span>();        test.methodA();    &#125;    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">methodA</span><span class="params">()</span> &#123;        <span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">10</span>;        <span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> <span class="number">20</span>;        methodB();    &#125;    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">methodB</span><span class="params">()</span>&#123;        <span class="type">int</span> <span class="variable">k</span> <span class="operator">=</span> <span class="number">30</span>;        <span class="type">int</span> <span class="variable">m</span> <span class="operator">=</span> <span class="number">40</span>;    &#125;&#125;</code></pre><p>如上面的代码，<code>main()</code> 、<code>methodA()</code> 、<code>methodB()</code>  在虚拟机栈中都对应着一个一个的栈帧。</p><ul><li>虚拟机栈的生命周期<ul><li>生命周期和线程一致，也就是线程结束了，该虚拟机栈也销毁了</li></ul></li><li>虚拟机栈的作用<ul><li>主管Java程序的运行，它保存方法的局部变量（8 种基本数据类型、对象的引用地址）、部分结果，并参与方法的调用和返回。<ul><li>局部变量，它是相比于成员变量来说的（或属性）</li><li>基本数据类型变量 VS 引用类型变量（类、数组、接口）</li></ul></li></ul></li></ul><h2 id="4-虚拟机栈的特点"><a href="#4-虚拟机栈的特点" class="headerlink" title="4. 虚拟机栈的特点"></a>4. 虚拟机栈的特点</h2><ul><li>栈是一种快速有效的分配存储方式，访问速度仅次于程序计数器。</li><li>JVM直接对Java栈的操作只有两个<ul><li>每个方法执行，伴随着<strong>进栈</strong>（入栈、压栈）</li><li>执行结束后的<strong>出栈</strong>工作</li></ul></li><li>对于栈来说不存在垃圾回收问题<ul><li>栈不需要GC，但是可能存在OOM</li></ul></li></ul><img src="https://raw.githubusercontent.com/GeorgeChan95/blogimg/master/img/2023/11/29/20231129-095026.png" alt="入栈和出栈" style="zoom:50%;" /><h2 id="5-虚拟机栈的异常"><a href="#5-虚拟机栈的异常" class="headerlink" title="5. 虚拟机栈的异常"></a>5. 虚拟机栈的异常</h2><p><strong>栈中可能出现的异常有哪些？</strong></p><ul><li>Java 虚拟机规范允许Java栈的大小是动态的或者是固定不变的。<ul><li>如果采用固定大小的Java虚拟机栈，那每一个线程的Java虚拟机栈容量可以在线程创建的时候独立选定。如果线程请求分配的栈容量超过Java虚拟机栈允许的最大容量，Java虚拟机将会抛出一个StackoverflowError 异常。</li><li>如果Java虚拟机栈可以动态扩展，并且在尝试扩展的时候无法申请到足够的内存，或者在创建新的线程时没有足够的内存去创建对应的虚拟机栈，那Java虚拟机将会抛出一个 OutofMemoryError 异常。</li></ul></li></ul><h2 id="6-设置栈内存大小"><a href="#6-设置栈内存大小" class="headerlink" title="6. 设置栈内存大小"></a>6. 设置栈内存大小</h2><p><strong>参考：</strong></p><p><a href="https://docs.oracle.com/en/java/javase/11/tools/java.html#GUID-3B1CE181-CD30-4178-9602-230B800D4FAE">官方文档-JDK11</a></p><p><a href="https://docs.oracle.com/javase/8/docs/technotes/tools/unix/java.html#CBBFHAJA">官方文档-JDK8</a></p><p>可以使用参数 <code>-Xss</code> 选项来设置线程的最大栈空间，栈的大小直接决定了函数调用的最大可达深度。</p><p><img src="https://raw.githubusercontent.com/GeorgeChan95/blogimg/master/img/2023/11/29/20231129-095748.png" alt="image-20231129095746846"></p><p><strong>IDEA中设置栈大小</strong></p><p>修改 <code>VM options</code> 设置栈的大小</p><img src="https://raw.githubusercontent.com/GeorgeChan95/blogimg/master/img/2023/11/29/20231129-100149.png" alt="image-20231129100148069" style="zoom: 80%;" /><h1 id="二、栈的存储单位"><a href="#二、栈的存储单位" class="headerlink" title="二、栈的存储单位"></a>二、栈的存储单位</h1><h2 id="1-栈中存储什么？"><a href="#1-栈中存储什么？" class="headerlink" title="1. 栈中存储什么？"></a>1. 栈中存储什么？</h2><ul><li>每个线程都有自己的栈，栈中的数据都是以<strong>栈帧</strong>（Stack Frame）的格式存在</li><li>在这个线程上正在执行的每个方法都各自对应一个栈帧（Stack Frame）。</li><li>栈帧是一个内存区块，是一个数据集，维系着方法执行过程中的各种数据信息。</li></ul><h2 id="2-栈运行原理"><a href="#2-栈运行原理" class="headerlink" title="2. 栈运行原理"></a>2. 栈运行原理</h2><ul><li>JVM直接对Java栈的操作只有两个，就是对栈帧的<strong>压栈和出栈</strong>，遵循先进后出（后进先出）原则</li><li>在一条活动线程中，一个时间点上，只会有一个活动的栈帧。即只有当前正在执行的方法的栈帧（栈顶栈帧）是有效的。这个栈帧被称为<strong>当前栈帧（Current Frame）</strong>，与当前栈帧相对应的方法就是<strong>当前方法（Current Method）</strong>，定义这个方法的类就是<strong>当前类（Current Class）</strong></li><li>执行引擎运行的所有字节码指令只针对当前栈帧进行操作。</li><li>如果在该方法中调用了其他方法，对应的新的栈帧会被创建出来，放在栈的顶端，成为新的当前帧。</li></ul><img src="https://raw.githubusercontent.com/GeorgeChan95/blogimg/master/img/2023/11/29/20231129-102521.jpg" alt="方法与栈桢" style="zoom: 50%;" /><ul><li><strong>不同线程中所包含的栈帧是不允许存在相互引用的</strong>，即不可能在一个栈帧之中引用另外一个线程的栈帧。</li><li>如果当前方法调用了其他方法，方法返回之际，当前栈帧会传回此方法的执行结果给前一个栈帧，接着，虚拟机会丢弃当前栈帧，使得前一个栈帧重新成为当前栈帧。</li><li>Java方法有两种返回函数的方式。<ul><li>一种是正常的函数返回，使用return指令。</li><li>另一种是方法执行中出现未捕获处理的异常，以抛出异常的方式结束。</li><li>但不管使用哪种方式，都会导致栈帧被弹出。</li></ul></li></ul><h2 id="3-栈帧的内部结构"><a href="#3-栈帧的内部结构" class="headerlink" title="3. 栈帧的内部结构"></a>3. 栈帧的内部结构</h2><ul><li>每个栈帧中存储着：<ul><li>局部变量表（Local Variables）</li><li>操作数栈（Operand Stack）（或表达式栈）</li><li>动态链接（Dynamic Linking）（或指向运行时常量池的方法引用）</li><li>方法返回地址（Return Address）（或方法正常退出或者异常退出的定义）</li><li>一些附加信息</li></ul></li></ul><img src="https://raw.githubusercontent.com/GeorgeChan95/blogimg/master/img/2023/11/29/20231129-102908.jpg" alt="栈桢内部结构" style="zoom:50%;" /><p><strong>并行每个线程下的栈都是私有的，因此每个线程都有自己各自的栈，并且每个栈里面都有很多栈帧，栈帧的大小主要由局部变量表 和 操作数栈决定的。</strong></p><p><img src="https://raw.githubusercontent.com/GeorgeChan95/blogimg/master/img/2023/11/29/20231129-103440.png" alt="线程和虚拟机栈"></p><h1 id="三、局部变量表"><a href="#三、局部变量表" class="headerlink" title="三、局部变量表"></a>三、局部变量表</h1><h2 id="1-认识局部变量表"><a href="#1-认识局部变量表" class="headerlink" title="1. 认识局部变量表"></a>1. 认识局部变量表</h2><h3 id="1-1-概念"><a href="#1-1-概念" class="headerlink" title="1.1 概念"></a>1.1 概念</h3><ul><li>局部变量表也被称之为局部变量数组或本地变量表</li><li><strong>定义为一个数字数组，主要用于存储方法参数和定义在方法体内的局部变量</strong>，这些数据类型包括各类基本数据类型、对象引用（reference），以及returnAddress返回值类型。</li><li>由于局部变量表是建立在线程的栈上，是线程的私有数据，因此<strong>不存在数据安全问题</strong></li><li><strong>局部变量表所需的容量大小是在编译期确定下来的</strong>，并保存在方法的Code属性的<strong>maximum local variables</strong>数据项中。在方法运行期间是不会改变局部变量表的大小的。</li><li>方法嵌套调用的次数由栈的大小决定。一般来说，栈越大，方法嵌套调用次数越多。<ul><li>对一个函数而言，它的参数和局部变量越多，使得局部变量表膨胀，它的栈帧就越大，以满足方法调用所需传递的信息增大的需求。进而函数调用就会占用更多的栈空间，导致其嵌套调用次数就会减少。</li></ul></li><li>局部变量表中的变量只在当前方法调用中有效。<ul><li>在方法执行时，虚拟机通过使用局部变量表完成参数值到参数变量列表的传递过程。</li><li>当方法调用结束后，随着方法栈帧的销毁，局部变量表也会随之销毁。</li></ul></li></ul><h3 id="1-2-示例"><a href="#1-2-示例" class="headerlink" title="1.2 示例"></a>1.2 示例</h3><pre><code class="highlight java"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">LocalVariablesTest</span> &#123;    <span class="keyword">private</span> <span class="type">int</span> <span class="variable">count</span> <span class="operator">=</span> <span class="number">0</span>;    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;        <span class="type">LocalVariablesTest</span> <span class="variable">test</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">LocalVariablesTest</span>();        <span class="type">int</span> <span class="variable">num</span> <span class="operator">=</span> <span class="number">10</span>;        test.test1();    &#125;    <span class="comment">//练习：</span>    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">testStatic</span><span class="params">()</span>&#123;        <span class="type">LocalVariablesTest</span> <span class="variable">test</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">LocalVariablesTest</span>();        <span class="type">Date</span> <span class="variable">date</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Date</span>();        <span class="type">int</span> <span class="variable">count</span> <span class="operator">=</span> <span class="number">10</span>;        System.out.println(count);        <span class="comment">//因为this变量不存在于当前方法的局部变量表中！！</span><span class="comment">//        System.out.println(this.count);</span>    &#125;    <span class="comment">//关于Slot的使用的理解</span>    <span class="keyword">public</span> <span class="title function_">LocalVariablesTest</span><span class="params">()</span>&#123;        <span class="built_in">this</span>.count = <span class="number">1</span>;    &#125;    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">test1</span><span class="params">()</span> &#123;        <span class="type">Date</span> <span class="variable">date</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Date</span>();        <span class="type">String</span> <span class="variable">name1</span> <span class="operator">=</span> <span class="string">&quot;atguigu.com&quot;</span>;        test2(date, name1);        System.out.println(date + name1);    &#125;    <span class="keyword">public</span> String <span class="title function_">test2</span><span class="params">(Date dateP, String name2)</span> &#123;        dateP = <span class="literal">null</span>;        name2 = <span class="string">&quot;songhongkang&quot;</span>;        <span class="type">double</span> <span class="variable">weight</span> <span class="operator">=</span> <span class="number">130.5</span>;<span class="comment">//占据两个slot</span>        <span class="type">char</span> <span class="variable">gender</span> <span class="operator">=</span> <span class="string">&#x27;男&#x27;</span>;        <span class="keyword">return</span> dateP + name2;    &#125;    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">test3</span><span class="params">()</span> &#123;        <span class="built_in">this</span>.count++;    &#125;    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">test4</span><span class="params">()</span> &#123;        <span class="type">int</span> <span class="variable">a</span> <span class="operator">=</span> <span class="number">0</span>;        &#123;            <span class="type">String</span> <span class="variable">j</span> <span class="operator">=</span> <span class="string">&quot;George&quot;</span>;            <span class="type">String</span> <span class="variable">p</span> <span class="operator">=</span> <span class="string">&quot;Chan&quot;</span>;            System.out.println(j);            System.out.println(p);            <span class="type">int</span> <span class="variable">b</span> <span class="operator">=</span> <span class="number">0</span>;            b = a + <span class="number">1</span>;        &#125;        <span class="comment">//变量c使用之前已经销毁的变量b占据的slot的位置</span>        <span class="type">int</span> <span class="variable">c</span> <span class="operator">=</span> a + <span class="number">1</span>;    &#125;    <span class="comment">/*</span><span class="comment">    变量的分类：按照数据类型分：① 基本数据类型  ② 引用数据类型</span><span class="comment">                按照在类中声明的位置分：① 成员变量：在使用前，都经历过默认初始化赋值</span><span class="comment">                                                类变量： linking的prepare阶段：给类变量默认赋值  ---&gt; initial阶段：给类变量显式赋值即静态代码块赋值</span><span class="comment">                                                实例变量：随着对象的创建，会在堆空间中分配实例变量空间，并进行默认赋值</span><span class="comment">                                       ② 局部变量：在使用前，必须要进行显式赋值的！否则，编译不通过</span><span class="comment">     */</span>    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">test5Temp</span><span class="params">()</span>&#123;        <span class="type">int</span> num;        <span class="comment">//System.out.println(num);//错误信息：变量num未进行初始化</span>    &#125;&#125;</code></pre><img src="https://raw.githubusercontent.com/GeorgeChan95/blogimg/master/img/2023/11/29/20231129-191609.png" alt="image-20231129191607535" style="zoom:50%;" /><h3 id="1-3-部分详解"><a href="#1-3-部分详解" class="headerlink" title="1.3 部分详解"></a>1.3 部分详解</h3><p>下面以main方法为例</p><h4 id="Bytecode"><a href="#Bytecode" class="headerlink" title="Bytecode"></a>Bytecode</h4><p>0-15表示main方法编译成字节码后有16行。</p><p><img src="https://raw.githubusercontent.com/GeorgeChan95/blogimg/master/img/2023/11/29/20231129-192403.png" alt="image-20231129192402449"></p><h4 id="Exception-Table"><a href="#Exception-Table" class="headerlink" title="Exception Table"></a>Exception Table</h4><p>异常表。由于main()方法没有声明异常，所以异常表为空。</p><p><img src="https://raw.githubusercontent.com/GeorgeChan95/blogimg/master/img/2023/11/29/20231129-192508.png" alt="image-20231129192506846"></p><h4 id="Misc"><a href="#Misc" class="headerlink" title="Misc"></a>Misc</h4><ul><li>Maximum stack size : 2 <ul><li>最大栈深度，2表示最多同时会往此方法的 <code>操作数栈</code> 中压入两个变量</li></ul></li><li>Maximum local variables : 3<ul><li>局部变量数，这里对应着 args、test、num</li></ul></li><li>Code length : 16<ul><li>字节码行数</li></ul></li></ul><p><img src="https://raw.githubusercontent.com/GeorgeChan95/blogimg/master/img/2023/11/29/20231129-193742.png" alt="image-20231129193741378"></p><h4 id="LineNumberTable"><a href="#LineNumberTable" class="headerlink" title="LineNumberTable"></a>LineNumberTable</h4><ul><li>行号表<ul><li>将编译后字节码指令行号(Bytecode)与Java代码行号对应起来</li></ul></li></ul><p><img src="https://raw.githubusercontent.com/GeorgeChan95/blogimg/master/img/2023/11/29/20231129-194412.png" alt="image-20231129194411074"></p><p><img src="https://raw.githubusercontent.com/GeorgeChan95/blogimg/master/img/2023/11/29/20231129-192403.png" alt="image-20231129192402449"></p><h4 id="LocalVariableTable"><a href="#LocalVariableTable" class="headerlink" title="LocalVariableTable"></a>LocalVariableTable</h4><ul><li>局部变量表<ul><li>作用：保存方法的局部变量的索引和变量的作用范围信息</li><li>Start PC<ul><li>变量在字节码指令中的行号，变量从这里开始生效。</li></ul></li><li>Length<ul><li>变量在字节码指令中，从Start PC开始，向下有效的行数。(由于字节码行号从0开始，所以Length需要减1，否则可能会超过字节码总行数)</li></ul></li><li>Index<ul><li>在局部变量表中的索引位置(成员方法索引位置为0的位置参数默认是 <code>this</code> )</li></ul></li><li>Name<ul><li>参数名</li></ul></li><li>Descriptor<ul><li>参数的描述信息</li><li>[Ljava&#x2F;lang&#x2F;String; <ul><li>表示参数为String类型的数组，L表示引用类型</li></ul></li><li>I 表示参数为 int类型</li></ul></li></ul></li></ul><img src="https://raw.githubusercontent.com/GeorgeChan95/blogimg/master/img/2023/11/29/20231129-194716.png" alt="image-20231129194715444"  /><h2 id="2-关于Slot的理解"><a href="#2-关于Slot的理解" class="headerlink" title="2. 关于Slot的理解"></a>2. 关于Slot的理解</h2><ul><li><p>参数值的存放总是从局部变量数组索引 0 的位置开始，到数组长度-1的索引结束。</p></li><li><p>局部变量表，<strong>最基本的存储单元是Slot（变量槽）</strong>，局部变量表中存放编译期可知的各种基本数据类型（8种），引用类型（reference），returnAddress类型的变量。</p></li><li><p>在局部变量表里，<strong>32位以内的类型只占用一个slot</strong>（包括returnAddress类型），<strong>64位的类型占用两个slot</strong>（1ong和double）。</p><ul><li>byte、short、char在储存前被转换为int，boolean也被转换为int，0表示false，非0表示true</li><li>long和double则占据两个slot</li></ul></li><li><p>JVM会为局部变量表中的每一个Slot都分配一个访问索引，通过这个索引即可成功访问到局部变量表中指定的局部变量值</p></li><li><p>当一个实例方法被调用的时候，它的方法参数和方法体内部定义的局部变量将会<strong>按照顺序被复制</strong>到局部变量表中的每一个slot上</p></li><li><p>如果需要访问局部变量表中一个64bit的局部变量值时，只需要使用前一个索引即可。（比如：访问long或double类型变量）</p></li><li><p>如果当前帧是由构造方法或者实例方法创建的，那么<strong>该对象引用this将会存放在index为0的slot处</strong>，其余的参数按照参数表顺序继续排列。（this也相当于一个变量）</p></li></ul><p><img src="https://raw.githubusercontent.com/GeorgeChan95/blogimg/master/img/2023/11/30/20231130-092013.png" alt="image-20231130092010061"></p><h3 id="2-1-代码示例"><a href="#2-1-代码示例" class="headerlink" title="2.1 代码示例"></a>2.1 代码示例</h3><p><strong>this 存放在 index &#x3D; 0 的位置：</strong></p><pre><code class="highlight java"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">test3</span><span class="params">()</span> &#123;<span class="built_in">this</span>.count++;&#125;</code></pre><p><img src="https://raw.githubusercontent.com/GeorgeChan95/blogimg/master/img/2023/11/30/20231130-093254.png" alt="image-20231130093253042"></p><p><strong>64位的类型（ long 和 double ）占用两个slot</strong></p><pre><code class="highlight java"><span class="keyword">public</span> String <span class="title function_">test2</span><span class="params">(Date dateP, String name2)</span> &#123;    dateP = <span class="literal">null</span>;    name2 = <span class="string">&quot;songhongkang&quot;</span>;    <span class="type">double</span> <span class="variable">weight</span> <span class="operator">=</span> <span class="number">130.5</span>;<span class="comment">//占据两个slot</span>    <span class="type">char</span> <span class="variable">gender</span> <span class="operator">=</span> <span class="string">&#x27;男&#x27;</span>;    <span class="keyword">return</span> dateP + name2;&#125;</code></pre><p>weight 为 double 类型， 占用了3和4两个index 索引位</p><p><img src="https://raw.githubusercontent.com/GeorgeChan95/blogimg/master/img/2023/11/30/20231130-094139.png" alt="image-20231130094138168"></p><p><strong>static 无法调用 this</strong></p><p>this 不存在与 static 方法的局部变量表中，所以无法调用</p><pre><code class="highlight java"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">testStatic</span><span class="params">()</span>&#123;    <span class="type">LocalVariablesTest</span> <span class="variable">test</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">LocalVariablesTest</span>();    <span class="type">Date</span> <span class="variable">date</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Date</span>();    <span class="type">int</span> <span class="variable">count</span> <span class="operator">=</span> <span class="number">10</span>;    System.out.println(count);    <span class="comment">//因为this变量不存在于当前方法的局部变量表中！！</span><span class="comment">// System.out.println(this.count);</span>&#125;</code></pre><h3 id="2-2-Slot的重复利用"><a href="#2-2-Slot的重复利用" class="headerlink" title="2.2 Slot的重复利用"></a>2.2 Slot的重复利用</h3><p>栈帧中的局部变量表中的槽位是可以重用的，如果一个局部变量过了其作用域，那么在其作用域之后申明新的局部变量变就很有可能会复用过期局部变量的槽位，从而达到节省资源的目的。</p><pre><code class="highlight java"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">test4</span><span class="params">()</span> &#123;    <span class="type">int</span> <span class="variable">a</span> <span class="operator">=</span> <span class="number">0</span>;    &#123;        <span class="type">String</span> <span class="variable">j</span> <span class="operator">=</span> <span class="string">&quot;George&quot;</span>;        <span class="type">String</span> <span class="variable">p</span> <span class="operator">=</span> <span class="string">&quot;Chan&quot;</span>;        System.out.println(j);        System.out.println(p);        <span class="type">int</span> <span class="variable">b</span> <span class="operator">=</span> <span class="number">0</span>;        b = a + <span class="number">1</span>;    &#125;    <span class="comment">//变量c使用之前已经销毁的变量b占据的slot的位置</span>    <span class="type">int</span> <span class="variable">c</span> <span class="operator">=</span> a + <span class="number">1</span>;&#125;</code></pre><p>局部变量 c 重用了局部变量 j 的 slot 位置</p><p><img src="https://raw.githubusercontent.com/GeorgeChan95/blogimg/master/img/2023/11/30/20231130-095006.png" alt="image-20231130095004942"></p><h2 id="3-静态变量与局部变量的对比"><a href="#3-静态变量与局部变量的对比" class="headerlink" title="3. 静态变量与局部变量的对比"></a>3. 静态变量与局部变量的对比</h2><h3 id="3-1-变量的分类"><a href="#3-1-变量的分类" class="headerlink" title="3.1 变量的分类"></a>3.1 变量的分类</h3><ul><li>按照数据类型分<ul><li>基本数据类型</li><li>引用数据类型</li></ul></li><li>按照在类中声明的位置分<ul><li>成员变量：在使用前，都经历过默认初始化赋值<ul><li>类变量：<ul><li>linking的prepare阶段：给类变量默认赋值</li><li>initial阶段：给类变量显式赋值即静态代码块赋值</li></ul></li><li>实例变量：<ul><li>随着对象的创建，会在堆空间中分配实例变量空间，并进行默认赋值</li></ul></li></ul></li><li>局部变量：在使用前，必须要进行显式赋值的！否则，编译不通过。</li></ul></li></ul><h3 id="3-2-总结"><a href="#3-2-总结" class="headerlink" title="3.2 总结"></a>3.2 总结</h3><ul><li>参数表分配完毕之后，再根据方法体内定义的变量的顺序和作用域分配。</li><li>成员变量有两次初始化的机会，第一次是在“准备阶段”，执行系统初始化，对类变量设置零值，另一次则是在“初始化”阶段，赋予程序员在代码中定义的初始值。</li><li>和类变量初始化不同的是，<strong>局部变量表不存在系统初始化的过程</strong>，这意味着一旦定义了局部变量则必须人为的初始化，否则无法使用。</li></ul><h3 id="3-3-补充说明"><a href="#3-3-补充说明" class="headerlink" title="3.3 补充说明"></a>3.3 补充说明</h3><ul><li>在栈帧中，与性能调优关系最为密切的部分就是前面提到的局部变量表。在方法执行时，虚拟机使用局部变量表完成方法的传递。</li><li>局部变量表中的变量也是重要的垃圾回收根节点，只要被局部变量表中直接或间接引用的对象都不会被回收。</li></ul><h2 id="四、操作数栈"><a href="#四、操作数栈" class="headerlink" title="四、操作数栈"></a>四、操作数栈</h2><h3 id="1-操作数栈的特点"><a href="#1-操作数栈的特点" class="headerlink" title="1. 操作数栈的特点"></a>1. 操作数栈的特点</h3><ul><li>每一个独立的栈帧除了包含局部变量表以外，还包含一个后进先出（Last - In - First -Out）的 操作数栈，也可以称之为<strong>表达式栈</strong>（Expression Stack）</li><li>操作数栈，在方法执行过程中，<strong>根据字节码指令，往栈中写入数据或提取数据</strong>，即入栈（push）和 出栈（pop）</li><li>某些字节码指令将值压入操作数栈，其余的字节码指令将操作数取出栈。使用它们后再把结果压入栈<ul><li>比如：执行复制、交换、求和等操作</li></ul></li></ul><img src="https://raw.githubusercontent.com/GeorgeChan95/blogimg/master/img/2023/11/30/20231130-100454.png" alt="操作数栈" style="zoom:50%;" /><img src="https://raw.githubusercontent.com/GeorgeChan95/blogimg/master/img/2023/11/30/20231130-100652.png" alt="操作数栈2" style="zoom:67%;" /><h3 id="2-操作数栈的作用"><a href="#2-操作数栈的作用" class="headerlink" title="2. 操作数栈的作用"></a>2. 操作数栈的作用</h3><ul><li>操作数栈，<strong>主要用于保存计算过程的中间结果，同时作为计算过程中变量临时的存储空间</strong>。</li><li>操作数栈就是JVM执行引擎的一个工作区，当一个方法刚开始执行的时候，一个新的栈帧也会随之被创建出来，这时方法的操作数栈是空的。</li><li>每一个操作数栈都会拥有一个明确的栈深度用于存储数值，其所需的最大深度在编译期就定义好了，保存在方法的Code属性中，为<strong>maxstack</strong>的值。</li><li>栈中的任何一个元素都是可以任意的Java数据类型<ul><li>32bit的类型占用一个栈单位深度</li><li>64bit的类型占用两个栈单位深度</li></ul></li><li>操作数栈并非采用访问索引的方式来进行数据访问的，而是只能通过标准的入栈和出栈操作来完成一次数据访问。<strong>只不过操作数栈是用数组这个结构来实现的而已</strong></li><li>如果被调用的方法带有返回值的话，其返回值将会被压入当前栈帧的操作数栈中，并更新PC寄存器中下一条需要执行的字节码指令。</li><li>操作数栈中元素的数据类型必须与字节码指令的序列严格匹配，这由编译器在编译器期间进行验证，同时在类加载过程中的类检验阶段的数据流分析阶段要再次验证。</li><li>另外，<strong>我们说Java虚拟机的解释引擎是基于栈的执行引擎，其中的栈指的就是操作数栈</strong>。</li></ul><h3 id="3-操作数栈代码追踪"><a href="#3-操作数栈代码追踪" class="headerlink" title="3. 操作数栈代码追踪"></a>3. 操作数栈代码追踪</h3><blockquote><p>Java代码</p></blockquote><pre><code class="highlight java"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">testAddOperation</span><span class="params">()</span> &#123;    <span class="comment">//byte、short、char、boolean：都以int型来保存</span>    <span class="type">byte</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">15</span>;    <span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> <span class="number">8</span>;    <span class="type">int</span> <span class="variable">k</span> <span class="operator">=</span> i + j;&#125;</code></pre><blockquote><p>对应字节码指令</p></blockquote><pre><code class="highlight plaintext"> 0 bipush 15 2 istore_1 3 bipush 8 5 istore_2 6 iload_1 7 iload_2 8 iadd 9 istore_310 return</code></pre><h4 id="具体执行流程"><a href="#具体执行流程" class="headerlink" title="具体执行流程"></a>具体执行流程</h4><p>1、首先执行第一条语句，PC寄存器指向的是0，也就是指令地址为0，然后使用bipush让操作数15入操作数栈。</p><p><img src="https://raw.githubusercontent.com/GeorgeChan95/blogimg/master/img/2023/11/30/20231130-103909.png" alt="image-20231130103907694"></p><p>2、执行完后，PC寄存器往下移，指向下一行代码，下一行代码就是将操作数栈的元素存储到局部变量表1的位置（istore_1），我们可以看到局部变量表的已经增加了一个元素，并且操作数栈为空了。</p><ul><li>解释为什么局部变量表索引从 1 开始，因为该方法为实例方法，局部变量表索引为 0 的位置存放的是 this</li></ul><p><img src="https://raw.githubusercontent.com/GeorgeChan95/blogimg/master/img/2023/11/30/20231130-104032.png" alt="image-20231130104030850"></p><p>3、然后PC下移，指向的是下一行。让操作数8也入栈，同时执行store操作，存入局部变量表中</p><p><img src="https://raw.githubusercontent.com/GeorgeChan95/blogimg/master/img/2023/11/30/20231130-104137.png" alt="image-20231130104135613"></p><p>4、PC寄存器往下移，指向下一行代码，将操作数栈的元素8存储到局部变量表索引为 2 的位置（<code>istore_2</code>）</p><p><img src="https://raw.githubusercontent.com/GeorgeChan95/blogimg/master/img/2023/11/30/20231130-104333.png" alt="image-20231130104332206"></p><p>5、从局部变量表中，依次将数据取出放在操作数栈中，等待执行 add 操作</p><ul><li>iload_1：取出局部变量表中索引为1的数据入操作数栈</li><li>iload_2：取出局部变量表中索引为2的数据入操作数栈</li></ul><p><img src="https://raw.githubusercontent.com/GeorgeChan95/blogimg/master/img/2023/11/30/20231130-104553.png" alt="image-20231130104551702"></p><p><img src="https://raw.githubusercontent.com/GeorgeChan95/blogimg/master/img/2023/11/30/20231130-104728.png" alt="image-20231130104551702"></p><p>6、将操作数栈中的两个元素执行相加操作，并存储在局部变量表3的位置</p><p><img src="https://raw.githubusercontent.com/GeorgeChan95/blogimg/master/img/2023/11/30/20231130-104835.png" alt="image-20231130104834157"></p><p><img src="https://raw.githubusercontent.com/GeorgeChan95/blogimg/master/img/2023/11/30/20231130-104858.png" alt="image-20231130104857485"></p><h3 id="4-常见问题"><a href="#4-常见问题" class="headerlink" title="4. 常见问题"></a>4. 常见问题</h3><h4 id="4-1-关于类型转换的说明"><a href="#4-1-关于类型转换的说明" class="headerlink" title="4.1 关于类型转换的说明"></a>4.1 关于类型转换的说明</h4><ul><li>因为 15 可以存放在 byte 类型中，所以压入操作数栈的类型为 byte ，而不是 int ，所以执行的字节码指令为 bipush 15</li><li>但是存储在局部变量的时候，会转成 int 类型的变量：istore_1</li><li>如果数值超过了byte类型能存储的数据值范围，存储局部变量表时会使用更大的类型，如 <code>sipush 800</code></li></ul><p><img src="https://raw.githubusercontent.com/GeorgeChan95/blogimg/master/img/2023/11/30/20231130-105244.png" alt="image-20231130105242980"></p><h4 id="4-2-方法带有返回值"><a href="#4-2-方法带有返回值" class="headerlink" title="4.2 方法带有返回值"></a>4.2 方法带有返回值</h4><ul><li>如果被调用的方法带有返回值，返回值入操作数栈</li></ul><pre><code class="highlight java"><span class="keyword">public</span> <span class="type">int</span> <span class="title function_">getSum</span><span class="params">()</span>&#123;    <span class="type">int</span> <span class="variable">m</span> <span class="operator">=</span> <span class="number">10</span>;    <span class="type">int</span> <span class="variable">n</span> <span class="operator">=</span> <span class="number">20</span>;    <span class="type">int</span> <span class="variable">k</span> <span class="operator">=</span> m + n;    <span class="keyword">return</span> k;&#125;<span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">testGetSum</span><span class="params">()</span>&#123;    <span class="comment">//获取上一个栈桢返回的结果，并保存在操作数栈中</span>    <span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> getSum();    <span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> <span class="number">10</span>;&#125;</code></pre><ul><li>getSum() 方法字节码指令：最后带着个 <code>ireturn</code></li></ul><p><img src="https://raw.githubusercontent.com/GeorgeChan95/blogimg/master/img/2023/11/30/20231130-105742.png" alt="image-20231130105740956"></p><ul><li>testGetSum() 方法字节码指令：一上来就加载 getSum() 方法的返回值()</li></ul><p><img src="https://raw.githubusercontent.com/GeorgeChan95/blogimg/master/img/2023/11/30/20231130-105824.png" alt="image-20231130105823472"></p><p>解释：<code>aload_0</code> 加载的是 <strong>this 变量</strong>，然后通过 this 变量执行  <code>invokevirtual</code> 指令调用 <code>getSum</code> 方法计算结果，然后将计算的结果 通过 <code>istore_1</code> 存储到局部变量表<strong>索引为 1</strong> 的位置</p><h1 id="五、栈顶缓存技术"><a href="#五、栈顶缓存技术" class="headerlink" title="五、栈顶缓存技术"></a>五、栈顶缓存技术</h1><p><strong>栈顶缓存技术：Top Of Stack Cashing</strong></p><ul><li>基于栈式架构的虚拟机所使用的零地址指令更加紧凑，但完成一项操作的时候必然需要使用更多的入栈和出栈指令，这同时也就意味着将需要更多的指令分派（instruction dispatch）次数（也就是你会发现指令很多）和导致内存读&#x2F;写次数多，效率不高。</li><li>由于操作数是存储在内存中的，因此频繁地执行内存读&#x2F;写操作必然会影响执行速度。为了解决这个问题，HotSpot JVM的设计者们提出了栈顶缓存（Tos，Top-of-Stack Cashing）技术，<strong>将栈顶元素全部缓存在物理CPU的寄存器中，以此降低对内存的读&#x2F;写次数，提升执行引擎的执行效率。</strong></li><li>寄存器的主要优点：指令更少，执行速度快，但是指令集（也就是指令种类）很多</li></ul><h1 id="六、动态链接"><a href="#六、动态链接" class="headerlink" title="六、动态链接"></a>六、动态链接</h1><p><strong>动态链接（或指向运行时常量池的方法引用）</strong></p><ul><li>每一个栈帧内部都包含<strong>一个指向运行时常量池中该栈帧所属方法的引用</strong>。包含这个引用的目的就是<strong>为了支持当前方法的代码能够实现动态链接</strong>（Dynamic Linking），比如：invokedynamic指令</li><li>在Java源文件被编译到字节码文件中时，所有的变量和方法引用都作为符号引用（Symbolic Reference）保存在class文件的常量池里。比如：描述一个方法调用了另外的其他方法时，就是通过常量池中指向方法的符号引用来表示的，那么<strong>动态链接的作用就是为了将这些符号引用转换为调用方法的直接引用</strong></li></ul><blockquote><p>Java源代码</p></blockquote><pre><code class="highlight java"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">DynamicLinkingTest</span> &#123;    <span class="type">int</span> <span class="variable">num</span> <span class="operator">=</span> <span class="number">10</span>;    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">methodA</span><span class="params">()</span>&#123;        System.out.println(<span class="string">&quot;methodA()....&quot;</span>);    &#125;    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">methodB</span><span class="params">()</span>&#123;        System.out.println(<span class="string">&quot;methodB()....&quot;</span>);        methodA();        num++;    &#125;&#125;</code></pre><blockquote><p>字节码</p></blockquote><pre><code class="highlight plaintext">Classfile /H:/code_test/JVMDemo/out/production/chapter05/com/atguigu/java1/DynamicLinkingTest.class  Last modified 2023-11-28; size 712 bytes         MD5 checksum e56913c945f897c7ee6c0a608629bca8    Compiled from &quot;DynamicLinkingTest.java&quot;        public class com.atguigu.java1.DynamicLinkingTest  minor version: 0  major version: 52  flags: ACC_PUBLIC, ACC_SUPERConstant pool:   #1 = Methodref          #9.#23         // java/lang/Object.&quot;&lt;init&gt;&quot;:()V   #2 = Fieldref           #8.#24         // com/atguigu/java1/DynamicLinkingTest.num:I   #3 = Fieldref           #25.#26        // java/lang/System.out:Ljava/io/PrintStream;   #4 = String             #27            // methodA()....   #5 = Methodref          #28.#29        // java/io/PrintStream.println:(Ljava/lang/String;)V   #6 = String             #30            // methodB()....   #7 = Methodref          #8.#31         // com/atguigu/java1/DynamicLinkingTest.methodA:()V   #8 = Class              #32            // com/atguigu/java1/DynamicLinkingTest   #9 = Class              #33            // java/lang/Object  #10 = Utf8               num  #11 = Utf8               I  #12 = Utf8               &lt;init&gt;  #13 = Utf8               ()V  #14 = Utf8               Code  #15 = Utf8               LineNumberTable  #16 = Utf8               LocalVariableTable  #17 = Utf8               this  #18 = Utf8               Lcom/atguigu/java1/DynamicLinkingTest;  #19 = Utf8               methodA  #20 = Utf8               methodB  #21 = Utf8               SourceFile  #22 = Utf8               DynamicLinkingTest.java  #23 = NameAndType        #12:#13        // &quot;&lt;init&gt;&quot;:()V  #24 = NameAndType        #10:#11        // num:I  #25 = Class              #34            // java/lang/System  #26 = NameAndType        #35:#36        // out:Ljava/io/PrintStream;  #27 = Utf8               methodA()....  #28 = Class              #37            // java/io/PrintStream  #29 = NameAndType        #38:#39        // println:(Ljava/lang/String;)V  #30 = Utf8               methodB()....  #31 = NameAndType        #19:#13        // methodA:()V  #32 = Utf8               com/atguigu/java1/DynamicLinkingTest  #33 = Utf8               java/lang/Object  #34 = Utf8               java/lang/System  #35 = Utf8               out  #36 = Utf8               Ljava/io/PrintStream;  #37 = Utf8               java/io/PrintStream  #38 = Utf8               println  #39 = Utf8               (Ljava/lang/String;)V&#123;  int num;    descriptor: I    flags:  public com.atguigu.java1.DynamicLinkingTest();    descriptor: ()V    flags: ACC_PUBLIC    Code:      stack=2, locals=1, args_size=1         0: aload_0         1: invokespecial #1                  // Method java/lang/Object.&quot;&lt;init&gt;&quot;:()V         4: aload_0         5: bipush        10         7: putfield      #2                  // Field num:I        10: return      LineNumberTable:        line 7: 0        line 9: 4      LocalVariableTable:        Start  Length  Slot  Name   Signature            0      11     0  this   Lcom/atguigu/java1/DynamicLinkingTest;  public void methodA();    descriptor: ()V    flags: ACC_PUBLIC    Code:      stack=2, locals=1, args_size=1         0: getstatic     #3                  // Field java/lang/System.out:Ljava/io/PrintStream;         3: ldc           #4                  // String methodA()....         5: invokevirtual #5                  // Method java/io/PrintStream.println:(Ljava/lang/String;)V         8: return      LineNumberTable:        line 12: 0        line 13: 8      LocalVariableTable:        Start  Length  Slot  Name   Signature            0       9     0  this   Lcom/atguigu/java1/DynamicLinkingTest;  public void methodB();    descriptor: ()V    flags: ACC_PUBLIC    Code:      stack=3, locals=1, args_size=1         0: getstatic     #3                  // Field java/lang/System.out:Ljava/io/PrintStream;         3: ldc           #6                  // String methodB()....         5: invokevirtual #5                  // Method java/io/PrintStream.println:(Ljava/lang/String;)V         8: aload_0         9: invokevirtual #7                  // Method methodA:()V        12: aload_0        13: dup        14: getfield      #2                  // Field num:I        17: iconst_1        18: iadd        19: putfield      #2                  // Field num:I        22: return      LineNumberTable:        line 16: 0        line 18: 8        line 20: 12        line 21: 22      LocalVariableTable:        Start  Length  Slot  Name   Signature            0      23     0  this   Lcom/atguigu/java1/DynamicLinkingTest;&#125;SourceFile: &quot;DynamicLinkingTest.java&quot;</code></pre><p>1、在字节码指令中，methodB() 方法中通过 invokevirtual #7 指令调用了方法 A ，那么 #7 是个啥呢？</p><p>2、往上面翻，找到常量池的定义：<code>#7 = Methodref #8.#31</code></p><ul><li>先找 #8 ：<ul><li><code>#8 = Class #32</code> ：去找 #32</li><li><code>#32 = Utf8 com/atguigu/java1/DynamicLinkingTest</code></li><li>结论：通过 #8 我们找到了 <code>DynamicLinkingTest</code> 这个类</li></ul></li><li>再来找 #31：<ul><li><code>#31 = NameAndType #19:#13</code> ：去找 #19 和 #13</li><li><code>#19 = Utf8 methodA</code> ：方法名为 methodA</li><li><code>#13 = Utf8 ()V</code> ：方法没有形参，返回值为 void</li></ul></li></ul><p>3、结论：通过 #7 我们就能找到需要调用的 methodA() 方法，并进行调用</p><p>4、在上面，其实还有很多符号引用，比如 Object、System、PrintStream 等等</p><p><img src="https://raw.githubusercontent.com/GeorgeChan95/blogimg/master/img/2023/11/30/20231130-113303.png" alt="运行时常量池"></p><p><strong>为什么要用常量池呢？</strong></p><ul><li>因为在不同的方法，都可能调用常量或者方法，所以只需要存储一份即可，然后记录其引用即可，节省了空间。</li><li>常量池的作用：就是为了提供一些符号和常量，便于指令的识别</li></ul><h1 id="七、方法的调用"><a href="#七、方法的调用" class="headerlink" title="七、方法的调用"></a>七、方法的调用</h1><h2 id="1-静态链接与动态链接"><a href="#1-静态链接与动态链接" class="headerlink" title="1. 静态链接与动态链接"></a>1. 静态链接与动态链接</h2><p>在JVM中，将符号引用转换为调用方法的直接引用与方法的绑定机制相关</p><ul><li><p>静态链接</p><p>当一个字节码文件被装载进JVM内部时，如果被调用的目标方法在编译期确定，且运行期保持不变时，这种情况下将调用方法的符号引用转换为直接引用的过程称之为静态链接</p></li><li><p>动态链接</p><p>如果被调用的方法在编译期无法被确定下来，也就是说，只能够在程序运行期将调用的方法的符号转换为直接引用，由于这种引用转换过程具备动态性，因此也被称之为动态链接。</p></li></ul><h2 id="2-早期绑定与晚期绑定"><a href="#2-早期绑定与晚期绑定" class="headerlink" title="2. 早期绑定与晚期绑定"></a>2. 早期绑定与晚期绑定</h2><p>静态链接与动态链接针对的是方法，早期绑定和晚期绑定范围更广。早期绑定涵盖了静态链接，晚期绑定涵盖了动态链接。</p><p>静态链接和动态链接对应的方法的绑定机制为：早期绑定（Early Binding）和晚期绑定（Late Binding）。<strong>绑定是一个字段、方法或者类在符号引用被替换为直接引用的过程</strong>，这仅仅发生一次。</p><ul><li><p>早期绑定</p><p>早期绑定就是指被调用的目标方法如果在编译期可知，且运行期保持不变时，即可将这个方法与所属的类型进行绑定，这样一来，由于明确了被调用的目标方法究竟是哪一个，因此也就<strong>可以使用静态链接的方式将符号引用转换为直接引用</strong>。</p></li><li><p>晚期绑定</p><p>如果被调用的方法在编译期无法被确定下来，<strong>只能够在程序运行期根据实际的类型绑定相关的方法</strong>，这种绑定方式也就被称之为晚期绑定。</p></li></ul><blockquote><p>JAVA 源码</p></blockquote><pre><code class="highlight java"><span class="keyword">class</span> <span class="title class_">Animal</span>&#123;    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">eat</span><span class="params">()</span>&#123;        System.out.println(<span class="string">&quot;动物进食&quot;</span>);    &#125;&#125;<span class="keyword">interface</span> <span class="title class_">Huntable</span>&#123;    <span class="keyword">void</span> <span class="title function_">hunt</span><span class="params">()</span>;&#125;<span class="keyword">class</span> <span class="title class_">Dog</span> <span class="keyword">extends</span> <span class="title class_">Animal</span> <span class="keyword">implements</span> <span class="title class_">Huntable</span>&#123;    <span class="meta">@Override</span>    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">eat</span><span class="params">()</span> &#123;        System.out.println(<span class="string">&quot;狗吃骨头&quot;</span>);    &#125;    <span class="meta">@Override</span>    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">hunt</span><span class="params">()</span> &#123;        System.out.println(<span class="string">&quot;捕食耗子，多管闲事&quot;</span>);    &#125;&#125;<span class="keyword">class</span> <span class="title class_">Cat</span> <span class="keyword">extends</span> <span class="title class_">Animal</span> <span class="keyword">implements</span> <span class="title class_">Huntable</span>&#123;    <span class="keyword">public</span> <span class="title function_">Cat</span><span class="params">()</span>&#123;        <span class="built_in">super</span>();<span class="comment">//表现为：早期绑定</span>    &#125;    <span class="keyword">public</span> <span class="title function_">Cat</span><span class="params">(String name)</span>&#123;        <span class="built_in">this</span>();<span class="comment">//表现为：早期绑定</span>    &#125;    <span class="meta">@Override</span>    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">eat</span><span class="params">()</span> &#123;        <span class="built_in">super</span>.eat();<span class="comment">//表现为：早期绑定</span>        System.out.println(<span class="string">&quot;猫吃鱼&quot;</span>);    &#125;    <span class="meta">@Override</span>    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">hunt</span><span class="params">()</span> &#123;        System.out.println(<span class="string">&quot;捕食耗子，天经地义&quot;</span>);    &#125;&#125;<span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">AnimalTest</span> &#123;    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">showAnimal</span><span class="params">(Animal animal)</span>&#123;        animal.eat();<span class="comment">//表现为：晚期绑定</span>    &#125;    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">showHunt</span><span class="params">(Huntable h)</span>&#123;        h.hunt();<span class="comment">//表现为：晚期绑定</span>    &#125;&#125;</code></pre><blockquote><p>字节码</p></blockquote><p><strong>执行命令：</strong> <code>javap -v AnimalTest.class</code></p><pre><code class="highlight plaintext">Classfile /H:/code_test/JVMDemo/out/production/chapter05/com/atguigu/java2/AnimalTest.class  Last modified 2023-11-28; size 701 bytes  MD5 checksum 874899c4a820e8bd8fa1d408ae7a36c0  Compiled from &quot;AnimalTest.java&quot;public class com.atguigu.java2.AnimalTest  minor version: 0  major version: 52  flags: ACC_PUBLIC, ACC_SUPERConstant pool:   #1 = Methodref          #5.#23         // java/lang/Object.&quot;&lt;init&gt;&quot;:()V   #2 = Methodref          #24.#25        // com/atguigu/java2/Animal.eat:()V   #3 = InterfaceMethodref #26.#27        // com/atguigu/java2/Huntable.hunt:()V   #4 = Class              #28            // com/atguigu/java2/AnimalTest   #5 = Class              #29            // java/lang/Object   #6 = Utf8               &lt;init&gt;   #7 = Utf8               ()V   #8 = Utf8               Code   #9 = Utf8               LineNumberTable  #10 = Utf8               LocalVariableTable  #11 = Utf8               this  #12 = Utf8               Lcom/atguigu/java2/AnimalTest;  #13 = Utf8               showAnimal  #14 = Utf8               (Lcom/atguigu/java2/Animal;)V  #15 = Utf8               animal  #16 = Utf8               Lcom/atguigu/java2/Animal;  #17 = Utf8               showHunt  #18 = Utf8               (Lcom/atguigu/java2/Huntable;)V  #19 = Utf8               h  #20 = Utf8               Lcom/atguigu/java2/Huntable;  #21 = Utf8               SourceFile  #22 = Utf8               AnimalTest.java  #23 = NameAndType        #6:#7          // &quot;&lt;init&gt;&quot;:()V  #24 = Class              #30            // com/atguigu/java2/Animal  #25 = NameAndType        #31:#7         // eat:()V  #26 = Class              #32            // com/atguigu/java2/Huntable  #27 = NameAndType        #33:#7         // hunt:()V  #28 = Utf8               com/atguigu/java2/AnimalTest  #29 = Utf8               java/lang/Object  #30 = Utf8               com/atguigu/java2/Animal  #31 = Utf8               eat  #32 = Utf8               com/atguigu/java2/Huntable  #33 = Utf8               hunt&#123;  public com.atguigu.java2.AnimalTest();    descriptor: ()V    flags: ACC_PUBLIC    Code:      stack=1, locals=1, args_size=1         0: aload_0         1: invokespecial #1                  // Method java/lang/Object.&quot;&lt;init&gt;&quot;:()V         4: return      LineNumberTable:        line 50: 0      LocalVariableTable:        Start  Length  Slot  Name   Signature            0       5     0  this   Lcom/atguigu/java2/AnimalTest;  public void showAnimal(com.atguigu.java2.Animal);    descriptor: (Lcom/atguigu/java2/Animal;)V    flags: ACC_PUBLIC    Code:      stack=1, locals=2, args_size=2         0: aload_1    Code:      stack=1, locals=2, args_size=2         0: aload_1         1: invokeinterface #3,  1            // InterfaceMethod com/atguigu/java2/Huntable.hunt:()V         6: return      LineNumberTable:        line 55: 0        line 56: 6      LocalVariableTable:        Start  Length  Slot  Name   Signature            0       7     0  this   Lcom/atguigu/java2/AnimalTest;            0       7     1     h   Lcom/atguigu/java2/Huntable;&#125;SourceFile: &quot;AnimalTest.java&quot;</code></pre><ul><li><p><strong>invokevirtual</strong>  体现为晚期绑定</p></li><li><p><strong>invokeinterface</strong>  也体现为晚期绑定</p></li><li><p><strong>invokespecial</strong>  体现为早期绑定</p></li></ul><h2 id="3-多态与绑定"><a href="#3-多态与绑定" class="headerlink" title="3. 多态与绑定"></a>3. 多态与绑定</h2><ul><li>随着高级语言的横空出世，类似于Java一样的基于面向对象的编程语言如今越来越多，尽管这类编程语言在语法风格上存在一定的差别，但是它们彼此之间始终保持着一个共性，那就是都支持封装、继承和多态等面向对象特性，既然这一类的编程语言具备多态特性，那么自然也就具备早期绑定和晚期绑定两种绑定方式。</li><li>Java中任何一个普通的方法其实都具备虚函数的特征，它们相当于C++语言中的虚函数（C++中则需要使用关键字virtual来显式定义）。如果在Java程序中不希望某个方法拥有虚函数的特征时，则可以使用关键字final来标记这个方法。</li></ul><h3 id="3-1-虚方法与非虚方法"><a href="#3-1-虚方法与非虚方法" class="headerlink" title="3.1 虚方法与非虚方法"></a>3.1 虚方法与非虚方法</h3><h4 id="虚方法与非虚方法的区别"><a href="#虚方法与非虚方法的区别" class="headerlink" title="虚方法与非虚方法的区别"></a>虚方法与非虚方法的区别</h4><ul><li>如果方法在编译期就确定了具体的调用版本，这个版本在运行时是不可变的。这样的方法称为非虚方法。</li><li>静态方法(static)、私有方法(private)、final方法、实例构造器、父类方法(super)都是非虚方法。</li><li>其他方法称为虚方法。</li></ul><h4 id="多态的使用前提"><a href="#多态的使用前提" class="headerlink" title="多态的使用前提"></a>多态的使用前提</h4><ul><li>存在类的继承</li><li>子类重写父类方法</li></ul><h4 id="虚拟机中调用方法的指令"><a href="#虚拟机中调用方法的指令" class="headerlink" title="虚拟机中调用方法的指令"></a>虚拟机中调用方法的指令</h4><ul><li>普通指令<ul><li>invokestatic：调用静态方法，解析阶段确定唯一方法版本</li><li>invokespecial：调用 <code>&lt;init&gt;</code> (构造器)方法、私有(private)及父类(super)方法，解析阶段确定唯一方法版本</li><li>invokevirtual：调用所有虚方法</li><li>invokeinterface：调用接口方法</li></ul></li><li>动态调用指令<ul><li>invokedynamic：动态解析出需要调用的方法，然后执行</li></ul></li></ul><p>前四条指令固化在虚拟机内部，方法的调用执行不可人为干预。而invokedynamic指令则支持由用户确定方法版本。其中invokestatic指令和invokespecial指令调用的方法称为非虚方法，其余的（final修饰的除外）称为虚方法。</p><p><strong>final 修饰的方法在字节码中也会被标记为 invokevirtual ，但它其实是非虚方法</strong></p><h4 id="示例"><a href="#示例" class="headerlink" title="示例"></a>示例</h4><blockquote><p>JAVA代码</p></blockquote><pre><code class="highlight java"><span class="keyword">class</span> <span class="title class_">Father</span> &#123;    <span class="keyword">public</span> <span class="title function_">Father</span><span class="params">()</span> &#123;        System.out.println(<span class="string">&quot;father的构造器&quot;</span>);    &#125;    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">showStatic</span><span class="params">(String str)</span> &#123;        System.out.println(<span class="string">&quot;father &quot;</span> + str);    &#125;    <span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">void</span> <span class="title function_">showFinal</span><span class="params">()</span> &#123;        System.out.println(<span class="string">&quot;father show final&quot;</span>);    &#125;    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">showCommon</span><span class="params">()</span> &#123;        System.out.println(<span class="string">&quot;father 普通方法&quot;</span>);    &#125;&#125;<span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Son</span> <span class="keyword">extends</span> <span class="title class_">Father</span> &#123;    <span class="keyword">public</span> <span class="title function_">Son</span><span class="params">()</span> &#123;        <span class="comment">//invokespecial</span>        <span class="built_in">super</span>();    &#125;    <span class="keyword">public</span> <span class="title function_">Son</span><span class="params">(<span class="type">int</span> age)</span> &#123;        <span class="comment">//invokespecial</span>        <span class="built_in">this</span>();    &#125;    <span class="comment">//不是重写的父类的静态方法，因为静态方法不能被重写！</span>    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">showStatic</span><span class="params">(String str)</span> &#123;        System.out.println(<span class="string">&quot;son &quot;</span> + str);    &#125;    <span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">showPrivate</span><span class="params">(String str)</span> &#123;        System.out.println(<span class="string">&quot;son private&quot;</span> + str);    &#125;    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">show</span><span class="params">()</span> &#123;        <span class="comment">//invokestatic</span>        showStatic(<span class="string">&quot;atguigu.com&quot;</span>);        <span class="comment">//invokestatic</span>        <span class="built_in">super</span>.showStatic(<span class="string">&quot;good!&quot;</span>);        <span class="comment">//invokespecial</span>        showPrivate(<span class="string">&quot;hello!&quot;</span>);        <span class="comment">//invokespecial</span>        <span class="built_in">super</span>.showCommon();        <span class="comment">//invokevirtual</span>        showFinal();<span class="comment">//因为此方法声明有final，不能被子类重写，所以也认为此方法是非虚方法。</span>        <span class="comment">//虚方法如下：</span>        <span class="comment">//invokevirtual</span>        showCommon();        info();        <span class="type">MethodInterface</span> <span class="variable">in</span> <span class="operator">=</span> <span class="literal">null</span>;        <span class="comment">//invokeinterface</span>        in.methodA();    &#125;    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">info</span><span class="params">()</span>&#123;    &#125;    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">display</span><span class="params">(Father f)</span>&#123;        f.showCommon();    &#125;    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;        <span class="type">Son</span> <span class="variable">so</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Son</span>();        so.show();    &#125;&#125;<span class="keyword">interface</span> <span class="title class_">MethodInterface</span>&#123;    <span class="keyword">void</span> <span class="title function_">methodA</span><span class="params">()</span>;&#125;</code></pre><p>Son 类中 show() 方法的字节码指令如下</p><p><img src="https://raw.githubusercontent.com/GeorgeChan95/blogimg/master/img/2023/11/30/20231130-133257.png" alt="image-20231130133256188"></p><h3 id="3-2-关于-invokedynamic-指令"><a href="#3-2-关于-invokedynamic-指令" class="headerlink" title="3.2 关于 invokedynamic 指令"></a>3.2 关于 invokedynamic 指令</h3><ul><li>JVM字节码指令集一直比较稳定，一直到Java7中才增加了一个invokedynamic指令，这是Java为了实现【动态类型语言】支持而做的一种改进。</li><li>但是在Java7中并没有提供直接生成invokedynamic指令的方法，需要借助ASM这种底层字节码工具来产生invokedynamic指令。直到Java8的Lambda表达式的出现，invokedynamic指令的生成，在Java中才有了直接的生成方式。</li><li>Java7中增加的动态语言类型支持的本质是对Java虚拟机规范的修改，而不是对Java语言规则的修改，这一块相对来讲比较复杂，增加了虚拟机中的方法调用，最直接的受益者就是运行在Java平台的动态语言的编译器。</li></ul><blockquote><p>JAVA源码示例</p></blockquote><pre><code class="highlight java"><span class="meta">@FunctionalInterface</span><span class="keyword">interface</span> <span class="title class_">Func</span> &#123;    <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">func</span><span class="params">(String str)</span>;&#125;<span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Lambda</span> &#123;    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">lambda</span><span class="params">(Func func)</span> &#123;        <span class="keyword">return</span>;    &#125;    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;        <span class="type">Lambda</span> <span class="variable">lambda</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Lambda</span>();        <span class="type">Func</span> <span class="variable">func</span> <span class="operator">=</span> s -&gt; &#123;            <span class="keyword">return</span> <span class="literal">true</span>;        &#125;;        lambda.lambda(func);        lambda.lambda(s -&gt; &#123;            <span class="keyword">return</span> <span class="literal">true</span>;        &#125;);    &#125;&#125;</code></pre><p><img src="https://raw.githubusercontent.com/GeorgeChan95/blogimg/master/img/2023/11/30/20231130-133827.png" alt="image-20231130133826164"></p><h2 id="4-动态语言和静态语言"><a href="#4-动态语言和静态语言" class="headerlink" title="4. 动态语言和静态语言"></a>4. 动态语言和静态语言</h2><ul><li><p>动态类型语言和静态类型语言两者的区别就在于对类型的检查是在编译期还是在运行期，满足前者就是静态类型语言，反之是动态类型语言。</p></li><li><p>说的再直白一点就是，静态类型语言是判断变量自身的类型信息；动态类型语言是判断变量值的类型信息，变量没有类型信息，变量值才有类型信息，这是动态语言的一个重要特征。</p></li><li><p>JAVA 属于静态语言，JavaScript 属于动态语言，Python 属于动态语言。</p></li></ul><h2 id="5-Java语言中方法重写的本质"><a href="#5-Java语言中方法重写的本质" class="headerlink" title="5. Java语言中方法重写的本质"></a>5. Java语言中方法重写的本质</h2><ol><li>找到操作数栈顶的第一个元素所执行的对象的实际类型，记作C。</li><li>如果在类型C中找到与常量中的描述符合简单名称都相符的方法，则进行访问权限校验。<ol><li>如果通过则返回这个方法的直接引用，查找过程结束</li><li>如果不通过，则返回java.lang.IllegalAccessError 异常</li></ol></li><li>否则，按照继承关系从下往上依次对C的各个父类进行第2步的搜索和验证过程。</li><li>如果始终没有找到合适的方法，则抛出java.lang.AbstractMethodError异常。</li></ol><p><em>上面这个过程称为<strong>动态分派</strong></em></p><h3 id="IllegalAccessError介绍"><a href="#IllegalAccessError介绍" class="headerlink" title="IllegalAccessError介绍"></a>IllegalAccessError介绍</h3><p>程序试图访问或修改一个属性或调用一个方法，这个属性或方法，你没有权限访问。一般的，这个会引起编译器异常。这个错误如果发生在运行时，就说明一个类发生了不兼容的改变。比如，你把应该有的jar包放从工程中拿走了，或者Maven中存在jar包冲突</p><h2 id="6-虚方法表"><a href="#6-虚方法表" class="headerlink" title="6. 虚方法表"></a>6. 虚方法表</h2><ul><li>在面向对象的编程中，会很频繁的使用到<strong>动态分派</strong>，如果在每次动态分派的过程中都要重新在类的方法元数据中搜索合适的目标的话就可能影响到执行效率。因此，为了提高性能，<strong>JVM采用在类的方法区建立一个虚方法表（virtual method table）来实现</strong>，非虚方法不会出现在表中。使用索引表来代替查找。【上面动态分派的过程，我们可以看到如果子类找不到，还要从下往上找其父类，非常耗时】</li><li>每个类中都有一个虚方法表，表中存放着各个方法的实际入口。</li><li>虚方法表是什么时候被创建的呢？虚方法表会在类加载的链接阶段被创建并开始初始化，类的变量初始值准备完成之后，JVM会把该类的虚方法表也初始化完毕。</li></ul><blockquote><p>示例1</p></blockquote><p>如图所示：如果类中重写了方法，那么调用的时候，就会直接在该类的虚方法表中查找</p><p><img src="https://raw.githubusercontent.com/GeorgeChan95/blogimg/master/img/2023/11/30/20231130-134718.png" alt="image-20231130134717020"></p><ul><li>比如说son在调用toString的时候，Son没有重写过，Son的父类Father也没有重写过，那就直接调用Object类的toString。那么就直接在虚方法表里指明toString直接指向Object类。</li><li>下次Son对象再调用toString就直接去找Object，不用先找Son–&gt;再找Father–&gt;最后才到Object的这样的一个过程。</li></ul><h1 id="八、方法返回地址"><a href="#八、方法返回地址" class="headerlink" title="八、方法返回地址"></a>八、方法返回地址</h1><blockquote><p>方法返回地址、动态链接、附加信息 在某些时候也叫做 <strong>帧数据区</strong></p></blockquote><h2 id="1-概述"><a href="#1-概述" class="headerlink" title="1. 概述"></a>1. 概述</h2><ul><li><p>存放调用该方法的pc寄存器的值。</p><p>一个方法的结束，有两种方式：</p><ul><li>正常执行完成</li><li>出现未处理的异常，非正常退出</li></ul></li><li><p>无论通过哪种方式退出，在方法退出后都返回到该方法被调用的位置。方法正常退出时，<strong>调用者的pc计数器的值作为返回地址，即调用该方法的指令的下一条指令的地址</strong>。而通过异常退出的，返回地址是要通过异常表来确定，栈帧中一般不会保存这部分信息。</p></li><li><p>本质上，方法的退出就是当前栈帧出栈的过程。此时，需要<strong>恢复上层方法的局部变量表、操作数栈、将返回值压入调用者栈帧的操作数栈、设置PC寄存器值</strong>等，让调用者方法继续执行下去。</p></li><li><p>正常完成出口和异常完成出口的区别在于：<strong>通过异常完成出口退出的不会给他的上层调用者产生任何的返回值。</strong></p></li></ul><h2 id="2-方法退出的两种方式"><a href="#2-方法退出的两种方式" class="headerlink" title="2. 方法退出的两种方式"></a>2. 方法退出的两种方式</h2><blockquote><p>当一个方法开始执行后，只有两种方式可以退出这个方法</p></blockquote><ul><li>正常退出<ul><li>执行引擎遇到任意一个方法返回的字节码指令（return），会有返回值传递给上层的方法调用者，简称<strong>正常完成出口</strong>；</li><li>一个方法在正常调用完成之后，究竟需要使用哪一个返回指令，还需要根据方法返回值的实际数据类型而定。</li><li>在字节码指令中，返回指令包含：<ul><li>ireturn：当返回值是boolean，byte，char，short和int类型时使用</li><li>lreturn：Long类型</li><li>freturn：Float类型</li><li>dreturn：Double类型</li><li>areturn：引用类型</li><li>return：返回值类型为void的方法、实例初始化方法、类和接口的初始化方法</li></ul></li></ul></li><li>异常退出<ul><li>在方法执行过程中遇到异常（Exception），并且这个异常没有在方法内进行处理，也就是只要在本方法的异常表中没有搜索到匹配的异常处理器，就会导致方法退出，简称异常完成出口。<ul><li>简单来说就是代码块中是否声明了try catch，以及catch块中是否包含了对应的异常</li></ul></li><li>方法执行过程中，抛出异常时的异常处理，存储在一个异常处理表，方便在发生异常的时候找到处理异常的代码</li></ul></li></ul><blockquote><p>代码示例</p></blockquote><pre><code class="highlight java"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">method2</span><span class="params">()</span> &#123;    methodVoid();    <span class="keyword">try</span> &#123;        method1();    &#125; <span class="keyword">catch</span> (IOException e) &#123;        e.printStackTrace();    &#125;&#125;<span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">method1</span><span class="params">()</span> <span class="keyword">throws</span> IOException &#123;    <span class="type">FileReader</span> <span class="variable">fis</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">FileReader</span>(<span class="string">&quot;atguigu.txt&quot;</span>);    <span class="type">char</span>[] cBuffer = <span class="keyword">new</span> <span class="title class_">char</span>[<span class="number">1024</span>];    <span class="type">int</span> len;    <span class="keyword">while</span> ((len = fis.read(cBuffer)) != -<span class="number">1</span>) &#123;        <span class="type">String</span> <span class="variable">str</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">String</span>(cBuffer, <span class="number">0</span>, len);        System.out.println(str);    &#125;    fis.close();&#125;</code></pre><blockquote><p>字节码：异常表</p></blockquote><p><img src="https://raw.githubusercontent.com/GeorgeChan95/blogimg/master/img/2023/11/30/20231130-140311.png" alt="image-20231130140309699"></p><h2 id="3-异常处理表"><a href="#3-异常处理表" class="headerlink" title="3. 异常处理表"></a>3. 异常处理表</h2><ul><li>反编译字节码文件，可得到 Exception Table</li><li>Start PC(from) ：字节码指令起始地址</li><li>End PC(to) ：字节码指令结束地址</li><li>Handler PC(target) ：出现异常跳转至地址为 11 的指令执行</li><li>Catch Type(type) ：捕获异常的类型</li></ul><p>异常处理表通过javap命令查看的表头信息与通过Jclasslib插件查看的表头名称不同，但是意思是一样的。</p><pre><code class="highlight plaintext">public void method2();  descriptor: ()V  flags: ACC_PUBLIC  Code:    stack=1, locals=2, args_size=1       0: aload_0       1: invokevirtual #2                  // Method methodVoid:()V       4: aload_0       5: invokevirtual #3                  // Method method1:()V       8: goto          16      11: astore_1      12: aload_1      13: invokevirtual #5                  // Method java/io/IOException.printStackTrace:()V      16: return    Exception table:       from    to  target type           4     8    11   Class java/io/IOException    LineNumberTable:      line 69: 0      line 72: 4      line 75: 8      line 73: 11      line 74: 12      line 76: 16    LocalVariableTable:      Start  Length  Slot  Name   Signature         12       4     1     e   Ljava/io/IOException;          0      17     0  this   Lcom/atguigu/java3/ReturnAddressTest;    StackMapTable: number_of_entries = 2      frame_type = 75 /* same_locals_1_stack_item */        stack = [ class java/io/IOException ]      frame_type = 4 /* same */</code></pre><h1 id="九、一些附加信息"><a href="#九、一些附加信息" class="headerlink" title="九、一些附加信息"></a>九、一些附加信息</h1><p>栈帧中还允许携带与Java虚拟机实现相关的一些附加信息。例如：对程序调试提供支持的信息。</p><h1 id="十、常见问题"><a href="#十、常见问题" class="headerlink" title="十、常见问题"></a>十、常见问题</h1><h2 id="1-举例栈溢出的情况"><a href="#1-举例栈溢出的情况" class="headerlink" title="1. 举例栈溢出的情况"></a>1. 举例栈溢出的情况</h2><p>SOF（StackOverflowError），栈大小分为固定的，和动态变化。如果是固定的就可能出现StackOverflowError。如果是动态变化的，内存不足时就可能出现OOM</p><h2 id="2-调整栈大小，就能保证不出现溢出么？"><a href="#2-调整栈大小，就能保证不出现溢出么？" class="headerlink" title="2. 调整栈大小，就能保证不出现溢出么？"></a>2. 调整栈大小，就能保证不出现溢出么？</h2><p>不能保证不溢出，只能保证SOF出现的几率小</p><h2 id="3-分配的栈内存越大越好么？"><a href="#3-分配的栈内存越大越好么？" class="headerlink" title="3. 分配的栈内存越大越好么？"></a>3. 分配的栈内存越大越好么？</h2><p>不是，一定时间内降低了OOM概率，但是会挤占其它的线程空间，因为整个虚拟机的内存空间是有限的</p><h2 id="4-垃圾回收是否涉及到虚拟机栈？"><a href="#4-垃圾回收是否涉及到虚拟机栈？" class="headerlink" title="4. 垃圾回收是否涉及到虚拟机栈？"></a>4. 垃圾回收是否涉及到虚拟机栈？</h2><p><strong>不会</strong></p><table><thead><tr><th>位置</th><th>是否有Error</th><th>是否存在GC</th></tr></thead><tbody><tr><td>PC计数器</td><td>无</td><td>不存在</td></tr><tr><td>虚拟机栈</td><td>有，SOF</td><td>不存在</td></tr><tr><td>本地方法栈(在HotSpot的实现中和虚拟机栈一样)</td><td></td><td></td></tr><tr><td>堆</td><td>有，OOM</td><td>存在</td></tr><tr><td>方法区</td><td>有</td><td>存在</td></tr></tbody></table><h2 id="5-方法中定义的局部变量是否线程安全？"><a href="#5-方法中定义的局部变量是否线程安全？" class="headerlink" title="5. 方法中定义的局部变量是否线程安全？"></a>5. 方法中定义的局部变量是否线程安全？</h2><ul><li>如果只有一个线程才可以操作此数据，则必是线程安全的。</li><li>如果有多个线程操作此数据，则此数据是共享数据。如果不考虑同步机制的话，会存在线程安全问题。</li></ul><p><strong>如果对象是在内部产生，并在内部消亡，没有返回到外部，那么它就是线程安全的，反之则是线程不安全的。</strong></p><blockquote><p>示例：</p></blockquote><pre><code class="highlight java"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">StringBuilderTest</span> &#123;    <span class="type">int</span> <span class="variable">num</span> <span class="operator">=</span> <span class="number">10</span>;    <span class="comment">//s1的声明方式是线程安全的</span>    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">method1</span><span class="params">()</span>&#123;        <span class="comment">//StringBuilder:线程不安全</span>        <span class="type">StringBuilder</span> <span class="variable">s1</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">StringBuilder</span>();        s1.append(<span class="string">&quot;a&quot;</span>);        s1.append(<span class="string">&quot;b&quot;</span>);        <span class="comment">//...</span>    &#125;    <span class="comment">//sBuilder的操作过程：是线程不安全的</span>    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">method2</span><span class="params">(StringBuilder sBuilder)</span>&#123;        sBuilder.append(<span class="string">&quot;a&quot;</span>);        sBuilder.append(<span class="string">&quot;b&quot;</span>);        <span class="comment">//...</span>    &#125;    <span class="comment">//s1的操作：是线程不安全的</span>    <span class="keyword">public</span> <span class="keyword">static</span> StringBuilder <span class="title function_">method3</span><span class="params">()</span>&#123;        <span class="type">StringBuilder</span> <span class="variable">s1</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">StringBuilder</span>();        s1.append(<span class="string">&quot;a&quot;</span>);        s1.append(<span class="string">&quot;b&quot;</span>);        <span class="keyword">return</span> s1;    &#125;    <span class="comment">//s1的操作：是线程安全的</span>    <span class="keyword">public</span> <span class="keyword">static</span> String <span class="title function_">method4</span><span class="params">()</span>&#123;        <span class="type">StringBuilder</span> <span class="variable">s1</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">StringBuilder</span>();        s1.append(<span class="string">&quot;a&quot;</span>);        s1.append(<span class="string">&quot;b&quot;</span>);        <span class="keyword">return</span> s1.toString();    &#125;    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;        <span class="type">StringBuilder</span> <span class="variable">s</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">StringBuilder</span>();                <span class="keyword">new</span> <span class="title class_">Thread</span>(() -&gt; &#123;            s.append(<span class="string">&quot;a&quot;</span>);            s.append(<span class="string">&quot;b&quot;</span>);        &#125;).start();        method2(s);    &#125;&#125;</code></pre>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;环境&quot;&gt;&lt;a href=&quot;#环境&quot; class=&quot;headerlink&quot; title=&quot;环境&quot;&gt;&lt;/a&gt;环境&lt;/h1&gt;&lt;blockquote&gt;
&lt;p&gt;系统 : Windows 10&lt;br&gt;JDK : 1.8&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h1 id=&quot;一、</summary>
      
    
    
    
    <category term="JVM" scheme="https://georgechan95.github.io/categories/JVM/"/>
    
    
    <category term="jvm" scheme="https://georgechan95.github.io/tags/jvm/"/>
    
    <category term="java" scheme="https://georgechan95.github.io/tags/java/"/>
    
  </entry>
  
  <entry>
    <title>第三章-运行时数据区</title>
    <link href="https://georgechan95.github.io/2023/11/28/jvm/%E7%AC%AC%E4%B8%89%E7%AB%A0-%E8%BF%90%E8%A1%8C%E6%97%B6%E6%95%B0%E6%8D%AE%E5%8C%BA/"/>
    <id>https://georgechan95.github.io/2023/11/28/jvm/%E7%AC%AC%E4%B8%89%E7%AB%A0-%E8%BF%90%E8%A1%8C%E6%97%B6%E6%95%B0%E6%8D%AE%E5%8C%BA/</id>
    <published>2023-11-28T11:31:00.000Z</published>
    <updated>2024-06-22T10:36:12.823Z</updated>
    
    <content type="html"><![CDATA[<h1 id="环境"><a href="#环境" class="headerlink" title="环境"></a>环境</h1><blockquote><p>系统 : Windows 10<br>JDK : 1.8</p></blockquote><h1 id="一、运行时数据区结构"><a href="#一、运行时数据区结构" class="headerlink" title="一、运行时数据区结构"></a>一、运行时数据区结构</h1><p><img src="https://raw.githubusercontent.com/GeorgeChan95/blogimg/master/img/2023/11/28/20231128-194630.jpg" alt="JVM架构-简图"></p><h2 id="1-运行时数据区与内存"><a href="#1-运行时数据区与内存" class="headerlink" title="1. 运行时数据区与内存"></a>1. 运行时数据区与内存</h2><p>内存是非常重要的系统资源，是硬盘和 CPU 的中间仓库及桥梁，承载着操作系统和应用程序的实时运行。 JVM 内存布局规定了 Java 在运行过程中内存申请、分配、管理的策略，保证了 JVM 的高效稳定运行。<strong>不同的 JVM 对于内存的划分方式和管理机制存在着部分差异。</strong>结合 JVM 虚拟机规范，来探讨一下 <strong>经典的 JVM 内存布局</strong>：<br><img src="https://raw.githubusercontent.com/GeorgeChan95/blogimg/master/img/2023/11/28/20231128-194803.png" alt="jvm内存布局"></p><h2 id="2-线程的内存空间"><a href="#2-线程的内存空间" class="headerlink" title="2. 线程的内存空间"></a>2. 线程的内存空间</h2><p>Java 虚拟机定义了若干种程序运行期间会使用到的运行时数据区，其中有一些会随着虚拟机启动而创建，随着虚拟机退出而销毁。另外一些则是与线程一一对应的，这些与线程对应的数据区域会堕着线程开始和结束而创建和销毁。</p><p>如下图，灰色的为单独线程私有的，红色的为多个线程共享的。即：</p><ul><li>每个线程：独立包括 程序计数器、栈、本地方法栈。</li><li>线程间共享：堆、堆外内存（永久代或元空间、代码缓存）</li></ul><p><img src="https://raw.githubusercontent.com/GeorgeChan95/blogimg/master/img/2023/11/28/20231128-194944.png" alt="运行时数据区"></p><p>关于线程间共享的说明：</p><h2 id="3-Runtime类"><a href="#3-Runtime类" class="headerlink" title="3. Runtime类"></a>3. Runtime类</h2><p><strong>每个 JVM 只有一个 <code>java.lang.Runtime</code> 实例，即为运行时环境。</strong></p><p><img src="https://raw.githubusercontent.com/GeorgeChan95/blogimg/master/img/2023/11/28/20231128-195238.png" alt="Runtime"></p><h1 id="二、线程"><a href="#二、线程" class="headerlink" title="二、线程"></a>二、线程</h1><h2 id="1-JVM线程概述"><a href="#1-JVM线程概述" class="headerlink" title="1. JVM线程概述"></a>1. JVM线程概述</h2><ul><li>线程是一个程序里的运行单元。 JVM 允许一个应用有多个线程并行的执行。</li><li>在 HotSpot JVM 里，每个线程都与操作系统的本地线程直接映射。<ul><li>当一个 Java 线程准备好执行以后，此时一个操作系统的本地线程也同时创建。 Java 线程执行终止后，本地线程也会回收。</li></ul></li><li>操作系统负责所有线程的安排调度到任何一个可用的 CPU 上。一旦本地线程初始化成功，它就会调用 Java 线程中的 <code>java.lang.Thread#run</code> 方法。</li><li>Java 中线程分为 <strong>守护线程</strong> 和 <strong>用户线程</strong> 两类</li></ul><h2 id="2-JVM系统线程"><a href="#2-JVM系统线程" class="headerlink" title="2. JVM系统线程"></a>2. JVM系统线程</h2><p>如果你使用 jconsole 或者是任何一个调试工具，都能看到在后台有许多线程在运行。这些后台线程不包括调用 public static void main(String []) 的 main 线程以及所有这个 main 线程自己创建的线程。</p><p>这些主要的后台系统线程在 HotSpot JVM 里主要是以下几个：</p><ul><li>虚拟机线程：这种线程的操作是需要 JVM 达到安全点オ会出现。这些操作必须在不同的线程中发生的原因是他们都需要 JVM 达到安全点，这样堆才不会变化。这种线程的执行类型包括 “stop-the-world” 的垃圾收集，线程栈收集，线程挂起以及偏向锁撒销。</li><li>周期任务线程：这种线程是时间周期事件的体现（比如中断），他们一般用于周期性操作的调度执行。</li><li>GC 线程：这种线程对在 JVM 里不同种类的垃圾收集行为提供了支持。</li><li>编译线程：这种线程在运行时会将字节码编译成到本地代码。</li><li>信号调度线程：这种线程接收信号并发送给 JVM ，在它内部通过调用适当的方法进行处理。</li></ul><h1 id="三、程序计数器-PC寄存器"><a href="#三、程序计数器-PC寄存器" class="headerlink" title="三、程序计数器(PC寄存器)"></a>三、程序计数器(PC寄存器)</h1><h2 id="1-PC寄存器介绍"><a href="#1-PC寄存器介绍" class="headerlink" title="1. PC寄存器介绍"></a>1. PC寄存器介绍</h2><p><a href="https://docs.oracle.com/javase/specs/jvms/se8/html/jvms-2.html#jvms-2.5.1">oracle官网介绍</a></p><p><img src="https://raw.githubusercontent.com/GeorgeChan95/blogimg/master/img/2023/11/28/20231128-200619.png" alt="运行时数据区"></p><p>JVM 中的程序计数寄存器（ Program Counter Register ）中， Register 的命名源于 CPU 的寄存器，寄存器存储指令相关的现场信息。 CPU 只有把数据装载到寄存器才能够运行。这里，并非是广义上所指的物理寄存器，或许将其翻译为 PC 计数器（或指令计数器）会更加贴切（也称为程序钩子），并且也不容易引起一些不必要的误会。 <strong>JVM 中的 PC 寄存器是对物理 PC 寄存器的一种抽象模拟</strong></p><h3 id="1-1-PC寄存器的作用"><a href="#1-1-PC寄存器的作用" class="headerlink" title="1.1 PC寄存器的作用"></a>1.1 PC寄存器的作用</h3><p>PC 寄存器用来存储指向下一条令的地址也即将要执行的指令代码。由执行引擎读取下一条指令。</p><p><img src="https://raw.githubusercontent.com/GeorgeChan95/blogimg/master/img/2023/11/28/20231128-201602.png" alt="PC寄存器"></p><ul><li>它是一块很小的内存空间，几乎可以忽略不记。也是运行速度最快的存储区域。</li><li>在 JVM 规范中，每个线程都有它自己的程序计数器，是线程私有的，生命周期与线程的生命周期保持一致。</li><li>任何时间一个线程都只有一个方法在执行，也就是所谓的当前方法。程序计数器会存储当前线程正在执行的 Java 方法的 JVM 指令地址；或者，如果是在执行 native 方法，则是未指定值（ undefined ）。</li><li>它是程序控制流的指示器，分支、循环、跳转、异常处理、线程恢复等基础功能都需要依赖这个计数器来完成。</li><li>字节码解释器工作时就是通过改变这个计数器的值来选取下一条需要执行的字节码指令。</li><li>它是唯一一个在 Java 虚拟机规范中没有规定任何 <code>OutOfMemoryError</code> 情况的区域。</li></ul><h2 id="2-示例解读PC寄存器工作原理"><a href="#2-示例解读PC寄存器工作原理" class="headerlink" title="2. 示例解读PC寄存器工作原理"></a>2. 示例解读PC寄存器工作原理</h2><pre><code class="highlight java"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">PCRegisterTest</span> &#123;    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;        <span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">10</span>;        <span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> <span class="number">20</span>;        <span class="type">int</span> <span class="variable">k</span> <span class="operator">=</span> i + j;        <span class="type">String</span> <span class="variable">s</span> <span class="operator">=</span> <span class="string">&quot;abc&quot;</span>;        System.out.println(i);        System.out.println(k);    &#125;&#125;</code></pre><p>查看字节码</p><p><img src="https://raw.githubusercontent.com/GeorgeChan95/blogimg/master/img/2023/11/28/20231128-203322.png" alt="image-20231128203321069"></p><pre><code class="highlight sh"> 0 bipush 10 2 istore_1 3 bipush 20 5 istore_2 6 iload_1 7 iload_2 8 iadd 9 istore_310 ldc <span class="comment">#2 &lt;abc&gt;</span>12 astore 414 getstatic <span class="comment">#3 &lt;java/lang/System.out : Ljava/io/PrintStream;&gt;</span>17 iload_118 invokevirtual <span class="comment">#4 &lt;java/io/PrintStream.println : (I)V&gt;</span>21 getstatic <span class="comment">#3 &lt;java/lang/System.out : Ljava/io/PrintStream;&gt;</span>24 iload_325 invokevirtual <span class="comment">#4 &lt;java/io/PrintStream.println : (I)V&gt;</span>28 <span class="built_in">return</span></code></pre><ul><li>左边的数字代表<strong>指令地址（指令偏移）</strong>，即 PC 寄存器中可能存储的值，然后执行引擎读取 PC 寄存器中的值，并执行该指令</li></ul><p><img src="https://raw.githubusercontent.com/GeorgeChan95/blogimg/master/img/2023/11/28/20231128-203547.png" alt="PC寄存器工作原理1"></p><h2 id="3-常见问题"><a href="#3-常见问题" class="headerlink" title="3. 常见问题"></a>3. 常见问题</h2><p><strong>使用PC寄存器存储字节码指令地址有什么用呢？</strong>  <strong>为什么使用 PC 寄存器来记录当前线程的执行地址呢？</strong></p><ul><li>因为CPU需要不停的切换各个线程，这时候切换回来以后，就得知道接着从哪开始继续执行</li><li>JVM的字节码解释器就需要通过改变PC寄存器的值来明确下一条应该执行什么样的字节码指令</li></ul><img src="https://raw.githubusercontent.com/GeorgeChan95/blogimg/master/img/2023/11/28/20231128-203823.jpg" alt="第04章_PC寄存器" style="zoom:80%;" /><p><strong>PC寄存器为什么被设定为私有的？</strong></p><ul><li>我们都知道所谓的多线程在一个特定的时间段内只会执行其中某一个线程的方法，CPU会不停地做任务切换，这样必然导致经常中断或恢复，如何保证分毫无差呢？<strong>为了能够准确地记录各个线程正在执行的当前字节码指令地址，最好的办法自然是为每一个线程都分配一个PC寄存器</strong>，这样一来各个线程之间便可以进行独立计算，从而不会出现相互干扰的情况。</li><li>由于CPU时间片轮限制，众多线程在并发执行过程中，任何一个确定的时刻，一个处理器或者多核处理器中的一个内核，只会执行某个线程中的一条指令。</li><li>这样必然导致经常中断或恢复，如何保证分毫无差呢？每个线程在创建后，都会产生自己的程序计数器和栈帧，程序计数器在各个线程之间互不影响。</li></ul><h2 id="4-CPU-时间片"><a href="#4-CPU-时间片" class="headerlink" title="4. CPU 时间片"></a>4. CPU 时间片</h2><ul><li>CPU时间片即CPU分配给各个程序的时间，每个线程被分配一个时间段，称作它的时间片。</li><li>在宏观上：我们可以同时打开多个应用程序，每个程序并行不悖，同时运行。</li><li>但在微观上：由于只有一个CPU，一次只能处理程序要求的一部分，如何处理公平，一种方法就是引入时间片，<strong>每个程序轮流执行</strong>。</li></ul><p><img src="https://raw.githubusercontent.com/GeorgeChan95/blogimg/master/img/2023/11/28/20231128-204323.png" alt="CPU时间片"></p><h2 id="5-理解串行、并行、并发"><a href="#5-理解串行、并行、并发" class="headerlink" title="5. 理解串行、并行、并发"></a>5. 理解串行、并行、并发</h2><ul><li>串行：即顺序执行</li><li>并发（Concurrent），在操作系统中，是指一个时间段中有几个程序都处于已启动运行到运行完毕之间，且这几个程序都是在同一个处理机上运行。</li><li>并行（Parallel），当系统有一个以上CPU时，当一个CPU执行一个进程时，另一个CPU可以执行另一个进程，两个进程互不抢占CPU资源，可以同时进行，这种方式我们称之为并行(Parallel)。其实决定并行的因素不是CPU的数量，而是CPU的核心数量，比如一个CPU多个核也可以并行。</li></ul><img src="https://raw.githubusercontent.com/GeorgeChan95/blogimg/master/img/2023/11/28/20231128-204550.png" alt="串行、并行与并发" style="zoom:67%;" />]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;环境&quot;&gt;&lt;a href=&quot;#环境&quot; class=&quot;headerlink&quot; title=&quot;环境&quot;&gt;&lt;/a&gt;环境&lt;/h1&gt;&lt;blockquote&gt;
&lt;p&gt;系统 : Windows 10&lt;br&gt;JDK : 1.8&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h1 id=&quot;一、</summary>
      
    
    
    
    <category term="JVM" scheme="https://georgechan95.github.io/categories/JVM/"/>
    
    
    <category term="jvm" scheme="https://georgechan95.github.io/tags/jvm/"/>
    
    <category term="java" scheme="https://georgechan95.github.io/tags/java/"/>
    
  </entry>
  
  <entry>
    <title>第二章-JVM类加载子系统</title>
    <link href="https://georgechan95.github.io/2023/11/25/jvm/%E7%AC%AC%E4%BA%8C%E7%AB%A0-%E7%B1%BB%E5%8A%A0%E8%BD%BD%E5%AD%90%E7%B3%BB%E7%BB%9F/"/>
    <id>https://georgechan95.github.io/2023/11/25/jvm/%E7%AC%AC%E4%BA%8C%E7%AB%A0-%E7%B1%BB%E5%8A%A0%E8%BD%BD%E5%AD%90%E7%B3%BB%E7%BB%9F/</id>
    <published>2023-11-25T06:35:00.000Z</published>
    <updated>2024-06-22T10:36:12.823Z</updated>
    
    <content type="html"><![CDATA[<h1 id="环境"><a href="#环境" class="headerlink" title="环境"></a>环境</h1><blockquote><p>系统 : Windows 10</p><p>JDK : 1.8</p></blockquote><h1 id="一、内存结构概述"><a href="#一、内存结构概述" class="headerlink" title="一、内存结构概述"></a>一、内存结构概述</h1><p><img src="https://raw.githubusercontent.com/GeorgeChan95/blogimg/master/img/2023/11/27/20231127-195327.jpg" alt="JVM架构"></p><h1 id="二、类加载器与类的加载过程"><a href="#二、类加载器与类的加载过程" class="headerlink" title="二、类加载器与类的加载过程"></a>二、类加载器与类的加载过程</h1><h2 id="1-类加载子系统的作用"><a href="#1-类加载子系统的作用" class="headerlink" title="1. 类加载子系统的作用"></a>1. 类加载子系统的作用</h2><p><img src="https://raw.githubusercontent.com/GeorgeChan95/blogimg/master/img/2023/11/27/20231127-200336.png" alt="类加载子系统"></p><ul><li>类加载器子系统负责从文件系统或者网络中加载 class 文件， class 文件在文件开头有特定的文件标识。参考：<a href="https://blog.csdn.net/Azure_xw/article/details/117914433">IDEA安装JClasslib插件</a></li><li>ClassLoader 只负责 class 文件的加载，至于它是否可以运行，则由 Execution Engine 决定。</li><li>加载的类信息存放于一块称为方法区的内存空间。除了类的信息外，方法区中还会存放运行时常量池信息，可能述包括字符串字面量和数字常量（这部分常量信息是 class 文件中常量池部分的内存映射）</li></ul><p><img src="https://raw.githubusercontent.com/GeorgeChan95/blogimg/master/img/2023/11/27/20231127-200937.png" alt="类加载子系统示例"></p><ul><li>class file可存在于硬盘或网络上，作为一个实例模板。在执行时需要将这个file加载到JVM中，根据类文件实例化出多个类的实例。</li><li>class file 加载到 JVM 中，被称为 DNA 元数据模板，放在<strong>方法区</strong>。</li><li>在 .class 文件ー&gt; JVM -&gt;最终成为元数据模板，此过程就要一个运输工具（类装载器 Class Loader ），扮演一个快递员的角色</li></ul><h2 id="2-类的加载过程"><a href="#2-类的加载过程" class="headerlink" title="2. 类的加载过程"></a>2. 类的加载过程</h2><p><img src="https://raw.githubusercontent.com/GeorgeChan95/blogimg/master/img/2023/11/27/20231127-201513.jpg" alt="类的加载过程"></p><p>整体加载过程的三个环节：</p><ol><li>加载</li><li>链接<ol><li>验证</li><li>准备</li><li>解析</li></ol></li><li>初始化</li></ol><p><img src="https://raw.githubusercontent.com/GeorgeChan95/blogimg/master/img/2023/11/28/20231128-090956.png" alt="clinit"></p><h3 id="2-1-加载"><a href="#2-1-加载" class="headerlink" title="2.1 加载"></a>2.1 加载</h3><ul><li><p>通过一个类的全限定名获取定义此类的二进制字节流</p></li><li><p>将这个字节流所代表的静态存储结构转化为 <strong>方法区</strong> 的运行时数据结构</p></li><li><p><strong>在内存中生成一个代表这个类的 <code>java.lang.Class</code> 对象</strong>，作为方法区这个类的各种数据的访问入口</p></li></ul><h4 id="补充：加载-class-文件的方式"><a href="#补充：加载-class-文件的方式" class="headerlink" title="补充：加载 .class 文件的方式"></a><strong>补充：加载 .class 文件的方式</strong></h4><ul><li>从本地系统中直接加载</li><li>通过网络获取，典型场景： Web Applet</li><li>从 zip 压缩包中读取，成为日后 jar 、 war 格式的基础</li><li>运行时计算生成，使用最多的是：动态代理技术</li><li>由其他文件生成，典型场景： JSP 应用</li><li>从专有数据库中提取 .class 文件，比较少见从加密文件中获取，典型的防 class 文件被反编译的保护措施</li></ul><h3 id="2-2-链接"><a href="#2-2-链接" class="headerlink" title="2.2 链接"></a>2.2 链接</h3><p>链接分为三个子阶段：验证 -&gt; 准备 -&gt; 解析</p><h4 id="验证"><a href="#验证" class="headerlink" title="验证"></a>验证</h4><ul><li>目的在于确保 class 文件的字节流中包含信息符合当前虚拟机要求，保证被加载类的正确性，不会危害虚拟机自身安全</li><li>主要包括四种验证，文件格式验证，元数据验证，字节码验证，符号引用验证。</li></ul><p><strong>举例：</strong></p><p>使用 BinaryViewer软件查看字节码文件，其开头均为 CAFE BABE ，如果出现不合法的字节码文件，那么将会验证不通过。</p><p><img src="https://raw.githubusercontent.com/GeorgeChan95/blogimg/master/img/2023/11/25/20231125-153009.png" alt="image-20231125153008206"></p><h4 id="准备"><a href="#准备" class="headerlink" title="准备"></a>准备</h4><ul><li>为类变量分配内存并且设置该类变量的默认初始值，即零值</li><li><strong>这里不包含用 final 修饰的 static ，因为 final 在编译的时候就会分配了，准备阶段会显式初始化；</strong></li><li><strong>这里不会为实例变量分配初始化</strong>，类变量会分配在方法区中，而实例变量是会随着对象一起分配到 Java 堆中。</li></ul><p><strong>举例：</strong></p><p>代码：变量a在准备阶段会赋初始值，但不是1，而是0，在初始化阶段会被赋值为 1</p><pre><code class="highlight java"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">HelloApp</span> &#123;    <span class="keyword">private</span> <span class="keyword">static</span> <span class="type">int</span> <span class="variable">a</span> <span class="operator">=</span> <span class="number">1</span>;<span class="comment">//prepare：a = 0 ---&gt; initial : a = 1</span>    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;        System.out.println(a);    &#125;&#125;</code></pre><h4 id="解析"><a href="#解析" class="headerlink" title="解析"></a>解析</h4><p>将常量池内的符号引用转换为直接引用的过程。</p><p>事实上，解析操作住往会伴随着 JVM 在执行完初始化之后再执行。</p><p><strong>符号引用就是一组符号来描述所引用的目标。</strong>符号引用的字面量形式明确定义在《Java 虚拟机规范》的 class 文件格式中。<strong>直接引用就是直接指向目标的指针、相对偏移量或一个间接定位到目标的句柄。</strong></p><p>解析动作主要针对类或接口、字段、类方法、接口方法、方法类型等。对应常量池中的 CONSTANT_Class_info、CONSTANT_Fieldref_info、CONSTANT_Methodref_info</p><h5 id="符号引用"><a href="#符号引用" class="headerlink" title="符号引用"></a>符号引用</h5><p>反编译 class 文件后可以查看符号引用，下面带# 的就是符号引用</p><p><img src="https://raw.githubusercontent.com/GeorgeChan95/blogimg/master/img/2023/11/28/20231128-112145.png" alt="符号引用"></p><h3 id="2-3-初始化"><a href="#2-3-初始化" class="headerlink" title="2.3 初始化"></a>2.3 初始化</h3><h4 id="2-3-1-类的初始化时机"><a href="#2-3-1-类的初始化时机" class="headerlink" title="2.3.1 类的初始化时机"></a>2.3.1 类的初始化时机</h4><ol><li>创建类的实例</li><li>访问某个类或接口的静态变量，或者对该静态变量赋值</li><li>调用类的静态方法</li><li>反射（比如：Class.forName(“com.atguigu.Test”)）</li><li>初始化一个类的子类</li><li>Java虚拟机启动时被标明为启动类的类</li><li>JDK7开始提供的动态语言支持：java.lang.invoke.MethodHandle实例的解析结果REF_getStatic、REF putStatic、REF_invokeStatic句柄对应的类没有初始化，则初始化</li></ol><p>除了以上七种情况，其他使用Java类的方式都被看作是对类的被动使用，都不会导致类的初始化，即不会执行初始化阶段（不会调用 clinit() 方法和 init() 方法）</p><h4 id="2-3-2-clinit"><a href="#2-3-2-clinit" class="headerlink" title="2.3.2 clinit()"></a>2.3.2 clinit()</h4><ul><li>初始化阶段就是执行类构造器方法<code>&lt;clinit&gt;()</code>的过程</li><li>此方法不需定义，是javac编译器自动收集类中的所有<strong>类变量</strong>的赋值动作和静态代码块中的语句合并而来。也就是说，当我们代码中包含static变量的时候，就会有clinit方法</li><li><code>&lt;clinit&gt;()</code>方法中的指令按语句在源文件中出现的顺序执行</li><li><code>&lt;clinit&gt;()</code>不同于类的构造器。（关联：构造器是虚拟机视角下的<code>&lt;init&gt;()</code>）</li><li>若该类具有父类，JVM会保证子类的<code>&lt;clinit&gt;()</code>执行前，父类的<code>&lt;clinit&gt;()</code>已经执行完毕</li><li>虚拟机必须保证一个类的<code>&lt;clinit&gt;()</code>方法在多线程下被同步加锁</li></ul><h5 id="示例1：有static变量"><a href="#示例1：有static变量" class="headerlink" title="示例1：有static变量"></a>示例1：有static变量</h5><pre><code class="highlight java"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ClassInitTest</span> &#123;   <span class="keyword">private</span> <span class="keyword">static</span> <span class="type">int</span> <span class="variable">num</span> <span class="operator">=</span> <span class="number">1</span>;   <span class="keyword">static</span>&#123;       num = <span class="number">2</span>;       number = <span class="number">20</span>;       System.out.println(num);       <span class="comment">//System.out.println(number);//报错：非法的前向引用。</span>   &#125;    <span class="comment">/**</span><span class="comment">     * 1、linking之prepare: number = 0 --&gt; initial: 20 --&gt; 10</span><span class="comment">     * 2、这里因为静态代码块出现在声明变量语句前面，所以之前被准备阶段为0的number变量会</span><span class="comment">     * 首先被初始化为20，再接着被初始化成10</span><span class="comment">     *</span><span class="comment">     */</span>   <span class="keyword">private</span> <span class="keyword">static</span> <span class="type">int</span> <span class="variable">number</span> <span class="operator">=</span> <span class="number">10</span>;  <span class="comment">//linking之prepare: number = 0 --&gt; initial: 20 --&gt; 10</span>    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;        System.out.println(ClassInitTest.num);<span class="comment">//2</span>        System.out.println(ClassInitTest.number);<span class="comment">//10</span>    &#125;&#125;</code></pre><p>​</p><p><img src="https://raw.githubusercontent.com/GeorgeChan95/blogimg/master/img/2023/11/28/20231128-132611.png" alt="image-20231128132610525"></p><pre><code class="highlight plaintext">0: iconst_11: putstatic     #3                  // Field num:I4: iconst_25: putstatic     #3                  // Field num:I8: bipush        2010: putstatic     #5                  // Field number:I13: getstatic     #2                  // Field java/lang/System.out:Ljava/io/PrintStream;16: getstatic     #3                  // Field num:I19: invokevirtual #4                  // Method java/io/PrintStream.println:(I)V22: bipush        1024: putstatic     #5                  // Field number:I27: return</code></pre><p><strong>当我们代码中包含static变量的时候，就会有clinit方法</strong></p><h5 id="示例2：无static变量"><a href="#示例2：无static变量" class="headerlink" title="示例2：无static变量"></a>示例2：无static变量</h5><p>类中没有static修饰的变量时，字节码解析没有 <code>clinit方法</code></p><p><img src="https://raw.githubusercontent.com/GeorgeChan95/blogimg/master/img/2023/11/28/20231128-133933.png" alt="image-20231128133932200"></p><p>添加上static变量后，编译、刷新后可看见c<code>linit方法</code></p><p><img src="https://raw.githubusercontent.com/GeorgeChan95/blogimg/master/img/2023/11/28/20231128-134045.png" alt="image-20231128134044632"></p><h5 id="示例3：构造器内变量赋值"><a href="#示例3：构造器内变量赋值" class="headerlink" title="示例3：构造器内变量赋值"></a>示例3：构造器内变量赋值</h5><p><img src="https://raw.githubusercontent.com/GeorgeChan95/blogimg/master/img/2023/11/28/20231128-140200.png" alt="image-20231128140159587"></p><ul><li>先将局部变量赋值为20</li><li>再将类变量赋值为10</li></ul><h5 id="示例4：先加载父类后加载子类"><a href="#示例4：先加载父类后加载子类" class="headerlink" title="示例4：先加载父类后加载子类"></a>示例4：先加载父类后加载子类</h5><p><img src="https://raw.githubusercontent.com/GeorgeChan95/blogimg/master/img/2023/11/28/20231128-141930.png" alt="image-20231128141929531"></p><p>如上代码，加载流程如下：</p><ul><li>首先，执行 main() 方法需要加载 ClinitTest1 类</li><li>获取 Son.B 静态变量，需要加载 Son 类</li><li>Son 类的父类是 Father 类，所以需要先执行 Father 类的加载，再执行 Son 类的加载</li></ul><h5 id="示例5：clinit同步加锁"><a href="#示例5：clinit同步加锁" class="headerlink" title="示例5：clinit同步加锁"></a>示例5：clinit同步加锁</h5><p>虚拟机必须保证一个类的 <code>&lt;clinit&gt;()</code> 方法在多线程下被同步加锁</p><pre><code class="highlight java"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">DeadThreadTest</span> &#123;    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;        <span class="type">Runnable</span> <span class="variable">r</span> <span class="operator">=</span> () -&gt; &#123;            System.out.println(Thread.currentThread().getName() + <span class="string">&quot;开始&quot;</span>);            <span class="type">DeadThread</span> <span class="variable">dead</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">DeadThread</span>();            System.out.println(Thread.currentThread().getName() + <span class="string">&quot;结束&quot;</span>);        &#125;;        <span class="type">Thread</span> <span class="variable">t1</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Thread</span>(r,<span class="string">&quot;线程1&quot;</span>);        <span class="type">Thread</span> <span class="variable">t2</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Thread</span>(r,<span class="string">&quot;线程2&quot;</span>);        t1.start();        t2.start();    &#125;&#125;<span class="keyword">class</span> <span class="title class_">DeadThread</span>&#123;    <span class="keyword">static</span>&#123;        <span class="keyword">if</span>(<span class="literal">true</span>)&#123;            System.out.println(Thread.currentThread().getName() + <span class="string">&quot;初始化当前类&quot;</span>);            <span class="keyword">while</span>(<span class="literal">true</span>)&#123;            &#125;        &#125;    &#125;&#125;</code></pre><p>输出结果如下：</p><pre><code class="highlight plaintext">线程1开始线程2开始线程1初始化当前类// 程序卡死</code></pre><p>程序卡死，分析原因：</p><ul><li>两个线程同时去加载 DeadThread 类，而 DeadThread 类中静态代码块中有一处死循环</li><li>先加载 DeadThread 类的线程抢到了同步锁，然后在类的静态代码块中执行死循环，而另一个线程在等待同步锁的释放</li><li>所以无论哪个线程先执行 DeadThread 类的加载，另外一个类也不会继续执行。（一个类只会被加载一次）</li></ul><p><strong>静态变量和静态代码块在编译后，都在 <code>clinit方法</code> 中，他们都是类的属性而不属于类的实例的属性，只有在类初始化时加载。</strong></p><h1 id="三、类加载器分类"><a href="#三、类加载器分类" class="headerlink" title="三、类加载器分类"></a>三、类加载器分类</h1><h2 id="1-概述"><a href="#1-概述" class="headerlink" title="1. 概述"></a>1. 概述</h2><ul><li><p>JVM 支持两种类型的类加载器，分別为 <strong>引导类加载器</strong>（ Bootstrap ClassLoader ）和 <strong>自定义类加载器</strong> （ User-Defined ClassLoader ）</p></li><li><p>从概念上来讲，自定义类加载器一般指的是程序中由开发人员自定义的一类类加裁器，但是 Java 虚拟机规范却没有这么定义，而是<strong>将所有派生于抽象类 <code>ClassLoader</code> 的类加载器都划分为自定义类加载器</strong>。</p></li><li><p>无论类加载器的类型如何划分，在程序中我们最常见的类加裁器始终只有 3 个，如下所示：</p></li></ul><p><img src="https://raw.githubusercontent.com/GeorgeChan95/blogimg/master/img/2023/11/28/20231128-091201.png" alt="类加载器分类"></p><pre><code class="highlight java"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ClassLoaderTest</span> &#123;    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;        <span class="comment">//获取系统类加载器</span>        <span class="type">ClassLoader</span> <span class="variable">systemClassLoader</span> <span class="operator">=</span> ClassLoader.getSystemClassLoader();        System.out.println(systemClassLoader);<span class="comment">//sun.misc.Launcher$AppClassLoader@18b4aac2</span>        <span class="comment">//获取其上层：扩展类加载器</span>        <span class="type">ClassLoader</span> <span class="variable">extClassLoader</span> <span class="operator">=</span> systemClassLoader.getParent();        System.out.println(extClassLoader);<span class="comment">//sun.misc.Launcher$ExtClassLoader@1540e19d</span>        <span class="comment">//获取其上层：获取不到引导类加载器</span>        <span class="type">ClassLoader</span> <span class="variable">bootstrapClassLoader</span> <span class="operator">=</span> extClassLoader.getParent();        System.out.println(bootstrapClassLoader);<span class="comment">//null</span>        <span class="comment">//对于用户自定义类来说：默认使用系统类加载器进行加载</span>        <span class="type">ClassLoader</span> <span class="variable">classLoader</span> <span class="operator">=</span> ClassLoaderTest.class.getClassLoader();        System.out.println(classLoader);<span class="comment">//sun.misc.Launcher$AppClassLoader@18b4aac2</span>        <span class="comment">//String类使用引导类加载器进行加载的。---&gt; Java的核心类库都是使用引导类加载器进行加载的。</span>        <span class="type">ClassLoader</span> <span class="variable">classLoader1</span> <span class="operator">=</span> String.class.getClassLoader();        System.out.println(classLoader1);<span class="comment">//null</span>    &#125;&#125;</code></pre><h2 id="2-虚拟机自带的加载器"><a href="#2-虚拟机自带的加载器" class="headerlink" title="2. 虚拟机自带的加载器"></a>2. 虚拟机自带的加载器</h2><h3 id="2-1-启动类加裁器（引导类加载器，-Bootstrap-ClassLoader）"><a href="#2-1-启动类加裁器（引导类加载器，-Bootstrap-ClassLoader）" class="headerlink" title="2.1. 启动类加裁器（引导类加载器， Bootstrap ClassLoader）"></a>2.1. 启动类加裁器（引导类加载器， Bootstrap ClassLoader）</h3><ul><li>这个类加载<strong>使用 C&#x2F;C++ 语言实现</strong>的，嵌套在 JVM 内部。</li><li>它用来加载 Java 的核心库（ JAVA_HOME&#x2F;jre&#x2F;lib&#x2F;rt.jar 、resources.jar 或 sun.boot.class.path 路径下的内容），用于提供 JVM 自身需要的类</li><li>并不继承自 <code>java.lang.Classloader</code>，没有父加载器。</li><li>加载扩展类和应用程序类加载器，并指定为他们的父类加载器。</li><li>出于安全考虑，Bootstrap 启动类加载器只加载包名为 java、javax 、sun 等开头的类</li></ul><h3 id="2-2-扩展类加载器（-Extension-ClassLoader-）"><a href="#2-2-扩展类加载器（-Extension-ClassLoader-）" class="headerlink" title="2.2. 扩展类加载器（ Extension ClassLoader ）"></a>2.2. 扩展类加载器（ Extension ClassLoader ）</h3><p><img src="https://raw.githubusercontent.com/GeorgeChan95/blogimg/master/img/2023/11/28/20231128-093551.png" alt="ExtClassLoader"></p><ul><li><strong>Java 语言编写</strong>，由 <code>sun.misc.Launcher$ExtClassLoader</code> 实现</li><li><strong>派生于 <code>ClassLoader</code> 类</strong></li><li>父类加载器为启动类加载器</li><li>从 <code>java.ext.dirs</code> 系统属性所指定的目录中加载类库，或从 JDK 的安装目录的 <code>jre/lib/ext</code> 子目录（扩展目录）下加载类库。<strong>如果用户创建的 JAR 放在此目录下，也会自动由扩展类加载器加载。</strong></li></ul><pre><code class="highlight java"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ClassLoaderTest1</span> &#123;    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;        System.out.println(<span class="string">&quot;**********启动类加载器**************&quot;</span>);        <span class="comment">//获取BootstrapClassLoader能够加载的api的路径</span>        URL[] urLs = sun.misc.Launcher.getBootstrapClassPath().getURLs();        <span class="keyword">for</span> (URL element : urLs) &#123;            System.out.println(element.toExternalForm());        &#125;        <span class="comment">/**</span><span class="comment">         * 输出结果:</span><span class="comment">         * file:/H:/software/Java/jdk1.8.0_241/jre/lib/resources.jar</span><span class="comment">         * file:/H:/software/Java/jdk1.8.0_241/jre/lib/rt.jar</span><span class="comment">         * file:/H:/software/Java/jdk1.8.0_241/jre/lib/sunrsasign.jar</span><span class="comment">         * file:/H:/software/Java/jdk1.8.0_241/jre/lib/jsse.jar</span><span class="comment">         * file:/H:/software/Java/jdk1.8.0_241/jre/lib/jce.jar</span><span class="comment">         * file:/H:/software/Java/jdk1.8.0_241/jre/lib/charsets.jar</span><span class="comment">         * file:/H:/software/Java/jdk1.8.0_241/jre/lib/jfr.jar</span><span class="comment">         * file:/H:/software/Java/jdk1.8.0_241/jre/classes</span><span class="comment">         * file:/C:/Users/George/AppData/Local/JetBrains/IntelliJIdea2022.2/captureAgent/debugger-agent.jar</span><span class="comment">         */</span>                <span class="comment">//从上面的路径中随意选择一个类,来看看他的类加载器是什么:引导类加载器</span>        <span class="type">ClassLoader</span> <span class="variable">classLoader</span> <span class="operator">=</span> Provider.class.getClassLoader();        System.out.println(classLoader); <span class="comment">// null</span>        System.out.println(<span class="string">&quot;***********扩展类加载器*************&quot;</span>);        <span class="type">String</span> <span class="variable">extDirs</span> <span class="operator">=</span> System.getProperty(<span class="string">&quot;java.ext.dirs&quot;</span>);        <span class="keyword">for</span> (String path : extDirs.split(<span class="string">&quot;;&quot;</span>)) &#123;            System.out.println(path);        &#125;        <span class="comment">/**</span><span class="comment">         * 输出结果:</span><span class="comment">         * H:\software\Java\jdk1.8.0_241\jre\lib\ext</span><span class="comment">         * C:\Windows\Sun\Java\lib\ext</span><span class="comment">         */</span>                <span class="comment">//从上面的路径中随意选择一个类,来看看他的类加载器是什么:扩展类加载器</span>        <span class="type">ClassLoader</span> <span class="variable">classLoader1</span> <span class="operator">=</span> CurveDB.class.getClassLoader();        System.out.println(classLoader1);<span class="comment">//sun.misc.Launcher$ExtClassLoader@1540e19d</span>    &#125;&#125;</code></pre><h3 id="2-3-系统类加载器-System-ClassLoader"><a href="#2-3-系统类加载器-System-ClassLoader" class="headerlink" title="2.3. 系统类加载器(System ClassLoader)"></a>2.3. 系统类加载器(System ClassLoader)</h3><p><img src="https://raw.githubusercontent.com/GeorgeChan95/blogimg/master/img/2023/11/28/20231128-093343.png" alt="image-20231128093342448"></p><ul><li>Java语言编写，由sun.misc.LaunchersAppClassLoader实现</li><li>派生于ClassLoader类</li><li>父类加载器为扩展类加载器</li><li>它负责加载环境变量classpath或系统属性java.class.path指定路径下的类库</li><li>该类加载是程序中默认的类加载器，一般来说，Java应用的类都是由它来完成加载</li><li>通过classLoader.getSystemclassLoader()方法可以获取到该类加载器</li></ul><h2 id="3-用户自定义类加载器"><a href="#3-用户自定义类加载器" class="headerlink" title="3. 用户自定义类加载器"></a>3. 用户自定义类加载器</h2><h3 id="3-1-什么时候需要自定义类加载器？"><a href="#3-1-什么时候需要自定义类加载器？" class="headerlink" title="3.1 什么时候需要自定义类加载器？"></a>3.1 什么时候需要自定义类加载器？</h3><p>在Java的日常应用程序开发中，类的加载几乎是由上述3种类加载器相互配合执行的，在必要时，我们还可以自定义类加载器，来定制类的加载方式。那为什么还需要自定义类加载器？</p><ul><li>隔离加载类（比如说我假设现在Spring框架，和RocketMQ有包名路径完全一样的类，类名也一样，这个时候类就冲突了。不过一般的主流框架和中间件都会自定义类加载器，实现不同的框架，中间是隔离的）</li><li>修改类加载的方式</li><li>扩展加载源（还可以考虑从数据库中加载类，路由器等等不同的地方）</li><li>防止源码泄漏（对字节码文件进行解密，自己用的时候通过自定义类加载器来对其进行解密）</li></ul><h3 id="3-2-如何自定义类加载器？"><a href="#3-2-如何自定义类加载器？" class="headerlink" title="3.2 如何自定义类加载器？"></a>3.2 如何自定义类加载器？</h3><ul><li>开发人员可以通过继承抽象类java.lang.ClassLoader类的方式，实现自己的类加载器，以满足一些特殊的需求</li><li>在JDK1.2之前，在自定义类加载器时，总会去继承ClassLoader类并重写loadClass()方法，从而实现自定义的类加载类，但是在JDK1.2之后已不再建议用户去覆盖loadClass()方法，而是建议把自定义的类加载逻辑写在findclass()方法中。</li><li>在编写自定义类加载器时，如果没有太过于复杂的需求，可以直接继承URIClassLoader类，这样就可以避免自己去编写findclass()方法及其获取字节码流的方式，使自定义类加载器编写更加简洁。</li></ul><p>参考：[自定义类加载器][]</p><p><strong>代码示例：</strong></p><ul><li>基础类：<code>Person</code></li></ul><pre><code class="highlight java"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Person</span> &#123;    <span class="keyword">private</span> String name;    <span class="keyword">public</span> <span class="title function_">Person</span><span class="params">()</span> &#123;    &#125;    <span class="keyword">public</span> <span class="title function_">Person</span><span class="params">(String name)</span> &#123;        <span class="built_in">this</span>.name = name;    &#125;    <span class="keyword">public</span> String <span class="title function_">getName</span><span class="params">()</span> &#123;        <span class="keyword">return</span> name;    &#125;    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setName</span><span class="params">(String name)</span> &#123;        <span class="built_in">this</span>.name = name;    &#125;    <span class="keyword">public</span> String <span class="title function_">toString</span><span class="params">()</span> &#123;        <span class="keyword">return</span> <span class="string">&quot;I am a person, my name is &quot;</span> + name;    &#125;&#125;</code></pre><ul><li>自定义类加载器 <code>MyClassLoader</code></li></ul><pre><code class="highlight java"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">MyClassLoader</span> <span class="keyword">extends</span> <span class="title class_">ClassLoader</span> &#123;    <span class="keyword">public</span> <span class="title function_">MyClassLoader</span><span class="params">()</span> &#123;    &#125;    <span class="keyword">public</span> <span class="title function_">MyClassLoader</span><span class="params">(ClassLoader parent)</span> &#123;        <span class="built_in">super</span>(parent);    &#125;    <span class="keyword">protected</span> Class&lt;?&gt; findClass(String name) <span class="keyword">throws</span> ClassNotFoundException &#123;        <span class="type">File</span> <span class="variable">file</span> <span class="operator">=</span> getClassFile(name);        <span class="keyword">try</span> &#123;            <span class="type">byte</span>[] bytes = getClassBytes(file);            Class&lt;?&gt; c = <span class="built_in">this</span>.defineClass(name, bytes, <span class="number">0</span>, bytes.length);            <span class="keyword">return</span> c;        &#125; <span class="keyword">catch</span> (Exception e) &#123;            e.printStackTrace();        &#125;        <span class="keyword">return</span> <span class="built_in">super</span>.findClass(name);    &#125;    <span class="keyword">private</span> File <span class="title function_">getClassFile</span><span class="params">(String name)</span> &#123;        <span class="type">File</span> <span class="variable">file</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">File</span>(<span class="string">&quot;H:/code_test/Person.class&quot;</span>);        <span class="keyword">return</span> file;    &#125;    <span class="keyword">private</span> <span class="type">byte</span>[] getClassBytes(File file) <span class="keyword">throws</span> Exception &#123;        <span class="comment">// 这里要读入.class的字节，因此要使用字节流</span>        <span class="type">FileInputStream</span> <span class="variable">fis</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">FileInputStream</span>(file);        <span class="type">FileChannel</span> <span class="variable">fc</span> <span class="operator">=</span> fis.getChannel();        <span class="type">ByteArrayOutputStream</span> <span class="variable">baos</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ByteArrayOutputStream</span>();        <span class="type">WritableByteChannel</span> <span class="variable">wbc</span> <span class="operator">=</span> Channels.newChannel(baos);        <span class="type">ByteBuffer</span> <span class="variable">by</span> <span class="operator">=</span> ByteBuffer.allocate(<span class="number">1024</span>);        <span class="keyword">while</span> (<span class="literal">true</span>) &#123;            <span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> fc.read(by);            <span class="keyword">if</span> (i == <span class="number">0</span> || i == -<span class="number">1</span>)                <span class="keyword">break</span>;            by.flip();            wbc.write(by);            by.clear();        &#125;        fis.close();        <span class="keyword">return</span> baos.toByteArray();    &#125;&#125;</code></pre><ul><li>测试</li></ul><pre><code class="highlight java"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">TestMyClassLoader</span> &#123;    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception &#123;        <span class="type">MyClassLoader</span> <span class="variable">mcl</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">MyClassLoader</span>();        Class&lt;?&gt; c1 = Class.forName(<span class="string">&quot;com.atguigu.java1.Person&quot;</span>, <span class="literal">true</span>, mcl);        <span class="type">Object</span> <span class="variable">obj</span> <span class="operator">=</span> c1.newInstance();        System.out.println(obj);        System.out.println(obj.getClass().getClassLoader());    &#125;&#125;</code></pre><p>如果打印了 : sun.misc.Launcher$AppClassLoader，参考： <a href="https://www.cnblogs.com/xrq730/p/4847337.html">自定义类加载器</a></p><ul><li>打印结果</li></ul><pre><code class="highlight plaintext">I am a person, my name is nullcom.atguigu.java1.MyClassLoader@16f65612</code></pre><h2 id="4-关于ClassLoader"><a href="#4-关于ClassLoader" class="headerlink" title="4. 关于ClassLoader"></a>4. 关于ClassLoader</h2><p>ClassLoader类，它是一个抽象类，其后所有的类加载器都继承自ClassLoader（不包括启动类加载器）</p><p><img src="https://raw.githubusercontent.com/GeorgeChan95/blogimg/master/img/2023/11/28/20231128-103945.png" alt="Classloader"></p><p><strong>sun.misc.Launcher 它是一个java虚拟机的入口应用</strong></p><p><img src="https://raw.githubusercontent.com/GeorgeChan95/blogimg/master/img/2023/11/28/20231128-104129.png" alt="ClassLoader继承关系"></p><h3 id="4-1-获取-ClassLoader-的途径"><a href="#4-1-获取-ClassLoader-的途径" class="headerlink" title="4.1 获取 ClassLoader 的途径"></a>4.1 获取 ClassLoader 的途径</h3><table><thead><tr><th>方式</th><th>代码</th></tr></thead><tbody><tr><td>获取当前类的 ClassLoader</td><td><code>clazz.getClassLoader()</code></td></tr><tr><td>获取当前线程上下文的 ClassLoader</td><td><code>Threar.currentThread().getClassLoader()</code></td></tr><tr><td>获取系统的 ClassLoader</td><td><code>ClassLoader.getSystemClassLoader()</code></td></tr><tr><td>获取调用者的 ClassLoader</td><td><code>DriverManager.getCallerClassLoader()</code></td></tr></tbody></table><p><strong>代码示例：</strong></p><pre><code class="highlight java"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ClassLoaderTest2</span> &#123;    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;        <span class="keyword">try</span> &#123;            <span class="comment">//1. String由启动类加载器加载</span>            <span class="type">ClassLoader</span> <span class="variable">classLoader</span> <span class="operator">=</span> Class.forName(<span class="string">&quot;java.lang.String&quot;</span>).getClassLoader();            System.out.println(classLoader); <span class="comment">// null</span>            <span class="comment">//2.系统类加载器</span>            <span class="type">ClassLoader</span> <span class="variable">classLoader1</span> <span class="operator">=</span> Thread.currentThread().getContextClassLoader();            System.out.println(classLoader1); <span class="comment">// sun.misc.Launcher$AppClassLoader@18b4aac2</span>            <span class="comment">//3.系统类加载器的父类加载器</span>            <span class="type">ClassLoader</span> <span class="variable">systemClassLoader</span> <span class="operator">=</span> ClassLoader.getSystemClassLoader();            System.out.println(systemClassLoader);<span class="comment">// sun.misc.Launcher$AppClassLoader@18b4aac2</span>            <span class="type">ClassLoader</span> <span class="variable">classLoader2</span> <span class="operator">=</span> systemClassLoader.getParent();            System.out.println(classLoader2); <span class="comment">// sun.misc.Launcher$ExtClassLoader@3b192d32</span>        &#125; <span class="keyword">catch</span> (ClassNotFoundException e) &#123;            e.printStackTrace();        &#125;    &#125;&#125;</code></pre><h1 id="四、双亲委派机制"><a href="#四、双亲委派机制" class="headerlink" title="四、双亲委派机制"></a>四、双亲委派机制</h1><h2 id="1-双亲委派机制原理"><a href="#1-双亲委派机制原理" class="headerlink" title="1. 双亲委派机制原理"></a>1. 双亲委派机制原理</h2><p>Java虚拟机对class文件采用的是按需加载的方式，也就是说当需要使用该类时才会将它的class文件加载到内存生成class对象。而且加载某个类的class文件时，Java虚拟机采用的是双亲委派模式，即把请求交由父类处理，它是一种任务委派模式</p><ul><li>如果一个类加载器收到了类加载请求，它并不会自己先去加载，而是把这个请求委托给父类的加载器去执行；</li><li>如果父类加载器还存在其父类加载器，则进一步向上委托，依次递归，请求最终将到达顶层的启动类加载器；</li><li>如果父类加载器可以完成类加载任务，就成功返回，倘若父类加载器无法完成此加载任务，子加载器才会尝试自己去加载，这就是双亲委派模式。</li><li>父类加载器一层一层往下分配任务，如果子类加载器能加载，则加载此类，如果将加载任务分配至系统类加载器也无法加载此类，则抛出异常</li></ul><img src="https://raw.githubusercontent.com/GeorgeChan95/blogimg/master/img/2023/11/28/20231128-110045.png" alt="双亲委派机制" style="zoom:50%;" /><h2 id="2-双亲委派机制代码演示"><a href="#2-双亲委派机制代码演示" class="headerlink" title="2. 双亲委派机制代码演示"></a>2. 双亲委派机制代码演示</h2><h3 id="演示1：自定义String类"><a href="#演示1：自定义String类" class="headerlink" title="演示1：自定义String类"></a>演示1：自定义String类</h3><p>我们自己建立一个 java.lang.String 类，写上 static 代码块</p><pre><code class="highlight java"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">String</span> &#123;    <span class="comment">//</span>    <span class="keyword">static</span>&#123;        System.out.println(<span class="string">&quot;我是自定义的String类的静态代码块&quot;</span>);    &#125;&#125;</code></pre><p>在另外的程序中加载 String 类，看看加载的 String 类是 JDK 自带的 String 类，还是我们自己编写的 String 类</p><pre><code class="highlight java"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">StringTest</span> &#123;    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;        java.lang.<span class="type">String</span> <span class="variable">str</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">java</span>.lang.String();        System.out.println(<span class="string">&quot;hello,atguigu.com&quot;</span>);        <span class="type">StringTest</span> <span class="variable">test</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">StringTest</span>();        System.out.println(test.getClass().getClassLoader());    &#125;&#125;</code></pre><p>输出结果：</p><pre><code class="highlight plaintext">hello,atguigu.comsun.misc.Launcher$AppClassLoader@18b4aac2</code></pre><p><em>程序并没有输出我们静态代码块中的内容，可见仍然加载的是 JDK 自带的 String 类。</em></p><p>把刚刚的类改一下。</p><pre><code class="highlight java"><span class="keyword">package</span> java.lang;<span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">String</span> &#123;    <span class="comment">//</span>    <span class="keyword">static</span>&#123;        System.out.println(<span class="string">&quot;我是自定义的String类的静态代码块&quot;</span>);    &#125;    <span class="comment">//错误: 在类 java.lang.String 中找不到 main 方法</span>    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;        System.out.println(<span class="string">&quot;hello,String&quot;</span>);    &#125;&#125;</code></pre><p>执行后，报错如下：</p><pre><code class="highlight plaintext">错误: 在类 java.lang.String 中找不到 main 方法, 请将 main 方法定义为:   public static void main(String[] args)否则 JavaFX 应用程序类必须扩展javafx.application.Application</code></pre><p><strong>原因：</strong>由于双亲委派机制一直找父类，所以最后找到了Bootstrap ClassLoader，Bootstrap ClassLoader找到的是 JDK 自带的 String 类，在那个String类中并没有 main() 方法，所以就报了上面的错误。</p><h3 id="演示2：使用受保护的包名"><a href="#演示2：使用受保护的包名" class="headerlink" title="演示2：使用受保护的包名"></a>演示2：使用受保护的包名</h3><p>在自己的代码中创建包：<code>java.lang</code> ,  然后在这个包下新建类：<code>ShkStart</code></p><pre><code class="highlight java"><span class="keyword">package</span> java.lang;<span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ShkStart</span> &#123;    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;        System.out.println(<span class="string">&quot;hello!&quot;</span>);    &#125;&#125;</code></pre><p>输出结果：</p><pre><code class="highlight plaintext">java.lang.SecurityException: Prohibited package name: java.langat java.lang.ClassLoader.preDefineClass(ClassLoader.java:662)at java.lang.ClassLoader.defineClass(ClassLoader.java:761)at java.security.SecureClassLoader.defineClass(SecureClassLoader.java:142)at java.net.URLClassLoader.defineClass(URLClassLoader.java:467)at java.net.URLClassLoader.access$100(URLClassLoader.java:73)at java.net.URLClassLoader$1.run(URLClassLoader.java:368)at java.net.URLClassLoader$1.run(URLClassLoader.java:362)at java.security.AccessController.doPrivileged(Native Method)at java.net.URLClassLoader.findClass(URLClassLoader.java:361)at java.lang.ClassLoader.loadClass(ClassLoader.java:424)at sun.misc.Launcher$AppClassLoader.loadClass(Launcher.java:335)at java.lang.ClassLoader.loadClass(ClassLoader.java:357)at sun.launcher.LauncherHelper.checkAndLoadMain(LauncherHelper.java:495)Error: A JNI error has occurred, please check your installation and try againException in thread &quot;main&quot; Process finished with exit code 1</code></pre><p><strong>即使类名没有重复，也禁止使用java.lang这种包名。这是一种保护机制</strong></p><h3 id="演示3：jdbc-jar"><a href="#演示3：jdbc-jar" class="headerlink" title="演示3：jdbc.jar"></a>演示3：jdbc.jar</h3><p>当我们加载jdbc.jar 用于实现数据库连接的时候</p><ul><li>我们现在程序中需要用到SPI接口，而SPI接口属于rt.jar包中Java核心api</li><li>然后使用双清委派机制，引导类加载器把rt.jar包加载进来，而rt.jar包中的SPI存在一些接口，接口我们就需要具体的实现类了</li><li>具体的实现类就涉及到了某些第三方的jar包了，比如我们加载SPI的实现类jdbc.jar包【首先我们需要知道的是 jdbc.jar是基于SPI接口进行实现的】</li><li>第三方的jar包中的类属于系统类加载器来加载</li><li>从这里面就可以看到SPI核心接口由引导类加载器来加载，SPI具体实现类由系统类加载器来加载</li></ul><p><img src="https://raw.githubusercontent.com/GeorgeChan95/blogimg/master/img/2023/11/28/20231128-111246.png" alt="SPI-JDBC"></p><p>总结：SPI核心接口由引导类加载器加载，接口的具体实现由系统类加载器加载。</p><h2 id="3-双亲委派机制优势"><a href="#3-双亲委派机制优势" class="headerlink" title="3. 双亲委派机制优势"></a>3. 双亲委派机制优势</h2><ul><li>避免类的重复加载</li><li>保护程序安全，防止核心API被随意篡改<ul><li>自定义类：自定义java.lang.String 没有被加载。</li><li>自定义类：java.lang.ShkStart（报错：阻止创建 java.lang开头的类）</li></ul></li></ul><h1 id="五、沙箱安全机制"><a href="#五、沙箱安全机制" class="headerlink" title="五、沙箱安全机制"></a>五、沙箱安全机制</h1><p>自定义String类时：在加载自定义String类的时候会率先使用引导类加载器加载，而引导类加载器在加载的过程中会先加载jdk自带的文件（rt.jar包中java.lang.String.class），报错信息说没有main方法，就是因为加载的是rt.jar包中的String类。这样可以保证对java核心源代码的保护，这就是沙箱安全机制。</p><h1 id="六、其他"><a href="#六、其他" class="headerlink" title="六、其他"></a>六、其他</h1><h2 id="1-如何判断两个class对象是否相同？"><a href="#1-如何判断两个class对象是否相同？" class="headerlink" title="1. 如何判断两个class对象是否相同？"></a>1. 如何判断两个class对象是否相同？</h2><p>在JVM中表示两个class对象是否为同一个类存在两个必要条件：</p><ul><li>类的完整类名必须一致，包括包名</li><li><strong>加载这个类的ClassLoader（指ClassLoader实例对象）必须相同</strong></li></ul><p>换句话说，在JVM中，即使这两个类对象（class对象）来源同一个Class文件，被同一个虚拟机所加载，但只要加载它们的ClassLoader实例对象不同，那么这两个类对象也是不相等的</p><h2 id="2-对类加载器的引用"><a href="#2-对类加载器的引用" class="headerlink" title="2. 对类加载器的引用"></a>2. 对类加载器的引用</h2><ul><li>JVM必须知道一个类型是由启动加载器加载的还是由用户类加载器加载的</li><li><strong>如果一个类型是由用户类加载器加载的，那么JVM会将这个类加载器的一个引用作为类型信息的一部分保存在方法区中</strong></li><li>当解析一个类型到另一个类型的引用的时候，JVM需要保证这两个类型的类加载器是相同的</li></ul><h2 id="3-文件头示例"><a href="#3-文件头示例" class="headerlink" title="3. 文件头示例"></a>3. 文件头示例</h2><p><img src="https://raw.githubusercontent.com/GeorgeChan95/blogimg/master/img/2023/11/25/20231125-153009.png" alt="image-20231125153008206"></p>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;环境&quot;&gt;&lt;a href=&quot;#环境&quot; class=&quot;headerlink&quot; title=&quot;环境&quot;&gt;&lt;/a&gt;环境&lt;/h1&gt;&lt;blockquote&gt;
&lt;p&gt;系统 : Windows 10&lt;/p&gt;
&lt;p&gt;JDK : 1.8&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h1 id</summary>
      
    
    
    
    <category term="JVM" scheme="https://georgechan95.github.io/categories/JVM/"/>
    
    
    <category term="jvm" scheme="https://georgechan95.github.io/tags/jvm/"/>
    
    <category term="java" scheme="https://georgechan95.github.io/tags/java/"/>
    
    <category term="双亲委派机制" scheme="https://georgechan95.github.io/tags/%E5%8F%8C%E4%BA%B2%E5%A7%94%E6%B4%BE%E6%9C%BA%E5%88%B6/"/>
    
  </entry>
  
  <entry>
    <title>第一章-JVM和Java体系结构</title>
    <link href="https://georgechan95.github.io/2023/11/25/jvm/%E7%AC%AC%E4%B8%80%E7%AB%A0-JVM%E5%92%8CJava%E4%BD%93%E7%B3%BB%E7%BB%93%E6%9E%84/"/>
    <id>https://georgechan95.github.io/2023/11/25/jvm/%E7%AC%AC%E4%B8%80%E7%AB%A0-JVM%E5%92%8CJava%E4%BD%93%E7%B3%BB%E7%BB%93%E6%9E%84/</id>
    <published>2023-11-25T02:00:00.000Z</published>
    <updated>2024-06-22T10:36:12.823Z</updated>
    
    <content type="html"><![CDATA[<h1 id="环境"><a href="#环境" class="headerlink" title="环境"></a>环境</h1><blockquote><p>系统 : Windows 10</p><p>JDK : 1.8</p></blockquote><h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>大部分Java开发人员，除了会在项目中使用到与Java平台相关的各种高精尖技术，对于Java技术的核心Java虚拟机了解甚少。在项目的开发过程中，可能会遇到虾米那这些问题。</p><ul><li>运行着的线上系统突然卡死，系统无法访问，甚至直接OOM！</li><li>想解决线上JVM GC问题，但却无从下手。</li><li>新项目上线，对各种JVM参数设置一脸茫然，只好使用默认配置。</li><li>每次面试之前都要重新背一遍JVM的一些原理概念性的东西，然而面试官却经常问你在实际项目中如何调优VM参数，如何解决GC、OOM等问题，一脸懵逼。</li></ul><h1 id="我们为什么要学习JVM"><a href="#我们为什么要学习JVM" class="headerlink" title="我们为什么要学习JVM"></a>我们为什么要学习JVM</h1><ul><li>面试的需要（BATJ、TMD，PKQ等面试都爱问）</li><li>中高级程序员必备技能</li><li>项目管理、调优的需要</li><li>追求极客的精神<ul><li>比如：垃圾回收算法、JIT、底层原理</li></ul></li></ul><h1 id="Java-VS-C"><a href="#Java-VS-C" class="headerlink" title="Java VS C++"></a>Java VS C++</h1><ol><li>Java的垃圾收集机制为我们打理了很多繁琐的工作，大大提高了开发的效率，但是，垃圾收集也不是万能的，懂得JVM内部的内存结构、工作机制，是设计高扩展性应用和诊断运行时问题的基础，也是Java工程师进阶的必备能力。</li><li>C++语言需要程序员自己来分配内存和回收内存，对于高手来说可能更加舒服，但是对于普通开发者，如果技术实力不够，很容易造成内存泄漏。而Java全部交给JVM进行内存分配和回收，这也是一种趋势，减少程序员的工作量。</li></ol><p><img src="https://raw.githubusercontent.com/GeorgeChan95/blogimg/master/img/2023/11/25/20231125-104520.jpg" alt="Java-vs-C++"></p><h1 id="Java官方文档"><a href="#Java官方文档" class="headerlink" title="Java官方文档"></a>Java官方文档</h1><p><a href="https://docs.oracle.com/javase/specs/index.html">Java 语言和虚拟机规范</a> </p><h1 id="Open-JDK和Oracle-JDK"><a href="#Open-JDK和Oracle-JDK" class="headerlink" title="Open JDK和Oracle JDK"></a>Open JDK和Oracle JDK</h1><p>在JDK11之前，Oracle JDK中还会存在一些Open JDK中没有的，闭源的功能。但在JDK11中，我们可以认为Open JDK和Oracle JDK代码实质上已经达到完全一致的程度了。主要的区别就是两者更新周期不一样</p><h1 id="什么是虚拟机"><a href="#什么是虚拟机" class="headerlink" title="什么是虚拟机"></a>什么是虚拟机</h1><h2 id="虚拟机概念"><a href="#虚拟机概念" class="headerlink" title="虚拟机概念"></a>虚拟机概念</h2><p>所谓虚拟机（Virtual Machine），就是一台虚拟的计算机。它是一款软件，用来执行一系列虚拟计算机指令。大体上，虚拟机可以分为系统虚拟机和程序虚拟机。</p><ul><li>系统虚拟机<ul><li>大名鼎鼎的Virtual Box，VMware就属于系统虚拟机，它们完全是对物理计算机硬件的仿真(模拟)，提供了一个可运行完整操作系统的软件平台。</li></ul></li><li>程序虚拟机<ul><li>程序虚拟机的典型代表就是Java虚拟机，它专门为执行单个计算机程序而设计，在Java虚拟机中执行的指令我们称为Java字节码指令。</li></ul></li></ul><p>无论是系统虚拟机还是程序虚拟机，在上面运行的软件都被限制于虚拟机提供的资源中。</p><h2 id="Java虚拟机"><a href="#Java虚拟机" class="headerlink" title="Java虚拟机"></a>Java虚拟机</h2><ul><li>Java虚拟机是一台执行Java字节码的虚拟计算机，它拥有独立的运行机制，其运行的Java字节码也未必由Java语言编译而成。</li><li>JVM平台的各种语言可以共享Java虚拟机带来的跨平台性、优秀的垃圾回器，以及可靠的即时编译器。</li><li><strong>Java技术的核心就是Java虚拟机</strong>（JVM，Java Virtual Machine），因为所有的Java程序都运行在Java虚拟机内部。</li></ul><h3 id="作用"><a href="#作用" class="headerlink" title="作用"></a>作用</h3><p>Java虚拟机就是二进制字节码的运行环境，负责装载字节码到其内部，解释&#x2F;编译为对应平台上的机器指令执行。每一条Java指令，Java虚拟机规范中都有详细定义，如怎么取操作数，怎么处理操作数，处理结果放在哪里。</p><h3 id="特点"><a href="#特点" class="headerlink" title="特点"></a>特点</h3><ul><li>一次编译，到处运行</li><li>自动内存管理</li><li>自动垃圾回收功能</li></ul><h1 id="JVM的位置"><a href="#JVM的位置" class="headerlink" title="JVM的位置"></a>JVM的位置</h1><p>JVM是运行在操作系统之上的，它与硬件没有直接的交互</p><p><img src="https://raw.githubusercontent.com/GeorgeChan95/blogimg/master/img/2023/11/25/20231125-110500.jpg" alt="JVM所处位置"></p><p><img src="https://raw.githubusercontent.com/GeorgeChan95/blogimg/master/img/2023/11/25/20231125-112429.png" alt="jvm的位置"></p><h1 id="JVM的整体结构"><a href="#JVM的整体结构" class="headerlink" title="JVM的整体结构"></a>JVM的整体结构</h1><p>从整体上看，JVM内部被划分为一下五个部分：</p><ol><li>类加载子系统</li><li>运行时数据区</li><li>执行引擎</li><li>本地方法接口</li><li>本地方法库</li></ol><p><img src="https://raw.githubusercontent.com/GeorgeChan95/blogimg/master/img/2023/11/25/20231125-110950.png" alt="image-20231125110949260"></p><p><strong>备注：</strong></p><ul><li>HotSpot VM是目前市面上高性能虚拟机的代表作之一。</li><li>它采用解释器与即时编译器并存的架构。</li><li>在今天，Java程序的运行性能早已脱胎换骨，已经达到了可以和C&#x2F;C++程序一较高下的地步。</li></ul><h1 id="Java-代码执行流程"><a href="#Java-代码执行流程" class="headerlink" title="Java 代码执行流程"></a>Java 代码执行流程</h1><p><img src="https://raw.githubusercontent.com/GeorgeChan95/blogimg/master/img/2023/11/25/20231125-112820.png" alt="Java代码执行流程"></p><h1 id="JVM的架构模型"><a href="#JVM的架构模型" class="headerlink" title="JVM的架构模型"></a>JVM的架构模型</h1><p><strong>Java 编译器输入的指令流基木上是一种基于栈的指令集架构</strong>，另外一种指令集架构则是<strong>基于寄存器的指令集架构</strong>。</p><h2 id="架构特点"><a href="#架构特点" class="headerlink" title="架构特点"></a>架构特点</h2><p>具体来说，这两种架构之间的区别：</p><ul><li>基于栈式架构的特点<ul><li>设计和实现更简单，适用于资源受限的系统；</li><li>避开了寄存器的分配难题：<strong>使用零地址指令方式分配</strong>。</li><li>指令流中的指令大部分是零地址指令，其执行过程依赖于操作栈。指令集更小，编译器容易实现。</li><li>不需要硬件支持，可移植性更好，更好实现跨平台</li></ul></li><li>基于寄存器架构的特点<ul><li>典型的应用是 x86 的二进制指令集：比如传统的 PC 以及 Android 的 Davlik 虚拟机。</li><li><strong>指令集架构则完全依赖硬件，可移植性差</strong></li><li><strong>性能优秀和执行更高效</strong></li><li>花费更少的指令去完成一项操作。</li><li>在大部分情况下，基于寄存器架构的指令集往往都以一地址指令、二地址指令和三地址指令为主，而基于栈式架构的指令集却是以零地址指令为主。</li></ul></li></ul><h2 id="字节码对比"><a href="#字节码对比" class="headerlink" title="字节码对比"></a>字节码对比</h2><p>同样执行2+3这种逻辑操作，其指令分别如下：</p><ul><li><p><strong>基于栈的计算流程（以Java虚拟机为例）：</strong></p><pre><code class="highlight plaintext">iconst_2 // 常量2入栈istore_1iconst_3 // 常量3入栈istore_2iload_1iload_2iadd // 常量2/3出栈，执行相加istore_0 // 结果5入栈</code></pre><p>8个指令</p></li><li><p><strong>而基于寄存器的计算流程</strong></p><pre><code class="highlight plaintext">mov eax,2 // 将eax寄存器的值设为1add eax,3 // 使eax寄存器的值加3</code></pre><p>2个指令</p></li></ul><h2 id="JVM架构总结"><a href="#JVM架构总结" class="headerlink" title="JVM架构总结"></a>JVM架构总结</h2><ul><li><strong>由于跨平台性的设计，Java的指令都是根据栈来设计的</strong>。不同平台CPU架构不同，所以不能设计为基于寄存器的。栈的优点：跨平台，指令集小，编译器容易实现，缺点是性能比寄存器差一些。</li><li>时至今日，尽管嵌入式平台已经不是Java程序的主流运行平台了（准确来说应该是HotSpot VM的宿主环境已经不局限于嵌入式平台了），那么为什么不将架构更换为基于寄存器的架构呢？因为基于栈的架构跨平台性好、指令集小，虽然相对于基于寄存器的架构来说，基于栈的架构编译得到的指令更多，执行性能也不如基于寄存器的架构好，但考虑到其跨平台性与移植性，我们还是选用栈的架构</li></ul><h1 id="JVM的生命周期"><a href="#JVM的生命周期" class="headerlink" title="JVM的生命周期"></a>JVM的生命周期</h1><h2 id="虚拟机的启动"><a href="#虚拟机的启动" class="headerlink" title="虚拟机的启动"></a>虚拟机的启动</h2><p>Java虚拟机的启动是通过引导类加载器（bootstrap class loader）创建一个初始类（initial class）来完成的，这个类是由虚拟机的具体实现指定的。</p><h2 id="虚拟机的执行"><a href="#虚拟机的执行" class="headerlink" title="虚拟机的执行"></a>虚拟机的执行</h2><ul><li>一个运行中的Java虚拟机有着一个清晰的任务：执行Java程序</li><li>程序开始执行时他才运行，程序结束时他就停止</li><li><strong>执行一个所谓的Java程序的时候，真真正正在执行的是一个叫做Java虚拟机的进程</strong></li></ul><h2 id="虚拟机的退出"><a href="#虚拟机的退出" class="headerlink" title="虚拟机的退出"></a>虚拟机的退出</h2><p>有如下的几种情况：</p><ol><li>程序正常执行结束</li><li>程序在执行过程中遇到了异常或错误而异常终止</li><li>由于操作系统用现错误而导致Java虚拟机进程终止</li><li>某线程调用Runtime类或System类的exit()方法，或Runtime类的halt()方法，并且Java安全管理器也允许这次exit()或halt()操作。</li><li>除此之外，JNI（Java Native Interface）规范描述了用JNI Invocation API来加载或卸载 Java虚拟机时，Java虚拟机的退出情况。</li></ol><h1 id="JVM发展历程"><a href="#JVM发展历程" class="headerlink" title="JVM发展历程"></a>JVM发展历程</h1><ul><li><p>Sun Classic VM</p><ul><li>早在 1996 年 Java 1.0 版本的时候， Sun 公司发布了一款名为 Sun Classic VM 的 J ava 虚拟机，它同时也是世界上第一款商用 Java 虚拟机， JDK1.4 时完全被淘汰。</li><li>这款虚拟机内部只提供解释器。如果使用 JIT 编译器，就需要进行外挂。但是一旦使用了 J 编译器， J エ T 就会接管虚拟机的执行系统。解释器就不再工作。解释器和编译器不能配合工作</li><li>现在 hotspot 内置了此虚拟机。</li></ul></li><li><p>Exact VM</p><ul><li>为了解決上一个虚拟机问题，jdk1.2 时， sun 提供了此虚拟机。</li><li>Exact Memory Management ：准确式内存管理<ul><li>也可以叫 Non-Conservative &#x2F; Accurate Memory Management</li><li>虚拟机可以知道内存中某个位置的数据具体是什么类型。</li></ul></li><li>具备现代高性能虚拟机的雏形<ul><li>热点探测</li><li>编译器与解释器混合工作模式</li></ul></li><li>只在 Solaris 平台短暂使用，其他平台上还是 classic vm</li><li>英雄气短，终被 Hotspot 虚拟机替换</li></ul></li><li><p>SUN 公司的 Hotspot VM</p><ul><li>Hotspot 历史<ul><li>最初由一家名为 “ Longview Technologies “ 的小公司设计</li><li>1997 年，此公司被 Sun 收购； 2009 年， Sun 公司被甲骨文收购。</li><li>JDK 1. 3 时， Hotspot VM 成为默认虚拟机</li></ul></li><li>目前Hotspot 占有绝对的市场地位，称霸武林。<ul><li>不管是现在仍在广泛使用的 JDK 6，还是使用比例较多的 JDK 8中，默认的虛拟机都是 Hotspot</li><li>Sun &#x2F; Oracle JDK 和 OpenJDK 的默认虚拟机</li><li>因此本课程中默认介绍的虚拟机都是 Hotspot，相关机制也主要是指 Hotspot 的 GC 机制。（比如其他两个商用虚拟机都没有方法区的概念）</li></ul></li><li>从服务器、桌面到移动端、嵌入式都有应用。</li><li>名称中的 Hotspot 指的就是它的热点代码探测技术。<ul><li>通过计数器找到最具编译价值代码，触发即时编译或栈上替换</li><li>通过编译器与解释器协同工作，在最优化的程序响应时间与最佳执行性能中取得平衡</li></ul></li></ul></li><li><p>BEA 的 JRockit</p><ul><li>专注于服务器端应用<ul><li>它可以不太关注程序启动速度，因此 <strong>JRockit 内部不包含解析器实现</strong>，全部代码都靠即时编译器编译后执行。</li></ul></li><li>大量的行业基准测试显示，JRockit JVM 是世界上最快的 JVM<ul><li>使用 JRockit 产品，客户已经体验到了显著的性能提高（一些超过了 70%）和硬件成本的减少（达 50%）。</li></ul></li><li>优势：全而的 Java 运行时解决方案组合<ul><li>JRockit 面向延迟敏感型应用的解决方案 JRockit Real Time 提供以毫秒或微秒级的 JVM 响应时间，适合财务、军事指挥、电信网络的需要</li><li>MissionControl 服务套件，它是一组以极低的开销来监控、管理和分析生产坏境中的应用程序的工具。</li></ul></li><li>2008 年， BEA 被 Oracle 收购</li><li>Oracle 表达了整合两大优秀虚拟机的工作，大致在 JDK8 中完成。整合的方式是在 Hotspot 的基础上，移植 JRockit的优秀特性。</li><li>高斯林：目前就职于谷歌，研究人工智能和水下机器人</li></ul></li><li><p>IBM 的 J9</p><ul><li>全称：IBM Technology for Java Virtual Machine ，简称 IT4J ，内部代号： J9</li><li>市场定位与 Hotspot 接近，服务器端、桌而应用、嵌入式等多用途 VM</li><li>广泛用于 IBM 的各种 Java 产品。</li><li>目前，<strong>有影响力的三大商用虚拟机之一</strong>，也号称是世界上最快的Java虚拟机。</li><li>2017 年左右，IBM 发布了开源 J9 VM ，命名为 OpenJ9，交给 Eclipse 基金会管理，也称为 Eclipse OpenJ9</li></ul></li><li><p>KVM 和 CDC&#x2F;CLDC Hotspot</p><ul><li>Oracle 在 Java ME 产品线上的两款虛拟机为： CDC&#x2F;CLDC Hotspot Implementation VM</li><li>KVM（Kilobyte ）是 CLDC-HI 早期产品</li><li>目前移动领域地位尴尬，智能平机被 Android 和 IOS 二分天下。</li><li>KVM 简单、轻量、高度可移植，面向更低端的设备上还维持自己的一片市场<ul><li>智能控制器、传感器</li><li>老人手机、经济欠发达地区的功能手机</li></ul></li><li>所有的虛拟机的原则：一次编译，到处运行。</li></ul></li><li><p>Azul VM</p><ul><li><p>前面三大 “高性能 Java 虚拟机” 使用在通用硬件平台上</p></li><li><p>这里 Azul VM 和 BEA Liquid VM 是</p><p>与特定硬件平台绑定、软硬件配合的专有虚拟机</p><ul><li>高性能 Java 虚拟机中的战斗机。</li></ul></li><li><p>Azul VM 是 Azul Systems 公司在 Hotspot 基础上进行大量改进，运行于 Azul Systems 公司的专有硬件 Vega 系统上的 Java 虚拟机。</p></li><li><p><strong>每个 Azul VM 实例都可以管理至少数十个 CPU 和数百 GB 内存的硬件资源，并提供在巨大内存范围内实现可控的 GC 时间的垃圾收集器、专有硬件优化的线程调度等优秀特性</strong></p></li><li><p>2010 年，Azul Systems 公司开始从硬件转向软件，发布了自己的 Zing JVM ，可以在通用 x86 平台上提供接近于 Vega 系统的特性。</p></li></ul></li><li><p>Liquid VM</p><ul><li>高性能 Java 虚拟机中的战斗机。</li><li>BEA 公司开发的，直接运行在自家 Hypervisor 系统上</li><li>Liquid VM 即是现在的 JRockit VE（ Virtual Edition ）， Liquid VM 不需要操作系统的支持，或者说它自己本身实现了一个专用操作系统的必要功能，如线程调度、文件系统、网络支持等。</li><li>随着 JRockit 虚拟机终止开发， Liquid VM项目也停止了。</li></ul></li><li><p>Apache Harmony</p><ul><li>Apache 也曾经推出过与 JDK 1.5 和 JDK 1.6 兼容的 Java 运行平台 Apache Harmony</li><li>它是 IBM 和 Intel 联合开发的开源 JVM ，受到同样开源的 OpenJDK 的压制，Sun 坚决不让 Harmony 获得 JCP 认证，最终于 2011 年退役， IBM 转而参与 OpenJDK</li><li>虽然目前并没有 Apache Harmony 被大规模商用的案例，但是它的 Java 类库代码吸纳进了 Android SDK。</li></ul></li><li><p>Microsoft JVM</p><ul><li>微软为了在工 E3 浏览器中支持 Java Applets ，开发了 Microsoft JVM 。</li><li>只能在 Windows 平台下运行。但确是当时 Windows 下性能最好的 Java VM 。</li><li>1997 年， Sun 以侵犯商标、不正当竞争罪名指控微软成功，赔了 Sun 很多钱。微软在 Windows SP3 中抹掉了其 VM 。现在 Windows 上安装的 JDK 都是 Hotspot</li></ul></li><li><p>TaobaoJVM</p><ul><li>由 Ali JVM团队发布。阿里，国内使用 Java 最强大的公司，覆盖云计算、金融、物流电商等众多领域，需要解决高并发、高可用、分布式的复合问题。有大量的开源产品</li><li><strong>基于 OpenJDK 开发了自己的定制版本 AlibabaJDK</strong> ，简称 AJDK。是整个阿里 Java体系的基石。</li><li>基于 OpenJDK Hotspot VM 发布的国内第一个优化、深度定制且开源的高性能服务器版 Java虚拟机<ul><li>创新的 GCIH（ GC invisible heap ）技术实现了 off-heap ，<strong>即将生命周期较长的 Java对象从 heap 中移到heap 之外，并且 GC 不能管理 GCIH 内部的 Java对象，以此达到降低 GC 的回收频率和提升 GC 的回收效率的目的</strong></li><li>GCIH 中的<strong>对象还能够在多个 Java虚拟机进程中实现共享</strong></li><li>使用 crc32 指令实现 JVM intrinsic 降低 JNI 的调用开销 \</li><li>PMU hardware 的 Java profiling tool 和诊断协助功能</li><li>针对大数据场景的 ZenGC</li></ul></li><li>taobao vm 应用在阿里产品上性能高，硬件严重依赖 intel 的 cpu损失了兼容性，但提高了性能<ul><li>目前已经在淘宝、天猫上线，把 Oracle 官方 JVM版木全部替换了。</li></ul></li></ul></li><li><p>Dalvik VM</p><ul><li>谷歌开发的，应用于 Android 系统，并在 Android 2.2 中提供了 JIT ，发展迅猛。</li><li><strong>Dalvik vm 只能称作虚拟机，而不能称作“Java虚拟机”</strong>，它没有遵循Java虚拟机规范</li><li>不能直接执行 Java 的 Class 文件</li><li>基于寄存器架构，不是 jvm 的栈架构</li><li>执行的是编译以后的 dex（ Dalvik Executable ）文件。执行效率比较高<ul><li>它执行的 dek（ Dalvik Executable ）文件可以通过 class 文件转化而来，使用 Java 语法编写应用程序，可以直接使用大部分的 Java api 等。</li></ul></li><li>Android 5. 0 使用支持提前编译（ Ahead of Time Compilation ， AOT ）的 ART VM 替换 Dalvik VM 。</li></ul></li><li><p>Graal VM</p><ul><li>2018 年 4 月， Oracle Labs 公开了 Graal VM，号称 “ <strong>Run Programs Faster Anywhere</strong> “，勃勃野心。</li><li>与 1995 年 Java 的 “ write once, run anywhere “ 遥相呼应。</li><li>Graal VM 在 Hotspot VM 基础上増强而成的<strong>跨语言全栈虚拟机，可以作为 “任何语言” 的运行平台使用</strong>。语言包括： Java 、Scala 、 Groovy 、 Kotlin ； C 、 C ++、 JavaScript、 Ruby、 Python 、 R 等</li><li>支持不同语言中混用对方的接口和对象，支持这些语言使用已经编写好的本地库文件</li><li>工作原理是将这些语言的源代码或源代码编译后的中间格式，通过解释器转换为能被 Graal VM 接受的中间表示。Graal VM 提供 Truffle 工具集快速构建面向一种新语言的解释器。在运行时还能进行即时编译优化，获得比原生编译器更优秀的执行效率。</li><li><strong>如果说 HotSpot 有一天真的被取代，Graal VM 希望最大</strong>。但是 Java 的软件生态没有丝毫变化</li></ul></li></ul><p><strong>总结</strong></p><p>具体JVM的内存结构，其实取决于其实现，不同厂商的JVM，或者同一厂商发布的不同版本，都有可能存在一定差异。主要以Oracle HotSpot VM为默认虚拟机。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;环境&quot;&gt;&lt;a href=&quot;#环境&quot; class=&quot;headerlink&quot; title=&quot;环境&quot;&gt;&lt;/a&gt;环境&lt;/h1&gt;&lt;blockquote&gt;
&lt;p&gt;系统 : Windows 10&lt;/p&gt;
&lt;p&gt;JDK : 1.8&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h1 id</summary>
      
    
    
    
    <category term="JVM" scheme="https://georgechan95.github.io/categories/JVM/"/>
    
    
    <category term="jvm" scheme="https://georgechan95.github.io/tags/jvm/"/>
    
    <category term="java" scheme="https://georgechan95.github.io/tags/java/"/>
    
  </entry>
  
  <entry>
    <title>给博客网站添加站点地图-sitemap</title>
    <link href="https://georgechan95.github.io/2023/11/21/hexo/%E5%8D%9A%E5%AE%A2%E6%B7%BB%E5%8A%A0Sitemap/"/>
    <id>https://georgechan95.github.io/2023/11/21/hexo/%E5%8D%9A%E5%AE%A2%E6%B7%BB%E5%8A%A0Sitemap/</id>
    <published>2023-11-21T12:00:00.000Z</published>
    <updated>2024-06-22T10:36:12.823Z</updated>
    
    <content type="html"><![CDATA[<h1 id="环境"><a href="#环境" class="headerlink" title="环境"></a>环境</h1><blockquote><p>系统 : Windows 10</p><p>NodeJS : 14.21.3</p></blockquote><h1 id="站点地图"><a href="#站点地图" class="headerlink" title="站点地图"></a>站点地图</h1><p>站点地图是一个网站所有链接的容器。很多网站的连接层次比较深，爬虫很难抓取到，站点地图可以方便爬虫抓取网站页面，通过抓取网站页面，清晰了解网站的架构，网站地图一般存放在根目录下并命名 sitemap，为爬虫指路，增加网站重要内容页面的收录。</p><p>站点地图就是根据网站的结构、框架、内容，生成的导航网页文件。站点地图对于提高用户体验有好处，它们为网站访问者指明方向，并帮助迷失的访问者找到他们想看的页面。</p><h1 id="一、添加sitemap"><a href="#一、添加sitemap" class="headerlink" title="一、添加sitemap"></a>一、添加sitemap</h1><h2 id="1-安装插件"><a href="#1-安装插件" class="headerlink" title="1. 安装插件"></a>1. 安装插件</h2><p>打开命令行工具，进入博客根目录，使用npm执行如下命令</p><pre><code class="highlight shell"><span class="meta prompt_"># </span><span class="language-bash">谷歌、Bing 网站地图插件</span>npm install hexo-generator-sitemap --save<span class="meta prompt_"># </span><span class="language-bash">百度网站地图插件</span>npm install hexo-generator-baidu-sitemap --save</code></pre><h2 id="2-修改-config-yml配置"><a href="#2-修改-config-yml配置" class="headerlink" title="2. 修改_config.yml配置"></a>2. 修改_config.yml配置</h2><p>修改博客根目录下的 _config.yml 文件,添加如下配置。</p><pre><code class="highlight yaml"><span class="comment"># 配置后自动生成sitemap</span><span class="attr">sitemap:</span>    <span class="attr">path:</span> <span class="string">sitemap.xml</span><span class="attr">baidusitemap:</span>    <span class="attr">path:</span> <span class="string">baidusitemap.xml</span></code></pre><h2 id="3-编译博客"><a href="#3-编译博客" class="headerlink" title="3. 编译博客"></a>3. 编译博客</h2><pre><code class="highlight shell">hexo clean &amp; hexo g</code></pre><h2 id="4-查看sitemap文件"><a href="#4-查看sitemap文件" class="headerlink" title="4. 查看sitemap文件"></a>4. 查看sitemap文件</h2><p>进入博客根目录下的 <code>public</code> 文件夹下，发现已经生成了 <code>sitemap.xml</code> 和 <code>baidusitemap.xml</code> 两个文件，表示添加网站地图文件操作成功！</p><p><img src="https://raw.githubusercontent.com/GeorgeChan95/blogimg/master/img/2023/11/21/20231121-101144.png" alt="image-20231121101143695"></p><h2 id="5-查看站点地图"><a href="#5-查看站点地图" class="headerlink" title="5. 查看站点地图"></a>5. 查看站点地图</h2><p>Github Pages 站点跟路径 + sitemap.xml 可查看站点地图</p><p><a href="https://georgechan95.github.io/sitemap.xml">sitemap.xml</a></p><p><a href="https://georgechan95.github.io/baidusitemap.xml">baidusitemap.xml</a></p><p><img src="https://raw.githubusercontent.com/GeorgeChan95/blogimg/master/img/2023/11/21/20231121-101910.png" alt="image-20231121101909570"></p><h1 id="参考链接"><a href="#参考链接" class="headerlink" title="参考链接"></a>参考链接</h1><p><a href="https://jueee.github.io/2020/08/2020-08-09-%E5%8D%9A%E5%AE%A2%E7%BD%91%E5%9D%80%E5%A2%9E%E5%8A%A0%E7%AB%99%E7%82%B9%E5%9C%B0%E5%9B%BEsitemap/">博客网址增加站点地图 sitemap</a></p>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;环境&quot;&gt;&lt;a href=&quot;#环境&quot; class=&quot;headerlink&quot; title=&quot;环境&quot;&gt;&lt;/a&gt;环境&lt;/h1&gt;&lt;blockquote&gt;
&lt;p&gt;系统 : Windows 10&lt;/p&gt;
&lt;p&gt;NodeJS : 14.21.3&lt;/p&gt;
&lt;/blockquote&gt;</summary>
      
    
    
    
    <category term="Hexo" scheme="https://georgechan95.github.io/categories/Hexo/"/>
    
    
    <category term="hexo" scheme="https://georgechan95.github.io/tags/hexo/"/>
    
    <category term="github pages" scheme="https://georgechan95.github.io/tags/github-pages/"/>
    
    <category term="sitemap" scheme="https://georgechan95.github.io/tags/sitemap/"/>
    
  </entry>
  
  <entry>
    <title>Typora设置图片自动上传Github</title>
    <link href="https://georgechan95.github.io/2023/11/20/hexo/Typora%E8%AE%BE%E7%BD%AE%E5%9B%BE%E7%89%87%E8%87%AA%E5%8A%A8%E4%B8%8A%E4%BC%A0Github/"/>
    <id>https://georgechan95.github.io/2023/11/20/hexo/Typora%E8%AE%BE%E7%BD%AE%E5%9B%BE%E7%89%87%E8%87%AA%E5%8A%A8%E4%B8%8A%E4%BC%A0Github/</id>
    <published>2023-11-20T12:30:00.000Z</published>
    <updated>2024-06-22T10:36:12.823Z</updated>
    
    <content type="html"><![CDATA[<h1 id="环境"><a href="#环境" class="headerlink" title="环境"></a>环境</h1><blockquote><p>系统 : Windows 10</p><p>NodeJS : 14.21.3</p></blockquote><h1 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h1><p>在使用 <code>Typora</code> 编辑Markdown笔记时需要将复制的截图上传到图床，并能够自动将上传后的路径替换掉图片粘贴时自动生成的路径。这样操作方便笔记查看和迁移。</p><p>这里使用Github做图床，优点：免费&amp;没有容量的限制，缺点：国内网络访问很慢。</p><p>图片上传使用 PicGo-Core 插件，需要使用 <code>npm</code> 安装该插件。</p><h1 id="一、安装PicGo-Core"><a href="#一、安装PicGo-Core" class="headerlink" title="一、安装PicGo-Core"></a>一、安装PicGo-Core</h1><h2 id="1-修改Typora图像上传设置"><a href="#1-修改Typora图像上传设置" class="headerlink" title="1. 修改Typora图像上传设置"></a>1. 修改Typora图像上传设置</h2><p>打开Typora，依次点击：文件 –&gt; 偏好设置 –&gt; 图像 </p><p>勾选配置如下：</p><p>选择 <code>上传图片</code> –&gt; <code>勾选上传图片配置(2、3、4)</code>  –&gt; 选择 <code>PicGo-Core(command line)</code> –&gt; 点击 <code>下载或更新</code> </p><p><img src="https://raw.githubusercontent.com/GeorgeChan95/blogimg/master/img/2023/11/20/20231120-205500.png" alt="image-20231120205458979"></p><p><strong>PicGo-Core 安装成功</strong></p><p><img src="https://raw.githubusercontent.com/GeorgeChan95/blogimg/master/img/2023/11/20/20231120-210102.png" alt="image-20231120210101191"></p><h2 id="2-修改PicGo-Core配置文件"><a href="#2-修改PicGo-Core配置文件" class="headerlink" title="2. 修改PicGo-Core配置文件"></a>2. 修改PicGo-Core配置文件</h2><p>PicGo-Core 插件安装成功后，点击 <code>打开配置文件</code> 修改 PicGo-Core 配置文件。</p><p>默认路径：C:\Users\用户名\.picgo\config.json</p><p>配置文件内容如下：</p><pre><code class="highlight json"><span class="punctuation">&#123;</span>  <span class="attr">&quot;picBed&quot;</span><span class="punctuation">:</span> <span class="punctuation">&#123;</span>    <span class="attr">&quot;github&quot;</span><span class="punctuation">:</span> <span class="punctuation">&#123;</span>      <span class="attr">&quot;repo&quot;</span><span class="punctuation">:</span> <span class="string">&quot;github仓库名&quot;</span><span class="punctuation">,</span>      <span class="attr">&quot;token&quot;</span><span class="punctuation">:</span> <span class="string">&quot;github Token配置&quot;</span><span class="punctuation">,</span>      <span class="attr">&quot;path&quot;</span><span class="punctuation">:</span> <span class="string">&quot;img/&quot;</span><span class="punctuation">,</span>      <span class="attr">&quot;customPath&quot;</span><span class="punctuation">:</span> <span class="string">&quot;&quot;</span><span class="punctuation">,</span>      <span class="attr">&quot;customUrl&quot;</span><span class="punctuation">:</span> <span class="string">&quot;&quot;</span><span class="punctuation">,</span>      <span class="attr">&quot;branch&quot;</span><span class="punctuation">:</span> <span class="string">&quot;master&quot;</span>    <span class="punctuation">&#125;</span><span class="punctuation">,</span>    <span class="attr">&quot;current&quot;</span><span class="punctuation">:</span> <span class="string">&quot;github&quot;</span><span class="punctuation">,</span>    <span class="attr">&quot;uploader&quot;</span><span class="punctuation">:</span> <span class="string">&quot;github&quot;</span>  <span class="punctuation">&#125;</span><span class="punctuation">,</span>  <span class="comment">// 插件设置</span>  <span class="attr">&quot;picgoPlugins&quot;</span><span class="punctuation">:</span> <span class="punctuation">&#123;</span>  <span class="punctuation">&#125;</span><span class="punctuation">&#125;</span></code></pre><h3 id="2-1-Github图床配置"><a href="#2-1-Github图床配置" class="headerlink" title="2.1 Github图床配置"></a>2.1 Github图床配置</h3><p>在Github创建一个仓库作为 <code>PicGo</code> 上传图片的图床，并为 <code>PicGo</code> 创建 github <code>token</code>。</p><h4 id="2-1-1-新建图床仓库"><a href="#2-1-1-新建图床仓库" class="headerlink" title="2.1.1 新建图床仓库"></a>2.1.1 新建图床仓库</h4><p><img src="https://raw.githubusercontent.com/GeorgeChan95/blogimg/master/img/2023/11/20/20231120-211154.png" alt="image-20231120211152544"></p><p><strong>注意：</strong>图床仓库必须为 <strong>Public</strong> 权限。</p><p>图床仓库创建成功后，PicGo 配置文件(config.json)中 <code>picBed.github.repo</code> 的值就确定了，应该改为：<code>GeorgeChan95/picgo-img</code></p><h4 id="2-1-2-配置Token"><a href="#2-1-2-配置Token" class="headerlink" title="2.1.2 配置Token"></a>2.1.2 配置Token</h4><p>打开Github –&gt; 点击头像 –&gt; <code>Settings</code> –&gt; <code>Developer settings</code> –&gt; 点击 <code>Personal access tokens</code> –&gt; 点击 <code>Tokens(classic)</code>  –&gt; 选择 <code>Generate new token</code>  –&gt;  填写Note(token名称)\选择过期时间\选择token权限 –&gt; 点击 <code>Generate token</code> 保存token</p><p><img src="https://raw.githubusercontent.com/GeorgeChan95/blogimg/master/img/2023/11/20/20231120-212117.png" alt="image-20231120212115905"></p><p><img src="https://raw.githubusercontent.com/GeorgeChan95/blogimg/master/img/2023/11/20/20231120-212235.png" alt="image-20231120212234100"></p><p><img src="https://raw.githubusercontent.com/GeorgeChan95/blogimg/master/img/2023/11/20/20231120-212414.png" alt="image-20231120212413138"></p><p><img src="https://raw.githubusercontent.com/GeorgeChan95/blogimg/master/img/2023/11/20/20231120-212948.png" alt="image-20231120212946870"></p><p><img src="https://raw.githubusercontent.com/GeorgeChan95/blogimg/master/img/2023/11/20/20231120-213320.png" alt="image-20231120213319506"></p><p><strong>复制token，填写到 PicGo 配置文件(config.json)的 <code>picBed.github.token</code> 中。</strong></p><h4 id="2-1-3-修改PicGo配置文件"><a href="#2-1-3-修改PicGo配置文件" class="headerlink" title="2.1.3 修改PicGo配置文件"></a>2.1.3 修改PicGo配置文件</h4><p>配置文件(config.json)内容修改如下：</p><pre><code class="highlight json"><span class="punctuation">&#123;</span>  <span class="attr">&quot;picBed&quot;</span><span class="punctuation">:</span> <span class="punctuation">&#123;</span>    <span class="attr">&quot;github&quot;</span><span class="punctuation">:</span> <span class="punctuation">&#123;</span>      <span class="attr">&quot;repo&quot;</span><span class="punctuation">:</span> <span class="string">&quot;GeorgeChan95/picgo-img&quot;</span><span class="punctuation">,</span>      <span class="attr">&quot;token&quot;</span><span class="punctuation">:</span> <span class="string">&quot;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&quot;</span><span class="punctuation">,</span>      <span class="attr">&quot;path&quot;</span><span class="punctuation">:</span> <span class="string">&quot;img/&quot;</span><span class="punctuation">,</span>      <span class="attr">&quot;customPath&quot;</span><span class="punctuation">:</span> <span class="string">&quot;&quot;</span><span class="punctuation">,</span>      <span class="attr">&quot;customUrl&quot;</span><span class="punctuation">:</span> <span class="string">&quot;&quot;</span><span class="punctuation">,</span>      <span class="attr">&quot;branch&quot;</span><span class="punctuation">:</span> <span class="string">&quot;master&quot;</span>    <span class="punctuation">&#125;</span><span class="punctuation">,</span>    <span class="attr">&quot;current&quot;</span><span class="punctuation">:</span> <span class="string">&quot;github&quot;</span><span class="punctuation">,</span>    <span class="attr">&quot;uploader&quot;</span><span class="punctuation">:</span> <span class="string">&quot;github&quot;</span>  <span class="punctuation">&#125;</span><span class="punctuation">,</span>  <span class="comment">// 插件设置</span>  <span class="attr">&quot;picgoPlugins&quot;</span><span class="punctuation">:</span> <span class="punctuation">&#123;</span>  <span class="punctuation">&#125;</span><span class="punctuation">&#125;</span></code></pre><p>保存！！</p><h4 id="2-1-4-验证PicGo图片上传"><a href="#2-1-4-验证PicGo图片上传" class="headerlink" title="2.1.4 验证PicGo图片上传"></a>2.1.4 验证PicGo图片上传</h4><p>在Typora偏好设置里，点击 <code>验证图片选项</code>，</p><p><img src="https://raw.githubusercontent.com/GeorgeChan95/blogimg/master/img/2023/11/20/20231120-213941.png" alt="image-20231120213939604"></p><p>验证成功！</p><p><img src="https://raw.githubusercontent.com/GeorgeChan95/blogimg/master/img/2023/11/20/20231120-214114.png" alt="image-20231120214113620"></p><h1 id="二、为Picgo安装插件"><a href="#二、为Picgo安装插件" class="headerlink" title="二、为Picgo安装插件"></a>二、为Picgo安装插件</h1><p>到上一步已实现了图片的自动上传和替换markdown图片url的功能，但默认的图片上传其实有一些问题。</p><ul><li><p>问题1：默认会把所有图片上传到配置文件指定的 <code>picBed.github.path</code> 路径下，不会创建子文件夹，图片不好管理。</p></li><li><p>问题2：默认不会给文件重命名，如果两个文件重名，粘贴上传就会出错。</p></li></ul><p>所以需要为 Picgo 安装 <code>super-prefix</code> 插件，实现文件自动重命名和按日期创建文件夹存储文件。</p><h2 id="1-安装super-prefix插件"><a href="#1-安装super-prefix插件" class="headerlink" title="1. 安装super-prefix插件"></a>1. 安装super-prefix插件</h2><p>建议使用npm进行安装</p><pre><code class="highlight shell">npm install picgo-plugin-super-prefix</code></pre><p><img src="https://raw.githubusercontent.com/GeorgeChan95/blogimg/master/img/2023/11/20/20231120-215637.png" alt="image-20231120215635966"></p><h2 id="2-修改Picgo配置文件"><a href="#2-修改Picgo配置文件" class="headerlink" title="2. 修改Picgo配置文件"></a>2. 修改Picgo配置文件</h2><p>添加 <code>super-prefix</code> 插件相关配置</p><p>默认路径：C:\Users\用户名\.picgo\config.json</p><pre><code class="highlight json"><span class="punctuation">&#123;</span>  <span class="attr">&quot;picBed&quot;</span><span class="punctuation">:</span> <span class="punctuation">&#123;</span>    <span class="attr">&quot;github&quot;</span><span class="punctuation">:</span> <span class="punctuation">&#123;</span>      <span class="attr">&quot;repo&quot;</span><span class="punctuation">:</span> <span class="string">&quot;GeorgeChan95/picgo-img&quot;</span><span class="punctuation">,</span>      <span class="attr">&quot;token&quot;</span><span class="punctuation">:</span> <span class="string">&quot;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&quot;</span><span class="punctuation">,</span>      <span class="attr">&quot;path&quot;</span><span class="punctuation">:</span> <span class="string">&quot;img/&quot;</span><span class="punctuation">,</span>      <span class="attr">&quot;customPath&quot;</span><span class="punctuation">:</span> <span class="string">&quot;&quot;</span><span class="punctuation">,</span>      <span class="attr">&quot;customUrl&quot;</span><span class="punctuation">:</span> <span class="string">&quot;&quot;</span><span class="punctuation">,</span>      <span class="attr">&quot;branch&quot;</span><span class="punctuation">:</span> <span class="string">&quot;master&quot;</span>    <span class="punctuation">&#125;</span><span class="punctuation">,</span>    <span class="attr">&quot;current&quot;</span><span class="punctuation">:</span> <span class="string">&quot;github&quot;</span><span class="punctuation">,</span>    <span class="attr">&quot;uploader&quot;</span><span class="punctuation">:</span> <span class="string">&quot;github&quot;</span>  <span class="punctuation">&#125;</span><span class="punctuation">,</span>  <span class="comment">// 插件设置</span>  <span class="attr">&quot;picgoPlugins&quot;</span><span class="punctuation">:</span> <span class="punctuation">&#123;</span>    <span class="attr">&quot;picgo-plugin-super-prefix&quot;</span><span class="punctuation">:</span> <span class="literal"><span class="keyword">true</span></span>  <span class="punctuation">&#125;</span><span class="punctuation">,</span>  <span class="attr">&quot;picgo-plugin-super-prefix&quot;</span><span class="punctuation">:</span> <span class="punctuation">&#123;</span>    <span class="attr">&quot;prefixFormat&quot;</span><span class="punctuation">:</span> <span class="string">&quot;YYYY/MM/DD/&quot;</span><span class="punctuation">,</span>    <span class="attr">&quot;fileFormat&quot;</span><span class="punctuation">:</span> <span class="string">&quot;YYYYMMDD-HHmmss&quot;</span>  <span class="punctuation">&#125;</span><span class="punctuation">&#125;</span></code></pre><p>保存！！重启Typora！</p><h3 id="2-1-配置解析"><a href="#2-1-配置解析" class="headerlink" title="2.1 配置解析"></a>2.1 配置解析</h3><ul><li>“prefixFormat”: “YYYY&#x2F;MM&#x2F;DD&#x2F;“<ul><li>图片上传到仓库中会自动在 <code>picBed.github.path</code> 路径下，根据当前时间创建  <code>年/月/日</code> 文件夹，并将文件上传到改路径下</li></ul></li><li>“fileFormat”: “YYYYMMDD-HHmmss”<ul><li>文件上传后按照上传时间重命名，格式为：YYYYMMDD-HHmmss</li></ul></li></ul><h1 id="参考链接"><a href="#参考链接" class="headerlink" title="参考链接"></a>参考链接</h1><p><a href="https://www.cnblogs.com/yongdaimi/p/16300462.html">https://www.cnblogs.com/yongdaimi/p/16300462.html</a></p>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;环境&quot;&gt;&lt;a href=&quot;#环境&quot; class=&quot;headerlink&quot; title=&quot;环境&quot;&gt;&lt;/a&gt;环境&lt;/h1&gt;&lt;blockquote&gt;
&lt;p&gt;系统 : Windows 10&lt;/p&gt;
&lt;p&gt;NodeJS : 14.21.3&lt;/p&gt;
&lt;/blockquote&gt;</summary>
      
    
    
    
    <category term="Hexo" scheme="https://georgechan95.github.io/categories/Hexo/"/>
    
    <category term="Typora" scheme="https://georgechan95.github.io/categories/Hexo/Typora/"/>
    
    
    <category term="hexo" scheme="https://georgechan95.github.io/tags/hexo/"/>
    
    <category term="typora" scheme="https://georgechan95.github.io/tags/typora/"/>
    
    <category term="github" scheme="https://georgechan95.github.io/tags/github/"/>
    
  </entry>
  
</feed>
