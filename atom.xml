<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>George&#39;s Blog</title>
  
  <subtitle>个人邮箱：george_95@126.com</subtitle>
  <link href="https://georgechan95.github.io/atom.xml" rel="self"/>
  
  <link href="https://georgechan95.github.io/"/>
  <updated>2024-11-02T03:40:07.745Z</updated>
  <id>https://georgechan95.github.io/</id>
  
  <author>
    <name>George</name>
    
  </author>
  
  <generator uri="https://hexo.io/">Hexo</generator>
  
  <entry>
    <title>02-UML图绘制工具</title>
    <link href="https://georgechan95.github.io/blog/c13304c1.html"/>
    <id>https://georgechan95.github.io/blog/c13304c1.html</id>
    <published>2024-11-02T01:57:00.000Z</published>
    <updated>2024-11-02T03:40:07.745Z</updated>
    
    <content type="html"><![CDATA[<h1 id="一、UML绘图工具"><a href="#一、UML绘图工具" class="headerlink" title="一、UML绘图工具"></a>一、UML绘图工具</h1><p>UML绘制工具有很多，这里仅介绍两种。</p><ul><li><p>IDEA自带插件：<code>Diagrams</code></p><p>用于查看类与类之间的关联关系</p></li><li><p>UML绘制工具：Astah Professional</p><p>专业的UML绘图工具，这里使用的是 <code>Astah Pro 8</code></p></li></ul><h2 id="1-IDEA自带插件：Diagrams"><a href="#1-IDEA自带插件：Diagrams" class="headerlink" title="1. IDEA自带插件：Diagrams"></a>1. IDEA自带插件：Diagrams</h2><h3 id="1-1-设置-Diagrams"><a href="#1-1-设置-Diagrams" class="headerlink" title="1.1 设置 Diagrams"></a>1.1 设置 Diagrams</h3><p>在idea中，依次打开 <code>File</code> –&gt; Settings –&gt; <code>Tools</code> –&gt; <code>Diagrams</code> </p><p>设置Diagrams如下，选择： <code>字段</code>、<code>构造器</code>、<code>方法</code></p><p><img src="https://raw.githubusercontent.com/GeorgeChan95/blogimg/master/img/2024/11/02/20241102-101823.png" alt="设置 Diagrams"></p><h3 id="1-2-使用-Diagrams"><a href="#1-2-使用-Diagrams" class="headerlink" title="1.2 使用 Diagrams"></a>1.2 使用 Diagrams</h3><h4 id="1-2-1-示例代码"><a href="#1-2-1-示例代码" class="headerlink" title="1.2.1 示例代码"></a>1.2.1 示例代码</h4><p>有如下三个类，<code>Computer</code>、<code>Moniter</code> 、<code>Mouse</code></p><pre><code class="highlight java"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Computer</span> &#123;<span class="keyword">private</span> Mouse mouse; <span class="comment">//鼠标可以和computer分离</span><span class="keyword">private</span> Moniter moniter;<span class="comment">//显示器可以和Computer分离</span><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setMouse</span><span class="params">(Mouse mouse)</span> &#123;<span class="built_in">this</span>.mouse = mouse;&#125;<span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setMoniter</span><span class="params">(Moniter moniter)</span> &#123;<span class="built_in">this</span>.moniter = moniter;&#125;&#125;<span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Moniter</span> &#123;&#125;<span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Mouse</span> &#123;&#125;</code></pre><p>从代码可以看出，他们之间为 <code>聚合关系（Aggregation）</code>，如果不知道什么是聚合关系，本篇后面会介绍。</p><h4 id="1-2-2-使用IDEA查看UML关系图"><a href="#1-2-2-使用IDEA查看UML关系图" class="headerlink" title="1.2.2 使用IDEA查看UML关系图"></a>1.2.2 使用IDEA查看UML关系图</h4><p>同时选中这三个类，鼠标右键选择 Diagrams ， 然后选择 Show Diagram…</p><p><img src="https://raw.githubusercontent.com/GeorgeChan95/blogimg/master/img/2024/11/02/20241102-103131.png" alt="使用IDEA查看UML关系图"></p><p><img src="https://raw.githubusercontent.com/GeorgeChan95/blogimg/master/img/2024/11/02/20241102-103440.png" alt="UML关系图"></p><h4 id="1-2-3-在UML图中添加类或接口"><a href="#1-2-3-在UML图中添加类或接口" class="headerlink" title="1.2.3 在UML图中添加类或接口"></a>1.2.3 在UML图中添加类或接口</h4><p>UML图中鼠标右键 –&gt; <code>Content</code> –&gt; <code>Add Class to Diagram</code> </p><p><img src="https://raw.githubusercontent.com/GeorgeChan95/blogimg/master/img/2024/11/02/20241102-103622.png" alt="在UML图中添加类或接口"></p><p>找到要添加的类，选择它</p><p><img src="https://raw.githubusercontent.com/GeorgeChan95/blogimg/master/img/2024/11/02/20241102-103800.png" alt="添加类到UML图中"></p><p><img src="https://raw.githubusercontent.com/GeorgeChan95/blogimg/master/img/2024/11/02/20241102-103847.png" alt="完成类在UML图中添加"></p><h2 id="2-UML绘制工具：Astah-Professional"><a href="#2-UML绘制工具：Astah-Professional" class="headerlink" title="2. UML绘制工具：Astah Professional"></a>2. UML绘制工具：Astah Professional</h2><p>官网：<a href="http://astah.net/cn/">http://astah.net/cn/</a></p><p>Astah Professional 是一款专业的UML绘图工具，除了绘制UML图以外，还可以绘制ER图、流程图和数据流图等，这里仅介绍它的安装、破解、汉化。</p><blockquote></blockquote><h3 id="2-1-安装-Astah-Pro"><a href="#2-1-安装-Astah-Pro" class="headerlink" title="2.1 安装 Astah Pro"></a>2.1 安装 Astah Pro</h3><p><strong>下载</strong></p><p>百度网盘：<a href="https://pan.baidu.com/s/1Is0BpNy41uI5U9woFIVu_Q?pwd=0000">https://pan.baidu.com/s/1Is0BpNy41uI5U9woFIVu_Q?pwd=0000</a></p><p><strong>解压</strong></p><p><img src="https://raw.githubusercontent.com/GeorgeChan95/blogimg/master/img/2024/11/02/20241102-110113.png" alt="安装包"></p><p>从上往下依次是：破解包、汉化包、安装文件</p><p><strong>开始安装</strong></p><p>首先确保你的电脑上有JDK环境，我的电脑上目前已安装并配置好了JDK8的开发环境</p><pre><code class="highlight shell">C:\Users\kd&gt;java -versionjava version &quot;1.8.0_241&quot;Java(TM) SE Runtime Environment (build 1.8.0_241-b07)Java HotSpot(TM) 64-Bit Server VM (build 25.241-b07, mixed mode)</code></pre><p><img src="https://raw.githubusercontent.com/GeorgeChan95/blogimg/master/img/2024/11/02/20241102-110416.png" alt="选择语言"></p><p><img src="https://raw.githubusercontent.com/GeorgeChan95/blogimg/master/img/2024/11/02/20241102-110443.png" alt="next"></p><p><img src="https://raw.githubusercontent.com/GeorgeChan95/blogimg/master/img/2024/11/02/20241102-110514.png" alt="同意用户协议"></p><p><img src="https://raw.githubusercontent.com/GeorgeChan95/blogimg/master/img/2024/11/02/20241102-110544.png" alt="选择安装位置"></p><p><img src="https://raw.githubusercontent.com/GeorgeChan95/blogimg/master/img/2024/11/02/20241102-110630.png" alt="确保磁盘有足够的空间"></p><p><img src="https://raw.githubusercontent.com/GeorgeChan95/blogimg/master/img/2024/11/02/20241102-110658.png" alt="添加到开始菜单"></p><p><img src="https://raw.githubusercontent.com/GeorgeChan95/blogimg/master/img/2024/11/02/20241102-110742.png" alt="为所有用户安装"></p><p><img src="https://raw.githubusercontent.com/GeorgeChan95/blogimg/master/img/2024/11/02/20241102-110757.png" alt="开始安装"></p><p><img src="https://raw.githubusercontent.com/GeorgeChan95/blogimg/master/img/2024/11/02/20241102-110808.png" alt="软件安装中"></p><p><strong>安装完成，取消勾选 <code>启用应用</code>， 再点击 Finish</strong></p><p>这么做的目的是为了后面对软件做破解。</p><p><img src="https://raw.githubusercontent.com/GeorgeChan95/blogimg/master/img/2024/11/02/20241102-110958.png" alt="安装完成"></p><h3 id="2-2-破解-Astah-Pro"><a href="#2-2-破解-Astah-Pro" class="headerlink" title="2.2 破解 Astah Pro"></a>2.2 破解 Astah Pro</h3><p><strong>复制破解Jar包</strong></p><p>将破解jar包复制到软件的安装目录中， 就是安装Astah时选择的路径，我这里安装到了：E:\software\astah-professional </p><p><img src="https://raw.githubusercontent.com/GeorgeChan95/blogimg/master/img/2024/11/02/20241102-111158.png" alt="复制破解Jar包"></p><p><strong>粘贴破解包</strong></p><p><img src="https://raw.githubusercontent.com/GeorgeChan95/blogimg/master/img/2024/11/02/20241102-111507.png" alt="替换文件"></p><p><strong>新建文件夹“License”</strong></p><p> 在这个目录下新建一个文件夹“License”</p><p><img src="https://raw.githubusercontent.com/GeorgeChan95/blogimg/master/img/2024/11/02/20241102-111725.png" alt="新建文件夹“License”"></p><p><strong>打开CMD</strong></p><p>cd到破解jar所在目录</p><p>执行命令：<code>java -jar dvt-AstahKeyfileMaker.jar</code></p><p><img src="https://raw.githubusercontent.com/GeorgeChan95/blogimg/master/img/2024/11/02/20241102-112057.png" alt="执行Java命令"></p><p>执行完java命令后，自动打开弹窗如下：</p><p><img src="https://raw.githubusercontent.com/GeorgeChan95/blogimg/master/img/2024/11/02/20241102-112129.png" alt="破解jar包弹窗"></p><p><strong>选择 Astah Professional， 点击 Generate</strong></p><p><img src="https://raw.githubusercontent.com/GeorgeChan95/blogimg/master/img/2024/11/02/20241102-112252.png" alt="生成许可文件"></p><p><strong>选择刚才创建的License目录，点击 保存</strong></p><p>会在该目录下自动创建 license.xml 文件，此文件就用于激活 Astah</p><p><img src="https://raw.githubusercontent.com/GeorgeChan95/blogimg/master/img/2024/11/02/20241102-112346.png" alt="生成激活文件"></p><p><img src="https://raw.githubusercontent.com/GeorgeChan95/blogimg/master/img/2024/11/02/20241102-112521.png" alt="文件生成成功"></p><p><strong>激活Astah Pro</strong></p><p>打开Astah， 点击 Help –&gt; License ，设置许可证为刚才生成的 xml 文件</p><p><img src="https://raw.githubusercontent.com/GeorgeChan95/blogimg/master/img/2024/11/02/20241102-112656.png" alt="查看许可证"></p><p><img src="https://raw.githubusercontent.com/GeorgeChan95/blogimg/master/img/2024/11/02/20241102-112734.png" alt="设置许可证"></p><p><img src="https://raw.githubusercontent.com/GeorgeChan95/blogimg/master/img/2024/11/02/20241102-112756.png" alt="选择生成的xml文件"></p><p>再次查看许可信息，发现有效期到 2030年。</p><p><img src="https://raw.githubusercontent.com/GeorgeChan95/blogimg/master/img/2024/11/02/20241102-112936.png" alt="验证许可信息"></p><h3 id="2-3-汉化-Astah-Pro"><a href="#2-3-汉化-Astah-Pro" class="headerlink" title="2.3 汉化 Astah Pro"></a>2.3 汉化 Astah Pro</h3><p>复制汉化文件：<code>astah-gui_zh_cn.properties</code> 到安装根目录即可</p><p><img src="https://raw.githubusercontent.com/GeorgeChan95/blogimg/master/img/2024/11/02/20241102-113141.png" alt="复制汉化文件"></p><p>重新打开 Astah， 发现已汉化成功</p><p><img src="https://raw.githubusercontent.com/GeorgeChan95/blogimg/master/img/2024/11/02/20241102-113308.png" alt="汉化成功"></p><p><strong>参考链接</strong></p><blockquote><p><a href="https://www.cnblogs.com/xsge/p/15871002.html">https://www.cnblogs.com/xsge/p/15871002.html</a></p><p><a href="https://github.com/QingMings/astah-professional-8.1-zh_CN">https://github.com/QingMings/astah-professional-8.1-zh_CN</a></p></blockquote>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;一、UML绘图工具&quot;&gt;&lt;a href=&quot;#一、UML绘图工具&quot; class=&quot;headerlink&quot; title=&quot;一、UML绘图工具&quot;&gt;&lt;/a&gt;一、UML绘图工具&lt;/h1&gt;&lt;p&gt;UML绘制工具有很多，这里仅介绍两种。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;p&gt;IDEA自带</summary>
      
    
    
    
    <category term="UML" scheme="https://georgechan95.github.io/categories/UML/"/>
    
    
    <category term="设计模式" scheme="https://georgechan95.github.io/tags/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"/>
    
    <category term="UML" scheme="https://georgechan95.github.io/tags/UML/"/>
    
  </entry>
  
  <entry>
    <title>Docker环境下RTSP流转RTMP和HLS</title>
    <link href="https://georgechan95.github.io/blog/2e826df1.html"/>
    <id>https://georgechan95.github.io/blog/2e826df1.html</id>
    <published>2024-11-01T07:17:33.000Z</published>
    <updated>2024-11-01T08:12:48.876Z</updated>
    
    <content type="html"><![CDATA[<h1 id="一、RTSP转RTMP"><a href="#一、RTSP转RTMP" class="headerlink" title="一、RTSP转RTMP"></a>一、RTSP转RTMP</h1><h2 id="Nginx-Rtmp环境搭建"><a href="#Nginx-Rtmp环境搭建" class="headerlink" title="Nginx-Rtmp环境搭建"></a>Nginx-Rtmp环境搭建</h2><pre><code class="highlight shell"><span class="meta prompt_"># </span><span class="language-bash">拉取镜像</span>docker pull tiangolo/nginx-rtmp:latest-2024-08-26<span class="meta prompt_"></span><span class="meta prompt_"># </span><span class="language-bash">启动镜像</span>docker run --name nginx-rtmp -itd --restart=always -p 1935:1935 tiangolo/nginx-rtmp</code></pre><h2 id="ffmpeg环境搭建"><a href="#ffmpeg环境搭建" class="headerlink" title="ffmpeg环境搭建"></a>ffmpeg环境搭建</h2><pre><code class="highlight shell"><span class="meta prompt_"># </span><span class="language-bash">拉取镜像</span>docker pull chainguard/ffmpeg:latest<span class="meta prompt_"></span><span class="meta prompt_"># </span><span class="language-bash">启动镜像，并将一个rtsp流转为rtmp流</span>docker run --name ffmpeg29 -itd --restart=always chainguard/ffmpeg -rtsp_transport tcp -i rtsp://admin:CSG300222@10.10.10.29:554/h264/ch1/main/av_stream -f flv -r 25 -s 1920*1080 -an rtmp://192.168.6.209:1935/live/29</code></pre><h2 id="测试"><a href="#测试" class="headerlink" title="测试"></a>测试</h2><p><img src="https://raw.githubusercontent.com/GeorgeChan95/blogimg/master/img/2024/08/30/20240830-154304.png" alt="VLC测试" title="VLC测试"></p><p><img src="https://raw.githubusercontent.com/GeorgeChan95/blogimg/master/img/2024/08/30/20240830-154420.png" alt="VLC播放成功" title="VLC播放成功"></p><h1 id="二、RTSP流转HLS"><a href="#二、RTSP流转HLS" class="headerlink" title="二、RTSP流转HLS"></a>二、RTSP流转HLS</h1><h2 id="创建映射目录"><a href="#创建映射目录" class="headerlink" title="创建映射目录"></a>创建映射目录</h2><pre><code class="highlight shell">mkdir /usr/local/docker/data/nginx/hlschmod 777 /usr/local/docker/data/nginx/hls</code></pre><h2 id="nginx-配置"><a href="#nginx-配置" class="headerlink" title="nginx 配置"></a>nginx 配置</h2><pre><code class="highlight shell">server &#123;  listen       8002;  server_name  server_hls;  location / &#123;    types &#123;       application/vnd.apple.mpegusr m3u8;       video/mp2t ts;    &#125;    root hls;    #8002端口服务的根目录,nginx目录下的hls目录    add_header Cache-Control no-cache;    add_header Access-Control-Allow-Origin *;    add_header Access-Control-Allow-Headers &quot;Origin, X-Requested-With,      Content-Type, Accept&quot;;    add_header Access-Control-Methods &quot;GET, POST, OPTIONS&quot;;  &#125;&#125;</code></pre><h2 id="nginx-映射路径"><a href="#nginx-映射路径" class="headerlink" title="nginx 映射路径"></a>nginx 映射路径</h2><pre><code class="highlight shell">-v /usr/local/docker/data/nginx/hls:/etc/nginx/hls</code></pre><h2 id="nginx-映射端口"><a href="#nginx-映射端口" class="headerlink" title="nginx 映射端口"></a>nginx 映射端口</h2><pre><code>-p 8002:8002</code></pre><h2 id="ffmpeg启动容器"><a href="#ffmpeg启动容器" class="headerlink" title="ffmpeg启动容器"></a>ffmpeg启动容器</h2><pre><code class="highlight shell">docker run --name ffmpeghls --privileged=true -v /usr/local/docker/data/nginx/hls:/hls -itd --restart=always chainguard/ffmpeg -f rtsp -rtsp_transport tcp -i rtsp://admin:CSG300222@10.10.10.29:554/h264/ch1/main/av_stream -codec copy -f hls -hls_list_size 10 -hls_flags 20 -hls_time 15 /hls/test.m3u8</code></pre><h2 id="hls流访问地址"><a href="#hls流访问地址" class="headerlink" title="hls流访问地址"></a>hls流访问地址</h2><pre><code class="highlight shell"><span class="meta prompt_"># </span><span class="language-bash">nginx ip + 映射端口</span>http://192.168.6.209:8002/test.m3u8</code></pre><p><img src="https://raw.githubusercontent.com/GeorgeChan95/blogimg/master/img/2024/08/30/20240830-164326.png" alt="hls流播放效果" title="hls流播放效果"></p>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;一、RTSP转RTMP&quot;&gt;&lt;a href=&quot;#一、RTSP转RTMP&quot; class=&quot;headerlink&quot; title=&quot;一、RTSP转RTMP&quot;&gt;&lt;/a&gt;一、RTSP转RTMP&lt;/h1&gt;&lt;h2 id=&quot;Nginx-Rtmp环境搭建&quot;&gt;&lt;a href=&quot;#Ngi</summary>
      
    
    
    
    <category term="linux" scheme="https://georgechan95.github.io/categories/linux/"/>
    
    
    <category term="linux" scheme="https://georgechan95.github.io/tags/linux/"/>
    
    <category term="ubuntu18" scheme="https://georgechan95.github.io/tags/ubuntu18/"/>
    
  </entry>
  
  <entry>
    <title>01-设计模式六大原则</title>
    <link href="https://georgechan95.github.io/blog/cd625bba.html"/>
    <id>https://georgechan95.github.io/blog/cd625bba.html</id>
    <published>2024-10-31T09:00:00.000Z</published>
    <updated>2024-11-01T08:14:11.787Z</updated>
    
    <content type="html"><![CDATA[<h1 id="一、设计模式的目的"><a href="#一、设计模式的目的" class="headerlink" title="一、设计模式的目的"></a>一、设计模式的目的</h1><p>编写软件过程中，程序员面临着来自<strong>耦合性</strong>，<strong>内聚性</strong>以及<strong>可维护性</strong>，<strong>可扩展性</strong>，重用性，<strong>灵活性</strong> 等多方面的 挑战，设计模式是为了让程序(软件) ，具有更好的</p><ul><li>代码重用性 (即：相同功能的代码，不用多次编写)</li><li>可读性 (即：编程规范性,  便于其他程序员的阅读和理解)</li><li>可扩展性 (即：当需要增加新的功能时，非常的方便，称为可维护)</li><li>可靠性 (即：当我们增加新的功能后，对原来的功能没有影响)</li><li>可靠性 (即：当我们增加新的功能后，对原来的功能没有影响)</li></ul><h1 id="二、单一职责原则（Single-Responsibility-Principle）"><a href="#二、单一职责原则（Single-Responsibility-Principle）" class="headerlink" title="二、单一职责原则（Single Responsibility Principle）"></a>二、单一职责原则（Single Responsibility Principle）</h1><h2 id="1-基本介绍"><a href="#1-基本介绍" class="headerlink" title="1. 基本介绍"></a>1. 基本介绍</h2><p>就一个类而言，应该仅有一个引起它变化的原因。应该只有一个职责。如果一个类有一个以上的职责，这些职责就耦合在了一起。一个职责的变化可能会削弱或者抑制这个类完成其他职责的能力。这会导致脆弱的设计。当一个职责发生变化时，可能会影响其它的职责。另外，多个职责耦合在一起，会影响复用性。想要避免这种现象的发生，就要尽可能的遵守单一职责原则。</p><p>单一职责原则的核心就是<strong>解耦和增强内聚性</strong>。</p><h2 id="2-为什么要遵守单一职责原则？"><a href="#2-为什么要遵守单一职责原则？" class="headerlink" title="2. 为什么要遵守单一职责原则？"></a>2. 为什么要遵守单一职责原则？</h2><ul><li><p>提高类的可维护性和可读写性</p><p>一个类的职责少了，复杂度降低了，代码就少了，可读性也就好了，可维护性自然就高了。</p></li><li><p>提高系统的可维护性</p><p>系统是由类组成的，每个类的可维护性高，相对来讲整个系统的可维护性就高。当然，前提是系统的架构没有问题。</p></li><li><p>降低变更的风险</p><p>一个类的职责越多，变更的可能性就越大，变更带来的风险也就越大</p></li></ul><p>如果在一个类中可能会有多个发生变化的东西，这样的设计会带来风险, 我们尽量保证只有一个可以变化，其他变化的就放在其他类中，这样的好处就是 <strong>提高内聚，降低耦合</strong>。</p><h2 id="3-单一职责原则应用的范围"><a href="#3-单一职责原则应用的范围" class="headerlink" title="3. 单一职责原则应用的范围"></a>3. 单一职责原则应用的范围</h2><p>单一职责原则适用的范围有接口、方法类。按大家的说法，<strong>接口和方法必须保证单一职责</strong>，类就不必保证，只要符合业务就行。</p><h3 id="3-1-【方法层面】单一职责原则的应用"><a href="#3-1-【方法层面】单一职责原则的应用" class="headerlink" title="3.1  【方法层面】单一职责原则的应用"></a>3.1  【方法层面】单一职责原则的应用</h3><p>现在有一个场景, 需要修改用户的用户名和密码. 就针对这个功能我们可以有多种实现.</p><p><strong>第一种:</strong></p><pre><code class="highlight java"><span class="comment">/**</span><span class="comment"> * 操作的类型</span><span class="comment"> */</span><span class="keyword">public</span> <span class="keyword">enum</span> <span class="title class_">OperateEnum</span> &#123;    UPDATE_USERNAME,    UPDATE_PASSWORD;&#125;<span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">UserOperate</span> &#123;    <span class="keyword">void</span> <span class="title function_">updateUserInfo</span><span class="params">(OperateEnum type, UserInfo userInfo)</span>;&#125;<span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">UserOperateImpl</span> <span class="keyword">implements</span> <span class="title class_">UserOperate</span>&#123;    <span class="meta">@Override</span>    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">updateUserInfo</span><span class="params">(OperateEnum type, UserInfo userInfo)</span> &#123;        <span class="keyword">if</span> (type == OperateEnum.UPDATE_PASSWORD) &#123;            <span class="comment">// 修改密码</span>        &#125; <span class="keyword">else</span> <span class="keyword">if</span>(type == OperateEnum.UPDATE_USERNAME) &#123;            <span class="comment">// 修改用户名</span>        &#125;    &#125;&#125;</code></pre><p><strong>第二种方法:</strong></p><pre><code class="highlight java"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">UserOperate</span> &#123;    <span class="keyword">void</span> <span class="title function_">updateUserName</span><span class="params">(UserInfo userInfo)</span>;    <span class="keyword">void</span> <span class="title function_">updateUserPassword</span><span class="params">(UserInfo userInfo)</span>;&#125;<span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">UserOperateImpl</span> <span class="keyword">implements</span> <span class="title class_">UserOperate</span> &#123;    <span class="meta">@Override</span>    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">updateUserName</span><span class="params">(UserInfo userInfo)</span> &#123;        <span class="comment">// 修改用户名逻辑</span>    &#125;    <span class="meta">@Override</span>    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">updateUserPassword</span><span class="params">(UserInfo userInfo)</span> &#123;        <span class="comment">// 修改密码逻辑</span>    &#125;&#125;</code></pre><p>来看看这两种实现的区别: </p><ul><li>第一种实现是根据操作类型进行区分, 不同类型执行不同的逻辑. 把修改用户名和修改密码这两件事耦合在一起了. 如果客户端在操作的时候传错了类型, 那么就会发生错误. </li><li>第二种实现是我们推荐的实现方式. 修改用户名和修改密码逻辑分开. 各自执行各自的职责, 互不干扰. 功能清晰明了.</li></ul><p>由此可见, 第二种设计是符合单一职责原则的. 这是在方法层面实现单一职责原则.</p><h3 id="3-2-【接口层面】单一职责原则的应用"><a href="#3-2-【接口层面】单一职责原则的应用" class="headerlink" title="3.2 【接口层面】单一职责原则的应用"></a>3.2 【接口层面】单一职责原则的应用</h3><p>我们假设一个场景, 大家一起做家务, 张三扫地, 李四买菜. 李四买完菜回来还得做饭. 这个逻辑怎么实现呢?</p><p><strong>方式一</strong></p><pre><code class="highlight java"><span class="comment">/**</span><span class="comment"> * 做家务</span><span class="comment"> */</span><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">HouseWork</span> &#123;    <span class="comment">// 扫地</span>    <span class="keyword">void</span> <span class="title function_">sweepFloor</span><span class="params">()</span>;    <span class="comment">// 购物</span>    <span class="keyword">void</span> <span class="title function_">shopping</span><span class="params">()</span>;&#125;<span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Zhangsan</span> <span class="keyword">implements</span> <span class="title class_">HouseWork</span>&#123;    <span class="meta">@Override</span>    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">sweepFloor</span><span class="params">()</span> &#123;        <span class="comment">// 扫地</span>    &#125;    <span class="meta">@Override</span>    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">shopping</span><span class="params">()</span> &#123;    &#125;&#125;<span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Lisi</span> <span class="keyword">implements</span> <span class="title class_">HouseWork</span>&#123;    <span class="meta">@Override</span>    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">sweepFloor</span><span class="params">()</span> &#123;    &#125;    <span class="meta">@Override</span>    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">shopping</span><span class="params">()</span> &#123;        <span class="comment">// 购物</span>    &#125;&#125;</code></pre><p>首先定义了一个做家务的接口, 定义两个方法扫地和买菜. 张三扫地, 就实现扫地接口. 李四买菜, 就实现买菜接口. 然后李四买完菜回来还要做饭, 于是就要在接口类中增加一个方法cooking. 张三和李四都重写这个方法, 但只有李四有具体实现.</p><p>这样设计本身就是不合理的. 首先: 张三只扫地, 但是他需要重写买菜方法, 李四不需要扫地, 但是李四也要重写扫地方法. 第二: 这也不符合开闭原则. 增加一种类型做饭, 要修改3个类. 这样当逻辑很复杂的时候, 很容易引起意外错误.</p><p>上面这种设计不符合单一职责原则, 修改一个地方, 影响了其他不需要修改的地方.</p><p><strong>方法二</strong></p><pre><code class="highlight java"><span class="comment">/**</span><span class="comment"> * 做家务</span><span class="comment"> */</span><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">Hoursework</span> &#123;&#125;<span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">Shopping</span> <span class="keyword">extends</span> <span class="title class_">Hoursework</span>&#123;    <span class="comment">// 购物</span>    <span class="keyword">void</span> <span class="title function_">shopping</span><span class="params">()</span>;&#125;<span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">SweepFloor</span> <span class="keyword">extends</span> <span class="title class_">Hoursework</span>&#123;    <span class="comment">// 扫地</span>    <span class="keyword">void</span> <span class="title function_">sweepFlooring</span><span class="params">()</span>;&#125;<span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Zhangsan</span> <span class="keyword">implements</span> <span class="title class_">SweepFloor</span>&#123;    <span class="meta">@Override</span>    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">sweepFlooring</span><span class="params">()</span> &#123;        <span class="comment">// 张三扫地</span>    &#125;&#125;<span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Lisi</span> <span class="keyword">implements</span> <span class="title class_">Shopping</span>&#123;    <span class="meta">@Override</span>    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">shopping</span><span class="params">()</span> &#123;        <span class="comment">// 李四购物</span>    &#125;&#125;</code></pre><p>上面做家务不是定义成一个接口, 而是将扫地和做家务分开了. 张三扫地, 那么张三就实现扫地的接口. 李四购物, 李四就实现购物的接口. 后面李四要增加一个功能做饭. 那么就新增一个做饭接口, 这次只需要李四实现做饭接口就可以了.</p><pre><code class="highlight java"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">Cooking</span> <span class="keyword">extends</span> <span class="title class_">Hoursework</span>&#123;     <span class="keyword">void</span> <span class="title function_">cooking</span><span class="params">()</span>;&#125;<span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Lisi</span> <span class="keyword">implements</span> <span class="title class_">Shopping</span>, Cooking&#123;    <span class="meta">@Override</span>    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">shopping</span><span class="params">()</span> &#123;        <span class="comment">// 李四购物</span>    &#125;    <span class="meta">@Override</span>    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">cooking</span><span class="params">()</span> &#123;        <span class="comment">// 李四做饭</span>    &#125;&#125;</code></pre><p>如上, 我们看到张三没有实现多余的接口, 李四也没有. 而且当新增功能的时候, 只影响了李四, 并没有影响张三. 这就是符合单一职责原则. 一个类只做一件事. 并且他的修改不会带来其他的变化.</p><h2 id="4-如何遵守单一职责原则"><a href="#4-如何遵守单一职责原则" class="headerlink" title="4. 如何遵守单一职责原则"></a>4. 如何遵守单一职责原则</h2><h3 id="4-1-合理的职责分解"><a href="#4-1-合理的职责分解" class="headerlink" title="4.1 合理的职责分解"></a>4.1 合理的职责分解</h3><p>相同的职责放到一起，不同的职责分解到不同的接口和实现中去，这个是最容易也是最难运用的原则，关键还是要从业务出发，从需求出发，识别出同一种类型的职责。</p><p>例子：人的行为分析，包括了生活和工作等行为的分析，生活行为包括吃、跑、睡等行为，工作行为包括上下班，开会等行为，如下图所示：</p><p><img src="https://raw.githubusercontent.com/GeorgeChan95/blogimg/master/img/2024/10/31/20241031-161624.png" alt="单一职责原则"></p><p>人类的行为分成了两个接口：生活行为接口、工作行为接口，以及两个实现类。如果都用一个实现类来承担这两个接口的职责，就会导致代码臃肿，不易维护，如果以后再加上其他行为，例如学习行为接口，将会产生变更风险（这里还用到了组合模式）。</p><h3 id="4-2-代码实现"><a href="#4-2-代码实现" class="headerlink" title="4.2 代码实现"></a>4.2 代码实现</h3><p><strong>第一步: 定义一个行为接口</strong></p><pre><code class="highlight java"><span class="comment">/**</span><span class="comment"> * 人的行为</span><span class="comment"> * 人的行为包括两种: 生活行为, 工作行为</span><span class="comment"> */</span><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">IBehavior</span> &#123;    &#125;</code></pre><p>这里面定义了一个空的接口, 行为接口. 具体这个行为接口下面有哪些接口呢?有生活和工作两方面的行为.</p><p><strong>第二步: 定义生活和工作接口, 并且他们都是行为接口的子类</strong></p><p>生活行为接口:</p><pre><code class="highlight java"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">LivingBehavior</span> <span class="keyword">extends</span> <span class="title class_">IBehavior</span>&#123;    <span class="comment">/** 吃饭 */</span>    <span class="keyword">void</span> <span class="title function_">eat</span><span class="params">()</span>;    <span class="comment">/** 跑步 */</span>    <span class="keyword">void</span> <span class="title function_">running</span><span class="params">()</span>;    <span class="comment">/** 睡觉 */</span>    <span class="keyword">void</span> <span class="title function_">sleeping</span><span class="params">()</span>;&#125;</code></pre><p>工作行为接口:</p><pre><code class="highlight java"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">WorkingBehavior</span> <span class="keyword">extends</span> <span class="title class_">IBehavior</span>&#123;    <span class="comment">/** 上班 */</span>    <span class="keyword">void</span> <span class="title function_">goToWork</span><span class="params">()</span>;    <span class="comment">/** 下班 */</span>    <span class="keyword">void</span> <span class="title function_">goOffWork</span><span class="params">()</span>;    <span class="comment">/** 开会 */</span>    <span class="keyword">void</span> <span class="title function_">meeting</span><span class="params">()</span>;&#125;</code></pre><p><strong>第三步: 定义工作行为接口和生活行为接口的实现类</strong></p><p>生活行为接口实现类:</p><pre><code class="highlight java"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">LivingBehaviorImpl</span> <span class="keyword">implements</span> <span class="title class_">LivingBehavior</span>&#123;    <span class="meta">@Override</span>    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">eat</span><span class="params">()</span> &#123;        System.out.println(<span class="string">&quot;吃饭&quot;</span>);    &#125;    <span class="meta">@Override</span>    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">running</span><span class="params">()</span> &#123;        System.out.println(<span class="string">&quot;跑步&quot;</span>);    &#125;    <span class="meta">@Override</span>    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">sleeping</span><span class="params">()</span> &#123;        System.out.println(<span class="string">&quot;睡觉&quot;</span>);    &#125;&#125;</code></pre><p>工作行为接口实现类:</p><pre><code class="highlight java"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">WorkingBehaviorImpl</span> <span class="keyword">implements</span> <span class="title class_">WorkingBehavior</span>&#123;    <span class="meta">@Override</span>    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">goToWork</span><span class="params">()</span> &#123;        System.out.println(<span class="string">&quot;上班&quot;</span>);    &#125;    <span class="meta">@Override</span>    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">goOffWork</span><span class="params">()</span> &#123;        System.out.println(<span class="string">&quot;下班&quot;</span>);    &#125;    <span class="meta">@Override</span>    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">meeting</span><span class="params">()</span> &#123;        System.out.println(<span class="string">&quot;开会&quot;</span>);    &#125;&#125;</code></pre><p><strong>第四步: 行为组合调用</strong></p><p>行为接口定义好了. 接下来会定义一个行为集合. 不同的用户拥有的行为是不一样 , 有的用户只用生活行为, 有的用户既有生活行为又有工作行为. 我们并不知道具体用户到底会有哪些行为, 所以,通常使用一个集合来接收用户的行为. 用户有哪些行为, 就往里面添加哪些行为.</p><ul><li><p>行为组合接口BehaviorComposer</p><pre><code class="highlight java"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">BehaviorComposer</span> &#123;    <span class="keyword">void</span> <span class="title function_">add</span><span class="params">(IBehavior behavior)</span>;&#125;</code></pre></li><li><p>行为组合接口实现类IBehaviorComposerImpl</p><pre><code class="highlight java"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">IBehaviorComposerImpl</span> <span class="keyword">implements</span> <span class="title class_">BehaviorComposer</span> &#123;    <span class="keyword">private</span> List&lt;IBehavior&gt; behaviors = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();    <span class="meta">@Override</span>    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">add</span><span class="params">(IBehavior behavior)</span> &#123;        System.out.println(<span class="string">&quot;添加行为&quot;</span>);        behaviors.add(behavior);    &#125;    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">doSomeThing</span><span class="params">()</span> &#123;        behaviors.forEach(b-&gt;&#123;            <span class="keyword">if</span>(b <span class="keyword">instanceof</span> LivingBehavior) &#123;                <span class="type">LivingBehavior</span> <span class="variable">li</span> <span class="operator">=</span> (LivingBehavior)b;                <span class="comment">// 处理生活行为</span>            &#125; <span class="keyword">else</span> <span class="keyword">if</span>(b <span class="keyword">instanceof</span> WorkingBehavior) &#123;                <span class="type">WorkingBehavior</span> <span class="variable">wb</span> <span class="operator">=</span> (WorkingBehavior) b;                <span class="comment">// 处理工作行为</span>            &#125;        &#125;);    &#125;&#125;</code></pre></li></ul><p><strong>第五步: 客户端调用</strong></p><p>用户在调用的时候, 根据实际情况调用就可以了, 比如下面的代码: 张三是全职妈妈, 只有生活行为, 李四是职场妈妈, 既有生活行为又有工作行为.</p><pre><code class="highlight java"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;    <span class="comment">//  张三--全职妈妈</span>    <span class="type">LivingBehavior</span> <span class="variable">zslivingBehavior</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">LivingBehaviorImpl</span>();    <span class="type">BehaviorComposer</span> <span class="variable">zsBehaviorComposer</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">IBehaviorComposerImpl</span>();    zsBehaviorComposer.add(zslivingBehavior);    <span class="comment">// 李四--职场妈妈</span>    <span class="type">LivingBehavior</span> <span class="variable">lsLivingBehavior</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">LivingBehaviorImpl</span>();    <span class="type">WorkingBehavior</span> <span class="variable">lsWorkingBehavior</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">WorkingBehaviorImpl</span>();    <span class="type">BehaviorComposer</span> <span class="variable">lsBehaviorComposer</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">IBehaviorComposerImpl</span>();    lsBehaviorComposer.add(lsLivingBehavior);    lsBehaviorComposer.add(lsWorkingBehavior);&#125;</code></pre><h2 id="5-单一职责原则的优缺点"><a href="#5-单一职责原则的优缺点" class="headerlink" title="5. 单一职责原则的优缺点"></a>5. 单一职责原则的优缺点</h2><ul><li>类的复杂性降低: 一个类实现什么职责都有清晰明确的定义了, 复杂性自然就降低了 </li><li>可读性提高: 复杂性降低了，可读性自然就提高了 </li><li>可维护性提高: 可读性提高了，代码就更容易维护了 </li><li>变更引起的风险降低: 变更是必不可少的，如果接口的单一职责做得好，一个接口修改只对相应的实现类有影响，对其他的接口和类无影响，这对系统的扩展性、维护性都有非常大的帮助</li></ul><h1 id="三、接口隔离原则-Interface-Segregation-Principle"><a href="#三、接口隔离原则-Interface-Segregation-Principle" class="headerlink" title="三、接口隔离原则(Interface Segregation Principle)"></a>三、接口隔离原则(Interface Segregation Principle)</h1><h2 id="1-接口隔离原则的定义"><a href="#1-接口隔离原则的定义" class="headerlink" title="1. 接口隔离原则的定义"></a>1. 接口隔离原则的定义</h2><p>客户端只依赖于它所需要的接口；它需要什么接口就提供什么接口，把不需要的接口剔除掉。</p><p>类间的依赖关系应建立在最小的接口上。</p><p>也就是说: 接口尽量细化，接口中的方法尽量少</p><h2 id="2-接口隔离原则和单一职责原则"><a href="#2-接口隔离原则和单一职责原则" class="headerlink" title="2. 接口隔离原则和单一职责原则"></a>2. 接口隔离原则和单一职责原则</h2><p>功能上来看，接口隔离原则和单一职责原则都是为了提高类的内聚, 降低类之间的耦合, 体现了封装的思想。但二者还是有区别的。</p><ul><li>从原则约束来看: 接口隔离原则更关注的是接口依赖程度的隔离；而单一职责原则更加注重的是接口职责的划分。</li><li>从接口的细化程度来看: 单一职责原则对接口的划分更加精细，而接口隔离原则注重的是相同功能的接口的隔离。接口隔离里面的最小接口有时可以是多个单一职责的公共接口。</li><li>单一职责原则更加偏向对业务的约束: 接口隔离原则更加偏向设计架构的约束。这个应该好理解，职责是根据业务功能来划分的，所以单一原则更加偏向业务；而接口隔离更多是为了“高内聚”，偏向架构的设计。</li></ul><h2 id="3-接口隔离原则的优点"><a href="#3-接口隔离原则的优点" class="headerlink" title="3. 接口隔离原则的优点"></a>3. 接口隔离原则的优点</h2><p>接口隔离原则是为了约束接口、降低类对接口的依赖性，遵循接口隔离原则有以下 5 个优点。</p><ul><li>将臃肿庞大的接口分解为多个粒度小的接口，可以预防外来变更的扩散，提高系统的灵活性和可维护性。</li><li>接口隔离提高了系统的内聚性，减少了对外交互，降低了系统的耦合性。</li><li>如果接口的粒度大小定义合理，能够保证系统的稳定性；然而，如果定义过小，则会造成接口数量过多，使设计复杂化；如果定义太大，灵活性降低，无法提供定制服务，给整体项目带来无法预料的风险。</li><li>使用多个专门的接口能够体现对象的层次，因为可以通过接口的继承，实现对总接口的定义。</li><li>能减少项目工程中的代码冗余。过大的大接口里面通常放置许多不用的方法，当实现这个接口的时候，被迫设计冗余的代码。</li></ul><h2 id="4-接口隔离原则的实现方法"><a href="#4-接口隔离原则的实现方法" class="headerlink" title="4. 接口隔离原则的实现方法"></a>4. 接口隔离原则的实现方法</h2><p>在具体应用接口隔离原则时，应该根据以下几个规则来衡量。</p><ul><li><p>接口要尽量小</p><p>不能出现Fat Interface；但是要有限度，首先不能违反单一职责原则（不能一个接口对应半个职责）。</p></li><li><p>接口要高内聚</p><p> 在接口中尽量少公布public方法。 接口是对外的承诺，承诺越少对系统的开发越有利。</p></li><li><p>定制服务</p><p>只提供访问者需要的方法。例如，为管理员提供IComplexSearcher接口，为公网提供ISimpleSearcher接口。</p></li><li><p>接口的设计是有限度的</p><p>了解环境，拒绝盲从。每个项目或产品都有选定的环境因素，环境不同，接口拆分的标准就不同, 需要深入了解业务逻辑。</p></li></ul><h2 id="5-接口隔离原则的建议"><a href="#5-接口隔离原则的建议" class="headerlink" title="5. 接口隔离原则的建议"></a>5. 接口隔离原则的建议</h2><ul><li>一个接口只服务于一个子模块或业务逻辑；</li><li>通过业务逻辑压缩接口中的public方法；</li><li>已被污染了的接口，尽量去修改；若变更的风险较大，则采用适配器模式转化处理；</li><li>拒绝盲从</li></ul><h2 id="6-案例分析"><a href="#6-案例分析" class="headerlink" title="6. 案例分析"></a>6. 案例分析</h2><p>下面以学生成绩管理为例来说明接口隔离原则:</p><p>分析：学生成绩管理程序一般包含查询成绩、新增成绩、删除成绩、修改成绩、计算总分、计算平均分、打印成绩信息等功能，通常我们会怎么做呢？</p><h3 id="6-1-最初的设计"><a href="#6-1-最初的设计" class="headerlink" title="6.1 最初的设计"></a>6.1 最初的设计</h3><p>通常我们设计接口的方式如下:</p><pre><code class="highlight java"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">IStudentScore</span> &#123;    <span class="comment">// 查询成绩</span>    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">queryScore</span><span class="params">()</span>;    <span class="comment">// 修改成绩</span>    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">updateScore</span><span class="params">()</span>;    <span class="comment">// 添加成绩</span>    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">saveScore</span><span class="params">()</span>;    <span class="comment">// 删除成绩</span>    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">delete</span><span class="params">()</span>;    <span class="comment">// 计算总分</span>    <span class="keyword">public</span> <span class="type">double</span> <span class="title function_">sum</span><span class="params">()</span>;    <span class="comment">// 计算平均分</span>    <span class="keyword">public</span> <span class="type">double</span> <span class="title function_">avg</span><span class="params">()</span>;    <span class="comment">// 打印成绩单</span>    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">printScore</span><span class="params">()</span>;&#125;</code></pre><p>我们会吧所有的功能都放在一个接口里面. 这会产生什么样的问题呢?</p><p>首先, 接口的方法很多, 不利于扩展. 比如: 学生只有查看成绩,打印成绩单的权限, 没有增删改的权限; 老师拥有所有的权限.</p><p><strong>查询成绩单:</strong></p><pre><code class="highlight java"><span class="keyword">package</span> com.lxl.www.designPatterns.sixPrinciple.interfaceSegregationPrinciple.score;<span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">QueryScore</span> <span class="keyword">implements</span> <span class="title class_">IStudentScore</span>&#123;    <span class="meta">@Override</span>    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">queryScore</span><span class="params">()</span> &#123;        <span class="comment">// 查询成绩</span>    &#125;    <span class="meta">@Override</span>    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">updateScore</span><span class="params">()</span> &#123;         <span class="comment">// 没有权限</span>    &#125;    <span class="meta">@Override</span>    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">saveScore</span><span class="params">()</span> &#123;        <span class="comment">// 没有权限</span>    &#125;    <span class="meta">@Override</span>    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">delete</span><span class="params">()</span> &#123;        <span class="comment">// 没有权限</span>    &#125;    <span class="meta">@Override</span>    <span class="keyword">public</span> <span class="type">double</span> <span class="title function_">sum</span><span class="params">()</span> &#123;        <span class="comment">// 没有权限</span>        <span class="keyword">return</span> <span class="number">0</span>;    &#125;    <span class="meta">@Override</span>    <span class="keyword">public</span> <span class="type">double</span> <span class="title function_">avg</span><span class="params">()</span> &#123;        <span class="comment">// 没有权限</span>        <span class="keyword">return</span> <span class="number">0</span>;    &#125;    <span class="meta">@Override</span>    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">printScore</span><span class="params">()</span> &#123;        <span class="comment">//打印成绩单</span>    &#125;&#125;</code></pre><p><strong>操作成绩单</strong></p><pre><code class="highlight java"><span class="keyword">package</span> com.lxl.www.designPatterns.sixPrinciple.interfaceSegregationPrinciple.score;<span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Operate</span> <span class="keyword">implements</span> <span class="title class_">IStudentScore</span>&#123;    <span class="meta">@Override</span>    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">queryScore</span><span class="params">()</span> &#123;            &#125;    <span class="meta">@Override</span>    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">updateScore</span><span class="params">()</span> &#123;    &#125;    <span class="meta">@Override</span>    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">saveScore</span><span class="params">()</span> &#123;    &#125;    <span class="meta">@Override</span>    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">delete</span><span class="params">()</span> &#123;    &#125;    <span class="meta">@Override</span>    <span class="keyword">public</span> <span class="type">double</span> <span class="title function_">sum</span><span class="params">()</span> &#123;        <span class="keyword">return</span> <span class="number">0</span>;    &#125;    <span class="meta">@Override</span>    <span class="keyword">public</span> <span class="type">double</span> <span class="title function_">avg</span><span class="params">()</span> &#123;        <span class="keyword">return</span> <span class="number">0</span>;    &#125;    <span class="meta">@Override</span>    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">printScore</span><span class="params">()</span> &#123;    &#125;&#125;</code></pre><p>可以看出问题. 查询成绩单, 我们只会用到两个方法, 可是因为实现了接口, 不得不重写所有的方法.</p><p> 如果这时候增加需求–发送给家长, 只有老师才有这个权限, 学生没有这个权限. 可是, 在接口中增加一个抽象方法以后, 所有的实现类都要重写这个方法. 这就违背了开闭原则.</p><h3 id="6-2-使用接口隔离原则的设计"><a href="#6-2-使用接口隔离原则的设计" class="headerlink" title="6.2 使用接口隔离原则的设计"></a>6.2 使用接口隔离原则的设计</h3><p>采用接口隔离原则设计的接口, 代码如下:</p><pre><code class="highlight java"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">IQueryScore</span> &#123;    <span class="comment">// 查询成绩</span>    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">queryScore</span><span class="params">()</span>;    <span class="comment">// 打印成绩单</span>    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">printScore</span><span class="params">()</span>;&#125;<span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">IOperateScore</span> &#123;    <span class="comment">// 修改成绩</span>    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">updateScore</span><span class="params">()</span>;    <span class="comment">// 添加成绩</span>    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">saveScore</span><span class="params">()</span>;    <span class="comment">// 删除成绩</span>    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">delete</span><span class="params">()</span>;    <span class="comment">// 计算总分</span>    <span class="keyword">public</span> <span class="type">double</span> <span class="title function_">sum</span><span class="params">()</span>;    <span class="comment">// 计算平均分</span>    <span class="keyword">public</span> <span class="type">double</span> <span class="title function_">avg</span><span class="params">()</span>;&#125;<span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">StudentOperate</span> <span class="keyword">implements</span> <span class="title class_">IQueryScore</span>&#123;    <span class="meta">@Override</span>    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">queryScore</span><span class="params">()</span> &#123;        <span class="comment">// 查询成绩</span>    &#125;    <span class="meta">@Override</span>    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">printScore</span><span class="params">()</span> &#123;        <span class="comment">//打印成绩单</span>    &#125;&#125;<span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">TeacherOperate</span> <span class="keyword">implements</span> <span class="title class_">IQueryScore</span>, IOperateScore&#123;    <span class="meta">@Override</span>    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">queryScore</span><span class="params">()</span> &#123;    &#125;    <span class="meta">@Override</span>    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">updateScore</span><span class="params">()</span> &#123;    &#125;    <span class="meta">@Override</span>    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">saveScore</span><span class="params">()</span> &#123;    &#125;    <span class="meta">@Override</span>    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">delete</span><span class="params">()</span> &#123;    &#125;    <span class="meta">@Override</span>    <span class="keyword">public</span> <span class="type">double</span> <span class="title function_">sum</span><span class="params">()</span> &#123;        <span class="keyword">return</span> <span class="number">0</span>;    &#125;    <span class="meta">@Override</span>    <span class="keyword">public</span> <span class="type">double</span> <span class="title function_">avg</span><span class="params">()</span> &#123;        <span class="keyword">return</span> <span class="number">0</span>;    &#125;    <span class="meta">@Override</span>    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">printScore</span><span class="params">()</span> &#123;    &#125;&#125;</code></pre><p>我们将原来的一个接口进行了接口拆分. 分为查询接口和操作接口. 这样学生端就不需要重写和他不相关的接口了.</p><p>如果将这些功能全部放到一个接口中显然不太合理，正确的做法是将它们分别放在输入模块、统计模块和打印模块等 3 个模块中。</p><h1 id="四、依赖倒转原则（Dependence-Inversion-Principle）"><a href="#四、依赖倒转原则（Dependence-Inversion-Principle）" class="headerlink" title="四、依赖倒转原则（Dependence Inversion Principle）"></a>四、依赖倒转原则（Dependence Inversion Principle）</h1><h2 id="1-概念"><a href="#1-概念" class="headerlink" title="1. 概念"></a>1. 概念</h2><p>依赖倒置原则(Dependence Inversion Principle, DIP), 其含义:</p><ul><li>高层模块不应该依赖低层模块，两者都应该依赖其抽象</li><li>抽象不应该依赖细节, 细节应该依赖于抽象</li><li>要针对接口编程，不要针对实现编程</li></ul><h2 id="2-什么是依赖？"><a href="#2-什么是依赖？" class="headerlink" title="2. 什么是依赖？"></a>2. 什么是依赖？</h2><p>这里的依赖关系我们理解为UML关系中的依赖。简单的说就是A use B，那么A对B产生了依赖。具体请看下面的例子。</p><p><img src="https://raw.githubusercontent.com/GeorgeChan95/blogimg/master/img/2024/10/31/20241031-190021.png" alt="依赖"></p><p>从上图中我们可以发现, 类A中的<code>方法a()</code>里面用到了类B, 其实这就是依赖关系, A依赖了B. 需要注意的是: 并不是说A中声明了B就叫依赖, 如果引用了但是没有真实调用方法, 那么叫做零耦合关系. 如下图:</p><p><img src="https://raw.githubusercontent.com/GeorgeChan95/blogimg/master/img/2024/10/31/20241031-190058.png" alt="零耦合"></p><h2 id="3-依赖的关系种类"><a href="#3-依赖的关系种类" class="headerlink" title="3. 依赖的关系种类"></a>3. 依赖的关系种类</h2><p>1、零耦合关系：如果两个类之间没有耦合关系，称之为零耦合</p><p><img src="https://raw.githubusercontent.com/GeorgeChan95/blogimg/master/img/2024/10/31/20241031-190458.png" alt="零耦合关系"></p><p>2、直接耦合关系: 具体耦合发生在两个具体类（可实例化的）之间，经由一个类对另一个类的直接引用造成。</p><p><img src="https://raw.githubusercontent.com/GeorgeChan95/blogimg/master/img/2024/10/31/20241031-190516.png" alt="直接耦合关系"></p><p>3、抽象耦合关系: 抽象耦合关系发生在一个具体类和一个抽象类（或者java接口）之间，使两个必须发生关系的类之间存在最大的灵活性。</p><p><img src="https://raw.githubusercontent.com/GeorgeChan95/blogimg/master/img/2024/10/31/20241031-190525.png" alt="抽象耦合关系"></p><p>依赖倒转原则就是要针对接口编程，不要针对实现编程。这就是说，应当使用接口或者抽象类进行<strong>变量的类型声明</strong>，<strong>参数的类型声明</strong>，<strong>方法的返回类型说明</strong>，<strong>以及数据类型的转换</strong>等。</p><h2 id="4-依赖倒置的案例"><a href="#4-依赖倒置的案例" class="headerlink" title="4. 依赖倒置的案例"></a>4. 依赖倒置的案例</h2><h3 id="4-1-初步设计方案"><a href="#4-1-初步设计方案" class="headerlink" title="4.1 初步设计方案"></a>4.1 初步设计方案</h3><pre><code class="highlight java"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Benz</span> &#123;    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span> &#123;        System.out.println(<span class="string">&quot;奔驰跑起来了!&quot;</span>);    &#125;&#125;<span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Driver</span> &#123;    <span class="keyword">private</span> String name;    <span class="keyword">public</span> <span class="title function_">Driver</span><span class="params">(String name)</span> &#123;        <span class="built_in">this</span>.name = name;    &#125;    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">driver</span><span class="params">(Benz benz)</span> &#123;        benz.run();    &#125;&#125;<span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">CarTest</span> &#123;    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;        <span class="type">Benz</span> <span class="variable">benz</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Benz</span>();        <span class="type">Driver</span> <span class="variable">driver</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Driver</span>(<span class="string">&quot;张三&quot;</span>);        driver.driver(benz);    &#125;&#125;</code></pre><p>有一个驾驶员张三可以驾驶奔驰汽车, 于是最开始我们思考, 会有一个驾驶员类, 有一个奔驰汽车类. 随着业务的发展, 我们发现, 驾驶员张三还可以驾驶宝马.</p><p>于是,我们定义一个BM类,</p><pre><code class="highlight java"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">BM</span> &#123;    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span> &#123;        System.out.println(<span class="string">&quot;宝马跑起来了!&quot;</span>);    &#125;&#125;</code></pre><p>这时, 张三如果想要开宝马, 就要将宝马注册在他名下.</p><pre><code class="highlight java"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Driver</span> &#123;    <span class="keyword">private</span> String name;    <span class="keyword">public</span> <span class="title function_">Driver</span><span class="params">(String name)</span> &#123;        <span class="built_in">this</span>.name = name;    &#125;    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">driver</span><span class="params">(Benz benz)</span> &#123;        benz.run();    &#125;    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">driver</span><span class="params">(BM bm)</span> &#123;        bm.run();    &#125;&#125;<span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">CarTest</span> &#123;    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;        <span class="type">Benz</span> <span class="variable">benz</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Benz</span>();        <span class="type">BM</span> <span class="variable">bm</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">BM</span>();        <span class="type">Driver</span> <span class="variable">driver</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Driver</span>(<span class="string">&quot;张三&quot;</span>);        driver.driver(benz);        driver.driver(bm);    &#125;&#125;</code></pre><p>似乎这样就可以了, 但是这样有什么问题呢?</p><ul><li>如果张三有一天要开大众, 还要增加一个大众车类, 同时还得挂载司机名下.</li><li>不是所有的人都要开奔驰, 开宝马. 开大众.</li></ul><p>这就是面向实现编程的问题, 接下来我们就要考虑面向接口编程.</p><h3 id="4-2-改进后的方案"><a href="#4-2-改进后的方案" class="headerlink" title="4.2 改进后的方案"></a>4.2 改进后的方案</h3><pre><code class="highlight java"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">ICar</span> &#123;    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span>;&#125;<span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Benz</span> <span class="keyword">implements</span> <span class="title class_">ICar</span>&#123;    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span> &#123;        System.out.println(<span class="string">&quot;奔驰跑起来了!&quot;</span>);    &#125;&#125;<span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">BM</span> <span class="keyword">implements</span> <span class="title class_">ICar</span>&#123;    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span> &#123;        System.out.println(<span class="string">&quot;宝马跑起来了!&quot;</span>);    &#125;&#125;<span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">IDriver</span> &#123;    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">driver</span><span class="params">(ICar car)</span>;&#125;<span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Driver</span> <span class="keyword">implements</span> <span class="title class_">IDriver</span>&#123;    <span class="meta">@Override</span>    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">driver</span><span class="params">(ICar car)</span> &#123;        car.run();    &#125;&#125;<span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">CarTest</span> &#123;    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;        <span class="type">IDriver</span> <span class="variable">driver</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Driver</span>();        driver.driver(<span class="keyword">new</span> <span class="title class_">Benz</span>());        driver.driver(<span class="keyword">new</span> <span class="title class_">BM</span>());    &#125;&#125;</code></pre><p>修改后的代码, 提炼出来一个IDriver接口和ICar接口, 面向接口编程. IDriver的实现类驾驶员可以driver任何类型的汽车, 所以传入参数也是一个接口ICar. 任何类型的汽车, 都可以通过实现ICar接口注册为一种新的汽车类型. 当客户端调用的时候, 将对应的汽车传入就可以了.</p><h2 id="5-依赖的方式"><a href="#5-依赖的方式" class="headerlink" title="5.依赖的方式"></a>5.依赖的方式</h2><h3 id="5-1-依赖注入主要有三种方式"><a href="#5-1-依赖注入主要有三种方式" class="headerlink" title="5.1 依赖注入主要有三种方式"></a>5.1 依赖注入主要有三种方式</h3><ul><li><p>构造注入</p><p>在构造的时候注入依赖</p></li><li><p>Setter方法注入</p></li><li><p>接口方法中注入(汽车的例子使用的就是此方法)</p></li></ul><h3 id="5-2-依赖倒置原则在设计模式中的体现"><a href="#5-2-依赖倒置原则在设计模式中的体现" class="headerlink" title="5.2 依赖倒置原则在设计模式中的体现"></a>5.2 依赖倒置原则在设计模式中的体现</h3><ul><li>简单工厂设计模式, 使用的是接口方法中注入</li><li>策略设计模式: 在构造函数中注入</li></ul><h1 id="五、里氏替换原则（Liskov-Substitution-Principle）"><a href="#五、里氏替换原则（Liskov-Substitution-Principle）" class="headerlink" title="五、里氏替换原则（Liskov Substitution Principle）"></a>五、里氏替换原则（Liskov Substitution Principle）</h1><h2 id="1-什么是里式替换原则"><a href="#1-什么是里式替换原则" class="headerlink" title="1. 什么是里式替换原则"></a>1. 什么是里式替换原则</h2><h3 id="1-1-里式替换原则定义"><a href="#1-1-里式替换原则定义" class="headerlink" title="1.1 里式替换原则定义"></a>1.1 里式替换原则定义</h3><p>里式替换原则是用来帮助我们在继承关系中进行父子类的设计。</p><p>里氏替换原则（Liskov Substitution principle）是对子类型的特别定义的. 为什么叫里式替换原则呢?因为这项原则最早是在1988年，由麻省理工学院的一位姓里的女士（Barbara Liskov）提出来的。</p><p>里氏替换原则主要阐述了有关继承的一些原则，也就是什么时候应该使用继承，什么时候不应该使用继承，以及其中蕴含的原理。里氏替换原是继承复用的基础，它反映了基类与子类之间的关系，是对开闭原则的补充，是对实现抽象化的具体步骤的规范。</p><p>里式替换原则有两层定义: </p><p>定义1：</p><blockquote><p>If S is a subtype of T, then objects of type T may be replaced with objects of type S, without breaking the program。 如果S是T的子类，则T的对象可以替换为S的对象，而不会破坏程序。</p></blockquote><p>定义2：</p><blockquote><p>Functions that use pointers of references to base classes must be able to use objects of derived classes without knowing it。<br>所有引用其父类对象方法的地方，都可以透明的替换为其子类对象</p></blockquote><p>这两种定义方式其实都是一个意思，即：应用程序中任何父类对象出现的地方，我们都可以用其子类的对象来替换，并且可以保证原有程序的逻辑行为和正确性。</p><h3 id="1-2-里氏替换原则有至少有两种含义"><a href="#1-2-里氏替换原则有至少有两种含义" class="headerlink" title="1.2 里氏替换原则有至少有两种含义"></a>1.2 里氏替换原则有至少有两种含义</h3><ul><li>里氏替换原则是针对继承而言的，如果继承是为了实现代码重用，也就是为了共享方法，那么共享的父类方法就应该保持不变，不能被子类重新定义。子类只能通过新添加方法来扩展功能，父类和子类都可以实例化，而子类继承的方法和父类是一样的，父类调用方法的地方，子类也可以调用同一个继承得来的，逻辑和父类一致的方法，这时用子类对象将父类对象替换掉时，当然逻辑一致，相安无事。</li><li>如果继承的目的是为了多态，而多态的前提就是子类覆盖并重新定义父类的方法，为了符合LSP，我们应该将父类定义为抽象类，并定义抽象方法，让子类重新定义这些方法，当父类是抽象类时，父类就是不能实例化，所以也不存在可实例化的父类对象在程序里。也就不存在子类替换父类实例（根本不存在父类实例了）时逻辑不一致的可能。</li></ul><p>不符合LSP的最常见的情况是，父类和子类都是可实例化的非抽象类，且父类的方法被子类重新定义，这一类的实现继承会造成父类和子类间的强耦合，也就是实际上并不相关的属性和方法牵强附会在一起，不利于程序扩展和维护。</p><h2 id="2-使用里式替换原则的目的"><a href="#2-使用里式替换原则的目的" class="headerlink" title="2. 使用里式替换原则的目的"></a>2. 使用里式替换原则的目的</h2><p>采用里氏替换原则就是为了减少继承带来的缺点，增强程序的健壮性，版本升级时也可以保持良好的兼容性。即使增加子类，原有的子类也可以继续运行。</p><h2 id="3-里式替换原则与继承多态之间的关系"><a href="#3-里式替换原则与继承多态之间的关系" class="headerlink" title="3. 里式替换原则与继承多态之间的关系"></a>3. 里式替换原则与继承多态之间的关系</h2><p>里式替换原则和继承多态有关系, 但是他俩并不是一回事. 我们来看看下面的案例</p><pre><code class="highlight java"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Cache</span> &#123;    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">set</span><span class="params">(String key, String value)</span> &#123;    &#125;&#125;<span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Redis</span> <span class="keyword">extends</span> <span class="title class_">Cache</span> &#123;    <span class="meta">@Override</span>    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">set</span><span class="params">(String key, String value)</span> &#123;    &#125;&#125;<span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Memcache</span> <span class="keyword">extends</span> <span class="title class_">Cache</span> &#123;    <span class="meta">@Override</span>    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">set</span><span class="params">(String key, String value)</span> &#123;    &#125;&#125;<span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">CacheTest</span> &#123;    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;        <span class="comment">// 父类对象都可以接收子类对象</span>        <span class="type">Cache</span> <span class="variable">cache</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Cache</span>();        cache.set(<span class="string">&quot;key123&quot;</span>, <span class="string">&quot;key123&quot;</span>);        cache = <span class="keyword">new</span> <span class="title class_">Redis</span>();        cache.set(<span class="string">&quot;key123&quot;</span>, <span class="string">&quot;key123&quot;</span>);        cache = <span class="keyword">new</span> <span class="title class_">Memcache</span>();        cache.set(<span class="string">&quot;key123&quot;</span>, <span class="string">&quot;key123&quot;</span>);    &#125;&#125;</code></pre><p>通过上面的例子, 可以看出Cache是父类, Redis 和 Memcache是子类, 他们继承自Cache. 这是继承和多态的思想. 而且这两个子类目前为止也都符合里式替换原则.可以替换父类出现的任何位置，并且原来代码的逻辑行为不变且正确性也没有被破坏。 看最后的CacheTest类, 我们使用父类的cache可以接收任何一种类型的缓存对象, 包括父类和子类.</p><p>但如果我们对Redis中的set方法做了长度校验</p><pre><code class="highlight java"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Redis</span> <span class="keyword">extends</span> <span class="title class_">Cache</span>&#123;    <span class="meta">@Override</span>    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">set</span><span class="params">(String key, String value)</span> &#123;        <span class="keyword">if</span> (key == <span class="literal">null</span> || key.length() &lt; <span class="number">10</span> || key.length() &gt; <span class="number">100</span>) &#123;            System.out.println(<span class="string">&quot;key的长度不符合要求&quot;</span>);            <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">IllegalArgumentException</span>(key的长度不符合要求);        &#125;    &#125;&#125;<span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">CacheTest</span> &#123;    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;        <span class="comment">// 父类对象都可以接收子类对象</span>        <span class="type">Cache</span> <span class="variable">cache</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Cache</span>();        cache.set(<span class="string">&quot;key123&quot;</span>, <span class="string">&quot;key123&quot;</span>);        cache = <span class="keyword">new</span> <span class="title class_">Redis</span>();        cache.set(<span class="string">&quot;key123&quot;</span>, <span class="string">&quot;key123&quot;</span>);    &#125;&#125;</code></pre><p>如上情况, 如果我们使用父类对象时替换成子类对象, 那么就会抛出异常. 程序的逻辑行为就发生了变化，虽然改造之后的代码仍然可以通过子类来替换父类 ，但是，从设计思路上来讲，Redis子类的设计是不符合里式替换原则的。</p><p>继承和多态是面向对象语言所提供的一种语法，是代码实现的思路，而里式替换则是一种思想，一种设计原则，是用来指导继承关系中子类该如何设计的，子类的设计要保证在替换父类的时候，不改变原有程序的逻辑以及不破坏原有程序的正确性。</p><h2 id="4-里式替换的规则"><a href="#4-里式替换的规则" class="headerlink" title="4. 里式替换的规则"></a>4. 里式替换的规则</h2><p>里式替换原则的核心就是“约定”，父类与子类的约定。里氏替换原则要求子类在进行设计的时候要遵守父类的一些行为约定。这里的行为约定包括：函数所要实现的功能，对输入、输出、异常的约定，甚至包括注释中一些特殊说明等。</p><h3 id="4-1-子类方法不能违背父类方法对输入输出异常的约定"><a href="#4-1-子类方法不能违背父类方法对输入输出异常的约定" class="headerlink" title="4.1 子类方法不能违背父类方法对输入输出异常的约定"></a>4.1 子类方法不能违背父类方法对输入输出异常的约定</h3><p>1、前置条件不能被加强</p><p>前置条件即输入参数是不能被加强的，就像上面Cache的示例，Redis子类对输入参数Key的要求进行了加强，此时在调用处替换父类对象为子类对象就可能引发异常。</p><p>也就是说，子类对输入的数据的校验比父类更加严格，那子类的设计就违背了里式替换原则。</p><p>2、后置条件不能被削弱</p><p>后置条件即输出，假设我们的父类方法约定输出参数要大于0，调用父类方法的程序根据约定对输出参数进行了大于0的验证。而子类在实现的时候却输出了小于等于0的值。此时子类的涉及就违背了里氏替换原则</p><p>3、不能违背对异常的约定</p><p>在父类中，某个函数约定，只会抛出 ArgumentNullException 异常， 那子类的设计实现中只允许抛出 ArgumentNullException 异常，任何其他异常的抛出，都会导致子类违背里式替换原则。</p><h3 id="4-2-子类方法不能违背父类方法定义的功能"><a href="#4-2-子类方法不能违背父类方法定义的功能" class="headerlink" title="4.2 子类方法不能违背父类方法定义的功能"></a>4.2 子类方法不能违背父类方法定义的功能</h3><pre><code class="highlight java"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Product</span> &#123;    <span class="keyword">private</span> BigDecimal amount;    <span class="keyword">private</span> Calendar createTime;     <span class="keyword">public</span> BigDecimal <span class="title function_">getAmount</span><span class="params">()</span> &#123;        <span class="keyword">return</span> amount;    &#125;    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setAmount</span><span class="params">(BigDecimal amount)</span> &#123;        <span class="built_in">this</span>.amount = amount;    &#125;     <span class="keyword">public</span> Calendar <span class="title function_">getCreateTime</span><span class="params">()</span> &#123;        <span class="keyword">return</span> createTime;    &#125;    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setCreateTime</span><span class="params">(Calendar createTime)</span> &#123;        <span class="built_in">this</span>.createTime = createTime;    &#125;&#125; <span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ProductSort</span> <span class="keyword">extends</span> <span class="title class_">Sort</span>&lt;Product&gt; &#123;     <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">sortByAmount</span><span class="params">(List&lt;Product&gt; list)</span> &#123;        <span class="comment">//根据时间进行排序</span>        list.sort((h1, h2)-&gt;h1.getCreateTime().compareTo(h2.getCreateTime()));    &#125;&#125;</code></pre><p>父类中提供的 sortByAmount() 排序函数，是按照金额从小到大来进行排序的，而子类重写这个 sortByAmount() 排序函数之后，却是是按照创建日期来进行排序的。那子类的设计就违背里式替换原则。</p><p>实际上对于如何验证子类设计是否符合里氏替换原则其实有一个小技巧，那就是你可以使用父类的单测来运行子类的代码，如果不可以正常运行，那么你就要考虑一下自己的设计是否合理了！</p><h3 id="4-3-子类必须完全实现父类的抽象方法"><a href="#4-3-子类必须完全实现父类的抽象方法" class="headerlink" title="4.3 子类必须完全实现父类的抽象方法"></a>4.3 子类必须完全实现父类的抽象方法</h3><p>如果你设计的子类不能完全实现父类的抽象方法那么你的设计就不满足里式替换原则。</p><pre><code class="highlight java"><span class="comment">// 定义抽象类枪</span><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">class</span> <span class="title class_">AbstractGun</span>&#123;    <span class="comment">// 射击</span>    <span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">void</span> <span class="title function_">shoot</span><span class="params">()</span>;        <span class="comment">// 杀人</span>    <span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">void</span> <span class="title function_">kill</span><span class="params">()</span>;&#125;</code></pre><p>比如我们定义了一个抽象的枪类，可以射击和杀人。无论是步枪还是手枪都可以射击和杀人，我们可以定义子类来继承父类</p><pre><code class="highlight java"><span class="comment">// 定义手枪，步枪，机枪</span><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Handgun</span> <span class="keyword">extends</span> <span class="title class_">AbstractGun</span>&#123;       <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">shoot</span><span class="params">()</span>&#123;           <span class="comment">// 手枪射击</span>    &#125;        <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">kill</span><span class="params">()</span>&#123;            <span class="comment">// 手枪杀人</span>    &#125;&#125;<span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Rifle</span> <span class="keyword">extends</span> <span class="title class_">AbstractGun</span>&#123;    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">shoot</span><span class="params">()</span>&#123;         <span class="comment">// 步枪射击</span>    &#125;        <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">kill</span><span class="params">()</span>&#123;             <span class="comment">// 步枪杀人</span>    &#125;&#125;</code></pre><p>但是如果我们在这个继承体系内加入一个玩具枪，就会有问题了，因为玩具枪只能射击，不能杀人。但是很多人写代码经常会这么写。</p><pre><code class="highlight java"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ToyGun</span> <span class="keyword">extends</span> <span class="title class_">AbstractGun</span>&#123;    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">shoot</span><span class="params">()</span>&#123;        <span class="comment">// 玩具枪射击</span>    &#125;        <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">kill</span><span class="params">()</span>&#123;         <span class="comment">// 因为玩具枪不能杀人，就返回空，或者直接throw一个异常出去</span>        <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">Exception</span>(<span class="string">&quot;我是个玩具枪，惊不惊喜，意不意外，刺不刺激？&quot;</span>);    &#125;&#125;</code></pre><p>这时，我们如果把使用父类对象的地方替换为子类对象，显然是会有问题的。</p><p>而这种情况不仅仅不满足里氏替换原则，也不满足接口隔离原则，对于这种场景可以通过 <strong>接口隔离+委托</strong> 的方式来解决。</p><h2 id="5-里氏替换原则的作用"><a href="#5-里氏替换原则的作用" class="headerlink" title="5. 里氏替换原则的作用"></a>5. 里氏替换原则的作用</h2><ul><li>里氏替换原则是实现开闭原则的重要方式之一。</li><li>它克服了继承中重写父类造成的可复用性变差的缺点。</li><li>它是动作正确性的保证。即类的扩展不会给已有的系统引入新的错误，降低了代码出错的可能性。</li><li>加强程序的健壮性，同时变更时可以做 到非常好的兼容性，提高程序的维护性、可扩展性，降低需求变更时引入的风险。</li></ul><p><strong>尽量不要从可实例化的父类中继承，而是要使用基于抽象类和接口的继承。</strong></p><h2 id="6-里氏替换原则的实现方法"><a href="#6-里氏替换原则的实现方法" class="headerlink" title="6. 里氏替换原则的实现方法"></a>6. 里氏替换原则的实现方法</h2><p>里氏替换原则通俗来讲就是：子类可以扩展父类的功能，但不能改变父类原有的功能。也就是说：子类继承父类时，除添加新的方法完成新增功能外，尽量不要重写父类的方法。</p><p>根据上述理解，对里氏替换原则的定义可以总结如下：</p><ul><li>子类可以实现父类的抽象方法，但不能覆盖父类的非抽象方法</li><li>子类中可以增加自己特有的方法</li><li>当子类的方法重载父类的方法时，方法的前置条件（即方法的输入参数）要比父类的方法更宽松</li><li>当子类的方法实现父类的方法时（重写&#x2F;重载或实现抽象方法），方法的后置条件（即方法的的输出&#x2F;返回值）要比父类的方法更严格或相等</li></ul><p>通过重写父类的方法来完成新的功能写起来虽然简单，但是整个继承体系的可复用性会比较差，特别是运用多态比较频繁时，程序运行出错的概率会非常大。</p><p>如果程序违背了里氏替换原则，则继承类的对象在基类出现的地方会出现运行错误。这时其修正方法是：取消原来的继承关系，重新设计它们之间的关系。</p><h2 id="7-案例分析"><a href="#7-案例分析" class="headerlink" title="7. 案例分析"></a>7. 案例分析</h2><h3 id="7-1-案例一-两数相减"><a href="#7-1-案例一-两数相减" class="headerlink" title="7.1 案例一: 两数相减"></a>7.1 案例一: 两数相减</h3><p>当使用继承时，遵循里氏替换原则。类B继承类A时，除添加新的方法完成新增功能P2外，尽量不要重写父类A的方法，也尽量不要重载父类A的方法。</p><p>继承包含这样一层含义：父类中凡是已经实现好的方法（相对于抽象方法而言），实际上是在设定一系列的规范和契约，虽然它不强制要求所有的子类必须遵从这些契约，但是如果子类对这些非抽象方法任意修改，就会对整个继承体系造成破坏。而里氏替换原则就是表达了这一层含义。</p><blockquote><p>继承作为面向对象三大特性之一，在给程序设计带来巨大便利的同时，也带来了弊端。比如使用继承会给程序带来侵入性，程序的可移植性降低，增加了对象间的耦合性，如果一个类被其他的类所继承，则当这个类需要修改时，必须考虑到所有的子类，并且父类修改后，所有涉及到子类的功能都有可能会产生故障。</p></blockquote><pre><code class="highlight java"><span class="keyword">class</span> <span class="title class_">A</span>&#123;<span class="keyword">public</span> <span class="type">int</span> <span class="title function_">func1</span><span class="params">(<span class="type">int</span> a, <span class="type">int</span> b)</span>&#123;<span class="keyword">return</span> a-b;&#125;&#125; <span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Client</span>&#123;<span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span>&#123;<span class="type">A</span> <span class="variable">a</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">A</span>();System.out.println(<span class="string">&quot;100-50=&quot;</span>+a.func1(<span class="number">100</span>, <span class="number">50</span>));System.out.println(<span class="string">&quot;100-80=&quot;</span>+a.func1(<span class="number">100</span>, <span class="number">80</span>));&#125;&#125;</code></pre><p>运行结果：</p><pre><code class="highlight shell">100-50=50 100-80=20</code></pre><p>后来，我们需要增加一个新的功能：完成两数相加，然后再与100求和，由类B来负责。即类B需要完成两个功能：</p><ol><li>两数相减。</li><li>两数相加，然后再加100。</li></ol><p>由于类A已经实现了第一个功能，所以类B继承类A后，只需要再完成第二个功能就可以了，代码如下：</p><pre><code class="highlight java"><span class="keyword">class</span> <span class="title class_">B</span> <span class="keyword">extends</span> <span class="title class_">A</span>&#123;<span class="keyword">public</span> <span class="type">int</span> <span class="title function_">func1</span><span class="params">(<span class="type">int</span> a, <span class="type">int</span> b)</span>&#123;<span class="keyword">return</span> a+b;&#125;<span class="keyword">public</span> <span class="type">int</span> <span class="title function_">func2</span><span class="params">(<span class="type">int</span> a, <span class="type">int</span> b)</span>&#123;<span class="keyword">return</span> func1(a,b)+<span class="number">100</span>;&#125;&#125; <span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Client</span>&#123;<span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span>&#123;<span class="type">B</span> <span class="variable">b</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">B</span>();System.out.println(<span class="string">&quot;100-50=&quot;</span>+b.func1(<span class="number">100</span>, <span class="number">50</span>));System.out.println(<span class="string">&quot;100-80=&quot;</span>+b.func1(<span class="number">100</span>, <span class="number">80</span>));System.out.println(<span class="string">&quot;100+20+100=&quot;</span>+b.func2(<span class="number">100</span>, <span class="number">20</span>));&#125;&#125;</code></pre><p>类B完成后，运行结果：</p><pre><code class="highlight shell">100-50=150 100-80=180 100+20+100=220</code></pre><p>我们发现原本运行正常的相减功能发生了错误。原因就是类B在给方法起名时无意中重写了父类的方法，造成所有运行相减功能的代码全部调用了类B重写后的方法，造成原本运行正常的功能出现了错误。在本例中，引用基类A完成的功能，换成子类B之后，发生了异常。在实际编程中，我们常常会通过重写父类的方法来完成新的功能，这样写起来虽然简单，但是整个继承体系的可复用性会比较差，特别是运用多态比较频繁时，程序运行出错的几率非常大。如果非要重写父类的方法，比较<strong>通用的做法是：原来的父类和子类都继承一个更通俗的基类，原有的继承关系去掉，采用依赖、聚合，组合等关系代替。</strong></p><h3 id="7-2-案例二-“几维鸟不是鸟”"><a href="#7-2-案例二-“几维鸟不是鸟”" class="headerlink" title="7.2 案例二: “几维鸟不是鸟”"></a>7.2 案例二: “几维鸟不是鸟”</h3><p>需求分析: 鸟通常都是会飞的, 比如燕子每小时120千米, 但是新西兰的几维鸟由于翅膀退化不会飞. 假如要设计一个实例，计算这两种鸟飞行 300 千米要花费的时间。显然，拿燕子来测试这段代码，结果正确，能计算出所需要的时间；但拿几维鸟来测试，结果会发生“除零异常”或是“无穷大”，明显不符合预期，其类图如图 下 所示。</p><p><img src="https://raw.githubusercontent.com/GeorgeChan95/blogimg/master/img/2024/10/31/20241031-202900.png" alt="里氏替换原则"></p><p>源码如下:</p><pre><code class="highlight java"><span class="comment">/**</span><span class="comment"> * 鸟</span><span class="comment"> */</span><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Bird</span> &#123;    <span class="comment">// 飞行的速度</span>    <span class="keyword">private</span> <span class="type">double</span> flySpeed;    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setFlySpeed</span><span class="params">(<span class="type">double</span> flySpeed)</span> &#123;        <span class="built_in">this</span>.flySpeed = flySpeed;    &#125;    <span class="keyword">public</span> <span class="type">double</span> <span class="title function_">getFlyTime</span><span class="params">(<span class="type">double</span> distance)</span> &#123;        <span class="keyword">return</span> distance/flySpeed;    &#125;&#125;<span class="comment">/**</span><span class="comment"> * 燕子</span><span class="comment"> */</span><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Swallow</span> <span class="keyword">extends</span> <span class="title class_">Bird</span>&#123;&#125;<span class="comment">/**</span><span class="comment"> * 几维鸟</span><span class="comment"> */</span><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Kiwi</span> <span class="keyword">extends</span> <span class="title class_">Bird</span> &#123;    <span class="meta">@Override</span>    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setFlySpeed</span><span class="params">(<span class="type">double</span> flySpeed)</span> &#123;        flySpeed = <span class="number">0</span>;    &#125;&#125;<span class="comment">/**</span><span class="comment">  * 测试飞行耗费时间</span><span class="comment">  */</span><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">BirdTest</span> &#123;    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;        <span class="type">Bird</span> <span class="variable">bird1</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Swallow</span>();        <span class="type">Bird</span> <span class="variable">bird2</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Kiwi</span>();        bird1.setFlySpeed(<span class="number">120</span>);        bird2.setFlySpeed(<span class="number">120</span>);        System.out.println(<span class="string">&quot;如果飞行300公里：&quot;</span>);        <span class="keyword">try</span> &#123;            System.out.println(<span class="string">&quot;燕子花费&quot;</span> + bird1.getFlyTime(<span class="number">300</span>) + <span class="string">&quot;小时.&quot;</span>);            System.out.println(<span class="string">&quot;几维花费&quot;</span> + bird2.getFlyTime(<span class="number">300</span>) + <span class="string">&quot;小时。&quot;</span>);        &#125; <span class="keyword">catch</span> (Exception err) &#123;            System.out.println(<span class="string">&quot;发生错误了!&quot;</span>);        &#125;    &#125;&#125;</code></pre><p>运行结果:</p><pre><code class="highlight java">如果飞行<span class="number">300</span>公里： 燕子花费<span class="number">2.5</span>小时. 几维花费Infinity小时。</code></pre><p>程序运行错误的原因是：几维鸟类重写了鸟类的 setSpeed(double speed) 方法，这违背了里氏替换原则。正确的做法是：取消几维鸟原来的继承关系，定义鸟和几维鸟的更一般的父类，如动物类，它们都有奔跑的能力。几维鸟的飞行速度虽然为 0，但奔跑速度不为 0，可以计算出其奔跑 300 千米所要花费的时间。其类图如图 下所示。</p><p><img src="https://raw.githubusercontent.com/GeorgeChan95/blogimg/master/img/2024/10/31/20241031-203352.png" alt="里氏替换原则2"></p><p>源代码实现如下</p><pre><code class="highlight java"><span class="comment">/**</span><span class="comment"> * 动物</span><span class="comment"> */</span><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Animal</span> &#123;    <span class="keyword">private</span> <span class="type">double</span> runSpeed;    <span class="keyword">public</span> <span class="type">double</span> <span class="title function_">getRunTime</span><span class="params">(<span class="type">double</span> distance)</span> &#123;        <span class="keyword">return</span> distance/runSpeed;    &#125;    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setRunSpeed</span><span class="params">(<span class="type">double</span> runSpeed)</span> &#123;        <span class="built_in">this</span>.runSpeed = runSpeed;    &#125;&#125;<span class="comment">/**</span><span class="comment"> * 鸟</span><span class="comment"> */</span><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Bird</span> &#123;    <span class="comment">// 飞行的速度</span>    <span class="keyword">private</span> <span class="type">double</span> flySpeed;    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setFlySpeed</span><span class="params">(<span class="type">double</span> flySpeed)</span> &#123;        <span class="built_in">this</span>.flySpeed = flySpeed;    &#125;    <span class="keyword">public</span> <span class="type">double</span> <span class="title function_">getFlyTime</span><span class="params">(<span class="type">double</span> distance)</span> &#123;        <span class="keyword">return</span> distance/flySpeed;    &#125;&#125;<span class="comment">/**</span><span class="comment"> * 燕子</span><span class="comment"> */</span><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Swallow</span> <span class="keyword">extends</span> <span class="title class_">Bird</span> &#123;&#125;<span class="comment">/**</span><span class="comment"> * 几维鸟</span><span class="comment"> */</span><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Kiwi</span> <span class="keyword">extends</span> <span class="title class_">Animal</span> &#123;    <span class="meta">@Override</span>    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setRunSpeed</span><span class="params">(<span class="type">double</span> runSpeed)</span> &#123;        <span class="built_in">super</span>.setRunSpeed(runSpeed);    &#125;&#125;<span class="comment">/**</span><span class="comment">  * 测试飞行耗费时间</span><span class="comment">  */</span><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">BirdTest</span> &#123;    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;        <span class="type">Bird</span> <span class="variable">bird1</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Swallow</span>();        <span class="type">Animal</span> <span class="variable">bird2</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Kiwi</span>();        bird1.setFlySpeed(<span class="number">120</span>);        bird2.setRunSpeed(<span class="number">110</span>);        System.out.println(<span class="string">&quot;如果飞行300公里：&quot;</span>);        <span class="keyword">try</span> &#123;            System.out.println(<span class="string">&quot;燕子花费&quot;</span> + bird1.getFlyTime(<span class="number">300</span>) + <span class="string">&quot;小时.&quot;</span>);            System.out.println(<span class="string">&quot;几维鸟花费&quot;</span> + bird2.getRunTime(<span class="number">300</span>) + <span class="string">&quot;小时。&quot;</span>);        &#125; <span class="keyword">catch</span> (Exception err) &#123;            System.out.println(<span class="string">&quot;发生错误了!&quot;</span>);        &#125;    &#125;&#125;</code></pre><p>运行结果</p><pre><code class="highlight shell">如果飞行300公里： 燕子花费2.5小时. 几维鸟花费2.727272727272727小时。</code></pre><p><strong>总结:</strong></p><p>面向对象的编程思想中提供了继承和多态是我们可以很好的实现代码的复用性和可扩展性，但继承并非没有缺点，因为继承的本身就是具有侵入性的，如果使用不当就会大大增加代码的耦合性，而降低代码的灵活性，增加我们的维护成本，然而在实际使用过程中却往往会出现滥用继承的现象，而里式替换原则可以很好的帮助我们在继承关系中进行父子类的设计。</p><h1 id="六、开闭原则（Open-Closed-Principle）"><a href="#六、开闭原则（Open-Closed-Principle）" class="headerlink" title="六、开闭原则（Open Closed Principle）"></a>六、开闭原则（Open Closed Principle）</h1><h2 id="1-什么是开闭原则"><a href="#1-什么是开闭原则" class="headerlink" title="1. 什么是开闭原则"></a>1. 什么是开闭原则</h2><p>开放封闭原则（OCP，Open Closed Principle）是所有面向对象原则的核心。软件设计本身所追求的目标就是封装变化、降低耦合，而开放封闭原则正是对这一目标的最直接体现。其他的设计原则，很多时候是为实现这一目标服务的.</p><h3 id="1-1-开闭原则的定义"><a href="#1-1-开闭原则的定义" class="headerlink" title="1.1 开闭原则的定义"></a>1.1 开闭原则的定义</h3><blockquote><p>Software entities like classes,modules and functions should be open for extension but closed for modifications 一个软件实体, 如类, 模块, 函数等应该对扩展开放, 对修改封闭.</p></blockquote><p>这也是开放封闭原则的核心思想：对扩展开放，对修改封闭.</p><ul><li>对扩展开放，意味着有新的需求或变化时，可以对现有代码进行扩展，以适应新的情况。</li><li>对修改封闭，意味着类一旦设计完成，就可以独立完成其工作，而不要对已有代码进行任何修改</li></ul><h2 id="2-如何实现开放封闭原则"><a href="#2-如何实现开放封闭原则" class="headerlink" title="2. 如何实现开放封闭原则"></a>2. 如何实现开放封闭原则</h2><p>“需求总是变化”、“世界上没有一个软件是不变的”。这里投射出的意思是：需求总是变化的， 可是对于软件设计者来说, 如何才能做到不对原有系统修改的前提下, 实现灵活的扩展. 这就是开闭原则要实现的.</p><p>我们在设计系统的时候, 不可能设想一次性把需求确定后, 后面就不改变了.这不科学也不现实的. 既然需求是一定会变化的, 那么我们要如何优雅的面对这种变化呢? 如何设计可以使软件相对容易修改, 不至于需求一变, 就要把整个程序推到重来?</p><blockquote><p>开封-封闭原则. 设计软件要容易维护且不容易出问题的最好办法, 就是多扩展, 少修改.</p></blockquote><h3 id="2-1-依赖与抽象"><a href="#2-1-依赖与抽象" class="headerlink" title="2.1 依赖与抽象"></a>2.1 依赖与抽象</h3><p>实现开放封闭的核心思想就是面对抽象编程，而不是面对具体编程，因为抽象相对稳定。 让类依赖于固定的抽象，所以对修改是封闭的；而通过面向对象的继承和多态机制，可以实现对抽象体的继承，通过覆写其方法来改变固有行为，实现新的扩展方法，所以对于扩展就是开放的。这是实施开放封闭原则的基本思路。</p><h3 id="2-2-如何落地开闭原则"><a href="#2-2-如何落地开闭原则" class="headerlink" title="2.2 如何落地开闭原则"></a>2.2 如何落地开闭原则</h3><p>如果当前的设计不符合开放封闭原则，则必须进行重构。常用的设计模式主要有 <strong>模板方法（Template Method）设计模式</strong> 和 <strong>策略（Strategy）设计模式</strong> 。而封装变化，是实现这一原则的重要手段，将经常发生变化的部分封装为一个类。</p><h3 id="2-3-开闭原则的重要性"><a href="#2-3-开闭原则的重要性" class="headerlink" title="2.3 开闭原则的重要性"></a>2.3 开闭原则的重要性</h3><ol><li><p>开闭原则对测试的影响</p><p>开闭原则可是保持原有的测试代码仍然能够正常运行，我们只需要对扩展的代码进行测试就可以了。</p></li><li><p>开闭原则可以提高复用性</p><p>在面向对象的设计中，所有的逻辑都是从原子逻辑组合而来的，而不是在一个类中独立实现一个业务逻辑。只有这样代码才可以复用，粒度越小，被复用的可能性就越大。</p></li><li><p>开闭原则可以提高可维护性</p><p>面向对象开发的要求。</p></li></ol><h3 id="2-4-如何使用开闭原则"><a href="#2-4-如何使用开闭原则" class="headerlink" title="2.4 如何使用开闭原则"></a>2.4 如何使用开闭原则</h3><ul><li><p>抽象约束</p><ul><li>第一，通过接口或者抽象类约束扩展，对扩展进行边界限定，不允许出现在接口或抽象类中不存在的<strong>public</strong>方法；</li><li>第二，参数类型、引用对象尽量使用接口或者抽象类，而不是实现类； </li><li>第三，抽象层尽量保持稳定，一旦确定即不允许修改。</li></ul></li><li><p>元数据（metadata）控制模块行为</p><p>元数据就是用来描述环境和数据的数据，通俗地说就是配置参数，参数可以从文件中获得，也可以从数据库中获得。 </p><p>Spring容器就是一个典型的元数据控制模块行为的例子，其中达到极致的就是控制反转（Inversion of Control）</p></li><li><p>制定项目章程</p><p>在一个团队中，建立项目章程是非常重要的，因为章程中指定了所有人员都必须遵守的约定，对项目来说，约定优于配置。</p></li><li><p>封装变化</p><p>对变化的封装包含两层含义： </p><p>​第一，将相同的变化封装到一个接口或者抽象类中； </p><p>​第二，将不同的变化封装到不同的接口或抽象类中，不应该有两个不同的变化出现在同一个接口或抽象类中。</p></li></ul><h2 id="3-案例分析"><a href="#3-案例分析" class="headerlink" title="3. 案例分析"></a>3. 案例分析</h2><h3 id="3-1-案例一-画形状"><a href="#3-1-案例一-画形状" class="headerlink" title="3.1 案例一: 画形状"></a>3.1 案例一: 画形状</h3><p>需求: 有圆形, 有椭圆形, 根据要求画出相应的形状</p><pre><code class="highlight java"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">GraphicEditor</span> &#123;    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">draw</span><span class="params">(Shape shape)</span> &#123;        <span class="keyword">if</span> (shape.m_type == <span class="number">1</span>) &#123;            drawRectangle();        &#125; <span class="keyword">else</span> <span class="keyword">if</span>(shape.m_type == <span class="number">2</span>) &#123;            drawCircle();        &#125;    &#125;    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">drawRectangle</span><span class="params">()</span> &#123;        System.out.println(<span class="string">&quot;画长方形&quot;</span>);    &#125;    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">drawCircle</span><span class="params">()</span> &#123;        System.out.println(<span class="string">&quot;画圆形&quot;</span>);    &#125;    <span class="keyword">class</span> <span class="title class_">Shape</span> &#123;        <span class="type">int</span> m_type;    &#125;    <span class="keyword">class</span> <span class="title class_">Rectangle</span> <span class="keyword">extends</span> <span class="title class_">Shape</span> &#123;        Rectangle() &#123;            <span class="built_in">super</span>.m_type=<span class="number">1</span>;        &#125;    &#125;    <span class="keyword">class</span> <span class="title class_">Circle</span> <span class="keyword">extends</span> <span class="title class_">Shape</span> &#123;        Circle() &#123;            <span class="built_in">super</span>.m_type=<span class="number">2</span>;        &#125;    &#125;&#125;</code></pre><p>我们来看看, 这个代码, 初看是符合要求了, 再想想, 要是我增加一种形状呢? 比如增加三角形. </p><ul><li><p>首先, 要增加一个三角形的类, 继承自Shape ;</p></li><li><p>第二, 要增加一个画三角形的方法drawTrriage() ;</p></li><li><p>第三, 在draw方法中增加一种类型type&#x3D;3的处理方案</p></li></ul><p> 这就违背了开闭原则-对扩展开发, 对修改关闭. 增加一个类型, 修改了三处代码.</p><p>我们来看看合适的设计</p><pre><code class="highlight java"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">GraphicEditor1</span> &#123;    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">draw</span><span class="params">(Shape shape)</span> &#123;        shape.draw();    &#125;    <span class="keyword">interface</span> <span class="title class_">Shape</span> &#123;        <span class="keyword">void</span> <span class="title function_">draw</span><span class="params">()</span>;    &#125;    <span class="keyword">class</span> <span class="title class_">Rectangle</span> <span class="keyword">implements</span> <span class="title class_">Shape</span> &#123;        <span class="meta">@Override</span>        <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">draw</span><span class="params">()</span> &#123;            System.out.println(<span class="string">&quot;画矩形&quot;</span>);        &#125;    &#125;    <span class="keyword">class</span> <span class="title class_">Circle</span> <span class="keyword">implements</span> <span class="title class_">Shape</span> &#123;        <span class="meta">@Override</span>        <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">draw</span><span class="params">()</span> &#123;            System.out.println(<span class="string">&quot;画圆形&quot;</span>);        &#125;    &#125;&#125;</code></pre><p>各种类型的形状自己规范自己的行为, 而 <code>GraphicEditor.draw()</code> 只负责画出来. 当增加一种类型三角形. 只需要 </p><ul><li><p>第一: 增加一个三角形的类,实现Shape接口 </p></li><li><p>第二, 调用draw方法,划出来就可以了.</p></li></ul><p>整个过程都是在扩展, 而没有修改原来的类. 这个设计是符合开闭原则的.</p><h3 id="3-2-案例二"><a href="#3-2-案例二" class="headerlink" title="3.2 案例二"></a>3.2 案例二</h3><p>比如现在有一个银行业务, 存钱, 取钱和转账. 最初我们会怎么思考呢?</p><ul><li>首先有一个银行业务类, 用来处理银行的业务</li><li>银行有哪些业务呢? 存钱,取钱,转账, 这都是银行要执行的操作</li><li>那外部说我要存钱, 我要取钱,我要转账, 通过一个类型来告诉我们 代码就生成了</li></ul><pre><code class="highlight java"><span class="comment">/**</span><span class="comment">* 银行业务</span><span class="comment">*/</span><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">BankBusiness</span> &#123;   <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">operate</span><span class="params">(<span class="type">int</span> type)</span> &#123;       <span class="keyword">if</span> (type == <span class="number">1</span>) &#123;           save();       &#125; <span class="keyword">else</span> <span class="keyword">if</span>(type == <span class="number">2</span>) &#123;           take();       &#125; <span class="keyword">else</span> <span class="keyword">if</span>(type == <span class="number">3</span>) &#123;           transfer();       &#125;   &#125;   <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">save</span><span class="params">()</span>&#123;       System.out.println(<span class="string">&quot;存钱&quot;</span>);   &#125;   <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">take</span><span class="params">()</span>&#123;       System.out.println(<span class="string">&quot;取钱&quot;</span>);   &#125;   <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">transfer</span><span class="params">()</span> &#123;       System.out.println(<span class="string">&quot;转账&quot;</span>);   &#125;&#125;</code></pre><p>咋一看已经实现了需求. 但是现在有新的需求来了, 银行要增加功能—理财. 理财是银行业务的一种, 自然是新增一个方法. 然后在operate()方法里增加一种类型. 这就是一个糟糕的设计, 增加新功能, 但是却修改了原来的代码.</p><p>们设计成接口抽象的形式,源码如下：</p><pre><code class="highlight java"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">Business</span> &#123;    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">operate</span><span class="params">()</span>;&#125;<span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Save</span> <span class="keyword">implements</span> <span class="title class_">Business</span>&#123;    <span class="meta">@Override</span>    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">operate</span><span class="params">()</span> &#123;        System.out.println(<span class="string">&quot;存钱业务&quot;</span>);    &#125;&#125;<span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Take</span> <span class="keyword">implements</span> <span class="title class_">Business</span> &#123;    <span class="meta">@Override</span>    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">operate</span><span class="params">()</span> &#123;        System.out.println(<span class="string">&quot;取钱业务&quot;</span>);    &#125;&#125;<span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Transfer</span> <span class="keyword">implements</span> <span class="title class_">Business</span> &#123;    <span class="meta">@Override</span>    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">operate</span><span class="params">()</span> &#123;        System.out.println(<span class="string">&quot;转账业务&quot;</span>);    &#125;&#125;<span class="comment">/**</span><span class="comment"> * 银行业务类</span><span class="comment"> */</span><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">BankBusinesses</span> &#123;    <span class="comment">/**</span><span class="comment">     * 处理银行业务</span><span class="comment">     * <span class="doctag">@param</span> business</span><span class="comment">     */</span>    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">operate</span><span class="params">(Business business)</span> &#123;        System.out.println(<span class="string">&quot;处理银行业务&quot;</span>);        business.operate();    &#125;&#125;</code></pre><p>通过接口抽象的形式方便扩展, 加入要新增理财功能. 只需新增一个理财类, 其他业务代码都不需要修改.</p><p>其实, 在日常工作中, 经常会遇到这种情况. 因为我们平时写业务逻辑会更多一些, 而业务就像流水账, 今天一个明天一个一点一点的增加. 所以,当业务增加到3个的时候, 我们就要思考, 如何写能够方便扩展.</p><p><strong>总结</strong></p><ul><li>遵守开闭原则可以提高软件扩展性和维护性。</li><li>大部分的设计模式和设计原则都是在实现开闭原则。</li></ul><h1 id="七、迪米特法则（Demeter-Principle）"><a href="#七、迪米特法则（Demeter-Principle）" class="headerlink" title="七、迪米特法则（Demeter Principle）"></a>七、迪米特法则（Demeter Principle）</h1><h2 id="1-什么是迪米特法则"><a href="#1-什么是迪米特法则" class="headerlink" title="1. 什么是迪米特法则"></a>1. 什么是迪米特法则</h2><p>迪米特法则(Law of Demeter )又叫做最少知识原则，也就是说，一个对象应当对其他对象尽可能少的了解。不和陌生人说话。英文简写为: LoD。</p><p>迪米特法则的目的在于降低类之间的耦合。由于每个类尽量减少对其他类的依赖，因此，很容易使得系统的功能模块功能独立，相互之间不存在（或很少有）依赖关系。</p><p>迪米特法则不希望类之间建立直接的联系。如果真的有需要建立联系，也希望能通过它的友元类来转达。因此，应用迪米特法则有可能造成的一个后果就是：系统中存在大量的中介类，这些类之所以存在完全是为了传递类之间的相互调用关系——这在一定程度上增加了系统的复杂度。</p><h2 id="2-为什么要遵守迪米特法则"><a href="#2-为什么要遵守迪米特法则" class="headerlink" title="2. 为什么要遵守迪米特法则?"></a>2. 为什么要遵守迪米特法则?</h2><p>在面向对象编程中有一些众所周知的抽象概念，比如封装、内聚和耦合，理论上可以用来生成清晰的设计和良好的代码。虽然这些都是非常重要的概念，但它们不够实用，不能直接用于开发环境，这些概念是比较主观的，非常依赖于使用人的经验和知识。对于其他概念，如单一责任原则、开闭原则等，情况也是一样的。迪米特法则的独特之处在于它简洁而准确的定义，它允许在编写代码时直接应用，几乎自动地应用了适当的封装、低内聚和松耦合。</p><h2 id="3-迪米特法则的广狭义"><a href="#3-迪米特法则的广狭义" class="headerlink" title="3. 迪米特法则的广狭义"></a>3. 迪米特法则的广狭义</h2><h3 id="3-1-狭义的迪米特法则"><a href="#3-1-狭义的迪米特法则" class="headerlink" title="3.1 狭义的迪米特法则"></a>3.1 狭义的迪米特法则</h3><p>如果两个类不必彼此直接通信，那么这两个类就不应当发生直接的相互作用。如果其中的一个类需要调用另一个类的某一个方法的话，可以通过第三者转发这个调用。</p><p><strong>朋友圈的确定“朋友”条件：</strong></p><ul><li><p>当前对象本身（this）</p></li><li><p>以参数形式传入到当前对象方法中的对象.</p><p>方法入参是一个对象, 这时这个对象和当前类是朋友</p></li><li><p>当前对象的实例变量直接引用的对象</p><p>定义一个类, 里面的属性引用了其他对象, 那么引用对象的实例和当前实例是朋友</p></li><li><p>当前对象的实例变量如果是一个聚集，那么聚集中的元素也都是朋友</p><p>如果属性是一个对象, 那么属性和对象里的元素都是朋友</p></li><li><p>当前对象所创建的对象</p></li></ul><p>任何一个对象，如果满足上面的条件之一，就是当前对象的“朋友”；否则就是“陌生人”。</p><p><strong>狭义的迪米特法则的缺点：</strong></p><p>在系统里造出大量的小方法，这些方法仅仅是传递间接的调用，与系统的业务逻辑无关。 遵循类之间的迪米特法则会是一个系统的局部设计简化，因为每一个局部都不会和远距离的对象有直接的关联。但是，这也会造成系统的不同模块之间的通信效率降低，也会使系统的不同模块之间不容易协调。</p><h3 id="3-2-广义的迪米特法则在类的设计上的体现"><a href="#3-2-广义的迪米特法则在类的设计上的体现" class="headerlink" title="3.2 广义的迪米特法则在类的设计上的体现"></a>3.2 广义的迪米特法则在类的设计上的体现</h3><ul><li>优先考虑将一个类设置成不变类。 </li><li>尽量降低一个类的访问权限。  </li><li>谨慎使用Serializable。  </li><li>尽量降低成员的访问权限。</li></ul><h2 id="4-迪米特法则在设计模式中的应用"><a href="#4-迪米特法则在设计模式中的应用" class="headerlink" title="4. 迪米特法则在设计模式中的应用"></a>4. 迪米特法则在设计模式中的应用</h2><p>设计模式的门面模式（Facade）和中介模式（Mediator），都是迪米特法则的应用</p><p>下面我们已经租房为例, 来研究迪米特法则. 通常 客户要找房子住, 我们就直接建一个房子类, 建一个客户类, 客户找房子即可.</p><pre><code class="highlight java"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">IHouse</span> &#123;    <span class="comment">// 住房子</span>    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">Housing</span><span class="params">()</span>;&#125;<span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">House</span> <span class="keyword">implements</span> <span class="title class_">IHouse</span>&#123;    <span class="meta">@Override</span>    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">Housing</span><span class="params">()</span> &#123;        System.out.println(<span class="string">&quot;住房子&quot;</span>);    &#125;&#125;<span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Customer</span> &#123;    <span class="keyword">public</span> String name;    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">findHourse</span><span class="params">(IHouse house)</span> &#123;        house.Housing();    &#125;&#125;</code></pre><p>客户找房子住, 逻辑很简单, 这样是ok的. 虽然违背了迪米特法则, 但符合业务逻辑也说得通. 但是, 通常我们找房子, 不是一下子就能找到的, 我们要找很多家, 这就很费劲, 那不如交给中介. 中介有很多房源, 房东吧房子给了中介, 不需要关心租户是谁, 租户将找房的事交给房东, 他也不用管房东是谁, 而且租户+房东都很省事.</p><pre><code class="highlight java"><span class="comment">/**</span><span class="comment"> * 房子</span><span class="comment"> */</span><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">IHouse</span> &#123;    <span class="comment">// 住房子</span>    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">Housing</span><span class="params">()</span>;&#125;<span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">House</span> <span class="keyword">implements</span> <span class="title class_">IHouse</span>&#123;    <span class="meta">@Override</span>    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">Housing</span><span class="params">()</span> &#123;        System.out.println(<span class="string">&quot;住房子&quot;</span>);    &#125;&#125;<span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">ICustomer</span> &#123;    <span class="keyword">void</span> <span class="title function_">findHourse</span><span class="params">(IHouse house)</span> ;&#125;<span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Customer</span> <span class="keyword">implements</span> <span class="title class_">ICustomer</span> &#123;    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">findHourse</span><span class="params">(IHouse house)</span> &#123;        house.Housing();    &#125;&#125;<span class="comment">/**</span><span class="comment"> * 中介</span><span class="comment"> */</span><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Intermediary</span> &#123;    <span class="comment">// 找房子</span>    <span class="keyword">public</span> IHouse <span class="title function_">findHouse</span><span class="params">(ICustomer customer)</span>&#123;        <span class="comment">// 帮租户找房子</span>        <span class="keyword">return</span> <span class="literal">null</span>;    &#125;&#125;</code></pre><p>房子,客户是相互独立的, 彼此之间没有引用. 他们之间建立关系是通过中介. 也就是, 客户找中介租房子, 房东吧房子交给租户, 最后中介将找好的房子给到客户. 客户和房东彼此隔离, 符合迪米特法则.</p><h2 id="5-迪米特法则实践"><a href="#5-迪米特法则实践" class="headerlink" title="5. 迪米特法则实践"></a>5. 迪米特法则实践</h2><p>那么在实践中如何做到一个对象应该对其他对象有最少的了解呢？如果我们把一个对象看作是一个人，那么要实现“一个人应该对其他人有最少的了解”，做到两点就足够了：</p><ul><li>只和直接的朋友交流；</li><li>减少对朋友的了解。下面就详细说说如何做到这两点。</li></ul><h3 id="5-1-只和直接的朋友交流"><a href="#5-1-只和直接的朋友交流" class="headerlink" title="5.1 只和直接的朋友交流"></a>5.1 只和直接的朋友交流</h3><p>迪米特法则还有一个英文解释是：talk only to your immediate friends（只和直接的朋友交流）。</p><p><strong>什么是朋友呢？</strong></p><p>每个对象都必然会与其他的对象有耦合关系，两个对象之间的耦合就会成为朋友关系。那么什么又是直接的朋友呢？出现在<strong>成员变量</strong>、<strong>方法的输入输出参数</strong>中的类就是直接的朋友。迪米特法则要求只和直接的朋友通信。</p><blockquote><p><strong>注意：</strong><br>只出现在方法体内部的类就不是直接的朋友，如果一个类和不是直接的朋友进行交流，就属于违反迪米特法则。</p></blockquote><p>我们举一个例子说明什么是朋友，什么是直接的朋友。很简单的例子：老师让班长清点全班同学的人数。这个例子中总共有三个类：老师Teacher、班长GroupLeader和学生Student。</p><pre><code class="highlight java"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">ITeacher</span> &#123;    <span class="keyword">void</span> <span class="title function_">command</span><span class="params">(IGroupLeader groupLeader)</span>;&#125;<span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Teacher</span> <span class="keyword">implements</span> <span class="title class_">ITeacher</span>&#123;    <span class="meta">@Override</span>    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">command</span><span class="params">(IGroupLeader groupLeader)</span> &#123;        <span class="comment">// 全班同学</span>        List&lt;Student&gt; allStudent = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();        allStudent.add(<span class="keyword">new</span> <span class="title class_">Student</span>());        allStudent.add(<span class="keyword">new</span> <span class="title class_">Student</span>());        allStudent.add(<span class="keyword">new</span> <span class="title class_">Student</span>());        allStudent.add(<span class="keyword">new</span> <span class="title class_">Student</span>());        allStudent.add(<span class="keyword">new</span> <span class="title class_">Student</span>());        <span class="comment">// 班长清点人数</span>        groupLeader.count(allStudent);    &#125;&#125;** * 班长类 */<span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">IGroupLeader</span> &#123;    <span class="comment">// 班长清点人数</span>    <span class="keyword">void</span> <span class="title function_">count</span><span class="params">(List&lt;Student&gt; students)</span>;&#125;<span class="comment">/**</span><span class="comment"> * 班长类</span><span class="comment"> */</span><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">GroupLeader</span> <span class="keyword">implements</span> <span class="title class_">IGroupLeader</span>&#123;    <span class="comment">/**</span><span class="comment">     * 班长清点人数</span><span class="comment">     * <span class="doctag">@param</span> students</span><span class="comment">     */</span>    <span class="meta">@Override</span>    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">count</span><span class="params">(List&lt;Student&gt; students)</span> &#123;        <span class="comment">// 班长清点人数</span>        System.out.println(<span class="string">&quot;上课的学生人数是: &quot;</span> + students.size());    &#125;&#125;<span class="comment">/**</span><span class="comment"> * 学生类</span><span class="comment"> */</span><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">IStudent</span> &#123;&#125;<span class="comment">/**</span><span class="comment"> * 学生类</span><span class="comment"> */</span><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Student</span> <span class="keyword">implements</span> <span class="title class_">IStudent</span> &#123;&#125;<span class="comment">/**</span><span class="comment"> * 客户端</span><span class="comment"> */</span><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Client</span> &#123;    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;        <span class="comment">// 老师类</span>        <span class="type">ITeacher</span> <span class="variable">wangTeacher</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Teacher</span>();        <span class="comment">// 班长</span>        <span class="type">IGroupLeader</span> <span class="variable">zhangBanzhang</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">GroupLeader</span>();        wangTeacher.command(zhangBanzhang);    &#125;&#125;</code></pre><p>运行结果:</p><pre><code class="highlight shell">上课的学生人数是: 5</code></pre><p>在这个例子中，我们的Teacher有几个朋友？两个，一个是GroupLeader，它是Teacher的command()方法的入参；另一个是Student，因为在Teacher的command()方法体中使用了Student。</p><p>那么Teacher有几个是直接的朋友？按照直接的朋友的定义</p><blockquote><p>出现在成员变量、方法的输入输出参数中的类就是直接的朋友</p></blockquote><p>只有GroupLeader是Teacher的直接的朋友。</p><p>Teacher在command()方法中创建了Student的数组，和非直接的朋友Student发生了交流，所以，上述例子<strong>违反了迪米特法则</strong>。方法是类的一个行为，类竟然不知道自己的行为与其他的类产生了依赖关系，这是不允许的，<strong>严重违反了迪米特法则</strong>！</p><p><strong>为了使上述例子符合迪米特法则，我们可以做如下修改：</strong></p><pre><code class="highlight java"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">ITeacher</span> &#123;    <span class="keyword">void</span> <span class="title function_">command</span><span class="params">(IGroupLeader groupLeader)</span>;&#125;<span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Teacher</span> <span class="keyword">implements</span> <span class="title class_">ITeacher</span> &#123;    <span class="meta">@Override</span>    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">command</span><span class="params">(IGroupLeader groupLeader)</span> &#123;        <span class="comment">// 班长清点人数</span>        groupLeader.count();    &#125;&#125;<span class="comment">/**</span><span class="comment"> * 班长类</span><span class="comment"> */</span><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">IGroupLeader</span> &#123;    <span class="comment">// 班长清点人数</span>    <span class="keyword">void</span> <span class="title function_">count</span><span class="params">()</span>;&#125;<span class="comment">/**</span><span class="comment"> * 班长类</span><span class="comment"> */</span><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">GroupLeader</span> <span class="keyword">implements</span> <span class="title class_">IGroupLeader</span> &#123;    <span class="keyword">private</span> List&lt;Student&gt; students;    <span class="keyword">public</span> <span class="title function_">GroupLeader</span><span class="params">(List&lt;Student&gt; students)</span> &#123;        <span class="built_in">this</span>.students = students;    &#125;    <span class="comment">/**</span><span class="comment">     * 班长清点人数</span><span class="comment">     */</span>    <span class="meta">@Override</span>    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">count</span><span class="params">()</span> &#123;        <span class="comment">// 班长清点人数</span>        System.out.println(<span class="string">&quot;上课的学生人数是: &quot;</span> + students.size());    &#125;&#125;<span class="comment">/**</span><span class="comment"> * 学生类</span><span class="comment"> */</span><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">IStudent</span> &#123;&#125;<span class="comment">/**</span><span class="comment"> * 学生类</span><span class="comment"> */</span><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Student</span> <span class="keyword">implements</span> <span class="title class_">IStudent</span> &#123;&#125;<span class="comment">/**</span><span class="comment"> * 客户端</span><span class="comment"> */</span><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Client</span> &#123;    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;        <span class="comment">// 老师类</span>        <span class="type">ITeacher</span> <span class="variable">wangTeacher</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Teacher</span>();        List&lt;Student&gt; allStudent = <span class="keyword">new</span> <span class="title class_">ArrayList</span>(<span class="number">10</span>);        allStudent.add(<span class="keyword">new</span> <span class="title class_">Student</span>());        allStudent.add(<span class="keyword">new</span> <span class="title class_">Student</span>());        allStudent.add(<span class="keyword">new</span> <span class="title class_">Student</span>());        allStudent.add(<span class="keyword">new</span> <span class="title class_">Student</span>());        <span class="comment">// 班长</span>        <span class="type">IGroupLeader</span> <span class="variable">zhangBanzhang</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">GroupLeader</span>(allStudent);        wangTeacher.command(zhangBanzhang);    &#125;&#125;</code></pre><p>运行结果: </p><pre><code class="highlight shell">上课的学生人数是: 4</code></pre><p>这样修改后，每个类都只和直接的朋友交流，有效减少了类之间的耦合</p><h3 id="5-2-减少对朋友的了解"><a href="#5-2-减少对朋友的了解" class="headerlink" title="5.2 减少对朋友的了解"></a>5.2 减少对朋友的了解</h3><p>如何减少对朋友的了解？即：<strong>在一个类中，就是尽量减少一个类对外暴露的方法</strong></p><p>举一个简单的例子说明一个类暴露方法过多的情况。一个人用咖啡机煮咖啡的过程，例子中只有两个类，一个是人，一个是咖啡机。</p><p>首先是咖啡机类CoffeeMachine，咖啡机制作咖啡只需要三个方法：1.加咖啡豆；2.加水；3.制作咖啡：</p><pre><code class="highlight java"><span class="comment">/**</span><span class="comment"> * 咖啡机抽象接口</span><span class="comment"> */</span><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">ICoffeeMachine</span> &#123;    <span class="comment">//加咖啡豆</span>    <span class="keyword">void</span> <span class="title function_">addCoffeeBean</span><span class="params">()</span>;    <span class="comment">//加水</span>    <span class="keyword">void</span> <span class="title function_">addWater</span><span class="params">()</span>;    <span class="comment">//制作咖啡</span>    <span class="keyword">void</span> <span class="title function_">makeCoffee</span><span class="params">()</span>;&#125;<span class="comment">/**</span><span class="comment"> * 咖啡机实现类</span><span class="comment"> */</span><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">CoffeeMachine</span> <span class="keyword">implements</span> <span class="title class_">ICoffeeMachine</span>&#123;    <span class="comment">//加咖啡豆</span>    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">addCoffeeBean</span><span class="params">()</span> &#123;        System.out.println(<span class="string">&quot;放咖啡豆&quot;</span>);    &#125;    <span class="comment">//加水</span>    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">addWater</span><span class="params">()</span> &#123;        System.out.println(<span class="string">&quot;加水&quot;</span>);    &#125;    <span class="comment">//制作咖啡</span>    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">makeCoffee</span><span class="params">()</span> &#123;        System.out.println(<span class="string">&quot;制作咖啡&quot;</span>);    &#125;&#125;<span class="comment">/**</span><span class="comment"> * 人, 制作咖啡</span><span class="comment"> */</span><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">IMan</span> &#123;    <span class="comment">/**</span><span class="comment">     * 制作咖啡</span><span class="comment">     */</span>    <span class="keyword">void</span> <span class="title function_">makeCoffee</span><span class="params">()</span>;&#125;<span class="comment">/**</span><span class="comment"> * 人制作咖啡</span><span class="comment"> */</span><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Man</span> <span class="keyword">implements</span> <span class="title class_">IMan</span> &#123;    <span class="keyword">private</span> ICoffeeMachine coffeeMachine;    <span class="keyword">public</span> <span class="title function_">Man</span><span class="params">(ICoffeeMachine coffeeMachine)</span> &#123;        <span class="built_in">this</span>.coffeeMachine = coffeeMachine;    &#125;    <span class="comment">/**</span><span class="comment">     * 制作咖啡</span><span class="comment">     */</span>    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">makeCoffee</span><span class="params">()</span> &#123;        coffeeMachine.addWater();        coffeeMachine.addCoffeeBean();        coffeeMachine.makeCoffee();    &#125;&#125;<span class="comment">/**</span><span class="comment"> * 客户端</span><span class="comment"> */</span><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Client</span> &#123;    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;        <span class="type">ICoffeeMachine</span> <span class="variable">coffeeMachine</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">CoffeeMachine</span>();        <span class="type">IMan</span> <span class="variable">man</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Man</span>(coffeeMachine);        man.makeCoffee();    &#125;&#125;</code></pre><p>运行结果:</p><pre><code class="highlight shell">加水放咖啡豆制作咖啡</code></pre><p>在这个例子中，CoffeeMachine是Man的直接好友，但问题是Man对CoffeeMachine了解的太多了，其实人根本不关心咖啡机具体制作咖啡的过程。所以我们可以作如下优化：</p><p>优化后的咖啡机类，只暴露一个work方法，把制作咖啡的三个具体的方法addCoffeeBean、addWater、makeCoffee设为私有.</p><pre><code class="highlight java"><span class="comment">/**</span><span class="comment"> * 咖啡机抽象接口</span><span class="comment"> */</span><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">ICoffeeMachine</span> &#123;    <span class="comment">//咖啡机工作</span>    <span class="keyword">void</span> <span class="title function_">work</span><span class="params">()</span>;&#125;<span class="comment">/**</span><span class="comment"> * 咖啡机实现类</span><span class="comment"> */</span><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">CoffeeMachine</span> <span class="keyword">implements</span> <span class="title class_">ICoffeeMachine</span> &#123;    <span class="comment">//加咖啡豆</span>    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">addCoffeeBean</span><span class="params">()</span> &#123;        System.out.println(<span class="string">&quot;放咖啡豆&quot;</span>);    &#125;    <span class="comment">//加水</span>    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">addWater</span><span class="params">()</span> &#123;        System.out.println(<span class="string">&quot;加水&quot;</span>);    &#125;    <span class="comment">//制作咖啡</span>    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">makeCoffee</span><span class="params">()</span> &#123;        System.out.println(<span class="string">&quot;制作咖啡&quot;</span>);    &#125;    <span class="meta">@Override</span>    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">work</span><span class="params">()</span> &#123;        addCoffeeBean();        addWater();        makeCoffee();    &#125;&#125;<span class="comment">/**</span><span class="comment"> * 人, 制作咖啡</span><span class="comment"> */</span><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">IMan</span> &#123;    <span class="comment">/**</span><span class="comment">     * 制作咖啡</span><span class="comment">     */</span>    <span class="keyword">void</span> <span class="title function_">makeCoffee</span><span class="params">()</span>;&#125;<span class="comment">/**</span><span class="comment"> * 人制作咖啡</span><span class="comment"> */</span><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Man</span> <span class="keyword">implements</span> <span class="title class_">IMan</span> &#123;    <span class="keyword">private</span> ICoffeeMachine coffeeMachine;    <span class="keyword">public</span> <span class="title function_">Man</span><span class="params">(ICoffeeMachine coffeeMachine)</span> &#123;        <span class="built_in">this</span>.coffeeMachine = coffeeMachine;    &#125;    <span class="comment">/**</span><span class="comment">     * 制作咖啡</span><span class="comment">     */</span>    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">makeCoffee</span><span class="params">()</span> &#123;        coffeeMachine.work();    &#125;&#125;<span class="comment">/**</span><span class="comment"> * 客户端</span><span class="comment"> */</span><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Client</span> &#123;    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;        <span class="type">ICoffeeMachine</span> <span class="variable">coffeeMachine</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">CoffeeMachine</span>();        <span class="type">IMan</span> <span class="variable">man</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Man</span>(coffeeMachine);        man.makeCoffee();    &#125;&#125;</code></pre><p>这样修改后，通过减少CoffeeMachine对外暴露的方法，减少Man对CoffeeMachine的了解，从而降低了它们之间的耦合。</p><p><strong>注意事项</strong></p><ul><li><p>第一：在类的划分上，应当创建弱耦合的类，类与类之间的耦合越弱，就越有利于实现可复用的目标。 </p></li><li><p>第二：在类的结构设计上，每个类都应该降低成员的访问权限。 </p></li><li><p>第三：在类的设计上，只要有可能，一个类应当设计成不变的类。 </p></li><li><p>第四：在对其他类的引用上，一个对象对其他类的对象的引用应该降到最低。 </p></li><li><p>第五：尽量限制局部变量的有效范围，降低类的访问权限。</p></li></ul><p>参考链接</p><blockquote><p><a href="https://juejin.cn/column/6966429007785459749">https://juejin.cn/column/6966429007785459749</a></p></blockquote>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;一、设计模式的目的&quot;&gt;&lt;a href=&quot;#一、设计模式的目的&quot; class=&quot;headerlink&quot; title=&quot;一、设计模式的目的&quot;&gt;&lt;/a&gt;一、设计模式的目的&lt;/h1&gt;&lt;p&gt;编写软件过程中，程序员面临着来自&lt;strong&gt;耦合性&lt;/strong&gt;，&lt;stro</summary>
      
    
    
    
    <category term="设计模式" scheme="https://georgechan95.github.io/categories/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"/>
    
    
    <category term="设计模式" scheme="https://georgechan95.github.io/tags/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"/>
    
    <category term="java" scheme="https://georgechan95.github.io/tags/java/"/>
    
  </entry>
  
  <entry>
    <title>13-JUC进阶-ReentrantReadWriteLock与StampedLock</title>
    <link href="https://georgechan95.github.io/blog/1a649f4c.html"/>
    <id>https://georgechan95.github.io/blog/1a649f4c.html</id>
    <published>2024-10-19T01:26:00.000Z</published>
    <updated>2024-10-19T08:52:05.976Z</updated>
    
    <content type="html"><![CDATA[<h1 id="一、锁的演变"><a href="#一、锁的演变" class="headerlink" title="一、锁的演变"></a>一、锁的演变</h1><p>无锁  –&gt; 独占锁  –&gt; 读写锁  –&gt; 邮戳锁</p><ul><li><p>无锁：存在线程安全问题</p></li><li><p>独占锁（synchronized，ReentrantLock）</p><p>同一时刻只能有一个线程访问，在读多写少的场景下，效率并不高。</p></li><li><p>读写锁（ReentrantReadWriteLock）</p><p> 适应在多读写少的场景下，读锁可以被线程共享(<strong>共享锁</strong>)，写锁只能有一个线程获取(<strong>排它锁</strong>)。读的时候不允许写，写的时候不允许读。</p><ul><li>读写锁的缺点<ul><li>写锁饥饿问题</li><li>锁降级问题</li></ul></li></ul></li><li><p>邮戳锁（StampedLock）</p><p>是对ReentrantReadWriteLock读写锁的一种改进，主要的改进为：在没有写只有读的场景下，StampedLock支持不用加读锁而是直接进行读操作，最大程度提升读的效率，只有在发生过写操作之后，再加读锁才能进行读操作</p></li></ul><h1 id="二、ReentrantReadWriteLock"><a href="#二、ReentrantReadWriteLock" class="headerlink" title="二、ReentrantReadWriteLock"></a>二、ReentrantReadWriteLock</h1><p>关于读写锁的原理和锁降级，参考博客：<a href="https://georgechan95.github.io/blog/850dac3c.html">https://georgechan95.github.io/blog/850dac3c.html</a></p><h1 id="三、邮戳锁"><a href="#三、邮戳锁" class="headerlink" title="三、邮戳锁"></a>三、邮戳锁</h1><h2 id="1-StampedLock简介"><a href="#1-StampedLock简介" class="headerlink" title="1. StampedLock简介"></a>1. StampedLock简介</h2><p><code>StampedLock</code> 是JUC并发包里面 JDK8 版本新增的一个锁，是读写锁的一种具体实现，和 <code>ReentrantReadWriteLock</code> 不同的是其不提供可重入性，不基于某个类似<code>Lock</code> 或者 <code>ReadWriteLock</code> 接口实现,而是基于CLH锁思想实现这点这AQS有些类似，并且 <code>StampedLock</code> 不支持条件变量 <code>Condition</code> 。</p><h3 id="1-1-StampedLock-三个主要的锁模式"><a href="#1-1-StampedLock-三个主要的锁模式" class="headerlink" title="1.1 StampedLock 三个主要的锁模式"></a>1.1 StampedLock 三个主要的锁模式</h3><ul><li><p><strong>写锁模式（writeLock()）</strong></p><p>用于排他性地写操作。在写锁模式下，其他线程既无法获取读锁，也无法获取写锁。</p></li><li><p><strong>乐观读锁模式（tryOptimisticRead()）</strong></p><p>允许线程进行读操作而不获取读锁，这种模式假设在读操作过程中数据不会被其他线程修改。如果发现数据被修改，可以重新获取悲观读锁以保证数据一致性。</p></li><li><p><strong>悲观读锁模式（readLock()）</strong></p><p>类似于 ReadWriteLock 的读锁，允许多个线程同时获取读锁，但无法与写锁共存。</p></li></ul><h3 id="1-2-戳记"><a href="#1-2-戳记" class="headerlink" title="1.2 戳记"></a>1.2 戳记</h3><p>戳记（stamp） 是 StampedLock 的关键，表示当前锁的状态。获取锁时返回的戳记值在后续的锁操作中用于验证锁的有效性，确保在锁的释放或转换操作中锁的状态是正确的。使用戳记有助于减少锁的争用和开销， StampedLock 通过提供乐观读锁在多线程多读的情况下提供了更好的性能，这是因为获取乐观读锁时不需要进行 CAS 操作设置锁的状态，而只是简单地测试状态。</p><h3 id="1-3-获取锁和释放锁的方法"><a href="#1-3-获取锁和释放锁的方法" class="headerlink" title="1.3 获取锁和释放锁的方法"></a>1.3 获取锁和释放锁的方法</h3><ul><li>获取锁：<ul><li><code>tryOptimisticRead()</code>: 获取乐观读锁，返回戳记。</li><li><code>readLock()</code>: 获取悲观读锁，返回戳记</li><li><code>writeLock()</code>: 获取写锁，返回戳记。</li></ul></li><li>释放锁：<ul><li><code>unlockRead(stamp)</code>: 释放读锁（悲观读锁或乐观读锁）。</li><li><code>unlockWrite(stamp)</code>: 释放写锁。</li></ul></li><li>转换锁：<ul><li><code>tryConvertToWriteLock(long stamp)</code>：尝试将当前持有的锁转换为写锁</li><li><code>tryConvertToReadLock(long stamp)</code>：尝试将当前持有的写锁转换为读锁</li><li><code>tryConvertToOptimisticRead(long stamp)</code>：尝试将当前持有的悲观读锁转换为乐观读锁</li></ul></li></ul><p>可以看出<code>tryConvertToWriteLock</code> 方法表明 <code>StampedLock</code> 支持锁升级，这也是和<code>ReentrantReadWriteLock</code> 不同的点</p><h3 id="1-4-并发度比较"><a href="#1-4-并发度比较" class="headerlink" title="1.4 并发度比较"></a>1.4 并发度比较</h3><table><thead><tr><th align="left">锁</th><th align="left">并发度</th></tr></thead><tbody><tr><td align="left">ReentrantLock</td><td align="left">读读互斥，读写互斥，写写互斥</td></tr><tr><td align="left">ReentrantReadWriteLock</td><td align="left">读读不互斥、读写互斥、写写互斥</td></tr><tr><td align="left">StampedLock</td><td align="left">读读不互斥、读写不互斥、写写互斥</td></tr></tbody></table><p>上面对于StampedLock 的读写不互斥是指 乐观读和写，而不是悲观读和写。</p><p>乐观读的思想和数据库中MVCC（Multi-Version Concurrency Control，多版本并发控制）有点类似。</p><h2 id="2-StampedLock简单使用示例"><a href="#2-StampedLock简单使用示例" class="headerlink" title="2. StampedLock简单使用示例"></a>2. StampedLock简单使用示例</h2><h3 id="2-1-示例代码"><a href="#2-1-示例代码" class="headerlink" title="2.1 示例代码"></a>2.1 示例代码</h3><pre><code class="highlight java"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">TestStampedLock</span> &#123;    <span class="comment">// 声明邮戳锁</span>    <span class="keyword">private</span> <span class="type">StampedLock</span> <span class="variable">lock</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">StampedLock</span>();    <span class="keyword">private</span> <span class="keyword">volatile</span> <span class="type">int</span> <span class="variable">num</span> <span class="operator">=</span> <span class="number">10</span>;    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> InterruptedException &#123;        <span class="type">TestStampedLock</span> <span class="variable">test</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">TestStampedLock</span>();        <span class="type">Runnable</span> <span class="variable">readRun</span> <span class="operator">=</span> () -&gt; test.read();        <span class="type">Runnable</span> <span class="variable">writeRun</span> <span class="operator">=</span> () -&gt; test.write(<span class="number">5</span>);        <span class="comment">// 读数据线程</span>        <span class="type">Thread</span> <span class="variable">thread1</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Thread</span>(readRun, <span class="string">&quot;thread1&quot;</span>);        <span class="comment">// 写数据线程</span>        <span class="type">Thread</span> <span class="variable">thread2</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Thread</span>(writeRun, <span class="string">&quot;thread2&quot;</span>);        <span class="comment">// 读数据线程</span>        <span class="type">Thread</span> <span class="variable">thread3</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Thread</span>(readRun, <span class="string">&quot;thread3&quot;</span>);        thread1.start();        thread2.start();        thread3.start();        <span class="keyword">try</span> &#123;            thread1.join();            thread1.join();            thread1.join();        &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;            Thread.currentThread().interrupt();        &#125;    &#125;    <span class="comment">/**</span><span class="comment">     * 读数据</span><span class="comment">     */</span>    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">read</span><span class="params">()</span> &#123;        <span class="type">long</span> <span class="variable">stamp</span> <span class="operator">=</span> lock.tryOptimisticRead();        <span class="keyword">try</span> &#123;            System.out.println(Thread.currentThread().getName() + <span class="string">&quot;开始读数据&quot;</span>);            <span class="comment">// 初次尝试乐观读</span>            <span class="type">int</span> <span class="variable">currentNum</span> <span class="operator">=</span> num;            <span class="comment">// 模拟读取时间延迟</span>            TimeUnit.MILLISECONDS.sleep(<span class="number">300</span>);            <span class="keyword">if</span> (!lock.validate(stamp)) &#123;                <span class="comment">// 乐观读失败，开始悲观读</span>                stamp = lock.readLock();                <span class="keyword">try</span> &#123;                    <span class="comment">// 再次读取内容</span>                    currentNum = num;                &#125; <span class="keyword">finally</span> &#123;                    <span class="comment">// 释放悲观读</span>                    lock.unlockRead(stamp);                &#125;            &#125;            System.out.println(Thread.currentThread().getName() + <span class="string">&quot;读取到的数值：&quot;</span> + currentNum);        &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;            System.out.println(Thread.currentThread().getName() + <span class="string">&quot; 发生异常，异常消息：&quot;</span> + e.getMessage());            <span class="comment">// 终端线程执行</span>            Thread.currentThread().interrupt();        &#125;    &#125;    <span class="comment">/**</span><span class="comment">     * 写数据</span><span class="comment">     * <span class="doctag">@param</span> number</span><span class="comment">     */</span>    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">write</span><span class="params">(<span class="type">int</span> number)</span> &#123;        <span class="type">long</span> <span class="variable">stamp</span> <span class="operator">=</span> lock.writeLock();        <span class="keyword">try</span> &#123;            System.out.println(Thread.currentThread().getName() + <span class="string">&quot;开始写数据&quot;</span>);            num += number;            System.out.println(Thread.currentThread().getName() + <span class="string">&quot;将数据写为：&quot;</span> + num);        &#125; <span class="keyword">finally</span> &#123;            lock.unlockWrite(stamp);        &#125;    &#125;&#125;</code></pre><blockquote><p>运行结果</p></blockquote><pre><code class="highlight shell">thread1开始读数据thread3开始读数据thread2开始写数据thread2将数据写为：15thread3读取到的数值：15thread1读取到的数值：15</code></pre><p>需要注意的点就是，<code>lock.tryOptimisticRead();</code> 获取悲观锁方法并不真正获取锁，而是假设在读操作期间数据不会被修改。使用戳记来验证数据是否在读操作期间被修改，必要时需要升级为悲观读锁来保证数据一致性。</p><h3 id="2-2-使用乐观读锁需要遵循一定的规则："><a href="#2-2-使用乐观读锁需要遵循一定的规则：" class="headerlink" title="2.2 使用乐观读锁需要遵循一定的规则："></a>2.2 使用乐观读锁需要遵循一定的规则：</h3><p>比如 <code>read()</code> 方法中获取 <code>num</code> 的时候需要遵循下面几个步骤：<br>并且一定要按照下面几个步骤顺序处理。</p><ul><li><p><strong>乐观读操作：</strong></p><p>先尝试使用 <code>tryOptimisticRead()</code> 获取乐观读锁。此时不持有实际的读锁，仅仅假设数据在读取期间不会被修改。进行乐观读操作，相当于把共享变量读取到线程的栈内存，这一步很重要需要在验证之前执行。</p></li><li><p><strong>验证和转换：</strong></p><p>使用 <code>validate(stamp)</code> 检查在乐观读期间数据是否被修改。如果数据未被修改，读取的结果就是可靠的。如果数据被修改，需要使用 <code>readLock()</code> 获取悲观读锁，再进行一遍悲观读取操作来确保数据的一致性。</p></li><li><p><strong>释放锁：</strong></p><p>如果获取了悲观读锁，必须在读操作完成后使用 <code>unlockRead(stamp)</code> 释放锁。</p></li></ul><pre><code class="highlight java"><span class="comment">/**</span><span class="comment"> * 读数据</span><span class="comment"> */</span><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">read</span><span class="params">()</span> &#123;    <span class="type">long</span> <span class="variable">stamp</span> <span class="operator">=</span> lock.tryOptimisticRead();    <span class="keyword">try</span> &#123;        System.out.println(Thread.currentThread().getName() + <span class="string">&quot;开始读数据&quot;</span>);        <span class="comment">// 初次尝试乐观读</span>        <span class="type">int</span> <span class="variable">currentNum</span> <span class="operator">=</span> num;        <span class="comment">// 模拟读取时间延迟</span>        TimeUnit.MILLISECONDS.sleep(<span class="number">300</span>);        <span class="keyword">if</span> (!lock.validate(stamp)) &#123;            <span class="comment">// 乐观读失败，开始悲观读</span>            stamp = lock.readLock();            <span class="keyword">try</span> &#123;                <span class="comment">// 再次读取内容</span>                currentNum = num;            &#125; <span class="keyword">finally</span> &#123;                <span class="comment">// 释放悲观读</span>                lock.unlockRead(stamp);            &#125;        &#125;        System.out.println(Thread.currentThread().getName() + <span class="string">&quot;读取到的数值：&quot;</span> + currentNum);    &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;        System.out.println(Thread.currentThread().getName() + <span class="string">&quot; 发生异常，异常消息：&quot;</span> + e.getMessage());        <span class="comment">// 终端线程执行</span>        Thread.currentThread().interrupt();    &#125;&#125;</code></pre><p>使用乐观锁、悲观锁思想也是 <code>StampedLock</code> 提升读取性能的一个方式。因为<code>tryOptimisticRead</code> 和 <code>validate</code> 这两个方法都比悲观读锁的CAS操作要快。</p><h3 id="2-3-validate方法的注意点"><a href="#2-3-validate方法的注意点" class="headerlink" title="2.3 validate方法的注意点"></a>2.3 <code>validate</code>方法的注意点</h3><p>由于乐观读操作对顺序要求很严格，并且乐观读返回的是普通long类型变量，所以为了防止重排序，在validate方法中使用了读屏障（ <code>U.loadFence();</code>） 确保在屏障之前的所有读操作在屏障之后的读操作之前完成。这意味着，<code>U.loadFence(</code>) 保证了在它之前的内存读取操作不会被重新排序到它之后。</p><p><code>StampedLock</code> 中的 <code>state</code> 变量是<code>volatile</code>修饰的，但是<code>validate</code>方法的入参<code>stamp</code>并不能保证是 <code>volatile</code> 变量，所以需要加个读屏障，确保 <code>stamp</code> 和 <code>state</code> 的读取操作不会被重排序，从而保证 <code>stamp</code> 的有效性检查是准确的。如果不使用读屏障，可能会出现 <code>stamp</code> 和 <code>state</code> 的读取操作被重排序的情况，这可能导致 <code>validate</code> 方法返回不正确的结果。</p><pre><code class="highlight java"><span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">validate</span><span class="params">(<span class="type">long</span> stamp)</span> &#123;    U.loadFence();    <span class="keyword">return</span> (stamp &amp; SBITS) == (state &amp; SBITS);&#125;</code></pre><h2 id="3-StampedLock获取释放锁详解"><a href="#3-StampedLock获取释放锁详解" class="headerlink" title="3. StampedLock获取释放锁详解"></a>3. StampedLock获取释放锁详解</h2><h3 id="3-1-类继承结构"><a href="#3-1-类继承结构" class="headerlink" title="3.1 类继承结构"></a>3.1 类继承结构</h3><p><img src="https://raw.githubusercontent.com/GeorgeChan95/blogimg/master/img/2024/10/19/20241019-154603.png" alt="类继承结构"></p><pre><code class="highlight java"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">StampedLock</span> <span class="keyword">implements</span> <span class="title class_">java</span>.io.Serializable</code></pre><h3 id="3-2-类属性"><a href="#3-2-类属性" class="headerlink" title="3.2 类属性"></a>3.2 类属性</h3><pre><code class="highlight java"><span class="comment">/** CPU 核心数，用于自旋控制 */</span><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">int</span> <span class="variable">NCPU</span> <span class="operator">=</span> Runtime.getRuntime().availableProcessors();<span class="comment">/** 尝试获取锁时的最大自旋次数。自旋是指在短时间内反复检查锁状态，而不是立即阻塞线程。 */</span><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">int</span> <span class="variable">SPINS</span> <span class="operator">=</span> (NCPU &gt; <span class="number">1</span>) ? <span class="number">1</span> &lt;&lt; <span class="number">6</span> : <span class="number">0</span>;<span class="comment">/** 尝试获取锁时，最大自旋次数，超出此值后会尝试阻塞在队列的头部。 */</span><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">int</span> <span class="variable">HEAD_SPINS</span> <span class="operator">=</span> (NCPU &gt; <span class="number">1</span>) ? <span class="number">1</span> &lt;&lt; <span class="number">10</span> : <span class="number">0</span>;<span class="comment">/** 自旋时的最大重试次数，超出此值后会重新尝试阻塞。 */</span><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">int</span> <span class="variable">MAX_HEAD_SPINS</span> <span class="operator">=</span> (NCPU &gt; <span class="number">1</span>) ? <span class="number">1</span> &lt;&lt; <span class="number">16</span> : <span class="number">0</span>;<span class="comment">/** 等待溢出自旋锁时的放弃 CPU 使用的周期。这是一个幂次 2 - 1 的值。 */</span><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">int</span> <span class="variable">OVERFLOW_YIELD_RATE</span> <span class="operator">=</span> <span class="number">7</span>; <span class="comment">// 必须是 2 的幂次 - 1</span><span class="comment">/** 用于表示读锁计数的位数，超出此范围会发生溢出。  范围是1~126  */</span><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">int</span> <span class="variable">LG_READERS</span> <span class="operator">=</span> <span class="number">7</span>;<span class="comment">/** 锁状态和印章操作的相关常量值 */</span><span class="comment">// 单位读操作的位掩码</span><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">long</span> <span class="variable">RUNIT</span> <span class="operator">=</span> <span class="number">1L</span>;<span class="comment">// 写操作的位掩码（位移了 LG_READERS 位）</span><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">long</span> <span class="variable">WBIT</span>  <span class="operator">=</span> <span class="number">1L</span> &lt;&lt; LG_READERS;<span class="comment">// 读操作的位掩码范围</span><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">long</span> <span class="variable">RBITS</span> <span class="operator">=</span> WBIT - <span class="number">1L</span>;<span class="comment">// 读操作的满位掩码</span><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">long</span> <span class="variable">RFULL</span> <span class="operator">=</span> RBITS - <span class="number">1L</span>;<span class="comment">// 所有锁的位掩码（包括读和写）</span><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">long</span> <span class="variable">ABITS</span> <span class="operator">=</span> RBITS | WBIT;<span class="comment">// 只有写锁的位掩码 ( ~ 是按位取反操作符)</span><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">long</span> <span class="variable">SBITS</span> <span class="operator">=</span> ~RBITS; <span class="comment">// 注意与 ABITS 的重叠</span><span class="comment">// 锁状态的初始值; 避免零值作为失败值</span><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">long</span> <span class="variable">ORIGIN</span> <span class="operator">=</span> WBIT &lt;&lt; <span class="number">1</span>;<span class="comment">/** 从被取消的获取方法返回的特殊值，用于抛出中断异常。 */</span><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">long</span> <span class="variable">INTERRUPTED</span> <span class="operator">=</span> <span class="number">1L</span>;<span class="comment">/** 节点状态的相关常量值，顺序很重要 */</span><span class="comment">// 等待状态</span><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">int</span> <span class="variable">WAITING</span>   <span class="operator">=</span> -<span class="number">1</span>;<span class="comment">// 取消状态</span><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">int</span> <span class="variable">CANCELLED</span> <span class="operator">=</span>  <span class="number">1</span>;<span class="comment">/** 节点模式; 用整数而不是布尔值，以允许进行算术操作 */</span><span class="comment">// 读模式</span><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">int</span> <span class="variable">RMODE</span> <span class="operator">=</span> <span class="number">0</span>;<span class="comment">// 写模式</span><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">int</span> <span class="variable">WMODE</span> <span class="operator">=</span> <span class="number">1</span>;<span class="comment">/** 等待节点的内部类，用于管理队列中的节点 */</span><span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">class</span> <span class="title class_">WNode</span> &#123;    <span class="keyword">volatile</span> WNode prev;    <span class="comment">// 上一个节点</span>    <span class="keyword">volatile</span> WNode next;    <span class="comment">// 下一个节点</span>    <span class="keyword">volatile</span> WNode cowait;  <span class="comment">// 链接的读线程列表</span>    <span class="keyword">volatile</span> Thread thread; <span class="comment">// 线程对象; 如果非空，则线程可能被挂起</span>    <span class="keyword">volatile</span> <span class="type">int</span> status;    <span class="comment">// 节点状态; 0, WAITING 或 CANCELLED</span>    <span class="keyword">final</span> <span class="type">int</span> mode;         <span class="comment">// 节点模式; RMODE 或 WMODE</span>    WNode(<span class="type">int</span> m, WNode p) &#123; mode = m; prev = p; &#125;&#125;<span class="comment">/** CLH 队列的头部节点 */</span><span class="keyword">private</span> <span class="keyword">transient</span> <span class="keyword">volatile</span> WNode whead;<span class="comment">/** CLH 队列的尾部节点 */</span><span class="keyword">private</span> <span class="keyword">transient</span> <span class="keyword">volatile</span> WNode wtail;<span class="comment">/** 锁视图，用于提供不同类型的锁视图 */</span><span class="keyword">transient</span> ReadLockView readLockView;<span class="keyword">transient</span> WriteLockView writeLockView;<span class="keyword">transient</span> ReadWriteLockView readWriteLockView;<span class="comment">/** 锁的状态*/</span><span class="keyword">private</span> <span class="keyword">transient</span> <span class="keyword">volatile</span> <span class="type">long</span> state;<span class="comment">/** 当状态的读计数饱和时，所使用的额外读锁计数 */</span><span class="keyword">private</span> <span class="keyword">transient</span> <span class="type">int</span> readerOverflow;</code></pre><p>可以看出<code>StampedLock</code>是通过内部类 <code>WNode</code> 来管理队列中的节点(队列属于双向链表结构，利用了CLH锁思想)。并且用了大量的标志位和位运算来处理锁的逻辑。</p><h3 id="3-3-StampedLock对于state变量的设计"><a href="#3-3-StampedLock对于state变量的设计" class="headerlink" title="3.3 StampedLock对于state变量的设计"></a>3.3 StampedLock对于state变量的设计</h3><pre><code class="highlight java"><span class="comment">/** 用于表示读锁计数的位数，超出此范围会发生溢出。  范围是1~126  */</span><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">int</span> <span class="variable">LG_READERS</span> <span class="operator">=</span> <span class="number">7</span>;<span class="comment">// 写操作的位掩码（位移了 LG_READERS 位）</span><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">long</span> <span class="variable">WBIT</span>  <span class="operator">=</span> <span class="number">1L</span> &lt;&lt; LG_READERS;<span class="comment">// 锁状态的初始值; 避免零值作为失败值</span><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">long</span> <span class="variable">ORIGIN</span> <span class="operator">=</span> WBIT &lt;&lt; <span class="number">1</span>;<span class="comment">/** 锁的状态*/</span><span class="keyword">private</span> <span class="keyword">transient</span> <span class="keyword">volatile</span> <span class="type">long</span> state;</code></pre><p>由于只有一个<code>state</code>变量，又需要表示读写锁，所以<code>StampedLock</code>也把state变量拆成了读和写的部分，但是不同于 <code>ReentrantReadWriteLock</code>的int类型的state变量把高16位表示读锁计数，低16位表示写锁计数。</p><p><code>StampedLock</code>中 锁状态的初始值是 <code>ORIGIN</code> 也就是 1&lt;&lt;7,也就是 <code>1000 0000</code>（前面的0省略）用最低的8位表示读和写的状态，其中最低的7位表示读锁的状态(版本)，第8位表示写锁的状态。因为写锁是互斥的且不可重入，用一位就够了。</p><h3 id="3-4-StampedLock乐观锁实现原理"><a href="#3-4-StampedLock乐观锁实现原理" class="headerlink" title="3.4 StampedLock乐观锁实现原理"></a>3.4 StampedLock乐观锁实现原理</h3><p>结合<code>tryOptimisticRead</code>和<code>validate</code>方法分析：</p><pre><code class="highlight java"><span class="keyword">public</span> <span class="type">long</span> <span class="title function_">tryOptimisticRead</span><span class="params">()</span> &#123;    <span class="type">long</span> s;    <span class="keyword">return</span> (((s = state) &amp; WBIT) == <span class="number">0L</span>) ? (s &amp; SBITS) : <span class="number">0L</span>;&#125;</code></pre><pre><code class="highlight java"><span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">validate</span><span class="params">(<span class="type">long</span> stamp)</span> &#123;    U.loadFence();    <span class="keyword">return</span> (stamp &amp; SBITS) == (state &amp; SBITS);&#125;</code></pre><p><code>tryOptimisticRead</code> 方法中 <code>state&amp;WBIT！=0</code>，说明 <code>state</code> 变量表示写锁的第八位为1，也就是有线程持有写锁，那么 <code>tryOptimisticRead</code> 方法就会返回0。表示获取乐观读锁失败。然后我们再调用 <code>validate(0)</code> 一定会得到false，也就是校验失败。这个符合当有线程持有写锁时与其他锁互斥的逻辑。</p><p>为什么<code>validate</code>方法，比较的是<code>(stamp &amp; SBITS) == (state &amp; SBITS);</code>？<br>因为需要支持读读不互斥，即使修改了state的低7位也就是读锁的部分，<code>(stamp &amp; SBITS) == (state &amp; SBITS);</code>依然会返回true。</p><h3 id="3-5-StampedLock的构造方法"><a href="#3-5-StampedLock的构造方法" class="headerlink" title="3.5 StampedLock的构造方法"></a>3.5 StampedLock的构造方法</h3><pre><code class="highlight java"><span class="comment">/** 用于表示读锁状态的位数，超出此范围会发生溢出。  范围是1~126  */</span><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">int</span> <span class="variable">LG_READERS</span> <span class="operator">=</span> <span class="number">7</span>;<span class="comment">/** 写操作的位掩码（位移了 LG_READERS 位） */</span><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">long</span> <span class="variable">WBIT</span>  <span class="operator">=</span> <span class="number">1L</span> &lt;&lt; LG_READERS;<span class="comment">/** 锁状态的初始值; 避免零值作为失败值 */</span><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">long</span> <span class="variable">ORIGIN</span> <span class="operator">=</span> WBIT &lt;&lt; <span class="number">1</span>;<span class="comment">/** 锁的状态*/</span><span class="keyword">private</span> <span class="keyword">transient</span> <span class="keyword">volatile</span> <span class="type">long</span> state;<span class="comment">/**</span><span class="comment"> * 默认构造方法。</span><span class="comment"> * 初始化 `StampedLock` 对象，将锁状态设置为初始值。</span><span class="comment"> */</span><span class="keyword">public</span> <span class="title function_">StampedLock</span><span class="params">()</span> &#123;    <span class="comment">// 初始化锁状态为初始值 ORIGIN，避免状态为零作为失败值。</span>    state = ORIGIN;&#125;</code></pre><h3 id="3-6-tryOptimisticRead方法"><a href="#3-6-tryOptimisticRead方法" class="headerlink" title="3.6 tryOptimisticRead方法"></a>3.6 tryOptimisticRead方法</h3><pre><code class="highlight java"><span class="comment">/** 用于表示读锁状态的位数 */</span><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">int</span> <span class="variable">LG_READERS</span> <span class="operator">=</span> <span class="number">7</span>;<span class="comment">/** 写操作的位掩码（位移了 LG_READERS 位） */</span><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">long</span> <span class="variable">WBIT</span>  <span class="operator">=</span> <span class="number">1L</span> &lt;&lt; LG_READERS;<span class="comment">/** 只有写锁的位掩码 */</span><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">long</span> <span class="variable">SBITS</span> <span class="operator">=</span> ~RBITS;<span class="comment">/** 读操作的位掩码范围 */</span><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">long</span> <span class="variable">RBITS</span> <span class="operator">=</span> WBIT - <span class="number">1L</span>;<span class="comment">/**</span><span class="comment"> * 尝试以乐观读模式获取锁。</span><span class="comment"> * </span><span class="comment"> * 这个方法检查当前锁状态以确定是否可以进行乐观读操作。</span><span class="comment"> * 如果没有写锁持有者（即锁的写位没有被设置），方法返回当前的读者计数（即锁的状态）。</span><span class="comment"> * 否则，返回 0 表示无法进行乐观读操作。</span><span class="comment"> * </span><span class="comment"> * <span class="doctag">@return</span> 如果可以进行乐观读，则返回当前的读者计数；否则返回 0。</span><span class="comment"> */</span><span class="keyword">public</span> <span class="type">long</span> <span class="title function_">tryOptimisticRead</span><span class="params">()</span> &#123;    <span class="type">long</span> s;    <span class="comment">// 读取当前锁状态</span>    s = state;    <span class="comment">// 检查写锁位是否被设置。如果没有写锁持有者（写位为 0），则返回当前读者计数（即去除写锁位后的状态值）。</span>    <span class="keyword">return</span> (((s &amp; WBIT) == <span class="number">0L</span>) ? (s &amp; SBITS) : <span class="number">0L</span>);&#125;</code></pre><p>这个方法允许线程在没有写锁持有者的情况下进行乐观读操作，这可以提高并发性能，因为乐观读操作不需要获取实际的读锁。</p><h3 id="3-7-readLock-方法"><a href="#3-7-readLock-方法" class="headerlink" title="3.7 readLock 方法"></a>3.7 readLock 方法</h3><pre><code class="highlight java"><span class="comment">/**</span><span class="comment"> * 尝试获取读锁。</span><span class="comment"> * </span><span class="comment"> * 在常见的无竞争情况下，这个方法会直接返回一个读锁的印章。</span><span class="comment"> * 如果当前队列为空（即 `whead` 等于 `wtail`），并且没有写锁持有者（即当前状态的读位小于 RFULL），</span><span class="comment"> * 则通过 CAS 操作将状态值加上 `RUNIT` 以尝试获取读锁。</span><span class="comment"> * 否则，调用 `acquireRead` 方法来实际获取读锁。</span><span class="comment"> * </span><span class="comment"> * <span class="doctag">@return</span> 成功获取读锁时的印章值。如果无法获取，则调用 `acquireRead` 方法来处理。</span><span class="comment"> */</span><span class="keyword">public</span> <span class="type">long</span> <span class="title function_">readLock</span><span class="params">()</span> &#123;    <span class="type">long</span> <span class="variable">s</span> <span class="operator">=</span> state, next;  <span class="comment">// 读取当前锁状态，并为下一个状态准备变量</span>    <span class="comment">// 如果当前队列为空且状态值允许新的读操作，则尝试通过 CAS 操作增加读锁计数</span>    <span class="keyword">return</span> ((whead == wtail &amp;&amp; (s &amp; ABITS) &lt; RFULL &amp;&amp;             U.compareAndSwapLong(<span class="built_in">this</span>, STATE, s, next = s + RUNIT)) ?            next : acquireRead(<span class="literal">false</span>, <span class="number">0L</span>));  <span class="comment">// 否则调用 acquireRead 方法来获取读锁</span>&#125;</code></pre><p><strong><code>readLock</code> 方法总结：</strong></p><ul><li><p><strong>目标：</strong> 尝试在无竞争情况下快速获取读锁。如果直接获取失败，则调用 <code>acquireRead</code> 处理复杂情况。</p></li><li><p><strong>具体步骤：</strong></p><ul><li><p><strong>检查队列状态：</strong></p><p>如果队列为空（whead &#x3D;&#x3D; wtail）且状态允许增加读锁计数（(s &amp; ABITS) &lt; RFULL），即没有达到读锁计数上限：尝试通过 CAS 操作将 state 增加 RUNIT，即增加读锁计数。如果 CAS 操作成功，返回新的状态 next。</p></li><li><p><strong>调用 acquireRead：</strong></p><p>如果队列不为空，或者 CAS 操作失败，则调用 acquireRead 方法来处理更复杂的情况，实际获取读锁。</p></li></ul></li></ul><h3 id="3-8-acquireRead方法"><a href="#3-8-acquireRead方法" class="headerlink" title="3.8 acquireRead方法"></a>3.8 acquireRead方法</h3><pre><code class="highlight java"><span class="comment">/**</span><span class="comment"> * 实际获取读锁的方法。</span><span class="comment"> * </span><span class="comment"> * 这个方法会尝试获取读锁。如果直接获取失败，它会通过自旋、队列管理和线程等待来确保获取读锁。</span><span class="comment"> * </span><span class="comment"> * <span class="doctag">@param</span> interruptible 是否可中断。</span><span class="comment"> * <span class="doctag">@param</span> deadline 线程等待的截止时间（纳秒）。</span><span class="comment"> * <span class="doctag">@return</span> 成功获取读锁时的印章值。如果超时或中断，则可能会取消等待。</span><span class="comment"> */</span><span class="keyword">private</span> <span class="type">long</span> <span class="title function_">acquireRead</span><span class="params">(<span class="type">boolean</span> interruptible, <span class="type">long</span> deadline)</span> &#123;    <span class="type">WNode</span> <span class="variable">node</span> <span class="operator">=</span> <span class="literal">null</span>, p;    <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">spins</span> <span class="operator">=</span> -<span class="number">1</span>;;) &#123;        WNode h;        <span class="keyword">if</span> ((h = whead) == (p = wtail)) &#123;  <span class="comment">// 检查队列是否为空</span>            <span class="keyword">for</span> (<span class="type">long</span> m, s, ns;;) &#123;                <span class="comment">// 检查当前状态是否允许增加读锁计数</span>                <span class="keyword">if</span> ((m = (s = state) &amp; ABITS) &lt; RFULL ?                    U.compareAndSwapLong(<span class="built_in">this</span>, STATE, s, ns = s + RUNIT) :                    (m &lt; WBIT &amp;&amp; (ns = tryIncReaderOverflow(s)) != <span class="number">0L</span>))                    <span class="keyword">return</span> ns;  <span class="comment">// 成功获取读锁</span>                <span class="keyword">else</span> <span class="keyword">if</span> (m &gt;= WBIT) &#123;                    <span class="keyword">if</span> (spins &gt; <span class="number">0</span>) &#123;                        <span class="keyword">if</span> (LockSupport.nextSecondarySeed() &gt;= <span class="number">0</span>)                            --spins;                    &#125;                    <span class="keyword">else</span> &#123;                        <span class="keyword">if</span> (spins == <span class="number">0</span>) &#123;                            <span class="type">WNode</span> <span class="variable">nh</span> <span class="operator">=</span> whead, np = wtail;                            <span class="keyword">if</span> ((nh == h &amp;&amp; np == p) || (h = nh) != (p = np))                                <span class="keyword">break</span>;                        &#125;                        spins = SPINS;  <span class="comment">// 重置自旋次数</span>                    &#125;                &#125;            &#125;        &#125;        <span class="keyword">if</span> (p == <span class="literal">null</span>) &#123; <span class="comment">// 如果队列为空，初始化队列</span>            <span class="type">WNode</span> <span class="variable">hd</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">WNode</span>(WMODE, <span class="literal">null</span>);            <span class="keyword">if</span> (U.compareAndSwapObject(<span class="built_in">this</span>, WHEAD, <span class="literal">null</span>, hd))                wtail = hd;        &#125;        <span class="keyword">else</span> <span class="keyword">if</span> (node == <span class="literal">null</span>)            node = <span class="keyword">new</span> <span class="title class_">WNode</span>(RMODE, p);  <span class="comment">// 创建新的读节点</span>        <span class="keyword">else</span> <span class="keyword">if</span> (h == p || p.mode != RMODE) &#123;  <span class="comment">// 如果队列中的前驱节点不是读节点，尝试加入队列</span>            <span class="keyword">if</span> (node.prev != p)                node.prev = p;            <span class="keyword">else</span> <span class="keyword">if</span> (U.compareAndSwapObject(<span class="built_in">this</span>, WTAIL, p, node)) &#123;                p.next = node;                <span class="keyword">break</span>;            &#125;        &#125;        <span class="keyword">else</span> <span class="keyword">if</span> (!U.compareAndSwapObject(p, WCOWAIT,                                         node.cowait = p.cowait, node))            node.cowait = <span class="literal">null</span>;  <span class="comment">// 更新前驱节点的等待列表</span>        <span class="keyword">else</span> &#123;            <span class="keyword">for</span> (;;) &#123;                WNode pp, c; Thread w;                <span class="keyword">if</span> ((h = whead) != <span class="literal">null</span> &amp;&amp; (c = h.cowait) != <span class="literal">null</span> &amp;&amp;                    U.compareAndSwapObject(h, WCOWAIT, c, c.cowait) &amp;&amp;                    (w = c.thread) != <span class="literal">null</span>) <span class="comment">// 唤醒等待线程</span>                    U.unpark(w);                <span class="keyword">if</span> (h == (pp = p.prev) || h == p || pp == <span class="literal">null</span>) &#123;                    <span class="type">long</span> m, s, ns;                    <span class="keyword">do</span> &#123;                        <span class="comment">// 检查状态是否允许增加读锁计数</span>                        <span class="keyword">if</span> ((m = (s = state) &amp; ABITS) &lt; RFULL ?                            U.compareAndSwapLong(<span class="built_in">this</span>, STATE, s,                                                 ns = s + RUNIT) :                            (m &lt; WBIT &amp;&amp;                             (ns = tryIncReaderOverflow(s)) != <span class="number">0L</span>))                            <span class="keyword">return</span> ns;  <span class="comment">// 成功获取读锁</span>                    &#125; <span class="keyword">while</span> (m &lt; WBIT);                &#125;                <span class="keyword">if</span> (whead == h &amp;&amp; p.prev == pp) &#123;                    <span class="type">long</span> time;                    <span class="keyword">if</span> (pp == <span class="literal">null</span> || h == p || p.status &gt; <span class="number">0</span>) &#123;                        node = <span class="literal">null</span>; <span class="comment">// 丢弃节点</span>                        <span class="keyword">break</span>;                    &#125;                    <span class="keyword">if</span> (deadline == <span class="number">0L</span>)                        time = <span class="number">0L</span>;                    <span class="keyword">else</span> <span class="keyword">if</span> ((time = deadline - System.nanoTime()) &lt;= <span class="number">0L</span>)                        <span class="keyword">return</span> cancelWaiter(node, p, <span class="literal">false</span>);  <span class="comment">// 超时取消等待</span>                    <span class="type">Thread</span> <span class="variable">wt</span> <span class="operator">=</span> Thread.currentThread();                    U.putObject(wt, PARKBLOCKER, <span class="built_in">this</span>);                    node.thread = wt;                    <span class="keyword">if</span> ((h != pp || (state &amp; ABITS) == WBIT) &amp;&amp;                        whead == h &amp;&amp; p.prev == pp)                        U.park(<span class="literal">false</span>, time);  <span class="comment">// 线程等待</span>                    node.thread = <span class="literal">null</span>;                    U.putObject(wt, PARKBLOCKER, <span class="literal">null</span>);                    <span class="keyword">if</span> (interruptible &amp;&amp; Thread.interrupted())                        <span class="keyword">return</span> cancelWaiter(node, p, <span class="literal">true</span>);  <span class="comment">// 处理中断</span>                &#125;            &#125;        &#125;    &#125;    <span class="comment">// 在队列头部自旋等待</span>    <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">spins</span> <span class="operator">=</span> -<span class="number">1</span>;;) &#123;        WNode h, np, pp; <span class="type">int</span> ps;        <span class="keyword">if</span> ((h = whead) == p) &#123;            <span class="keyword">if</span> (spins &lt; <span class="number">0</span>)                spins = HEAD_SPINS;  <span class="comment">// 初始化自旋次数</span>            <span class="keyword">else</span> <span class="keyword">if</span> (spins &lt; MAX_HEAD_SPINS)                spins &lt;&lt;= <span class="number">1</span>;  <span class="comment">// 增加自旋次数</span>            <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">k</span> <span class="operator">=</span> spins;;) &#123; <span class="comment">// 在队列头部自旋</span>                <span class="type">long</span> m, s, ns;                <span class="keyword">if</span> ((m = (s = state) &amp; ABITS) &lt; RFULL ?                    U.compareAndSwapLong(<span class="built_in">this</span>, STATE, s, ns = s + RUNIT) :                    (m &lt; WBIT &amp;&amp; (ns = tryIncReaderOverflow(s)) != <span class="number">0L</span>)) &#123;                    WNode c; Thread w;                    whead = node;  <span class="comment">// 更新队列头部</span>                    node.prev = <span class="literal">null</span>;                    <span class="keyword">while</span> ((c = node.cowait) != <span class="literal">null</span>) &#123;                        <span class="keyword">if</span> (U.compareAndSwapObject(node, WCOWAIT,                                                   c, c.cowait) &amp;&amp;                            (w = c.thread) != <span class="literal">null</span>)                            U.unpark(w);  <span class="comment">// 唤醒等待线程</span>                    &#125;                    <span class="keyword">return</span> ns;  <span class="comment">// 成功获取读锁</span>                &#125;                <span class="keyword">else</span> <span class="keyword">if</span> (m &gt;= WBIT &amp;&amp;                         LockSupport.nextSecondarySeed() &gt;= <span class="number">0</span> &amp;&amp; --k &lt;= <span class="number">0</span>)                    <span class="keyword">break</span>;  <span class="comment">// 超过自旋次数，退出自旋</span>            &#125;        &#125;        <span class="keyword">else</span> <span class="keyword">if</span> (h != <span class="literal">null</span>) &#123;            WNode c; Thread w;            <span class="keyword">while</span> ((c = h.cowait) != <span class="literal">null</span>) &#123;                <span class="keyword">if</span> (U.compareAndSwapObject(h, WCOWAIT, c, c.cowait) &amp;&amp;                    (w = c.thread) != <span class="literal">null</span>)                    U.unpark(w);  <span class="comment">// 唤醒等待线程</span>            &#125;        &#125;        <span class="keyword">if</span> (whead == h) &#123;            <span class="keyword">if</span> ((np = node.prev) != p) &#123;                <span class="keyword">if</span> (np != <span class="literal">null</span>)                    (p = np).next = node;   <span class="comment">// 更新前驱节点的 next 指针</span>            &#125;            <span class="keyword">else</span> <span class="keyword">if</span> ((ps = p.status) == <span class="number">0</span>)                U.compareAndSwapInt(p, WSTATUS, <span class="number">0</span>, WAITING);  <span class="comment">// 设置节点状态为等待</span>            <span class="keyword">else</span> <span class="keyword">if</span> (ps == CANCELLED) &#123;                <span class="keyword">if</span> ((pp = p.prev) != <span class="literal">null</span>) &#123;                    node.prev = pp;                    pp.next = node;  <span class="comment">// 更新前驱节点的 next 指针</span>                &#125;            &#125;            <span class="keyword">else</span> &#123;                <span class="type">long</span> time;                <span class="keyword">if</span> (deadline == <span class="number">0L</span>)                    time = <span class="number">0L</span>;                <span class="keyword">else</span> <span class="keyword">if</span> ((time = deadline - System.nanoTime()) &lt;= <span class="number">0L</span>)                    <span class="keyword">return</span> cancelWaiter(node, node, <span class="literal">false</span>);  <span class="comment">// 超时取消等待</span>                <span class="type">Thread</span> <span class="variable">wt</span> <span class="operator">=</span> Thread.currentThread();                U.putObject(wt, PARKBLOCKER, <span class="built_in">this</span>);                node.thread = wt;                <span class="keyword">if</span> (p.status &lt; <span class="number">0</span> &amp;&amp;                    (p != h || (state &amp; ABITS) == WBIT) &amp;&amp;                    whead == h &amp;&amp; node.prev == p)                    U.park(<span class="literal">false</span>, time);  <span class="comment">// 线程等待</span>                node.thread = <span class="literal">null</span>;                U.putObject(wt, PARKBLOCKER, <span class="literal">null</span>);                <span class="keyword">if</span> (interruptible &amp;&amp;</code></pre><p><strong>acquireRead 方法总结：</strong></p><ul><li><p><strong>目标：</strong> 在有竞争的情况下获取读锁，包括处理线程等待、队列管理、自旋等。</p></li><li><p><strong>acquireRead 的详细步骤：</strong></p><ul><li><p><strong>检查队列状态</strong></p><p>如果队列为空（whead &#x3D;&#x3D; wtail），尝试直接增加读锁计数（state）。如果成功，返回新的状态 ns。否则，进行自旋尝试。</p></li><li><p><strong>创建或管理节点</strong></p><p>如果队列为空，初始化一个新的头节点。如果节点 node 为空，则创建一个新的读节点。尝试将新的读节点添加到队列中，处理节点前驱和队列管理。</p></li><li><p><strong>处理自旋等待</strong></p><p>如果直接获取读锁失败，通过自旋等待的方式尝试获取读锁。</p></li><li><p><strong>处理线程等待</strong></p><p>如果自旋仍然失败，将线程放入等待队列中，处理中断和超时。</p></li><li><p><strong>唤醒等待线程</strong></p><p>当读锁被成功获取后，唤醒等待的线程。</p></li></ul></li></ul><h3 id="3-9-unlockRead方法"><a href="#3-9-unlockRead方法" class="headerlink" title="3.9 unlockRead方法"></a>3.9 unlockRead方法</h3><pre><code class="highlight java"><span class="comment">/**</span><span class="comment"> * 解锁读锁。</span><span class="comment"> * </span><span class="comment"> * 这个方法会验证提供的印章（`stamp`）是否与当前锁状态一致。如果印章无效或锁状态不匹配，会抛出 `IllegalMonitorStateException`。</span><span class="comment"> * 如果锁的读计数低于 `RFULL`，尝试通过 CAS 操作减少读计数。如果读计数减少到 0，则释放队列中可能被阻塞的线程。</span><span class="comment"> * 如果读计数达到了 `RFULL`，则调用 `tryDecReaderOverflow` 方法来处理溢出读线程计数。</span><span class="comment"> * </span><span class="comment"> * <span class="doctag">@param</span> stamp 读锁的印章值。</span><span class="comment"> * <span class="doctag">@throws</span> IllegalMonitorStateException 如果印章无效或状态不匹配。</span><span class="comment"> */</span><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">unlockRead</span><span class="params">(<span class="type">long</span> stamp)</span> &#123;    <span class="type">long</span> s, m; WNode h;    <span class="keyword">for</span> (;;) &#123;  <span class="comment">// 自旋</span>        <span class="comment">// 获取当前锁状态</span>        s = state;        <span class="comment">// 检查印章是否与当前状态匹配，或者印章是否有效</span>        <span class="keyword">if</span> (((s &amp; SBITS) != (stamp &amp; SBITS)) ||            (stamp &amp; ABITS) == <span class="number">0L</span> || (m = s &amp; ABITS) == <span class="number">0L</span> || m == WBIT)            <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">IllegalMonitorStateException</span>();  <span class="comment">// 印章无效，抛出异常</span>        <span class="keyword">if</span> (m &lt; RFULL) &#123;            <span class="comment">// 如果读计数小于 RFULL，尝试减少读计数</span>            <span class="keyword">if</span> (U.compareAndSwapLong(<span class="built_in">this</span>, STATE, s, s - RUNIT)) &#123;                <span class="comment">// 如果减少后读计数为 RUNIT 且队列头部节点状态不为 0，释放队列中的线程</span>                <span class="keyword">if</span> (m == RUNIT &amp;&amp; (h = whead) != <span class="literal">null</span> &amp;&amp; h.status != <span class="number">0</span>)                    release(h);                <span class="keyword">break</span>;            &#125;        &#125;        <span class="keyword">else</span> <span class="keyword">if</span> (tryDecReaderOverflow(s) != <span class="number">0L</span>)            <span class="keyword">break</span>;  <span class="comment">// 处理溢出的读者计数</span>    &#125;&#125;</code></pre><p><strong><code>unlockRead</code> 方法总结：</strong></p><ul><li><p><code>目标：</code>释放读锁，验证印章的有效性，并根据读锁计数的状态更新锁状态。</p></li><li><p><strong>步骤：</strong></p><ul><li><p>自旋检查印章有效性</p><p>进入自旋循环，获取当前锁状态 s。<br>检查传入的印章 stamp 是否与当前状态一致（通过比较 SBITS），以及印章是否有效（(stamp &amp; ABITS) &#x3D;&#x3D; 0L），或者当前状态是否无效（m &#x3D;&#x3D; WBIT）。<br>如果印章无效，抛出 IllegalMonitorStateException。</p></li><li><p>处理读计数</p><p>如果读计数小于 RFULL：<br>尝试通过 CAS 操作将状态 s 减少 RUNIT，即减少读锁计数。<br>如果读计数减少后为 RUNIT，并且队列头部节点状态不为 0，调用 release(h) 释放队列中的线程。<br>跳出循环，完成解锁。</p><p>如果读计数达到 RFULL：<br>调用 tryDecReaderOverflow 方法处理读计数溢出情况。</p></li><li><p>处理读计数溢出</p><p><code>tryDecReaderOverflow</code> 方法用于减少在 RFULL 状态下的溢出读线程计数。</p></li></ul></li></ul><h3 id="3-10-tryDecReaderOverflow方法"><a href="#3-10-tryDecReaderOverflow方法" class="headerlink" title="3.10 tryDecReaderOverflow方法"></a>3.10 tryDecReaderOverflow方法</h3><pre><code class="highlight java"><span class="comment">/**</span><span class="comment"> * 尝试减少溢出的读计数。</span><span class="comment"> * </span><span class="comment"> * 这个方法会处理在读锁计数达到 `RFULL` 后的溢出情况。如果当前状态的读计数已经达到 `RFULL`，</span><span class="comment"> * 通过 CAS 操作将状态更新为包含读位的值，并减少 `readerOverflow` 计数器。</span><span class="comment"> * 如果 `readerOverflow` 计数器为 0，则直接减少读计数。</span><span class="comment"> * </span><span class="comment"> * <span class="doctag">@param</span> s 当前锁状态。</span><span class="comment"> * <span class="doctag">@return</span> 更新后的状态值。如果无法减少读者计数，则返回 0L。</span><span class="comment"> */</span><span class="keyword">private</span> <span class="type">long</span> <span class="title function_">tryDecReaderOverflow</span><span class="params">(<span class="type">long</span> s)</span> &#123;    <span class="comment">// 确保当前状态的读位计数达到了 RFULL</span>    <span class="keyword">if</span> ((s &amp; ABITS) == RFULL) &#123;        <span class="comment">// 通过 CAS 操作将状态值更新为包含读位的状态</span>        <span class="keyword">if</span> (U.compareAndSwapLong(<span class="built_in">this</span>, STATE, s, s | RBITS)) &#123;            <span class="type">int</span> r; <span class="type">long</span> next;            <span class="keyword">if</span> ((r = readerOverflow) &gt; <span class="number">0</span>) &#123;                <span class="comment">// 如果溢出计数器大于 0，减少计数器并保持状态</span>                readerOverflow = r - <span class="number">1</span>;                next = s;            &#125;            <span class="keyword">else</span>                <span class="comment">// 否则，减少读锁计数</span>                next = s - RUNIT;            state = next;  <span class="comment">// 更新锁状态</span>            <span class="keyword">return</span> next;  <span class="comment">// 返回更新后的状态值</span>        &#125;    &#125;    <span class="keyword">else</span> <span class="keyword">if</span> ((LockSupport.nextSecondarySeed() &amp; OVERFLOW_YIELD_RATE) == <span class="number">0</span>)        Thread.<span class="keyword">yield</span>();  <span class="comment">// 在不能处理溢出时，让线程让步</span>    <span class="keyword">return</span> <span class="number">0L</span>;  <span class="comment">// 无法减少读者计数时返回 0L</span>&#125;</code></pre><p><strong>tryDecReaderOverflow方法总结：</strong></p><ul><li><p>目标： 处理在读锁计数达到上限时的溢出情况，确保锁状态的正确性。</p></li><li><p>步骤：</p><ul><li><p>检查读计数是否达到 RFULL：如果当前状态的读位计数等于 RFULL，则尝试更新状态以处理溢出情况。</p></li><li><p>更新状态：</p><p>通过 CAS 操作将状态更新为包含读位的状态<code>（s | RBITS）</code>。<br>如果 readerOverflow 计数器大于 0，减少计数器并保持状态。<br>如果 readerOverflow 为 0，减少读锁计数。<br>更新 state 变量，并返回更新后的状态值。</p></li><li><p>处理无法减少计数的情况：</p><p>如果无法处理溢出情况，让线程让步（Thread.yield()），并返回 0L。</p></li></ul></li></ul><h3 id="3-11-writeLock-方法"><a href="#3-11-writeLock-方法" class="headerlink" title="3.11 writeLock 方法"></a>3.11 writeLock 方法</h3><pre><code class="highlight java"><span class="comment">/**</span><span class="comment"> * 尝试获取写锁。</span><span class="comment"> * </span><span class="comment"> * 这个方法首先检查当前锁状态，如果当前没有读锁或写锁（`ABITS` 中没有任何标志位），</span><span class="comment"> * 直接通过 CAS 操作将状态更新为加上写锁位 `WBIT` 的新状态。如果更新成功，返回新的状态值。</span><span class="comment"> * 如果锁已被其他线程持有，或者队列中存在等待写锁的线程，则调用 `acquireWrite` 方法，</span><span class="comment"> * 通过排队的方式来获取写锁。</span><span class="comment"> * </span><span class="comment"> * <span class="doctag">@return</span> 成功获取的写锁印章。</span><span class="comment"> */</span><span class="keyword">public</span> <span class="type">long</span> <span class="title function_">writeLock</span><span class="params">()</span> &#123;    <span class="type">long</span> s, next;  <span class="comment">// 当前锁状态和新的状态</span>    <span class="comment">// 检查当前锁状态是否为完全解锁状态</span>    <span class="keyword">return</span> ((((s = state) &amp; ABITS) == <span class="number">0L</span> &amp;&amp;             U.compareAndSwapLong(<span class="built_in">this</span>, STATE, s, next = s + WBIT)) ?            next : acquireWrite(<span class="literal">false</span>, <span class="number">0L</span>));&#125;</code></pre><p><strong>writeLock 方法总结：</strong></p><ul><li><p>目标： writeLock 方法尝试直接获取写锁，如果失败则调用 acquireWrite 方法通过排队的方式获取写锁。</p></li><li><p>步骤：</p><ul><li><p>检查当前锁状态：</p><p>获取当前锁状态 s。<br>如果当前状态没有任何读锁或写锁（即 ABITS 中没有任何标志位），尝试通过 CAS 操作将状态更新为加上写锁位 WBIT 的新状态 next。</p></li><li><p>更新锁状态：</p><p>如果 CAS 操作成功，则返回新的状态值 next。</p></li><li><p>调用 acquireWrite：</p><p>如果状态更新失败（锁已被其他线程持有或队列中存在等待写锁的线程），调用 acquireWrite 方法来通过排队的方式获取写锁。</p></li></ul></li></ul><h3 id="3-12-acquireWrite方法"><a href="#3-12-acquireWrite方法" class="headerlink" title="3.12 acquireWrite方法"></a>3.12 acquireWrite方法</h3><pre><code class="highlight java"><span class="comment">/**</span><span class="comment"> * 尝试获取写锁。</span><span class="comment"> * </span><span class="comment"> * 这个方法通过自旋和排队的方式获取写锁。如果直接获取写锁失败，则将当前线程排入等待队列，</span><span class="comment"> * 并在队列中等待直到能够获取写锁。</span><span class="comment"> * </span><span class="comment"> * <span class="doctag">@param</span> interruptible 是否可中断。</span><span class="comment"> * <span class="doctag">@param</span> deadline 等待的最大时间（以纳秒为单位），0 表示不超时。</span><span class="comment"> * <span class="doctag">@return</span> 成功获取的写锁印章。</span><span class="comment"> */</span><span class="keyword">private</span> <span class="type">long</span> <span class="title function_">acquireWrite</span><span class="params">(<span class="type">boolean</span> interruptible, <span class="type">long</span> deadline)</span> &#123;    <span class="type">WNode</span> <span class="variable">node</span> <span class="operator">=</span> <span class="literal">null</span>, p;    <span class="comment">// 自旋尝试将当前线程排入等待队列</span>    <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">spins</span> <span class="operator">=</span> -<span class="number">1</span>;;) &#123; <span class="comment">// 自旋，直到将节点加入队列</span>        <span class="type">long</span> m, s, ns;        <span class="comment">// 获取当前锁状态</span>        <span class="keyword">if</span> ((m = (s = state) &amp; ABITS) == <span class="number">0L</span>) &#123;            <span class="comment">// 如果当前没有读锁或写锁，通过 CAS 操作将状态更新为加上写锁位 WBIT</span>            <span class="keyword">if</span> (U.compareAndSwapLong(<span class="built_in">this</span>, STATE, s, ns = s + WBIT))                <span class="keyword">return</span> ns;  <span class="comment">// 返回更新后的状态值</span>        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (spins &lt; <span class="number">0</span>)            <span class="comment">// 如果当前状态为写锁且队列为空，设置自旋次数</span>            spins = (m == WBIT &amp;&amp; wtail == whead) ? SPINS : <span class="number">0</span>;        <span class="keyword">else</span> <span class="keyword">if</span> (spins &gt; <span class="number">0</span>) &#123;            <span class="comment">// 自旋，减少自旋次数</span>            <span class="keyword">if</span> (LockSupport.nextSecondarySeed() &gt;= <span class="number">0</span>)                --spins;        &#125; <span class="keyword">else</span> <span class="keyword">if</span> ((p = wtail) == <span class="literal">null</span>) &#123; <span class="comment">// 初始化队列</span>            <span class="type">WNode</span> <span class="variable">hd</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">WNode</span>(WMODE, <span class="literal">null</span>);            <span class="keyword">if</span> (U.compareAndSwapObject(<span class="built_in">this</span>, WHEAD, <span class="literal">null</span>, hd))                wtail = hd;        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (node == <span class="literal">null</span>)            <span class="comment">// 创建新的等待节点</span>            node = <span class="keyword">new</span> <span class="title class_">WNode</span>(WMODE, p);        <span class="keyword">else</span> <span class="keyword">if</span> (node.prev != p)            <span class="comment">// 确保节点的前驱节点正确</span>            node.prev = p;        <span class="keyword">else</span> <span class="keyword">if</span> (U.compareAndSwapObject(<span class="built_in">this</span>, WTAIL, p, node)) &#123;            <span class="comment">// 将当前节点加入队列</span>            p.next = node;            <span class="keyword">break</span>;  <span class="comment">// 成功将节点加入队列，退出自旋循环</span>        &#125;    &#125;    <span class="comment">// 自旋等待，直到获取写锁</span>    <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">spins</span> <span class="operator">=</span> -<span class="number">1</span>;;) &#123;        WNode h, np, pp;        <span class="type">int</span> ps;        <span class="comment">// 检查当前队列头节点</span>        <span class="keyword">if</span> ((h = whead) == p) &#123;            <span class="comment">// 如果当前节点是队列头节点，自旋等待写锁</span>            <span class="keyword">if</span> (spins &lt; <span class="number">0</span>)                spins = HEAD_SPINS;            <span class="keyword">else</span> <span class="keyword">if</span> (spins &lt; MAX_HEAD_SPINS)                spins &lt;&lt;= <span class="number">1</span>;            <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">k</span> <span class="operator">=</span> spins;;) &#123;                <span class="type">long</span> s, ns;                <span class="comment">// 获取当前锁状态</span>                <span class="keyword">if</span> (((s = state) &amp; ABITS) == <span class="number">0L</span>) &#123;                    <span class="comment">// 如果当前没有读锁或写锁，通过 CAS 操作更新状态</span>                    <span class="keyword">if</span> (U.compareAndSwapLong(<span class="built_in">this</span>, STATE, s, ns = s + WBIT)) &#123;                        <span class="comment">// 更新队列头部为当前节点</span>                        whead = node;                        node.prev = <span class="literal">null</span>;                        <span class="keyword">return</span> ns;  <span class="comment">// 返回新的状态值</span>                    &#125;                &#125; <span class="keyword">else</span> <span class="keyword">if</span> (LockSupport.nextSecondarySeed() &gt;= <span class="number">0</span> &amp;&amp;                         --k &lt;= <span class="number">0</span>)                    <span class="keyword">break</span>;  <span class="comment">// 超过自旋次数，退出循环</span>            &#125;        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (h != <span class="literal">null</span>) &#123; <span class="comment">// 帮助释放过时的等待节点</span>            WNode c;            Thread w;            <span class="keyword">while</span> ((c = h.cowait) != <span class="literal">null</span>) &#123;                <span class="keyword">if</span> (U.compareAndSwapObject(h, WCOWAIT, c, c.cowait) &amp;&amp;                    (w = c.thread) != <span class="literal">null</span>)                    U.unpark(w);            &#125;        &#125;        <span class="keyword">if</span> (whead == h) &#123;            <span class="keyword">if</span> ((np = node.prev) != p) &#123;                <span class="comment">// 更新链表，将当前节点插入到正确的位置</span>                <span class="keyword">if</span> (np != <span class="literal">null</span>)                    (p = np).next = node;   <span class="comment">// 处理过时的节点</span>            &#125; <span class="keyword">else</span> <span class="keyword">if</span> ((ps = p.status) == <span class="number">0</span>)                <span class="comment">// 如果节点状态为 0，设置为 WAITING</span>                U.compareAndSwapInt(p, WSTATUS, <span class="number">0</span>, WAITING);            <span class="keyword">else</span> <span class="keyword">if</span> (ps == CANCELLED) &#123;                <span class="comment">// 如果节点状态为 CANCELLED，处理取消的节点</span>                <span class="keyword">if</span> ((pp = p.prev) != <span class="literal">null</span>) &#123;                    node.prev = pp;                    pp.next = node;                &#125;            &#125; <span class="keyword">else</span> &#123;                <span class="comment">// 等待获取写锁</span>                <span class="type">long</span> time; <span class="comment">// 0 参数表示无超时</span>                <span class="keyword">if</span> (deadline == <span class="number">0L</span>)                    time = <span class="number">0L</span>;                <span class="keyword">else</span> <span class="keyword">if</span> ((time = deadline - System.nanoTime()) &lt;= <span class="number">0L</span>)                    <span class="comment">// 超过等待时间，取消等待</span>                    <span class="keyword">return</span> cancelWaiter(node, node, <span class="literal">false</span>);                <span class="type">Thread</span> <span class="variable">wt</span> <span class="operator">=</span> Thread.currentThread();                U.putObject(wt, PARKBLOCKER, <span class="built_in">this</span>);                node.thread = wt;                <span class="keyword">if</span> (p.status &lt; <span class="number">0</span> &amp;&amp; (p != h || (state &amp; ABITS) != <span class="number">0L</span>) &amp;&amp;                    whead == h &amp;&amp; node.prev == p)                    <span class="comment">// 如果条件满足，则使当前线程进入等待状态</span>                    U.park(<span class="literal">false</span>, time);  <span class="comment">// 模拟 LockSupport.park</span>                node.thread = <span class="literal">null</span>;                U.putObject(wt, PARKBLOCKER, <span class="literal">null</span>);                <span class="keyword">if</span> (interruptible &amp;&amp; Thread.interrupted())                    <span class="comment">// 如果线程被中断，取消等待</span>                    <span class="keyword">return</span> cancelWaiter(node, node, <span class="literal">true</span>);            &#125;        &#125;    &#125;&#125;</code></pre><p><strong>acquireWrite 方法总结：</strong></p><ul><li><p>目标： 负责处理排队、等待和自旋等复杂逻辑，确保在竞争条件下正确地获取写锁。</p></li><li><p>步骤：</p><ul><li><p>自旋排队:</p><p>方法开始时，尝试通过自旋的方式将当前线程排入等待队列。如果当前没有读锁或写锁，尝试直接获取写锁。如果无法直接获取写锁，初始化队列或创建新的等待节点，将其添加到队列中。</p></li><li><p>等待队列初始化:</p><p>如果队列为空，创建队列头节点，并将尾节点指向该头节点。若节点已经存在，则创建新的节点并将其加入队列。</p></li><li><p>自旋等待写锁:</p><p>在自旋阶段，尝试检查队列头节点并自旋等待写锁。更新队列头节点为当前节点，确保其他线程能够正确地获取写锁。</p></li><li><p>处理过时的等待节点:</p><p>在等待期间，帮助释放已经过时的等待节点，并唤醒那些被阻塞的线程。</p></li><li><p>等待获取写锁:</p><p>如果条件允许，将当前线程进入等待状态，直到写锁可用。支持中断处理，如果线程被中断则取消等待。</p></li></ul></li></ul><h3 id="3-13-unlockWrite方法"><a href="#3-13-unlockWrite方法" class="headerlink" title="3.13 unlockWrite方法"></a>3.13 unlockWrite方法</h3><pre><code class="highlight java"><span class="comment">/**</span><span class="comment"> * 解锁写锁。</span><span class="comment"> * </span><span class="comment"> * 这个方法会验证提供的印章（`stamp`）是否为当前锁的写锁印章。如果印章无效或不是写锁印章，会抛出 `IllegalMonitorStateException`。</span><span class="comment"> * 成功解锁后，将状态重置为原始值 `ORIGIN`（如果 `stamp` 变为 0L），或者恢复为提供的印章加上写锁位 `WBIT`。</span><span class="comment"> * 如果队列头部节点（`whead`）不为空且状态不为 0，则调用 `release` 方法释放队列中可能被阻塞的线程。</span><span class="comment"> * </span><span class="comment"> * <span class="doctag">@param</span> stamp 写锁的印章值。</span><span class="comment"> * <span class="doctag">@throws</span> IllegalMonitorStateException 如果印章无效或不是写锁印章。</span><span class="comment"> */</span><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">unlockWrite</span><span class="params">(<span class="type">long</span> stamp)</span> &#123;    WNode h;    <span class="comment">// 验证提供的印章是否与当前锁状态匹配，并且是写锁印章</span>    <span class="keyword">if</span> (state != stamp || (stamp &amp; WBIT) == <span class="number">0L</span>)        <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">IllegalMonitorStateException</span>();  <span class="comment">// 印章无效，抛出异常</span>    <span class="comment">// 更新锁状态。如果解锁后状态为 0L，重置为原始值 ORIGIN</span>    state = (stamp += WBIT) == <span class="number">0L</span> ? ORIGIN : stamp;        <span class="comment">// 如果队列头部节点不为空且状态不为 0，释放队列中的线程</span>    <span class="keyword">if</span> ((h = whead) != <span class="literal">null</span> &amp;&amp; h.status != <span class="number">0</span>)        release(h);&#125;</code></pre><p><strong>unlockWrite方法总结：</strong></p><ul><li><p>目标： 安全地释放持有的写锁，并确保相关线程被正确唤醒。</p></li><li><p>步骤：</p><ul><li><p>验证印章:</p><p>首先，方法会检查提供的印章是否与当前锁状态匹配，且印章是否包含写锁位 (WBIT)。如果不匹配或不包含写锁位，抛出 IllegalMonitorStateException。</p></li><li><p>更新锁状态:</p><p>如果印章有效，解锁后将状态重置为原始值 ORIGIN（如果 stamp 加上 WBIT 结果为 0L），否则将状态更新为印章加上 WBIT。这个操作确保锁的状态正确反映当前的锁持有情况。</p></li><li><p>释放阻塞线程:</p><p>检查队列头部节点 (whead) 是否存在且状态不为 0。如果存在，则调用 release 方法尝试释放队列中的线程。</p></li></ul></li></ul><h3 id="3-14-release方法"><a href="#3-14-release方法" class="headerlink" title="3.14 release方法"></a>3.14 release方法</h3><pre><code class="highlight java"><span class="comment">/**</span><span class="comment"> * 释放队列中阻塞的线程。</span><span class="comment"> * </span><span class="comment"> * 这个方法会尝试从队列中找到下一个需要被唤醒的节点（`WNode`）。</span><span class="comment"> * 将队列头部节点的状态从 `WAITING` 更新为 0（表示节点不再等待）。</span><span class="comment"> * 如果队列中的下一个节点（`q`）存在且状态不为 `CANCELLED`，唤醒线程。</span><span class="comment"> * </span><span class="comment"> * <span class="doctag">@param</span> h 队列中的头部节点。</span><span class="comment"> */</span><span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">release</span><span class="params">(WNode h)</span> &#123;    <span class="keyword">if</span> (h != <span class="literal">null</span>) &#123;        WNode q; Thread w;        <span class="comment">// 更新队列头部节点的状态为 0</span>        U.compareAndSwapInt(h, WSTATUS, WAITING, <span class="number">0</span>);                <span class="comment">// 查找下一个需要被唤醒的节点（如果下一个节点为空或者状态为 CANCELLED）</span>        <span class="keyword">if</span> ((q = h.next) == <span class="literal">null</span> || q.status == CANCELLED) &#123;            <span class="keyword">for</span> (<span class="type">WNode</span> <span class="variable">t</span> <span class="operator">=</span> wtail; t != <span class="literal">null</span> &amp;&amp; t != h; t = t.prev)                <span class="keyword">if</span> (t.status &lt;= <span class="number">0</span>)                    q = t;        &#125;                <span class="comment">// 如果找到的节点存在且线程不为空，唤醒线程</span>        <span class="keyword">if</span> (q != <span class="literal">null</span> &amp;&amp; (w = q.thread) != <span class="literal">null</span>)            U.unpark(w);    &#125;&#125;</code></pre><p><strong>release方法总结：</strong></p><ul><li><p>目标： 从队列中释放阻塞的线程，并确保下一个等待的线程被正确唤醒。</p></li><li><p>步骤：</p><ul><li><p>更新节点状态:</p><p>将队列头部节点的状态从 WAITING 更新为 0，表示该节点不再需要等待。此操作标志着头部节点已处理完毕，准备释放或处理下一个节点。</p></li><li><p>查找并设置下一个待唤醒的节点:</p><p>如果头部节点的下一个节点为空或状态为 CANCELLED，从队列尾部向前查找有效的待唤醒节点。这样可以确保唤醒操作的正确性，并避免唤醒已取消或不再需要的线程。</p></li><li><p>唤醒线程:</p><p>如果找到有效的待唤醒节点，并且该节点关联的线程不为空，则唤醒该线程。通过调用 U.unpark(w)，可以确保线程能够继续执行，减少系统中的线程阻塞时间。</p></li></ul></li></ul><h2 id="4-StampedLock管理线程的队列"><a href="#4-StampedLock管理线程的队列" class="headerlink" title="4. StampedLock管理线程的队列"></a>4. StampedLock管理线程的队列</h2><p>StampedLock内部基于<code>WNode</code>实现的阻塞队列和AQS实现的阻塞队列类似。<br>初始化时，新建个空节点，<code>whead=wtail=NULL</code> 。</p><p><img src="https://raw.githubusercontent.com/GeorgeChan95/blogimg/master/img/2024/10/19/20241019-164228.png" alt="队列初始化"></p><p>之后再往里面加入一个个读线程或写线程节点。</p><p>但是上面<code>acquireRead</code>和<code>acquireWrite</code>方法对于自旋的操作就和AQS有很大不同了。</p><p>在AQS里面，当一个线程CAS state失败之后，会立即加入阻塞队列，并且进入阻塞状态。但在StampedLock中，CAS state失败之后，会不断自旋，自旋足够多的次数之后，如果还拿不到锁，才进入阻塞状态。为此，根据CPU的核数，定义了自旋次数的常量值。如果是单核的CPU，肯定不能自旋，在多核情况下，才采用自旋策略。</p><p>还有个比较特殊的地方在于，每个WNode里面有一个cowait指针，用于串联起所有的读线程。<br>例如，队列尾部阻塞的是一个读线程 1，现在又来了读线程 2、3，那么会通过cowait指针，把1、2、3串联起来。1被唤醒之后，2、3也随之一起被唤醒，因为读和读之间不互斥。</p><p>也就是当入队一个线程时，如果队尾是写结点，则直接链接到队尾。<br>当入队一个读线程时，如果队尾是读节点，则直接链接到该读结点的cowait链中。</p><p><img src="https://raw.githubusercontent.com/GeorgeChan95/blogimg/master/img/2024/10/19/20241019-164402.png" alt="节点进入队列"></p><h1 id="四、StampedLock和ReentrantReadWriteLock对比"><a href="#四、StampedLock和ReentrantReadWriteLock对比" class="headerlink" title="四、StampedLock和ReentrantReadWriteLock对比"></a>四、StampedLock和ReentrantReadWriteLock对比</h1><table><thead><tr><th>特性</th><th><code>StampedLock</code></th><th><code>ReentrantReadWriteLock</code></th></tr></thead><tbody><tr><td><strong>引入版本</strong></td><td>JDK 8</td><td>JDK 5</td></tr><tr><td><strong>锁类型</strong></td><td>提供乐观读锁、悲观读锁和写锁</td><td>提供悲观读锁和写锁</td></tr><tr><td><strong>乐观读锁</strong></td><td>支持（<code>tryOptimisticRead()</code>）</td><td>不支持</td></tr><tr><td><strong>悲观读锁</strong></td><td>支持（<code>readLock()</code>）</td><td>支持（<code>readLock()</code>）</td></tr><tr><td><strong>写锁</strong></td><td>支持（<code>writeLock()</code>）</td><td>支持（<code>writeLock()</code>）</td></tr><tr><td><strong>锁升级</strong></td><td>支持从乐观读锁升级到悲观读锁或写锁（<code>tryConvertToWriteLock()</code>等）</td><td>不支持</td></tr><tr><td><strong>锁降级</strong></td><td>支持从写锁降级为读锁（<code>tryConvertToReadLock()</code>）</td><td>支持从写锁降级为读锁</td></tr><tr><td><strong>锁管理复杂度</strong></td><td>复杂，需要管理戳记，确保在转换锁时一致性</td><td>相对简单，直接使用 <code>readLock()</code> 和 <code>writeLock()</code></td></tr><tr><td><strong>性能优化</strong></td><td>乐观读锁减少了锁竞争，提高了读取性能</td><td>读写锁性能依赖于锁的竞争情况(大量并发读可能会导致写线程饥饿)</td></tr><tr><td><strong>公平性</strong></td><td>不提供公平性（锁的获取是非公平的）</td><td>可以选择公平性（通过构造函数 <code>ReentrantReadWriteLock(true)</code>）</td></tr><tr><td><strong>条件变量<code>Condition</code></strong></td><td>不支持</td><td>支持</td></tr></tbody></table><p><strong>总结</strong></p><p><strong><code>StampedLock</code></strong> 适用于需要高效读取性能的场景，通过乐观读锁减少锁竞争，同时支持锁的升级和降级，但锁的管理相对复杂，不支持重入，并且使用乐观读锁时需要遵循一定的顺序，所以使用时一定要谨慎。</p><p><strong>参考链接：</strong></p><blockquote><p><a href="https://blog.csdn.net/qq_37883866/article/details/140664358">https://blog.csdn.net/qq_37883866/article/details/140664358</a></p></blockquote>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;一、锁的演变&quot;&gt;&lt;a href=&quot;#一、锁的演变&quot; class=&quot;headerlink&quot; title=&quot;一、锁的演变&quot;&gt;&lt;/a&gt;一、锁的演变&lt;/h1&gt;&lt;p&gt;无锁  –&amp;gt; 独占锁  –&amp;gt; 读写锁  –&amp;gt; 邮戳锁&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;p&gt;无锁</summary>
      
    
    
    
    <category term="JUC" scheme="https://georgechan95.github.io/categories/JUC/"/>
    
    
    <category term="java" scheme="https://georgechan95.github.io/tags/java/"/>
    
    <category term="juc" scheme="https://georgechan95.github.io/tags/juc/"/>
    
  </entry>
  
  <entry>
    <title>Docker部署Neo4j并导入CSV数据</title>
    <link href="https://georgechan95.github.io/blog/5c93903a.html"/>
    <id>https://georgechan95.github.io/blog/5c93903a.html</id>
    <published>2024-10-17T07:00:30.000Z</published>
    <updated>2024-10-18T09:09:53.466Z</updated>
    
    <content type="html"><![CDATA[<p><strong>系统环境</strong></p><blockquote><p>操作系统：Ubuntu18.04.6</p><p>Docker：24.0.2</p><p>Neo4j: 3.5.35(社区版)</p></blockquote><h1 id="一、下载并启动Neo4j"><a href="#一、下载并启动Neo4j" class="headerlink" title="一、下载并启动Neo4j"></a>一、下载并启动Neo4j</h1><h2 id="1-修改Docker配置文件"><a href="#1-修改Docker配置文件" class="headerlink" title="1. 修改Docker配置文件"></a>1. 修改Docker配置文件</h2><p>neo4j镜像在国外服务器，国内直接pull会超时失败，这里需要配置一下代理。</p><pre><code class="highlight shell"><span class="meta prompt_"># </span><span class="language-bash">创建docker默认的配置文件路径</span>mkdir -p /etc/docker<span class="meta prompt_"></span><span class="meta prompt_"># </span><span class="language-bash">内容如下：直接拷贝粘贴</span>tee /etc/docker/daemon.json &lt;&lt;-&#x27;EOF&#x27;&#123;&quot;registry-mirrors&quot;: [&quot;https://docker-proxy.741001.xyz&quot;,&quot;https://registry.docker-cn.com&quot;]&#125;EOF<span class="meta prompt_"></span><span class="meta prompt_"># </span><span class="language-bash">重启docker服务</span>systemctl daemon-reloadsystemctl restart docker</code></pre><h2 id="2-启动neo4j"><a href="#2-启动neo4j" class="headerlink" title="2. 启动neo4j"></a>2. 启动neo4j</h2><ul><li><p>拉取镜像</p><pre><code class="highlight shell"><span class="meta prompt_"># </span><span class="language-bash">拉取镜像</span>docker pull neo4j:3.5.35<span class="meta prompt_"></span><span class="meta prompt_"># </span><span class="language-bash">查看本地镜像，检验是否拉取成功</span>docker images</code></pre></li><li><p>创建挂载目录</p><pre><code class="highlight shell">mkdir -p /opt/module /opt/softwaremkdir -p /opt/module/neo4jcd /opt/module/neo4j/mkdir -p data logs conf import plugins</code></pre></li><li><p>启动容器</p><pre><code class="highlight shell">docker run -itd \    --name neo4j \    -p 7474:7474 -p 7687:7687 \    -v /opt/module/neo4j/data:/data \    -v /opt/module/neo4j/logs:/logs \    -v /opt/module/neo4j/conf:/var/lib/neo4j/conf \    -v /opt/module/neo4j/import:/var/lib/neo4j/import \    -v /opt/module/neo4j/plugins:/var/lib/neo4j/plugins \    --env NEO4J_AUTH=neo4j/123456 \    --restart=always \    neo4j:3.5.35</code></pre><ul><li><p>命令解析</p><pre><code class="highlight shell">docker run -itd --name container_name \  //-d表示容器后台运行 --name指定容器名字-p 7474:7474 -p 7687:7687 \  //映射容器的端口号到宿主机的端口号-v /opt/module/neo4j/data:/data \  //把容器内的数据目录挂载到宿主机的对应目录下-v /opt/module/neo4j/logs:/logs \  //挂载日志目录-v /opt/module/neo4j/conf:/var/lib/neo4j/conf   //挂载配置目录-v /opt/module/neo4j/import:/var/lib/neo4j/import \  //挂载数据导入目录-v /opt/module/neo4j/plugins:/var/lib/neo4j/plugins \ // neo4j插件安装目录--env NEO4J_AUTH=neo4j/123456 \  //设定数据库的名字的访问密码--restart=always \ // 设置开机自启neo4j:3.5.35 //指定使用的镜像</code></pre></li></ul><p>挂载目录可根据实际情况替换，neo4j密码不设置，默认为：<code>neo4j</code>,  这里设置成：<code>123456</code> 。如果希望neo4j没有密码，</p><p>可以使用命令：<code>--env NEO4J_AUTH=none</code></p></li></ul><h2 id="3-浏览器访问测试"><a href="#3-浏览器访问测试" class="headerlink" title="3. 浏览器访问测试"></a>3. 浏览器访问测试</h2><p>浏览器访问地址：<a href="http://neo4j服务地址:7474/">http://Neo4j服务地址:7474</a></p><ul><li>数据库默认用户名：neo4j</li><li>密码：启动命令设置的密码</li></ul><p><img src="https://raw.githubusercontent.com/GeorgeChan95/blogimg/master/img/2024/10/17/20241017-162812.png" alt="登录Neo4j"></p><h2 id="4-Neo4j配置文件解读"><a href="#4-Neo4j配置文件解读" class="headerlink" title="4. Neo4j配置文件解读"></a>4. Neo4j配置文件解读</h2><p>宿主机目录：<code>/opt/module/neo4j/conf/neo4j.conf</code></p><p>启动后，配置文件会自动创建到挂在目录，默认内容如下：</p><pre><code class="highlight shell"><span class="meta prompt_"># </span><span class="language-bash">事务保留策略，超过100MB会进行轮换</span>dbms.tx_log.rotation.retention_policy=100M size<span class="meta prompt_"># </span><span class="language-bash">设置了 Neo4j 的页面缓存大小为 512MB，页面缓存用于存储从磁盘加载到内存中的节点和关系数据，以提高数据库查询的性能。</span>dbms.memory.pagecache.size=512M<span class="meta prompt_"></span><span class="meta prompt_"># </span><span class="language-bash">允许任何ip连接到数据库</span>dbms.connectors.default_listen_address=0.0.0.0<span class="meta prompt_"># </span><span class="language-bash">https请求的监听 地址:端口</span>dbms.connector.https.listen_address=0.0.0.0:7473<span class="meta prompt_"></span><span class="meta prompt_"># </span><span class="language-bash">http请求的监听 地址:端口</span>dbms.connector.http.listen_address=0.0.0.0:7474<span class="meta prompt_"># </span><span class="language-bash">bolt请求的监听 地址:端口</span>dbms.connector.bolt.listen_address=0.0.0.0:7687<span class="meta prompt_"># </span><span class="language-bash">这是一个 Java 运行时参数，表明 Neo4j 是运行在 Docker 环境下的</span>wrapper.java.additional=-Dneo4j.ext.udc.source=docker<span class="meta prompt_"># </span><span class="language-bash">指定了 Neo4j 日志文件的存储目录为 /logs</span>dbms.directories.logs=/logs</code></pre><h1 id="二、CSV数据的导入导出"><a href="#二、CSV数据的导入导出" class="headerlink" title="二、CSV数据的导入导出"></a>二、CSV数据的导入导出</h1><h2 id="1-数据准备"><a href="#1-数据准备" class="headerlink" title="1. 数据准备"></a>1. 数据准备</h2><p>上面只是通过docker启动了一个Neo4j数据库实例，此时还没有数据，在演示neo4j数据的导入、导出之前，需要先模拟一些数据到Neo4j中。</p><pre><code class="highlight shell"><span class="meta prompt_"># </span><span class="language-bash">删除所有的节点和关系</span> MATCH(n) OPTIONAL MATCH (n)-[r]-() DELETE n,r;<span class="meta prompt_">  </span><span class="meta prompt_"># </span><span class="language-bash">创建Person 的节点</span> CREATE (person:Person &#123;cid:1,name:&quot;范闲&quot;,age:24,gender:0,character:&quot;A&quot;,money:1000,description:&quot;范闲，是猫腻小说《庆余年》主人公，穿越人士，庆国数十年风雨画卷的见证者。其容貌俊美无双，尤胜于女子，生性淡薄刚毅，善良而腹黑，城府极深，重视恩情。最终隐居江南&quot;&#125;);CREATE (person:Person &#123;cid:2,name:&quot;林婉儿&quot;,age:20,gender:1,character:&quot;B&quot;,money:800,description:&quot;林婉儿是庆国宰相和长公主的私生女，电视剧《庆余年》里的女主人公，由李沁饰演&quot;&#125;);CREATE (person:Person &#123;cid:3,name:&quot;庆帝&quot;,age:49,gender:0,character:&quot;A&quot;,money:8900,description:&quot;庆帝，网文作家猫腻所著的权谋小说《庆余年》的角色之一，南庆国的皇帝，心中装有天下统一&quot;&#125;);CREATE (person:Person &#123;cid:4,name:&quot;长公主&quot;,age:46,gender:1,character:&quot;B&quot;,money:3700,description:&quot;《庆余年》中,长公主这个人不仅人设很复杂,就连她的感情生活还是挺复杂。长公主所处的身份就是庆国的公主,皇帝的妹妹,太子的姑姑,国家重要财权的掌管,林婉儿的母亲&quot;&#125;);CREATE (person:Person &#123;cid:5,name:&quot;宰相林若甫&quot;,age:47,gender:0,character:&quot;A&quot;,money:1600,description:&quot;林若甫，是电视剧《庆余年》登场的虚拟人物之一，南庆当朝宰相，林婉儿的亲生父亲。&quot;&#125;);CREATE (person:Person &#123;cid:6,name:&quot;叶灵儿&quot;,age:20,gender:1,character:&quot;C&quot;,money:700,description:&quot;叶灵儿，网文作家猫腻所著的权谋小说《庆余年》的角色之一，林婉儿的好友，最后嫁给了二皇子&quot;&#125;);CREATE (person:Person &#123;cid:7,name:&quot;九品射手燕小乙&quot;,age:47,gender:0,character:&quot;C&quot;,money:900,description:&quot;一品最低,九品最高。庆帝身边的燕小乙便是九品,而且是庆国独一无二的神射手,臂力、眼力、听力惊人&quot;&#125;);CREATE (person:Person &#123;cid:8,name:&quot;二皇子&quot;,age:26,gender:0,character:&quot;B&quot;,money:1700,description:&quot;《庆余年》中,二皇子结局自杀身亡。二皇子对庆帝也是意见很大,但以他的实力还掀不起什么水花,所以只能慢慢等待时机&quot;&#125;);CREATE (person:Person &#123;cid:9,name:&quot;靖王世子&quot;,age:25,gender:0,character:&quot;A&quot;,money:1600,description:&quot;在《庆余年》中,此靖王非彼靖王,但是同音之美也会让人会对靖王世子李弘成这个角色产生好感,而靖王世子李弘成的出场的确是帮助了范闲逃脱太子势力的纠缠&quot;&#125;);CREATE (person:Person &#123;cid:10,name:&quot;王启年&quot;,age:46,gender:0,character:&quot;C&quot;,money:1700,description:&quot;王启年，网文作家猫腻所著的权谋小说《庆余年》的角色之一，庆国监察院一处的文书，擅长追踪之术。&quot;&#125;);CREATE (person:Person &#123;cid:11,name:&quot;北齐圣女海棠朵朵&quot;,age:21,gender:1,character:&quot;A&quot;,money:2600,description:&quot;海棠朵朵是北齐国的才女,被人尊称为圣女,而且是北齐大宗师苦荷的关门弟子,在北齐国也算是举足轻重的人物&quot;&#125;);CREATE (person:Person &#123;cid:12,name:&quot;北齐小皇帝战豆豆&quot;,age:20,gender:0,character:&quot;A&quot;,money:4600,description:&quot;很多人想知道剧中的北齐小皇帝是谁呢?让小编告诉你们吧。 战豆豆是北齐第二任皇帝,乃前北魏一代大将战清风之孙,大宗师苦荷的叔侄女兼徒孙&quot;&#125;);<span class="meta prompt_"></span><span class="meta prompt_"># </span><span class="language-bash">创建关系</span> match(person:Person &#123;name:&quot;范闲&quot;&#125;),(person2:Person &#123;name:&quot;林婉儿&quot;&#125;) create(person)-[r:Couple]-&gt;(person2);match(person:Person &#123;name:&quot;范闲&quot;&#125;),(person2:Person &#123;name:&quot;王启年&quot;&#125;) create(person)-[r:Friends]-&gt;(person2);match(person:Person &#123;name:&quot;范闲&quot;&#125;),(person2:Person &#123;name:&quot;北齐圣女海棠朵朵&quot;&#125;) create(person)-[r:Friends]-&gt;(person2);match(person:Person &#123;name:&quot;范闲&quot;&#125;),(person2:Person &#123;name:&quot;庆帝&quot;&#125;) create(person)-[r:Father]-&gt;(person2);match(person:Person &#123;name:&quot;范闲&quot;&#125;),(person2:Person &#123;name:&quot;长公主&quot;&#125;) create(person)-[r:Wife_Mother]-&gt;(person2);match(person:Person &#123;name:&quot;庆帝&quot;&#125;),(person2:Person &#123;name:&quot;二皇子&quot;&#125;) create(person)-[r:Son]-&gt;(person2);match(person:Person &#123;name:&quot;庆帝&quot;&#125;),(person2:Person &#123;name:&quot;长公主&quot;&#125;) create(person)-[r:BrotherSister]-&gt;(person2);match(person:Person &#123;name:&quot;二皇子&quot;&#125;),(person2:Person &#123;name:&quot;靖王世子&quot;&#125;) create(person)-[r:Friends]-&gt;(person2);match(person:Person &#123;name:&quot;北齐圣女海棠朵朵&quot;&#125;),(person2:Person &#123;name:&quot;北齐小皇帝战豆豆&quot;&#125;) create(person)-[r:Friends]-&gt;(person2);match(person:Person &#123;name:&quot;林婉儿&quot;&#125;),(person2:Person &#123;name:&quot;叶灵儿&quot;&#125;) create(person)-[r:Friends]-&gt;(person2);match(person:Person &#123;name:&quot;林婉儿&quot;&#125;),(person2:Person &#123;name:&quot;宰相林若甫&quot;&#125;) create(person)-[r:Father]-&gt;(person2);match(person:Person &#123;name:&quot;林婉儿&quot;&#125;),(person2:Person &#123;name:&quot;长公主&quot;&#125;) create(person)-[r:Mother]-&gt;(person2);match(person:Person &#123;name:&quot;长公主&quot;&#125;),(person2:Person &#123;name:&quot;九品射手燕小乙&quot;&#125;) create(person)-[r:Friends]-&gt;(person2);</code></pre><p>将上面的CQL语句，复制到Neo4j执行语句输入框中，注意：不能有注释内容。</p><p><img src="https://raw.githubusercontent.com/GeorgeChan95/blogimg/master/img/2024/10/17/20241017-184620.png" alt="Neo4j数据初始化"></p><h2 id="2-安装-apoc-插件"><a href="#2-安装-apoc-插件" class="headerlink" title="2. 安装 apoc 插件"></a>2. 安装 apoc 插件</h2><p>APOC（Awesome Procedures on Cypher）是Neo4j图数据库的一个插件，它提供了一组强大的过程和函数，扩展了Cypher查询语言的功能。APOC可以帮助你进行更高级的数据处理和操作，例如导入和导出数据、动态创建节点和关系、执行事务操作等。</p><p>使用APOC插件需要先下载并安装它，然后在Neo4j的配置文件中启用它。一旦启用，你就可以在Cypher查询中使用APOC提供的各种过程和函数了。</p><h3 id="2-1-下载插件"><a href="#2-1-下载插件" class="headerlink" title="2.1  下载插件"></a>2.1  下载插件</h3><p>neo4j这里使用的是 3.5社区版，所以 apoc 插件也选择3.5版本的。</p><p>下载地址：<a href="https://github.com/neo4j-contrib/neo4j-apoc-procedures/releases">https://github.com/neo4j-contrib/neo4j-apoc-procedures/releases</a></p><p>找到对应的版本后，下载到服务器的 plugins 文件夹中</p><p><img src="https://raw.githubusercontent.com/GeorgeChan95/blogimg/master/img/2024/10/17/20241017-190711.png" alt="apoc插件下载"></p><p>Neo4j的插件安装目录在 <code>plugins</code> 路径下，Docker部署Neo4j时，将宿主机 <code>/opt/module/neo4j/plugins</code> 目录映射到了neo4j的插件安装目录： <code>/var/lib/neo4j/plugins</code>， 因此需要将 apoc 插件下载到此目录中，无需解压。</p><pre><code class="highlight shell">root@csg-pc1:/opt/module/neo4j/plugins# pwd/opt/module/neo4j/pluginsroot@csg-pc1:/opt/module/neo4j/plugins# lsapoc-3.5.0.21-all.jar<span class="meta prompt_"></span><span class="meta prompt_"># </span><span class="language-bash">修改插件jar包的权限(添加执行权限)</span>chmod 755 apoc-3.5.0.21-all.jar</code></pre><h3 id="2-2-修改配置文件"><a href="#2-2-修改配置文件" class="headerlink" title="2.2 修改配置文件"></a>2.2 修改配置文件</h3><p>修改neo4j配置文件 <code>neo4j.conf</code> , 修改内容如下：</p><pre><code class="highlight shell"><span class="meta prompt_"># </span><span class="language-bash">neo4j插件安装路径</span>dbms.directories.plugins=plugins<span class="meta prompt_"># </span><span class="language-bash">配置安全白名单，指定允许所有apoc开头的存储过程</span>dbms.security.procedures.whitelist=apoc.coll.*,apoc.load.*,apoc.*,gds.*<span class="meta prompt_"># </span><span class="language-bash">放宽apoc权限</span>dbms.security.procedures.unrestricted=apoc.*,algo.*<span class="meta prompt_"># </span><span class="language-bash">指定了 Neo4j 的数据导入目录</span>dbms.directories.import=import<span class="meta prompt_"># </span><span class="language-bash">开启文件导出功能</span>apoc.export.file.enabled=true<span class="meta prompt_"># </span><span class="language-bash">开启文件导入功能</span>apoc.import.file.enabled=true</code></pre><h3 id="2-3-测试apoc插件是否安装-成功"><a href="#2-3-测试apoc插件是否安装-成功" class="headerlink" title="2.3  测试apoc插件是否安装 成功"></a>2.3  测试apoc插件是否安装 成功</h3><p>在浏览器中，执行 cypher-shell：</p><pre><code class="highlight cypher">return apoc.version();</code></pre><p><img src="https://raw.githubusercontent.com/GeorgeChan95/blogimg/master/img/2024/10/17/20241017-192551.png" alt="验证插件安装"></p><h2 id="3-导出CSV数据"><a href="#3-导出CSV数据" class="headerlink" title="3. 导出CSV数据"></a>3. 导出CSV数据</h2><h3 id="3-1-开始导出"><a href="#3-1-开始导出" class="headerlink" title="3.1 开始导出"></a>3.1 开始导出</h3><p>neo4j 官方文档有说明，使用 neo4j-admin restore &#x2F; dump 导出和恢复数据库的时候需要停掉数据，否则会报数据库正在使用的错误：</p><blockquote><p>command failed: the database is in use — stop Neo4j and try again</p></blockquote><p>但问题是docker容器中是没办法停止neo4j进程的，现在进入容器shudown的话，neo4j容器会停掉（docker-run）或者重启数据库（docker-compose），所以这里采用的迂回的方法：</p><ul><li><p>首先停掉neo4j容器</p><pre><code class="highlight shell">docker stop neo4j</code></pre></li><li><p>启动一个带有TTY新的容器，使用-v参数挂载data目录</p><pre><code class="highlight shell">docker run -it \    --name neo4j-tmp \    -p 7474:7474 -p 7687:7687 \    -v /opt/module/neo4j/data:/data \    -v /opt/module/neo4j/conf:/var/lib/neo4j/conf \    -v /opt/module/neo4j/import:/var/lib/neo4j/import \    -v /opt/module/neo4j/plugins:/var/lib/neo4j/plugins \    --restart=always \    neo4j:3.5.35 /bin/bash</code></pre></li><li><p>以console方式启动neo4j容器</p><p>这里有个坑，如果不用 <code>console</code> 启动容器， 而是使用 <code>bin/neo4j start</code> 启动临时neo4j容器，导出的csv文件格式有问题，会导入不了。</p><pre><code class="highlight shell">bin/neo4j console</code></pre></li><li><p>导出CSV文件</p><p>在浏览器 Neo4j 的 <code>cypher-shell</code> 输入框中执行语句</p><ul><li><p>方式一：批量导出全部数据到一个csv文件中, 【强烈不建议】</p><pre><code class="highlight cypher">// 导出全部数据（包括了节点和关系）[这个不常用，了解就行]CALL apoc.export.csv.all(&quot;database-all-data.csv&quot;, &#123;&#125;);</code></pre></li><li><p>方式二：批量导出全部数据，但是会自动将 <code>节点数据</code> 和 <code>关系数据 </code> 自动分到不同到文件中 【本文采用的就是这种方式】</p></li></ul><pre><code class="highlight cypher">// 批量导出【建议用这个，亲测可行】CALL apoc.export.csv.all(  &quot;all.csv&quot;, // 文件名和类型，也可以是txt格式   &#123;     quotes:&#x27;none&#x27;, // 导出的文件中没有引号    useTypes:true, //  useTypes参数表明输出时是否表明type类型是node还是relationship    bulkImport:true, // 导出的数据，就按照nodes和relationships分开    delim: &quot;$&quot; // 指定导出数据分割符号   &#125;)</code></pre><ul><li><p>方式三：手动导出节点数据和关系数据</p><pre><code class="highlight cypher">// 导出所有节点数据，忽略关系MATCH (person:Person)WITH collect(person) AS peopleCALL apoc.export.csv.query(    &quot;MATCH (p:Person) RETURN id(p) AS `:ID`, p.name AS `name`, p.age AS `age:long`, p.cid AS `cid:long`, p.character AS `character`, p.money AS `money:long`, p.gender AS `gender:long`, p.description AS `description`, head(labels(p)) AS `:LABEL`&quot;,     &quot;all_nodes.csv&quot;, // 导出的文件&#123;    quotes:&#x27;none&#x27;, // 文件中没有引号    delim: &quot;$&quot;, // 指定导出数据的分割符号        useTypes:true, //  useTypes参数表明输出时是否表明type类型是node还是relationship        arrayDelim: &quot;;&quot;&#125;)YIELD file, source, format, nodes, relationships, properties, time, rows, batchSize, batches, done, dataRETURN file, source, format, nodes, relationships, properties, time, rows, batchSize, batches, done, data// 导出特定的关系数据，忽略节点MATCH (start)-[r:BrotherSister]-&gt;(end)WITH start, end, rCALL apoc.export.csv.query(    &quot;MATCH (start:Person)-[r:BrotherSister]-&gt;(end:Person) RETURN id(start) AS `:START_ID`, id(end) AS `:END_ID`, type(r) AS `:TYPE`&quot;,     &quot;BrotherSister.csv&quot;,&#123;    quotes:&#x27;none&#x27;, // 导出的文件中没有引号    useTypes:true, //  useTypes参数表明输出时是否表明type类型是node还是relationship    delim: &quot;$&quot; // 指定导出数据分割符号    &#125;)YIELD file, source, format, nodes, relationships, properties, time, rows, batchSize, batches, done, dataRETURN file, source, format, nodes, relationships, properties, time, rows, batchSize, batches, done, data</code></pre></li></ul></li></ul><p><img src="https://raw.githubusercontent.com/GeorgeChan95/blogimg/master/img/2024/10/17/20241017-192845.png" alt="导出所有数据"></p><p><img src="https://raw.githubusercontent.com/GeorgeChan95/blogimg/master/img/2024/10/18/20241018-141228.png" alt="导出全部数据，自动分割CSV文件"></p><h3 id="3-2-查看导出文件"><a href="#3-2-查看导出文件" class="headerlink" title="3.2 查看导出文件"></a>3.2 查看导出文件</h3><ul><li><p>导出文件在neo4j的 <code>import</code> 文件夹中，映射到宿主机：<code>/opt/module/neo4j/import</code> 路径，查看该路径：</p><pre><code class="highlight shell">root@csg-pc1:/opt/module/neo4j/import# pwd/opt/module/neo4j/importroot@csg-pc1:/opt/module/neo4j/import# lsall.nodes.Person.csvall.relationships.BrotherSister.csvall.relationships.Couple.csvall.relationships.Father.csvall.relationships.Friends.csvall.relationships.Mother.csvall.relationships.Son.csvall.relationships.Wife_Mother.csv</code></pre></li><li><p>查看CSV文件</p><p>虽然CSV文件可以用wps、office等工具查看和修改，但是还是如果需要修改的话，用 nodepad++、vsCode等相对简单的文本编辑工具，如果不小心修改了文件编码，或者wps等工具在保存时修改了格式，CSV文件导入就会报错。</p><p>文件要使用UTF-8编码，这也是默认的编码格式。</p><p><img src="https://raw.githubusercontent.com/GeorgeChan95/blogimg/master/img/2024/10/18/20241018-142107.png" alt="节点数据"></p><p><img src="https://raw.githubusercontent.com/GeorgeChan95/blogimg/master/img/2024/10/18/20241018-142132.png" alt="关系数据"></p></li></ul><h2 id="4-导入CSV数据"><a href="#4-导入CSV数据" class="headerlink" title="4. 导入CSV数据"></a>4. 导入CSV数据</h2><p>前面已经将neo4j数据导出到一个个 CSV 文件中了，导入数据也使用 APOC 插件，但是不需要在 <code>bin/neo4j console</code> 启动环境中导入。可以退出并删除临时容器，启动原有的 ne4j 容器。</p><ul><li><p>删除临时容器</p><pre><code class="highlight shell"><span class="meta prompt_"># </span><span class="language-bash">删除临时容器</span>docker rm -f neo4j-tmp</code></pre></li><li><p>启动原neo4j容器</p><pre><code class="highlight shell">docker start neo4j</code></pre></li><li><p>清空数据库</p><p>在浏览器 Neo4j 的 <code>cypher-shell</code> 输入框中执行语句</p><pre><code class="highlight cypher">MATCH(n) OPTIONAL MATCH (n)-[r]-() DELETE n,r;</code></pre></li><li><p>将导出的csv文件拷贝到neo4j的 import 文件夹中</p></li><li><p>使用 APOC 插件导入CSV文件</p><p>在浏览器 Neo4j 的 <code>cypher-shell</code> 输入框中执行语句</p><pre><code class="highlight shell"><span class="meta prompt_"># </span><span class="language-bash">方式一：批量导入节点和节点的关系【本文使用的导入方式】</span>CALL apoc.import.csv(  [  &#123;fileName: &#x27;file:/all.nodes.Person.csv&#x27;, labels: [&#x27;Person&#x27;]&#125;  ],  [  &#123;fileName: &#x27;file:/all.relationships.Mother.csv&#x27;, type: &#x27;relationships&#x27;&#125;,  &#123;fileName: &#x27;file:/all.relationships.BrotherSister.csv&#x27;, type: &#x27;relationships&#x27;&#125;,  &#123;fileName: &#x27;file:/all.relationships.Couple.csv&#x27;, type: &#x27;relationships&#x27;&#125;,  &#123;fileName: &#x27;file:/all.relationships.Father.csv&#x27;, type: &#x27;relationships&#x27;&#125;,  &#123;fileName: &#x27;file:/all.relationships.Friends.csv&#x27;, type: &#x27;relationships&#x27;&#125;,  &#123;fileName: &#x27;file:/all.relationships.Son.csv&#x27;, type: &#x27;relationships&#x27;&#125;,  &#123;fileName: &#x27;file:/all.relationships.Wife_Mother.csv&#x27;, type: &#x27;relationships&#x27;&#125;  ],  &#123;  delimiter: &#x27;$&#x27;, // 指定数据分隔符，导出时用的是$符号，导入也得用它  arrayDelimiter: &#x27;;&#x27;,  // 指定数组元素分隔符，默认：;  stringIds: false  &#125;)</code></pre><p><img src="https://raw.githubusercontent.com/GeorgeChan95/blogimg/master/img/2024/10/18/20241018-142912.png" alt="批量导入节点和节点的关系"></p><ul><li>方式二，单独导入节点和关系</li></ul><pre><code class="highlight cypher">// 只导入节点，不导入关系CALL apoc.import.csv(  [  &#123;fileName: &#x27;file:/all_nodes.csv&#x27;, labels: [&#x27;Person&#x27;]&#125;  ],  [],  // 没有关系要在这个步骤中导入  &#123;  delimiter: &#x27;$&#x27;, // 指定数据分隔符，导出时用的是$符号，导入也得用它  arrayDelimiter: &#x27;;&#x27;,  // 指定数组元素分隔符，默认：;  stringIds: false  &#125;)// 只导入关系，不导入节点（我试了，不行，报空指针）CALL apoc.import.csv(  [],  [  &#123;fileName: &#x27;file:/BrotherSister.csv&#x27;, type: &#x27;BrotherSister&#x27;&#125;  ],  &#123;  delimiter: &#x27;$&#x27;, // 指定数据分隔符，导出时用的是$符号，导入也得用它  arrayDelimiter: &#x27;;&#x27;,  // 指定数组元素分隔符，默认：;  stringIds: false  &#125;)// 同时导入节点和关系（可以）CALL apoc.import.csv(  [  &#123;fileName: &#x27;file:/all_nodes.csv&#x27;, labels: [&#x27;Person&#x27;]&#125;  ],  [&#123;fileName: &#x27;file:/BrotherSister.csv&#x27;, type: &#x27;BrotherSister&#x27;&#125;],  // 没有关系要在这个步骤中导入  &#123;  delimiter: &#x27;$&#x27;, // 指定数据分隔符，导出时用的是$符号，导入也得用它  arrayDelimiter: &#x27;;&#x27;,  // 指定数组元素分隔符，默认：;  stringIds: false  &#125;)</code></pre></li></ul><p><strong>总结</strong></p><p>neo4j数据的导出、导入坑很多，相对资料又比较少，以上都是亲自测试的可行方案。</p><p>如今neo4j已经出到 5.x 版本了，这篇还是使用的 3.5 版本，主要是因为算法部门他们训练和测试使用的是这个版本，与他们保持一致，后续有时间的话再研究一下新版本。</p><p><strong>参考链接</strong></p><blockquote><p><a href="https://blog.naughtyfox.top/neo4j%E7%9A%84%E5%AF%BC%E5%85%A5%E4%B8%8E%E5%AF%BC%E5%87%BA/#3-4-import-csv%E6%96%87%E4%BB%B6">https://blog.naughtyfox.top/neo4j%E7%9A%84%E5%AF%BC%E5%85%A5%E4%B8%8E%E5%AF%BC%E5%87%BA/#3-4-import-csv%E6%96%87%E4%BB%B6</a></p><p><a href="https://www.cnblogs.com/caoyusang/p/13610408.html">https://www.cnblogs.com/caoyusang/p/13610408.html</a></p><p><a href="https://www.cnblogs.com/Iven-L/p/17978724">https://www.cnblogs.com/Iven-L/p/17978724</a></p></blockquote>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;&lt;strong&gt;系统环境&lt;/strong&gt;&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;操作系统：Ubuntu18.04.6&lt;/p&gt;
&lt;p&gt;Docker：24.0.2&lt;/p&gt;
&lt;p&gt;Neo4j: 3.5.35(社区版)&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h1 id=&quot;一、下</summary>
      
    
    
    
    <category term="neo4j" scheme="https://georgechan95.github.io/categories/neo4j/"/>
    
    
    <category term="linux" scheme="https://georgechan95.github.io/tags/linux/"/>
    
    <category term="neo4j" scheme="https://georgechan95.github.io/tags/neo4j/"/>
    
  </entry>
  
  <entry>
    <title>Ubuntu18.04离线源环境搭建</title>
    <link href="https://georgechan95.github.io/blog/ad38e6b1.html"/>
    <id>https://georgechan95.github.io/blog/ad38e6b1.html</id>
    <published>2024-10-17T01:47:33.000Z</published>
    <updated>2024-10-17T05:46:20.411Z</updated>
    
    <content type="html"><![CDATA[<p><strong>系统环境</strong></p><blockquote><p>系统发行版：Ubuntu 18.04.6 LTS</p><p>内核版本：5.4.0-150-generic</p></blockquote><p><strong>注意事项</strong></p><p>使用此方式制作的离线源只能在相同的系统版本下用于离线的环境安装，即：Ubuntu18.04系统环境下制作的离线源，不能用于Ubuntu20.04系统的离线环境安装，如果环境不同可能导致在离线电脑上安装时会缺少部分依赖导致安装失败。</p><h1 id="一、制作离线源（可连外网）"><a href="#一、制作离线源（可连外网）" class="headerlink" title="一、制作离线源（可连外网）"></a>一、制作离线源（可连外网）</h1><p>先在一台可以连接外网的Ubuntu18.04服务器制作离线源环境。</p><ul><li><p>创建离线源目录</p><pre><code class="highlight shell">mkdir -p /opt/offline<span class="meta prompt_"></span><span class="meta prompt_"># </span><span class="language-bash">修改权限</span>chmod 777 -R /opt/offline/</code></pre><p>后面所有的安装包都会放到此目录，及子目录下。</p></li><li><p>安装 dpkg-dev 工具</p><pre><code class="highlight shell">apt-get install -y dpkg-dev</code></pre></li><li><p>备份系统目录的安装包</p><pre><code class="highlight shell"><span class="meta prompt_"># </span><span class="language-bash">创建安装包备份目录</span>mkdir -p /opt/offline/default/archives<span class="meta prompt_"></span><span class="meta prompt_"># </span><span class="language-bash">文件迁移</span>mv /var/cache/apt/archives/* /opt/offline/default/archives/<span class="meta prompt_"></span><span class="meta prompt_"># </span><span class="language-bash">删除源安装包</span>rm -rf /var/cache/apt/archives/*</code></pre></li></ul><p>下面演示常用软件离线源制作</p><h2 id="1-ssh"><a href="#1-ssh" class="headerlink" title="1. ssh"></a>1. ssh</h2><pre><code class="highlight shell">mkdir -p /opt/offline/ssh/archives/cd /opt/offline/ssh/archives/sudo apt-get download $(apt-cache depends --recurse --no-recommends --no-suggests --no-conflicts --no-breaks --no-replaces --no-enhances openssh-client openssh-server openssh-sftp-server | grep &quot;^\w&quot; | sort -u)cd ..<span class="meta prompt_"></span><span class="meta prompt_">#</span><span class="language-bash">带上-m，会将所有包全部建立依赖关系到 Packages.gz中，如此会有重复，但无需剔除重复的包</span>sudo dpkg-scanpackages -m . /dev/null | gzip -9c &gt; Packages.gz<span class="meta prompt_"></span><span class="meta prompt_"># </span><span class="language-bash">复制依赖关系文件到archives中</span>cp Packages.gz ./archives<span class="meta prompt_"></span><span class="meta prompt_"># </span><span class="language-bash">删除外部的依赖关系文件</span>rm -rf /opt/offline/ssh/Packages.gz</code></pre><h2 id="2-vim"><a href="#2-vim" class="headerlink" title="2. vim"></a>2. vim</h2><pre><code class="highlight shell">mkdir -p /opt/offline/vim/archives/cd /opt/offline/vim/archives/sudo apt-get download $(apt-cache depends --recurse --no-recommends --no-suggests --no-conflicts --no-breaks --no-replaces --no-enhances vim | grep &quot;^\w&quot; | sort -u)cd ..<span class="meta prompt_"></span><span class="meta prompt_">#</span><span class="language-bash">带上-m，会将所有包全部建立依赖关系到 Packages.gz中，如此会有重复，但无需剔除重复的包</span>sudo dpkg-scanpackages -m . /dev/null | gzip -9c &gt; Packages.gz<span class="meta prompt_"> </span><span class="meta prompt_"># </span><span class="language-bash">复制依赖关系文件到archives中,并删除无用的依赖关系文件</span>cp Packages.gz ./archives &amp;&amp; rm -rf /opt/offline/vim/Packages.gz</code></pre><h2 id="3-curl"><a href="#3-curl" class="headerlink" title="3. curl"></a>3. curl</h2><pre><code class="highlight shell">mkdir -p /opt/offline/curl/archives/cd /opt/offline/curl/archives/sudo apt-get download $(apt-cache depends --recurse --no-recommends --no-suggests --no-conflicts --no-breaks --no-replaces --no-enhances curl | grep &quot;^\w&quot; | sort -u)cd ..<span class="meta prompt_"></span><span class="meta prompt_">#</span><span class="language-bash">带上-m，会将所有包全部建立依赖关系到 Packages.gz中，如此会有重复，但无需剔除重复的包</span>sudo dpkg-scanpackages -m . /dev/null | gzip -9c &gt; Packages.gz<span class="meta prompt_"> </span><span class="meta prompt_"># </span><span class="language-bash">复制依赖关系文件到archives中,并删除无用的依赖关系文件</span>cp Packages.gz ./archives &amp;&amp; rm -rf /opt/offline/curl/Packages.gz</code></pre><h2 id="4-wget"><a href="#4-wget" class="headerlink" title="4. wget"></a>4. wget</h2><pre><code class="highlight shell">mkdir -p /opt/offline/wget/archives/cd /opt/offline/wget/archives/sudo apt-get download $(apt-cache depends --recurse --no-recommends --no-suggests --no-conflicts --no-breaks --no-replaces --no-enhances wget | grep &quot;^\w&quot; | sort -u)cd ..<span class="meta prompt_"></span><span class="meta prompt_">#</span><span class="language-bash">带上-m，会将所有包全部建立依赖关系到 Packages.gz中，如此会有重复，但无需剔除重复的包</span>sudo dpkg-scanpackages -m . /dev/null | gzip -9c &gt; Packages.gz<span class="meta prompt_"> </span><span class="meta prompt_"># </span><span class="language-bash">复制依赖关系文件到archives中,并删除无用的依赖关系文件</span>cp Packages.gz ./archives &amp;&amp; rm -rf /opt/offline/wget/Packages.gz</code></pre><h2 id="5-unzip"><a href="#5-unzip" class="headerlink" title="5. unzip"></a>5. unzip</h2><pre><code class="highlight shell">mkdir -p /opt/offline/unzip/archives/cd /opt/offline/unzip/archives/sudo apt-get download $(apt-cache depends --recurse --no-recommends --no-suggests --no-conflicts --no-breaks --no-replaces --no-enhances unzip | grep &quot;^\w&quot; | sort -u)cd ..<span class="meta prompt_"></span><span class="meta prompt_">#</span><span class="language-bash">带上-m，会将所有包全部建立依赖关系到 Packages.gz中，如此会有重复，但无需剔除重复的包</span>sudo dpkg-scanpackages -m . /dev/null | gzip -9c &gt; Packages.gz<span class="meta prompt_"> </span><span class="meta prompt_"># </span><span class="language-bash">复制依赖关系文件到archives中,并删除无用的依赖关系文件</span>cp Packages.gz ./archives &amp;&amp; rm -rf /opt/offline/unzip/Packages.gz</code></pre><h2 id="6-net-tools"><a href="#6-net-tools" class="headerlink" title="6. net-tools"></a>6. net-tools</h2><pre><code class="highlight shell">mkdir -p /opt/offline/net-tools/archives/cd /opt/offline/net-tools/archives/sudo apt-get download $(apt-cache depends --recurse --no-recommends --no-suggests --no-conflicts --no-breaks --no-replaces --no-enhances net-tools | grep &quot;^\w&quot; | sort -u)cd ..<span class="meta prompt_"></span><span class="meta prompt_">#</span><span class="language-bash">带上-m，会将所有包全部建立依赖关系到 Packages.gz中，如此会有重复，但无需剔除重复的包</span>sudo dpkg-scanpackages -m . /dev/null | gzip -9c &gt; Packages.gz<span class="meta prompt_"> </span><span class="meta prompt_"># </span><span class="language-bash">复制依赖关系文件到archives中,并删除无用的依赖关系文件</span>cp Packages.gz ./archives &amp;&amp; rm -rf /opt/offline/net-tools/Packages.gz</code></pre><h2 id="7-ffmpeg"><a href="#7-ffmpeg" class="headerlink" title="7. ffmpeg"></a>7. ffmpeg</h2><pre><code class="highlight shell">mkdir -p /opt/offline/ffmpeg/archives/cd /opt/offline/ffmpeg/archives/sudo apt-get download $(apt-cache depends --recurse --no-recommends --no-suggests --no-conflicts --no-breaks --no-replaces --no-enhances ffmpeg | grep &quot;^\w&quot; | sort -u)cd ..<span class="meta prompt_"></span><span class="meta prompt_">#</span><span class="language-bash">带上-m，会将所有包全部建立依赖关系到 Packages.gz中，如此会有重复，但无需剔除重复的包</span>sudo dpkg-scanpackages -m . /dev/null | gzip -9c &gt; Packages.gz<span class="meta prompt_"> </span><span class="meta prompt_"># </span><span class="language-bash">复制依赖关系文件到archives中,并删除无用的依赖关系文件</span>cp Packages.gz ./archives &amp;&amp; rm -rf /opt/offline/ffmpeg/Packages.gz</code></pre><h2 id="8-ntp"><a href="#8-ntp" class="headerlink" title="8. ntp"></a>8. ntp</h2><pre><code class="highlight shell">mkdir -p /opt/offline/ntp/archives/cd /opt/offline/ntp/archives/sudo apt-get download $(apt-cache depends --recurse --no-recommends --no-suggests --no-conflicts --no-breaks --no-replaces --no-enhances ntp ntpdate | grep &quot;^\w&quot; | sort -u)cd ..<span class="meta prompt_"></span><span class="meta prompt_">#</span><span class="language-bash">带上-m，会将所有包全部建立依赖关系到 Packages.gz中，如此会有重复，但无需剔除重复的包</span>sudo dpkg-scanpackages -m . /dev/null | gzip -9c &gt; Packages.gz<span class="meta prompt_"> </span><span class="meta prompt_"># </span><span class="language-bash">复制依赖关系文件到archives中,并删除无用的依赖关系文件</span>cp Packages.gz ./archives &amp;&amp; rm -rf /opt/offline/ntp/Packages.gz</code></pre><h2 id="9-apt-transport-https"><a href="#9-apt-transport-https" class="headerlink" title="9. apt-transport-https"></a>9. apt-transport-https</h2><pre><code class="highlight shell">mkdir -p /opt/offline/apt-transport-https/archives/cd /opt/offline/apt-transport-https/archives/sudo apt-get download $(apt-cache depends --recurse --no-recommends --no-suggests --no-conflicts --no-breaks --no-replaces --no-enhances apt-transport-https | grep &quot;^\w&quot; | sort -u)cd ..<span class="meta prompt_"></span><span class="meta prompt_">#</span><span class="language-bash">带上-m，会将所有包全部建立依赖关系到 Packages.gz中，如此会有重复，但无需剔除重复的包</span>sudo dpkg-scanpackages -m . /dev/null | gzip -9c &gt; Packages.gz<span class="meta prompt_"> </span><span class="meta prompt_"># </span><span class="language-bash">复制依赖关系文件到archives中,并删除无用的依赖关系文件</span>cp Packages.gz ./archives &amp;&amp; rm -rf /opt/offline/apt-transport-https/Packages.gz</code></pre><h2 id="10-ca-certificates"><a href="#10-ca-certificates" class="headerlink" title="10. ca-certificates"></a>10. ca-certificates</h2><pre><code class="highlight shell">mkdir -p /opt/offline/ca-certificates/archives/cd /opt/offline/ca-certificates/archives/sudo apt-get download $(apt-cache depends --recurse --no-recommends --no-suggests --no-conflicts --no-breaks --no-replaces --no-enhances ca-certificates | grep &quot;^\w&quot; | sort -u)cd ..<span class="meta prompt_"></span><span class="meta prompt_">#</span><span class="language-bash">带上-m，会将所有包全部建立依赖关系到 Packages.gz中，如此会有重复，但无需剔除重复的包</span>sudo dpkg-scanpackages -m . /dev/null | gzip -9c &gt; Packages.gz<span class="meta prompt_"> </span><span class="meta prompt_"># </span><span class="language-bash">复制依赖关系文件到archives中,并删除无用的依赖关系文件</span>cp Packages.gz ./archives &amp;&amp; rm -rf /opt/offline/ca-certificates/Packages.gz</code></pre><h2 id="11-software-properties-common"><a href="#11-software-properties-common" class="headerlink" title="11. software-properties-common"></a>11. software-properties-common</h2><pre><code class="highlight shell">mkdir -p /opt/offline/software-properties-common/archives/cd /opt/offline/software-properties-common/archives/sudo apt-get download $(apt-cache depends --recurse --no-recommends --no-suggests --no-conflicts --no-breaks --no-replaces --no-enhances software-properties-common | grep &quot;^\w&quot; | sort -u)cd ..<span class="meta prompt_"></span><span class="meta prompt_">#</span><span class="language-bash">带上-m，会将所有包全部建立依赖关系到 Packages.gz中，如此会有重复，但无需剔除重复的包</span>sudo dpkg-scanpackages -m . /dev/null | gzip -9c &gt; Packages.gz<span class="meta prompt_"> </span><span class="meta prompt_"># </span><span class="language-bash">复制依赖关系文件到archives中,并删除无用的依赖关系文件</span>cp Packages.gz ./archives &amp;&amp; rm -rf /opt/offline/software-properties-common/Packages.gz</code></pre><h2 id="12-docker"><a href="#12-docker" class="headerlink" title="12. docker"></a>12. docker</h2><p>docker的离线源制作稍稍复杂，需要GPG密钥，这里从阿里云下载Docker的GPG密钥，配置APT以从阿里云的Docker镜像仓库安装Docker.</p><ul><li><p>参考资料</p><blockquote><p><a href="https://help.aliyun.com/zh/ecs/use-cases/install-and-use-docker-on-a-linux-ecs-instance#33f11a5f1800n">安装Docker并使用</a></p></blockquote></li></ul><pre><code class="highlight shell">sudo apt-get update -y<span class="meta prompt_"></span><span class="meta prompt_"># </span><span class="language-bash">安装必要的包，包括证书、curl（用于数据传输）和gnupg（用于GPG密钥管理）。</span>sudo apt-get install -y ca-certificates curl gnupg<span class="meta prompt_"></span><span class="meta prompt_"># </span><span class="language-bash">创建一个目录/etc/apt/keyrings，并设置其权限为755。</span>sudo install -m 0755 -d /etc/apt/keyrings<span class="meta prompt_"></span><span class="meta prompt_"># </span><span class="language-bash">下载Docker的GPG密钥，并将其转换为适合APT使用的格式，保存到指定目录。</span>sudo curl -fsSL http://mirrors.aliyun.com/docker-ce/linux/ubuntu/gpg -o /etc/apt/keyrings/docker.asc<span class="meta prompt_"></span><span class="meta prompt_"># </span><span class="language-bash">为docker.gpg文件添加可读权限，以便所有用户都可以读取它。</span>sudo chmod a+r /etc/apt/keyrings/docker.asc<span class="meta prompt_"></span><span class="meta prompt_"># </span><span class="language-bash">将Docker的APT源添加到新的列表文件中，使用当前系统架构和版本代号。</span>echo \  &quot;deb [arch=$(dpkg --print-architecture) signed-by=/etc/apt/keyrings/docker.asc] http://mirrors.aliyun.com/docker-ce/linux/ubuntu \<span class="meta prompt_">  $</span><span class="language-bash">(. /etc/os-release &amp;&amp; <span class="built_in">echo</span> <span class="string">&quot;<span class="variable">$VERSION_CODENAME</span>&quot;</span>) stable<span class="string">&quot; | \</span></span><span class="string"><span class="language-bash">  sudo tee /etc/apt/sources.list.d/docker.list &gt; /dev/null</span></span><span class="meta prompt_">  </span><span class="meta prompt_"># </span><span class="language-bash"><span class="string">再次更新包索引，以包括刚添加的Docker源。</span></span>sudo apt-get update -y<span class="meta prompt_"></span><span class="meta prompt_"># </span><span class="language-bash"><span class="string">安装docker</span></span> sudo apt-get install -y docker-ce docker-ce-cli containerd.io<span class="meta prompt_"></span><span class="meta prompt_"># </span><span class="language-bash"><span class="string">查看docker版本信息</span></span>docker --version<span class="meta prompt_"></span><span class="meta prompt_"># </span><span class="language-bash"><span class="string">创建docker离线源安装包目录</span></span>mkdir -p /opt/offline/docker/archives/<span class="meta prompt_"></span><span class="meta prompt_"># </span><span class="language-bash"><span class="string">将docker安装时下载的缓存包，移动到离线源安装包路径中</span></span>mv /var/cache/apt/archives/* /opt/offline/docker/archives/cd /opt/offline/docker/<span class="meta prompt_"></span><span class="meta prompt_">#</span><span class="language-bash"><span class="string">带上-m，会将所有包全部建立依赖关系到 Packages.gz中，如此会有重复，但无需剔除重复的包</span></span>sudo dpkg-scanpackages -m . /dev/null | gzip -9c &gt; Packages.gz<span class="meta prompt_"> </span><span class="meta prompt_"># </span><span class="language-bash"><span class="string">复制依赖关系文件到archives中,并删除无用的依赖关系文件</span></span>cp Packages.gz ./archives &amp;&amp; rm -rf /opt/offline/docker/Packages.gz</code></pre><h2 id="13-nfs"><a href="#13-nfs" class="headerlink" title="13. nfs"></a>13. nfs</h2><p><a href="https://www.cnblogs.com/mrld/articles/14149708.html">https://www.cnblogs.com/mrld/articles/14149708.html</a></p><pre><code class="highlight shell">mkdir -p /opt/offline/nfs/archives/cd /opt/offline/nfs/archives/sudo apt-get download $(apt-cache depends --recurse --no-recommends --no-suggests --no-conflicts --no-breaks --no-replaces --no-enhances nfs-kernel-server nfs-common | grep &quot;^\w&quot; | sort -u)cd ..<span class="meta prompt_"></span><span class="meta prompt_">#</span><span class="language-bash">带上-m，会将所有包全部建立依赖关系到 Packages.gz中，如此会有重复，但无需剔除重复的包</span>sudo dpkg-scanpackages -m . /dev/null | gzip -9c &gt; Packages.gz<span class="meta prompt_"> </span><span class="meta prompt_"># </span><span class="language-bash">复制依赖关系文件到archives中,并删除无用的依赖关系文件</span>cp Packages.gz ./archives &amp;&amp; rm -rf /opt/offline/nfs/Packages.gz</code></pre><h2 id="14-sftp"><a href="#14-sftp" class="headerlink" title="14. sftp"></a>14. sftp</h2><p><a href="https://www.cnblogs.com/zhumengke/articles/11225040.html">https://www.cnblogs.com/zhumengke/articles/11225040.html</a></p><pre><code class="highlight shell">mkdir -p /opt/offline/sftp/archives/cd /opt/offline/sftp/archives/sudo apt-get download $(apt-cache depends --recurse --no-recommends --no-suggests --no-conflicts --no-breaks --no-replaces --no-enhances vsftpd | grep &quot;^\w&quot; | sort -u)cd ..<span class="meta prompt_"></span><span class="meta prompt_">#</span><span class="language-bash">带上-m，会将所有包全部建立依赖关系到 Packages.gz中，如此会有重复，但无需剔除重复的包</span>sudo dpkg-scanpackages -m . /dev/null | gzip -9c &gt; Packages.gz<span class="meta prompt_"> </span><span class="meta prompt_"># </span><span class="language-bash">复制依赖关系文件到archives中,并删除无用的依赖关系文件</span>cp Packages.gz ./archives &amp;&amp; rm -rf /opt/offline/sftp/Packages.gz</code></pre><h2 id="15-dos2unix"><a href="#15-dos2unix" class="headerlink" title="15. dos2unix"></a>15. dos2unix</h2><pre><code class="highlight shell">mkdir -p /opt/offline/dos2unix/archives/cd /opt/offline/dos2unix/archives/sudo apt-get download $(apt-cache depends --recurse --no-recommends --no-suggests --no-conflicts --no-breaks --no-replaces --no-enhances dos2unix | grep &quot;^\w&quot; | sort -u)cd ..<span class="meta prompt_"></span><span class="meta prompt_">#</span><span class="language-bash">带上-m，会将所有包全部建立依赖关系到 Packages.gz中，如此会有重复，但无需剔除重复的包</span>sudo dpkg-scanpackages -m . /dev/null | gzip -9c &gt; Packages.gz<span class="meta prompt_"> </span><span class="meta prompt_"># </span><span class="language-bash">复制依赖关系文件到archives中,并删除无用的依赖关系文件</span>cp Packages.gz ./archives &amp;&amp; rm -rf /opt/offline/dos2unix/Packages.gz</code></pre><h2 id="16-离线源打包"><a href="#16-离线源打包" class="headerlink" title="16. 离线源打包"></a>16. 离线源打包</h2><p>将上面制作好的连线源安装包，打包</p><pre><code class="highlight shell">cd /opt/offlinetar -zcf offline-source.tar.gz ./*</code></pre><p><code>offline-source.tar.gz</code> 就是制作好的离线包</p><h1 id="二、使用离线源安装服务器"><a href="#二、使用离线源安装服务器" class="headerlink" title="二、使用离线源安装服务器"></a>二、使用离线源安装服务器</h1><p>上面基于可连外网的服务器制作了离线源，并将离线源打成了一个tar包 ：<code>offline-source.tar.gz</code> ，现在就使用这个打包好的离线源，在断网的服务器上安装环境。</p><h2 id="1-上传离线安装包"><a href="#1-上传离线安装包" class="headerlink" title="1. 上传离线安装包"></a>1. 上传离线安装包</h2><p>将 <code>offline-source.tar.gz</code> 上传到服务器上，可以通过U盘拷贝的方式，或者内网文件服务器下载。</p><h2 id="2-配置离线源"><a href="#2-配置离线源" class="headerlink" title="2. 配置离线源"></a>2. 配置离线源</h2><pre><code class="highlight shell"><span class="meta prompt_"># </span><span class="language-bash">创建离线文件存放目录</span>mkdir -p /opt/offline<span class="meta prompt_"></span><span class="meta prompt_"># </span><span class="language-bash">解压离线文件</span>tar -zxvf offline-source.tar.gz -C /opt/offline/<span class="meta prompt_"></span><span class="meta prompt_"># </span><span class="language-bash">备份源文件</span>mv /etc/apt/sources.list /etc/apt/sources.list.bak<span class="meta prompt_"></span><span class="meta prompt_"># </span><span class="language-bash">映射本地源，这里可以使用vi</span>cat &gt;&gt;/etc/apt/sources.list &lt;&lt;EOFdeb [trusted=yes] file:///opt/offline/apt-transport-https/ archives/deb [trusted=yes] file:///opt/offline/ca-certificates/ archives/deb [trusted=yes] file:///opt/offline/curl/ archives/deb [trusted=yes] file:///opt/offline/docker/ archives/deb [trusted=yes] file:///opt/offline/ffmpeg/ archives/deb [trusted=yes] file:///opt/offline/net-tools/ archives/deb [trusted=yes] file:///opt/offline/nfs/ archives/deb [trusted=yes] file:///opt/offline/ntp/ archives/deb [trusted=yes] file:///opt/offline/sftp/ archives/deb [trusted=yes] file:///opt/offline/software-properties-common/ archives/deb [trusted=yes] file:///opt/offline/ssh/ archives/deb [trusted=yes] file:///opt/offline/unzip/ archives/deb [trusted=yes] file:///opt/offline/vim/ archives/deb [trusted=yes] file:///opt/offline/wget/ archives/deb [trusted=yes] file:///opt/offline/dos2unix/ archives/EOF<span class="meta prompt_"></span><span class="meta prompt_"># </span><span class="language-bash">更新</span>apt-get update -y</code></pre><h2 id="3-测试安装"><a href="#3-测试安装" class="headerlink" title="3. 测试安装"></a>3. 测试安装</h2><pre><code class="highlight shell">//根据自己需求进行安装，例如：apt-get install -y wget</code></pre><h2 id="4-使用离线源安装docker"><a href="#4-使用离线源安装docker" class="headerlink" title="4. 使用离线源安装docker"></a>4. 使用离线源安装docker</h2><pre><code class="highlight shell">sudo apt-get install -y docker-ce docker-ce-cli containerd.io</code></pre><p><strong>参考文档</strong></p><blockquote><p><a href="https://always200.com/ubuntu-offline-sources/">ubuntu制作离线源</a></p></blockquote>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;&lt;strong&gt;系统环境&lt;/strong&gt;&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;系统发行版：Ubuntu 18.04.6 LTS&lt;/p&gt;
&lt;p&gt;内核版本：5.4.0-150-generic&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;&lt;strong&gt;注意事项&lt;/stron</summary>
      
    
    
    
    <category term="linux" scheme="https://georgechan95.github.io/categories/linux/"/>
    
    
    <category term="linux" scheme="https://georgechan95.github.io/tags/linux/"/>
    
    <category term="ubuntu18" scheme="https://georgechan95.github.io/tags/ubuntu18/"/>
    
  </entry>
  
  <entry>
    <title>12-JUC进阶-从ReentrantLock到AQS源码详解</title>
    <link href="https://georgechan95.github.io/blog/3fdbf0f6.html"/>
    <id>https://georgechan95.github.io/blog/3fdbf0f6.html</id>
    <published>2024-10-15T11:42:07.000Z</published>
    <updated>2024-10-16T11:27:35.626Z</updated>
    
    <content type="html"><![CDATA[<h1 id="一、前置知识"><a href="#一、前置知识" class="headerlink" title="一、前置知识"></a>一、前置知识</h1><ul><li><p><strong>公平锁和非公平锁</strong></p><ul><li>公平锁：锁被释放以后，先申请的线程先得到锁。性能较差一些，因为公平锁为了保证时间上的绝对顺序，上下文切换更频繁</li><li>非公平锁：锁被释放以后，后申请的线程可能会先获取到锁，是随机或者按照其他优先级排序的。性能更好，但可能会导致某些线程永远无法获取到锁</li></ul></li><li><p><strong>可重入锁</strong></p><p>也叫做递归锁，指的是线程可以再次获取自己的内部锁，比如一个线程获取到了对象锁，此时这个对象锁还没有释放，当其想再次获取这个对象锁的时候还是可以获取的，如果不可重入的话，会导致阻塞。</p></li><li><p><strong>自旋思想</strong></p><p>当线程请求锁时，如果锁已经被其他线程持有，那么该线程会不断地重试获取锁，而不是被挂起等待，这种不断尝试获取锁的行为称为自旋</p></li><li><p><strong>LockSupport</strong></p><ul><li>一个工具类，用于线程的阻塞和唤醒操作，类似于wait()和notify()方法，但是更加灵活和可控</li><li>提供了 <code>park()</code> 和 <code>unpark()</code> 两个静态方法用于线程阻塞和唤醒操作。</li><li>优点在于可以在任意时刻阻塞和唤醒线程而不需要事先获取锁或监视器对象。</li></ul></li><li><p><strong>数据结构之双向链表</strong></p><p>双向链表（Doubly Linked List）是一种常见的数据结构，它是由一系列结点（Node）组成的，每个结点包含三个部分：数据域、前驱指针和后继指针。其中，数据域存储结点的数据，前驱指针指向前一个结点，后继指针指向后一个结点。通过这种方式，双向链表可以实现双向遍历和插入、删除操作。</p></li><li><p><strong>设计模式之模板设计模式</strong></p><ul><li>模板设计模式是一种行为型设计模式，定义了一种算法的框架，并将某些步骤延迟到子类中事先，这种设计模式的主要目的是允许子类在不改变算法结构的情况下重新定义算法中的某些步骤。</li><li>优点是能够提高代码复用性和可维护性。</li></ul></li></ul><h1 id="二、概述"><a href="#二、概述" class="headerlink" title="二、概述"></a>二、概述</h1><p>Java中的大部分同步类（<code>Lock</code>、<code>Semaphore</code>、<code>ReentrantLock</code> 等）都是基于 <code>AbstractQueuedSynchronizer</code>（简称为AQS）实现的。AQS是一种提供了原子式管理同步状态、阻塞和唤醒线程功能以及队列模型的简单框架。本文会从应用层逐渐深入到原理层，并通过 <code>ReentrantLock</code> 的基本特性和 <code>ReentrantLock</code> 与AQS的关联，来深入解读AQS相关独占锁的知识点。</p><h1 id="三、ReentrantLock"><a href="#三、ReentrantLock" class="headerlink" title="三、ReentrantLock"></a>三、ReentrantLock</h1><h2 id="1-ReentrantLock特性概览"><a href="#1-ReentrantLock特性概览" class="headerlink" title="1. ReentrantLock特性概览"></a>1. ReentrantLock特性概览</h2><p>ReentrantLock意思为可重入锁，指的是一个线程能够对一个临界资源重复加锁。为了帮助大家更好地理解ReentrantLock的特性，我们先将ReentrantLock跟常用的Synchronized进行比较，其特性如下</p><table><thead><tr><th></th><th>ReentrantLock</th><th>Synchronized</th></tr></thead><tbody><tr><td>锁实现机制</td><td>依赖AQS</td><td>监视器模式</td></tr><tr><td>灵活性</td><td>支持响应中断、超时、尝试获取锁</td><td>不灵活</td></tr><tr><td>释放形式</td><td>必须显示调用unlock0释放锁</td><td>自动释放监视器</td></tr><tr><td>锁类型</td><td>公平锁&amp;非公平锁</td><td>非公平锁</td></tr><tr><td>条件队列</td><td>可关联多个条件队列</td><td>关联一个条件队列</td></tr><tr><td>可重入性</td><td>可重入</td><td>可重入</td></tr></tbody></table><p>下面通过伪代码，进行更加直观的比较：</p><pre><code class="highlight java"><span class="comment">// **************************Synchronized的使用方式**************************</span><span class="comment">// 1.用于代码块</span><span class="keyword">synchronized</span> (<span class="built_in">this</span>) &#123;&#125;<span class="comment">// 2.用于对象</span><span class="keyword">synchronized</span> (object) &#123;&#125;<span class="comment">// 3.用于方法</span><span class="keyword">public</span> <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title function_">test</span> <span class="params">()</span> &#123;&#125;<span class="comment">// 4.可重入</span><span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; <span class="number">100</span>; i++) &#123;<span class="keyword">synchronized</span> (<span class="built_in">this</span>) &#123;&#125;&#125;<span class="comment">// **************************ReentrantLock的使用方式**************************</span><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">test</span> <span class="params">()</span> <span class="keyword">throw</span> Exception &#123;<span class="comment">// 1.初始化选择公平锁、非公平锁</span><span class="type">ReentrantLock</span> <span class="variable">lock</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ReentrantLock</span>(<span class="literal">true</span>);<span class="comment">// 2.可用于代码块</span>lock.lock();<span class="keyword">try</span> &#123;<span class="keyword">try</span> &#123;<span class="comment">// 3.支持多种加锁方式，比较灵活; 具有可重入特性</span><span class="keyword">if</span>(lock.tryLock(<span class="number">100</span>, TimeUnit.MILLISECONDS))&#123; &#125;&#125; <span class="keyword">finally</span> &#123;<span class="comment">// 4.手动释放锁</span>lock.unlock()&#125;&#125; <span class="keyword">finally</span> &#123;lock.unlock();&#125;&#125;</code></pre><h2 id="2-ReentrantLock与AQS的关联"><a href="#2-ReentrantLock与AQS的关联" class="headerlink" title="2. ReentrantLock与AQS的关联"></a>2. ReentrantLock与AQS的关联</h2><p>通过上文我们已经了解，ReentrantLock支持公平锁和非公平锁（关于公平锁和非公平锁的原理分析，可参考《<a href="https://mp.weixin.qq.com/s?__biz=MjM5NjQ5MTI5OA==&mid=2651749434&idx=3&sn=5ffa63ad47fe166f2f1a9f604ed10091&chksm=bd12a5778a652c61509d9e718ab086ff27ad8768586ea9b38c3dcf9e017a8e49bcae3df9bcc8&scene=38#wechat_redirect">不可不说的Java“锁”事</a>》），并且ReentrantLock的底层就是由AQS来实现的。那么ReentrantLock是如何通过公平锁和非公平锁与AQS关联起来呢？ 我们着重从这两者的加锁过程来理解一下它们与AQS之间的关系（加锁过程中与AQS的关联比较明显，解锁流程后续会介绍）。</p><p>非公平锁源码中的加锁流程如下：</p><pre><code class="highlight java"><span class="comment">// java.util.concurrent.locks.ReentrantLock#NonfairSync</span><span class="comment">// 非公平锁</span><span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">class</span> <span class="title class_">NonfairSync</span> <span class="keyword">extends</span> <span class="title class_">Sync</span> &#123;...<span class="keyword">final</span> <span class="keyword">void</span> <span class="title function_">lock</span><span class="params">()</span> &#123;<span class="keyword">if</span> (compareAndSetState(<span class="number">0</span>, <span class="number">1</span>))setExclusiveOwnerThread(Thread.currentThread());<span class="keyword">else</span>acquire(<span class="number">1</span>);&#125;  ...&#125;</code></pre><p>上述代码解析如下：</p><ul><li>首先通过CAS的方式，将 state（同步状态）从0 设置成 1， 如果成功，则将当前线程设置成独占线程</li><li>如果state（同步状态）修改失败，程序走else逻辑，通过 <code>acquire()</code> 方法进行后续处理。</li></ul><p><code>acquire()</code> 是CAS的核心方法，有 <code>FairSync</code> 和 <code>UnfairSync</code> 两个子类实现它，它们的逻辑基本类似，目的都是通过将争抢锁的线程组成队列，基于 state（同步状态）的变化，阻塞和唤醒线程，从而实现锁的获取和释放。</p><h1 id="四、AQS原理"><a href="#四、AQS原理" class="headerlink" title="四、AQS原理"></a>四、AQS原理</h1><h2 id="1-AQS整体框架"><a href="#1-AQS整体框架" class="headerlink" title="1. AQS整体框架"></a>1. AQS整体框架</h2><p>首先，我们通过下面的架构图来整体了解一下AQS框架：</p><p><img src="https://raw.githubusercontent.com/GeorgeChan95/blogimg/master/img/2024/10/15/20241015-184824.png" alt="AQS的整体框架"></p><ul><li>上图中有颜色的为Method，无颜色的为Attribution。</li><li>总的来说，AQS框架共分为五层，自上而下由浅入深，从AQS对外暴露的API到底层基础数据。</li><li>当有自定义同步器接入时，只需重写第一层所需要的部分方法即可，不需要关注底层具体的实现流程。当自定义同步器进行加锁或者解锁操作时，先经过第一层的API进入AQS内部方法，然后经过第二层进行锁的获取，接着对于获取锁失败的流程，进入第三层和第四层的等待队列处理，而这些处理方式均依赖于第五层的基础数据提供层。</li></ul><h2 id="2-AQS原理概览"><a href="#2-AQS原理概览" class="headerlink" title="2. AQS原理概览"></a>2. AQS原理概览</h2><p>AQS核心思想是，如果被请求的共享资源空闲，那么就将当前请求资源的线程设置为有效的工作线程，将共享资源设置为锁定状态；如果共享资源被占用，就需要一定的阻塞等待唤醒机制来保证锁分配。这个机制主要用的是CLH队列的变体实现的，将暂时获取不到锁的线程加入到队列中。</p><p>CLH：Craig、Landin and Hagersten队列，是单向链表，AQS中的队列是CLH变体的虚拟双向队列（FIFO），AQS是通过将每条请求共享资源的线程封装成一个节点来实现锁的分配。</p><p>主要原理图如下：</p><p><img src="https://raw.githubusercontent.com/GeorgeChan95/blogimg/master/img/2024/10/15/20241015-185444.png" alt="CLH队列"></p><h3 id="2-1-AQS数据结构"><a href="#2-1-AQS数据结构" class="headerlink" title="2.1 AQS数据结构"></a>2.1 AQS数据结构</h3><p>先来看下AQS中最基本的数据结构——Node，Node即为上面CLH变体队列中的节点。</p><p><img src="https://raw.githubusercontent.com/GeorgeChan95/blogimg/master/img/2024/10/15/20241015-185548.png" alt="AQS数据结构"></p><p><strong>Node源码如下（重要）：</strong></p><pre><code class="highlight java"><span class="comment">/**</span><span class="comment"> * Wait queue node class.</span><span class="comment"> *</span><span class="comment"> * &lt;p&gt;To enqueue into a CLH lock, you atomically splice it in as new</span><span class="comment"> * tail. To dequeue, you just set the head field.</span><span class="comment"> * &lt;pre&gt;</span><span class="comment"> *      +------+  prev +-----+       +-----+</span><span class="comment"> * head |      | &lt;---- |     | &lt;---- |     |  tail</span><span class="comment"> *      +------+       +-----+       +-----+</span><span class="comment"> * &lt;/pre&gt;</span><span class="comment"> *</span><span class="comment"> */</span><span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">class</span> <span class="title class_">Node</span> &#123;    <span class="comment">/** 共享模式下的节点 */</span>    <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">Node</span> <span class="variable">SHARED</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Node</span>();    <span class="comment">/** 独占模式下的节点 */</span>    <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">Node</span> <span class="variable">EXCLUSIVE</span> <span class="operator">=</span> <span class="literal">null</span>;    <span class="comment">/** 线程取消执行状态：1 */</span>    <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">int</span> <span class="variable">CANCELLED</span> <span class="operator">=</span>  <span class="number">1</span>;    <span class="comment">/** 线程准备就绪，等待资源释放后执行 */</span>    <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">int</span> <span class="variable">SIGNAL</span>    <span class="operator">=</span> -<span class="number">1</span>;    <span class="comment">/** 线程等待执行条件触发 */</span>    <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">int</span> <span class="variable">CONDITION</span> <span class="operator">=</span> -<span class="number">2</span>;    <span class="comment">/**</span><span class="comment">     * 此状态在共享模式下才会用到</span><span class="comment">     */</span>    <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">int</span> <span class="variable">PROPAGATE</span> <span class="operator">=</span> -<span class="number">3</span>;    <span class="comment">/**</span><span class="comment">     * Status field, taking on only the values:</span><span class="comment">     *   SIGNAL: 为-1，表示线程已经准备好了，就等资源释放了</span><span class="comment">     *   CANCELLED: 为 1，表示线程获取锁的请求已经取消了</span><span class="comment">     *   CONDITION: 为-2，表示节点在等待队列中，节点线程等待唤醒</span><span class="comment">     *   PROPAGATE: 为-3，当前线程处在SHARED情况下，该字段才会使用</span><span class="comment">     *   0:         当一个Node被初始化的时候的默认值</span><span class="comment">     */</span>    <span class="keyword">volatile</span> <span class="type">int</span> waitStatus;    <span class="comment">/**</span><span class="comment">     * node节点的前节点</span><span class="comment">     */</span>    <span class="keyword">volatile</span> Node prev;    <span class="comment">/**</span><span class="comment">     * node节点的后节点</span><span class="comment">     */</span>    <span class="keyword">volatile</span> Node next;    <span class="comment">/**</span><span class="comment">     * 当前节点运行的线程</span><span class="comment">     */</span>    <span class="keyword">volatile</span> Thread thread;    <span class="comment">/**</span><span class="comment">     * Link to next node waiting on condition, or the special value SHARED.</span><span class="comment">     */</span>    Node nextWaiter;    <span class="comment">/**</span><span class="comment">     * 共享模式下返回true</span><span class="comment">     */</span>    <span class="keyword">final</span> <span class="type">boolean</span> <span class="title function_">isShared</span><span class="params">()</span> &#123;        <span class="keyword">return</span> nextWaiter == SHARED;    &#125;    <span class="comment">/**</span><span class="comment">     * 返回当前节点的前节点</span><span class="comment">     */</span>    <span class="keyword">final</span> Node <span class="title function_">predecessor</span><span class="params">()</span> <span class="keyword">throws</span> NullPointerException &#123;        <span class="type">Node</span> <span class="variable">p</span> <span class="operator">=</span> prev;        <span class="keyword">if</span> (p == <span class="literal">null</span>)            <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">NullPointerException</span>();        <span class="keyword">else</span>            <span class="keyword">return</span> p;    &#125;    Node() &#123;    <span class="comment">// Used to establish initial head or SHARED marker</span>    &#125;    Node(Thread thread, Node mode) &#123;     <span class="comment">// Used by addWaiter</span>        <span class="built_in">this</span>.nextWaiter = mode;        <span class="built_in">this</span>.thread = thread;    &#125;    Node(Thread thread, <span class="type">int</span> waitStatus) &#123; <span class="comment">// Used by Condition</span>        <span class="built_in">this</span>.waitStatus = waitStatus;        <span class="built_in">this</span>.thread = thread;    &#125;&#125;</code></pre><p><strong>解释一下几个方法和属性值的含义：</strong></p><table><thead><tr><th align="left">方法和属性值</th><th align="left">含义</th></tr></thead><tbody><tr><td align="left">waitStatus</td><td align="left">当前节点在队列中的状态</td></tr><tr><td align="left">thread</td><td align="left">表示处于该节点的线程</td></tr><tr><td align="left">prev</td><td align="left">前驱指针</td></tr><tr><td align="left">predecessor</td><td align="left">返回前驱节点，没有的话抛出npe</td></tr><tr><td align="left">nextWaiter</td><td align="left">指向下一个处于CONDITION状态的节点（由于本篇文章不讲述Condition Queue队列，这个指针不多介绍）</td></tr><tr><td align="left">next</td><td align="left">后继指针</td></tr></tbody></table><p>线程两种锁的模式：</p><table><thead><tr><th align="left">模式</th><th align="left">含义</th></tr></thead><tbody><tr><td align="left">SHARED</td><td align="left">表示线程以共享的模式等待锁</td></tr><tr><td align="left">EXCLUSIVE</td><td align="left">表示线程正在以独占的方式等待锁</td></tr></tbody></table><p><code>waitStatus</code> 有下面几个枚举值：</p><table><thead><tr><th align="left">枚举</th><th align="left">含义</th></tr></thead><tbody><tr><td align="left">0</td><td align="left">当一个Node被初始化的时候的默认值</td></tr><tr><td align="left">CANCELLED</td><td align="left">为1，表示线程获取锁的请求已经取消了</td></tr><tr><td align="left">CONDITION</td><td align="left">为-2，表示节点在等待队列中，节点线程等待唤醒</td></tr><tr><td align="left">PROPAGATE</td><td align="left">为-3，当前线程处在SHARED情况下，该字段才会使用</td></tr><tr><td align="left">SIGNAL</td><td align="left">为-1，表示线程已经准备好了，就等资源释放了</td></tr></tbody></table><h3 id="2-2-同步状态State"><a href="#2-2-同步状态State" class="headerlink" title="2.2 同步状态State"></a>2.2 同步状态State</h3><p>在了解数据结构后，接下来了解一下AQS的同步状态——State。AQS中维护了一个名为state的字段，意为同步状态，是由Volatile修饰的，用于展示当前临界资源的获锁情况。</p><pre><code class="highlight java"><span class="comment">// java.util.concurrent.locks.AbstractQueuedSynchronizer</span><span class="comment">/**</span><span class="comment"> * The synchronization state.</span><span class="comment"> */</span><span class="keyword">private</span> <span class="keyword">volatile</span> <span class="type">int</span> state;</code></pre><p>下面提供了几个访问这个字段的方法：</p><table><thead><tr><th align="left">方法名</th><th align="left">描述</th></tr></thead><tbody><tr><td align="left">protected final int getState()</td><td align="left">获取State的值</td></tr><tr><td align="left">protected final void setState(int newState)</td><td align="left">设置State的值</td></tr><tr><td align="left">protected final boolean compareAndSetState(int expect, int update)</td><td align="left">使用CAS方式更新State</td></tr></tbody></table><p>这几个方法都是Final修饰的，说明子类中无法重写它们。我们可以通过修改State字段表示的同步状态来实现多线程的独占模式和共享模式（加锁过程）。</p><p><img src="https://p0.meituan.net/travelcube/27605d483e8935da683a93be015713f331378.png" alt="独占模式"><img src="https://raw.githubusercontent.com/GeorgeChan95/blogimg/master/img/2024/10/15/20241015-190158.png" alt="共享模式"></p><p><em>对于我们自定义的同步工具，需要自定义获取同步状态和释放状态的方式，也就是AQS架构图中的第一层：API层。</em></p><h3 id="2-3-AQS其它关键属性"><a href="#2-3-AQS其它关键属性" class="headerlink" title="2.3 AQS其它关键属性"></a>2.3 AQS其它关键属性</h3><ul><li><p>head ： 表示CLH队列中的头节点</p><pre><code class="highlight java"><span class="keyword">private</span> <span class="keyword">transient</span> <span class="keyword">volatile</span> Node head;</code></pre></li><li><p>tail ：表示CLH队列中的尾节点</p><pre><code class="highlight java"><span class="keyword">private</span> <span class="keyword">transient</span> <span class="keyword">volatile</span> Node tail;</code></pre></li></ul><h2 id="3-AQS重要方法与ReentrantLock的关联"><a href="#3-AQS重要方法与ReentrantLock的关联" class="headerlink" title="3. AQS重要方法与ReentrantLock的关联"></a>3. AQS重要方法与ReentrantLock的关联</h2><p>从架构图中可以得知，AQS提供了大量用于自定义同步器实现的Protected方法。自定义同步器实现的相关方法也只是为了通过修改State字段来实现多线程的独占模式或者共享模式。自定义同步器需要实现以下方法（ReentrantLock需要实现的方法如下，并不是全部）：</p><table><thead><tr><th align="left">方法名</th><th align="left">描述</th></tr></thead><tbody><tr><td align="left">protected boolean isHeldExclusively()</td><td align="left">该线程是否正在独占资源。只有用到Condition才需要去实现它。</td></tr><tr><td align="left">protected boolean tryAcquire(int arg)</td><td align="left">独占方式。arg为获取锁的次数，尝试获取资源，成功则返回True，失败则返回False。</td></tr><tr><td align="left">protected boolean tryRelease(int arg)</td><td align="left">独占方式。arg为释放锁的次数，尝试释放资源，成功则返回True，失败则返回False。</td></tr><tr><td align="left">protected int tryAcquireShared(int arg)</td><td align="left">共享方式。arg为获取锁的次数，尝试获取资源。负数表示失败；0表示成功，但没有剩余可用资源；正数表示成功，且有剩余资源。</td></tr><tr><td align="left">protected boolean tryReleaseShared(int arg)</td><td align="left">共享方式。arg为释放锁的次数，尝试释放资源，如果释放后允许唤醒后续等待结点返回True，否则返回False。</td></tr></tbody></table><p>一般来说，自定义同步器要么是独占方式，要么是共享方式，它们也只需实现<code>tryAcquire-tryRelease</code>、<code>tryAcquireShared-tryReleaseShared</code>中的一种即可。AQS也支持自定义同步器同时实现独占和共享两种方式，如<code>ReentrantReadWriteLock</code>。<code>ReentrantLock</code>是独占锁，所以实现了<code>tryAcquire-tryRelease</code>。</p><p>为了帮助大家理解ReentrantLock和AQS之间方法的交互过程，以非公平锁为例，我们将加锁和解锁的交互流程单独拎出来强调一下，以便于对后续内容的理解。</p><p><img src="https://raw.githubusercontent.com/GeorgeChan95/blogimg/master/img/2024/10/15/20241015-191329.png" alt="ReentrantLock加锁和解锁的调用流程"></p><p><strong>加锁：</strong></p><ul><li><p>通过<code>ReentrantLock</code>的加锁方法<code>Lock</code>进行加锁操作。</p></li><li><p>会调用到内部类<code>Sync</code>的<code>Lock</code>方法，由于<code>Sync#lock</code>是抽象方法，根据<code>ReentrantLock</code>初始化选择的公平锁和非公平锁，执行相关内部类的<code>Lock</code>方法，本质上都会执行AQS的<code>Acquire</code>方法。（以非公平锁 <code>NonfairSync</code> 为例）</p><p><code>java.util.concurrent.locks.ReentrantLock#lock</code>  &#x3D;&gt;  <code>java.util.concurrent.locks.ReentrantLock.Sync#lock</code>  &#x3D;&gt;  <code>java.util.concurrent.locks.ReentrantLock.NonfairSync#lock</code>  &#x3D;&gt;  <code>java.util.concurrent.locks.AbstractQueuedSynchronizer#acquire</code></p></li><li><p>AQS的<code>Acquire</code>方法会执行<code>tryAcquire</code>方法，但是由于<code>tryAcquire</code>需要自定义同步器实现，因此执行了<code>ReentrantLock</code>中的<code>tryAcquire</code>方法，由于<code>ReentrantLock</code>是通过公平锁和非公平锁内部类实现的<code>tryAcquire</code>方法，因此会根据锁类型不同，执行不同的<code>tryAcquire</code>。(这里再次以非公平锁为例)</p><p><code>java.util.concurrent.locks.AbstractQueuedSynchronizer#tryAcquire</code>  &#x3D;&gt;  <code>java.util.concurrent.locks.ReentrantLock.NonfairSync#tryAcquire</code>  &#x3D;&gt;  <code>java.util.concurrent.locks.ReentrantLock.Sync#nonfairTryAcquire</code></p></li><li><p><code>tryAcquire</code>是获取锁逻辑，获取失败后，会执行框架AQS的后续逻辑，跟<code>ReentrantLock</code>自定义同步器无关。</p><ul><li><code>java.util.concurrent.locks.AbstractQueuedSynchronizer#addWaiter</code>  &#x3D;&gt;  <code>java.util.concurrent.locks.AbstractQueuedSynchronizer#enq</code> </li><li><code>java.util.concurrent.locks.AbstractQueuedSynchronizer#acquireQueued</code> &#x3D;&gt; <code>java.util.concurrent.locks.AbstractQueuedSynchronizer#shouldParkAfterFailedAcquire</code>  &#x3D;&gt;  <code>java.util.concurrent.locks.AbstractQueuedSynchronizer#parkAndCheckInterrupt</code></li></ul></li></ul><p>以上为AQS加锁过程的核心逻辑和核心方法。</p><p><strong>解锁：</strong></p><ul><li><p>通过<code>ReentrantLock</code>的解锁方法<code>Unlock</code>进行解锁。</p></li><li><p><code>Unlock</code>会调用内部类<code>Sync</code>的<code>Release</code>方法，该方法继承于AQS。</p><p><code>java.util.concurrent.locks.ReentrantLock#unlock</code>  &#x3D;&gt;  <code>java.util.concurrent.locks.AbstractQueuedSynchronizer#release</code></p></li><li><p>Release中会调用<code>tryRelease</code>方法，<code>tryRelease</code>需要自定义同步器实现，<code>tryRelease</code>只在<code>ReentrantLock</code>中的<code>Sync</code>实现，因此可以看出，释放锁的过程，并不区分是否为公平锁。</p><p><code>java.util.concurrent.locks.AbstractQueuedSynchronizer#tryRelease</code>  &#x3D;&gt;  <code>java.util.concurrent.locks.ReentrantLock.Sync#tryRelease</code></p></li><li><p>释放成功后，所有处理由AQS框架完成，与自定义同步器无关。</p></li></ul><p>通过上面的描述，大概可以总结出<code>ReentrantLock</code>加锁解锁时API层核心方法的映射关系。</p><p><img src="https://raw.githubusercontent.com/GeorgeChan95/blogimg/master/img/2024/10/15/20241015-192902.png" alt="加锁/解锁方法映射"></p><h1 id="五、AQS加锁-解锁源码解析"><a href="#五、AQS加锁-解锁源码解析" class="headerlink" title="五、AQS加锁&#x2F;解锁源码解析"></a>五、AQS加锁&#x2F;解锁源码解析</h1><p>下面以 <code>ReentrantLock</code> 的实现为例，通过一个具体的案例，详细解释AQS是如何实现线程的抢占、创建队列(FIFO)、入队、以及获取到锁后出队的过程。</p><h2 id="1-模拟场景"><a href="#1-模拟场景" class="headerlink" title="1. 模拟场景"></a>1. 模拟场景</h2><p>假设有5个线程，分别是 <code>线程A</code>、<code>线程B</code>、<code>线程C</code>、<code>线程D</code>、<code>线程E</code> 同时去争抢一个资源，然后执行相应的逻辑，线程A先抢到锁，其它线程只能 <code>等待A</code> 执行结束后再抢锁。这里使用 ReentrantLock非公平锁实现。</p><p>模拟代码如下：</p><pre><code class="highlight java"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">AQSDemo</span> &#123;    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;        <span class="type">ReentrantLock</span> <span class="variable">reentrantLock</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ReentrantLock</span>();<span class="comment">//非公平锁</span>        <span class="comment">// A线程先抢到锁，执行业务</span>        <span class="keyword">new</span> <span class="title class_">Thread</span>(() -&gt; &#123;            reentrantLock.lock();            <span class="keyword">try</span> &#123;                System.out.println(<span class="string">&quot;----come in A&quot;</span>);                <span class="comment">//暂停1分钟线程</span>                <span class="keyword">try</span> &#123;                    TimeUnit.MILLISECONDS.sleep(<span class="number">1000</span> * <span class="number">60</span>);                &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;                    e.printStackTrace();                &#125;            &#125; <span class="keyword">finally</span> &#123;                reentrantLock.unlock();            &#125;        &#125;, <span class="string">&quot;A&quot;</span>).start();        <span class="comment">// B线程等待，进入AQS队列(FIFO)，等待着A运行结束，尝试去抢占锁。</span>        <span class="keyword">new</span> <span class="title class_">Thread</span>(() -&gt; &#123;            reentrantLock.lock();            <span class="keyword">try</span> &#123;                System.out.println(<span class="string">&quot;----come in B&quot;</span>);            &#125; <span class="keyword">finally</span> &#123;                reentrantLock.unlock();            &#125;        &#125;, <span class="string">&quot;B&quot;</span>).start();        <span class="comment">// C线程等待，进入AQS队列(FIFO)，等待着A运行结束，此时前面是B线程</span>        <span class="keyword">new</span> <span class="title class_">Thread</span>(() -&gt; &#123;            reentrantLock.lock();            <span class="keyword">try</span> &#123;                System.out.println(<span class="string">&quot;----come in C&quot;</span>);            &#125; <span class="keyword">finally</span> &#123;                reentrantLock.unlock();            &#125;        &#125;, <span class="string">&quot;C&quot;</span>).start();        <span class="comment">// D线程等待，进入AQS队列(FIFO)，等待着A运行结束，此时前面是C线程</span>        <span class="keyword">new</span> <span class="title class_">Thread</span>(() -&gt; &#123;            reentrantLock.lock();            <span class="keyword">try</span> &#123;                System.out.println(<span class="string">&quot;----come in C&quot;</span>);            &#125; <span class="keyword">finally</span> &#123;                reentrantLock.unlock();            &#125;        &#125;, <span class="string">&quot;D&quot;</span>).start();        <span class="comment">// E线程等待，进入AQS队列(FIFO)，等待着A运行结束，此时前面是D线程</span>        <span class="keyword">new</span> <span class="title class_">Thread</span>(() -&gt; &#123;            reentrantLock.lock();            <span class="keyword">try</span> &#123;                System.out.println(<span class="string">&quot;----come in C&quot;</span>);            &#125; <span class="keyword">finally</span> &#123;                reentrantLock.unlock();            &#125;        &#125;, <span class="string">&quot;E&quot;</span>).start();    &#125;&#125;</code></pre><h2 id="2-资源初始化"><a href="#2-资源初始化" class="headerlink" title="2. 资源初始化"></a>2. 资源初始化</h2><p>最开始，没有线程争抢锁时，如下图，此时 同步状态为0（表示资源空闲），所没有被线程抢占。</p><p><img src="https://raw.githubusercontent.com/GeorgeChan95/blogimg/master/img/2024/10/15/20241015-203250.png" alt="无线程抢占资源"></p><h2 id="3-无竞争获取资源"><a href="#3-无竞争获取资源" class="headerlink" title="3. 无竞争获取资源"></a>3. 无竞争获取资源</h2><p>此时 线程A 调用了 lock() 方法抢占了锁，得到了资源，如下图：</p><p><img src="https://raw.githubusercontent.com/GeorgeChan95/blogimg/master/img/2024/10/15/20241015-203510.png" alt="线程A抢占锁"></p><p>此时，同步状态被修改为1，表示资源已被占用。由于此时还有其它线程来争抢资源，所以CLH队列依然是空的。</p><p>线程A的代码执行如下图：</p><pre><code class="highlight java"><span class="comment">// java.util.concurrent.locks.ReentrantLock.NonfairSync#lock</span>    <span class="keyword">final</span> <span class="keyword">void</span> <span class="title function_">lock</span><span class="params">()</span> &#123;    <span class="comment">// 使用CAS将同步状态从0修改为1，如果成功表示成功抢占了锁</span>    <span class="keyword">if</span> (compareAndSetState(<span class="number">0</span>, <span class="number">1</span>))        <span class="comment">// 抢占锁成功，设置当前线程为独占线程</span>        setExclusiveOwnerThread(Thread.currentThread());    <span class="keyword">else</span>        <span class="comment">// 以独占模式争抢锁，成功则返回，失败则线程进入CLH队列</span>        acquire(<span class="number">1</span>);&#125;</code></pre><h2 id="4-线程加入等待队列"><a href="#4-线程加入等待队列" class="headerlink" title="4. 线程加入等待队列"></a>4. 线程加入等待队列</h2><h3 id="4-1-加入队列的时机"><a href="#4-1-加入队列的时机" class="headerlink" title="4.1 加入队列的时机"></a>4.1 加入队列的时机</h3><p>此时 <code>线程B</code> 也调用了 <code>lock()</code> 方法争抢锁，但由于 <code>线程A</code> 没有退出执行，依然占有的着锁，此时 state(同步状态)为1，所以 线程B 使用CAS修改state 操作是失败的，只能走 else 分支，进入 acquire(1) 方法。</p><pre><code class="highlight java"><span class="comment">// java.util.concurrent.locks.AbstractQueuedSynchronizer#acquire</span><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">void</span> <span class="title function_">acquire</span><span class="params">(<span class="type">int</span> arg)</span> &#123;    <span class="keyword">if</span> (!tryAcquire(arg) &amp;&amp; acquireQueued(addWaiter(Node.EXCLUSIVE), arg))        selfInterrupt();&#125;</code></pre><ul><li><p>tryAcquire(arg)</p><p>获取锁逻辑, 获取成功则直接返回，获取失败后，会执行框架AQS的后续逻辑</p></li><li><p>addWaiter(Node mode)</p><p>当<code>tryAcquire(arg)</code>获取锁失败，就会调用 <code>addWaiter</code> 加入到等待队列中去，并返回Node对象（Node为执行线程经过封装后的对象）</p></li><li><p>acquireQueued(final Node node, int arg)</p><p>把放入队列中的线程不断去获取锁，直到获取成功或者不再需要获取（中断）</p></li></ul><p>下面基于非公平锁实现，详细解读这三个方法 <code>tryAcquire(arg)</code>、<code>addWaiter(Node mode)</code>、<code>acquireQueued(final Node node, int arg)</code></p><h4 id="4-1-1-tryAcquire"><a href="#4-1-1-tryAcquire" class="headerlink" title="4.1.1 tryAcquire"></a>4.1.1 tryAcquire</h4><pre><code class="highlight java"><span class="comment">// java.util.concurrent.locks.AbstractQueuedSynchronizer#tryAcquire</span>    <span class="keyword">protected</span> <span class="type">boolean</span> <span class="title function_">tryAcquire</span><span class="params">(<span class="type">int</span> arg)</span> &#123;    <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">UnsupportedOperationException</span>();&#125;</code></pre><p>这是AQS父类的默认实现，当子类没有重新实现它时，抛出 UnsupportedOperationException，tryAcquire 有公平锁、非公平锁等不同的实现逻辑，这里我们先看 <code>ReentrantLock</code> 内部类 <code>NonfairSync</code> 的实现</p><pre><code class="highlight java"><span class="comment">// java.util.concurrent.locks.ReentrantLock.NonfairSync#tryAcquire</span><span class="keyword">protected</span> <span class="keyword">final</span> <span class="type">boolean</span> <span class="title function_">tryAcquire</span><span class="params">(<span class="type">int</span> acquires)</span> &#123;    <span class="keyword">return</span> nonfairTryAcquire(acquires);&#125;继续往下<span class="comment">// java.util.concurrent.locks.ReentrantLock.Sync#nonfairTryAcquire</span>    <span class="keyword">final</span> <span class="type">boolean</span> <span class="title function_">nonfairTryAcquire</span><span class="params">(<span class="type">int</span> acquires)</span> &#123;    <span class="comment">// 获取当前线程</span>    <span class="keyword">final</span> <span class="type">Thread</span> <span class="variable">current</span> <span class="operator">=</span> Thread.currentThread();    <span class="comment">// 获取同步状态</span>    <span class="type">int</span> <span class="variable">c</span> <span class="operator">=</span> getState();    <span class="keyword">if</span> (c == <span class="number">0</span>) &#123; <span class="comment">// 如果同步状态为0，表示资源空闲，没有被其它线程占用</span>        <span class="comment">// CAS修改同步状态，成功的话则设置当前线程为独占线程，并返回true</span>        <span class="keyword">if</span> (compareAndSetState(<span class="number">0</span>, acquires)) &#123;            setExclusiveOwnerThread(current);            <span class="keyword">return</span> <span class="literal">true</span>;        &#125;    &#125;    <span class="comment">// 如果同步状态不是0，但是当前线程就是资源的独占线程，这就是表示锁重入，此时更新同步状态，并返回true</span>    <span class="keyword">else</span> <span class="keyword">if</span> (current == getExclusiveOwnerThread()) &#123;        <span class="type">int</span> <span class="variable">nextc</span> <span class="operator">=</span> c + acquires;        <span class="keyword">if</span> (nextc &lt; <span class="number">0</span>) <span class="comment">// overflow</span>            <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">Error</span>(<span class="string">&quot;Maximum lock count exceeded&quot;</span>);        setState(nextc);        <span class="keyword">return</span> <span class="literal">true</span>;    &#125;    <span class="comment">// 同步状态既不是空闲（0），当前线程也不是资源的独占线程，表示当前线程此次抢占锁失败，返回false。</span>    <span class="keyword">return</span> <span class="literal">false</span>;&#125;</code></pre><p>由于此时锁被 <code>线程A</code> 占用，<code>线程B</code> 执行到 nonfairTryAcquire 方法时，同步状态即不是0，<code>线程B</code> 也不是独占线程，所以这里返回 <code>false</code> 。</p><h3 id="4-2-如何加入队列"><a href="#4-2-如何加入队列" class="headerlink" title="4.2 如何加入队列"></a>4.2 如何加入队列</h3><p>在 <code>线程B</code> 执行 <code>tryAcquire</code> 获取锁失败后，会执行 <code>addWaiter(Node.EXCLUSIVE)</code> 加入等待队列，具体实现方法如下：</p><pre><code class="highlight java"><span class="comment">// java.util.concurrent.locks.AbstractQueuedSynchronizer#addWaiter</span><span class="keyword">private</span> Node <span class="title function_">addWaiter</span><span class="params">(Node mode)</span> &#123;    <span class="comment">// 通过当前的线程和锁模式新建一个节点</span>    <span class="type">Node</span> <span class="variable">node</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Node</span>(Thread.currentThread(), mode);    <span class="comment">// Pred指针指向尾节点Tail</span>    <span class="type">Node</span> <span class="variable">pred</span> <span class="operator">=</span> tail;    <span class="keyword">if</span> (pred != <span class="literal">null</span>) &#123;        <span class="comment">// 将New中Node的Prev指针指向Pred</span>        node.prev = pred;        <span class="comment">// CAS设置Tail节点为新建的节点</span>        <span class="keyword">if</span> (compareAndSetTail(pred, node)) &#123;            <span class="comment">// pred节点的next指针指向新的node节点</span>            pred.next = node;            <span class="comment">// 返回新建的node节点</span>            <span class="keyword">return</span> node;        &#125;    &#125;    <span class="comment">// node节点加入CLH队列</span>    enq(node);    <span class="comment">// 返回node节点</span>    <span class="keyword">return</span> node;&#125;</code></pre><p>由于 <code>线程B</code> 在争抢锁时，此时 CLH队列为空，即 head、tail 都为 null，那么上面代码中的 pred 也为null，此时需要创建CLH队列，并将 <code>线程B</code> 加入到队列中，这时就要进入 enq(node) 方法</p><pre><code class="highlight java"><span class="comment">// java.util.concurrent.locks.AbstractQueuedSynchronizer#enq</span><span class="keyword">private</span> Node <span class="title function_">enq</span><span class="params">(<span class="keyword">final</span> Node node)</span> &#123;    <span class="comment">// 自旋操作</span>    <span class="keyword">for</span> (;;) &#123;        <span class="type">Node</span> <span class="variable">t</span> <span class="operator">=</span> tail;        <span class="comment">// 如果队列没有被初始化过，则先初始化一个虚拟节点（new Node()）</span>        <span class="keyword">if</span> (t == <span class="literal">null</span>) &#123; <span class="comment">// Must initialize</span>            <span class="comment">// 初始化虚节点，并将它设置成头节点</span>            <span class="keyword">if</span> (compareAndSetHead(<span class="keyword">new</span> <span class="title class_">Node</span>()))                tail = head;        &#125; <span class="keyword">else</span> &#123;            <span class="comment">// 队列不为空时，当前线程所在节点node的prev指针指向尾节点</span>            node.prev = t;            <span class="comment">// CAS设置当前节点为尾节点</span>            <span class="keyword">if</span> (compareAndSetTail(t, node)) &#123;                <span class="comment">// 之前的尾节点的next指针指向当前节点node</span>                t.next = node;                <span class="comment">// 返回之前的尾节点</span>                <span class="keyword">return</span> t;            &#125;        &#125;    &#125;&#125;</code></pre><p>如果队列没有被初始化，需要进行初始化一个头结点出来。但请注意，初始化的头结点并不是当前线程节点，而是调用了无参构造函数的节点（虚节点）。如果经历了初始化或者并发导致队列中有元素，则与之前的方法相同。其实，<code>addWaiter</code> 就是一个在双端链表添加尾节点的操作，需要注意的是，双端链表的头结点是一个无参构造函数的头结点。</p><p><em>另外也需要注意，enq() 方法返回的 node对象(t) 并不是 addWaiter 方法返回的node对象。</em></p><p>此时 <code>线程B</code> 在经过 enq方法的自旋处理后，进入了CLH队列，如下图：<br><img src="https://raw.githubusercontent.com/GeorgeChan95/blogimg/master/img/2024/10/16/20241016-091107.png" alt="线程B自旋入队"></p><p>这时 线程B 就入队了，作为尾节点插入到队列中，头节点是一个虚节点。如果再有线程要获取锁，依次在队列中往后排队即可。</p><p>如果线程争抢锁是一个公平锁，那么还会增加下面一段逻辑代码：<code>hasQueuedPredecessors()</code> 方法</p><p><code>hasQueuedPredecessors</code> 是公平锁加锁时判断等待队列中是否存在有效节点的方法。如果返回False，说明当前线程可以争取共享资源；如果返回True，说明队列中存在有效节点，当前线程必须加入到等待队列中。</p><pre><code class="highlight java"><span class="comment">//java.util.concurrent.locks.AbstractQueuedSynchronizer#hasQueuedPredecessors</span>    <span class="keyword">public</span> <span class="keyword">final</span> <span class="type">boolean</span> <span class="title function_">hasQueuedPredecessors</span><span class="params">()</span> &#123;    <span class="comment">// 尾节点</span>    <span class="type">Node</span> <span class="variable">t</span> <span class="operator">=</span> tail; <span class="comment">// Read fields in reverse initialization order</span>    <span class="comment">// 头节点</span>    <span class="type">Node</span> <span class="variable">h</span> <span class="operator">=</span> head;    <span class="comment">// 指向头节点的下一个节点</span>    Node s;    <span class="keyword">return</span> h != t &amp;&amp;            ((s = h.next) == <span class="literal">null</span> || s.thread != Thread.currentThread());&#125;</code></pre><p>看到这里，我们理解一下 <code>h != t &amp;&amp; ((s = h.next) == null || s.thread != Thread.currentThread());</code> 为什么要判断的头结点的下一个节点？第一个节点储存的数据是什么？</p><blockquote><p>双向链表中，第一个节点为虚节点，其实并不存储任何信息，只是占位。真正的第一个有数据的节点，是在第二个节点开始的。当<code>h != t</code> 时： 如果<code>(s = h.next) == null</code>，等待队列正在有线程进行初始化，但只是进行到了Tail指向Head，没有将Head指向Tail，此时队列中有元素，需要返回True（这块具体见下边代码分析）。 如果(s &#x3D; h.next) !&#x3D; null，说明此时队列中至少有一个有效节点。如果此时s.thread &#x3D;&#x3D; Thread.currentThread()，说明等待队列的第一个有效节点中的线程与当前线程相同，那么当前线程是可以获取资源的；如果s.thread !&#x3D; Thread.currentThread()，说明等待队列的第一个有效节点线程与当前线程不同，当前线程必须加入进等待队列。</p></blockquote><p>这时，我们再回顾一下节点的入队操作，<code>enq()</code> 方法</p><pre><code class="highlight java"><span class="comment">// java.util.concurrent.locks.AbstractQueuedSynchronizer#enq</span><span class="keyword">private</span> Node <span class="title function_">enq</span><span class="params">(<span class="keyword">final</span> Node node)</span> &#123;    <span class="comment">// 自旋操作</span>    <span class="keyword">for</span> (;;) &#123;        <span class="type">Node</span> <span class="variable">t</span> <span class="operator">=</span> tail;        <span class="comment">// 如果队列没有被初始化过，则先初始化一个虚拟节点（new Node()）</span>        <span class="keyword">if</span> (t == <span class="literal">null</span>) &#123; <span class="comment">// Must initialize</span>            <span class="comment">// 初始化虚节点，并将它设置成头节点</span>            <span class="keyword">if</span> (compareAndSetHead(<span class="keyword">new</span> <span class="title class_">Node</span>()))                tail = head;        &#125; <span class="keyword">else</span> &#123;            <span class="comment">// 队列不为空时，当前线程所在节点node的prev指针指向尾节点</span>            node.prev = t;            <span class="comment">// CAS设置当前节点为尾节点</span>            <span class="keyword">if</span> (compareAndSetTail(t, node)) &#123;                <span class="comment">// 之前的尾节点的next指针指向当前节点node</span>                t.next = node;                <span class="comment">// 返回之前的尾节点</span>                <span class="keyword">return</span> t;            &#125;        &#125;    &#125;&#125;</code></pre><p>节点入队不是原子操作，所以会出现短暂的 <code>head != tail</code>，此时Tail指向 <code>null</code>，而Head指向<code>虚节点</code>。这种情况下也需要将相关线程加入队列中。所以这块代码是为了解决极端情况下的并发问题。</p><h3 id="4-3-等待队列中线程出队列时机"><a href="#4-3-等待队列中线程出队列时机" class="headerlink" title="4.3 等待队列中线程出队列时机"></a>4.3 等待队列中线程出队列时机</h3><p>回到最初的源码：</p><pre><code class="highlight java"><span class="comment">// java.util.concurrent.locks.AbstractQueuedSynchronizer#acquire</span><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">void</span> <span class="title function_">acquire</span><span class="params">(<span class="type">int</span> arg)</span> &#123;    <span class="keyword">if</span> (!tryAcquire(arg) &amp;&amp; acquireQueued(addWaiter(Node.EXCLUSIVE), arg))        selfInterrupt();&#125;</code></pre><p>上文解释了<code>addWaiter</code>方法，这个方法其实就是把对应的线程以Node的数据结构形式加入到双端队列里，返回的是一个包含该线程的Node。而这个Node会作为参数，进入到<code>acquireQueued</code>方法中。<code>acquireQueued</code>方法可以对排队中的线程进行“获锁”操作。</p><p>总的来说，一个线程获取锁失败了，被放入等待队列，<code>acquireQueued</code>会把放入队列中的线程不断去获取锁，直到获取成功或者不再需要获取（中断）。</p><p>下面我们从“何时出队列？”和“如何出队列？”两个方向来分析一下acquireQueued源码：</p><pre><code class="highlight java"><span class="comment">// java.util.concurrent.locks.AbstractQueuedSynchronizer</span><span class="keyword">final</span> <span class="type">boolean</span> <span class="title function_">acquireQueued</span><span class="params">(<span class="keyword">final</span> Node node, <span class="type">int</span> arg)</span> &#123;<span class="comment">// 标记是否成功拿到资源</span><span class="type">boolean</span> <span class="variable">failed</span> <span class="operator">=</span> <span class="literal">true</span>;<span class="keyword">try</span> &#123;<span class="comment">// 标记等待过程中是否中断过</span><span class="type">boolean</span> <span class="variable">interrupted</span> <span class="operator">=</span> <span class="literal">false</span>;<span class="comment">// 开始自旋，要么获取锁，要么中断</span><span class="keyword">for</span> (;;) &#123;<span class="comment">// 获取当前节点的前驱节点</span><span class="keyword">final</span> <span class="type">Node</span> <span class="variable">p</span> <span class="operator">=</span> node.predecessor();<span class="comment">// 如果p是头结点，说明当前节点在真实数据队列的首部，就尝试获取锁（别忘了头结点是虚节点）</span><span class="keyword">if</span> (p == head &amp;&amp; tryAcquire(arg)) &#123;<span class="comment">// 获取锁成功，头指针移动到当前node</span>setHead(node);p.next = <span class="literal">null</span>; <span class="comment">// help GC</span>failed = <span class="literal">false</span>;<span class="keyword">return</span> interrupted;&#125;<span class="comment">// 说明p为头节点且当前没有获取到锁（可能是非公平锁被抢占了）或者是p不为头结点，这个时候就要判断当前node是否要被阻塞（被阻塞条件：前驱节点的waitStatus为-1），防止无限循环浪费资源。具体两个方法下面细细分析</span><span class="keyword">if</span> (shouldParkAfterFailedAcquire(p, node) &amp;&amp; parkAndCheckInterrupt())interrupted = <span class="literal">true</span>;&#125;&#125; <span class="keyword">finally</span> &#123;<span class="keyword">if</span> (failed)cancelAcquire(node);&#125;&#125;</code></pre><p>注：setHead方法是把当前节点置为虚节点，但并没有修改 <code>waitStatus</code>，因为它是一直需要用的数据。</p><pre><code class="highlight java"><span class="comment">// java.util.concurrent.locks.AbstractQueuedSynchronizer</span><span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">setHead</span><span class="params">(Node node)</span> &#123;head = node;node.thread = <span class="literal">null</span>;node.prev = <span class="literal">null</span>;&#125;<span class="comment">// java.util.concurrent.locks.AbstractQueuedSynchronizer</span><span class="comment">// 靠前驱节点判断当前线程是否应该被阻塞</span><span class="keyword">private</span> <span class="keyword">static</span> <span class="type">boolean</span> <span class="title function_">shouldParkAfterFailedAcquire</span><span class="params">(Node pred, Node node)</span> &#123;<span class="comment">// 获取头结点的节点状态</span><span class="type">int</span> <span class="variable">ws</span> <span class="operator">=</span> pred.waitStatus;<span class="comment">// 说明头结点处于唤醒状态</span><span class="keyword">if</span> (ws == Node.SIGNAL)<span class="keyword">return</span> <span class="literal">true</span>; <span class="comment">// 通过枚举值我们知道waitStatus&gt;0是取消状态</span><span class="keyword">if</span> (ws &gt; <span class="number">0</span>) &#123;<span class="keyword">do</span> &#123;<span class="comment">// 循环向前查找取消节点，把取消节点从队列中剔除</span>node.prev = pred = pred.prev;&#125; <span class="keyword">while</span> (pred.waitStatus &gt; <span class="number">0</span>);pred.next = node;&#125; <span class="keyword">else</span> &#123;<span class="comment">// 设置前任节点等待状态为SIGNAL</span>compareAndSetWaitStatus(pred, ws, Node.SIGNAL);&#125;<span class="keyword">return</span> <span class="literal">false</span>;&#125;</code></pre><p><code>shouldParkAfterFailedAcquire</code>方法实现业务：</p><ul><li>判断前节点（pred）waitStatus 是否为 SIGNAL(待唤醒)状态，如果是，直接返回true</li><li>如果前节点 <code>waitStatus &gt; 0</code> (已取消状态)，则从前节点开始一直往前找，找到一个<code>waitStatus</code>不大于0的节点，作为当前节点的前节点</li><li>如果前节点 <code>waitStatus = 0</code> (默认状态)，则将前节点的<code>waitStatus</code>设置成SIGNAL</li></ul><p><code>parkAndCheckInterrupt</code> 主要用于挂起当前线程，阻塞调用栈，返回当前线程的中断状态。</p><pre><code class="highlight java"><span class="comment">// java.util.concurrent.locks.AbstractQueuedSynchronizer</span><span class="keyword">private</span> <span class="keyword">final</span> <span class="type">boolean</span> <span class="title function_">parkAndCheckInterrupt</span><span class="params">()</span> &#123;    <span class="comment">// 挂起当前线程</span>    LockSupport.park(<span class="built_in">this</span>);    <span class="comment">// 当前线程重新执行后，判断线程是否被中断过，返回中断标记，并清除中断标记（如果返回为true，表示线程被中断过，由于interrupted 方法会清除中断标识，后面会通过 selfInterrupt()补充还原中断标识）</span>    <span class="keyword">return</span> Thread.interrupted();&#125;</code></pre><p>上述方法的流程图如下：</p><p><img src="https://raw.githubusercontent.com/GeorgeChan95/blogimg/master/img/2024/10/16/20241016-112025.png" alt="acquireQueued 调用流程"></p><p>从上图可以看出，跳出当前循环的条件是当“前置节点是头结点，且当前线程获取锁成功”。为了防止因死循环导致CPU资源被浪费，我们会判断前置节点的状态来决定是否要将当前线程挂起，具体挂起流程用流程图表示如下（shouldParkAfterFailedAcquire流程）：</p><p><img src="https://raw.githubusercontent.com/GeorgeChan95/blogimg/master/img/2024/10/16/20241016-131149.png" alt="shouldParkAfterFailedAcquire 流程"></p><p>由上述我们可以知道，此时经过 acquireQueued 方法的自旋处理后，头节点(虚节点) 的waitStatus设置成 SIGNAL(-1), 而 线程B 被挂起，等待唤醒。</p><p>此时队列如下：<br><img src="https://raw.githubusercontent.com/GeorgeChan95/blogimg/master/img/2024/10/16/20241016-112946.png" alt="线程B被挂起"></p><p>如果此时还有其它线程来争抢锁，例如：<code>线程C</code>、<code>线程D</code>、<code>线程E</code>、<code>线程F</code> ，也加入到队列中，如图下：</p><p><img src="https://raw.githubusercontent.com/GeorgeChan95/blogimg/master/img/2024/10/16/20241016-140123.png" alt="CLH队列"></p><p>尾节点 (NodeE) 的前节点waitStatus 都为 -1。</p><h3 id="4-4-CANCELLED状态节点生成"><a href="#4-4-CANCELLED状态节点生成" class="headerlink" title="4.4 CANCELLED状态节点生成"></a>4.4 CANCELLED状态节点生成</h3><p>如果线程在抢锁的过程中出现异常，或者线程被中断，此时 <code>acquireQueued</code> 方法会走到 <code>finally</code> 分支<code>，failed</code> 标识依然为 false</p><pre><code class="highlight java"><span class="comment">// java.util.concurrent.locks.AbstractQueuedSynchronizer</span><span class="keyword">final</span> <span class="type">boolean</span> <span class="title function_">acquireQueued</span><span class="params">(<span class="keyword">final</span> Node node, <span class="type">int</span> arg)</span> &#123;<span class="comment">// 标记是否成功拿到资源</span><span class="type">boolean</span> <span class="variable">failed</span> <span class="operator">=</span> <span class="literal">true</span>;<span class="keyword">try</span> &#123;<span class="comment">// 标记等待过程中是否中断过</span><span class="type">boolean</span> <span class="variable">interrupted</span> <span class="operator">=</span> <span class="literal">false</span>;<span class="comment">// 开始自旋，要么获取锁，要么中断</span><span class="keyword">for</span> (;;) &#123;<span class="comment">// 获取当前节点的前驱节点</span><span class="keyword">final</span> <span class="type">Node</span> <span class="variable">p</span> <span class="operator">=</span> node.predecessor();<span class="comment">// 如果p是头结点，说明当前节点在真实数据队列的首部，就尝试获取锁（别忘了头结点是虚节点）</span><span class="keyword">if</span> (p == head &amp;&amp; tryAcquire(arg)) &#123;...&#125;...&#125;&#125; <span class="keyword">finally</span> &#123;<span class="keyword">if</span> (failed) <span class="comment">// failed为false</span>             <span class="comment">// 执行线程的取消操作，从队列中出队</span>cancelAcquire(node);&#125;&#125;</code></pre><p>通过<code>cancelAcquire</code> 方法，将Node的状态标记为<code>CANCELLED</code>。接下来，我们逐行来分析这个方法的原理：</p><pre><code class="highlight java"><span class="comment">// java.util.concurrent.locks.AbstractQueuedSynchronizer</span><span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">cancelAcquire</span><span class="params">(Node node)</span> &#123;  <span class="comment">// 将无效节点过滤</span><span class="keyword">if</span> (node == <span class="literal">null</span>)<span class="keyword">return</span>;  <span class="comment">// 设置该节点不关联任何线程，也就是虚节点</span>node.thread = <span class="literal">null</span>;<span class="type">Node</span> <span class="variable">pred</span> <span class="operator">=</span> node.prev;  <span class="comment">// 通过前驱节点，跳过取消状态的node</span><span class="keyword">while</span> (pred.waitStatus &gt; <span class="number">0</span>)node.prev = pred = pred.prev;  <span class="comment">// 获取过滤后的前驱节点的后继节点</span><span class="type">Node</span> <span class="variable">predNext</span> <span class="operator">=</span> pred.next;  <span class="comment">// 把当前node的状态设置为CANCELLED</span>node.waitStatus = Node.CANCELLED;  <span class="comment">// 如果当前节点是尾节点，将从后往前的第一个非取消状态的节点设置为尾节点</span>  <span class="comment">// 更新失败的话，则进入else，如果更新成功，将tail的后继节点设置为null</span><span class="keyword">if</span> (node == tail &amp;&amp; compareAndSetTail(node, pred)) &#123;compareAndSetNext(pred, predNext, <span class="literal">null</span>);&#125; <span class="keyword">else</span> &#123;<span class="type">int</span> ws;    <span class="comment">// 如果当前节点不是head的后继节点，1:判断当前节点前驱节点的是否为SIGNAL，2:如果不是，则把前驱节点设置为SINGAL看是否成功</span>    <span class="comment">// 如果1和2中有一个为true，再判断前驱节点的线程是否为null</span>    <span class="comment">// 如果上述条件都满足，把当前节点的前驱节点的后继指针指向当前节点的后继节点</span><span class="keyword">if</span> (pred != head &amp;&amp; ((ws = pred.waitStatus) == Node.SIGNAL || (ws &lt;= <span class="number">0</span> &amp;&amp; compareAndSetWaitStatus(pred, ws, Node.SIGNAL))) &amp;&amp; pred.thread != <span class="literal">null</span>) &#123;<span class="type">Node</span> <span class="variable">next</span> <span class="operator">=</span> node.next;<span class="keyword">if</span> (next != <span class="literal">null</span> &amp;&amp; next.waitStatus &lt;= <span class="number">0</span>)compareAndSetNext(pred, predNext, next);&#125; <span class="keyword">else</span> &#123;      <span class="comment">// 如果当前节点是head的后继节点，或者上述条件不满足，那就唤醒当前节点的后继节点</span>unparkSuccessor(node);&#125;node.next = node; <span class="comment">// help GC</span>&#125;&#125;</code></pre><p>当前的流程：</p><ul><li>获取当前节点的前驱节点，如果前驱节点的状态是CANCELLED，那就一直往前遍历，找到第一个waitStatus &lt;&#x3D; 0的节点，将找到的Pred节点和当前Node关联，将当前Node设置为CANCELLED。</li><li>根据当前节点的位置，考虑以下三种情况：<ul><li>当前节点是尾节点。</li><li>当前节点是Head的后继节点。</li><li>当前节点不是Head的后继节点，也不是尾节点。</li></ul></li></ul><p>这里看一下<code>unparkSuccessor</code>方法：</p><pre><code class="highlight java"><span class="comment">// java.util.concurrent.locks.AbstractQueuedSynchronizer</span><span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">unparkSuccessor</span><span class="params">(Node node)</span> &#123;<span class="comment">// 获取头结点waitStatus</span><span class="type">int</span> <span class="variable">ws</span> <span class="operator">=</span> node.waitStatus;<span class="keyword">if</span> (ws &lt; <span class="number">0</span>)compareAndSetWaitStatus(node, ws, <span class="number">0</span>);<span class="comment">// 获取当前节点的下一个节点</span><span class="type">Node</span> <span class="variable">s</span> <span class="operator">=</span> node.next;<span class="comment">// 如果下个节点是null或者下个节点被cancelled，就找到队列最开始的非cancelled的节点</span><span class="keyword">if</span> (s == <span class="literal">null</span> || s.waitStatus &gt; <span class="number">0</span>) &#123;s = <span class="literal">null</span>;<span class="comment">// 就从尾部节点开始找，到队首，找到队列第一个waitStatus&lt;0的节点。</span><span class="keyword">for</span> (<span class="type">Node</span> <span class="variable">t</span> <span class="operator">=</span> tail; t != <span class="literal">null</span> &amp;&amp; t != node; t = t.prev)<span class="keyword">if</span> (t.waitStatus &lt;= <span class="number">0</span>)s = t;&#125;<span class="comment">// 如果当前节点的下个节点不为空，而且状态&lt;=0，就把下一个节点unpark</span><span class="keyword">if</span> (s != <span class="literal">null</span>)LockSupport.unpark(s.thread);&#125;</code></pre><p>根据上述第二条，我们来分析每一种情况的流程。</p><ul><li>当前节点是尾节点。</li></ul><p><img src="https://raw.githubusercontent.com/GeorgeChan95/blogimg/master/img/2024/10/16/20241016-152013.png" alt="当前节点是尾节点"></p><ul><li><p>当前节点是Head的后继节点。</p><p><img src="https://raw.githubusercontent.com/GeorgeChan95/blogimg/master/img/2024/10/16/20241016-152048.png" alt="当前节点是Head的后继节点"></p></li><li><p>当前节点不是Head的后继节点，也不是尾节点</p><p><img src="https://raw.githubusercontent.com/GeorgeChan95/blogimg/master/img/2024/10/16/20241016-152128.png" alt="即不是Head的后继节点，也不是尾节点"></p></li></ul><blockquote><p>以前面的线程队列为例，画流程示意图</p></blockquote><p>当前队列中的线程如下：<br><img src="https://raw.githubusercontent.com/GeorgeChan95/blogimg/master/img/2024/10/16/20241016-140123.png" alt="CLH队列"></p><p>此时 线程D 被中断执行，需要退出队列，退出后队列如下：<br><img src="https://raw.githubusercontent.com/GeorgeChan95/blogimg/master/img/2024/10/16/20241016-151241.png" alt="线程D被中断执行"></p><p>通过上面的流程，我们对于CANCELLED节点状态的产生和变化已经有了大致的了解，但是为什么所有的变化都是对Next指针进行了操作，而没有对Prev指针进行操作呢？什么情况下会对Prev指针进行操作？</p><blockquote><p>执行cancelAcquire的时候，当前节点的前置节点可能已经从队列中出去了（已经执行过Try代码块中的shouldParkAfterFailedAcquire方法了），如果此时修改Prev指针，有可能会导致Prev指向另一个已经移除队列的Node，因此这块变化Prev指针不安全。 shouldParkAfterFailedAcquire方法中，会执行下面的代码，其实就是在处理Prev指针。shouldParkAfterFailedAcquire是获取锁失败的情况下才会执行，进入该方法后，说明共享资源已被获取，当前节点之前的节点都不会出现变化，因此这个时候变更Prev指针比较安全。</p></blockquote><pre><code class="highlight java"><span class="keyword">do</span> &#123;    node.prev = pred = pred.prev;&#125; <span class="keyword">while</span> (pred.waitStatus &gt; <span class="number">0</span>);</code></pre><h2 id="5-如何解锁"><a href="#5-如何解锁" class="headerlink" title="5. 如何解锁"></a>5. 如何解锁</h2><p>前面我们说了，多个线程抢占资源，<code>线程A</code> 抢到了锁，<code>线程B</code>、<code>线程C</code>、<code>线程D</code>、<code>线程E</code> 没有抢到锁，进入CLH队列中的加锁情况，也说了 <code>线程D</code> 中断执行，退出队列的情况。</p><p>现在我们来说，<code>线程A</code> 执行结束，对AQS释放锁流程进行分析。由于ReentrantLock在解锁的时候，并不区分公平锁和非公平锁，所以我们直接看解锁的源码：</p><pre><code class="highlight java"><span class="comment">// java.util.concurrent.locks.ReentrantLock</span><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">unlock</span><span class="params">()</span> &#123;sync.release(<span class="number">1</span>);&#125;</code></pre><p>可以看到，本质释放锁的地方，是通过框架来完成的。</p><pre><code class="highlight java"><span class="comment">// java.util.concurrent.locks.AbstractQueuedSynchronizer</span><span class="keyword">public</span> <span class="keyword">final</span> <span class="type">boolean</span> <span class="title function_">release</span><span class="params">(<span class="type">int</span> arg)</span> &#123;    <span class="comment">// 尝试释放锁，成功返回true，失败则返回false</span>    <span class="keyword">if</span> (tryRelease(arg)) &#123;        <span class="comment">// 队列头节点</span>        <span class="type">Node</span> <span class="variable">h</span> <span class="operator">=</span> head;        <span class="keyword">if</span> (h != <span class="literal">null</span> &amp;&amp; h.waitStatus != <span class="number">0</span>)            <span class="comment">// 更新头节点的waitStatus，并唤醒头节点的后继节点</span>            unparkSuccessor(h);        <span class="keyword">return</span> <span class="literal">true</span>;    &#125;    <span class="keyword">return</span> <span class="literal">false</span>;&#125;</code></pre><p>在ReentrantLock里面的公平锁和非公平锁的父类Sync定义了可重入锁的释放锁机制。</p><pre><code class="highlight java"><span class="comment">// java.util.concurrent.locks.ReentrantLock.Sync</span><span class="comment">// 方法返回当前锁是不是没有被线程持有</span><span class="keyword">protected</span> <span class="keyword">final</span> <span class="type">boolean</span> <span class="title function_">tryRelease</span><span class="params">(<span class="type">int</span> releases)</span> &#123;<span class="comment">// 减少可重入次数</span><span class="type">int</span> <span class="variable">c</span> <span class="operator">=</span> getState() - releases;<span class="comment">// 当前线程不是持有锁的线程，抛出异常</span><span class="keyword">if</span> (Thread.currentThread() != getExclusiveOwnerThread())<span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">IllegalMonitorStateException</span>();<span class="type">boolean</span> <span class="variable">free</span> <span class="operator">=</span> <span class="literal">false</span>;<span class="comment">// 如果持有线程全部释放，将当前独占锁所有线程设置为null，并更新state</span><span class="keyword">if</span> (c == <span class="number">0</span>) &#123;free = <span class="literal">true</span>;setExclusiveOwnerThread(<span class="literal">null</span>);&#125;setState(c);<span class="keyword">return</span> free;&#125;</code></pre><p>这里反过来再看一下 java.util.concurrent.locks.AbstractQueuedSynchronizer#release 释放锁的代码</p><pre><code class="highlight java"><span class="comment">// java.util.concurrent.locks.AbstractQueuedSynchronizer</span><span class="keyword">public</span> <span class="keyword">final</span> <span class="type">boolean</span> <span class="title function_">release</span><span class="params">(<span class="type">int</span> arg)</span> &#123;<span class="comment">// 上边自定义的tryRelease如果返回true，说明该锁没有被任何线程持有</span><span class="keyword">if</span> (tryRelease(arg)) &#123;<span class="comment">// 获取头结点</span><span class="type">Node</span> <span class="variable">h</span> <span class="operator">=</span> head;<span class="comment">// 头结点不为空并且头结点的waitStatus不是初始化节点情况，解除线程挂起状态</span><span class="keyword">if</span> (h != <span class="literal">null</span> &amp;&amp; h.waitStatus != <span class="number">0</span>)unparkSuccessor(h);<span class="keyword">return</span> <span class="literal">true</span>;&#125;<span class="keyword">return</span> <span class="literal">false</span>;&#125;</code></pre><p>这里的判断条件为什么是h !&#x3D; null &amp;&amp; h.waitStatus !&#x3D; 0？</p><ul><li><code>h == null</code> Head还没初始化。初始情况下，<code>head == null</code>，第一个节点入队，Head会被初始化一个虚拟节点。所以说，这里如果还没来得及入队，就会出现head &#x3D;&#x3D; null 的情况。<ul><li>如：<code>线程A</code>执行结束，其它线程还没有争抢锁的情况</li></ul></li><li><code>h != null &amp;&amp; waitStatus == 0</code> 表明后继节点对应的线程仍在运行中，不需要唤醒。<ul><li>如：<code>线程A</code> 执行结束，其它线程刚刚开始争抢锁，CLH队列正在初始化</li></ul></li><li><code>h != null &amp;&amp; waitStatus &lt; 0</code> 表明后继节点可能被阻塞了，需要唤醒。<ul><li>如：线程A 执行结束，此时CLH队列已经有多个线程排队等待唤醒</li></ul></li></ul><p>再看一下unparkSuccessor方法：</p><pre><code class="highlight java"><span class="comment">// java.util.concurrent.locks.AbstractQueuedSynchronizer</span><span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">unparkSuccessor</span><span class="params">(Node node)</span> &#123;<span class="comment">// 获取头结点waitStatus</span><span class="type">int</span> <span class="variable">ws</span> <span class="operator">=</span> node.waitStatus;<span class="keyword">if</span> (ws &lt; <span class="number">0</span>)compareAndSetWaitStatus(node, ws, <span class="number">0</span>);<span class="comment">// 获取当前节点的下一个节点</span><span class="type">Node</span> <span class="variable">s</span> <span class="operator">=</span> node.next;<span class="comment">// 如果下个节点是null或者下个节点被cancelled，就找到队列最开始的非cancelled的节点</span><span class="keyword">if</span> (s == <span class="literal">null</span> || s.waitStatus &gt; <span class="number">0</span>) &#123;s = <span class="literal">null</span>;<span class="comment">// 就从尾部节点开始找，到队首，找到队列第一个waitStatus&lt;0的节点。</span><span class="keyword">for</span> (<span class="type">Node</span> <span class="variable">t</span> <span class="operator">=</span> tail; t != <span class="literal">null</span> &amp;&amp; t != node; t = t.prev)<span class="keyword">if</span> (t.waitStatus &lt;= <span class="number">0</span>)s = t;&#125;<span class="comment">// 如果当前节点的下个节点不为空，而且状态&lt;=0，就把下一个节点unpark</span><span class="keyword">if</span> (s != <span class="literal">null</span>)LockSupport.unpark(s.thread);&#125;</code></pre><p>对应到我们的CLH队列示例图，就是 <code>虚节点</code> 的 <code>waitStatus</code> 设置成了0，然后将 <code>线程B</code> unpark。</p><p><img src="https://raw.githubusercontent.com/GeorgeChan95/blogimg/master/img/2024/10/16/20241016-160950.png" alt="线程B解锁"></p><p>为什么要从后往前找第一个非Cancelled的节点呢？原因如下。</p><p>之前的 <code>addWaiter</code> 方法：</p><pre><code class="highlight java"><span class="comment">// java.util.concurrent.locks.AbstractQueuedSynchronizer#addWaiter</span><span class="keyword">private</span> Node <span class="title function_">addWaiter</span><span class="params">(Node mode)</span> &#123;    <span class="comment">// 通过当前的线程和锁模式新建一个节点</span>    <span class="type">Node</span> <span class="variable">node</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Node</span>(Thread.currentThread(), mode);    <span class="comment">// Pred指针指向尾节点Tail</span>    <span class="type">Node</span> <span class="variable">pred</span> <span class="operator">=</span> tail;    <span class="keyword">if</span> (pred != <span class="literal">null</span>) &#123;        <span class="comment">// 将New中Node的Prev指针指向Pred</span>        node.prev = pred;        <span class="comment">// CAS设置Tail节点为新建的节点</span>        <span class="keyword">if</span> (compareAndSetTail(pred, node)) &#123;            <span class="comment">// pred节点的next指针指向新的node节点</span>            pred.next = node;            <span class="comment">// 返回新建的node节点</span>            <span class="keyword">return</span> node;        &#125;    &#125;    <span class="comment">// node节点加入CLH队列</span>    enq(node);    <span class="comment">// 返回node节点</span>    <span class="keyword">return</span> node;&#125;</code></pre><p>我们从这里可以看到，节点入队并不是原子操作，也就是说，<code>node.prev = pred;</code> <code>compareAndSetTail(pred, node)</code>  这两个地方可以看作Tail入队的原子操作，但是此时 <code>pred.next = node;</code> 还没执行，如果这个时候执行了unparkSuccessor方法，就没办法从前往后找了，所以需要从后往前找。还有一点原因，在产生CANCELLED状态节点的时候，先断开的是Next指针，Prev指针并未断开，因此也是必须要从后往前遍历才能够遍历完全部的Node。</p><p>综上所述，如果是从前往后找，由于极端情况下入队的非原子操作和CANCELLED节点产生过程中断开Next指针的操作，可能会导致无法遍历所有的节点。所以，唤醒对应的线程后，对应的线程就会继续往下执行。</p><pre><code class="highlight java"></code></pre><h2 id="6-中断恢复后的执行流程"><a href="#6-中断恢复后的执行流程" class="headerlink" title="6. 中断恢复后的执行流程"></a>6. 中断恢复后的执行流程</h2><p><code>线程B</code> 被唤醒后，会执行<code>return Thread.interrupted();</code>，这个函数返回的是当前执行线程的中断状态，并清除。</p><pre><code class="highlight java"><span class="comment">// java.util.concurrent.locks.AbstractQueuedSynchronizer</span><span class="keyword">private</span> <span class="keyword">final</span> <span class="type">boolean</span> <span class="title function_">parkAndCheckInterrupt</span><span class="params">()</span> &#123;LockSupport.park(<span class="built_in">this</span>);<span class="keyword">return</span> Thread.interrupted();&#125;</code></pre><p>再回到 <code>acquireQueued</code> 代码，当 <code>parkAndCheckInterrupt</code> 返回True或者False的时候，interrupted的值不同，但都会执行下次循环。如果这个时候获取锁成功，就会把当前interrupted返回。</p><pre><code class="highlight java"><span class="comment">// java.util.concurrent.locks.AbstractQueuedSynchronizer</span><span class="keyword">final</span> <span class="type">boolean</span> <span class="title function_">acquireQueued</span><span class="params">(<span class="keyword">final</span> Node node, <span class="type">int</span> arg)</span> &#123;<span class="comment">// 标记是否成功拿到资源</span><span class="type">boolean</span> <span class="variable">failed</span> <span class="operator">=</span> <span class="literal">true</span>;<span class="keyword">try</span> &#123;<span class="comment">// 标记等待过程中是否中断过</span><span class="type">boolean</span> <span class="variable">interrupted</span> <span class="operator">=</span> <span class="literal">false</span>;<span class="comment">// 开始自旋，要么获取锁，要么中断</span><span class="keyword">for</span> (;;) &#123;<span class="comment">// 获取当前节点的前驱节点</span><span class="keyword">final</span> <span class="type">Node</span> <span class="variable">p</span> <span class="operator">=</span> node.predecessor();<span class="comment">// 如果p是头结点，说明当前节点在真实数据队列的首部，就尝试获取锁（别忘了头结点是虚节点）</span><span class="keyword">if</span> (p == head &amp;&amp; tryAcquire(arg)) &#123;<span class="comment">// 获取锁成功，头指针移动到当前node</span>setHead(node);p.next = <span class="literal">null</span>; <span class="comment">// help GC</span>failed = <span class="literal">false</span>;                 <span class="comment">// 返回线程的中断标识</span><span class="keyword">return</span> interrupted;&#125;<span class="comment">// 说明p为头节点且当前没有获取到锁（可能是非公平锁被抢占了）或者是p不为头结点，这个时候就要判断当前node是否要被阻塞（被阻塞条件：前驱节点的waitStatus为-1），防止无限循环浪费资源。具体两个方法下面细细分析</span><span class="keyword">if</span> (shouldParkAfterFailedAcquire(p, node) &amp;&amp; parkAndCheckInterrupt())                 <span class="comment">// 中断标识设置为true</span>interrupted = <span class="literal">true</span>;&#125;&#125; <span class="keyword">finally</span> &#123;<span class="keyword">if</span> (failed)             <span class="comment">// 取消线程执行</span>cancelAcquire(node);&#125;&#125;</code></pre><p>如果acquireQueued为True，就会执行selfInterrupt方法。</p><pre><code class="highlight java"><span class="comment">// java.util.concurrent.locks.AbstractQueuedSynchronizer</span><span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">selfInterrupt</span><span class="params">()</span> &#123;Thread.currentThread().interrupt();&#125;</code></pre><ul><li>当中断线程被唤醒时，并不知道被唤醒的原因，可能是当前线程在等待中被中断，也可能是释放了锁以后被唤醒。因此我们通过Thread.interrupted()方法检查中断标记（该方法返回了当前线程的中断状态，并将当前线程的中断标识设置为False），并记录下来，如果发现该线程被中断过，就再中断一次（重新恢复线程的中断标识）。</li><li>线程在等待资源的过程中被唤醒，唤醒后还是会不断地去尝试获取锁，直到抢到锁为止。也就是说，在整个流程中，并不响应中断，只是记录中断记录。最后抢到锁返回了，那么如果被中断过的话，就需要补充一次中断。</li></ul><h1 id="六、AQS应用"><a href="#六、AQS应用" class="headerlink" title="六、AQS应用"></a>六、AQS应用</h1><h2 id="1-ReentrantLock的可重入应用"><a href="#1-ReentrantLock的可重入应用" class="headerlink" title="1. ReentrantLock的可重入应用"></a>1. ReentrantLock的可重入应用</h2><p>ReentrantLock的可重入性是AQS很好的应用之一，在了解完上述知识点以后，我们很容易得知ReentrantLock实现可重入的方法。在ReentrantLock里面，不管是公平锁还是非公平锁，都有一段逻辑。</p><ul><li><p>公平锁：</p><pre><code class="highlight java"><span class="comment">// java.util.concurrent.locks.ReentrantLock.FairSync#tryAcquire</span><span class="keyword">if</span> (c == <span class="number">0</span>) &#123;<span class="keyword">if</span> (!hasQueuedPredecessors() &amp;&amp; compareAndSetState(<span class="number">0</span>, acquires)) &#123;setExclusiveOwnerThread(current);<span class="keyword">return</span> <span class="literal">true</span>;&#125;&#125;<span class="keyword">else</span> <span class="keyword">if</span> (current == getExclusiveOwnerThread()) &#123;<span class="type">int</span> <span class="variable">nextc</span> <span class="operator">=</span> c + acquires;<span class="keyword">if</span> (nextc &lt; <span class="number">0</span>)<span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">Error</span>(<span class="string">&quot;Maximum lock count exceeded&quot;</span>);setState(nextc);<span class="keyword">return</span> <span class="literal">true</span>;&#125;</code></pre></li><li><p>非公平锁：</p><pre><code class="highlight java"><span class="comment">// java.util.concurrent.locks.ReentrantLock.Sync#nonfairTryAcquire</span><span class="keyword">if</span> (c == <span class="number">0</span>) &#123;<span class="keyword">if</span> (compareAndSetState(<span class="number">0</span>, acquires))&#123;setExclusiveOwnerThread(current);<span class="keyword">return</span> <span class="literal">true</span>;&#125;&#125;<span class="keyword">else</span> <span class="keyword">if</span> (current == getExclusiveOwnerThread()) &#123;<span class="type">int</span> <span class="variable">nextc</span> <span class="operator">=</span> c + acquires;<span class="keyword">if</span> (nextc &lt; <span class="number">0</span>) <span class="comment">// overflow</span><span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">Error</span>(<span class="string">&quot;Maximum lock count exceeded&quot;</span>);setState(nextc);<span class="keyword">return</span> <span class="literal">true</span>;&#125;</code></pre></li></ul><p>从上面这两段都可以看到，有一个 <code>同步状态State</code> 来控制整体可重入的情况。<code>State</code>是<code>Volatile</code>修饰的，用于保证一定的可见性和有序性。</p><pre><code class="highlight java"><span class="comment">// java.util.concurrent.locks.AbstractQueuedSynchronizer</span><span class="keyword">private</span> <span class="keyword">volatile</span> <span class="type">int</span> state;</code></pre><p>接下来看State这个字段主要的过程：</p><ul><li>State初始化的时候为0，表示没有任何线程持有锁。</li><li>当有线程持有该锁时，值就会在原来的基础上+1，同一个线程多次获得锁是，就会多次+1，这里就是可重入的概念。</li><li>解锁也是对这个字段-1，一直到0，此线程对锁释放。</li></ul><h2 id="2-JUC中的应用场景"><a href="#2-JUC中的应用场景" class="headerlink" title="2. JUC中的应用场景"></a>2. JUC中的应用场景</h2><p>除了上边ReentrantLock的可重入性的应用，AQS作为并发编程的框架，为很多其他同步工具提供了良好的解决方案。下面列出了JUC中的几种同步工具，大体介绍一下AQS的应用场景：</p><table><thead><tr><th align="left">同步工具</th><th align="left">同步工具与AQS的关联</th></tr></thead><tbody><tr><td align="left">ReentrantLock</td><td align="left">使用AQS保存锁重复持有的次数。当一个线程获取锁时，ReentrantLock记录当前获得锁的线程标识，用于检测是否重复获取，以及错误线程试图解锁操作时异常情况的处理。</td></tr><tr><td align="left">Semaphore</td><td align="left">使用AQS同步状态来保存信号量的当前计数。tryRelease会增加计数，acquireShared会减少计数。</td></tr><tr><td align="left">CountDownLatch</td><td align="left">使用AQS同步状态来表示计数。计数为0时，所有的Acquire操作（CountDownLatch的await方法）才可以通过。</td></tr><tr><td align="left">ReentrantReadWriteLock</td><td align="left">使用AQS同步状态中的16位保存写锁持有的次数，剩下的16位用于保存读锁的持有次数。</td></tr><tr><td align="left">ThreadPoolExecutor</td><td align="left">Worker利用AQS同步状态实现对独占线程变量的设置（tryAcquire和tryRelease）。</td></tr></tbody></table><h2 id="3-自定义同步工具"><a href="#3-自定义同步工具" class="headerlink" title="3. 自定义同步工具"></a>3. 自定义同步工具</h2><p>了解AQS基本原理以后，按照上面所说的AQS知识点，自己实现一个同步工具。</p><pre><code class="highlight java"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">MyLock</span> &#123;    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">class</span> <span class="title class_">Sync</span> <span class="keyword">extends</span> <span class="title class_">AbstractQueuedSynchronizer</span> &#123;        <span class="meta">@Override</span>        <span class="keyword">protected</span> <span class="type">boolean</span> <span class="title function_">tryAcquire</span><span class="params">(<span class="type">int</span> arg)</span> &#123;            <span class="keyword">return</span> compareAndSetState(<span class="number">0</span>, <span class="number">1</span>);        &#125;        <span class="meta">@Override</span>        <span class="keyword">protected</span> <span class="type">boolean</span> <span class="title function_">tryRelease</span><span class="params">(<span class="type">int</span> arg)</span> &#123;            <span class="keyword">return</span> compareAndSetState(<span class="number">1</span>, <span class="number">0</span>);        &#125;        <span class="meta">@Override</span>        <span class="keyword">protected</span> <span class="type">boolean</span> <span class="title function_">isHeldExclusively</span><span class="params">()</span> &#123;            <span class="keyword">return</span> getState() == <span class="number">1</span>;        &#125;    &#125;    <span class="keyword">private</span> <span class="type">Sync</span> <span class="variable">sync</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Sync</span>();    <span class="comment">/**</span><span class="comment">     * 加锁</span><span class="comment">     */</span>    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">lock</span><span class="params">()</span> &#123;        sync.acquire(<span class="number">1</span>);    &#125;    <span class="comment">/**</span><span class="comment">     * 解锁</span><span class="comment">     */</span>    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">unlock</span><span class="params">()</span> &#123;        sync.release(<span class="number">1</span>);    &#125;&#125;</code></pre><p>测试代码：</p><pre><code class="highlight java"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">TestMyLock</span> &#123;    <span class="keyword">static</span> <span class="type">int</span> <span class="variable">count</span> <span class="operator">=</span> <span class="number">0</span>;    <span class="keyword">static</span> <span class="type">MyLock</span> <span class="variable">myLock</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">MyLock</span>();    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span> <span class="params">(String[] args)</span> <span class="keyword">throws</span> InterruptedException &#123;        <span class="type">Runnable</span> <span class="variable">runnable</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Runnable</span>() &#123;            <span class="meta">@Override</span>            <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span> <span class="params">()</span> &#123;                <span class="keyword">try</span> &#123;                    myLock.lock();                    <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; <span class="number">10000</span>; i++) &#123;                        count++;                    &#125;                &#125; <span class="keyword">catch</span> (Exception e) &#123;                    e.printStackTrace();                &#125; <span class="keyword">finally</span> &#123;                    myLock.unlock();                &#125;            &#125;        &#125;;        <span class="type">Thread</span> <span class="variable">thread1</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Thread</span>(runnable);        <span class="type">Thread</span> <span class="variable">thread2</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Thread</span>(runnable);        thread1.start();        thread2.start();        thread1.join();        thread2.join();        System.out.println(count);    &#125;&#125;</code></pre><p>运行结果：</p><pre><code class="highlight shell">20000</code></pre><p>上述代码每次运行结果都会是20000。通过简单的几行代码就能实现同步功能，这就是AQS的强大之处。</p><p>本文主要参考以下链接</p><blockquote><p><a href="https://tech.meituan.com/2019/12/05/aqs-theory-and-apply.html">从ReentrantLock的实现看AQS的原理及应用</a></p></blockquote>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;一、前置知识&quot;&gt;&lt;a href=&quot;#一、前置知识&quot; class=&quot;headerlink&quot; title=&quot;一、前置知识&quot;&gt;&lt;/a&gt;一、前置知识&lt;/h1&gt;&lt;ul&gt;
&lt;li&gt;&lt;p&gt;&lt;strong&gt;公平锁和非公平锁&lt;/strong&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;公平锁：锁被</summary>
      
    
    
    
    <category term="JUC" scheme="https://georgechan95.github.io/categories/JUC/"/>
    
    
    <category term="java" scheme="https://georgechan95.github.io/tags/java/"/>
    
    <category term="juc" scheme="https://georgechan95.github.io/tags/juc/"/>
    
  </entry>
  
  <entry>
    <title>11-JUC进阶-Synchronized与锁升级</title>
    <link href="https://georgechan95.github.io/blog/3e0d7592.html"/>
    <id>https://georgechan95.github.io/blog/3e0d7592.html</id>
    <published>2024-10-06T01:28:00.000Z</published>
    <updated>2024-10-08T04:46:24.744Z</updated>
    
    <content type="html"><![CDATA[<h1 id="一、Synchronized的性能变化"><a href="#一、Synchronized的性能变化" class="headerlink" title="一、Synchronized的性能变化"></a>一、Synchronized的性能变化</h1><h2 id="1-用户态与内核态切换"><a href="#1-用户态与内核态切换" class="headerlink" title="1. 用户态与内核态切换"></a>1. 用户态与内核态切换</h2><p>java5以前，只有 <code>Synchronized</code>，这个是操作系统级别的重量级操作.</p><p>重量级锁，假如锁的竞争比较激烈的话，性能会下降. 因为重量级锁需要在用户态和内核态之间反复切换,消耗大量的资源.</p><p><strong>Java5之前，用户态和内核态之间的切换</strong></p><p><img src="https://raw.githubusercontent.com/GeorgeChan95/blogimg/master/img/2024/10/06/20241006-105654.png" alt="用户态和内核态之间的切换"></p><p> java的线程是映射到操作系统原生线程之上的，如果要阻塞或唤醒一个线程就需要操作系统介入，需要在用户态与核心态之间切换，这种切换会消耗大量的系统资源，因为用户态与内核态都有各自专用的内存空间，专用的寄存器等，用户态切换至内核态需要传递给许多变量、参数给内核，内核也需要保护好用户态在切换时的一些寄存器值、变量等，以便内核态调用结束后切换回用户态继续工作。</p><p>在Java早期版本中，synchronized属于重量级锁，效率低下，因为监视器锁（monitor）是依赖于底层的操作系统的Mutex Lock来实现的，挂起线程和恢复线程都需要转入内核态去完成，阻塞或唤醒一个Java线程需要操作系统切换CPU状态来完成，这种状态切换需要耗费处理器时间，如果同步代码块中内容过于简单，这种切换的时间可能比用户代码执行的时间还长”，时间成本相对较高，这也是为什么早期的synchronized效率低的原因.</p><p>Java 6之后，为了减少获得锁和释放锁所带来的性能消耗，引入了轻量级锁和偏向锁</p><h2 id="2-为什么每一个对象都可以成为锁"><a href="#2-为什么每一个对象都可以成为锁" class="headerlink" title="2. 为什么每一个对象都可以成为锁?"></a>2. 为什么每一个对象都可以成为锁?</h2><p><strong>Java对象头</strong></p><p>在Hotspot虚拟机中，对象在内存中的布局分为三块区域：对象头、实例数据和对齐填充；Java对象头是实现synchronized的锁对象的基础，一般而言，synchronized使用的锁对象是存储在Java对象头里。它是轻量级锁和偏向锁的关键</p><p><strong>Mawrk Word</strong></p><p>Mark Word用于存储对象自身的运行时数据，如哈希码（HashCode）、GC分代年龄、锁状态标志、线程持有的锁、偏向线程 ID、偏向时间戳等等。</p><p>在64位系统中，Mark Word占了8个字节，类型指针占了8个字节，一共是16个字节</p><p><img src="https://raw.githubusercontent.com/GeorgeChan95/blogimg/master/img/2024/10/04/20241004-110133.png" alt="Mark Word 的存储结构"></p><p><strong>在源码中的体现：</strong></p><p>如果想更深入了解对象头在JVM源码中的定义，需要关心几个文件，<code>oop.hpp/markOop.hpp</code> 。</p><p><code>oop.hpp</code>，每个 Java Object 在 JVM 内部都有一个 native 的 C++ 对象 oop&#x2F;oopDesc 与之对应。先在<code>oop.hpp</code>中看<code>oopDesc</code>的定义：</p><pre><code class="highlight cpp"><span class="keyword">class</span> <span class="title class_">oopDesc</span> &#123;  <span class="keyword">friend</span> <span class="keyword">class</span> <span class="title class_">VMStructs</span>; <span class="keyword">private</span>:  <span class="keyword">volatile</span> markOop  _mark;<span class="comment">//理解为对象头</span>  <span class="keyword">union</span> <span class="title class_">_metadata</span> &#123;    Klass*      _klass;<span class="comment">//理解为类型指针</span>    narrowKlass _compressed_klass; <span class="comment">//默认开启压缩</span>  &#125; _metadata;......</code></pre><p><code>_mark</code> 被声明在 oopDesc 类的顶部，所以这个 <code>_mark</code> 可以认为是一个 头部, 也就是上面那个图种提到的头部保存了一些重要的状态和标识信息，在<code>markOop.hpp</code>文件中有一些注释说明markOop的内存布局：</p><p>官网: <a href="https://hg.openjdk.org/jdk8u/jdk8u/hotspot/file/89fb452b3688/src/share/vm/oops/markOop.hpp">https://hg.openjdk.org/jdk8u/jdk8u/hotspot/file/89fb452b3688/src/share/vm/oops/markOop.hpp</a></p><pre><code class="highlight cpp"><span class="comment">//  64 bits:</span><span class="comment">//  --------</span><span class="comment">//  unused:25 hash:31 --&gt;| unused:1   age:4    biased_lock:1 lock:2 (normal object) // 普通无锁对象</span><span class="comment">//  JavaThread*:54 epoch:2 unused:1   age:4    biased_lock:1 lock:2 (biased object) // 偏向锁对象</span><span class="comment">//  PromotedObject*:61 ---------------------&gt;| promo_bits:3 -----&gt;| (CMS promoted object) // CMS垃圾回收器中的提升对象</span><span class="comment">//  size:64 -----------------------------------------------------&gt;| (CMS free block) // CMS垃圾回收器中的空闲块</span><span class="comment">//</span></code></pre><h4 id="Monitor"><a href="#Monitor" class="headerlink" title="Monitor"></a><strong>Monitor</strong></h4><p>什么是Monitor？我们可以把它理解为一个同步工具，也可以描述为一种同步机制。所有的Java对象是天生的Monitor，每个object的对象里 markOop-&gt;monitor() 里可以保存ObjectMonitor的对象。从源码层面看一下monitor对象.</p><ul><li>oop.hpp下的oopDesc类是JVM对象的顶级基类，所以每个object对象都包含markOop</li></ul><pre><code class="highlight cpp"><span class="keyword">class</span> <span class="title class_">oopDesc</span> &#123;<span class="comment">//顶层基类</span>  <span class="keyword">friend</span> <span class="keyword">class</span> <span class="title class_">VMStructs</span>; <span class="keyword">private</span>:  <span class="keyword">volatile</span> markOop  _mark;<span class="comment">//这也就是每个对象的mark头</span>  <span class="keyword">union</span> <span class="title class_">_metadata</span> &#123;    Klass*      _klass;    narrowKlass _compressed_klass;  &#125; _metadata;</code></pre><ul><li><p>markOop.hpp 中 <code>markOopDesc</code> 继承自oopDesc</p><p><img src="https://raw.githubusercontent.com/GeorgeChan95/blogimg/master/img/2024/10/06/20241006-120755.png" alt="markOopDesc"></p><p>并扩展了自己的monitor方法，这个方法返回一个ObjectMonitor指针对象：这个ObjectMonitor 其实就是对象监视器</p><p><img src="https://raw.githubusercontent.com/GeorgeChan95/blogimg/master/img/2024/10/06/20241006-120858.png" alt="img"></p></li><li><p><code>objectMonitor.hpp</code> , 在hotspot虚拟机中，采用 <code>ObjectMonitor</code> 类来实现 monitor：</p><p><img src="https://raw.githubusercontent.com/GeorgeChan95/blogimg/master/img/2024/10/06/20241006-121021.png" alt="objectMonitor.hpp"></p></li></ul><p>到目前位置，对于锁存在哪个位置，我们已经清楚了，<strong>锁存在于每个对象的 markOop 对象头中</strong>.对于为什么每个对象都可以成为锁呢？ 因为每个 Java Object 在 JVM 内部都有一个 native 的 C++ 对象 oop&#x2F;oopDesc 与之对应，而对应的 oop&#x2F;oopDesc 都会存在一个markOop 对象头，而这个对象头是存储锁的位置，<strong>里面还有对象监视器，即ObjectMonitor</strong>，所以这也是为什么每个对象都能成为锁的原因之一。</p><h2 id="3-Java6的优化提升"><a href="#3-Java6的优化提升" class="headerlink" title="3. Java6的优化提升"></a>3. Java6的优化提升</h2><p>java6开始，优化Synchronized, Java6之后，为了减少获得锁和释放锁所带来的性能消耗，引入了<strong>轻量级锁</strong>和<strong>偏向锁</strong></p><p>​</p><h1 id="二、synchronized锁种类及升级步骤"><a href="#二、synchronized锁种类及升级步骤" class="headerlink" title="二、synchronized锁种类及升级步骤"></a>二、synchronized锁种类及升级步骤</h1><h2 id="1-多线程访问的3种情况"><a href="#1-多线程访问的3种情况" class="headerlink" title="1. 多线程访问的3种情况"></a>1. 多线程访问的3种情况</h2><ul><li>只有一个线程来访问</li><li>有2个线程交替访问</li><li>竞争激烈，多个线程同时来访问</li></ul><h2 id="2-升级流程"><a href="#2-升级流程" class="headerlink" title="2. 升级流程"></a>2. 升级流程</h2><p>synchronized 用的锁是存在Java对象头里的Mark Word中, 锁升级功能主要依赖 MarkWord 中锁标志位和释放偏向锁标志位.</p><p><img src="https://raw.githubusercontent.com/GeorgeChan95/blogimg/master/img/2024/10/06/20241006-122447.png" alt="64位系统,对象内存布局"></p><p><strong>锁指向</strong></p><ul><li>偏向锁：MarkWord存储的是<strong>偏向的线程ID</strong>；</li><li>轻量锁：MarkWord存储的是<strong>指向线程栈中Lock Record的指针</strong>；</li><li>重量锁：MarkWord存储的是<strong>指向堆中的monitor对象的指针</strong>；</li></ul><h2 id="3-无锁"><a href="#3-无锁" class="headerlink" title="3. 无锁"></a>3. 无锁</h2><p><strong>引入依赖</strong></p><pre><code class="highlight xml"><span class="comment">&lt;!--</span><span class="comment">   官网：http://openjdk.java.net/projects/code-tools/jol/</span><span class="comment">   定位：分析对象在JVM的大小和分布</span><span class="comment">--&gt;</span><span class="tag">&lt;<span class="name">dependency</span>&gt;</span>    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.openjdk.jol<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span>    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>jol-core<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span>    <span class="tag">&lt;<span class="name">version</span>&gt;</span>0.9<span class="tag">&lt;/<span class="name">version</span>&gt;</span><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></code></pre><p><strong>实例代码</strong></p><pre><code class="highlight java"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">MyObject</span> &#123;    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;        <span class="type">Object</span> <span class="variable">o</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Object</span>();        System.out.println(<span class="string">&quot;10进制hash码：&quot;</span> + o.hashCode());        System.out.println(<span class="string">&quot;16进制hash码：&quot;</span> + Integer.toHexString(o.hashCode()));        System.out.println(<span class="string">&quot;2进制hash码：&quot;</span> + Integer.toBinaryString(o.hashCode()));        System.out.println(ClassLayout.parseInstance(o).toPrintable());    &#125;&#125;</code></pre><p>打印如下:</p><p><img src="https://raw.githubusercontent.com/GeorgeChan95/blogimg/master/img/2024/10/06/20241006-123233.png" alt="image-20241006123232465"></p><p><strong>001</strong> 表示无锁.</p><p><strong>注意, 对象头打印内容为 大端序.</strong></p><p><strong>大端序（Big-Endian）</strong>将数据的低位字节存放在内存的高位地址，高位字节存放在低位地址。这种排列方式与数据用字节表示时的书写顺序一致，符合人类的阅读习惯。</p><p><strong>小端序（Little-Endian）</strong>，将一个多位数的低位放在较小的地址处，高位放在较大的地址处，则称小端序。小端序与人类的阅读习惯相反，但更符合计算机读取内存的方式，因为CPU读取内存中的数据时，是从低地址向高地址方向进行读取的。</p><p>对象头大端序打印如下(前8子节):</p><pre><code class="highlight plaintext">00000001 01000001 00111010 00101011 01000101 00000000 00000000 00000000</code></pre><p>转为小端序如下:</p><pre><code class="highlight plaintext">00000000 00000000 00000000 01000101 00101011 00111010 01000001 00000001</code></pre><p>前25位没有用到, 中间31位即为hashCode: 1000101 00101011 00111010 01000001, 与print语句打印的 2进制hash码一致.</p><p><img src="https://raw.githubusercontent.com/GeorgeChan95/blogimg/master/img/2024/10/06/20241006-124320.png" alt="无锁态"></p><h2 id="4-偏锁"><a href="#4-偏锁" class="headerlink" title="4. 偏锁"></a>4. 偏锁</h2><h3 id="4-1-主要作用"><a href="#4-1-主要作用" class="headerlink" title="4.1 主要作用"></a>4.1 主要作用</h3><ul><li>当一段同步代码一直被同一个线程多次访问，由于只有一个线程那么该线程在后续访问时便会自动获得锁</li></ul><p>Hotspot 的作者经过研究发现，大多数情况下：</p><p>多线程的情况下，锁不仅不存在多线程竞争，还存在锁由同一线程多次获得的情况，偏向锁就是在这种情况下出现的，它的出现是为了解决只有在一个线程执行同步时提高性能。</p><h3 id="4-2-偏向锁的持有"><a href="#4-2-偏向锁的持有" class="headerlink" title="4.2 偏向锁的持有"></a>4.2 偏向锁的持有</h3><h4 id="4-2-1-理论"><a href="#4-2-1-理论" class="headerlink" title="4.2.1 理论"></a>4.2.1 理论</h4><p><strong>理论解析</strong></p><p>在实际应用运行过程中发现，“锁总是同一个线程持有，很少发生竞争”，也就是说锁总是被第一个占用他的线程拥有，这个线程就是锁的偏向线程。</p><p>那么只需要**在锁第一次被拥有的时候，记录下偏向线程ID。这样偏向线程就一直持有着锁(后续这个线程进入和退出这段加了同步锁的代码块时，不需要再次加锁和释放锁。而是直接比较对象头里面是否存储了指向当前线程的偏向锁)**。<br>如果相等表示偏向锁是偏向于当前线程的，就不需要再尝试获得锁了，直到竞争发生才释放锁。以后每次同步，检查锁的偏向线程ID与当前线程ID是否一致，如果一致直接进入同步。无需每次加锁解锁都去CAS更新对象头。如果自始至终使用锁的线程只有一个，很明显偏向锁几乎没有额外开销，性能极高。</p><p> 假如不一致意味着发生了竞争，锁已经不是总是偏向于同一个线程了，这时候可能需要升级变为轻量级锁，才能保证线程间公平竞争锁。偏向锁只有遇到其他线程尝试竞争偏向锁时，持有偏向锁的线程才会释放锁，线程是不会主动释放偏向锁的。</p><p><strong>技术实现</strong></p><p>一个synchronized方法被一个线程抢到了锁时，那这个方法所在的对象就会修改Mark Word 的偏向锁状态位，同时还会占用前54位来存储线程指针作为标识。若该线程再次访问同一个synchronized方法时，该线程只需去对象头的Mark Word 中去判断一下是否有偏向锁指向当前线程的ID，无需再进入 Monitor 去竞争对象了。</p><p><img src="https://raw.githubusercontent.com/GeorgeChan95/blogimg/master/img/2024/10/06/20241006-144737.png" alt="64位锁标识"></p><h4 id="4-2-2-案例说明"><a href="#4-2-2-案例说明" class="headerlink" title="4.2.2 案例说明"></a>4.2.2 案例说明</h4><p>偏向锁的操作不用涉及操作系统，不涉及用户到内核转换，我们以一个account对象的“对象头”为例.</p><p><img src="https://raw.githubusercontent.com/GeorgeChan95/blogimg/master/img/2024/10/06/20241006-144929.png" alt="Account对象"></p><p>假如有一个线程执行到synchronized代码块的时候，JVM使用CAS操作把线程指针ID记录到Mark Word当中，并修改标偏向标识，表示当前线程就获得该锁。锁对象变成偏向锁（通过CAS修改对象头里的锁标志位），字面意思是“偏向于第一个获得它的线程”的锁。<strong>执行完同步代码块后，线程并不会主动释放偏向锁。</strong></p><p><img src="https://raw.githubusercontent.com/GeorgeChan95/blogimg/master/img/2024/10/06/20241006-145047.png" alt="对象头"></p><p>这时线程获得了锁，可以执行同步代码块。当该线程第二次到达同步代码块时会判断此时持有锁的线程是否还是自己（持有锁的线程ID也在对象头里），JVM通过account对象的Mark Word判断：当前线程ID还在，说明还持有着这个对象的锁，就可以继续进入临界区工作。由于之前没有释放锁，这里也就不需要重新加锁。 如果自始至终使用锁的线程只有一个，很明显偏向锁几乎没有额外开销，性能极高。</p><p>结论：JVM不用和操作系统协商设置Mutex(争取内核)，它只需要记录下线程ID就表示自己获得了当前锁，不用操作系统介入。<br>上述就是偏向锁：<strong>在没有其他线程竞争的时候，一直偏向偏心当前线程，当前线程可以一直执行。</strong></p><h3 id="4-3-偏向锁JVM命令"><a href="#4-3-偏向锁JVM命令" class="headerlink" title="4.3 偏向锁JVM命令"></a>4.3 偏向锁JVM命令</h3><p><code>java -XX:+PrintFlagsInitial |grep BiasedLock*</code></p><p><img src="https://raw.githubusercontent.com/GeorgeChan95/blogimg/master/img/2024/10/06/20241006-145555.png" alt="偏向锁命令"></p><p><strong>参数说明</strong></p><p><img src="https://raw.githubusercontent.com/GeorgeChan95/blogimg/master/img/2024/10/06/20241006-145638.png" alt="image-20241006145637339"></p><p>实际上偏向锁在JDK1.6之后是默认开启的，但是启动时间有延迟，所以需要添加参数 <code>-XX:BiasedLockingStartupDelay=0</code>，让其在程序启动时立刻启动。</p><ul><li><p>开启偏向锁</p><p><code>-XX:+UseBiasedLocking -XX:BiasedLockingStartupDelay=0</code></p></li><li><p>关闭偏向锁：关闭之后程序默认会直接进入 &#x3D;&gt; 轻量级锁状态。</p><p><code>-XX:-UseBiasedLocking</code></p></li></ul><h3 id="4-4-代码验证"><a href="#4-4-代码验证" class="headerlink" title="4.4 代码验证"></a>4.4 代码验证</h3><pre><code class="highlight java"><span class="comment">/**</span><span class="comment"> * <span class="doctag">@author</span> George Chan</span><span class="comment"> * <span class="doctag">@date</span> 2024/10/6 14:58</span><span class="comment"> * &lt;p&gt;</span><span class="comment"> *     验证Jdk1.8 默认开启偏向锁</span><span class="comment"> *     设置 VM option : -XX:BiasedLockingStartupDelay=0</span><span class="comment"> * &lt;/p&gt;</span><span class="comment"> */</span><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">BiasedLockDemo</span> &#123;    <span class="keyword">private</span> <span class="keyword">static</span> <span class="type">Object</span> <span class="variable">objectLock</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Object</span>();    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;        <span class="keyword">new</span> <span class="title class_">Thread</span>(() -&gt; &#123;            <span class="keyword">synchronized</span> (objectLock) &#123;                System.out.println(ClassLayout.parseInstance(objectLock).toPrintable());            &#125;        &#125;).start();    &#125;&#125;</code></pre><p>打印如下:</p><p><img src="https://raw.githubusercontent.com/GeorgeChan95/blogimg/master/img/2024/10/06/20241006-150251.png" alt="默认开启偏向锁"></p><p>注意: 偏向锁默认程序启动4秒后开启,如果不设置启动参数: <code>-XX:BiasedLockingStartupDelay=0</code>, 则程序启动打印显示为 轻量级锁.</p><h3 id="4-5-偏向锁的撤销"><a href="#4-5-偏向锁的撤销" class="headerlink" title="4.5 偏向锁的撤销"></a>4.5 偏向锁的撤销</h3><p>当有另外线程逐步来竞争锁的时候，就不能再使用偏向锁了，要升级为轻量级锁.</p><p><strong>竞争线程尝试CAS更新对象头失败，会等待到全局安全点（此时不会执行任何代码）撤销偏向锁。</strong></p><p><strong>偏向锁的撤销</strong></p><p>偏向锁使用一种等到竞争出现才释放锁的机制，只有当其他线程竞争锁时，持有偏向锁的原来线程才会被撤销。<br>撤销需要等待全局安全点(该时间点上没有字节码正在执行)，同时检查持有偏向锁的线程是否还在执行： </p><ul><li>第一个线程正在执行synchronized方法(处于同步块)，它还没有执行完，其它线程来抢夺，该偏向锁会被取消掉并出现锁升级。<br>此时轻量级锁由原持有偏向锁的线程持有，继续执行其同步代码，而正在竞争的线程会进入自旋等待获得该轻量级锁。</li><li>第一个线程执行完成synchronized方法(退出同步块)，则将对象头设置成无锁状态并撤销偏向锁，重新偏向 。</li></ul><p><img src="https://raw.githubusercontent.com/GeorgeChan95/blogimg/master/img/2024/10/06/20241006-151632.png" alt="撤销偏向锁的过程"></p><h3 id="4-6-总体步骤流程图示"><a href="#4-6-总体步骤流程图示" class="headerlink" title="4.6 总体步骤流程图示"></a>4.6 总体步骤流程图示</h3><p><strong>图示1</strong></p><p><a href="https://www.processon.com/view/61cb1799f346fb2161a3ecfc">https://www.processon.com/view/61cb1799f346fb2161a3ecfc</a></p><p><img src="https://raw.githubusercontent.com/GeorgeChan95/blogimg/master/img/2024/10/06/20241006-152712.png" alt="锁的升级流程图"></p><p><strong>图示2</strong></p><p><img src="https://raw.githubusercontent.com/GeorgeChan95/blogimg/master/img/2024/10/06/20241006-153339.png" alt="image-20241006153337711"></p><h2 id="5-轻锁"><a href="#5-轻锁" class="headerlink" title="5. 轻锁"></a>5. 轻锁</h2><h3 id="5-1-主要作用"><a href="#5-1-主要作用" class="headerlink" title="5.1 主要作用"></a>5.1 主要作用</h3><p>有线程来参与锁的竞争，但是获取锁的冲突时间极短.</p><p>本质就是自旋锁.</p><p><strong>锁标识位: 00</strong></p><h3 id="5-2-轻量级锁的获取"><a href="#5-2-轻量级锁的获取" class="headerlink" title="5.2 轻量级锁的获取"></a>5.2 轻量级锁的获取</h3><p>轻量级锁是为了在线程近乎交替执行同步块时提高性能。</p><p><strong>主要目的</strong>： 在没有多线程竞争的前提下，通过CAS减少重量级锁使用操作系统互斥量产生的性能消耗，即:先自旋再阻塞。</p><p><strong>升级时机：</strong> 当关闭偏向锁功能或多线程竞争偏向锁会导致偏向锁升级为轻量级锁</p><p>假如线程A已经拿到锁，这时线程B又来抢该对象的锁，由于该对象的锁已经被线程A拿到，当前该锁已是偏向锁了。而线程B在争抢时发现对象头Mark Word中的线程ID不是线程B自己的线程ID(而是线程A)，那线程B就会进行CAS操作希望能获得锁。</p><p>此时线程B操作中有两种情况：</p><ul><li><p>如果锁获取成功，直接替换Mark Word中的线程ID为B自己的ID(A → B)，重新偏向于其他线程(即将偏向锁交给其他线程，相当于当前线程”被”释放了锁)，该锁会保持偏向锁状态，A线程Over，B线程上位；</p><p><img src="https://raw.githubusercontent.com/GeorgeChan95/blogimg/master/img/2024/10/06/20241006-162752.png" alt="偏向锁"></p></li><li><p>如果锁获取失败，则偏向锁升级为轻量级锁，此时轻量级锁由原持有偏向锁的线程持有，继续执行其同步代码，而正在竞争的线程B会进入自旋等待获得该轻量级锁。</p><p><img src="https://raw.githubusercontent.com/GeorgeChan95/blogimg/master/img/2024/10/06/20241006-162745.png" alt="轻量级锁"></p></li></ul><h3 id="5-3-代码验证"><a href="#5-3-代码验证" class="headerlink" title="5.3 代码验证"></a>5.3 代码验证</h3><p>程序启动参数设置: <code>-XX:-UseBiasedLocking</code> , 关闭偏向锁, 则默认为轻量级锁.</p><pre><code class="highlight java"><span class="comment">/**</span><span class="comment"> * <span class="doctag">@author</span> George Chan</span><span class="comment"> * <span class="doctag">@date</span> 2024/10/6 14:58</span><span class="comment"> * &lt;p&gt;</span><span class="comment"> *     验证轻量级锁:</span><span class="comment"> *     设置VM option : -XX:-UseBiasedLocking</span><span class="comment"> * &lt;/p&gt;</span><span class="comment"> */</span><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">BiasedLockDemo</span> &#123;    <span class="keyword">private</span> <span class="keyword">static</span> <span class="type">Object</span> <span class="variable">objectLock</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Object</span>();    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;        <span class="keyword">new</span> <span class="title class_">Thread</span>(() -&gt; &#123;            <span class="keyword">synchronized</span> (objectLock) &#123;                System.out.println(ClassLayout.parseInstance(objectLock).toPrintable());            &#125;        &#125;).start();    &#125;&#125;</code></pre><p>打印如下:</p><p><img src="https://raw.githubusercontent.com/GeorgeChan95/blogimg/master/img/2024/10/06/20241006-163122.png" alt="轻量级锁的标识位"></p><p><strong>000 表示 轻量级锁</strong></p><h3 id="5-4-图示"><a href="#5-4-图示" class="headerlink" title="5.4 图示"></a>5.4 图示</h3><p>见 4.6 </p><h3 id="5-5-自旋达到一定次数和程度"><a href="#5-5-自旋达到一定次数和程度" class="headerlink" title="5.5 自旋达到一定次数和程度"></a>5.5 自旋达到一定次数和程度</h3><h4 id="5-5-1-java6之前"><a href="#5-5-1-java6之前" class="headerlink" title="5.5.1 java6之前"></a>5.5.1 java6之前</h4><ul><li><p>默认启用，默认情况下自旋的次数是 10 次</p><p><code>-XX:PreBlockSpin=10</code> 来修改</p></li><li><p>或者自旋线程数超过cpu核数一半</p></li></ul><h4 id="5-5-2-Java6之后"><a href="#5-5-2-Java6之后" class="headerlink" title="5.5.2 Java6之后"></a>5.5.2 Java6之后</h4><p>采用自适应调整自旋次数. 自适应意味着自旋的次数不是固定不变的,而是根据： </p><ul><li>同一个锁上一次自旋的时间。</li><li>拥有锁线程的状态来决定。</li></ul><h3 id="5-6-轻量锁与偏向锁的区别和不同"><a href="#5-6-轻量锁与偏向锁的区别和不同" class="headerlink" title="5.6 轻量锁与偏向锁的区别和不同"></a>5.6 轻量锁与偏向锁的区别和不同</h3><ul><li>争夺轻量级锁失败时，自旋尝试抢占锁</li><li>轻量级锁每次退出同步块都需要释放锁，而偏向锁是在竞争发生时才释放锁</li></ul><h2 id="6-重锁"><a href="#6-重锁" class="headerlink" title="6. 重锁"></a>6. 重锁</h2><p>重锁发生在有大量的线程参与锁的竞争，冲突性很高的场景中.</p><h4 id="6-1-锁标志位"><a href="#6-1-锁标志位" class="headerlink" title="6.1 锁标志位"></a>6.1 锁标志位</h4><p><img src="https://raw.githubusercontent.com/GeorgeChan95/blogimg/master/img/2024/10/06/20241006-165212.png" alt="重锁"></p><h3 id="6-2-代码验证"><a href="#6-2-代码验证" class="headerlink" title="6.2 代码验证"></a>6.2 代码验证</h3><pre><code class="highlight java"><span class="comment">/**</span><span class="comment"> * <span class="doctag">@author</span> George Chan</span><span class="comment"> * <span class="doctag">@date</span> 2024/10/6 14:58</span><span class="comment"> * &lt;p&gt;</span><span class="comment"> *     关闭偏向锁:</span><span class="comment"> *     设置VM option : -XX:-UseBiasedLocking</span><span class="comment"> * &lt;/p&gt;</span><span class="comment"> */</span><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">BiasedLockDemo</span> &#123;    <span class="keyword">private</span> <span class="keyword">static</span> <span class="type">Object</span> <span class="variable">objectLock</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Object</span>();    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;        <span class="keyword">new</span> <span class="title class_">Thread</span>(() -&gt; &#123;            <span class="keyword">synchronized</span> (objectLock) &#123;                System.out.println(ClassLayout.parseInstance(objectLock).toPrintable());            &#125;        &#125;).start();        <span class="keyword">new</span> <span class="title class_">Thread</span>(() -&gt; &#123;            <span class="keyword">synchronized</span> (objectLock) &#123;                System.out.println(ClassLayout.parseInstance(objectLock).toPrintable());            &#125;        &#125;).start();        <span class="keyword">new</span> <span class="title class_">Thread</span>(() -&gt; &#123;            <span class="keyword">synchronized</span> (objectLock) &#123;                System.out.println(ClassLayout.parseInstance(objectLock).toPrintable());            &#125;        &#125;).start();    &#125;&#125;</code></pre><p>打印如下:</p><p><img src="https://raw.githubusercontent.com/GeorgeChan95/blogimg/master/img/2024/10/06/20241006-165452.png" alt="重锁的锁标志位"></p><h1 id="三、各种锁的总结"><a href="#三、各种锁的总结" class="headerlink" title="三、各种锁的总结"></a>三、各种锁的总结</h1><p>各种锁优缺点、synchronized锁升级和实现原理</p><p><img src="https://raw.githubusercontent.com/GeorgeChan95/blogimg/master/img/2024/10/06/20241006-165615.png" alt="锁的优缺点对比"></p><p>synchronized锁升级过程总结：就是先自旋，不行再阻塞。</p><p>实际上是把之前的悲观锁(重量级锁)变成在一定条件下使用偏向锁以及使用轻量级(自旋锁CAS)的形式</p><p>synchronized在修饰方法和代码块在字节码上实现方式有很大差异，但是内部实现还是基于对象头的MarkWord来实现的。</p><p>JDK1.6之前synchronized使用的是重量级锁，JDK1.6之后进行了优化，拥有了<strong>无锁-&gt;偏向锁-&gt;轻量级锁-&gt;重量级锁</strong>的升级过程，而不是无论什么情况都使用重量级锁。</p><ul><li>偏向锁:适用于单线程适用的情况，在不存在锁竞争的时候进入同步方法&#x2F;代码块则使用偏向锁。</li><li>轻量级锁：适用于竞争较不激烈的情况(这和乐观锁的使用范围类似)， 存在竞争时升级为轻量级锁，轻量级锁采用的是自旋锁，如果同步方法&#x2F;代码块执行时间很短的话，采用轻量级锁虽然会占用cpu资源但是相对比使用重量级锁还是更高效。</li><li>重量级锁：适用于竞争激烈的情况，如果同步方法&#x2F;代码块执行时间很长，那么使用轻量级锁自旋带来的性能消耗就比使用重量级锁更严重，这时候就需要升级为重量级锁。</li></ul><h1 id="四、JIT编译器对锁的优化"><a href="#四、JIT编译器对锁的优化" class="headerlink" title="四、JIT编译器对锁的优化"></a>四、JIT编译器对锁的优化</h1><p>JIT (Just In Time Compiler)，一般翻译为即时编译器. 在代码编译阶段会根据代码的实际运行情况 , 使用 锁消除, 锁粗话 的方式,对同步方法或或同步代码块进行优化处理.</p><h2 id="1-锁消除"><a href="#1-锁消除" class="headerlink" title="1. 锁消除"></a>1. 锁消除</h2><p>从JIT角度看相当于无视它，synchronized (o)不存在了,这个锁对象并没有被共用扩散到其它线程使用，极端的说就是根本没有加这个锁对象的底层机器码，消除了锁的使用</p><pre><code class="highlight java"><span class="comment">/**</span><span class="comment"> * 锁消除</span><span class="comment"> * 从JIT角度看相当于无视它，synchronized (o)不存在了,这个锁对象并没有被共用扩散到其它线程使用，</span><span class="comment"> * 极端的说就是根本没有加这个锁对象的底层机器码，消除了锁的使用</span><span class="comment"> */</span><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">LockClearUPDemo</span> &#123;    <span class="keyword">static</span> <span class="type">Object</span> <span class="variable">objectLock</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Object</span>();<span class="comment">//正常的,有且仅有同一把锁</span>        <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">m1</span><span class="params">()</span> &#123;        <span class="type">Object</span> <span class="variable">objectLock</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Object</span>();<span class="comment">//锁消除</span>        <span class="keyword">synchronized</span> (objectLock) &#123;            System.out.println(<span class="string">&quot;----hello lock&quot;</span>);        &#125;    &#125;    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;        <span class="type">LockClearUPDemo</span> <span class="variable">demo</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">LockClearUPDemo</span>();        demo.m1();    &#125;&#125;</code></pre><p>由于锁对象 objectLock  定义在 方法 m1 内部,对于每一次方法调用,都会重新创建一把新的锁,各线程拿到的锁都不是同一把锁,这是没有意义的锁, JIT 编译器在编译过程中对锁进行了消除.</p><h2 id="2-锁粗化"><a href="#2-锁粗化" class="headerlink" title="2. 锁粗化"></a>2. 锁粗化</h2><p>假如方法中首尾相接，前后相邻的都是同一个锁对象，那JIT编译器就会把这几个synchronized块合并成一个大块，加粗加大范围，一次申请锁使用即可，避免次次的申请和释放锁，提升了性能.</p><pre><code class="highlight java"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">LockBigDemo</span> &#123;    <span class="keyword">static</span> <span class="type">Object</span> <span class="variable">objectLock</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Object</span>();    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;        <span class="keyword">new</span> <span class="title class_">Thread</span>(() -&gt; &#123;            <span class="keyword">synchronized</span> (objectLock) &#123;                System.out.println(<span class="string">&quot;11111&quot;</span>);            &#125;            <span class="keyword">synchronized</span> (objectLock) &#123;                System.out.println(<span class="string">&quot;22222&quot;</span>);            &#125;            <span class="keyword">synchronized</span> (objectLock) &#123;                System.out.println(<span class="string">&quot;33333&quot;</span>);            &#125;        &#125;, <span class="string">&quot;a&quot;</span>).start();        <span class="keyword">new</span> <span class="title class_">Thread</span>(() -&gt; &#123;            <span class="keyword">synchronized</span> (objectLock) &#123;                System.out.println(<span class="string">&quot;44444&quot;</span>);            &#125;            <span class="keyword">synchronized</span> (objectLock) &#123;                System.out.println(<span class="string">&quot;55555&quot;</span>);            &#125;            <span class="keyword">synchronized</span> (objectLock) &#123;                System.out.println(<span class="string">&quot;66666&quot;</span>);            &#125;        &#125;, <span class="string">&quot;b&quot;</span>).start();    &#125;&#125;<span class="comment">// 上述代码经过JIT锁粗话后变为:</span><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">LockBigDemo</span> &#123;    <span class="keyword">static</span> <span class="type">Object</span> <span class="variable">objectLock</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Object</span>();    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;        <span class="keyword">new</span> <span class="title class_">Thread</span>(() -&gt; &#123;            <span class="keyword">synchronized</span> (objectLock) &#123;                System.out.println(<span class="string">&quot;11111&quot;</span>);                System.out.println(<span class="string">&quot;22222&quot;</span>);                System.out.println(<span class="string">&quot;33333&quot;</span>);            &#125;        &#125;, <span class="string">&quot;a&quot;</span>).start();        <span class="keyword">new</span> <span class="title class_">Thread</span>(() -&gt; &#123;            <span class="keyword">synchronized</span> (objectLock) &#123;                System.out.println(<span class="string">&quot;44444&quot;</span>);                System.out.println(<span class="string">&quot;55555&quot;</span>);                System.out.println(<span class="string">&quot;66666&quot;</span>);            &#125;        &#125;, <span class="string">&quot;b&quot;</span>).start();    &#125;&#125;</code></pre>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;一、Synchronized的性能变化&quot;&gt;&lt;a href=&quot;#一、Synchronized的性能变化&quot; class=&quot;headerlink&quot; title=&quot;一、Synchronized的性能变化&quot;&gt;&lt;/a&gt;一、Synchronized的性能变化&lt;/h1&gt;&lt;h2 i</summary>
      
    
    
    
    <category term="JUC" scheme="https://georgechan95.github.io/categories/JUC/"/>
    
    
    <category term="java" scheme="https://georgechan95.github.io/tags/java/"/>
    
    <category term="juc" scheme="https://georgechan95.github.io/tags/juc/"/>
    
  </entry>
  
  <entry>
    <title>10-JUC进阶-Java对象内存布局和对象头</title>
    <link href="https://georgechan95.github.io/blog/4502cffa.html"/>
    <id>https://georgechan95.github.io/blog/4502cffa.html</id>
    <published>2024-10-04T01:54:40.000Z</published>
    <updated>2024-10-08T04:46:24.744Z</updated>
    
    <content type="html"><![CDATA[<h1 id="一、对象在堆内存中布局"><a href="#一、对象在堆内存中布局" class="headerlink" title="一、对象在堆内存中布局"></a>一、对象在堆内存中布局</h1><h2 id="1-官方定义"><a href="#1-官方定义" class="headerlink" title="1. 官方定义"></a>1. 官方定义</h2><p>在HotSpot虚拟机里,对象在堆内存中的存储布局可以划分为三个部分: 对象头(Header), 实例数据(Instance Data), 对齐填充(Padding).</p><p><img src="https://raw.githubusercontent.com/GeorgeChan95/blogimg/master/img/2024/10/04/20241004-104806.png" alt="对象内存存储布局"></p><h2 id="2-对象在堆内存中的存储布局"><a href="#2-对象在堆内存中的存储布局" class="headerlink" title="2. 对象在堆内存中的存储布局"></a>2. 对象在堆内存中的存储布局</h2><h3 id="2-1-对象头"><a href="#2-1-对象头" class="headerlink" title="2.1 对象头"></a>2.1 对象头</h3><h4 id="2-1-1-对象标记Mark-Word"><a href="#2-1-1-对象标记Mark-Word" class="headerlink" title="2.1.1 对象标记Mark Word"></a>2.1.1 对象标记Mark Word</h4><p><strong>Mark Word保存什么?</strong></p><p>默认存储对象的HashCode、分代年龄和锁标志位等信息。<br>这些信息都是与对象自身定义无关的数据，所以MarkWord被设计成一个非固定的数据结构以便在极小的空间内存存储尽量多的数据。<br>它会根据对象的状态复用自己的存储空间，也就是说在运行期间MarkWord里存储的数据会随着锁标志位的变化而变化。</p><p><img src="https://raw.githubusercontent.com/GeorgeChan95/blogimg/master/img/2024/10/04/20241004-105323.png" alt="对象内部结构图"></p><p><img src="https://raw.githubusercontent.com/GeorgeChan95/blogimg/master/img/2024/10/04/20241004-105333.png" alt="mark word"></p><p>在64位系统中，Mark Word占了8个字节，类型指针占了8个字节，一共是16个字节</p><p><img src="https://raw.githubusercontent.com/GeorgeChan95/blogimg/master/img/2024/10/04/20241004-110133.png" alt="Mark Word 的存储结构"></p><h4 id="2-1-2-类元信息-又叫类型指针"><a href="#2-1-2-类元信息-又叫类型指针" class="headerlink" title="2.1.2 类元信息(又叫类型指针)"></a>2.1.2 类元信息(又叫类型指针)</h4><p>类型指针指向方法区中类的元数据.</p><p>对象指向它的类元数据的指针，虚拟机通过这个指针来确定这个对象是哪个类的实例。</p><p><img src="https://raw.githubusercontent.com/GeorgeChan95/blogimg/master/img/2024/10/04/20241004-110248.png" alt="类型指针"></p><h4 id="2-1-3-对象头多大"><a href="#2-1-3-对象头多大" class="headerlink" title="2.1.3 对象头多大"></a>2.1.3 对象头多大</h4><p>在64位系统中，Mark Word占了8个字节，类型指针占了8个字节，一共是16个字节。</p><p>(在实际运行的过程中,JVM会默认开启压缩指针,压缩后对象头没有16个子节这么大.)</p><h3 id="2-2-实例数据"><a href="#2-2-实例数据" class="headerlink" title="2.2 实例数据"></a>2.2 实例数据</h3><p>存放类的属性(Field)数据信息，包括父类的属性信息，<br>如果是<strong>数组</strong>的实例部分还包括<strong>数组的长度</strong>，这部分内存按4字节对齐。</p><h3 id="2-3-对齐填充"><a href="#2-3-对齐填充" class="headerlink" title="2.3 对齐填充"></a>2.3 对齐填充</h3><p>虚拟机要求对象起始地址必须是8字节的整数倍。填充数据不是必须存在的，仅仅是为了字节对齐, 这部分内存按8字节补充对齐。</p><h2 id="3-官网理论"><a href="#3-官网理论" class="headerlink" title="3. 官网理论"></a>3. 官网理论</h2><ul><li><p>Hotspot术语表官网</p><p><a href="http://openjdk.java.net/groups/hotspot/docs/HotSpotGlossary.html">http://openjdk.java.net/groups/hotspot/docs/HotSpotGlossary.html</a></p><p><img src="https://raw.githubusercontent.com/GeorgeChan95/blogimg/master/img/2024/10/04/20241004-111833.png" alt="Hotspot术语表官网"></p></li><li><p>底层源码理论证明</p><p><a href="http://hg.openjdk.java.net/jdk8u/jdk8u/hotspot/file/89fb452b3688/src/share/vm/oops/oop.hpp">http://hg.openjdk.java.net/jdk8u/jdk8u/hotspot/file/89fb452b3688/src/share/vm/oops/oop.hpp</a></p><p><img src="https://raw.githubusercontent.com/GeorgeChan95/blogimg/master/img/2024/10/04/20241004-111932.png" alt="hotspot源码"></p></li></ul><p><code>_mark</code>字段是 mark word，<code>_metadata</code> 是类指针 klass pointer，<br>对象头（object header）即是由这两个字段组成，这些术语可以参考Hotspot术语表，</p><p><img src="https://raw.githubusercontent.com/GeorgeChan95/blogimg/master/img/2024/10/04/20241004-112042.png" alt="说明"></p><h1 id="二、再说对象头的MarkWord"><a href="#二、再说对象头的MarkWord" class="headerlink" title="二、再说对象头的MarkWord"></a>二、再说对象头的MarkWord</h1><h2 id="1-32位虚拟机-了解"><a href="#1-32位虚拟机-了解" class="headerlink" title="1. 32位虚拟机(了解)"></a>1. 32位虚拟机(了解)</h2><p><img src="https://raw.githubusercontent.com/GeorgeChan95/blogimg/master/img/2024/10/04/20241004-112158.png" alt="32位虚拟机"></p><h2 id="2-64位虚拟机-重要"><a href="#2-64位虚拟机-重要" class="headerlink" title="2. 64位虚拟机(重要)"></a>2. 64位虚拟机(重要)</h2><p><img src="https://raw.githubusercontent.com/GeorgeChan95/blogimg/master/img/2024/10/04/20241004-112508.png" alt="64位虚拟机"></p><p><img src="https://raw.githubusercontent.com/GeorgeChan95/blogimg/master/img/2024/10/04/20241004-112836.png" alt="对象内部结构图"></p><p><img src="https://raw.githubusercontent.com/GeorgeChan95/blogimg/master/img/2024/10/04/20241004-112923.png" alt="HotSpot的实现"></p><p>对象布局、GC回收和后面的锁升级就是对象标记MarkWord里面标志位的变化</p><h1 id="三、分析Object-obj-new-Object"><a href="#三、分析Object-obj-new-Object" class="headerlink" title="三、分析Object obj &#x3D; new Object()"></a>三、分析Object obj &#x3D; new Object()</h1><h2 id="1-JOL证明"><a href="#1-JOL证明" class="headerlink" title="1. JOL证明"></a>1. JOL证明</h2><h3 id="1-1-JOL官网"><a href="#1-1-JOL官网" class="headerlink" title="1.1 JOL官网"></a>1.1 JOL官网</h3><p><a href="http://openjdk.java.net/projects/code-tools/jol/">http://openjdk.java.net/projects/code-tools/jol/</a></p><p><strong>pom</strong></p><pre><code class="highlight xml"><span class="comment">&lt;!--</span><span class="comment">官网：http://openjdk.java.net/projects/code-tools/jol/</span><span class="comment">定位：分析对象在JVM的大小和分布</span><span class="comment">--&gt;</span><span class="tag">&lt;<span class="name">dependency</span>&gt;</span>    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.openjdk.jol<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span>    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>jol-core<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span>    <span class="tag">&lt;<span class="name">version</span>&gt;</span>0.9<span class="tag">&lt;/<span class="name">version</span>&gt;</span><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></code></pre><h3 id="1-2-测试案例"><a href="#1-2-测试案例" class="headerlink" title="1.2 测试案例"></a>1.2 测试案例</h3><pre><code class="highlight java"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">MyObject</span> &#123;    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span>&#123;        <span class="comment">//VM的细节详细情况</span>        System.out.println(VM.current().details());        <span class="comment">//所有的对象分配的字节都是8的整数倍。</span>        System.out.println(VM.current().objectAlignment());    &#125;&#125;</code></pre><p>打印如下:</p><pre><code class="highlight shell"><span class="meta prompt_"># </span><span class="language-bash">WARNING: Unable to get Instrumentation. Dynamic Attach failed. You may add this JAR as -javaagent manually, or supply -Djdk.attach.allowAttachSelf</span><span class="meta prompt_"># </span><span class="language-bash">Running 64-bit HotSpot VM.</span><span class="meta prompt_"># </span><span class="language-bash">Using compressed oop with 3-bit <span class="built_in">shift</span>.</span><span class="meta prompt_"># </span><span class="language-bash">Using compressed klass with 0x0000000800000000 base address and 0-bit <span class="built_in">shift</span>.</span><span class="meta prompt_"># </span><span class="language-bash">Objects are 8 bytes aligned.</span><span class="meta prompt_"># </span><span class="language-bash">Field sizes by <span class="built_in">type</span>: 4, 1, 1, 2, 2, 4, 4, 8, 8 [bytes]</span><span class="meta prompt_"># </span><span class="language-bash">Array element sizes: 4, 1, 1, 2, 2, 4, 4, 8, 8 [bytes]</span>8</code></pre><p>从日志可以看出,对象是 8 子节对齐的.</p><h2 id="2-案例2"><a href="#2-案例2" class="headerlink" title="2. 案例2"></a>2. 案例2</h2><pre><code class="highlight java"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">MyObject</span> &#123;    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span>&#123;        <span class="type">Object</span> <span class="variable">o</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Object</span>();        System.out.println( ClassLayout.parseInstance(o).toPrintable());    &#125;&#125;</code></pre><p>打印如下:</p><p><img src="https://raw.githubusercontent.com/GeorgeChan95/blogimg/master/img/2024/10/04/20241004-115343.png" alt="jdk8"></p><p><img src="https://raw.githubusercontent.com/GeorgeChan95/blogimg/master/img/2024/10/04/20241004-114547.png" alt="image-20241004114546567"></p><table><thead><tr><th>属性</th><th>描述</th></tr></thead><tbody><tr><td>OFFSET</td><td>偏移量，也就是到这个字段位置所占用的byte数</td></tr><tr><td>SIZE</td><td>后面类型的字节大小</td></tr><tr><td>TYPE</td><td>是Class中定义的类型</td></tr><tr><td>DESCRIPTION</td><td>DESCRIPTION是类型的描述</td></tr><tr><td>VALUE</td><td>VALUE是TYPE在内存中的值</td></tr></tbody></table><h2 id="3-分代年龄"><a href="#3-分代年龄" class="headerlink" title="3. 分代年龄"></a>3. 分代年龄</h2><p>GC年龄采用4位bit存储，最大为15，例如 <code>-XX:MaxTenuringThreshold=15</code> 参数默认值就是15</p><p>如果设置参数超过15则会报错:</p><pre><code class="highlight shell">Error: Could not create the Java Virtual Machine.Error: A fatal exception has occurred. Program will exit.MaxTenuringThreshold of 16 is invalid; must be between 0 and 15</code></pre><h2 id="4-参数说明"><a href="#4-参数说明" class="headerlink" title="4. 参数说明"></a>4. 参数说明</h2><ul><li><p>查看默认的参数</p><p><code>java -XX:+PrintCommandLineFlags -version</code></p><pre><code class="highlight plaintext">-XX:InitialHeapSize=532618688 -XX:MaxHeapSize=8521899008 -XX:+PrintCommandLineFlags -XX:+UseCompressedClassPointers -XX:+UseCompressedOops -XX:-UseLargePagesIndividualAllocation -XX:+UseParallelGCjava version &quot;1.8.0_241&quot;Java(TM) SE Runtime Environment (build 1.8.0_241-b07)Java HotSpot(TM) 64-Bit Server VM (build 25.241-b07, mixed mode)</code></pre><p><code>-XX:+UseCompressedClassPointers</code> 表示默认开启了压缩指针, 因此对象头打印结果,类型指针不是理论上的8子节,变成了4子节.</p><p><img src="https://raw.githubusercontent.com/GeorgeChan95/blogimg/master/img/2024/10/04/20241004-115751.png" alt="自动对齐"></p></li><li><p>手动关闭压缩</p><p><code>-XX:-UseCompressedClassPointers</code></p><p><img src="https://raw.githubusercontent.com/GeorgeChan95/blogimg/master/img/2024/10/04/20241004-120017.png" alt="关闭了自动压缩"></p></li></ul>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;一、对象在堆内存中布局&quot;&gt;&lt;a href=&quot;#一、对象在堆内存中布局&quot; class=&quot;headerlink&quot; title=&quot;一、对象在堆内存中布局&quot;&gt;&lt;/a&gt;一、对象在堆内存中布局&lt;/h1&gt;&lt;h2 id=&quot;1-官方定义&quot;&gt;&lt;a href=&quot;#1-官方定义&quot; cla</summary>
      
    
    
    
    <category term="JUC" scheme="https://georgechan95.github.io/categories/JUC/"/>
    
    
    <category term="java" scheme="https://georgechan95.github.io/tags/java/"/>
    
    <category term="juc" scheme="https://georgechan95.github.io/tags/juc/"/>
    
  </entry>
  
  <entry>
    <title>09-JUC进阶-ThreadLocal</title>
    <link href="https://georgechan95.github.io/blog/4de6a39b.html"/>
    <id>https://georgechan95.github.io/blog/4de6a39b.html</id>
    <published>2024-10-01T12:39:10.000Z</published>
    <updated>2024-10-08T04:46:24.744Z</updated>
    
    <content type="html"><![CDATA[<h1 id="一、ThreadLocal简介"><a href="#一、ThreadLocal简介" class="headerlink" title="一、ThreadLocal简介"></a>一、ThreadLocal简介</h1><p>官方文档: <a href="https://www.runoob.com/manual/jdk11api/java.base/java/lang/ThreadLocal.html">https://www.runoob.com/manual/jdk11api/java.base/java/lang/ThreadLocal.html</a></p><h2 id="1-简介"><a href="#1-简介" class="headerlink" title="1. 简介"></a>1. 简介</h2><p>ThreadLocal提供线程局部变量。这些变量与正常的变量不同，因为每一个线程在访问ThreadLocal实例的时候（通过其get或set方法）都有自己的、独立初始化的变量副本。ThreadLocal实例通常是类中的私有静态字段，使用它的目的是希望将状态（例如，用户ID或事务ID）与线程关联起来。</p><h2 id="2-作用"><a href="#2-作用" class="headerlink" title="2. 作用"></a>2. 作用</h2><p>实现每一个线程都有自己专属的本地变量副本(不和其它线程共享)，主要解决了让每个线程绑定自己的值，通过使用get()和set()方法，获取默认值或将其值更改为当前线程所存的副本的值从而避免了线程安全问题。</p><p><img src="https://raw.githubusercontent.com/GeorgeChan95/blogimg/master/img/2024/10/02/20241002-062934.png" alt="ThreadLocal"></p><h2 id="3-常用API介绍"><a href="#3-常用API介绍" class="headerlink" title="3. 常用API介绍"></a>3. 常用API介绍</h2><ul><li><p><code>get()</code></p><p>返回当前线程的此线程局部变量副本中的值。 如果变量没有当前线程的值，则首先将其初始化为调用initialValue()方法返回的值。</p></li><li><p><code>initialValue()</code></p><p>返回此线程局部变量的当前线程的“初始值”。 当第一次一个线程访问get()方法,该方法将被调用的.除非线程先调用的set(T)方法，在这种情况下initialValue方法将不被调用的线程。 通常，每个线程最多调用一次此方法，但如果后续调用remove()后跟get() ，则可以再次调用此方法。</p><p>这个实现只返回<code>null</code> ; 如果程序员希望线程局部变量具有除<code>null</code>之外的初始值， <code>ThreadLocal</code>必须对<code>ThreadLocal</code>进行子类化，并且重写此方法。 通常，将使用匿名内部类。</p></li><li><p><code>remove()</code></p><p>删除此线程局部变量的当前线程值。 如果当前线程的此线程局部变量随后是read ，则其值将通过调用其initialValue()方法重新初始化。 这可能导致在当前线程中多次调用initialValue方法。</p></li><li><p>set(T value)</p><p>将此线程局部变量的当前线程副本设置为指定值。 大多数子类都不需要重写此方法，仅依靠initialValue()方法来设置线程局部的值。</p></li><li><p>withInitial(Supplier&lt;? extends S&gt; supplier)</p><p>创建一个线程局部变量。 通过调用<code>get</code>上的<code>Supplier</code>方法确定变量的初始值。</p></li></ul><p><img src="https://raw.githubusercontent.com/GeorgeChan95/blogimg/master/img/2024/10/02/20241002-064534.png" alt="常用API"></p><h2 id="4-入门案例"><a href="#4-入门案例" class="headerlink" title="4. 入门案例"></a>4. 入门案例</h2><h3 id="4-1-案例代码"><a href="#4-1-案例代码" class="headerlink" title="4.1 案例代码"></a>4.1 案例代码</h3><p>公司各个销售人员, 按照出单数各自统计, 使用ThreadLocal实现.</p><pre><code class="highlight java"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ThreadLocalTest</span> &#123;    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> InterruptedException &#123;        <span class="type">MyHouse</span> <span class="variable">house</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">MyHouse</span>();        <span class="keyword">new</span> <span class="title class_">Thread</span>(() -&gt; &#123;            <span class="keyword">try</span> &#123;                <span class="type">int</span> <span class="variable">num</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Random</span>().nextInt(<span class="number">10</span>);                <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; num; i++) &#123;                    house.saleHouse();                &#125;                System.out.println(Thread.currentThread().getName() + <span class="string">&quot;卖出了:&quot;</span> + house.threadLocal.get() + <span class="string">&quot;套房子&quot;</span>);            &#125; <span class="keyword">finally</span> &#123;                house.threadLocal.remove();            &#125;        &#125;, <span class="string">&quot;销售1&quot;</span>).start();        <span class="keyword">new</span> <span class="title class_">Thread</span>(() -&gt; &#123;            <span class="keyword">try</span> &#123;                <span class="type">int</span> <span class="variable">num</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Random</span>().nextInt(<span class="number">10</span>);                <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; num; i++) &#123;                    house.saleHouse();                &#125;                System.out.println(Thread.currentThread().getName() + <span class="string">&quot;卖出了:&quot;</span> + house.threadLocal.get() + <span class="string">&quot;套房子&quot;</span>);            &#125; <span class="keyword">finally</span> &#123;                house.threadLocal.remove();            &#125;        &#125;, <span class="string">&quot;销售2&quot;</span>).start();        <span class="keyword">new</span> <span class="title class_">Thread</span>(() -&gt; &#123;            <span class="keyword">try</span> &#123;                <span class="type">int</span> <span class="variable">num</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Random</span>().nextInt(<span class="number">10</span>);                <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; num; i++) &#123;                    house.saleHouse();                &#125;                System.out.println(Thread.currentThread().getName() + <span class="string">&quot;卖出了:&quot;</span> + house.threadLocal.get() + <span class="string">&quot;套房子&quot;</span>);            &#125; <span class="keyword">finally</span> &#123;                house.threadLocal.remove();            &#125;        &#125;, <span class="string">&quot;销售3&quot;</span>).start();        TimeUnit.SECONDS.sleep(<span class="number">1</span>);    &#125;&#125;<span class="keyword">class</span> <span class="title class_">MyHouse</span> &#123;    <span class="comment">// 初始化ThreadLocal,设置初始值为:0</span>    ThreadLocal&lt;Integer&gt; threadLocal = ThreadLocal.withInitial(() -&gt; <span class="number">0</span>);    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">saleHouse</span><span class="params">()</span> &#123;        <span class="type">Integer</span> <span class="variable">value</span> <span class="operator">=</span> threadLocal.get();        value++;        threadLocal.set(value);    &#125;&#125;</code></pre><p>运行结果:</p><pre><code class="highlight shell">销售1卖出了:8套房子销售2卖出了:3套房子销售3卖出了:1套房子</code></pre><h3 id="4-2-总结"><a href="#4-2-总结" class="headerlink" title="4.2 总结"></a>4.2 总结</h3><ul><li>因为每个 Thread 内有自己的实例副本且该副本只由当前线程自己使用</li><li>既然其它 Thread 不可访问，那就不存在多线程间共享的问题。</li><li>统一设置初始值，但是每个线程对这个值的修改都是各自线程互相独立的</li></ul><p>多线程如何才能不争抢</p><ol><li>加入synchronized或者Lock控制资源的访问顺序</li><li>使用ThreadLocal</li></ol><h1 id="二、ThreadLocal实际使用"><a href="#二、ThreadLocal实际使用" class="headerlink" title="二、ThreadLocal实际使用"></a>二、ThreadLocal实际使用</h1><h2 id="1-阿里ThreadLocal规范"><a href="#1-阿里ThreadLocal规范" class="headerlink" title="1. 阿里ThreadLocal规范"></a>1. 阿里ThreadLocal规范</h2><p><img src="https://raw.githubusercontent.com/GeorgeChan95/blogimg/master/img/2024/10/02/20241002-072742.png" alt="阿里ThreadLocal规范"></p><h2 id="2-非线程安全的SimpleDateFormat"><a href="#2-非线程安全的SimpleDateFormat" class="headerlink" title="2. 非线程安全的SimpleDateFormat"></a>2. 非线程安全的SimpleDateFormat</h2><h3 id="2-1-官网文档"><a href="#2-1-官网文档" class="headerlink" title="2.1 官网文档"></a>2.1 官网文档</h3><p><img src="https://raw.githubusercontent.com/GeorgeChan95/blogimg/master/img/2024/10/02/20241002-072823.png" alt="image-20241002072822670"></p><p>上述翻译：SimpleDateFormat中的日期格式不是同步的。推荐（建议）为每个线程创建独立的格式实例。如果多个线程同时访问一个格式，则它必须保持外部同步。</p><p>写时间工具类，一般写成静态的成员变量，但此种写法在多线程下是不安全的！</p><h3 id="2-2-错误示例代码"><a href="#2-2-错误示例代码" class="headerlink" title="2.2 错误示例代码"></a>2.2 错误示例代码</h3><pre><code class="highlight java"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">DateUtils</span> &#123;    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">SimpleDateFormat</span> <span class="variable">sdf</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">SimpleDateFormat</span>(<span class="string">&quot;yyyy-MM-dd HH:mm:ss&quot;</span>);    <span class="comment">/**</span><span class="comment">     * 模拟并发环境下使用SimpleDateFormat的parse方法将字符串转换成Date对象</span><span class="comment">     *</span><span class="comment">     * <span class="doctag">@param</span> stringDate</span><span class="comment">     * <span class="doctag">@return</span></span><span class="comment">     * <span class="doctag">@throws</span> Exception</span><span class="comment">     */</span>    <span class="keyword">public</span> <span class="keyword">static</span> Date <span class="title function_">parseDate</span><span class="params">(String stringDate)</span> <span class="keyword">throws</span> Exception &#123;        <span class="keyword">return</span> sdf.parse(stringDate);    &#125;    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception &#123;        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">1</span>; i &lt;= <span class="number">30</span>; i++) &#123;            <span class="keyword">new</span> <span class="title class_">Thread</span>(() -&gt; &#123;                <span class="keyword">try</span> &#123;                    System.out.println(DateUtils.parseDate(<span class="string">&quot;2020-11-11 11:11:11&quot;</span>));                &#125; <span class="keyword">catch</span> (Exception e) &#123;                    e.printStackTrace();                &#125;            &#125;, String.valueOf(i)).start();        &#125;    &#125;&#125;</code></pre><p>报错如下:</p><pre><code class="highlight shell">java.lang.NumberFormatException: For input string: &quot;..11111111EE22&quot;at java.base/java.lang.NumberFormatException.forInputString(NumberFormatException.java:65)at java.base/java.lang.Long.parseLong(Long.java:678)at java.base/java.lang.Long.parseLong(Long.java:817)at java.base/java.text.DigitList.getLong(DigitList.java:195)at java.base/java.text.DecimalFormat.parse(DecimalFormat.java:2121)at java.base/java.text.SimpleDateFormat.subParse(SimpleDateFormat.java:1933)at java.base/java.text.SimpleDateFormat.parse(SimpleDateFormat.java:1541)at java.base/java.text.DateFormat.parse(DateFormat.java:393)at com.atguigu.juc.tl.DateUtils.parseDate(DateUtils.java:22)at com.atguigu.juc.tl.DateUtils.lambda$main$0(DateUtils.java:29)at java.base/java.lang.Thread.run(Thread.java:834)java.lang.NumberFormatException: multiple pointsat java.base/jdk.internal.math.FloatingDecimal.readJavaFormatString(FloatingDecimal.java:1890)at java.base/jdk.internal.math.FloatingDecimal.parseDouble(FloatingDecimal.java:110)at java.base/java.lang.Double.parseDouble(Double.java:543)at java.base/java.text.DigitList.getDouble(DigitList.java:169)at java.base/java.text.DecimalFormat.parse(DecimalFormat.java:2126)at java.base/java.text.SimpleDateFormat.subParse(SimpleDateFormat.java:2240)at java.base/java.text.SimpleDateFormat.parse(SimpleDateFormat.java:1541)at java.base/java.text.DateFormat.parse(DateFormat.java:393)at com.atguigu.juc.tl.DateUtils.parseDate(DateUtils.java:22)at com.atguigu.juc.tl.DateUtils.lambda$main$0(DateUtils.java:29)at java.base/java.lang.Thread.run(Thread.java:834)java.lang.NumberFormatException: For input string: &quot;.2022020E&quot;at java.base/java.lang.NumberFormatException.forInputString(NumberFormatException.java:65)at java.base/java.lang.Long.parseLong(Long.java:678)at java.base/java.lang.Long.parseLong(Long.java:817)at java.base/java.text.DigitList.getLong(DigitList.java:195)at java.base/java.text.DecimalFormat.parse(DecimalFormat.java:2121)at java.base/java.text.SimpleDateFormat.subParse(SimpleDateFormat.java:1933)at java.base/java.text.SimpleDateFormat.parse(SimpleDateFormat.java:1541)at java.base/java.text.DateFormat.parse(DateFormat.java:393)at com.atguigu.juc.tl.DateUtils.parseDate(DateUtils.java:22)at com.atguigu.juc.tl.DateUtils.lambda$main$0(DateUtils.java:29)at java.base/java.lang.Thread.run(Thread.java:834)java.lang.NumberFormatException: For input string: &quot;.2220E0.202E4&quot;at java.base/jdk.internal.math.FloatingDecimal.readJavaFormatString(FloatingDecimal.java:2054)at java.base/jdk.internal.math.FloatingDecimal.parseDouble(FloatingDecimal.java:110)at java.base/java.lang.Double.parseDouble(Double.java:543)at java.base/java.text.DigitList.getDouble(DigitList.java:169)at java.base/java.text.DecimalFormat.parse(DecimalFormat.java:2126)at java.base/java.text.SimpleDateFormat.subParse(SimpleDateFormat.java:1933)at java.base/java.text.SimpleDateFormat.parse(SimpleDateFormat.java:1541)at java.base/java.text.DateFormat.parse(DateFormat.java:393)at com.atguigu.juc.tl.DateUtils.parseDate(DateUtils.java:22)at com.atguigu.juc.tl.DateUtils.lambda$main$0(DateUtils.java:29)at java.base/java.lang.Thread.run(Thread.java:834)java.lang.NumberFormatException: multiple pointsat java.base/jdk.internal.math.FloatingDecimal.readJavaFormatString(FloatingDecimal.java:1890)at java.base/jdk.internal.math.FloatingDecimal.parseDouble(FloatingDecimal.java:110)at java.base/java.lang.Double.parseDouble(Double.java:543)at java.base/java.text.DigitList.getDouble(DigitList.java:169)at java.base/java.text.DecimalFormat.parse(DecimalFormat.java:2126)at java.base/java.text.SimpleDateFormat.subParse(SimpleDateFormat.java:2240)at java.base/java.text.SimpleDateFormat.parse(SimpleDateFormat.java:1541)at java.base/java.text.DateFormat.parse(DateFormat.java:393)at com.atguigu.juc.tl.DateUtils.parseDate(DateUtils.java:22)at com.atguigu.juc.tl.DateUtils.lambda$main$0(DateUtils.java:29)</code></pre><h3 id="2-3-源码分析结论"><a href="#2-3-源码分析结论" class="headerlink" title="2.3 源码分析结论"></a>2.3 源码分析结论</h3><p>SimpleDateFormat类内部有一个Calendar对象引用,它用来储存和这个SimpleDateFormat相关的日期信息,例如 <code>sdf.parse(dateStr)</code> , <code>sdf.format(date)</code> 诸如此类的方法参数传入的日期相关String,Date等等, 都是交由Calendar引用来储存的.这样就会导致一个问题如果你的SimpleDateFormat是个static的, 那么多个thread 之间就会共享这个SimpleDateFormat, 同时也是共享这个Calendar引用。</p><ul><li>java.text.SimpleDateFormat#parse</li></ul><p><img src="https://raw.githubusercontent.com/GeorgeChan95/blogimg/master/img/2024/10/02/20241002-074144.png" alt="java.text.SimpleDateFormat#parse "></p><ul><li><p>java.text.CalendarBuilder#establish</p><p><img src="https://raw.githubusercontent.com/GeorgeChan95/blogimg/master/img/2024/10/02/20241002-074238.png" alt="image-20241002074237666"></p></li></ul><h2 id="3-解决方式1"><a href="#3-解决方式1" class="headerlink" title="3. 解决方式1"></a>3. 解决方式1</h2><p>将SimpleDateFormat定义成局部变量。</p><p>缺点：每调用一次方法就会创建一个SimpleDateFormat对象，方法结束又要作为垃圾回收。</p><pre><code class="highlight java"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">DateUtils</span> &#123;    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception &#123;        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">1</span>; i &lt;= <span class="number">30</span>; i++) &#123;            <span class="keyword">new</span> <span class="title class_">Thread</span>(() -&gt; &#123;                <span class="keyword">final</span> <span class="type">SimpleDateFormat</span> <span class="variable">sdf</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">SimpleDateFormat</span>(<span class="string">&quot;yyyy-MM-dd HH:mm:ss&quot;</span>);                <span class="keyword">try</span> &#123;                    System.out.println(sdf.parse(<span class="string">&quot;2020-11-11 11:11:11&quot;</span>));                &#125; <span class="keyword">catch</span> (Exception e) &#123;                    e.printStackTrace();                &#125;            &#125;, String.valueOf(i)).start();        &#125;    &#125;&#125;</code></pre><h2 id="4-解决方式2"><a href="#4-解决方式2" class="headerlink" title="4. 解决方式2"></a>4. 解决方式2</h2><p>使用ThreadLocal</p><pre><code class="highlight java"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">DateUtils</span> &#123;    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> ThreadLocal&lt;SimpleDateFormat&gt; threadLocal = ThreadLocal.withInitial(() -&gt; <span class="keyword">new</span> <span class="title class_">SimpleDateFormat</span>(<span class="string">&quot;yyyy-mm-dd HH:mm:ss&quot;</span>));    <span class="comment">/**</span><span class="comment">     * 模拟并发环境下使用SimpleDateFormat的parse方法将字符串转换成Date对象</span><span class="comment">     *</span><span class="comment">     * <span class="doctag">@param</span> stringDate</span><span class="comment">     * <span class="doctag">@return</span></span><span class="comment">     * <span class="doctag">@throws</span> Exception</span><span class="comment">     */</span>    <span class="keyword">public</span> <span class="keyword">static</span> Date <span class="title function_">parseDate</span><span class="params">(String stringDate)</span> <span class="keyword">throws</span> Exception &#123;        <span class="type">SimpleDateFormat</span> <span class="variable">sdf</span> <span class="operator">=</span> threadLocal.get();<span class="comment">//        System.out.println(&quot;执行线程:&quot; + Thread.currentThread().getName());</span>        <span class="keyword">return</span> sdf.parse(stringDate);    &#125;    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception &#123;        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">1</span>; i &lt;= <span class="number">30</span>; i++) &#123;            <span class="keyword">new</span> <span class="title class_">Thread</span>(() -&gt; &#123;                <span class="keyword">try</span> &#123;                    System.out.println(parseDate(<span class="string">&quot;2020-11-11 11:11:11&quot;</span>));                &#125; <span class="keyword">catch</span> (Exception e) &#123;                    e.printStackTrace();                &#125;            &#125;, String.valueOf(i)).start();        &#125;    &#125;&#125;</code></pre><p><strong>其它方案</strong></p><ul><li>加锁</li><li>第3方时间库</li></ul><h1 id="三、ThreadLocal源码分析"><a href="#三、ThreadLocal源码分析" class="headerlink" title="三、ThreadLocal源码分析"></a>三、ThreadLocal源码分析</h1><h2 id="1-Thread，ThreadLocal，ThreadLocalMap-关系"><a href="#1-Thread，ThreadLocal，ThreadLocalMap-关系" class="headerlink" title="1. Thread，ThreadLocal，ThreadLocalMap 关系"></a>1. Thread，ThreadLocal，ThreadLocalMap 关系</h2><p>根据官方API，Thread是程序中执行的线程；ThreadLocal类提供线程局部变量。</p><h3 id="1-1-Thread和ThreadLocal"><a href="#1-1-Thread和ThreadLocal" class="headerlink" title="1.1 Thread和ThreadLocal"></a>1.1 Thread和ThreadLocal</h3><p>先打开<code>Thread.java</code>类，发现每个Thread类里面有一个<code>ThreadLocal</code>类</p><p><img src="https://raw.githubusercontent.com/GeorgeChan95/blogimg/master/img/2024/10/02/20241002-102349.png" alt="ThreadLocal"></p><h3 id="1-2-ThreadLocal和ThreadLocalMap"><a href="#1-2-ThreadLocal和ThreadLocalMap" class="headerlink" title="1.2 ThreadLocal和ThreadLocalMap"></a>1.2 ThreadLocal和ThreadLocalMap</h3><p>而 <code>ThreadLocalMap</code> 是 <code>ThreadLocal</code> 的一个静态内部类</p><p><img src="https://raw.githubusercontent.com/GeorgeChan95/blogimg/master/img/2024/10/02/20241002-102550.png" alt="ThreadLocalMap"></p><h3 id="1-3-三者总概括"><a href="#1-3-三者总概括" class="headerlink" title="1.3 三者总概括"></a>1.3 三者总概括</h3><p><code>threadLocalMap </code>实际上就是一个以 <code>threadLocal</code> 实例为<strong>key</strong>，任意对象为<strong>value</strong>的 <code>Entry对象</code> 。<br>当我们为threadLocal变量赋值，实际上就是以当前threadLocal实例为key，值为value的Entry往这个threadLocalMap中存放</p><p><img src="https://raw.githubusercontent.com/GeorgeChan95/blogimg/master/img/2024/10/02/20241002-102628.png" alt="Thread，ThreadLocal，ThreadLocalMap"></p><p><img src="https://raw.githubusercontent.com/GeorgeChan95/blogimg/master/img/2024/10/02/20241002-103626.png" alt="ThreadLocal set"></p><h2 id="2-总结"><a href="#2-总结" class="headerlink" title="2. 总结"></a>2. 总结</h2><p>近似的可以理解为:<br><code>ThreadLocalMap</code> 从字面上就可以看出这是一个保存ThreadLocal对象的map(其实是以ThreadLocal为Key)，不过是经过了两层包装的ThreadLocal 对象：</p><p><img src="https://raw.githubusercontent.com/GeorgeChan95/blogimg/master/img/2024/10/02/20241002-104134.png" alt="ThreadLocalMap"></p><p>JVM内部维护了一个线程版的 <code>Map&lt;Thread,T&gt;</code> (通过 <code>ThreadLocal</code> 对象的 <code>set</code> 方法，结果把 <code>ThreadLocal</code> 对象自己当做key，放进了<code>ThreadLoalMap</code>中),每个线程要用到这个T的时候，用当前的线程去Map里面获取，通过这样让每个线程都拥有了自己独立的变量，<br>人手一份，竞争条件被彻底消除，在并发模式下是绝对安全的变量。</p><h1 id="四、ThreadLocal内存泄露问题"><a href="#四、ThreadLocal内存泄露问题" class="headerlink" title="四、ThreadLocal内存泄露问题"></a>四、ThreadLocal内存泄露问题</h1><h2 id="1-阿里代码规范"><a href="#1-阿里代码规范" class="headerlink" title="1. 阿里代码规范"></a>1. 阿里代码规范</h2><p><img src="https://raw.githubusercontent.com/GeorgeChan95/blogimg/master/img/2024/10/02/20241002-104235.png" alt="阿里代码规范"></p><h2 id="2-什么是内存泄漏"><a href="#2-什么是内存泄漏" class="headerlink" title="2. 什么是内存泄漏"></a>2. 什么是内存泄漏</h2><p>内存泄露为程序在申请内存后，无法释放已申请的内存空间，一次内存泄露危害可以忽略，但内存泄露堆积后果很严重，无论多少内存,迟早会被占光.</p><p>广义并通俗的说，就是：不再会被使用的对象或者变量占用的内存不能被回收，就是内存泄露。</p><h2 id="3-ThreadLocal的内存泄露分析"><a href="#3-ThreadLocal的内存泄露分析" class="headerlink" title="3. ThreadLocal的内存泄露分析"></a>3. ThreadLocal的内存泄露分析</h2><h3 id="3-1-实现原理"><a href="#3-1-实现原理" class="headerlink" title="3.1 实现原理"></a>3.1 实现原理</h3><pre><code class="highlight java"><span class="keyword">static</span> <span class="keyword">class</span> <span class="title class_">ThreadLocalMap</span> &#123;    <span class="keyword">static</span> <span class="keyword">class</span> <span class="title class_">Entry</span> <span class="keyword">extends</span> <span class="title class_">WeakReference</span>&lt;ThreadLocal&lt;?&gt;&gt; &#123;        <span class="comment">/** The value associated with this ThreadLocal. */</span>        Object value;        Entry(ThreadLocal&lt;?&gt; k, Object v) &#123;            <span class="built_in">super</span>(k);            value = v;        &#125;    &#125;    ...   &#125;</code></pre><p>ThreadLocal的实现原理，每一个Thread维护一个ThreadLocalMap，key为使用弱引用的ThreadLocal实例，value为线程变量的副本。这些对象之间的引用关系如下,</p><p><img src="https://raw.githubusercontent.com/GeorgeChan95/blogimg/master/img/2024/10/02/20241002-105317.png" alt="img"></p><blockquote><p>实心箭头表示强引用，空心箭头表示弱引用</p></blockquote><h3 id="3-2-ThreadLocal-内存泄漏的原因"><a href="#3-2-ThreadLocal-内存泄漏的原因" class="headerlink" title="3.2 ThreadLocal 内存泄漏的原因"></a>3.2 ThreadLocal 内存泄漏的原因</h3><p>从上图中可以看出，ThreadLocalMap 使用 ThreadLocal 的弱引用作为key，如果一个ThreadLocal不存在外部强引用时，Key(ThreadLocal)势必会被GC回收，这样就会导致 ThreadLocalMap 中key为 null， 而value还存在着强引用，只有thead线程退出以后,value的强引用链条才会断掉。</p><p>但如果当前线程再迟迟不结束的话，这些key为null的Entry的value就会一直存在一条强引用链：</p><blockquote><p>Thread Ref -&gt; Thread -&gt; ThreaLocalMap -&gt; Entry -&gt; value</p></blockquote><p>永远无法回收，造成内存泄漏。</p><h3 id="3-3-那为什么使用弱引用而不是强引用？"><a href="#3-3-那为什么使用弱引用而不是强引用？" class="headerlink" title="3.3 那为什么使用弱引用而不是强引用？"></a>3.3 那为什么使用弱引用而不是强引用？</h3><h4 id="3-3-1-key-使用强引用"><a href="#3-3-1-key-使用强引用" class="headerlink" title="3.3.1 key 使用强引用"></a>3.3.1 key 使用强引用</h4><p>当 <code>ThreadLocalMap</code> 的key为强引用回收 ThreadLocal 时，因为 ThreadLocalMap 还持有ThreadLocal的强引用，如果没有手动删除，ThreadLocal不会被回收，导致Entry内存泄漏。</p><h4 id="3-3-2-key使用弱引用"><a href="#3-3-2-key使用弱引用" class="headerlink" title="3.3.2 key使用弱引用"></a>3.3.2 key使用弱引用</h4><p>由于ThreadLocal对象是弱引用，如果外部没有强引用指向它，它就会被GC回收，导致Entry的Key为空(null)，如果这时Value外部也没有强引用指向它，那么Value就永远也访问不到了，按理也应该被GC回收，但是由于Entry对象还在强引用Value，导致Value无法被回收，这时「内存泄漏」就发生了，Value成了一个永远也无法被访问，但是又无法被回收的对象。</p><p>Entry对象属于ThreadLocalMap，ThreadLocalMap又属于Thread，如果线程本身的生命周期很短，短时间内就会被销毁，那么「内存泄漏」立刻就会得到解决，只要线程被销毁，Value也会随之被回收。</p><p>问题是，线程本身是非常珍贵的计算机资源，很少会去频繁的创建和销毁，一般都是通过线程池来使用，这就将线程的生命周期大大拉长，「内存泄漏」的影响也会越来越大。</p><p><strong>内存泄漏的代码示例</strong></p><p>线程池大小是3,但启动了6个线程,导致后面的线程直接复用了前面线程的 ThreadLocal数据.</p><pre><code class="highlight plaintext">public class ThreadLocalPoolTest &#123;    public static void main(String[] args) throws InterruptedException &#123;        MyCar car = new MyCar();        ExecutorService executorService = Executors.newFixedThreadPool(3);        for (int i = 0; i &lt; 6; i++) &#123;            executorService.submit(() -&gt; &#123;                int num = new Random().nextInt(10);                for (int j = 0; j &lt; num; j++) &#123;                    car.saleCar();                &#125;                System.out.println(Thread.currentThread().getName() + &quot;卖出了:&quot; + car.threadLocal.get() + &quot;辆车&quot;);            &#125;);        &#125;        executorService.shutdown();    &#125;&#125;class MyCar &#123;    // 初始化ThreadLocal,设置初始值为:0    ThreadLocal&lt;Integer&gt; threadLocal = ThreadLocal.withInitial(() -&gt; 0);    public void saleCar() &#123;        Integer value = threadLocal.get();        value++;        threadLocal.set(value);        System.out.println(Thread.currentThread().getName() + &quot;卖了:&quot; + threadLocal.get() + &quot;辆车&quot;);    &#125;&#125;</code></pre><p>运行结果:</p><pre><code class="highlight shell">pool-1-thread-1卖了:1辆车pool-1-thread-1卖了:2辆车pool-1-thread-2卖了:1辆车pool-1-thread-2卖了:2辆车pool-1-thread-3卖了:1辆车pool-1-thread-3卖了:2辆车pool-1-thread-2卖了:3辆车pool-1-thread-2卖了:4辆车pool-1-thread-1卖了:3辆车pool-1-thread-1卖了:4辆车pool-1-thread-2卖了:5辆车pool-1-thread-2卖出了:5辆车pool-1-thread-3卖了:3辆车pool-1-thread-1卖了:5辆车pool-1-thread-3卖了:4辆车pool-1-thread-2卖出了:5辆车pool-1-thread-1卖了:6辆车pool-1-thread-1卖了:7辆车pool-1-thread-1卖了:8辆车pool-1-thread-1卖了:9辆车pool-1-thread-1卖出了:9辆车pool-1-thread-3卖了:5辆车pool-1-thread-2卖了:6辆车pool-1-thread-2卖出了:6辆车pool-1-thread-1卖了:10辆车pool-1-thread-3卖出了:5辆车pool-1-thread-1卖出了:10辆车</code></pre><p><strong>方案: 手动回收自定义的 ThreadLocal变量</strong></p><pre><code class="highlight plaintext">public class ThreadLocalPoolTest &#123;    public static void main(String[] args) throws InterruptedException &#123;        MyCar car = new MyCar();        ExecutorService executorService = Executors.newFixedThreadPool(3);        for (int i = 0; i &lt; 6; i++) &#123;            executorService.submit(() -&gt; &#123;                try &#123;                    int num = new Random().nextInt(10);                    for (int j = 0; j &lt; num; j++) &#123;                        car.saleCar();                    &#125;                    System.out.println(Thread.currentThread().getName() + &quot;卖出了:&quot; + car.threadLocal.get() + &quot;辆车&quot;);                &#125; finally &#123;                    car.threadLocal.remove();                &#125;            &#125;);        &#125;        executorService.shutdown();    &#125;&#125;class MyCar &#123;    // 初始化ThreadLocal,设置初始值为:0    ThreadLocal&lt;Integer&gt; threadLocal = ThreadLocal.withInitial(() -&gt; 0);    public void saleCar() &#123;        Integer value = threadLocal.get();        value++;        threadLocal.set(value);        System.out.println(Thread.currentThread().getName() + &quot;卖了:&quot; + threadLocal.get() + &quot;辆车&quot;);    &#125;&#125;</code></pre><h2 id="4-强引用、软引用、弱引用、虚引用"><a href="#4-强引用、软引用、弱引用、虚引用" class="headerlink" title="4. 强引用、软引用、弱引用、虚引用"></a>4. 强引用、软引用、弱引用、虚引用</h2><h3 id="4-1-整体架构"><a href="#4-1-整体架构" class="headerlink" title="4.1 整体架构"></a>4.1 整体架构</h3><p><img src="https://raw.githubusercontent.com/GeorgeChan95/blogimg/master/img/2024/10/02/20241002-142730.png" alt="引用架构"></p><p>Java 技术允许使用 <code>finalize()</code> 方法在垃圾收集器将对象从内存中清除出去之前做必要的清理工作。</p><p><img src="https://raw.githubusercontent.com/GeorgeChan95/blogimg/master/img/2024/10/02/20241002-142848.png" alt="finalize()"></p><p>finalize() 方法定义在Object类中,每个类都可以重写此方法(不建议重写)</p><pre><code class="highlight java"><span class="keyword">class</span> <span class="title class_">MyObject</span> &#123;    <span class="comment">//一般这个方法工作中不用</span>    <span class="meta">@Override</span>    <span class="keyword">protected</span> <span class="keyword">void</span> <span class="title function_">finalize</span><span class="params">()</span> <span class="keyword">throws</span> Throwable &#123;        System.out.println(<span class="string">&quot;------------- gc ,finalize() invoked&quot;</span>);    &#125;&#125;</code></pre><h3 id="4-2-强引用-默认支持模式"><a href="#4-2-强引用-默认支持模式" class="headerlink" title="4.2 强引用(默认支持模式)"></a>4.2 强引用(默认支持模式)</h3><p>当内存不足，JVM开始垃圾回收，对于强引用的对象，就算是出现了OOM也不会对该对象进行回收.</p><p>强引用是我们最常见的普通对象引用，只要还有强引用指向一个对象，就能表明对象还“活着”，垃圾收集器不会碰这种对象。在 Java 中最常见的就是强引用，把一个对象赋给一个引用变量，这个引用变量就是一个强引用。当一个对象被强引用变量引用时，它处于可达状态，它是不可能被垃圾回收机制回收的，即使该对象以后永远都不会被用到JVM也不会回收。因此强引用是造成Java内存泄漏的主要原因之一。</p><pre><code class="highlight java"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">strongReference</span><span class="params">()</span> &#123;    <span class="type">MyObject</span> <span class="variable">myObject</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">MyObject</span>();<span class="comment">//默认，强引用,死了都不放手</span>    System.out.println(<span class="string">&quot;gc before: &quot;</span> + myObject);    myObject = <span class="literal">null</span>;    System.gc();<span class="comment">//手动挡的方式开启Gc回收。</span>    <span class="keyword">try</span> &#123;        TimeUnit.SECONDS.sleep(<span class="number">1</span>);    &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;        e.printStackTrace();    &#125;    System.out.println(<span class="string">&quot;gc after: &quot;</span> + myObject);&#125;</code></pre><h3 id="4-3-软引用"><a href="#4-3-软引用" class="headerlink" title="4.3 软引用"></a>4.3 软引用</h3><p>软引用是一种相对强引用弱化了一些的引用，需要用 <code>java.lang.ref.SoftReference</code> 类来实现，可以让对象豁免一些垃圾收集。</p><p>对于只有软引用的对象来说，</p><ul><li>当系统<strong>内存充足</strong>时它<strong>不会</strong>被回收，</li><li>当系统<strong>内存不足</strong>时它<strong>会</strong>被回收。</li></ul><h4 id="4-3-1-测试代码"><a href="#4-3-1-测试代码" class="headerlink" title="4.3.1 测试代码"></a>4.3.1 测试代码</h4><p>软引用通常用在对内存敏感的程序中，比如高速缓存就有用到软引用，内存够用的时候就保留，不够用就回收！</p><pre><code class="highlight java"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ReferenceTest</span> &#123;    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;        <span class="comment">//当我们内存不够用的时候，soft会被回收的情况，设置我们的内存大小：-Xms10m -Xmx10m</span>        SoftReference&lt;MyObject&gt; softReference = <span class="keyword">new</span> <span class="title class_">SoftReference</span>&lt;&gt;(<span class="keyword">new</span> <span class="title class_">MyObject</span>());        System.gc();        <span class="keyword">try</span> &#123;            TimeUnit.SECONDS.sleep(<span class="number">1</span>);        &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;            e.printStackTrace();        &#125;        System.out.println(<span class="string">&quot;-----gc after内存够用: &quot;</span> + softReference.get());        <span class="keyword">try</span> &#123;            <span class="type">byte</span>[] bytes = <span class="keyword">new</span> <span class="title class_">byte</span>[<span class="number">9</span> * <span class="number">1024</span> * <span class="number">1024</span>];        &#125; <span class="keyword">catch</span> (Exception e) &#123;            e.printStackTrace();        &#125; <span class="keyword">finally</span> &#123;            System.out.println(<span class="string">&quot;-----gc after内存不够: &quot;</span> + softReference.get());        &#125;    &#125;&#125;<span class="keyword">class</span> <span class="title class_">MyObject2</span> &#123;    <span class="comment">//一般这个方法工作中不用，此处为了讲解gc，给学生们演示</span>    <span class="meta">@Override</span>    <span class="keyword">protected</span> <span class="keyword">void</span> <span class="title function_">finalize</span><span class="params">()</span> <span class="keyword">throws</span> Throwable &#123;        System.out.println(<span class="string">&quot;------------- gc ,finalize() invoked&quot;</span>);    &#125;&#125;</code></pre><p>打印结果:</p><pre><code class="highlight shell">-----gc after内存够用: com.atguigu.juc.tl.MyObject@64616ca2-----gc after内存不够: null------------- gc ,finalize() invokedException in thread &quot;main&quot; java.lang.OutOfMemoryError: Java heap spaceat com.atguigu.juc.tl.ReferenceTest.main(ReferenceTest.java:25)</code></pre><h4 id="4-3-2-适用场景"><a href="#4-3-2-适用场景" class="headerlink" title="4.3.2 适用场景"></a>4.3.2 适用场景</h4><p>假如有一个应用需要读取大量的本地图片:</p><ul><li>如果每次读取图片都从硬盘读取则会严重影响性能,</li><li>如果一次性全部加载到内存中又可能造成内存溢出。</li></ul><p>如果每次读取图片都从硬盘读取则会严重影响性能,</p><p><strong>设计思路是</strong>：用一个HashMap来保存图片的路径和相应图片对象关联的软引用之间的映射关系，在内存不足时，JVM会自动回收这些缓存图片对象所占用的空间，从而有效地避免了OOM的问题。</p><pre><code class="highlight java">Map&lt;String, SoftReference&lt;Bitmap&gt;&gt; imageCache = <span class="keyword">new</span> <span class="title class_">HashMap</span>&lt;String, SoftReference&lt;Bitmap&gt;&gt;();</code></pre><h3 id="4-4-弱引用"><a href="#4-4-弱引用" class="headerlink" title="4.4 弱引用"></a>4.4 弱引用</h3><p>弱引用需要用java.lang.ref.WeakReference类来实现，它比软引用的生存期更短，对于只有弱引用的对象来说，只要垃圾回收机制一运行，不管JVM的内存空间是否足够，都会回收该对象占用的内存。 </p><pre><code class="highlight java"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ReferenceTest</span> &#123;    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;        WeakReference&lt;MyObject&gt; weakReference = <span class="keyword">new</span> <span class="title class_">WeakReference</span>&lt;&gt;(<span class="keyword">new</span> <span class="title class_">MyObject</span>());        System.out.println(<span class="string">&quot;-----gc before内存够用: &quot;</span>+weakReference.get());        System.gc();        <span class="keyword">try</span> &#123; TimeUnit.SECONDS.sleep(<span class="number">1</span>); &#125; <span class="keyword">catch</span> (InterruptedException e) &#123; e.printStackTrace(); &#125;        System.out.println(<span class="string">&quot;-----gc after内存够用: &quot;</span>+weakReference.get());    &#125;&#125;</code></pre><p>打印结果:</p><pre><code class="highlight shell">-----gc before内存够用: com.atguigu.juc.tl.MyObject@64616ca2------------- gc ,finalize() invoked-----gc after内存够用: null</code></pre><h3 id="4-5-虚引用"><a href="#4-5-虚引用" class="headerlink" title="4.5 虚引用"></a>4.5 虚引用</h3><p>虚引用需要 <code>java.lang.ref.PhantomReference</code> 类来实现。</p><p>顾名思义，就是形同虚设，与其他几种引用都不同，虚引用并不会决定对象的生命周期。如果一个对象仅持有虚引用，那么它就和没有任何引用一样，在任何时候都可能被垃圾回收器回收，它不能单独使用也不能通过它访问对象，虚引用必须和引用队列 (<code>ReferenceQueue</code>)联合使用。</p><p>虚引用的主要作用是跟踪对象被垃圾回收的状态。 <strong>仅仅是提供了一种确保对象被 finalize以后，做某些事情的机制。</strong> <strong>PhantomReference的get方法总是返回null</strong>，因此无法访问对应的引用对象。</p><p>其意义在于：说明一个对象已经进入finalization阶段，可以被gc回收，用来实现比finalization机制更灵活的回收操作。</p><p>换句话说，设置虚引用关联的唯一目的，就是在这个对象被收集器回收的时候收到一个系统通知或者后续添加进一步的处理。</p><h4 id="4-5-1-构造方法"><a href="#4-5-1-构造方法" class="headerlink" title="4.5.1 构造方法"></a>4.5.1 构造方法</h4><p><img src="https://raw.githubusercontent.com/GeorgeChan95/blogimg/master/img/2024/10/02/20241002-145624.png" alt="构造方法"></p><h4 id="4-5-2-引用队列"><a href="#4-5-2-引用队列" class="headerlink" title="4.5.2 引用队列"></a>4.5.2 引用队列</h4><p><img src="https://raw.githubusercontent.com/GeorgeChan95/blogimg/master/img/2024/10/02/20241002-145651.png" alt="引用队列"></p><p>被回收前需要被引用队列保存下。</p><pre><code class="highlight java"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ReferenceTest</span> &#123;    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;        <span class="comment">// 设置内存: -Xms10m -Xmx10m</span>        ReferenceQueue&lt;MyObject2&gt; referenceQueue = <span class="keyword">new</span> <span class="title class_">ReferenceQueue</span>();        PhantomReference&lt;MyObject2&gt; phantomReference = <span class="keyword">new</span> <span class="title class_">PhantomReference</span>&lt;&gt;(<span class="keyword">new</span> <span class="title class_">MyObject2</span>(), referenceQueue);        <span class="comment">//System.out.println(phantomReference.get());</span>        List&lt;<span class="type">byte</span>[]&gt; list = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();        <span class="keyword">new</span> <span class="title class_">Thread</span>(() -&gt; &#123;            <span class="keyword">while</span> (<span class="literal">true</span>) &#123;                list.add(<span class="keyword">new</span> <span class="title class_">byte</span>[<span class="number">1</span> * <span class="number">1024</span> * <span class="number">1024</span>]);                <span class="keyword">try</span> &#123;                    TimeUnit.MILLISECONDS.sleep(<span class="number">600</span>);                &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;                    e.printStackTrace();                &#125;                System.out.println(phantomReference.get()); <span class="comment">// null</span>            &#125;        &#125;, <span class="string">&quot;t1&quot;</span>).start();        <span class="keyword">new</span> <span class="title class_">Thread</span>(() -&gt; &#123;            <span class="keyword">while</span> (<span class="literal">true</span>) &#123;                Reference&lt;? <span class="keyword">extends</span> <span class="title class_">MyObject2</span>&gt; reference = referenceQueue.poll();                <span class="keyword">if</span> (reference != <span class="literal">null</span>) &#123;                    System.out.println(<span class="string">&quot;***********有虚对象加入队列了&quot;</span>);                &#125;            &#125;        &#125;, <span class="string">&quot;t2&quot;</span>).start();        <span class="comment">//暂停几秒钟线程</span>        <span class="keyword">try</span> &#123;            TimeUnit.SECONDS.sleep(<span class="number">5</span>);        &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;            e.printStackTrace();        &#125;    &#125;&#125;<span class="keyword">class</span> <span class="title class_">MyObject2</span> &#123;    <span class="comment">//一般这个方法工作中不用</span>    <span class="meta">@Override</span>    <span class="keyword">protected</span> <span class="keyword">void</span> <span class="title function_">finalize</span><span class="params">()</span> <span class="keyword">throws</span> Throwable &#123;        System.out.println(<span class="string">&quot;------------- gc ,finalize() invoked&quot;</span>);    &#125;&#125;</code></pre><p>打印结果:</p><pre><code class="highlight shell">null------------- gc ,finalize() invokednull***********有虚对象加入队列了nullException in thread &quot;t1&quot; java.lang.OutOfMemoryError: Java heap spaceat com.atguigu.juc.tl.ReferenceTest.lambda$main$0(ReferenceTest.java:26)at com.atguigu.juc.tl.ReferenceTest$$Lambda$14/0x0000000100066840.run(Unknown Source)at java.base/java.lang.Thread.run(Thread.java:834)</code></pre><h2 id="5-GCRoots和四大引用总结"><a href="#5-GCRoots和四大引用总结" class="headerlink" title="5. GCRoots和四大引用总结"></a>5. GCRoots和四大引用总结</h2><p><img src="https://raw.githubusercontent.com/GeorgeChan95/blogimg/master/img/2024/10/02/20241002-150258.png" alt="GCRoots和四大引用"></p><h1 id="五、总结"><a href="#五、总结" class="headerlink" title="五、总结"></a>五、总结</h1><ul><li>ThreadLocal 并不解决线程间共享数据的问题</li><li>ThreadLocal 适用于变量在线程间隔离且在方法间共享的场景</li><li>ThreadLocal 通过隐式的在不同线程内创建独立实例副本避免了实例线程安全的问题</li><li>每个线程持有一个只属于自己的专属Map并维护了ThreadLocal对象与具体实例的映射，该Map由于只被持有它的线程访问，故不存在线程安全以及锁的问题</li><li>ThreadLocalMap的Entry对ThreadLocal的引用为弱引用，避免了ThreadLocal对象无法被回收的问题</li><li>ThreadLocal 会通过expungeStaleEntry，cleanSomeSlots,replaceStaleEntry这三个方法回收键为 null 的 Entry 对象的值（即为具体实例）以及 Entry 对象本身从而防止内存泄漏，属于安全加固的方法</li></ul>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;一、ThreadLocal简介&quot;&gt;&lt;a href=&quot;#一、ThreadLocal简介&quot; class=&quot;headerlink&quot; title=&quot;一、ThreadLocal简介&quot;&gt;&lt;/a&gt;一、ThreadLocal简介&lt;/h1&gt;&lt;p&gt;官方文档: &lt;a href=&quot;htt</summary>
      
    
    
    
    <category term="JUC" scheme="https://georgechan95.github.io/categories/JUC/"/>
    
    
    <category term="java" scheme="https://georgechan95.github.io/tags/java/"/>
    
    <category term="juc" scheme="https://georgechan95.github.io/tags/juc/"/>
    
  </entry>
  
  <entry>
    <title>08-JUC进阶-常用的原子操作类(18个)</title>
    <link href="https://georgechan95.github.io/blog/72329cf5.html"/>
    <id>https://georgechan95.github.io/blog/72329cf5.html</id>
    <published>2024-09-28T05:37:09.000Z</published>
    <updated>2024-10-08T04:46:24.743Z</updated>
    
    <content type="html"><![CDATA[<h1 id="一、常用原子操作类"><a href="#一、常用原子操作类" class="headerlink" title="一、常用原子操作类"></a>一、常用原子操作类</h1><p>JDK文档：<a href="https://www.runoob.com/manual/jdk11api/java.base/java/util/concurrent/atomic/package-summary.html">https://www.runoob.com/manual/jdk11api/java.base/java/util/concurrent/atomic/package-summary.html</a></p><h2 id="1-为什么需要原子操作类"><a href="#1-为什么需要原子操作类" class="headerlink" title="1. 为什么需要原子操作类"></a>1. 为什么需要原子操作类</h2><p>对于多线程，在此之前已经了解到了一个关键字 <code>volatile</code>， volatile 解决多线程内存不可见问题。对于一写多读，是可以解决变量同步问题，但是如果多写，同样无法解决线程安全问题。</p><p>说明:如果是 count++操作,使用如下类实现: </p><pre><code class="highlight java"><span class="type">AtomicInteger</span> <span class="variable">count</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">AtomicInteger</span>(<span class="number">0</span>);count.addAndGet(<span class="number">1</span>);</code></pre><p>如果是 JDK8，推荐使用 <code>LongAdder</code> 对象，比 <code>AtomicLong</code> 性能更好(减少乐观锁的重试次数)。</p><h2 id="2-有哪些原子操作类"><a href="#2-有哪些原子操作类" class="headerlink" title="2. 有哪些原子操作类"></a>2. 有哪些原子操作类</h2><p><img src="https://raw.githubusercontent.com/GeorgeChan95/blogimg/master/img/2024/09/28/20240928-134643.png" alt="原子操作类"></p><ol><li>AtomicBoolean</li><li>AtomicInteger</li><li>AtomicIntegerArray</li><li>AtomicIntegerFieldUpdater</li><li>AtomicLong</li><li>AtomicLongArray</li><li>AtomicLongFieldUpdater</li><li>AtomicMarkableReference</li><li>AtomicReference</li><li>AtomicReferenceArray</li><li>AtomicReferenceFieldUpdater</li><li>AtomicStampedReference</li><li>DoubleAccumulator</li><li>DoubleAdder</li><li>LongAccumulator</li><li>LongAdder</li></ol><h1 id="二、分类学习"><a href="#二、分类学习" class="headerlink" title="二、分类学习"></a>二、分类学习</h1><h2 id="1-基本类型原子类"><a href="#1-基本类型原子类" class="headerlink" title="1. 基本类型原子类"></a>1. 基本类型原子类</h2><ul><li>AtomicInteger</li><li>AtomicBoolean</li><li>AtomicLong</li></ul><h3 id="1-1-常用API简介"><a href="#1-1-常用API简介" class="headerlink" title="1.1 常用API简介"></a>1.1 常用API简介</h3><ul><li>public final int get()  &#x2F;&#x2F;获取当前的值</li><li>public final int getAndSet(int newValue) &#x2F;&#x2F; 获取当前的值，并设置新的值</li><li>public final int getAndIncrement() &#x2F;&#x2F; 获取当前的值，并自增</li><li>public final int getAndDecrement() &#x2F;&#x2F; 获取当前的值，并自减</li><li>public final int getAndAdd(int delta) &#x2F;&#x2F; 获取当前的值，并加上预期的值</li><li>boolean compareAndSet(int expect, int update) &#x2F;&#x2F; 如果输入的数值等于预期值，则以原子方式将该值设置为输入值（update）</li></ul><h3 id="1-2-测试案例"><a href="#1-2-测试案例" class="headerlink" title="1.2 测试案例"></a>1.2 测试案例</h3><h4 id="1-2-1-错误案例"><a href="#1-2-1-错误案例" class="headerlink" title="1.2.1 错误案例"></a>1.2.1 错误案例</h4><p>开启50个线程，对一个原子类变量进行操作</p><pre><code class="highlight java"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">AtomicIntegerTest</span> &#123;    <span class="keyword">private</span> <span class="keyword">static</span> <span class="type">int</span> <span class="variable">size</span> <span class="operator">=</span> <span class="number">50</span>; <span class="comment">// 50个线程</span>    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;        <span class="type">AtomicInteger</span> <span class="variable">atomicInteger</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">AtomicInteger</span>(<span class="number">0</span>);        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; size; i++) &#123;            <span class="keyword">new</span> <span class="title class_">Thread</span>(() -&gt; &#123;                <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> <span class="number">0</span>; j &lt; <span class="number">1000</span>; j++) &#123;                    atomicInteger.getAndIncrement();                &#125;            &#125;, <span class="string">&quot;t&quot;</span> + i).start();        &#125;        System.out.println(<span class="string">&quot;运行结果：&quot;</span> + atomicInteger.get());    &#125;&#125;</code></pre><p>运行结果：</p><pre><code class="highlight plaintext">运行结果：31056</code></pre><p>AtomicInteger 是一个线程安全的原子操作类，但是执行结果却跟预期的不一致，这是为什么？</p><p>原因：在打印结果的时候，50个线程并没有完全运行结束，导致最后获得的结果跟预期不一致。</p><h4 id="1-2-2-解决方式"><a href="#1-2-2-解决方式" class="headerlink" title="1.2.2 解决方式"></a>1.2.2 解决方式</h4><ul><li>方式一：在代码中添加 sleep，等待其它线程结束后再打印主线程<ul><li>此方式并不推荐，因为在实际开发中并不确定要等待多久，sleep操作影响系统的执行效率</li></ul></li><li>方式二：使用 <code>CountDownLatch</code></li></ul><pre><code class="highlight java"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">AtomicIntegerTest</span> &#123;    <span class="keyword">private</span> <span class="keyword">static</span> <span class="type">int</span> <span class="variable">size</span> <span class="operator">=</span> <span class="number">50</span>; <span class="comment">// 50个线程</span>    <span class="keyword">private</span> <span class="keyword">static</span> <span class="type">CountDownLatch</span> <span class="variable">countDownLatch</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">CountDownLatch</span>(<span class="number">50</span>);    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> InterruptedException &#123;        <span class="type">AtomicInteger</span> <span class="variable">atomicInteger</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">AtomicInteger</span>(<span class="number">0</span>);        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; size; i++) &#123;            <span class="keyword">new</span> <span class="title class_">Thread</span>(() -&gt; &#123;                <span class="keyword">try</span> &#123;                    <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> <span class="number">0</span>; j &lt; <span class="number">1000</span>; j++) &#123;                        atomicInteger.getAndIncrement();                    &#125;                &#125; <span class="keyword">finally</span> &#123;                    countDownLatch.countDown();                &#125;            &#125;, <span class="string">&quot;t&quot;</span> + i).start();        &#125;        <span class="comment">// 方式一：等待线程运行结果后，再打印</span><span class="comment">//        TimeUnit.SECONDS.sleep(2);</span>        <span class="comment">// 方式二：使用 countDownLatch</span>        countDownLatch.await();        System.out.println(<span class="string">&quot;运行结果：&quot;</span> + atomicInteger.get());    &#125;&#125;</code></pre><h2 id="2-数组类型原子类"><a href="#2-数组类型原子类" class="headerlink" title="2. 数组类型原子类"></a>2. 数组类型原子类</h2><ul><li>AtomicIntegerArray</li><li>AtomicLongArray</li><li>AtomicReferenceArray</li></ul><h3 id="2-1-使用案例"><a href="#2-1-使用案例" class="headerlink" title="2.1 使用案例"></a>2.1 使用案例</h3><pre><code class="highlight java"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">AtomicIntegerArrayDemo</span> &#123;    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;        <span class="comment">// 方式一：指定数组长度</span>        <span class="type">AtomicIntegerArray</span> <span class="variable">atomicIntegerArray</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">AtomicIntegerArray</span>(<span class="keyword">new</span> <span class="title class_">int</span>[<span class="number">5</span>]);        <span class="comment">// 方式二：指定数组长度</span>        <span class="comment">//AtomicIntegerArray atomicIntegerArray = new AtomicIntegerArray(5);</span>        <span class="comment">// 方式三：指定数组长度并初始化内容</span>        <span class="comment">//AtomicIntegerArray atomicIntegerArray = new AtomicIntegerArray(new int[]&#123;1,2,3,4,5&#125;);</span>        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; atomicIntegerArray.length(); i++) &#123;            System.out.println(atomicIntegerArray.get(i));        &#125;        System.out.println();        System.out.println();        System.out.println();        <span class="type">int</span> <span class="variable">tmpInt</span> <span class="operator">=</span> <span class="number">0</span>;        <span class="comment">// 指定下标设置内容</span>        tmpInt = atomicIntegerArray.getAndSet(<span class="number">0</span>, <span class="number">1122</span>);        System.out.println(tmpInt + <span class="string">&quot;\t&quot;</span> + atomicIntegerArray.get(<span class="number">0</span>)); <span class="comment">// 0 1122</span>        <span class="comment">// 指定下标元素自增</span>        atomicIntegerArray.getAndIncrement(<span class="number">1</span>);        atomicIntegerArray.getAndIncrement(<span class="number">1</span>);        tmpInt = atomicIntegerArray.getAndIncrement(<span class="number">1</span>);        <span class="comment">// 打印下标元素</span>        System.out.println(tmpInt + <span class="string">&quot;\t&quot;</span> + atomicIntegerArray.get(<span class="number">1</span>)); <span class="comment">// 2 3</span>    &#125;&#125;</code></pre><p>打印结果：</p><pre><code class="highlight shell">000000112223</code></pre><h2 id="3-引用类型原子类"><a href="#3-引用类型原子类" class="headerlink" title="3. 引用类型原子类"></a>3. 引用类型原子类</h2><ul><li>AtomicReference</li><li>AtomicStampedReference</li><li>AtomicMarkableReference</li></ul><h3 id="3-1-AtomicReference"><a href="#3-1-AtomicReference" class="headerlink" title="3.1 AtomicReference"></a>3.1 AtomicReference</h3><p><strong>基础使用案例</strong></p><pre><code class="highlight java"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">AtomicReferenceTest</span> &#123;    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;        <span class="type">User1</span> <span class="variable">user1</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">User1</span>(<span class="string">&quot;张三&quot;</span>, <span class="number">20</span>);        <span class="type">User1</span> <span class="variable">user2</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">User1</span>(<span class="string">&quot;george&quot;</span>, <span class="number">22</span>);        AtomicReference&lt;User1&gt; atomicUser1 = <span class="keyword">new</span> <span class="title class_">AtomicReference</span>&lt;&gt;();        atomicUser1.set(user1);        System.out.println(<span class="string">&quot;当前人员：&quot;</span> + atomicUser1.get());        <span class="comment">// 第一次比较替换，张三 换成 george， 结果成功</span>        System.out.println(atomicUser1.compareAndSet(user1, user2) + <span class="string">&quot;\t&quot;</span> + atomicUser1.get());        <span class="comment">// 第二次比较替换，张三 换成 george， 结果失败</span>        System.out.println(atomicUser1.compareAndSet(user1, user2) + <span class="string">&quot;\t&quot;</span> + atomicUser1.get());    &#125;&#125;<span class="meta">@Data</span><span class="meta">@ToString</span><span class="meta">@NoArgsConstructor</span><span class="meta">@AllArgsConstructor</span><span class="keyword">class</span> <span class="title class_">User1</span> &#123;    <span class="keyword">private</span> String name;    <span class="keyword">private</span> Integer age;&#125;</code></pre><p><strong>实现自旋锁</strong></p><pre><code class="highlight java"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">MySpinLock</span> &#123;    AtomicReference&lt;Thread&gt; atomicReference = <span class="keyword">new</span> <span class="title class_">AtomicReference</span>&lt;&gt;();    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">lock</span><span class="params">()</span> &#123;        <span class="comment">// 当没有替换成当前线程，则表示获取锁失败，线程自旋</span>        <span class="keyword">while</span> (!atomicReference.compareAndSet(<span class="literal">null</span>, Thread.currentThread())) &#123;        &#125;        System.out.println(Thread.currentThread().getName() + <span class="string">&quot;获取锁成功&quot;</span>);    &#125;    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">unlock</span><span class="params">()</span> &#123;        <span class="keyword">while</span> (atomicReference.compareAndSet(Thread.currentThread(), <span class="literal">null</span>)) &#123;            System.out.println(Thread.currentThread().getName() + <span class="string">&quot;解锁成功&quot;</span>);        &#125;    &#125;    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> InterruptedException &#123;        <span class="type">MySpinLock</span> <span class="variable">lock</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">MySpinLock</span>();        <span class="keyword">new</span> <span class="title class_">Thread</span>(() -&gt; &#123;            <span class="comment">// 获取锁</span>            lock.lock();            <span class="keyword">try</span> &#123;                <span class="comment">// 阻塞3秒</span>                TimeUnit.SECONDS.sleep(<span class="number">3</span>);            &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;                <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">RuntimeException</span>(e);            &#125;            <span class="comment">// 解锁</span>            lock.unlock();        &#125;, <span class="string">&quot;t1&quot;</span>).start();        <span class="comment">// 程序暂停1秒， 保证t1先拿到锁</span>        TimeUnit.SECONDS.sleep(<span class="number">1</span>);        <span class="keyword">new</span> <span class="title class_">Thread</span>(() -&gt; &#123;            lock.lock();            lock.unlock();        &#125;, <span class="string">&quot;t2&quot;</span>).start();    &#125;&#125;</code></pre><h3 id="3-2-AtomicStampedReference"><a href="#3-2-AtomicStampedReference" class="headerlink" title="3.2 AtomicStampedReference"></a>3.2 AtomicStampedReference</h3><p>携带版本号的引用类型原子类，可以解决ABA问题</p><p><strong>使用案例：</strong></p><pre><code class="highlight java"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ABATest</span> &#123;    <span class="comment">// 初始值：100   初始版本号：1</span>    <span class="keyword">static</span> AtomicStampedReference&lt;Integer&gt; stampedReference = <span class="keyword">new</span> <span class="title class_">AtomicStampedReference</span>&lt;&gt;(<span class="number">100</span>, <span class="number">1</span>);    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;        <span class="keyword">new</span> <span class="title class_">Thread</span>(() -&gt; &#123;            <span class="type">int</span> <span class="variable">stamp</span> <span class="operator">=</span> stampedReference.getStamp();            System.out.println(Thread.currentThread().getName() + <span class="string">&quot; 默认获取到的值：&quot;</span> + stampedReference.getReference() + <span class="string">&quot;\t默认版本号：&quot;</span> + stamp);            <span class="keyword">try</span> &#123;                TimeUnit.SECONDS.sleep(<span class="number">1</span>);            &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;                <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">RuntimeException</span>(e);            &#125;            <span class="comment">// 修改值，将版本号加1</span>            <span class="type">boolean</span> <span class="variable">flag1</span> <span class="operator">=</span> stampedReference.compareAndSet(<span class="number">100</span>, <span class="number">101</span>, stampedReference.getStamp(), stampedReference.getStamp() + <span class="number">1</span>);            System.out.println(Thread.currentThread().getName() + <span class="string">&quot;第一次修改：&quot;</span> + flag1);            <span class="comment">// 修改值，将版本号加1</span>            <span class="type">boolean</span> <span class="variable">flag2</span> <span class="operator">=</span> stampedReference.compareAndSet(<span class="number">101</span>, <span class="number">100</span>, stampedReference.getStamp(), stampedReference.getStamp() + <span class="number">1</span>);            System.out.println(Thread.currentThread().getName() + <span class="string">&quot;第二次修改：&quot;</span> + flag2);            System.out.println(<span class="string">&quot;修改后的值：&quot;</span> + stampedReference.getReference() + <span class="string">&quot;\t版本号：&quot;</span> + stampedReference.getStamp());        &#125;, <span class="string">&quot;t1&quot;</span>).start();        <span class="keyword">new</span> <span class="title class_">Thread</span>(() -&gt; &#123;            <span class="type">int</span> <span class="variable">stamp</span> <span class="operator">=</span> stampedReference.getStamp();            System.out.println(Thread.currentThread().getName() + <span class="string">&quot; 默认获取到的值：&quot;</span> + stampedReference.getReference() + <span class="string">&quot;\t默认版本号：&quot;</span> + stamp);            <span class="keyword">try</span> &#123;                TimeUnit.SECONDS.sleep(<span class="number">3</span>);            &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;                <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">RuntimeException</span>(e);            &#125;            <span class="comment">// 修改值，将版本号加1</span>            <span class="type">boolean</span> <span class="variable">flag</span> <span class="operator">=</span> stampedReference.compareAndSet(<span class="number">100</span>, <span class="number">2024</span>, stamp, stampedReference.getStamp() + <span class="number">1</span>);            System.out.println(Thread.currentThread().getName() + <span class="string">&quot;修改：&quot;</span> + flag);            System.out.println(<span class="string">&quot;修改后的值：&quot;</span> + stampedReference.getReference() + <span class="string">&quot;\t版本号：&quot;</span> + stampedReference.getStamp());        &#125;, <span class="string">&quot;t2&quot;</span>).start();    &#125;&#125;</code></pre><h3 id="3-3-AtomicMarkableReference"><a href="#3-3-AtomicMarkableReference" class="headerlink" title="3.3 AtomicMarkableReference"></a>3.3 AtomicMarkableReference</h3><p>原子更新带有标记位的引用类型对象.</p><p>解决对象是否修改过的问题，它的定义就是将状态戳简化为 true|false。</p><pre><code class="highlight java"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">AtomicMarkableReferenceDemo</span> &#123;    <span class="keyword">static</span> <span class="type">AtomicMarkableReference</span> <span class="variable">atomicMarkableReference</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">AtomicMarkableReference</span>(<span class="number">100</span>, <span class="literal">false</span>);    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;        <span class="keyword">new</span> <span class="title class_">Thread</span>(() -&gt; &#123;            <span class="type">boolean</span> <span class="variable">marked</span> <span class="operator">=</span> atomicMarkableReference.isMarked();            System.out.println(Thread.currentThread().getName() + <span class="string">&quot;\t&quot;</span> + <span class="string">&quot;---默认修改标识：&quot;</span> + marked);            <span class="keyword">try</span> &#123;                TimeUnit.SECONDS.sleep(<span class="number">1</span>);            &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;                e.printStackTrace();            &#125;            atomicMarkableReference.compareAndSet(<span class="number">100</span>, <span class="number">101</span>, marked, !marked);        &#125;, <span class="string">&quot;t1&quot;</span>).start();        <span class="keyword">new</span> <span class="title class_">Thread</span>(() -&gt; &#123;            <span class="type">boolean</span> <span class="variable">marked</span> <span class="operator">=</span> atomicMarkableReference.isMarked();            System.out.println(Thread.currentThread().getName() + <span class="string">&quot;\t&quot;</span> + <span class="string">&quot;---默认修改标识：&quot;</span> + marked);            <span class="keyword">try</span> &#123;                TimeUnit.SECONDS.sleep(<span class="number">2</span>);            &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;                e.printStackTrace();            &#125;            <span class="type">boolean</span> <span class="variable">b</span> <span class="operator">=</span> atomicMarkableReference.compareAndSet(<span class="number">100</span>, <span class="number">20210308</span>, marked, !marked);            System.out.println(Thread.currentThread().getName() + <span class="string">&quot;\t&quot;</span> + <span class="string">&quot;---操作是否成功:&quot;</span> + b);            System.out.println(Thread.currentThread().getName() + <span class="string">&quot;\t&quot;</span> + atomicMarkableReference.getReference());            System.out.println(Thread.currentThread().getName() + <span class="string">&quot;\t&quot;</span> + atomicMarkableReference.isMarked());        &#125;, <span class="string">&quot;t2&quot;</span>).start();    &#125;&#125;</code></pre><p>运行结果：</p><pre><code class="highlight shell">t1---默认修改标识：falset2---默认修改标识：falset2---操作是否成功:falset2101t2true</code></pre><h2 id="4-对象的属性修改原子类"><a href="#4-对象的属性修改原子类" class="headerlink" title="4. 对象的属性修改原子类"></a>4. 对象的属性修改原子类</h2><h3 id="4-1-原子类"><a href="#4-1-原子类" class="headerlink" title="4.1 原子类"></a>4.1 原子类</h3><ul><li><p>AtomicIntegerFieldUpdater</p><p>原子更新对象中<strong>int类型</strong>字段的值</p></li><li><p>AtomicLongFieldUpdater</p><p>原子更新对象中<strong>Long类型</strong>字段的值</p></li><li><p>AtomicReferenceFieldUpdater</p><p>原子更新<strong>引用类型</strong>字段的值</p></li></ul><h3 id="4-2-使用目的"><a href="#4-2-使用目的" class="headerlink" title="4.2 使用目的"></a>4.2 使用目的</h3><p>以一种线程安全的方式操作非线程安全对象内的某些字段</p><h3 id="4-3-使用要求"><a href="#4-3-使用要求" class="headerlink" title="4.3 使用要求"></a>4.3 使用要求</h3><p>更新的对象属性必须使用 public volatile 修饰符。</p><p>因为对象的属性修改类型原子类都是抽象类，所以每次使用都必须使用静态方法newUpdater()创建一个更新器，并且需要设置想要更新的类和属性。</p><h3 id="4-4-使用案例"><a href="#4-4-使用案例" class="headerlink" title="4.4 使用案例"></a>4.4 使用案例</h3><p><strong>AtomicIntegerFieldUpdater</strong> : Integer 类型字段的原子修改</p><pre><code class="highlight java"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">AtomicIntegerFieldUpdaterTest</span> &#123;    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> InterruptedException &#123;        <span class="type">Bank</span> <span class="variable">bank</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Bank</span>();        <span class="comment">// 创建10个线程，每个线程操作1000次</span>        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; <span class="number">10</span>; i++) &#123;            <span class="keyword">new</span> <span class="title class_">Thread</span>(() -&gt; &#123;                <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> <span class="number">0</span>; j &lt; <span class="number">1000</span>; j++) &#123;                    bank.add(bank);                &#125;            &#125;).start();        &#125;        <span class="comment">// 主线程等待其它线程运行结束</span>        TimeUnit.SECONDS.sleep(<span class="number">3</span>);        System.out.println(<span class="string">&quot;账户还剩：&quot;</span> + bank.money);    &#125;&#125;<span class="keyword">class</span> <span class="title class_">Bank</span> &#123;    <span class="comment">//以一种线程安全的方式操作非线程安全对象内的某些字段</span>    <span class="comment">//1 更新的对象属性必须使用 public volatile 修饰符。</span>    <span class="keyword">public</span> <span class="keyword">volatile</span> <span class="type">int</span> <span class="variable">money</span> <span class="operator">=</span> <span class="number">0</span>;    <span class="keyword">public</span> String name;    <span class="comment">//2 因为对象的属性修改类型原子类都是抽象类，所以每次使用都必须</span>    <span class="comment">// 使用静态方法newUpdater()创建一个更新器，并且需要设置想要更新的类和属性。</span>    AtomicIntegerFieldUpdater&lt;Bank&gt; fieldUpdater = AtomicIntegerFieldUpdater.newUpdater(Bank.class, <span class="string">&quot;money&quot;</span>);    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">add</span><span class="params">(Bank bank)</span> &#123;        <span class="comment">// 每次增加10</span>        fieldUpdater.getAndAdd(bank, <span class="number">10</span>);    &#125;&#125;</code></pre><p>运行结果：</p><pre><code class="highlight shell">账户还剩：100000</code></pre><p><strong>AtomicReferenceFieldUpdater</strong>： 引用类型字段的原子修改</p><pre><code class="highlight java"><span class="keyword">class</span> <span class="title class_">MyVar</span> &#123;    <span class="keyword">public</span> <span class="keyword">volatile</span> <span class="type">MyVar</span> <span class="variable">var</span> <span class="operator">=</span> <span class="literal">null</span>;    AtomicReferenceFieldUpdater&lt;MyVar, MyVar&gt; updater = AtomicReferenceFieldUpdater.newUpdater(MyVar.class, MyVar.class, <span class="string">&quot;var&quot;</span>);    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">init</span><span class="params">(MyVar myVar)</span> &#123;        <span class="keyword">if</span> (updater.compareAndSet(myVar, <span class="literal">null</span>, <span class="keyword">new</span> <span class="title class_">MyVar</span>())) &#123;            System.out.println(Thread.currentThread().getName() + <span class="string">&quot;\t&quot;</span> + <span class="string">&quot;---start init&quot;</span>);            <span class="keyword">try</span> &#123;                TimeUnit.SECONDS.sleep(<span class="number">3</span>);            &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;                e.printStackTrace();            &#125;            System.out.println(Thread.currentThread().getName() + <span class="string">&quot;\t&quot;</span> + <span class="string">&quot;---end init&quot;</span>);        &#125; <span class="keyword">else</span> &#123;            System.out.println(Thread.currentThread().getName() + <span class="string">&quot;\t&quot;</span> + <span class="string">&quot;---抢夺失败，已经有线程在修改中&quot;</span>);        &#125;    &#125;&#125;<span class="comment">/**</span><span class="comment"> * <span class="doctag">@auther</span> zzyy</span><span class="comment"> * <span class="doctag">@create</span> 2021-03-22 15:20</span><span class="comment"> * 多线程并发调用一个类的初始化方法，如果未被初始化过，将执行初始化工作，要求只能初始化一次</span><span class="comment"> */</span><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">AtomicReferenceFieldUpdaterDemo</span> &#123;    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;        <span class="type">MyVar</span> <span class="variable">myVar</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">MyVar</span>();        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">1</span>; i &lt;= <span class="number">5</span>; i++) &#123;            <span class="keyword">new</span> <span class="title class_">Thread</span>(() -&gt; &#123;                myVar.init(myVar);            &#125;, String.valueOf(i)).start();        &#125;    &#125;&#125;</code></pre><p>运行结果：</p><pre><code class="highlight shell">1---start init4---抢夺失败，已经有线程在修改中3---抢夺失败，已经有线程在修改中2---抢夺失败，已经有线程在修改中5---抢夺失败，已经有线程在修改中1---end init</code></pre><h1 id="三、JDK8新增的原子操作类"><a href="#三、JDK8新增的原子操作类" class="headerlink" title="三、JDK8新增的原子操作类"></a>三、JDK8新增的原子操作类</h1><h2 id="1-原子类"><a href="#1-原子类" class="headerlink" title="1. 原子类"></a>1. 原子类</h2><ul><li>DoubleAccumulator</li><li>DoubleAdder</li><li>LongAccumulator</li><li>LongAdder</li></ul><h2 id="2-常用API"><a href="#2-常用API" class="headerlink" title="2. 常用API"></a>2. 常用API</h2><ul><li><p>void add(long x) 将当前的value加x</p></li><li><p>void increment() 将当前的value加1</p></li><li><p>void decrement() 将当前的value减1</p></li><li><p>long sum() </p><p>返回当前值。特别注意，在没有并发更新value的情况下，sum会返回一个精确值，在存在并发的情况下，sum不保证返回精确值。</p></li><li><p>void reset()</p><p>将value重置为0，可用于替代重新new一个 LongAdder，但此方法只可以在没有并发更新的情况下使用。</p></li><li><p>long sumThenReset() </p><p>获取当前value，并将value重置为0</p></li></ul><h2 id="3-入门讲解"><a href="#3-入门讲解" class="headerlink" title="3. 入门讲解"></a>3. 入门讲解</h2><p>LongAdder 只能用来计算加法，且从零开始计算.</p><p><strong>LongAccumulator</strong> 提供了自定义的函数操作.</p><pre><code class="highlight java"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">LongAccumulatorDemo</span> &#123;    <span class="comment">//LongAccumulator longAccumulator = new LongAccumulator((x, y) -&gt; x + y,0);</span>    <span class="comment">// 初始值为10，每次调用，将传进来的参数与10相减</span>    <span class="type">LongAccumulator</span> <span class="variable">longAccumulator</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">LongAccumulator</span>(<span class="keyword">new</span> <span class="title class_">LongBinaryOperator</span>() &#123;        <span class="meta">@Override</span>        <span class="keyword">public</span> <span class="type">long</span> <span class="title function_">applyAsLong</span><span class="params">(<span class="type">long</span> left, <span class="type">long</span> right)</span> &#123;            <span class="keyword">return</span> left - right;        &#125;    &#125;, <span class="number">10</span>); <span class="comment">// 10 是初始值</span>    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">add_LongAccumulator</span><span class="params">()</span> &#123;        <span class="comment">// 每次减1</span>        longAccumulator.accumulate(<span class="number">1</span>);    &#125;    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;        <span class="type">LongAccumulatorDemo</span> <span class="variable">demo</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">LongAccumulatorDemo</span>();        <span class="comment">// 第一次操作</span>        demo.add_LongAccumulator();        <span class="comment">// 第二次操作</span>        demo.add_LongAccumulator();        <span class="comment">// 打印结果</span>        System.out.println(<span class="string">&quot;执行结果：&quot;</span> + demo.longAccumulator.longValue()); <span class="comment">// 结果：8</span>    &#125;&#125;</code></pre><p><strong>LongAdder 使用案例</strong></p><pre><code class="highlight java"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">LongAdderAPIDemo</span> &#123;    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;        <span class="type">LongAdder</span> <span class="variable">longAdder</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">LongAdder</span>();<span class="comment">//只能做加法</span>        longAdder.increment();        longAdder.increment();        longAdder.increment();        System.out.println(longAdder.longValue()); <span class="comment">// 3</span>    &#125;&#125;</code></pre><h2 id="4-LongAdder-高性能对比"><a href="#4-LongAdder-高性能对比" class="headerlink" title="4. LongAdder 高性能对比"></a>4. LongAdder 高性能对比</h2><p>对比在原子操作中，使用 synchronized、AtomicInteger、AtomicLong、LongAdder、LongAccumulator的性能差距</p><h3 id="4-1-测试代码："><a href="#4-1-测试代码：" class="headerlink" title="4.1 测试代码："></a>4.1 测试代码：</h3><pre><code class="highlight java"><span class="keyword">class</span> <span class="title class_">ClickNumber</span> &#123;    <span class="type">int</span> <span class="variable">number</span> <span class="operator">=</span> <span class="number">0</span>;    <span class="comment">/**</span><span class="comment">     * 对比1：使用 synchronized</span><span class="comment">     */</span>    <span class="keyword">public</span> <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title function_">add_Synchronized</span><span class="params">()</span> &#123;        number++;    &#125;    <span class="type">AtomicInteger</span> <span class="variable">atomicInteger</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">AtomicInteger</span>();    <span class="comment">/**</span><span class="comment">     * 对比2: AtomicInteger</span><span class="comment">     */</span>    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">add_AtomicInteger</span><span class="params">()</span> &#123;        atomicInteger.incrementAndGet();    &#125;    <span class="type">AtomicLong</span> <span class="variable">atomicLong</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">AtomicLong</span>();    <span class="comment">/**</span><span class="comment">     * 对比3：AtomicLong</span><span class="comment">     */</span>    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">add_AtomicLong</span><span class="params">()</span> &#123;        atomicLong.incrementAndGet();    &#125;    <span class="type">LongAdder</span> <span class="variable">longAdder</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">LongAdder</span>();    <span class="comment">/**</span><span class="comment">     * 对比4：LongAdder</span><span class="comment">     */</span>    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">add_LongAdder</span><span class="params">()</span> &#123;        longAdder.increment();        <span class="comment">//longAdder.sum();</span>    &#125;    <span class="type">LongAccumulator</span> <span class="variable">longAccumulator</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">LongAccumulator</span>((x, y) -&gt; x + y, <span class="number">0</span>);    <span class="comment">/**</span><span class="comment">     * 对比5：LongAccumulator</span><span class="comment">     */</span>    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">add_LongAccumulator</span><span class="params">()</span> &#123;        longAccumulator.accumulate(<span class="number">1</span>);    &#125;&#125;<span class="comment">/**</span><span class="comment"> * 50个线程，每个线程100W次，总点赞数出来</span><span class="comment"> */</span><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">LongAdderCalcDemo</span> &#123;    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">int</span> <span class="variable">SIZE_THREAD</span> <span class="operator">=</span> <span class="number">50</span>;    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">int</span> <span class="variable">_1W</span> <span class="operator">=</span> <span class="number">10000</span>;    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> InterruptedException &#123;        <span class="type">ClickNumber</span> <span class="variable">clickNumber</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ClickNumber</span>();        <span class="type">long</span> startTime;        <span class="type">long</span> endTime;        <span class="type">CountDownLatch</span> <span class="variable">countDownLatch1</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">CountDownLatch</span>(SIZE_THREAD);        <span class="type">CountDownLatch</span> <span class="variable">countDownLatch2</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">CountDownLatch</span>(SIZE_THREAD);        <span class="type">CountDownLatch</span> <span class="variable">countDownLatch3</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">CountDownLatch</span>(SIZE_THREAD);        <span class="type">CountDownLatch</span> <span class="variable">countDownLatch4</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">CountDownLatch</span>(SIZE_THREAD);        <span class="type">CountDownLatch</span> <span class="variable">countDownLatch5</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">CountDownLatch</span>(SIZE_THREAD);        <span class="comment">//========================</span>        <span class="comment">/****************** synchronized *******************/</span>        startTime = System.currentTimeMillis();        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">1</span>; i &lt;= SIZE_THREAD; i++) &#123;            <span class="keyword">new</span> <span class="title class_">Thread</span>(() -&gt; &#123;                <span class="keyword">try</span> &#123;                    <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> <span class="number">1</span>; j &lt;= <span class="number">100</span> * _1W; j++) &#123;                        clickNumber.add_Synchronized();                    &#125;                &#125; <span class="keyword">catch</span> (Exception e) &#123;                    e.printStackTrace();                &#125; <span class="keyword">finally</span> &#123;                    countDownLatch1.countDown();                &#125;            &#125;, String.valueOf(i)).start();        &#125;        countDownLatch1.await();        endTime = System.currentTimeMillis();        System.out.println(<span class="string">&quot;----costTime: &quot;</span> + (endTime - startTime) + <span class="string">&quot; 毫秒&quot;</span> + <span class="string">&quot;\t add_Synchronized&quot;</span> + <span class="string">&quot;\t&quot;</span> + clickNumber.number);        <span class="comment">/****************** AtomicInteger *******************/</span>        startTime = System.currentTimeMillis();        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">1</span>; i &lt;= SIZE_THREAD; i++) &#123;            <span class="keyword">new</span> <span class="title class_">Thread</span>(() -&gt; &#123;                <span class="keyword">try</span> &#123;                    <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> <span class="number">1</span>; j &lt;= <span class="number">100</span> * _1W; j++) &#123;                        clickNumber.add_AtomicInteger();                    &#125;                &#125; <span class="keyword">catch</span> (Exception e) &#123;                    e.printStackTrace();                &#125; <span class="keyword">finally</span> &#123;                    countDownLatch2.countDown();                &#125;            &#125;, String.valueOf(i)).start();        &#125;        countDownLatch2.await();        endTime = System.currentTimeMillis();        System.out.println(<span class="string">&quot;----costTime: &quot;</span> + (endTime - startTime) + <span class="string">&quot; 毫秒&quot;</span> + <span class="string">&quot;\t add_AtomicInteger&quot;</span> + <span class="string">&quot;\t&quot;</span> + clickNumber.atomicInteger.get());        <span class="comment">/****************** AtomicLong *******************/</span>        startTime = System.currentTimeMillis();        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">1</span>; i &lt;= SIZE_THREAD; i++) &#123;            <span class="keyword">new</span> <span class="title class_">Thread</span>(() -&gt; &#123;                <span class="keyword">try</span> &#123;                    <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> <span class="number">1</span>; j &lt;= <span class="number">100</span> * _1W; j++) &#123;                        clickNumber.add_AtomicLong();                    &#125;                &#125; <span class="keyword">catch</span> (Exception e) &#123;                    e.printStackTrace();                &#125; <span class="keyword">finally</span> &#123;                    countDownLatch3.countDown();                &#125;            &#125;, String.valueOf(i)).start();        &#125;        countDownLatch3.await();        endTime = System.currentTimeMillis();        System.out.println(<span class="string">&quot;----costTime: &quot;</span> + (endTime - startTime) + <span class="string">&quot; 毫秒&quot;</span> + <span class="string">&quot;\t add_AtomicLong&quot;</span> + <span class="string">&quot;\t&quot;</span> + clickNumber.atomicLong.get());        <span class="comment">/****************** LongAdder *******************/</span>        startTime = System.currentTimeMillis();        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">1</span>; i &lt;= SIZE_THREAD; i++) &#123;            <span class="keyword">new</span> <span class="title class_">Thread</span>(() -&gt; &#123;                <span class="keyword">try</span> &#123;                    <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> <span class="number">1</span>; j &lt;= <span class="number">100</span> * _1W; j++) &#123;                        clickNumber.add_LongAdder();                    &#125;                &#125; <span class="keyword">catch</span> (Exception e) &#123;                    e.printStackTrace();                &#125; <span class="keyword">finally</span> &#123;                    countDownLatch4.countDown();                &#125;            &#125;, String.valueOf(i)).start();        &#125;        countDownLatch4.await();        endTime = System.currentTimeMillis();        System.out.println(<span class="string">&quot;----costTime: &quot;</span> + (endTime - startTime) + <span class="string">&quot; 毫秒&quot;</span> + <span class="string">&quot;\t add_LongAdder&quot;</span> + <span class="string">&quot;\t&quot;</span> + clickNumber.longAdder.longValue());        <span class="comment">/****************** LongAccumulator *******************/</span>        startTime = System.currentTimeMillis();        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">1</span>; i &lt;= SIZE_THREAD; i++) &#123;            <span class="keyword">new</span> <span class="title class_">Thread</span>(() -&gt; &#123;                <span class="keyword">try</span> &#123;                    <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> <span class="number">1</span>; j &lt;= <span class="number">100</span> * _1W; j++) &#123;                        clickNumber.add_LongAccumulator();                    &#125;                &#125; <span class="keyword">catch</span> (Exception e) &#123;                    e.printStackTrace();                &#125; <span class="keyword">finally</span> &#123;                    countDownLatch5.countDown();                &#125;            &#125;, String.valueOf(i)).start();        &#125;        countDownLatch5.await();        endTime = System.currentTimeMillis();        System.out.println(<span class="string">&quot;----costTime: &quot;</span> + (endTime - startTime) + <span class="string">&quot; 毫秒&quot;</span> + <span class="string">&quot;\t add_LongAccumulator&quot;</span> + <span class="string">&quot;\t&quot;</span> + clickNumber.longAccumulator.longValue());    &#125;&#125;</code></pre><p>打印结果：</p><pre><code class="highlight shell">----costTime: 2591 毫秒 add_Synchronized50000000----costTime: 702 毫秒 add_AtomicInteger50000000----costTime: 622 毫秒 add_AtomicLong50000000----costTime: 89 毫秒     add_LongAdder50000000----costTime: 137 毫秒 add_LongAccumulator50000000</code></pre><h3 id="4-2-结论"><a href="#4-2-结论" class="headerlink" title="4.2 结论"></a>4.2 结论</h3><p>LongAdder、LongAccumulator 在高并发程序中的性能表现要远好于其它原子操作。</p><h1 id="四、源码、原理分析"><a href="#四、源码、原理分析" class="headerlink" title="四、源码、原理分析"></a>四、源码、原理分析</h1><p><strong>解释：原理(LongAdder为什么这么快)?</strong></p><h2 id="1-原理解析"><a href="#1-原理解析" class="headerlink" title="1. 原理解析"></a>1. 原理解析</h2><h3 id="1-1-原理概述"><a href="#1-1-原理概述" class="headerlink" title="1.1 原理概述"></a>1.1 原理概述</h3><p>LongAdder的基本思路就是分散热点，将value值分散到一个Cell数组中，不同线程会命中到数组的不同槽中，各个线程只对自己槽中的那个值进行CAS操作，这样热点就被分散了，冲突的概率就小很多。如果要获取真正的long值，只要将各个槽中的变量值累加返回。</p><p>sum()会将所有Cell数组中的value和base累加作为返回值，核心的思想就是将之前AtomicLong一个value的更新压力分散到多个value中去，从而降级更新热点。</p><h3 id="1-2-图示"><a href="#1-2-图示" class="headerlink" title="1.2 图示"></a>1.2 图示</h3><p>实现原理如图:</p><p><img src="https://raw.githubusercontent.com/GeorgeChan95/blogimg/master/img/2024/10/01/20241001-161418.png" alt="分散热点"></p><h3 id="1-3-数学表达"><a href="#1-3-数学表达" class="headerlink" title="1.3 数学表达"></a>1.3 数学表达</h3><p>$$<br>value &#x3D; base + \sum_{i&#x3D;0}^n Cell[i]<br>$$</p><p>内部有一个base变量，一个Cell[]数组。</p><ul><li>base变量：非竞态条件下，直接累加到该变量上</li><li>Cell[]数组：竞态条件下，累加个各个线程自己的槽Cell[i]中</li></ul><h2 id="2-LongAdder-架构"><a href="#2-LongAdder-架构" class="headerlink" title="2. LongAdder 架构"></a>2. LongAdder 架构</h2><p><img src="https://raw.githubusercontent.com/GeorgeChan95/blogimg/master/img/2024/09/30/20240930-081127.png" alt="image-20240930081126088"></p><p><strong>LongAdder是Striped64的子类</strong></p><p><img src="https://raw.githubusercontent.com/GeorgeChan95/blogimg/master/img/2024/10/01/20241001-162819.png" alt="LongAdder"></p><h2 id="3-Striped64"><a href="#3-Striped64" class="headerlink" title="3. Striped64"></a>3. Striped64</h2><h3 id="3-1-成员变量"><a href="#3-1-成员变量" class="headerlink" title="3.1 成员变量"></a>3.1 成员变量</h3><p>Striped64有几个比较重要的成员变量</p><pre><code class="highlight java"><span class="comment">/** 计算当前CPU数量,Cell[] 扩容时会用到 */</span><span class="keyword">static</span> <span class="keyword">final</span> <span class="type">int</span> <span class="variable">NCPU</span> <span class="operator">=</span> Runtime.getRuntime().availableProcessors();<span class="comment">/**</span><span class="comment"> * Table of cells. When non-null, size is a power of 2.</span><span class="comment"> */</span><span class="keyword">transient</span> <span class="keyword">volatile</span> Cell[] cells;<span class="comment">/**</span><span class="comment"> * 类似于AtomicLong中全局的value值。在没有竞争情况下数据直接累加到base上，或者cells扩容时，也需要将数据写入到base上</span><span class="comment"> */</span><span class="keyword">transient</span> <span class="keyword">volatile</span> <span class="type">long</span> base;<span class="comment">/**</span><span class="comment"> * 初始化cells或者扩容cells需要获取锁，0:表示无锁状态 1:表示其他线程已经持有了锁</span><span class="comment"> */</span><span class="keyword">transient</span> <span class="keyword">volatile</span> <span class="type">int</span> cellsBusy;</code></pre><h3 id="3-2-成员方法"><a href="#3-2-成员方法" class="headerlink" title="3.2 成员方法"></a>3.2 成员方法</h3><p>Striped64有几个比较重要的成员方法</p><pre><code class="highlight java"><span class="comment">/**</span><span class="comment"> * 通过CAS操作修改 cellsBusy 的值，CAS成功代表获取锁，返回true</span><span class="comment"> */</span><span class="keyword">final</span> <span class="type">boolean</span> <span class="title function_">casCellsBusy</span><span class="params">()</span> &#123;    <span class="keyword">return</span> CELLSBUSY.compareAndSet(<span class="built_in">this</span>, <span class="number">0</span>, <span class="number">1</span>);&#125;<span class="comment">/**</span><span class="comment"> * 获取当前线程的hash值</span><span class="comment"> */</span><span class="keyword">static</span> <span class="keyword">final</span> <span class="type">int</span> <span class="title function_">getProbe</span><span class="params">()</span> &#123;    <span class="keyword">return</span> (<span class="type">int</span>) THREAD_PROBE.get(Thread.currentThread());&#125;<span class="comment">/**</span><span class="comment"> * 重置当前线程的hash值</span><span class="comment"> */</span><span class="keyword">static</span> <span class="keyword">final</span> <span class="type">int</span> <span class="title function_">advanceProbe</span><span class="params">(<span class="type">int</span> probe)</span> &#123;    probe ^= probe &lt;&lt; <span class="number">13</span>;   <span class="comment">// xorshift</span>    probe ^= probe &gt;&gt;&gt; <span class="number">17</span>;    probe ^= probe &lt;&lt; <span class="number">5</span>;    THREAD_PROBE.set(Thread.currentThread(), probe);    <span class="keyword">return</span> probe;&#125;</code></pre><h2 id="4-Cell"><a href="#4-Cell" class="headerlink" title="4. Cell"></a>4. Cell</h2><p>是 java.util.concurrent.atomic 下 Striped64 的一个内部类, 它是LongAdder分散热点实现的具体载体</p><p><img src="https://raw.githubusercontent.com/GeorgeChan95/blogimg/master/img/2024/10/01/20241001-163654.png" alt="Cell内部类"></p><h1 id="五、LongAdder源码解读深度分析"><a href="#五、LongAdder源码解读深度分析" class="headerlink" title="五、LongAdder源码解读深度分析"></a>五、LongAdder源码解读深度分析</h1><h2 id="1-源码解读概述"><a href="#1-源码解读概述" class="headerlink" title="1. 源码解读概述"></a>1. 源码解读概述</h2><p>LongAdder在无竞争的情况，跟 AtomicLong 一样，对同一个base 进行操作，当出现竞争关系时则是采用化整为零的做法，从空间换时间，用一个数组cells，将一个value拆分进这个数组cells。多个线程需要同时对value进行操作时候，可以对线程id进行hash得到hash值，再根据hash值映射到这个数组cells的某个下标，再对该下标所对应的值进行自增操作。当所有线程操作完毕，将数组cells的所有值和无竞争值base都加起来作为最终结果。</p><p><img src="https://raw.githubusercontent.com/GeorgeChan95/blogimg/master/img/2024/10/01/20241001-164412.png" alt="LongAdder并发处理"></p><p><strong>数学表达</strong><br>$$<br>value &#x3D; base + \sum_{i&#x3D;0}^n Cell[i]<br>$$</p><h2 id="2-longAdder-increment-方法解析"><a href="#2-longAdder-increment-方法解析" class="headerlink" title="2. longAdder.increment() 方法解析"></a>2. longAdder.increment() 方法解析</h2><h3 id="2-1-调用流程"><a href="#2-1-调用流程" class="headerlink" title="2.1 调用流程"></a>2.1 调用流程</h3><p><code>java.util.concurrent.atomic.LongAdder#increment</code> —&gt; <code>java.util.concurrent.atomic.LongAdder#add</code> —&gt; <code>java.util.concurrent.atomic.Striped64#longAccumulate</code></p><h3 id="2-2-add-方法"><a href="#2-2-add-方法" class="headerlink" title="2.2 add() 方法"></a>2.2 add() 方法</h3><pre><code class="highlight java"><span class="comment">/**</span><span class="comment"> * Adds the given value.</span><span class="comment"> *</span><span class="comment"> * <span class="doctag">@param</span> x the value to add</span><span class="comment"> */</span><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">add</span><span class="params">(<span class="type">long</span> x)</span> &#123;    Cell[] cs; <span class="comment">// cells 的引用</span>    <span class="type">long</span> b; <span class="comment">// 获取的base值</span>    <span class="type">long</span> v; <span class="comment">// 期望值</span>    <span class="type">int</span> m; <span class="comment">// cell数组的长度</span>    Cell c; <span class="comment">// 当前线程命中的cell单元格</span>    <span class="comment">// 首次首线程 (cs = cells) != null 一定是false，此时走casBase方法，以CAS的方式更新base值，且只有当cas失败时，才会走到if中</span>    <span class="comment">// 条件1: cells不为室，说明出现过竞争，cell[]己创建</span>    <span class="comment">// 条件2:cas操作base失败，说明其它线程先一步修改了base正在出现竞争</span>    <span class="keyword">if</span> ((cs = cells) != <span class="literal">null</span> || !casBase(b = base, b + x)) &#123;        <span class="type">boolean</span> <span class="variable">uncontended</span> <span class="operator">=</span> <span class="literal">true</span>; <span class="comment">// true表示当前线程cas更新成功, false表示cas更新失败,线程处于竞争中</span>        <span class="comment">// 条件1: 表示cells为空,且线程处于竞争状态中,因为经过casBase方法返回false</span>        <span class="comment">// 条件2: cells数组长度小于0,这个应该不会出现</span>        <span class="comment">// 条件3: 当前线程所在的cell为空，说明当前线程还没有更新过cell，应初始化一个cell</span>        <span class="comment">// 条件4: 更新当前线程所在的cell失败，说明现在竞争很激烈，多个线程hash到了同一个cell，应扩容</span>        <span class="comment">// getProbe()方法返回的是线程中的threadLocalRandomProbe字段,它是通过随机数生成的一个值，对于一个确定的线程这个值是固定的(除非刻意修改它)</span>        <span class="keyword">if</span> (cs == <span class="literal">null</span> || (m = cs.length - <span class="number">1</span>) &lt; <span class="number">0</span> ||                (c = cs[getProbe() &amp; m]) == <span class="literal">null</span> ||                !(uncontended = c.cas(v = c.value, v + x)))            <span class="comment">// 调用striped64中的方法处理</span>            longAccumulate(x, <span class="literal">null</span>, uncontended);    &#125;&#125;</code></pre><p><img src="https://raw.githubusercontent.com/GeorgeChan95/blogimg/master/img/2024/10/01/20241001-165106.png" alt="add方法调用流程"></p><ol><li>最初无竞争时只更新base；</li><li>如果更新base失败后，首次新建一个Cell[]数组</li><li>当多个线程竞争同一个Cell比较激烈时，可能就要对Cell[]扩容</li></ol><h3 id="2-3-longAccumulate-方法"><a href="#2-3-longAccumulate-方法" class="headerlink" title="2.3 longAccumulate() 方法"></a>2.3 longAccumulate() 方法</h3><h4 id="2-3-1-longAccumulate入参说明"><a href="#2-3-1-longAccumulate入参说明" class="headerlink" title="2.3.1 longAccumulate入参说明"></a>2.3.1 longAccumulate入参说明</h4><ul><li>long x : 需要增加的值，一般默认都是1</li><li>LongBinaryOperatorfn : 默认传递的是null</li><li>wasUncontended : 竞争标识，如果是false则代表有竞争。只有cels初始化之后，并且当前线程CAS竞争修改失败，才会是false</li></ul><h4 id="2-3-2-Striped64中一些变量或者方法的定义"><a href="#2-3-2-Striped64中一些变量或者方法的定义" class="headerlink" title="2.3.2 Striped64中一些变量或者方法的定义"></a>2.3.2 Striped64中一些变量或者方法的定义</h4><ul><li>base : 类似于AtomicLong中全局的value值。在没有竞争情况下数据直接累加到base上，或者cells扩容时，也需要将数据写入到base上</li><li>collide : 表示扩容意向，false一定不会扩容，true可能会扩容。cellsBusy:初始化cells或者扩容cells需要获取锁，0:表示无锁状态 1:表示其他线程已经持有了锁</li><li>casCellsBusy() : 通过CAS操作修改cellsBusy的值，CAS成功代表获取锁，返回true</li><li>NCPU : 当前计算机CPU数量，Cell数组扩容时会使用到</li><li>getProbe() : 获取当前线程的hash值</li><li>advanceProbe() : 重置当前线程的hash值</li></ul><h4 id="2-3-3-线程hash值：probe"><a href="#2-3-3-线程hash值：probe" class="headerlink" title="2.3.3 线程hash值：probe"></a>2.3.3 线程hash值：probe</h4><p><img src="https://raw.githubusercontent.com/GeorgeChan95/blogimg/master/img/2024/10/01/20241001-170318.png" alt="调用getProbe"></p><p><img src="https://raw.githubusercontent.com/GeorgeChan95/blogimg/master/img/2024/10/01/20241001-170444.png" alt="定义和初始化"></p><p><img src="https://raw.githubusercontent.com/GeorgeChan95/blogimg/master/img/2024/10/01/20241001-170357.png" alt="getProbe"></p><h4 id="2-3-4-longAccumulate-源码总体概览"><a href="#2-3-4-longAccumulate-源码总体概览" class="headerlink" title="2.3.4 longAccumulate 源码总体概览"></a>2.3.4 longAccumulate 源码总体概览</h4><p><img src="https://raw.githubusercontent.com/GeorgeChan95/blogimg/master/img/2024/10/01/20241001-170910.png" alt="longAccumulate 源码总体概览"></p><ul><li>CASE1：Cell[]数组已经初始化</li><li>CASE2：Cell[]数组未初始化(首次新建)</li><li>CASE3：Cell[]数组正在初始化中</li></ul><h4 id="2-3-5-详细解读"><a href="#2-3-5-详细解读" class="headerlink" title="2.3.5 详细解读"></a>2.3.5 详细解读</h4><pre><code class="highlight java"><span class="comment">/**</span><span class="comment"> * long型数据原子方式增长</span><span class="comment"> * <span class="doctag">@param</span> x 需要增加的值, 一般默认都是1</span><span class="comment"> * <span class="doctag">@param</span> fn 默认传递是null</span><span class="comment"> * <span class="doctag">@param</span> wasUncontended 竞争标识,如果是false表示有竞争,只有cells初始化之后,并且当前线程CAS竞争修改失败,才会是false</span><span class="comment"> */</span><span class="keyword">final</span> <span class="keyword">void</span> <span class="title function_">longAccumulate</span><span class="params">(<span class="type">long</span> x, LongBinaryOperator fn,</span><span class="params">                          <span class="type">boolean</span> wasUncontended)</span> &#123;    <span class="comment">// 存储线程的probe值</span>    <span class="type">int</span> h;    <span class="comment">// 如果getProbe()方法返回0，说明随机数未初始化</span>    <span class="keyword">if</span> ((h = getProbe()) == <span class="number">0</span>) &#123;        <span class="comment">// 使用ThreadLocalRandom为当前线程重新计算一个hash值,强制初始化</span>        ThreadLocalRandom.current(); <span class="comment">// force initialization</span>        <span class="comment">// 重新获取probe值,hash值被重置就好比一个全新的线程一样，所以设置了wasuncontended竞争状态为true。</span>        h = getProbe();        <span class="comment">// 重新计算了当前线程的hash后认为此次不算是一次竞争，都未初始化，肯定还不存在竞争激烈wasuncontended竞争状态为true</span>        wasUncontended = <span class="literal">true</span>;    &#125;    <span class="type">boolean</span> <span class="variable">collide</span> <span class="operator">=</span> <span class="literal">false</span>; <span class="comment">// 用于标识是否发生碰撞</span>    done: <span class="keyword">for</span> (;;) &#123;        Cell[] cs; <span class="comment">// cell数组</span>        Cell c; <span class="comment">// 单个cell</span>        <span class="type">int</span> n; <span class="comment">// cell数组长度</span>        <span class="type">long</span> v; <span class="comment">// cell中存储的值</span>        <span class="comment">// CASE1: cells已经被初始化(cell数组不为空,且长度&gt;0)</span>        <span class="keyword">if</span> ((cs = cells) != <span class="literal">null</span> &amp;&amp; (n = cs.length) &gt; <span class="number">0</span>) &#123;            <span class="keyword">if</span> ((c = cs[(n - <span class="number">1</span>) &amp; h]) == <span class="literal">null</span>) &#123; <span class="comment">// 当前线程的hash值运算后映射得到的Cell单元为null，说明该Cell没有被使用</span>                <span class="keyword">if</span> (cellsBusy == <span class="number">0</span>) &#123;       <span class="comment">// Cell[]数组没有正在扩容, 尝试创建一个新的cell</span>                    <span class="type">Cell</span> <span class="variable">r</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Cell</span>(x);   <span class="comment">// 创建一个Cell单元,值为x</span>                    <span class="keyword">if</span> (cellsBusy == <span class="number">0</span> &amp;&amp; casCellsBusy()) &#123; <span class="comment">// 尝试加锁,成功后cellsBusy == 1</span>                        <span class="keyword">try</span> &#123;               <span class="comment">// Recheck under lock</span>                            Cell[] rs; <span class="comment">// 新的cell数组</span>                            <span class="type">int</span> m; <span class="comment">// 新cell数组的长度</span>                            <span class="type">int</span> j; <span class="comment">// 新的cell在cell数组中的索引下标</span>                            <span class="comment">// rs = cells 避免了对全局变量的直接引用, 提高安全性和效率,同时rs 和 cells指向同一个数组,rs变化,cells也会同步</span>                            <span class="keyword">if</span> ((rs = cells) != <span class="literal">null</span> &amp;&amp;                                    (m = rs.length) &gt; <span class="number">0</span> &amp;&amp;                                    rs[j = (m - <span class="number">1</span>) &amp; h] == <span class="literal">null</span>) &#123;                                rs[j] = r; <span class="comment">// 将新创建的cell r 放入cell数组的计算位置</span>                                <span class="keyword">break</span> done;                            &#125;                        &#125; <span class="keyword">finally</span> &#123;                            cellsBusy = <span class="number">0</span>; <span class="comment">// cell创建完成后,重新将cellsBusy置为0,非竞争状态</span>                        &#125;                        <span class="keyword">continue</span>;           <span class="comment">// Slot is now non-empty</span>                    &#125;                &#125;                collide = <span class="literal">false</span>;            &#125;            <span class="keyword">else</span> <span class="keyword">if</span> (!wasUncontended)       <span class="comment">// 如果前一次CAS更新Cell单元失败了</span>                wasUncontended = <span class="literal">true</span>;      <span class="comment">// 重新置为true，后面会重新计算线程的hash值</span>            <span class="keyword">else</span> <span class="keyword">if</span> (c.cas(v = c.value,                    (fn == <span class="literal">null</span>) ? v + x : fn.applyAsLong(v, x))) <span class="comment">// 试CAS更新Cell单元值</span>                <span class="keyword">break</span>;            <span class="keyword">else</span> <span class="keyword">if</span> (n &gt;= NCPU || cells != cs) <span class="comment">// 当Cell数组的大小超过CPU核数后，不再进行扩容</span>                collide = <span class="literal">false</span>;            <span class="comment">// At max size or stale</span>            <span class="keyword">else</span> <span class="keyword">if</span> (!collide)                collide = <span class="literal">true</span>;            <span class="keyword">else</span> <span class="keyword">if</span> (cellsBusy == <span class="number">0</span> &amp;&amp; casCellsBusy()) &#123; <span class="comment">// 尝试加锁进行扩容</span>                <span class="keyword">try</span> &#123;                    <span class="keyword">if</span> (cells == cs) <span class="comment">// cells和局部变量cs相同,表示没有其他线程扩容过</span>                        cells = Arrays.copyOf(cs, n &lt;&lt; <span class="number">1</span>); <span class="comment">// 扩容后的大小==当前容量*2</span>                &#125; <span class="keyword">finally</span> &#123;                    cellsBusy = <span class="number">0</span>;                &#125;                collide = <span class="literal">false</span>;                <span class="keyword">continue</span>;                   <span class="comment">// Retry with expanded table</span>            &#125;            h = advanceProbe(h); <span class="comment">// 计算线程新的hash值,重新参与下一轮竞争中</span>        &#125;        <span class="comment">// CASE2: cells没有加锁且没有初始化,则尝试对它进行加锁,并初始化</span>        <span class="keyword">else</span> <span class="keyword">if</span> (cellsBusy == <span class="number">0</span> &amp;&amp; cells == cs &amp;&amp; casCellsBusy()) &#123;            <span class="keyword">try</span> &#123;                           <span class="comment">// Initialize table</span>                <span class="keyword">if</span> (cells == cs) &#123; <span class="comment">// 进行两次校验, 由于cells是共有的对象,可能出现多线程并发修改导致对象状态发生变化,两次校验确保数据状态一致</span>                    Cell[] rs = <span class="keyword">new</span> <span class="title class_">Cell</span>[<span class="number">2</span>]; <span class="comment">// 新建一个容量为2的cell数组</span>                    rs[h &amp; <span class="number">1</span>] = <span class="keyword">new</span> <span class="title class_">Cell</span>(x); <span class="comment">// 找到当前线程hash到数组中的位置,并创建对应的cell</span>                    cells = rs;                    <span class="keyword">break</span> done;                &#125;            &#125; <span class="keyword">finally</span> &#123;                cellsBusy = <span class="number">0</span>;            &#125;        &#125;        <span class="comment">//  // CASE3: cells正在进行初始化,则尝试直接在base上进行累加操作</span>        <span class="keyword">else</span> <span class="keyword">if</span> (casBase(v = base,                (fn == <span class="literal">null</span>) ? v + x : fn.applyAsLong(v, x)))            <span class="keyword">break</span> done;    &#125;&#125;</code></pre><p><img src="https://raw.githubusercontent.com/GeorgeChan95/blogimg/master/img/2024/10/01/20241001-171450.png" alt="代码流程"></p><h2 id="3-sum-方法"><a href="#3-sum-方法" class="headerlink" title="3. sum() 方法"></a>3. sum() 方法</h2><p>sum()会将所有Cell数组中的value和base累加作为返回值。<br>核心的思想就是将之前AtomicLong一个value的更新压力分散到多个value中去，从而降级更新热点。</p><h3 id="为什么在并发情况下sum的值不精确"><a href="#为什么在并发情况下sum的值不精确" class="headerlink" title="为什么在并发情况下sum的值不精确"></a>为什么在并发情况下sum的值不精确</h3><p><strong>sum执行时，并没有限制对base和cells的更新(关键点)。所以LongAdder不是强一致性的，它是最终一致性的。</strong></p><ul><li>sum执行时，并没有限制对base和cells的更新(一句要命的话)。所以LongAdder不是强一致性的，它是最终一致性的。</li><li>sum执行时，并没有限制对base和cells的更新(一句要命的话)。所以LongAdder不是强一致性的，它是最终一致性的。</li></ul><p><img src="C:/Users/George/AppData/Roaming/Typora/typora-user-images/image-20241001171643897.png" alt="sum方法"></p><h1 id="六、总结"><a href="#六、总结" class="headerlink" title="六、总结"></a>六、总结</h1><h2 id="1-AtomicLong与LongAdder对比"><a href="#1-AtomicLong与LongAdder对比" class="headerlink" title="1. AtomicLong与LongAdder对比"></a>1. AtomicLong与LongAdder对比</h2><p><strong>AtomicLong</strong></p><ul><li>线程安全，可允许一些性能损耗，要求高精度时可使用</li><li>保证精度，性能代价</li><li>AtomicLong是多个线程针对单个热点值value进行原子操作</li></ul><p><strong>LongAdder</strong></p><ul><li>当需要在高并发下有较好的性能表现，且对值的精确度要求不高时，可以使用</li><li>保证性能，精度代价</li><li>LongAdder是每个线程拥有自己的槽，各个线程一般只对自己槽中的那个值进行CAS操作</li></ul><h2 id="2-AtomicLong"><a href="#2-AtomicLong" class="headerlink" title="2. AtomicLong"></a>2. AtomicLong</h2><p><strong>原理</strong></p><ul><li>CAS+自旋</li><li>incrementAndGet</li></ul><p><strong>场景</strong></p><ul><li>低并发下的全局计算</li><li>AtomicLong能保证并发情况下计数的准确性，其内部通过CAS来解决并发安全性的问题。</li></ul><p><strong>缺陷</strong></p><ul><li><p>高并发后性能急剧下降,AtomicLong的自旋会成为瓶颈</p><p>N个线程CAS操作修改线程的值，每次只有一个成功过，其它N - 1失败，失败的不停的自旋直到成功，这样大量失败自旋的情况，一下子cpu就打高了。</p></li></ul><h2 id="3-LongAdder"><a href="#3-LongAdder" class="headerlink" title="3. LongAdder"></a>3. LongAdder</h2><p><strong>原理</strong></p><ul><li>CAS+Base+Cell数组分散</li><li>空间换时间并分散了热点数据</li></ul><p><strong>场景</strong></p><p>高并发下的全局计算</p><p><strong>缺陷</strong></p><p>sum求和后还有计算线程修改结果的话，最后结果不够准确</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;一、常用原子操作类&quot;&gt;&lt;a href=&quot;#一、常用原子操作类&quot; class=&quot;headerlink&quot; title=&quot;一、常用原子操作类&quot;&gt;&lt;/a&gt;一、常用原子操作类&lt;/h1&gt;&lt;p&gt;JDK文档：&lt;a href=&quot;https://www.runoob.com/manu</summary>
      
    
    
    
    <category term="JUC" scheme="https://georgechan95.github.io/categories/JUC/"/>
    
    
    <category term="java" scheme="https://georgechan95.github.io/tags/java/"/>
    
    <category term="juc" scheme="https://georgechan95.github.io/tags/juc/"/>
    
  </entry>
  
  <entry>
    <title>07-JUC进阶-CAS</title>
    <link href="https://georgechan95.github.io/blog/5e3757c1.html"/>
    <id>https://georgechan95.github.io/blog/5e3757c1.html</id>
    <published>2024-09-26T11:37:00.000Z</published>
    <updated>2024-09-27T11:59:54.524Z</updated>
    
    <content type="html"><![CDATA[<h1 id="一、没有CAS之前"><a href="#一、没有CAS之前" class="headerlink" title="一、没有CAS之前"></a>一、没有CAS之前</h1><ul><li><p>多线程环境不使用原子类保证线程安全（基本数据类型）</p><pre><code class="highlight java"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">T1</span> &#123;    <span class="keyword">volatile</span> <span class="type">int</span> <span class="variable">number</span> <span class="operator">=</span> <span class="number">0</span>;    <span class="comment">//读取</span>    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">getNumber</span><span class="params">()</span> &#123;        <span class="keyword">return</span> number;    &#125;    <span class="comment">//写入加锁保证原子性</span>    <span class="keyword">public</span> <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title function_">setNumber</span><span class="params">()</span> &#123;        number++;    &#125;&#125;</code></pre></li><li><p>多线程环境使用原子类保证线程安全（基本数据类型）</p><pre><code class="highlight java"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">T2</span> &#123;    <span class="type">AtomicInteger</span> <span class="variable">atomicInteger</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">AtomicInteger</span>();    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">getAtomicInteger</span><span class="params">()</span> &#123;        <span class="keyword">return</span> atomicInteger.get();    &#125;    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setAtomicInteger</span><span class="params">()</span> &#123;        atomicInteger.getAndIncrement();    &#125;&#125;</code></pre></li></ul><h1 id="二、什么是CAS"><a href="#二、什么是CAS" class="headerlink" title="二、什么是CAS"></a>二、什么是CAS</h1><h2 id="1-概念"><a href="#1-概念" class="headerlink" title="1. 概念"></a>1. 概念</h2><p>CAS 即： compare and swap的缩写，中文翻译成比较并交换,实现并发算法时常用到的一种技术。它包含三个操作数——内存位置、预期原值及更新值。</p><p>执行CAS操作的时候，将内存位置的值与预期原值比较：</p><ul><li>如果相匹配，那么处理器会自动将该位置值更新为新值，</li><li>如果不匹配，处理器不做任何操作，多个线程同时执行CAS操作只有一个会成功。</li></ul><h2 id="2-原理"><a href="#2-原理" class="headerlink" title="2. 原理"></a>2. 原理</h2><h3 id="2-1-概述"><a href="#2-1-概述" class="headerlink" title="2.1 概述"></a>2.1 概述</h3><p>CAS有3个操作数，位置内存值V，旧的预期值A，要修改的更新值B。</p><p>当且仅当旧的预期值A和内存值V相同时，将内存值V修改为B，否则什么都不做或重来</p><p><img src="https://raw.githubusercontent.com/GeorgeChan95/blogimg/master/img/2024/09/26/20240926-200317.png" alt="CAS原理"></p><h3 id="2-2-硬件级别保证"><a href="#2-2-硬件级别保证" class="headerlink" title="2.2 硬件级别保证"></a>2.2 硬件级别保证</h3><p>CAS是JDK提供的非阻塞原子性操作，它通过硬件保证了比较-更新的原子性。</p><p>它是非阻塞的且自身原子性，也就是说它效率更高且通过硬件保证，更可靠。</p><p>CAS是一条CPU的原子指令（cmpxchg指令），不会造成所谓的数据不一致问题，Unsafe提供的CAS方法（如 compareAndSwapXXX ）底层实现即为CPU指令<code>cmpxchg</code>。</p><p>执行 <code>cmpxchg</code> 指令的时候，会判断当前系统是否为多核系统，如果是就给总线加锁，只有一个线程会对总线加锁成功，加锁成功之后会执行cas操作，也就是说CAS的原子性实际上是CPU实现的， 其实在这一点上还是有排他锁的，只是比起用 <code>synchronized</code>， 这里的排他时间要短的多， 所以在多线程情况下性能会比较好</p><h2 id="3-CAS代码示例"><a href="#3-CAS代码示例" class="headerlink" title="3. CAS代码示例"></a>3. CAS代码示例</h2><pre><code class="highlight java"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">CASDemo</span> &#123;    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;        <span class="type">AtomicInteger</span> <span class="variable">atomicInteger</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">AtomicInteger</span>(<span class="number">5</span>);        System.out.println(atomicInteger.get());                System.out.println(atomicInteger.compareAndSet(<span class="number">5</span>, <span class="number">308</span>) + <span class="string">&quot;\t&quot;</span> + atomicInteger.get());        System.out.println(atomicInteger.compareAndSet(<span class="number">5</span>, <span class="number">3333</span>) + <span class="string">&quot;\t&quot;</span> + atomicInteger.get());    &#125;&#125;</code></pre><p>执行结果：</p><pre><code class="highlight shell">5true308false308</code></pre><h2 id="4-源码解析"><a href="#4-源码解析" class="headerlink" title="4. 源码解析"></a>4. 源码解析</h2><ul><li><p>compareAndSet(int expect, int update)</p><pre><code class="highlight java"><span class="comment">/**</span><span class="comment"> * Atomically sets the value to the given updated value</span><span class="comment"> * if the current value &#123;<span class="doctag">@code</span> ==&#125; the expected value.</span><span class="comment"> *</span><span class="comment"> * <span class="doctag">@param</span> expect the expected value</span><span class="comment"> * <span class="doctag">@param</span> update the new value</span><span class="comment"> * <span class="doctag">@return</span> &#123;<span class="doctag">@code</span> true&#125; if successful. False return indicates that</span><span class="comment"> * the actual value was not equal to the expected value.</span><span class="comment"> */</span><span class="keyword">public</span> <span class="keyword">final</span> <span class="type">boolean</span> <span class="title function_">compareAndSet</span><span class="params">(<span class="type">int</span> expect, <span class="type">int</span> update)</span> &#123;    <span class="keyword">return</span> unsafe.compareAndSwapInt(<span class="built_in">this</span>, valueOffset, expect, update);&#125;</code></pre><ul><li><p>unsafe.compareAndSwapInt(this, valueOffset, expect, update)</p><pre><code class="highlight java"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">native</span> <span class="type">boolean</span> <span class="title function_">compareAndSwapObject</span><span class="params">(Object var1, <span class="type">long</span> var2, Object var4, Object var5)</span>;<span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">native</span> <span class="type">boolean</span> <span class="title function_">compareAndSwapInt</span><span class="params">(Object var1, <span class="type">long</span> var2, <span class="type">int</span> var4, <span class="type">int</span> var5)</span>;<span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">native</span> <span class="type">boolean</span> <span class="title function_">compareAndSwapLong</span><span class="params">(Object var1, <span class="type">long</span> var2, <span class="type">long</span> var4, <span class="type">long</span> var6)</span>;</code></pre></li></ul><p>上面三个方法都是类似的，主要对4个参数做一下说明。</p><ul><li>var1：表示要操作的对象</li><li>var2：表示要操作对象中属性地址的偏移量</li><li>var4：表示需要修改数据的期望的值</li><li>var5&#x2F;var6：表示需要修改为的新值</li></ul></li></ul><p>那么什么是 <code>unsafe</code> 呢？</p><h1 id="三、关于-UnSafe-的理解"><a href="#三、关于-UnSafe-的理解" class="headerlink" title="三、关于 UnSafe 的理解"></a>三、关于 UnSafe 的理解</h1><h2 id="1-UnSafe"><a href="#1-UnSafe" class="headerlink" title="1. UnSafe"></a>1. UnSafe</h2><p><strong>UnSafe</strong></p><p><code>Unsafe</code> 是CAS的核心类，由于Java方法无法直接访问底层系统，需要通过本地（native）方法来访问，<code>Unsafe</code> 相当于一个后门，基于该类可以直接操作特定内存的数据。<code>Unsafe</code> 类存在于 <code>sun.misc</code> 包中，其内部方法操作可以像C的指针一样直接操作内存，因为Java中CAS操作的执行依赖于<code>Unsafe</code>类的方法。</p><p><strong>注意Unsafe类中的所有方法都是native修饰的，也就是说Unsafe类中的方法都直接调用操作系统底层资源执行相应任务</strong> </p><p><img src="https://raw.githubusercontent.com/GeorgeChan95/blogimg/master/img/2024/09/26/20240926-202221.png" alt="AtomicInteger"></p><p><strong>变量valueOffset</strong></p><p>变量 valueOffset，表示该变量值在内存中的偏移地址，因为 <code>Unsafe</code> 就是根据内存偏移地址获取数据的。</p><pre><code class="highlight java"><span class="comment">/**</span><span class="comment"> * Atomically increments by one the current value.</span><span class="comment"> *</span><span class="comment"> * <span class="doctag">@return</span> the previous value</span><span class="comment"> */</span><span class="keyword">public</span> <span class="keyword">final</span> <span class="type">int</span> <span class="title function_">getAndIncrement</span><span class="params">()</span> &#123;    <span class="keyword">return</span> unsafe.getAndAddInt(<span class="built_in">this</span>, valueOffset, <span class="number">1</span>);&#125;</code></pre><p><strong>用volatile修饰</strong>，保证了多线程之间的内存可见性。</p><p><img src="C:/Users/kd/AppData/Roaming/Typora/typora-user-images/image-20240926202653288.png" alt="变量value"></p><h2 id="2-CPU并发原语"><a href="#2-CPU并发原语" class="headerlink" title="2. CPU并发原语"></a>2. CPU并发原语</h2><p>我们知道i++线程不安全的，那 <code>atomicInteger.getAndIncrement()</code> 是如何保证线程安全的呢？</p><p>CAS的全称为Compare-And-Swap，它是一条CPU并发原语。它的功能是判断内存某个位置的值是否为预期值，如果是则更改为新的值，这个过程是原子的。<br>AtomicInteger 类主要利用 CAS (compare and swap) + volatile 和 native 方法来保证原子操作，从而避免 synchronized 的高开销，执行效率大为提升。</p><p><img src="https://raw.githubusercontent.com/GeorgeChan95/blogimg/master/img/2024/09/26/20240926-203001.png" alt="Compare-And-Swap"></p><p>CAS并发原语体现在JAVA语言中就是 <code>sun.misc.Unsafe</code> 类中的各个方法。调用 UnSafe 类中的CAS方法，JVM会帮我们实现出CAS汇编指令。这是一种完全依赖于硬件的功能，通过它实现了原子操作。再次强调，由于CAS是一种系统原语，原语属于操作系统用语范畴，是由若干条指令组成的，用于完成某个功能的一个过程，并且原语的执行必须是连续的，在执行过程中不允许被中断，也就是说CAS是一条CPU的原子指令，不会造成所谓的数据不一致问题。</p><h2 id="3-底层汇编"><a href="#3-底层汇编" class="headerlink" title="3. 底层汇编"></a>3. 底层汇编</h2><ul><li><p>native修饰的方法代表是底层方法</p><p>Unsafe类中的compareAndSwapInt，是一个本地方法，该方法的实现位于unsafe.cpp中</p><pre><code class="highlight cpp"><span class="built_in">UNSAFE_ENTRY</span>(jboolean, <span class="built_in">Unsafe_CompareAndSwapInt</span>(JNIEnv *env, jobject unsafe, jobject obj, jlong offset, jint e, jint x))  <span class="built_in">UnsafeWrapper</span>(<span class="string">&quot;Unsafe_CompareAndSwapInt&quot;</span>);  oop p = JNIHandles::<span class="built_in">resolve</span>(obj);<span class="comment">// 先想办法拿到变量value在内存中的地址，根据偏移量valueOffset，计算 value 的地址</span>  jint* addr = (jint *) <span class="built_in">index_oop_from_field_offset_long</span>(p, offset);<span class="comment">// 调用 Atomic 中的函数 cmpxchg来进行比较交换，其中参数x是即将更新的值，参数e是原内存的值</span>  <span class="keyword">return</span> (jint)(Atomic::<span class="built_in">cmpxchg</span>(x, addr, e)) == e;UNSAFE_END</code></pre><p>(Atomic::cmpxchg(x, addr, e)) &#x3D;&#x3D; e;</p></li><li><p>cmpxchg</p><p>&#x2F;&#x2F; 调用 Atomic 中的函数 cmpxchg来进行比较交换，其中参数x是即将更新的值，参数e是原内存的值<br>  return (jint)(Atomic::cmpxchg(x, addr, e)) &#x3D;&#x3D; e;</p><pre><code class="highlight cpp"><span class="function"><span class="type">unsigned</span> <span class="title">Atomic::cmpxchg</span><span class="params">(<span class="type">unsigned</span> <span class="type">int</span> exchange_value,<span class="keyword">volatile</span> <span class="type">unsigned</span> <span class="type">int</span>* dest, <span class="type">unsigned</span> <span class="type">int</span> compare_value)</span> </span>&#123;    <span class="built_in">assert</span>(<span class="built_in">sizeof</span>(<span class="type">unsigned</span> <span class="type">int</span>) == <span class="built_in">sizeof</span>(jint), <span class="string">&quot;more work to do&quot;</span>);  <span class="comment">/*</span><span class="comment">   * 根据操作系统类型调用不同平台下的重载函数，这个在预编译期间编译器会决定调用哪个平台下的重载函数*/</span>    <span class="keyword">return</span> (<span class="type">unsigned</span> <span class="type">int</span>)Atomic::<span class="built_in">cmpxchg</span>((jint)exchange_value, (<span class="keyword">volatile</span> jint*)dest, (jint)compare_value);&#125;</code></pre></li><li><p>在不同的操作系统下会调用不同的cmpxchg重载函数，本次用的是win10系统</p><pre><code class="highlight cpp"><span class="function"><span class="keyword">inline</span> jint <span class="title">Atomic::cmpxchg</span> <span class="params">(jint exchange_value, <span class="keyword">volatile</span> jint* dest, jint compare_value)</span> </span>&#123;  <span class="comment">//判断是否是多核CPU</span>  <span class="type">int</span> mp = os::<span class="built_in">is_MP</span>();  __asm &#123;    <span class="comment">//三个move指令表示的是将后面的值移动到前面的寄存器上</span>    mov edx, dest    mov ecx, exchange_value    mov eax, compare_value    <span class="comment">//CPU原语级别，CPU触发</span>    <span class="built_in">LOCK_IF_MP</span>(mp)    <span class="comment">//比较并交换指令</span>    <span class="comment">//cmpxchg: 即“比较并交换”指令</span>    <span class="comment">//dword: 全称是 double word 表示两个字，一共四个字节</span>    <span class="comment">//ptr: 全称是 pointer，与前面的 dword 连起来使用，表明访问的内存单元是一个双字单元 </span>    <span class="comment">//将 eax 寄存器中的值（compare_value）与 [edx] 双字内存单元中的值进行对比，</span>    <span class="comment">//如果相同，则将 ecx 寄存器中的值（exchange_value）存入 [edx] 内存单元中</span>    cmpxchg dword ptr [edx], ecx  &#125;&#125;</code></pre><p>到这里我们应该理解了CAS真正实现的机制了，它最终是由操作系统的汇编指令完成的。</p></li></ul><p><strong>总结：</strong></p><p>你只需要记住：CAS是靠硬件实现的从而在硬件层面提升效率，最底层还是交给硬件来保证原子性和可见性。实现方式是基于硬件平台的汇编指令，在intel的CPU中(X86机器上)，使用的是汇编指令<code>cmpxchg</code>指令。 </p><p>核心思想就是：比较要更新变量的值V和预期值E（compare），相等才会将V的值设为新值N（swap）如果不相等自旋再来。</p><h1 id="四、原子引用"><a href="#四、原子引用" class="headerlink" title="四、原子引用"></a>四、原子引用</h1><p>除了 AtomicInteger 原子整型，可否有其它原子类型？比如 AtomicBook 、AtomicOrder。</p><p>JDK 除了提供了原子整型之外，还提供了原子引用类：<code>AtomicReference</code></p><p><img src="https://raw.githubusercontent.com/GeorgeChan95/blogimg/master/img/2024/09/27/20240927-192203.png" alt="原子引用"></p><pre><code class="highlight java"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">AtomicReferenceTest</span> &#123;    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;        <span class="type">User1</span> <span class="variable">user1</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">User1</span>(<span class="string">&quot;张三&quot;</span>, <span class="number">20</span>);        <span class="type">User1</span> <span class="variable">user2</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">User1</span>(<span class="string">&quot;george&quot;</span>, <span class="number">22</span>);        AtomicReference&lt;User1&gt; atomicUser1 = <span class="keyword">new</span> <span class="title class_">AtomicReference</span>&lt;&gt;();        atomicUser1.set(user1);        System.out.println(<span class="string">&quot;当前人员：&quot;</span> + atomicUser1.get());        <span class="comment">// 第一次比较替换，张三 换成 george， 结果成功</span>        System.out.println(atomicUser1.compareAndSet(user1, user2) + <span class="string">&quot;\t&quot;</span> + atomicUser1.get());        <span class="comment">// 第二次比较替换，张三 换成 george， 结果失败</span>        System.out.println(atomicUser1.compareAndSet(user1, user2) + <span class="string">&quot;\t&quot;</span> + atomicUser1.get());    &#125;&#125;<span class="meta">@Data</span><span class="meta">@ToString</span><span class="meta">@NoArgsConstructor</span><span class="meta">@AllArgsConstructor</span><span class="keyword">class</span> <span class="title class_">User1</span> &#123;    <span class="keyword">private</span> String name;    <span class="keyword">private</span> Integer age;&#125;</code></pre><p>运行结果：</p><pre><code class="highlight shell">当前人员：User1(name=张三, age=20)trueUser1(name=george, age=22)falseUser1(name=george, age=22)</code></pre><h1 id="五、自旋锁"><a href="#五、自旋锁" class="headerlink" title="五、自旋锁"></a>五、自旋锁</h1><h2 id="1-自旋锁概念"><a href="#1-自旋锁概念" class="headerlink" title="1. 自旋锁概念"></a>1. 自旋锁概念</h2><p><strong>自旋锁（spinlock）</strong>是指尝试获取锁的线程不会立即阻塞，而是采用循环的方式去尝试获取锁，当线程发现锁被占用时，会不断循环判断锁的状态，直到获取。这样的好处是减少线程上下文切换的消耗，缺点是循环会消耗CPU</p><p>OpenJDK源码里面查看下 </p><p><img src="https://raw.githubusercontent.com/GeorgeChan95/blogimg/master/img/2024/09/27/20240927-192926.png" alt="Unsafe.java"></p><h2 id="2-实现一个自旋锁"><a href="#2-实现一个自旋锁" class="headerlink" title="2. 实现一个自旋锁"></a>2. 实现一个自旋锁</h2><pre><code class="highlight java"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">MySpinLock</span> &#123;    AtomicReference&lt;Thread&gt; atomicReference = <span class="keyword">new</span> <span class="title class_">AtomicReference</span>&lt;&gt;();    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">lock</span><span class="params">()</span> &#123;        <span class="comment">// 当没有替换成当前线程，则表示获取锁失败，线程自旋</span>        <span class="keyword">while</span> (!atomicReference.compareAndSet(<span class="literal">null</span>, Thread.currentThread())) &#123;        &#125;        System.out.println(Thread.currentThread().getName() + <span class="string">&quot;获取锁成功&quot;</span>);    &#125;    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">unlock</span><span class="params">()</span> &#123;        <span class="keyword">while</span> (atomicReference.compareAndSet(Thread.currentThread(), <span class="literal">null</span>)) &#123;            System.out.println(Thread.currentThread().getName() + <span class="string">&quot;解锁成功&quot;</span>);        &#125;    &#125;    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> InterruptedException &#123;        <span class="type">MySpinLock</span> <span class="variable">lock</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">MySpinLock</span>();        <span class="keyword">new</span> <span class="title class_">Thread</span>(() -&gt; &#123;            <span class="comment">// 获取锁</span>            lock.lock();            <span class="keyword">try</span> &#123;                <span class="comment">// 阻塞3秒</span>                TimeUnit.SECONDS.sleep(<span class="number">3</span>);            &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;                <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">RuntimeException</span>(e);            &#125;            <span class="comment">// 解锁</span>            lock.unlock();        &#125;, <span class="string">&quot;t1&quot;</span>).start();        <span class="comment">// 程序暂停1秒， 保证t1先拿到锁</span>        TimeUnit.SECONDS.sleep(<span class="number">1</span>);        <span class="keyword">new</span> <span class="title class_">Thread</span>(() -&gt; &#123;            lock.lock();            lock.unlock();        &#125;, <span class="string">&quot;t2&quot;</span>).start();    &#125;&#125;</code></pre><p>运行结果：</p><pre><code class="highlight shell">t1获取锁成功t1解锁成功t2获取锁成功t2解锁成功</code></pre><p>结果：t1先拿到了锁，将 atomicReference 设置成自己，t2 再去获取锁的时候就会获取失败，然后在 while 中自旋， 等待 t1 释放锁后，t2才能获取到锁继续执行。</p><h1 id="六、CAS缺点"><a href="#六、CAS缺点" class="headerlink" title="六、CAS缺点"></a>六、CAS缺点</h1><h2 id="1-时间开销大"><a href="#1-时间开销大" class="headerlink" title="1. 时间开销大"></a>1. 时间开销大</h2><p>循环时间长开销很大。</p><p>我们可以看到 <code>getAndAddInt</code> 方法执行时，有个 <code>do while</code></p><p><img src="https://raw.githubusercontent.com/GeorgeChan95/blogimg/master/img/2024/09/27/20240927-194243.png" alt="do while"></p><p>如果CAS失败，会一直进行尝试。如果CAS长时间一直不成功，可能会给CPU带来很大的开销。</p><h2 id="2-ABA问题"><a href="#2-ABA问题" class="headerlink" title="2. ABA问题"></a>2. ABA问题</h2><p>CAS会导致“ABA问题”。</p><p>CAS算法实现一个重要前提需要取出内存中某时刻的数据并在当下时刻比较并替换，那么在这个时间差类会导致数据的变化。</p><p>比如说一个<strong>线程t1</strong>从内存位置V中取出A，这时候另一个<strong>线程t2</strong>也从内存中取出A，并且<strong>线程t2</strong>进行了一些操作将值变成了B，<br>然后<strong>线程t2</strong>又将V位置的数据变成A，这时候<strong>线程t1</strong>进行CAS操作发现内存中仍然是A，然后<strong>线程t1</strong>操作成功。</p><pre><code class="highlight java"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">abaProblem</span><span class="params">()</span> &#123;    <span class="keyword">new</span> <span class="title class_">Thread</span>(() -&gt; &#123;        atomicInteger.compareAndSet(<span class="number">100</span>, <span class="number">101</span>);        atomicInteger.compareAndSet(<span class="number">101</span>, <span class="number">100</span>);    &#125;, <span class="string">&quot;t1&quot;</span>).start();    <span class="comment">//暂停毫秒</span>    <span class="keyword">try</span> &#123;        TimeUnit.MILLISECONDS.sleep(<span class="number">10</span>);    &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;        e.printStackTrace();    &#125;    <span class="keyword">new</span> <span class="title class_">Thread</span>(() -&gt; &#123;        <span class="type">boolean</span> <span class="variable">b</span> <span class="operator">=</span> atomicInteger.compareAndSet(<span class="number">100</span>, <span class="number">20210308</span>);        System.out.println(Thread.currentThread().getName() + <span class="string">&quot;\t&quot;</span> + <span class="string">&quot;修改成功否：&quot;</span> + b + <span class="string">&quot;\t&quot;</span> + atomicInteger.get());    &#125;, <span class="string">&quot;t2&quot;</span>).start();&#125;</code></pre><p>尽管<strong>线程t1</strong>的CAS操作成功，但是不代表这个过程就是没有问题的。</p><p><strong>解决方式：</strong>使用 <code>AtomicStampedReference</code>， 带有版本号的原子操作类。</p><pre><code class="highlight java"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ABATest</span> &#123;    <span class="comment">// 初始值：100   初始版本号：1</span>    <span class="keyword">static</span> AtomicStampedReference&lt;Integer&gt; stampedReference = <span class="keyword">new</span> <span class="title class_">AtomicStampedReference</span>&lt;&gt;(<span class="number">100</span>, <span class="number">1</span>);    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;        <span class="keyword">new</span> <span class="title class_">Thread</span>(() -&gt; &#123;            <span class="type">int</span> <span class="variable">stamp</span> <span class="operator">=</span> stampedReference.getStamp();            System.out.println(Thread.currentThread().getName() + <span class="string">&quot; 默认获取到的值：&quot;</span> + stampedReference.getReference() + <span class="string">&quot;\t默认版本号：&quot;</span> + stamp);            <span class="keyword">try</span> &#123;                TimeUnit.SECONDS.sleep(<span class="number">1</span>);            &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;                <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">RuntimeException</span>(e);            &#125;            <span class="comment">// 修改值，将版本号加1</span>            <span class="type">boolean</span> <span class="variable">flag1</span> <span class="operator">=</span> stampedReference.compareAndSet(<span class="number">100</span>, <span class="number">101</span>, stampedReference.getStamp(), stampedReference.getStamp() + <span class="number">1</span>);            System.out.println(Thread.currentThread().getName() + <span class="string">&quot;第一次修改：&quot;</span> + flag1);            <span class="comment">// 修改值，将版本号加1</span>            <span class="type">boolean</span> <span class="variable">flag2</span> <span class="operator">=</span> stampedReference.compareAndSet(<span class="number">101</span>, <span class="number">100</span>, stampedReference.getStamp(), stampedReference.getStamp() + <span class="number">1</span>);            System.out.println(Thread.currentThread().getName() + <span class="string">&quot;第二次修改：&quot;</span> + flag2);            System.out.println(<span class="string">&quot;修改后的值：&quot;</span> + stampedReference.getReference() + <span class="string">&quot;\t版本号：&quot;</span> + stampedReference.getStamp());        &#125;, <span class="string">&quot;t1&quot;</span>).start();        <span class="keyword">new</span> <span class="title class_">Thread</span>(() -&gt; &#123;            <span class="type">int</span> <span class="variable">stamp</span> <span class="operator">=</span> stampedReference.getStamp();            System.out.println(Thread.currentThread().getName() + <span class="string">&quot; 默认获取到的值：&quot;</span> + stampedReference.getReference() + <span class="string">&quot;\t默认版本号：&quot;</span> + stamp);            <span class="keyword">try</span> &#123;                TimeUnit.SECONDS.sleep(<span class="number">3</span>);            &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;                <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">RuntimeException</span>(e);            &#125;            <span class="comment">// 修改值，将版本号加1</span>            <span class="type">boolean</span> <span class="variable">flag</span> <span class="operator">=</span> stampedReference.compareAndSet(<span class="number">100</span>, <span class="number">2024</span>, stamp, stampedReference.getStamp() + <span class="number">1</span>);            System.out.println(Thread.currentThread().getName() + <span class="string">&quot;修改：&quot;</span> + flag);            System.out.println(<span class="string">&quot;修改后的值：&quot;</span> + stampedReference.getReference() + <span class="string">&quot;\t版本号：&quot;</span> + stampedReference.getStamp());        &#125;, <span class="string">&quot;t2&quot;</span>).start();    &#125;&#125;</code></pre><p>运行结果</p><pre><code class="highlight shell">t1 默认获取到的值：100默认版本号：1t2 默认获取到的值：100默认版本号：1t1第一次修改：truet1第二次修改：true修改后的值：100版本号：3t2修改：false修改后的值：100版本号：3</code></pre>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;一、没有CAS之前&quot;&gt;&lt;a href=&quot;#一、没有CAS之前&quot; class=&quot;headerlink&quot; title=&quot;一、没有CAS之前&quot;&gt;&lt;/a&gt;一、没有CAS之前&lt;/h1&gt;&lt;ul&gt;
&lt;li&gt;&lt;p&gt;多线程环境不使用原子类保证线程安全（基本数据类型）&lt;/p&gt;
&lt;pr</summary>
      
    
    
    
    <category term="JUC" scheme="https://georgechan95.github.io/categories/JUC/"/>
    
    
    <category term="java" scheme="https://georgechan95.github.io/tags/java/"/>
    
    <category term="juc" scheme="https://georgechan95.github.io/tags/juc/"/>
    
  </entry>
  
  <entry>
    <title>06-JUC进阶-Volatile与Java内存模型</title>
    <link href="https://georgechan95.github.io/blog/546d628d.html"/>
    <id>https://georgechan95.github.io/blog/546d628d.html</id>
    <published>2024-09-25T11:01:01.000Z</published>
    <updated>2024-09-26T11:36:37.257Z</updated>
    
    <content type="html"><![CDATA[<h1 id="一、被Volatile修改的变量有2大特点"><a href="#一、被Volatile修改的变量有2大特点" class="headerlink" title="一、被Volatile修改的变量有2大特点"></a>一、被Volatile修改的变量有2大特点</h1><h2 id="1-特点"><a href="#1-特点" class="headerlink" title="1. 特点"></a>1. 特点</h2><ul><li><p>可见性</p><p>写完后立即刷新回主内存并及时发出通知，其它线程可以去主内存拿到最新的数据，前面的修改对后面所有线程可见</p></li><li><p>有序性</p><p>重排序是指编译器和处理器为了优化程序性能而对指令序列进行重新排序的一种手段，有时候会改变程序语句的先后顺序，若不存在数据依赖关系，可以重排序；存在数据依赖关系，禁止重排序；但重排后的指令绝对不能改变原有的串行语义！这点在并发设计中必须要重点考虑！</p></li></ul><p><strong>注意：volatile 修饰的字段，没有原子性</strong></p><h2 id="2-volatile的内存语义"><a href="#2-volatile的内存语义" class="headerlink" title="2. volatile的内存语义"></a>2. volatile的内存语义</h2><ul><li>当写一个volatile变量时，JMM会把该线程对应的本地内存中的共享变量值立即刷新回主内存中</li><li>当读一个volatile变量时，JMM会把该线程对应的本地内存设置为无效，重新回到主内存中读取最新共享变量的值</li><li>所以volatile的写内存语义是直接刷新到主内存中，读的内存语义是直接从主内存中读取</li></ul><p><strong>volatile凭什么可以保证可见性和有序性？</strong></p><p>  内存屏障Memory Barrier</p><h1 id="二、内存屏障"><a href="#二、内存屏障" class="headerlink" title="二、内存屏障"></a>二、内存屏障</h1><h2 id="1-什么是内存屏障"><a href="#1-什么是内存屏障" class="headerlink" title="1. 什么是内存屏障"></a>1. 什么是内存屏障</h2><p>内存屏障（也称内存栅栏，内存栅障，屏障指令等，是一类同步屏障指令，是CPU或编译器在对内存随机访问的操作中的一个同步点，使得此点之前的所有读写操作都执行后才可以开始执行此点之后的操作），避免代码重排序。内存屏障其实就是一种JVM指令，Java内存模型的重排规则会要求Java编译器在生成JVM指令时插入特定的内存屏障指令，通过这些内存屏障指令，volatile实现了Java内存模型中的可见性和有序性，但volatile无法保证原子性。</p><p>内存屏障之前的所有写操作都要回写到主内存，<br>内存屏障之后的所有读操作都能获得内存屏障之前的所有写操作的最新结果(实现了可见性)。</p><p><img src="https://raw.githubusercontent.com/GeorgeChan95/blogimg/master/img/2024/09/25/20240925-191447.png" alt="内存屏障"></p><p>因此重排序时，不允许把内存屏障之后的指令重排序到内存屏障之前。</p><p>一句话：<strong>对一个 volatile 域的写, happens-before 于任意后续对这个 volatile 域的读，也叫写后读。</strong></p><h2 id="2-内存屏障分类"><a href="#2-内存屏障分类" class="headerlink" title="2. 内存屏障分类"></a>2. 内存屏障分类</h2><h3 id="2-1-分类解析"><a href="#2-1-分类解析" class="headerlink" title="2.1 分类解析"></a>2.1 分类解析</h3><p><strong>内存屏障粗分为两种</strong></p><ul><li>读屏障（Load Barrier）：在读指令之前插入读屏障，让工作内存或CPU高速缓存 当中的缓存数据失效，重新回到主内存中获取最新数据。</li><li>写屏障（Store Barrier）：在写指令之后插入写屏障，强制把缓冲区的数据刷回到主内存中。</li></ul><p><strong>内存屏障细分四种：</strong></p><table><thead><tr><th><strong>屏障类型</strong></th><th><strong>指令示例</strong></th><th><strong>说明</strong></th></tr></thead><tbody><tr><td>LoadLoad</td><td>Load1;LoadLoad;Load2</td><td>保证Load1的读取操作在Load2及后续读取操作之前执行</td></tr><tr><td>StoreStore</td><td>Store1;StoreStore;Store2</td><td>在store2及其后的写操作执行前，保证Store1的写操作已经刷新到主内存</td></tr><tr><td>LoadStore</td><td>Load1;LoadStore;Store2</td><td>在Store2及其后的写操作执行前，保证Load1的读操作已经结束</td></tr><tr><td>StoreLoad</td><td>Store1;StoreLoad;Load2</td><td>保证Store1的写操作已经刷新到主内存后，Load2及其后的读操作才能执行</td></tr></tbody></table><h3 id="2-2-源码分析"><a href="#2-2-源码分析" class="headerlink" title="2.2 源码分析"></a>2.2 源码分析</h3><p>IDEA工具里面找 <code>Unsafe.class</code> –&gt; <code>Unsafe.java</code> –&gt; <code>Unsafe.cpp</code> –&gt; <code>OrderAccess.hpp</code> –&gt; <code>orderAccess_linux_x86.inline.hpp</code></p><ul><li>Unsafe.class</li></ul><p><img src="https://raw.githubusercontent.com/GeorgeChan95/blogimg/master/img/2024/09/25/20240925-193844.png" alt="Unsafe.class"></p><ul><li>Unsafe.java</li></ul><p><img src="https://raw.githubusercontent.com/GeorgeChan95/blogimg/master/img/2024/09/25/20240925-193745.png" alt="Unsafe.java"></p><ul><li>Unsafe.cpp</li></ul><p><img src="https://raw.githubusercontent.com/GeorgeChan95/blogimg/master/img/2024/09/25/20240925-194019.png" alt="Unsafe.cpp"></p><ul><li>OrderAccess.hpp</li></ul><p><img src="https://raw.githubusercontent.com/GeorgeChan95/blogimg/master/img/2024/09/25/20240925-194034.png" alt="OrderAccess.hpp"></p><ul><li>orderAccess_linux_x86.inline.hpp</li></ul><p><img src="https://raw.githubusercontent.com/GeorgeChan95/blogimg/master/img/2024/09/25/20240925-194058.png" alt="orderAccess_linux_x86.inline.hpp"></p><h2 id="3-volatile-变量规则与插入策略"><a href="#3-volatile-变量规则与插入策略" class="headerlink" title="3. volatile 变量规则与插入策略"></a>3. volatile 变量规则与插入策略</h2><h3 id="3-1-如何保证有序性？"><a href="#3-1-如何保证有序性？" class="headerlink" title="3.1 如何保证有序性？"></a>3.1 如何保证有序性？</h3><p><strong>通过内存屏障禁重排</strong></p><ul><li>重排序有可能影响程序的执行和实现，因此，我们有时候希望JVM不要自动重排序。</li><li>对于编译器的重排序，JMM会根据重排序的规则，禁止特定类型的编译器重排序</li><li>对于处理器的重排序，Java编译器在生成指令序列的适当位置，插入内存屏障指令，来禁止特定类型的处理器排序。</li></ul><h3 id="3-2-happens-before-之-volatile-变量规则"><a href="#3-2-happens-before-之-volatile-变量规则" class="headerlink" title="3.2 happens-before 之 volatile 变量规则"></a>3.2 happens-before 之 volatile 变量规则</h3><p><img src="https://raw.githubusercontent.com/GeorgeChan95/blogimg/master/img/2024/09/25/20240925-192602.png" alt="volatile变量规则"></p><ul><li>当第一个操作为volatile读时，不论第二个操作是什么，都不能重排序。这个操作保证了volatile读之后的操作不会被重排到volatile读之前。</li><li>当第二个操作为volatile写时，不论第一个操作是什么，都不能重排序。这个操作保证了volatile写之前的操作不会被重排到volatile写之后。</li><li>当第一个操作为volatile写时，第二个操作为volatile读时，不能重排。</li></ul><h3 id="3-3-内存屏障插⼊策略"><a href="#3-3-内存屏障插⼊策略" class="headerlink" title="3.3 内存屏障插⼊策略"></a>3.3 内存屏障插⼊策略</h3><p>JMM 就将内存屏障插⼊策略分为 4 种</p><p><strong>读屏障</strong></p><ul><li><p>在每个 volatile 读操作的后⾯插⼊⼀个 LoadLoad 屏障</p><p>LoadLoad屏障用来禁止处理器把上面的volatile读与下面的普通读重排序。</p></li><li><p>在每个 volatile 读操作的后⾯插⼊⼀个 LoadStore 屏障</p><p>LoadStore屏障用来禁止处理器把上面的volatile读与下面的普通写重排序。</p><p><img src="https://raw.githubusercontent.com/GeorgeChan95/blogimg/master/img/2024/09/25/20240925-195529.png" alt="读屏障"></p></li></ul><p><strong>写屏障</strong></p><ul><li><p>在每个 volatile 写操作的前⾯插⼊⼀个 StoreStore 屏障</p><p>StoreStore屏障可以保证在volatile写之前，其前面的所有普通写操作都已经刷新到主内存中。</p></li><li><p>在每个 volatile 写操作的后⾯插⼊⼀个 StoreLoad 屏障</p><p>StoreLoad屏障的作用是避免volatile写与后面可能有的volatile读&#x2F;写操作重排序</p><p><img src="https://raw.githubusercontent.com/GeorgeChan95/blogimg/master/img/2024/09/25/20240925-195658.png" alt="写屏障"></p></li></ul><h1 id="三、volatile特性"><a href="#三、volatile特性" class="headerlink" title="三、volatile特性"></a>三、volatile特性</h1><h2 id="1-保证可见性"><a href="#1-保证可见性" class="headerlink" title="1. 保证可见性"></a>1. 保证可见性</h2><p>保证不同线程对某个变量完成操作后结果及时可见，即该共享变量一旦改变所有线程立即可见</p><h3 id="1-1-代码示例："><a href="#1-1-代码示例：" class="headerlink" title="1.1 代码示例："></a>1.1 代码示例：</h3><pre><code class="highlight java"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">VolatileSeeDemo</span> &#123;<span class="comment">//    static boolean flag = true;       //不加volatile，没有可见性</span>    <span class="keyword">static</span> <span class="keyword">volatile</span> <span class="type">boolean</span> <span class="variable">flag</span> <span class="operator">=</span> <span class="literal">true</span>;       <span class="comment">//加了volatile，保证可见性</span>    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;        <span class="keyword">new</span> <span class="title class_">Thread</span>(() -&gt; &#123;            System.out.println(Thread.currentThread().getName() + <span class="string">&quot;\t&quot;</span> + <span class="string">&quot;---come in&quot;</span>);            <span class="keyword">while</span> (flag) &#123;                <span class="keyword">new</span> <span class="title class_">Integer</span>(<span class="number">308</span>);            &#125;            System.out.println(<span class="string">&quot;t1 over&quot;</span>);        &#125;, <span class="string">&quot;t1&quot;</span>).start();        <span class="keyword">try</span> &#123;            TimeUnit.SECONDS.sleep(<span class="number">1</span>);        &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;            e.printStackTrace();        &#125;        <span class="keyword">new</span> <span class="title class_">Thread</span>(() -&gt; &#123;            flag = <span class="literal">false</span>;        &#125;, <span class="string">&quot;t2&quot;</span>).start();    &#125;&#125;</code></pre><ul><li>不加volatile，没有可见性，程序无法停止</li><li>加了volatile，保证可见性，程序可以停止</li></ul><h3 id="1-2-原理解析"><a href="#1-2-原理解析" class="headerlink" title="1.2 原理解析"></a>1.2 原理解析</h3><p><strong>线程t1中为何看不到被主线程main修改为false的flag的值？</strong></p><p>猜测：</p><ol><li>主线程修改了flag之后没有将其刷新到主内存，所以t1线程看不到。</li><li>主线程将flag刷新到了主内存，但是t1一直读取的是自己工作内存中flag的值，没有去主内存中更新获取flag最新的值。</li></ol><p>诉求：</p><ol><li>线程中修改了工作内存中的副本之后，立即将其刷新到主内存</li><li>工作内存中每次读取共享变量时，都去主内存中重新读取，然后拷贝到工作内存</li></ol><p>使用 <code>volatile</code> 修饰共享变量，就可以达到上面的效果，被 <code>volatile</code> 修改的变量有以下特点：</p><ul><li>线程中读取的时候，每次读取都会去主内存中读取共享变量最新的值，然后将其复制到工作内存</li><li>线程中修改了工作内存中变量的副本，修改之后会立即刷新到主内存</li></ul><h3 id="1-3-volatile变量的读写过程"><a href="#1-3-volatile变量的读写过程" class="headerlink" title="1.3 volatile变量的读写过程"></a>1.3 volatile变量的读写过程</h3><p>Java内存模型中定义的8种工作内存与主内存之间的原子操作</p><p>read(读取)→load(加载)→use(使用)→assign(赋值)→store(存储)→write(写入)→lock(锁定)→unlock(解锁)</p><p><img src="https://raw.githubusercontent.com/GeorgeChan95/blogimg/master/img/2024/09/25/20240925-202607.png" alt="image-20240925202607271"></p><ul><li><p>read: 作用于主内存，将变量的值从主内存传输到工作内存，主内存到工作内存</p></li><li><p>load: 作用于工作内存，将read从主内存传输的变量值放入工作内存变量副本中，即数据加载</p></li><li><p>use: 作用于工作内存，将工作内存变量副本的值传递给执行引擎，每当JVM遇到需要该变量的字节码指令时会执行该操作</p></li><li><p>assign: 作用于工作内存，将从执行引擎接收到的值赋值给工作内存变量，每当JVM遇到一个给变量赋值字节码指令时会执行该操作</p></li><li><p>store: 作用于工作内存，将赋值完毕的工作变量的值写回给主内存</p></li><li><p>write: 作用于主内存，将store传输过来的变量值赋值给主内存中的变量</p><p>由于上述只能保证单条指令的原子性，针对多条指令的组合性原子保证，没有大面积加锁，所以，JVM提供了另外两个原子指令：</p></li><li><p>lock: 作用于主内存，将一个变量标记为一个线程独占的状态，只是写时候加锁，就只是锁了写变量的过程。</p></li><li><p>unlock: 作用于主内存，把一个处于锁定状态的变量释放，然后才能被其他线程占用</p></li></ul><h2 id="2-没有原子性"><a href="#2-没有原子性" class="headerlink" title="2. 没有原子性"></a>2. 没有原子性</h2><p>volatile变量的符合操作不具有原子性</p><ul><li><p>对于voaltile变量具备可见性，<strong>JVM只是保证从主内存加载到线程工作内存的值是最新的</strong>，也仅仅是数据加载时是最新的。但是多线程环境下，“数据计算”和“数据赋值”操作可能多次出现，若数据在加载之后，若主内存volatile修饰变量发生修改之后，线程工作内存的操作将会<strong>作废</strong>去读主内存最新值，<strong>操作出现写丢失问题</strong>。<strong>即各线程私有内存和主内存公共内存中变量不同步</strong>，进而导致数据不一致。由此可见volatile解决的是变量读时的可见性问题，但<strong>无法保证原子性，对于多线程修改主内存共享变量的场景必须加锁同步</strong>。</p><p><img src="https://raw.githubusercontent.com/GeorgeChan95/blogimg/master/img/2024/09/26/20240926-103838.png" alt="image-20240926103741047"></p></li><li><p>至于怎么去理解这个写丢失的问题，就是再将数据读取到本地内存到写回主内存中有三个步骤：数据加载—-&gt;数据计算—-&gt;数据赋值，如果第二个线程在第一个线程读取旧值与写回新值期间读取共享变量的值，那么第二个线程将会与第一个线程一起看到同一个值，并执行自己的操作，<strong>一旦其中一个线程对volatile修饰的变量先行完成操作刷回主内存后，另一个线程会作废自己的操作，然后重新去读取最新的值再进行操作，这样的话，它自身的那一次操作就丢失了</strong>，这就造成了 线程安全失败，因此，这个问题<strong>需要使用synchronized修饰以保证线程安全性</strong>。</p></li></ul><p><strong>读取赋值一个volatile变量的情况</strong></p><p><img src="https://raw.githubusercontent.com/GeorgeChan95/blogimg/master/img/2024/09/26/20240926-104126.png" alt="读取赋值一个volatile变量"></p><p>read-load-use 和 assign-store-write 成为了两个不可分割的原子操作，但是在use和assign之间依然有极小的一段真空期，有可能变量会被其他线程读取，导致写丢失一次。无论在哪一个时间点主内存的变量和任一工作内存的变量的值都是相等的。这个特性就导致了volatile变量不适合参与到依赖当前值的运算，如i &#x3D; i + 1; i++;之类的那么依靠可见性的特点volatile可以用在哪些地方呢？ 通常volatile用做保存某个状态的boolean值or int值。</p><p><strong>结论：volatile变量不适合参与到依赖当前值的运算</strong>，如i++，i&#x3D;i+1之类的，<strong>通常用来保存某个状态的boolean值或者int值</strong>，也正是由于volatile变量只能保证可见性，在不符合以下规则的运算场景中，我们仍然要通过加锁来保证原子性：</p><ul><li><p>运算结果并不依赖变量的当前值，或者能够确保只有单一的线程修改变量的值</p></li><li><p>变量不需要与其他的状态变量共同参与不变约束</p></li></ul><p><strong>volatile不具备原子性的代码示例</strong></p><pre><code class="highlight java"><span class="keyword">class</span> <span class="title class_">MyNumber1</span> &#123;    <span class="keyword">public</span> <span class="keyword">volatile</span> <span class="type">int</span> <span class="variable">num</span> <span class="operator">=</span> <span class="number">0</span>;    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">addNum</span><span class="params">()</span> &#123;        num++;    &#125;&#125;<span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">VolatileDemo</span> &#123;    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> InterruptedException &#123;        <span class="type">MyNumber1</span> <span class="variable">myNumber1</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">MyNumber1</span>();        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; <span class="number">10</span>; i++) &#123;            <span class="keyword">new</span> <span class="title class_">Thread</span>(() -&gt; &#123;                <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> <span class="number">0</span>; j &lt; <span class="number">1000</span>; j++) &#123;                    myNumber1.addNum();                &#125;            &#125;, <span class="string">&quot;t&quot;</span> + i).start();        &#125;        TimeUnit.SECONDS.sleep(<span class="number">3</span>);        System.out.println(<span class="string">&quot;执行结束，num值为：&quot;</span> + myNumber1.num);    &#125;&#125;</code></pre><p>执行结果：</p><pre><code class="highlight shell">执行结束，num值为：9913</code></pre><p>多次执行，结果都接近10000，但是到不了10000，原因在于上面说的，volatile修饰的变量，在多线程并发修改情况下会出现写丢失。</p><p><strong>解决方式：</strong> 给 addNum() 添加 synchronized</p><pre><code class="highlight java"><span class="keyword">public</span> <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title function_">addNum</span><span class="params">()</span> &#123;    num++;&#125;</code></pre><h2 id="3-指令禁重排"><a href="#3-指令禁重排" class="headerlink" title="3. 指令禁重排"></a>3. 指令禁重排</h2><h3 id="3-1-重排序"><a href="#3-1-重排序" class="headerlink" title="3.1 重排序"></a>3.1 重排序</h3><p>重排序是指编译器和处理器为了优化程序性能而对指令序列进行重新排序的一种手段，有时候会改变程序语句的先后顺序</p><ul><li>不存在数据依赖关系，可以重排序；</li><li><strong>存在数据依赖关系，禁止重排序</strong></li></ul><p>但重排后的指令绝对不能改变原有的串行语义！这点在并发设计中必须要重点考虑！</p><h3 id="3-2-重排序的分类和执行流程"><a href="#3-2-重排序的分类和执行流程" class="headerlink" title="3.2 重排序的分类和执行流程"></a>3.2 重排序的分类和执行流程</h3><p><img src="https://raw.githubusercontent.com/GeorgeChan95/blogimg/master/img/2024/09/26/20240926-161621.png" alt="重排序的分类和执行流程"></p><ul><li>编译器优化的重排序：编译器在不改变单线程串行语义的前提下，可以重新调整指令的执行顺序</li><li>指令级并行的重排序：处理器使用指令级并行技术来讲多条指令重叠执行，若不存在数据依赖性，处理器可以改变语句对应机器指令的执行顺序</li><li>内存系统的重排序：由于处理器使用缓存和读&#x2F;写缓冲区，这使得加载和存储操作看上去可能是乱序执行</li></ul><h3 id="3-3-数据依赖性"><a href="#3-3-数据依赖性" class="headerlink" title="3.3 数据依赖性"></a>3.3 数据依赖性</h3><p>若两个操作访问同一变量，且这两个操作中有一个为写操作，此时两操作间就存在数据依赖性。</p><p><strong>案例说明</strong></p><ul><li><p>不存在数据依赖关系，可以重排序</p><table><thead><tr><th>重排前</th><th>重排后</th></tr></thead><tbody><tr><td>int a &#x3D; 1;  &#x2F;&#x2F;1<br/>int b &#x3D; 20; &#x2F;&#x2F;2<br/>int c &#x3D; a + b; &#x2F;&#x2F;3</td><td>int b &#x3D; 20;  &#x2F;&#x2F;1<br/>int a &#x3D; 1; &#x2F;&#x2F;2<br/>int c &#x3D; a + b; &#x2F;&#x2F;3</td></tr><tr><td>结论：编译器调整了语句的顺序，但是不影响程序的最终结果。</td><td><strong>可以重排序</strong></td></tr></tbody></table></li><li><p><strong>存在数据依赖关系，禁止重排序</strong></p><p>重排序发生，会导致程序运行结果不同。编译器和处理器在重排序时，会遵守数据依赖性，不会改变存在依赖关系的两个操作的执行,但不同处理器和不同线程之间的数据性不会被编译器和处理器考虑，其只会作用于单处理器和单线程环境，下面三种情况，只要重排序两个操作的执行顺序，程序的执行结果就会被改变。</p><p><img src="https://raw.githubusercontent.com/GeorgeChan95/blogimg/master/img/2024/09/26/20240926-162829.png" alt="数据依赖"></p></li></ul><h1 id="四、如何正确使用volatile"><a href="#四、如何正确使用volatile" class="headerlink" title="四、如何正确使用volatile"></a>四、如何正确使用volatile</h1><h2 id="1-单一赋值"><a href="#1-单一赋值" class="headerlink" title="1. 单一赋值"></a>1. 单一赋值</h2><p>单一赋值可以，但是含复合运算赋值不可以(i++之类)</p><pre><code class="highlight java"><span class="keyword">volatile</span> <span class="type">int</span> <span class="variable">a</span> <span class="operator">=</span> <span class="number">10</span><span class="keyword">volatile</span> <span class="type">boolean</span> <span class="variable">flag</span> <span class="operator">=</span> <span class="literal">false</span></code></pre><h2 id="2-状态标志"><a href="#2-状态标志" class="headerlink" title="2. 状态标志"></a>2. 状态标志</h2><p>判断业务是否结束</p><pre><code class="highlight java"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">VolatileSeeDemo</span> &#123;<span class="comment">//    static boolean flag = true;       //不加volatile，没有可见性</span>    <span class="keyword">static</span> <span class="keyword">volatile</span> <span class="type">boolean</span> <span class="variable">flag</span> <span class="operator">=</span> <span class="literal">true</span>;       <span class="comment">//加了volatile，保证可见性</span>    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;        <span class="keyword">new</span> <span class="title class_">Thread</span>(() -&gt; &#123;            System.out.println(Thread.currentThread().getName() + <span class="string">&quot;\t&quot;</span> + <span class="string">&quot;---come in&quot;</span>);            <span class="keyword">while</span> (flag) &#123;                <span class="keyword">new</span> <span class="title class_">Integer</span>(<span class="number">308</span>);            &#125;            System.out.println(<span class="string">&quot;t1 over&quot;</span>);        &#125;, <span class="string">&quot;t1&quot;</span>).start();        <span class="keyword">try</span> &#123;            TimeUnit.SECONDS.sleep(<span class="number">1</span>);        &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;            e.printStackTrace();        &#125;        <span class="keyword">new</span> <span class="title class_">Thread</span>(() -&gt; &#123;            flag = <span class="literal">false</span>;        &#125;, <span class="string">&quot;t2&quot;</span>).start();    &#125;&#125;</code></pre><h2 id="3-开销较低的读，写锁策略"><a href="#3-开销较低的读，写锁策略" class="headerlink" title="3. 开销较低的读，写锁策略"></a>3. 开销较低的读，写锁策略</h2><pre><code class="highlight java"><span class="keyword">class</span> <span class="title class_">MyNumber1</span> &#123;    <span class="keyword">public</span> <span class="keyword">volatile</span> <span class="type">int</span> <span class="variable">num</span> <span class="operator">=</span> <span class="number">0</span>;    <span class="keyword">public</span> <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title function_">addNum</span><span class="params">()</span> &#123;        num++;    &#125;&#125;<span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">VolatileDemo</span> &#123;    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> InterruptedException &#123;        <span class="type">MyNumber1</span> <span class="variable">myNumber1</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">MyNumber1</span>();        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; <span class="number">10</span>; i++) &#123;            <span class="keyword">new</span> <span class="title class_">Thread</span>(() -&gt; &#123;                <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> <span class="number">0</span>; j &lt; <span class="number">1000</span>; j++) &#123;                    myNumber1.addNum();                &#125;            &#125;, <span class="string">&quot;t&quot;</span> + i).start();        &#125;        TimeUnit.SECONDS.sleep(<span class="number">3</span>);        System.out.println(<span class="string">&quot;执行结束，num值为：&quot;</span> + myNumber1.num);    &#125;&#125;</code></pre><h2 id="4-DCL双端锁的发布"><a href="#4-DCL双端锁的发布" class="headerlink" title="4. DCL双端锁的发布"></a>4. DCL双端锁的发布</h2><h3 id="4-1-问题代码示例"><a href="#4-1-问题代码示例" class="headerlink" title="4.1 问题代码示例"></a>4.1 问题代码示例</h3><pre><code class="highlight java"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">SafeDoubleCheckSingleton</span> &#123;    <span class="comment">// 加 volatile 保证了对象的可见性</span>    <span class="comment">//    private volatile static SafeDoubleCheckSingleton singleton = null;</span>    <span class="comment">// 不加 volatile 在多线程环境下可能导致获取到的对象是null</span>    <span class="keyword">private</span> <span class="keyword">static</span> <span class="type">SafeDoubleCheckSingleton</span> <span class="variable">singleton</span> <span class="operator">=</span> <span class="literal">null</span>;    <span class="comment">//私有化构造方法</span>    <span class="keyword">private</span> <span class="title function_">SafeDoubleCheckSingleton</span><span class="params">()</span> &#123;    &#125;    <span class="comment">//双重锁设计</span>    <span class="keyword">public</span> <span class="keyword">static</span> SafeDoubleCheckSingleton <span class="title function_">getInstance</span><span class="params">()</span> &#123;        <span class="keyword">if</span> (singleton == <span class="literal">null</span>) &#123;            <span class="comment">//1.多线程并发创建对象时，会通过加锁保证只有一个线程能创建对象</span>            <span class="keyword">synchronized</span> (SafeDoubleCheckSingleton.class) &#123;                <span class="keyword">if</span> (singleton == <span class="literal">null</span>) &#123;                    <span class="comment">//隐患：多线程环境下，由于重排序，该对象可能还未完成初始化就被其他线程读取</span>                    singleton = <span class="keyword">new</span> <span class="title class_">SafeDoubleCheckSingleton</span>();                &#125;            &#125;        &#125;        <span class="comment">//2.对象创建完毕，执行getInstance()将不需要获取锁，直接返回创建对象</span>        <span class="keyword">return</span> singleton;    &#125;    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;        <span class="type">SafeDoubleCheckSingleton</span> <span class="variable">instance</span> <span class="operator">=</span> SafeDoubleCheckSingleton.getInstance();    &#125;&#125;</code></pre><h3 id="4-2-问题如下"><a href="#4-2-问题如下" class="headerlink" title="4.2 问题如下"></a>4.2 问题如下</h3><ul><li><p>单线程环境下：(或者说正常情况下)，在”问题代码处”，会执行如下操作，保证能获取到已完成初始化的实例</p><p><img src="https://raw.githubusercontent.com/GeorgeChan95/blogimg/master/img/2024/09/26/20240926-172219.png" alt="单线程环境下指令执行逻辑"></p><p>由于代码从编译到执行的过程中，可能会出现指令重排，2、3 两处的指令执行顺序可能会颠倒，这就有可能导致返回的对象，还未执行初始化。</p></li><li><p>多线程环境下：在”问题代码处”，会执行如下操作，由于重排序导致2,3乱序，后果就是其他线程得到的是null而不是完成初始化的对象</p><p>正确的执行顺序</p><p><img src="https://raw.githubusercontent.com/GeorgeChan95/blogimg/master/img/2024/09/26/20240926-172545.png" alt="指令顺序-正确"></p><p>异常的执行顺序</p><p><img src="https://raw.githubusercontent.com/GeorgeChan95/blogimg/master/img/2024/09/26/20240926-172531.png" alt="指令顺序-异常"></p></li></ul><h3 id="4-3-问题解决"><a href="#4-3-问题解决" class="headerlink" title="4.3 问题解决"></a>4.3 问题解决</h3><h4 id="4-3-1-方式一：加volatile修饰"><a href="#4-3-1-方式一：加volatile修饰" class="headerlink" title="4.3.1 方式一：加volatile修饰"></a>4.3.1 方式一：加volatile修饰</h4><p><strong>原理:利用volatile，禁止 “初始化对象”(2) 和 “设置singleton指向内存空间”(3) 的重排序</strong></p><pre><code class="highlight java"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">SafeDoubleCheckSingleton</span> &#123;    <span class="comment">// 加 volatile 保证了对象的可见性，实现线程安全的延迟初始化。</span>    <span class="keyword">private</span> <span class="keyword">volatile</span> <span class="keyword">static</span> <span class="type">SafeDoubleCheckSingleton</span> <span class="variable">singleton</span> <span class="operator">=</span> <span class="literal">null</span>;    <span class="comment">//私有化构造方法</span>    <span class="keyword">private</span> <span class="title function_">SafeDoubleCheckSingleton</span><span class="params">()</span> &#123;    &#125;    <span class="comment">//双重锁设计</span>    <span class="keyword">public</span> <span class="keyword">static</span> SafeDoubleCheckSingleton <span class="title function_">getInstance</span><span class="params">()</span> &#123;        <span class="keyword">if</span> (singleton == <span class="literal">null</span>) &#123;            <span class="comment">//1.多线程并发创建对象时，会通过加锁保证只有一个线程能创建对象</span>            <span class="keyword">synchronized</span> (SafeDoubleCheckSingleton.class) &#123;                <span class="keyword">if</span> (singleton == <span class="literal">null</span>) &#123;                    <span class="comment">//隐患：多线程环境下，由于重排序，该对象可能还未完成初始化就被其他线程读取</span>                    singleton = <span class="keyword">new</span> <span class="title class_">SafeDoubleCheckSingleton</span>();                &#125;            &#125;        &#125;        <span class="comment">//2.对象创建完毕，执行getInstance()将不需要获取锁，直接返回创建对象</span>        <span class="keyword">return</span> singleton;    &#125;    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;        <span class="type">SafeDoubleCheckSingleton</span> <span class="variable">instance</span> <span class="operator">=</span> SafeDoubleCheckSingleton.getInstance();    &#125;&#125;</code></pre><h4 id="4-3-2-方式二：采用静态内部类的方式实现"><a href="#4-3-2-方式二：采用静态内部类的方式实现" class="headerlink" title="4.3.2 方式二：采用静态内部类的方式实现"></a>4.3.2 方式二：采用静态内部类的方式实现</h4><pre><code class="highlight java"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">SingletonDemo</span> &#123;    <span class="keyword">private</span> <span class="title function_">SingletonDemo</span><span class="params">()</span> &#123;    &#125;    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">class</span> <span class="title class_">SingletonDemoHandler</span> &#123;        <span class="keyword">private</span> <span class="keyword">static</span> <span class="type">SingletonDemo</span> <span class="variable">instance</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">SingletonDemo</span>();    &#125;    <span class="keyword">public</span> <span class="keyword">static</span> SingletonDemo <span class="title function_">getInstance</span><span class="params">()</span> &#123;        <span class="keyword">return</span> SingletonDemoHandler.instance;    &#125;&#125;</code></pre><h1 id="五、总结"><a href="#五、总结" class="headerlink" title="五、总结"></a>五、总结</h1><p>凭什么我们java写了一个volatile关键字系统底层加入内存屏障？两者关系怎么勾搭上的?</p><ul><li><p>字节码层面</p><p>它其实给 volatile 修饰的字段添加了一个 <code>ACC_VOLATILE</code> 标识</p><p>查看命令：<code>javap -v -p SafeDoubleCheckSingleton.class</code></p><p><img src="https://raw.githubusercontent.com/GeorgeChan95/blogimg/master/img/2024/09/26/20240926-180150.png" alt="image-20240926180150159"></p></li></ul><p>JVM 在把字节码 生成 为 机器码 的时候，发现操作是 volatile 的变量的话，就会根据 JMM 要求，在相应的位置去插入 内存屏障指令</p><p><strong>对比 java.util.concurrent.locks.Lock 来理解</strong></p><p>cpu执行机器码指令的时候，是使用lock前缀指令 来实现 volatile 的功能的。</p><p>Lock 指令，相当于内存屏障，功能也类似内存屏障的功能:</p><ul><li>首先对总线&#x2F;缓存加锁，然后去执行后面的指令，最后，释放锁，同时把高速缓存的数据刷新回到主内存</li><li>在 lock 锁住总线&#x2F;缓存的时候，其它 cpu 的读写请求就会被阻塞，直到锁释放。Lock过后的写操作,会让其它cpu的高速缓存中相应的数据失效这样后续这些 cpu 在读取数据的时候，就会从主内存去加载最新的数据</li></ul><p>加了 Lock 指令过后的具体表现，就跟 JMM 添加内存屏障后一样。</p><p><strong>一句话总结</strong></p><ul><li>volatile写之前的的操作，都禁止重排到volatile之后</li><li>volatile读之后的操作，都禁止重排到volatile之前</li><li>volatile写之后volatile读，禁止重排序</li></ul>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;一、被Volatile修改的变量有2大特点&quot;&gt;&lt;a href=&quot;#一、被Volatile修改的变量有2大特点&quot; class=&quot;headerlink&quot; title=&quot;一、被Volatile修改的变量有2大特点&quot;&gt;&lt;/a&gt;一、被Volatile修改的变量有2大特点&lt;/</summary>
      
    
    
    
    <category term="JUC" scheme="https://georgechan95.github.io/categories/JUC/"/>
    
    
    <category term="java" scheme="https://georgechan95.github.io/tags/java/"/>
    
    <category term="juc" scheme="https://georgechan95.github.io/tags/juc/"/>
    
  </entry>
  
  <entry>
    <title>05-JUC进阶-Java内存模型-JMM</title>
    <link href="https://georgechan95.github.io/blog/1f2e0014.html"/>
    <id>https://georgechan95.github.io/blog/1f2e0014.html</id>
    <published>2024-09-23T15:01:07.000Z</published>
    <updated>2024-09-25T05:09:23.536Z</updated>
    
    <content type="html"><![CDATA[<h1 id="一、计算机硬件存储体系"><a href="#一、计算机硬件存储体系" class="headerlink" title="一、计算机硬件存储体系"></a>一、计算机硬件存储体系</h1><p> 计算机存储结构，从本地磁盘 到 主内存 到 CPU缓存，也就是从硬盘 -&gt; 内存 -&gt; CPU。</p><p>一般对应的程序的操作就是从数据库查数据到内存然后到CPU进行计算</p><p><img src="https://raw.githubusercontent.com/GeorgeChan95/blogimg/master/img/2024/09/23/20240923-162409.png" alt="计算机硬件存储体系"></p><p>由于CPU和物理主内存的速度不一致（CPU速度远快于主内存），因此CPU和主内存之间需要多级缓存。</p><p>CPU的运行并不是直接操作内存而是先把内存里边的数据读到缓存，而内存的读和写操作的时候就会造成不一致的问题。</p><p><img src="https://raw.githubusercontent.com/GeorgeChan95/blogimg/master/img/2024/09/23/20240923-162728.png" alt="CPU-缓存-内存"></p><p>Java虚拟机规范中试图定义一种Java内存模型（java Memory Model，简称JMM) 来屏蔽掉各种硬件和操作系统的内存访问差异，以实现让Java程序在各种平台下都能达到一致的内存访问效果。</p><h1 id="二、Java内存模型-JMM"><a href="#二、Java内存模型-JMM" class="headerlink" title="二、Java内存模型-JMM"></a>二、Java内存模型-JMM</h1><h2 id="1-JMM概述"><a href="#1-JMM概述" class="headerlink" title="1. JMM概述"></a>1. JMM概述</h2><p>JMM(Java内存模型Java Memory Model，简称JMM)本身是一种抽象的概念并不真实存在<strong>它仅仅描述的是一组约定或规范</strong>，通过这组规范定义了程序中(尤其是多线程)各个变量的读写访问方式并决定一个线程对共享变量的写入何时以及如何变成对另一个线程可见，<strong>关键技术点都是围绕多线程的原子性、可见性和有序性展开的</strong>。</p><h2 id="2-JMM的作用"><a href="#2-JMM的作用" class="headerlink" title="2. JMM的作用"></a>2. JMM的作用</h2><ul><li>通过JMM来实现线程和主内存之间的抽象关系</li><li>屏蔽各个硬件平台和操作系统的内存访问差异以实现让Java程序在各种平台下都能达到一致的内存访问效果。</li></ul><h2 id="3-JMM规范下，三大特性"><a href="#3-JMM规范下，三大特性" class="headerlink" title="3. JMM规范下，三大特性"></a>3. JMM规范下，三大特性</h2><ul><li><p>可见性</p></li><li><p>原子性</p></li><li><p>有序性</p></li></ul><h3 id="3-1-可见性"><a href="#3-1-可见性" class="headerlink" title="3.1 可见性"></a>3.1 可见性</h3><p>是指当一个线程修改了某一个共享变量的值，其他线程是否能够立即知道该变更 ，JMM规定了所有的变量都存储在主内存中。</p><p><img src="https://raw.githubusercontent.com/GeorgeChan95/blogimg/master/img/2024/09/23/20240923-165016.png" alt="CPU-缓存-主存"></p><p><img src="https://raw.githubusercontent.com/GeorgeChan95/blogimg/master/img/2024/09/23/20240923-165023.png" alt="多线程修改同一个变量"></p><p><strong>Java中普通的共享变量不保证可见性</strong>，因为数据修改被写入内存的时机是不确定的，多线程并发下很可能出现**”脏读”<strong>，所以每个线程都有自己的</strong>工作内存<strong>，线程自己的工作内存中保存了该线程使用到的变量的</strong>主内存副本拷贝**，线程对变量的所有操作（读取，赋值等 ）都必需在线程自己的工作内存中进行，而不能够直接读写主内存中的变量。不同线程之间也无法直接访问对方工作内存中的变量，线程间变量值的传递均需要通过主内存来完成</p><p><img src="https://raw.githubusercontent.com/GeorgeChan95/blogimg/master/img/2024/09/23/20240923-164824.png" alt="线程-主存-工作内存的关系"></p><p> <strong>线程脏读：如果没有可见性保证</strong></p><ul><li>主内存中有变量 x，初始值为 0</li><li>线程 A 要将 x 加 1，先将 x&#x3D;0 拷贝到自己的私有内存中，然后更新 x 的值</li><li>线程 A 将更新后的 x 值回刷到主内存的时间是不固定的</li><li>刚好在线程 A 没有回刷 x 到主内存时，线程 B 同样从主内存中读取 x，此时为 0，和线程 A 一样的操作，最后期盼的 x&#x3D;2 就会变成 x&#x3D;1</li></ul><p><img src="https://raw.githubusercontent.com/GeorgeChan95/blogimg/master/img/2024/09/23/20240923-170757.png" alt="线程脏读"></p><h3 id="3-2-原子性"><a href="#3-2-原子性" class="headerlink" title="3.2 原子性"></a>3.2 原子性</h3><p>指一个操作是不可被打断的，即多线程环境下，操作不能被其他线程干扰</p><h3 id="3-3-有序性"><a href="#3-3-有序性" class="headerlink" title="3.3. 有序性"></a>3.3. 有序性</h3><p>对于一个线程的执行代码而言，我们总是习惯性地认为代码的执行总是从上到下，有序执行。但为了提升性能，编译器和处理器通常会对指令序列进行重新排序。Java规范规定JVM线程内部维持顺序化语义，即只要程序的最终结果与它顺序化执行的结果相等，那么指令的执行顺序可以与代码顺序不一致，此过程叫指令的重排序。</p><p>  <strong>优缺点：</strong></p><ul><li>JVM能根据处理器特性（CPU多级缓存系统、多核处理器等）适当的对机器指令进行重排序，使机器指令更符合CPU的执行特性，最大限度的发挥机器性能</li><li>​    但是指令重排可以保证串行语义一致，<strong>但没有义务保证多线程的语义也一致（即可能产生“脏读”）</strong>，简单而言就是两行以上不相干的代码在执行的时候有可能先执行的不是第一条，不见得是从上到下顺序执行，执行顺序会被优化。</li></ul><p>从源码到最终执行示例图</p><p><img src="https://raw.githubusercontent.com/GeorgeChan95/blogimg/master/img/2024/09/23/20240923-171944.png" alt="原码编译到执行"></p><ul><li><p>单线程环境里面确保程序最终执行结果和代码顺序执行的结果一致。处理器在进行重排序时必须要考虑指令之间的数据依赖性。</p></li><li><p>多线程环境中线程交替执行,由于编译器优化重排的存在，两个线程中使用的变量能否保证一致性是无法确定的,结果无法预测</p></li></ul><h1 id="三、JMM规范下，多线程对变量的读写过程"><a href="#三、JMM规范下，多线程对变量的读写过程" class="headerlink" title="三、JMM规范下，多线程对变量的读写过程"></a>三、JMM规范下，多线程对变量的读写过程</h1><p><strong>读取过程</strong></p><p>由于JVM运行程序的实体是线程，而每个线程创建时JVM都会为其创建一个工作内存(有些地方称为栈空间)，工作内存是每个线程的私有数据区域，而Java内存模型中规定所有变量都存储在<strong>主内存</strong>，主内存是共享内存区域，所有线程都可以访问，但<strong>线程对变量的操作(读取赋值等)必须在工作内存中进行，首先要将变量从主内存拷贝到的线程自己的工作内存空间，然后对变量进行操作，操作完成后再将变量写回主内存</strong>，不能直接操作主内存中的变量，各个线程中的工作内存中存储着主内存中的变量副本拷贝，因此不同的线程间无法访问对方的工作内存，线程间的通信(传值)必须通过主内存来完成，其简要访问过程如下图:</p><p><img src="https://raw.githubusercontent.com/GeorgeChan95/blogimg/master/img/2024/09/23/20240923-172630.png" alt="多线程操作主内存变量"></p><p><strong>JMM定义了线程和主内存之间的抽象关系：</strong></p><ul><li>线程之间的共享变量存储在主内存中（从硬件角度讲就是内存条）</li><li>每个线程都有一个自己的本地工作内存，本地工作内存中存储了该线程用来读写共享变量的副本（从硬件角度来说就是CPU的缓存）</li></ul><p><strong>总结</strong></p><ul><li>我们定义的所有共享变量都储存在<strong>物理主内存中</strong></li><li>每个线程都有自己独立的工作内存，里面保证该线程使用到的共享变量的副本（主内存中该变量的一份拷贝）</li><li>线程对共享变量所有的操作都必须先在线程自己的工作内存中进行后写回主内存，不能直接从主内存在读写（不能越级）</li><li>不同线程之间也无法直接访问其他线程的工作内存中的变量，线程间变量值的传递需要通过主内存来进行（同级不能互相访问）。</li></ul><h1 id="四、JMM规范下，多线程先行发生原则之happens-before"><a href="#四、JMM规范下，多线程先行发生原则之happens-before" class="headerlink" title="四、JMM规范下，多线程先行发生原则之happens-before"></a>四、JMM规范下，多线程先行发生原则之happens-before</h1><p>在JVM中，如果一个操作执行的结果需要对另一个操作可见或者代码重排序，那么这两个操作之间必须存在 happens-before（先行发生）原则，逻辑上的先后关系。</p><h2 id="1-x-、y案例说明"><a href="#1-x-、y案例说明" class="headerlink" title="1. x 、y案例说明"></a>1. x 、y案例说明</h2><ul><li>x&#x3D;5;线程A执行</li><li>y&#x3D;x;线程B执行</li><li>问：y一定等于5吗？</li></ul><p><strong>答案：不一定</strong></p><p>如果线程A的操作（x&#x3D; 5）happens-before(先行发生)线程B的操作（y &#x3D; x）,那么可以确定线程B执行后y &#x3D; 5 一定成立;</p><p>如果他们不存在happens-before原则，那么y &#x3D; 5 不一定成立。</p><p><strong>这就是happens-before原则的为例———–&gt;包含可见性和有序性的约束</strong></p><h2 id="2-先行并发原则说明"><a href="#2-先行并发原则说明" class="headerlink" title="2. 先行并发原则说明"></a>2. 先行并发原则说明</h2><p>如果Java内存模型中所有的有序性都仅靠 <code>volatile</code> 和 <code>synchronized</code> 来完成，那么有很多操作都将变得非常罗嗦，但是我们在编写Java并发代码的时候并没有察觉到这一点。</p><p>我们没有时时、处处、次次，添加volatile和synchronized来完成程序，这是因为Java语言中JMM原则下，有一个“先行发生”（happens-before）的原则限制和规矩，给你理好了规矩！</p><p>这个原则非常重要：它是判断数据是否存在竞争，线程是否安全的非常有用的手段。依赖这个原则，我们可以通过几条简单规则解决并发环境下两个操作之间是否可能存在冲突的所有问题，而不需要陷入Java内存模型晦涩难懂的底层编译原理之中。</p><h2 id="3-happens-before总原则"><a href="#3-happens-before总原则" class="headerlink" title="3. happens-before总原则"></a>3. happens-before总原则</h2><ul><li>如果一个操作happens-before另一个操作，那么第一个操作的执行结果将对第二个操作可见，而且第一个操作的执行顺序排在第二个操作之前</li><li>如果两个操作之间存在happens-before关系，并不意味着一定要按照happens-before原则制定的顺序来执行。如果重排之后的执行结果与按照happens-before关系来执行的结果一致，那么这种重排序并不非法。</li></ul><h2 id="4-happens-before之8条规则"><a href="#4-happens-before之8条规则" class="headerlink" title="4. happens-before之8条规则"></a>4. happens-before之8条规则</h2><p>从JDK 5开始，Java使用新的JSR-133内存模型，提供了 happens-before 原则来辅助保证程序执行的原子性、可见性以及有序性的问题，它是判断数据是否存在竞争、线程是否安全的依据，happens-before 原则内容如下：</p><ol><li><p>次序规则：一个线程内，按照代码的顺序，写在前面的操作先行发生于写在后面的操作，也就是说前一个操作的结果可以被后续的操作获取（保证语义串行性，按照代码顺序执行）。比如前一个操作把变量x赋值为1，那后面一个操作肯定能知道x已经变成了1</p></li><li><p>锁定规则：一个 <code>unLock</code> 操作先行发生于后面对同一个锁的<code>lock</code>操作（后面指时间上的先后）</p><p>​解释：A线程的 unlock 操作，先行发生于 B线程的 lock 操作。</p></li><li><p>volatile变量规则：对一个volatile变量的写操作先行发生于后面对这个变量的读操作，前面的写对后面的读是可见的，这里的后面同样指时间上的先后</p></li><li><p>传递规则：如果操作A先行发生于操作B，而操作B又先行发生于操作C，则可以得出操作A先行发生于操作C。</p></li><li><p>线程启动规则（Thread start Rule）：Thread对象的start()方法先行发生于此线程的每一个动作</p></li><li><p>线程中断规则（Thread Interruption Rule）：</p><ol><li>对线程interrupt()方法的调用先行发生于被中断线程的代码检测到中断事件的发生</li><li>可以通过Thread.interrupted()检测到是否发生中断</li><li>也就是说你要先调用interrupt()方法设置过中断标志位，我才能检测到中断发生</li></ol><p>解释：这里其实都是重排序问题，如果没有的此规则就变成了你写的前面设置终止状态，判断结果理应是true，但指令重排序有可能给你改成先判断结果就是false了</p></li><li><p>线程终止规则（Thread Termination Rule）：线程中的所有操作都优先发生于对此线程的终止检测，我们可以通过isAlive()等手段检测线程是否已经终止执行。</p></li><li><p>对象终结规则（Finalizer Rule）：一个对象的初始化完成（构造函数执行结束）先行发生于它的finalize(）方法的开始——-&gt;对象没有完成初始化之前，是不能调用finalized()方法的</p></li></ol><h2 id="5-happens-before-总结"><a href="#5-happens-before-总结" class="headerlink" title="5. happens-before 总结"></a>5. happens-before 总结</h2><ul><li>在Java语言里面，Happens-before 的语义本质上是一种可见性</li><li>A happens-before B ,意味着A发生过的事情对B而言是可见的，无论A事件和B事件是否发生在同一线程里</li><li>JVM的设计分为两部分：<ul><li>一部分是面向我们程序员提供的，也就是happens-before规则，它通俗易懂的向我们程序员阐述了一个强内存模型，我们只要理解happens-before规则，就可以编写并发安全的程序了</li><li>另一部分是针对JVM实现的，为了尽可能少的对编译器和处理器做约束从而提升性能，JMM在不影响程序执行结果的前提下对其不做要求，即允许优化重排序，我们只要关注前者就好了，也就是理解happens-before规则即可，其他繁杂的内容由JMM规范结合操作系统给我们搞定，我们只写好代码即可。</li></ul></li></ul><h2 id="6-案例说明"><a href="#6-案例说明" class="headerlink" title="6. 案例说明"></a>6. 案例说明</h2><pre><code class="highlight java"><span class="keyword">private</span> <span class="type">int</span> <span class="variable">value</span> <span class="operator">=</span><span class="number">0</span>;<span class="keyword">public</span> <span class="type">int</span> <span class="title function_">getValue</span><span class="params">()</span>&#123;    <span class="keyword">return</span> value;&#125;<span class="keyword">public</span> <span class="type">int</span> <span class="title function_">setValue</span><span class="params">()</span>&#123;    <span class="keyword">return</span> ++value;&#125;</code></pre><p>问题描述：假设存在线程A和B，线程A先（时间上的先后）调用了setValue()方法，然后线程B调用了同一个对象的getValue()方法，那么线程B收到的返回值是什么？</p><p><strong>答案：不一定</strong></p><p><strong>分析如下：</strong></p><p>分析happens-before规则（规则5，6，7，8可以忽略，和代码无关）</p><ul><li>由于两个方法由不同线程调用，不满足一个线程的条件，不满足程序次序规则</li><li>两个方法都没有用锁，不满足锁定规则</li><li>变量没有使用volatile修饰，所以不满足volatile变量规则</li><li>传递规则肯定不满足</li></ul><p>综上：无法通过happens-before原则推导出线程A happens-before 线程B，虽然可以确定时间上线程A优于线程B，但就是无法确定线程B获得的结果是什么，所以这段代码不是线程安全的</p><p>注意：如果两个操作的执行次序无法从happens-before原则推导出来，那么就不能保证他们的有序性，虚拟机可以随意对他们进行重排序</p><p><strong>解决方案：</strong></p><ul><li><p>方案一：</p><ul><li><p>把getter&#x2F;setter方法都定义为synchronized方法——-&gt;<strong>不好，重量锁，并发性下降</strong></p><pre><code class="highlight java"><span class="keyword">private</span> <span class="type">int</span> <span class="variable">value</span> <span class="operator">=</span><span class="number">0</span>;<span class="keyword">public</span> <span class="keyword">synchronized</span> <span class="type">int</span> <span class="title function_">getValue</span><span class="params">()</span>&#123;    <span class="keyword">return</span> value;&#125;<span class="keyword">public</span> <span class="keyword">synchronized</span> <span class="type">int</span> <span class="title function_">setValue</span><span class="params">()</span>&#123;    <span class="keyword">return</span> ++value;&#125;</code></pre></li><li><p>把 value 定义为 volatile 变量，由于setter方法对value的修改不依赖value的原值，满足volatile关键字使用场景</p><pre><code class="highlight java"><span class="comment">/**</span><span class="comment">* 利用volatile保证读取操作的可见性，</span><span class="comment">* 利用synchronized保证符合操作的原子性结合使用锁和volatile变量来减少同步的开销</span><span class="comment">*/</span><span class="keyword">private</span> <span class="keyword">volatile</span> <span class="type">int</span> <span class="variable">value</span> <span class="operator">=</span><span class="number">0</span>;<span class="keyword">public</span> <span class="type">int</span> <span class="title function_">getValue</span><span class="params">()</span>&#123;    <span class="keyword">return</span> value;&#125;<span class="keyword">public</span> <span class="keyword">synchronized</span> <span class="type">int</span> <span class="title function_">setValue</span><span class="params">()</span>&#123;    <span class="keyword">return</span> ++value;&#125;</code></pre></li></ul></li></ul>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;一、计算机硬件存储体系&quot;&gt;&lt;a href=&quot;#一、计算机硬件存储体系&quot; class=&quot;headerlink&quot; title=&quot;一、计算机硬件存储体系&quot;&gt;&lt;/a&gt;一、计算机硬件存储体系&lt;/h1&gt;&lt;p&gt; 计算机存储结构，从本地磁盘 到 主内存 到 CPU缓存，也就是从硬</summary>
      
    
    
    
    <category term="JUC" scheme="https://georgechan95.github.io/categories/JUC/"/>
    
    
    <category term="java" scheme="https://georgechan95.github.io/tags/java/"/>
    
    <category term="juc" scheme="https://georgechan95.github.io/tags/juc/"/>
    
  </entry>
  
  <entry>
    <title>04-JUC进阶-LockSupport与线程中断</title>
    <link href="https://georgechan95.github.io/blog/19653fb9.html"/>
    <id>https://georgechan95.github.io/blog/19653fb9.html</id>
    <published>2024-09-23T12:51:50.000Z</published>
    <updated>2024-09-23T08:11:09.507Z</updated>
    
    <content type="html"><![CDATA[<h1 id="一、线程中断机制"><a href="#一、线程中断机制" class="headerlink" title="一、线程中断机制"></a>一、线程中断机制</h1><h2 id="1-什么是中断机制-？"><a href="#1-什么是中断机制-？" class="headerlink" title="1. 什么是中断机制 ？"></a>1. 什么是中断机制 ？</h2><p>首先一个线程不应该由其他线程来强制中断或停止，而是应该由线程自己自行停止。所以，<code>Thread.stop</code> , <code>Thread.suspend</code> , <code>Thread.resume</code> 都已经被废弃了。</p><p>其次在Java中没有办法立即停止一条线程，然而停止线程却显得尤为重要，如取消一个耗时操作。因此，Java提供了一种用于停止线程的机制——中断。</p><p><strong>中断只是一种协作机制，Java没有给中断增加任何语法，中断的过程完全需要程序员自己实现。</strong></p><ul><li>若要中断一个线程，你需要手动调用该线程的interrupt方法，<strong>该方法也仅仅是将线程对象的中断标识设成true</strong>；</li><li>接着你需要自己写代码不断地检测当前线程的标识位，如果为true，表示别的线程要求这条线程中断，</li><li>此时究竟该做什么需要你自己写代码实现。</li><li>每个线程对象中都有一个标识，用于表示线程是否被中断；该标识位为true表示中断，为false表示未中断；</li><li>通过调用线程对象的 <code>interrupt</code> 方法将该线程的标识位设为 true ；可以在别的线程中调用，也可以在自己的线程中调用。</li></ul><h2 id="2-中断的相关API方法"><a href="#2-中断的相关API方法" class="headerlink" title="2. 中断的相关API方法"></a>2. 中断的相关API方法</h2><p><img src="https://raw.githubusercontent.com/GeorgeChan95/blogimg/master/img/2024/09/23/20240923-094444.png" alt="线程中断API"></p><table><thead><tr><th>API</th><th>描述</th></tr></thead><tbody><tr><td>public void interrupt()</td><td>实例方法，<br/>实例方法 <code>interrupt()</code> 仅仅是设置线程的中断状态为true，不会停止线程</td></tr><tr><td><strong>public static boolean interrupted()</strong></td><td><strong>静态方法</strong>，<code>Thread.interrupted();</code>  <br/>判断线程是否被中断，并清除当前中断状态<br/>这个方法做了两件事：<br/>1 返回当前线程的中断状态<br/>2 将当前线程的中断状态设为false<br/> <br/>这个方法有点不好理解，因为连续调用两次的结果可能不一样。</td></tr><tr><td>public boolean isInterrupted()</td><td>实例方法，<br/>判断当前线程是否被中断（通过检查中断标志位）</td></tr></tbody></table><h3 id="2-1-通过一个-volatile-变量实现"><a href="#2-1-通过一个-volatile-变量实现" class="headerlink" title="2.1 通过一个 volatile 变量实现"></a>2.1 通过一个 volatile 变量实现</h3><ul><li>volatile保证了可见性，t2修改了标志位后能马上被t1看到</li></ul><pre><code class="highlight java"><span class="comment">/**</span><span class="comment"> * volatile变量实现线程中断</span><span class="comment"> *</span><span class="comment"> * <span class="doctag">@throws</span> InterruptedException</span><span class="comment"> */</span><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">volatileStopThread</span><span class="params">()</span> <span class="keyword">throws</span> InterruptedException &#123;    <span class="keyword">new</span> <span class="title class_">Thread</span>(() -&gt; &#123;        <span class="keyword">while</span> (!isStop) &#123;            System.out.println(<span class="string">&quot;------- t1 run&quot;</span>);        &#125;        System.out.println(<span class="string">&quot;===== t1 is stop =====&quot;</span>);    &#125;, <span class="string">&quot;t1&quot;</span>).start();    <span class="comment">// 让线程t1运行50毫秒后，中断线程运行</span>    Thread.sleep(<span class="number">10</span>);    <span class="keyword">new</span> <span class="title class_">Thread</span>(() -&gt; &#123;        isStop = <span class="literal">true</span>;        System.out.println(<span class="string">&quot;------- t2 stop: &quot;</span> + isStop);    &#125;, <span class="string">&quot;t2&quot;</span>).start();&#125;</code></pre><h3 id="2-2-通过-AtomicBoolean（原子布尔型）"><a href="#2-2-通过-AtomicBoolean（原子布尔型）" class="headerlink" title="2.2 通过 AtomicBoolean（原子布尔型）"></a>2.2 通过 AtomicBoolean（原子布尔型）</h3><pre><code class="highlight java"><span class="comment">/**</span><span class="comment"> * 通过AtomicBoolean变量实现线程中断</span><span class="comment"> *</span><span class="comment"> * <span class="doctag">@throws</span> InterruptedException</span><span class="comment"> */</span><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">atomicBooleanStopThread</span><span class="params">()</span> <span class="keyword">throws</span> InterruptedException &#123;    <span class="keyword">new</span> <span class="title class_">Thread</span>(() -&gt; &#123;        <span class="keyword">while</span> (!flag.get()) &#123;            System.out.println(<span class="string">&quot;------- t1 run&quot;</span>);        &#125;        System.out.println(<span class="string">&quot;===== t1 is stop =====&quot;</span>);    &#125;, <span class="string">&quot;t1&quot;</span>).start();    <span class="comment">// 让线程t1运行50毫秒后，中断线程运行</span>    Thread.sleep(<span class="number">50</span>);    <span class="keyword">new</span> <span class="title class_">Thread</span>(() -&gt; &#123;        flag.set(<span class="literal">true</span>);        System.out.println(<span class="string">&quot;------- t2 stop: &quot;</span> + flag.get());    &#125;, <span class="string">&quot;t2&quot;</span>).start();&#125;</code></pre><h3 id="2-3-通过Thread类自带的中断api方法实现"><a href="#2-3-通过Thread类自带的中断api方法实现" class="headerlink" title="2.3 通过Thread类自带的中断api方法实现"></a>2.3 通过Thread类自带的中断api方法实现</h3><pre><code class="highlight java"><span class="comment">/**</span><span class="comment"> * 通过Thread类自带的中断api方法实现</span><span class="comment"> *</span><span class="comment"> * <span class="doctag">@throws</span> InterruptedException</span><span class="comment"> */</span><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">threadApiInterruptThread</span><span class="params">()</span> <span class="keyword">throws</span> InterruptedException &#123;    <span class="type">Thread</span> <span class="variable">t1</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Thread</span>(() -&gt; &#123;        <span class="keyword">while</span> (!Thread.currentThread().isInterrupted()) &#123;            System.out.println(<span class="string">&quot;------- t1 run&quot;</span>);        &#125;        System.out.println(<span class="string">&quot;===== t1 is stop =====&quot;</span>);    &#125;, <span class="string">&quot;t1&quot;</span>);    t1.start();    <span class="comment">// 让线程t1运行50毫秒后，中断线程运行</span>    Thread.sleep(<span class="number">50</span>);    <span class="keyword">new</span> <span class="title class_">Thread</span>(() -&gt; &#123;        <span class="comment">// t1线程中断标识设置为true，等待县城自我中断</span>        t1.interrupt();        System.out.println(<span class="string">&quot;------- t2 stop: &quot;</span> + <span class="literal">true</span>);    &#125;, <span class="string">&quot;t2&quot;</span>).start();&#125;</code></pre><h2 id="3-中断API源码分析"><a href="#3-中断API源码分析" class="headerlink" title="3. 中断API源码分析"></a>3. 中断API源码分析</h2><ul><li><strong>实例方法interrupt()，没有返回值</strong></li></ul><pre><code class="highlight java"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">interrupt</span><span class="params">()</span> &#123;    <span class="keyword">if</span> (<span class="built_in">this</span> != Thread.currentThread())        checkAccess();    <span class="keyword">synchronized</span> (blockerLock) &#123;        <span class="type">Interruptible</span> <span class="variable">b</span> <span class="operator">=</span> blocker;        <span class="keyword">if</span> (b != <span class="literal">null</span>) &#123;            interrupt0();           <span class="comment">// Just to set the interrupt flag</span>            b.interrupt(<span class="built_in">this</span>);            <span class="keyword">return</span>;        &#125;    &#125;    interrupt0();&#125;<span class="comment">//Thread.java</span><span class="comment">/* Some private helper methods */</span><span class="keyword">private</span> <span class="keyword">native</span> <span class="keyword">void</span> <span class="title function_">setPriority0</span><span class="params">(<span class="type">int</span> newPriority)</span>;<span class="keyword">private</span> <span class="keyword">native</span> <span class="keyword">void</span> <span class="title function_">stop0</span><span class="params">(Object o)</span>;<span class="keyword">private</span> <span class="keyword">native</span> <span class="keyword">void</span> <span class="title function_">suspend0</span><span class="params">()</span>;<span class="keyword">private</span> <span class="keyword">native</span> <span class="keyword">void</span> <span class="title function_">resume0</span><span class="params">()</span>;<span class="keyword">private</span> <span class="keyword">native</span> <span class="keyword">void</span> <span class="title function_">interrupt0</span><span class="params">()</span>;  <span class="comment">//---------------------------调用了c底层原生方法</span><span class="keyword">private</span> <span class="keyword">native</span> <span class="keyword">void</span> <span class="title function_">setNativeName</span><span class="params">(String name)</span>;</code></pre><ul><li><strong>实例方法 isInterrupted，返回布尔值</strong></li></ul><pre><code class="highlight java"><span class="comment">/**</span><span class="comment"> * Tests whether this thread has been interrupted.  The &lt;i&gt;interrupted</span><span class="comment"> * status&lt;/i&gt; of the thread is unaffected by this method.</span><span class="comment"> *</span><span class="comment"> * &lt;p&gt;A thread interruption ignored because a thread was not alive</span><span class="comment"> * at the time of the interrupt will be reflected by this method</span><span class="comment"> * returning false.</span><span class="comment"> *</span><span class="comment"> * <span class="doctag">@return</span>  &lt;code&gt;true&lt;/code&gt; if this thread has been interrupted;</span><span class="comment"> *          &lt;code&gt;false&lt;/code&gt; otherwise.</span><span class="comment"> * <span class="doctag">@see</span>     #interrupted()</span><span class="comment"> * <span class="doctag">@revised</span> 6.0</span><span class="comment"> */</span><span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">isInterrupted</span><span class="params">()</span> &#123;    <span class="keyword">return</span> isInterrupted(<span class="literal">false</span>);&#125;<span class="comment">//Thread.java</span><span class="keyword">private</span> <span class="keyword">native</span> <span class="type">boolean</span> <span class="title function_">isInterrupted</span><span class="params">(<span class="type">boolean</span> ClearInterrupted)</span>;<span class="comment">//也调用了c底层</span></code></pre><p><strong>中断API相关说明：</strong></p><p>具体来说，当对一个线程，调用 interrupt() 时：</p><ul><li>如果线程处于<strong>正常活动状态</strong>，那么会将该线程的中断标志设置为 true，仅此而已。被设置中断标志的线程将继续正常运行，不受影响。所以， interrupt() 并不能真正的中断线程，需要被调用的线程自己进行配合才行（即：代码自行实现中断逻辑）。</li><li>如果线程处于被阻塞状态（例如处于sleep, wait, join 等状态），在别的线程中调用当前线程对象的interrupt方法，那么线程将立即退出被阻塞状态（中断状态将被清除），并抛出一个InterruptedException异常。（ 关于这一点，<code>interrupt()</code> 方法的注释有明确的说明，）</li><li>中断<strong>不活动的线程</strong>不会产生任何影响，具体看下面案例</li></ul><h3 id="3-1-当前线程的中断标识为true，是不是线程就立刻停止？"><a href="#3-1-当前线程的中断标识为true，是不是线程就立刻停止？" class="headerlink" title="3.1 当前线程的中断标识为true，是不是线程就立刻停止？"></a>3.1 <strong>当前线程的中断标识为true，是不是线程就立刻停止？</strong></h3><p>答案：否， 仅仅设置了一个中断状态为true。</p><pre><code class="highlight java"><span class="comment">/**</span><span class="comment"> * 中断为true后，并不是立刻stop程序</span><span class="comment"> */</span><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">m4</span><span class="params">()</span> &#123;    <span class="comment">//中断为true后，并不是立刻stop程序</span>    <span class="type">Thread</span> <span class="variable">t1</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Thread</span>(() -&gt; &#123;        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">1</span>; i &lt;= <span class="number">800</span>; i++) &#123;            System.out.println(<span class="string">&quot;------i: &quot;</span> + i);        &#125;        System.out.println(<span class="string">&quot;t1.interrupt()调用之后02： &quot;</span> + Thread.currentThread().isInterrupted());    &#125;, <span class="string">&quot;t1&quot;</span>);    t1.start();    System.out.println(<span class="string">&quot;t1.interrupt()调用之前,t1线程的中断标识默认值： &quot;</span> + t1.isInterrupted());    <span class="keyword">try</span> &#123;        TimeUnit.MILLISECONDS.sleep(<span class="number">3</span>);    &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;        e.printStackTrace();    &#125;    <span class="comment">//实例方法interrupt()仅仅是设置线程的中断状态位设置为true，不会停止线程</span>    t1.interrupt();    <span class="comment">//活动状态,t1线程还在执行中</span>    System.out.println(<span class="string">&quot;t1.interrupt()调用之后01： &quot;</span> + t1.isInterrupted());    <span class="keyword">try</span> &#123;        TimeUnit.MILLISECONDS.sleep(<span class="number">3000</span>);    &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;        e.printStackTrace();    &#125;    <span class="comment">//非活动状态,t1线程不在执行中，已经结束执行了, 此时调用 isInterrupted() 方法不起作用，中断状态标识位返回：false</span>    System.out.println(<span class="string">&quot;t1.interrupt()调用之后03： &quot;</span> + t1.isInterrupted());&#125;</code></pre><p>运行结果：</p><pre><code class="highlight shell">t1.interrupt()调用之前,t1线程的中断标识默认值： false------i: 1------i: 2------i: 3......------i: 645t1.interrupt()调用之后01： true // ------此处中断标志位设置为了true,但是t1仍然在运行------i: 646......------i: 798------i: 799------i: 800t1.interrupt()调用之后02： truet1.interrupt()调用之后03： false //中断不活动的线程不会产生任何影响，线程结束后应该是自动变为了false</code></pre><h3 id="3-2-中断异常代码案例："><a href="#3-2-中断异常代码案例：" class="headerlink" title="3.2 中断异常代码案例："></a>3.2 <strong>中断异常代码案例：</strong></h3><p>当线程处于 <code>wait</code> 、<code>join</code> 、<code>sleep</code> 时，此时调用 <code>interrupt()</code> 方法，会触发 <strong>中断异常</strong>， 且会导致程序无限循环. 因为 InterruptedException，将会把中断状态清除。</p><pre><code class="highlight java"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">m5</span><span class="params">()</span> &#123;    <span class="type">Thread</span> <span class="variable">t1</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Thread</span>(() -&gt; &#123;        <span class="keyword">while</span> (<span class="literal">true</span>) &#123;            <span class="keyword">if</span> (Thread.currentThread().isInterrupted()) &#123;                System.out.println(<span class="string">&quot;-----isInterrupted() = true，程序结束。&quot;</span>);                <span class="keyword">break</span>;            &#125;            <span class="keyword">try</span> &#123;                Thread.sleep(<span class="number">500</span>);            &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;<span class="comment">//                    Thread.currentThread().interrupt(); //线程的中断标志位为false,无法停下，需要再次掉interrupt()设置true</span>                e.printStackTrace();            &#125;            System.out.println(<span class="string">&quot;------hello Interrupt&quot;</span>);        &#125;    &#125;, <span class="string">&quot;t1&quot;</span>);    t1.start();    <span class="keyword">try</span> &#123;        TimeUnit.SECONDS.sleep(<span class="number">3</span>);    &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;        e.printStackTrace();    &#125;    <span class="keyword">new</span> <span class="title class_">Thread</span>(() -&gt; &#123;        t1.interrupt();<span class="comment">//修改t1线程的中断标志位为true</span>    &#125;, <span class="string">&quot;t2&quot;</span>).start();&#125;</code></pre><p><strong>运行结果：</strong></p><p>当调用 t1.interrupt(); 时，代码发生了异常，但 t1 依然在运行，没有结束掉</p><pre><code class="highlight shell">------hello Interrupt------hello Interruptjava.lang.InterruptedException: sleep interruptedat java.lang.Thread.sleep(Native Method)at com.atguigu.juc.interrupt.InterruptDemo.lambda$m5$0(InterruptDemo.java:34)at java.lang.Thread.run(Thread.java:748)------hello Interrupt------hello Interrupt------hello Interrupt......</code></pre><p><strong>解决方法：</strong></p><p>在 catch (InterruptedException e)  处添加 <code>Thread.currentThread().interrupt();</code> 发生异常后，再次调用代码执行中断，程序发生异常后依然可以正常结束；</p><pre><code class="highlight shell">------hello Interrupt------hello Interrupt------hello Interrupt------hello Interrupt------hello Interruptjava.lang.InterruptedException: sleep interruptedat java.lang.Thread.sleep(Native Method)at com.atguigu.juc.interrupt.InterruptDemo.lambda$m5$0(InterruptDemo.java:34)at java.lang.Thread.run(Thread.java:748)------hello Interrupt-----isInterrupted() = true，程序结束。</code></pre><h3 id="3-3-对静态方法-Thread-interrupted-的理解"><a href="#3-3-对静态方法-Thread-interrupted-的理解" class="headerlink" title="3.3 对静态方法 Thread.interrupted() 的理解"></a>3.3 对静态方法 Thread.interrupted() 的理解</h3><p><code>public static boolean interrupted()</code> </p><ul><li><p>静态方法，Thread.interrupted(); 判断线程是否被中断，并清除当前中断状态这个方法做了两件事：</p><ul><li>1 返回当前线程的中断状态</li><li>2 将当前线程的中断状态设为false</li></ul><p>注意：此方法连续调用两次的结果可能不一样</p></li></ul><pre><code class="highlight java"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;    System.out.println(Thread.currentThread().getName()+<span class="string">&quot;---&quot;</span>+Thread.interrupted()); <span class="comment">// main---false</span>    System.out.println(Thread.currentThread().getName()+<span class="string">&quot;---&quot;</span>+Thread.interrupted()); <span class="comment">// main---false</span>    System.out.println(<span class="string">&quot;111111&quot;</span>);    Thread.currentThread().interrupt();<span class="comment">///----false---&gt; true</span>    System.out.println(<span class="string">&quot;222222&quot;</span>);    System.out.println(Thread.currentThread().getName()+<span class="string">&quot;---&quot;</span>+Thread.interrupted()); <span class="comment">// main---true</span>    System.out.println(Thread.currentThread().getName()+<span class="string">&quot;---&quot;</span>+Thread.interrupted()); <span class="comment">// main---false</span>&#125;</code></pre><p>运行结果：</p><pre><code class="highlight shell">main---falsemain---false111111222222main---truemain---false</code></pre><p><strong>对比 <code>interrupted()</code> 与 <code>isInterrupted()</code> 源码</strong></p><pre><code class="highlight java"><span class="keyword">public</span> <span class="keyword">static</span> <span class="type">boolean</span> <span class="title function_">interrupted</span><span class="params">()</span> &#123;    <span class="keyword">return</span> currentThread().isInterrupted(<span class="literal">true</span>);&#125;<span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">isInterrupted</span><span class="params">()</span> &#123;    <span class="keyword">return</span> isInterrupted(<span class="literal">false</span>);&#125;<span class="comment">/**</span><span class="comment"> * Tests if some Thread has been interrupted.  The interrupted state</span><span class="comment"> * is reset or not based on the value of ClearInterrupted that is</span><span class="comment"> * passed.</span><span class="comment"> */</span><span class="keyword">private</span> <span class="keyword">native</span> <span class="type">boolean</span> <span class="title function_">isInterrupted</span><span class="params">(<span class="type">boolean</span> ClearInterrupted)</span>;</code></pre><p>他们在底层都调用了native方法 isInterrupted() , 只不过传入参数ClearInterrupted一个传参传了<code>true</code>，一个传了<code>false</code>。</p><ul><li>静态方法<code>interrupted() </code>中<code>true</code>表示清空当前中断状态。</li><li>实例方法<code>isInterrupted</code> 则不会。</li></ul><h2 id="4-总结"><a href="#4-总结" class="headerlink" title="4. 总结"></a>4. 总结</h2><p>线程中断相关的方法：</p><ul><li><p><code>interrupt()</code> 方法是一个实例方法</p><p>它通知目标线程中断，也就是设置目标线程的中断标志位为true，中断标志位表示当前线程已经被中断了。</p></li><li><p><code>isInterrupted()</code> 方法也是一个实例方法</p><p>它判断当前线程是否被中断（通过检查中断标志位）并获取中断标志</p></li><li><p>Thread类的静态方法 <code>interrupted()</code></p><p>返回当前线程的中断状态(boolean类型)且将当前线程的中断状态设为false，此方法调用之后会清除当前线程的中断标志位的状态（将中断标志置为false了），返回当前值并清零置false</p></li></ul><h1 id="二、LockSupport是什么"><a href="#二、LockSupport是什么" class="headerlink" title="二、LockSupport是什么"></a>二、LockSupport是什么</h1><p><code>LockSupport</code> 是用来创建锁和其他同步类的基本线程阻塞原语，其中 <code>park()</code> 和 <code>unpack()</code> 而作用分别是阻塞线程和解除阻塞线程.</p><p><img src="https://raw.githubusercontent.com/GeorgeChan95/blogimg/master/img/2024/09/23/20240923-133129.png" alt="LockSupport"></p><h1 id="三、线程等待唤醒机制"><a href="#三、线程等待唤醒机制" class="headerlink" title="三、线程等待唤醒机制"></a>三、线程等待唤醒机制</h1><h2 id="1-3种让线程等待和唤醒的方法"><a href="#1-3种让线程等待和唤醒的方法" class="headerlink" title="1. 3种让线程等待和唤醒的方法"></a>1. 3种让线程等待和唤醒的方法</h2><ul><li>使用Object中的<code>wait()</code>方法让线程等待，使用Object中的<code>notify()</code>方法唤醒线程</li><li>使用JUC包中<code>Condition</code>的<code>await()</code>方法让线程等待，使用<code>signal()</code>方法唤醒线程</li><li><code>LockSupport</code>类可以阻塞当前线程以及唤醒指定被阻塞的线程</li></ul><h2 id="2-Object类中的-wait-和-notify-方法实现线程等待和唤醒"><a href="#2-Object类中的-wait-和-notify-方法实现线程等待和唤醒" class="headerlink" title="2. Object类中的 wait 和 notify 方法实现线程等待和唤醒"></a>2. Object类中的 wait 和 notify 方法实现线程等待和唤醒</h2><p><strong>正确使用 wait &#x2F; notify</strong> </p><ul><li>wait 和 notify 都必须在 synchronized 覆盖的代码块中</li><li>必须先执行 wait， 再执行 notify</li></ul><pre><code class="highlight java"><span class="comment">/**</span><span class="comment"> * 正确使用 wait / notify 实现线程的等待和唤醒</span><span class="comment"> *</span><span class="comment"> * <span class="doctag">@throws</span> InterruptedException</span><span class="comment"> */</span><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">normal</span><span class="params">()</span> <span class="keyword">throws</span> InterruptedException &#123;    <span class="keyword">new</span> <span class="title class_">Thread</span>(() -&gt; &#123;        <span class="keyword">synchronized</span> (object) &#123;            <span class="keyword">try</span> &#123;                System.out.println(Thread.currentThread().getName() + <span class="string">&quot; ---- t1释放锁&quot;</span>);                <span class="comment">// wait方法会释放锁，给其他线程获取锁的机会</span>                object.wait();                System.out.println(Thread.currentThread().getName() + <span class="string">&quot; ---- t1重新获取锁&quot;</span>);            &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;                <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">RuntimeException</span>(e);            &#125;        &#125;    &#125;, <span class="string">&quot;t1&quot;</span>).start();    TimeUnit.SECONDS.sleep(<span class="number">1</span>);    <span class="keyword">new</span> <span class="title class_">Thread</span>(() -&gt; &#123;        <span class="keyword">synchronized</span> (object) &#123;            System.out.println(Thread.currentThread().getName() + <span class="string">&quot;---- notify&quot;</span>);            object.notify(); <span class="comment">// notify执行，让 t1 线程重新获取锁</span>        &#125;    &#125;, <span class="string">&quot;t2&quot;</span>).start();&#125;</code></pre><p>运行结果：</p><pre><code class="highlight shell">t1 ---- t1释放锁t2---- notifyt1 ---- t1重新获取锁</code></pre><p><strong>错误使用—： 去掉 synchronized</strong></p><pre><code class="highlight java"><span class="comment">/**</span><span class="comment"> * 错误方式—： 去掉 synchronized</span><span class="comment"> *</span><span class="comment"> * <span class="doctag">@throws</span> InterruptedException</span><span class="comment"> */</span><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">error1</span><span class="params">()</span> <span class="keyword">throws</span> InterruptedException &#123;    <span class="keyword">new</span> <span class="title class_">Thread</span>(() -&gt; &#123;        <span class="keyword">try</span> &#123;            System.out.println(Thread.currentThread().getName() + <span class="string">&quot; ---- t1释放锁&quot;</span>);            <span class="comment">// wait方法会释放锁，给其他线程获取锁的机会</span>            object.wait();            System.out.println(Thread.currentThread().getName() + <span class="string">&quot; ---- t1重新获取锁&quot;</span>);        &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;            <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">RuntimeException</span>(e);        &#125;    &#125;, <span class="string">&quot;t1&quot;</span>).start();    TimeUnit.SECONDS.sleep(<span class="number">1</span>);    <span class="keyword">new</span> <span class="title class_">Thread</span>(() -&gt; &#123;        System.out.println(Thread.currentThread().getName() + <span class="string">&quot;---- notify&quot;</span>);        object.notify(); <span class="comment">// notify执行，让 t1 线程重新获取锁</span>    &#125;, <span class="string">&quot;t2&quot;</span>).start();&#125;</code></pre><p>运行结果：</p><pre><code class="highlight shell">t1 ---- t1释放锁Exception in thread &quot;t1&quot; java.lang.IllegalMonitorStateExceptionat java.lang.Object.wait(Native Method)at java.lang.Object.wait(Object.java:502)at com.atguigu.juc.interrupt.SynchronizedDemo.lambda$error1$2(SynchronizedDemo.java:59)at java.lang.Thread.run(Thread.java:748)t2---- notifyException in thread &quot;t2&quot; java.lang.IllegalMonitorStateExceptionat java.lang.Object.notify(Native Method)at com.atguigu.juc.interrupt.SynchronizedDemo.lambda$error1$3(SynchronizedDemo.java:70)at java.lang.Thread.run(Thread.java:748)</code></pre><p><strong>错误使用二：把notify和wait的执行顺序对换</strong></p><pre><code class="highlight java"><span class="comment">/**</span><span class="comment"> * 错误使用二：把notify和wait的执行顺序对换</span><span class="comment"> *</span><span class="comment"> * <span class="doctag">@throws</span> InterruptedException</span><span class="comment"> */</span><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">error2</span><span class="params">()</span> <span class="keyword">throws</span> InterruptedException &#123;    <span class="keyword">new</span> <span class="title class_">Thread</span>(() -&gt; &#123;        <span class="keyword">try</span> &#123;            TimeUnit.SECONDS.sleep(<span class="number">2</span>); <span class="comment">// t1 线程先停2秒，等待t2线程执行结束</span>        &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;            <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">RuntimeException</span>(e);        &#125;        <span class="keyword">synchronized</span> (object) &#123;            <span class="keyword">try</span> &#123;                System.out.println(Thread.currentThread().getName() + <span class="string">&quot; ---- t1释放锁&quot;</span>);                <span class="comment">// wait方法会释放锁，给其他线程获取锁的机会</span>                object.wait();                System.out.println(Thread.currentThread().getName() + <span class="string">&quot; ---- t1重新获取锁&quot;</span>);            &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;                <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">RuntimeException</span>(e);            &#125;        &#125;    &#125;, <span class="string">&quot;t1&quot;</span>).start();    TimeUnit.SECONDS.sleep(<span class="number">1</span>);    <span class="keyword">new</span> <span class="title class_">Thread</span>(() -&gt; &#123;        <span class="keyword">synchronized</span> (object) &#123;            System.out.println(Thread.currentThread().getName() + <span class="string">&quot;---- notify&quot;</span>);            object.notify(); <span class="comment">// notify执行，让 t1 线程重新获取锁</span>        &#125;    &#125;, <span class="string">&quot;t2&quot;</span>).start();&#125;</code></pre><p>运行结果：</p><pre><code class="highlight shell">t2---- notifyt1 ---- t1释放锁</code></pre><p>现象：t1 线程没有结束掉。</p><p><strong>总结：</strong></p><ul><li>wait和notify方法必须要在<strong>同步</strong>块或者方法里面，且必须<strong>成对</strong>出现使用</li><li>先wait后notify才可以,<strong>顺序不能错</strong></li></ul><h2 id="3-Condition接口中的-await-后-signal-方法实现线程的等待和唤醒"><a href="#3-Condition接口中的-await-后-signal-方法实现线程的等待和唤醒" class="headerlink" title="3. Condition接口中的 await 后 signal 方法实现线程的等待和唤醒"></a>3. Condition接口中的 await 后 signal 方法实现线程的等待和唤醒</h2><p><strong>正确使用 await &#x2F; signal</strong> </p><ul><li>await 和 signal 都必须在 lock() &#x2F; unlock() 覆盖的代码块中</li><li>必须先执行 await ， 再执行 signal</li></ul><pre><code class="highlight java"><span class="comment">/**</span><span class="comment"> * 正确使用 Lock 的 await / signal 实现对线程的等待和唤醒</span><span class="comment"> * <span class="doctag">@throws</span> InterruptedException</span><span class="comment"> */</span><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">normal</span><span class="params">()</span> <span class="keyword">throws</span> InterruptedException &#123;    <span class="type">Lock</span> <span class="variable">lock</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ReentrantLock</span>();    <span class="type">Condition</span> <span class="variable">condition</span> <span class="operator">=</span> lock.newCondition();    <span class="keyword">new</span> <span class="title class_">Thread</span>(() -&gt; &#123;        <span class="keyword">try</span> &#123;            lock.lock();            System.out.println(Thread.currentThread().getName() + <span class="string">&quot;---- t1 释放锁&quot;</span>);            condition.await();            System.out.println(Thread.currentThread().getName() + <span class="string">&quot;---- t1 重新获取锁&quot;</span>);        &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;            <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">RuntimeException</span>(e);        &#125; <span class="keyword">finally</span> &#123;            lock.unlock();        &#125;    &#125;, <span class="string">&quot;t1&quot;</span>).start();    TimeUnit.SECONDS.sleep(<span class="number">1</span>);    <span class="keyword">new</span> <span class="title class_">Thread</span>(() -&gt; &#123;        <span class="keyword">try</span> &#123;            lock.lock();            System.out.println(Thread.currentThread().getName() + <span class="string">&quot;---- t2唤醒t1线程&quot;</span>);            condition.signal();        &#125; <span class="keyword">finally</span> &#123;            lock.unlock();        &#125;    &#125;, <span class="string">&quot;t2&quot;</span>).start();&#125;</code></pre><p>运行结果：</p><pre><code class="highlight shell">t1---- t1 释放锁t2---- t2唤醒t1线程t1---- t1 重新获取锁</code></pre><p><strong>错误使用一：await 和 signal 不在 lock() &#x2F; unlock() 覆盖的代码块中</strong></p><p>报错： java.lang.IllegalMonitorStateException</p><p><strong>错误使用二：必须先执行 signal ， 再执行 await</strong></p><p>线程没有正确的停止</p><h2 id="4-Object和Condition使用的限制条件"><a href="#4-Object和Condition使用的限制条件" class="headerlink" title="4. Object和Condition使用的限制条件"></a>4. Object和Condition使用的限制条件</h2><ul><li>线程先要获得并持有锁，必须在锁块(synchronized或lock)中</li><li>必须要先等待后唤醒，线程才能够被唤醒</li></ul><h2 id="5-LockSupport类中的park等待和unpark唤醒"><a href="#5-LockSupport类中的park等待和unpark唤醒" class="headerlink" title="5. LockSupport类中的park等待和unpark唤醒"></a>5. LockSupport类中的park等待和unpark唤醒</h2><h3 id="5-1-概念解析"><a href="#5-1-概念解析" class="headerlink" title="5.1 概念解析"></a>5.1 概念解析</h3><p>LockSupport 通过 <code>park()</code> 和 <code>unpark(thread)</code> 方法来实现阻塞和唤醒线程的操作</p><p><strong>官网解释</strong></p><p><img src="https://raw.githubusercontent.com/GeorgeChan95/blogimg/master/img/2024/09/23/20240923-145605.png" alt="LockSupport"></p><p>LockSupport是用来创建锁和其他同步类的基本线程阻塞原语。</p><ul><li>LockSupport类使用了一种名为Permit（许可）的概念来做到阻塞和唤醒线程的功能， 每个线程都有一个许可(permit)，</li><li>permit只有两个值1和零，默认是零。</li><li>可以把许可看成是一种(0,1)信号量（Semaphore），但与 Semaphore 不同的是，许可的累加上限是1。</li></ul><h3 id="5-2-主要方法"><a href="#5-2-主要方法" class="headerlink" title="5.2 主要方法"></a>5.2 主要方法</h3><h4 id="5-2-1-API"><a href="#5-2-1-API" class="headerlink" title="5.2.1 API"></a>5.2.1 API</h4><p><img src="https://raw.githubusercontent.com/GeorgeChan95/blogimg/master/img/2024/09/23/20240923-150101.png" alt="LockSupport API"></p><h4 id="5-2-2-阻塞"><a href="#5-2-2-阻塞" class="headerlink" title="5.2.2 阻塞"></a>5.2.2 阻塞</h4><ul><li><code>park() / park(Object blocker)</code></li><li>阻塞当前线程 &#x2F; 阻塞传入的具体线程</li></ul><p>调用<code>LockSupport.park()</code>时，发现它调用了<code>unsafe类</code>，并且默认传了一个0</p><pre><code class="highlight java"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">park</span><span class="params">()</span> &#123;    UNSAFE.park(<span class="literal">false</span>, <span class="number">0L</span>);&#125;</code></pre><ul><li>permit默认是零，所以一开始调用<code>park()</code>方法，当前线程就会阻塞，直到别的线程将当前线程的permit设置为1时，park方法会被唤醒，然后会将permit再次设置为零并返回。</li></ul><h4 id="5-2-3-唤醒"><a href="#5-2-3-唤醒" class="headerlink" title="5.2.3 唤醒"></a>5.2.3 唤醒</h4><p><code>unpark(Thread thread)</code> , 唤醒处于阻塞状态的指定线程</p><pre><code class="highlight java"><span class="comment">/**</span><span class="comment"> * Makes available the permit for the given thread, if it</span><span class="comment"> * was not already available.  If the thread was blocked on</span><span class="comment"> * &#123;<span class="doctag">@code</span> park&#125; then it will unblock.  Otherwise, its next call</span><span class="comment"> * to &#123;<span class="doctag">@code</span> park&#125; is guaranteed not to block. This operation</span><span class="comment"> * is not guaranteed to have any effect at all if the given</span><span class="comment"> * thread has not been started.</span><span class="comment"> *</span><span class="comment"> * <span class="doctag">@param</span> thread the thread to unpark, or &#123;<span class="doctag">@code</span> null&#125;, in which case</span><span class="comment"> *        this operation has no effect</span><span class="comment"> */</span><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">unpark</span><span class="params">(Thread thread)</span> &#123;    <span class="keyword">if</span> (thread != <span class="literal">null</span>)        UNSAFE.unpark(thread);&#125;</code></pre><p>调用<code>LockSupport.unpark();</code>时，也调用了<code>unsafe类</code></p><ul><li>调用unpark(thread)方法后，就会将 thread线程的许可 permit 设置成<strong>1</strong>(注意多次调用 unpark 方法，不会累加，permit 值还是1)会自动唤醒 thread 线程，即之前阻塞中的 LockSupport.park() 方法会立即返回。</li></ul><h3 id="5-3-LockSupport-代码示例"><a href="#5-3-LockSupport-代码示例" class="headerlink" title="5.3 LockSupport 代码示例"></a>5.3 LockSupport 代码示例</h3><p><strong>正常+无锁块要求</strong></p><pre><code class="highlight java"><span class="comment">/**</span><span class="comment"> * 正常使用，无锁块要求</span><span class="comment"> * 先阻塞后释放，可以实现线程的阻塞和唤醒</span><span class="comment"> *</span><span class="comment"> * <span class="doctag">@throws</span> InterruptedException</span><span class="comment"> */</span><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">m1</span><span class="params">()</span> <span class="keyword">throws</span> InterruptedException &#123;    <span class="type">Thread</span> <span class="variable">t1</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Thread</span>(() -&gt; &#123;        System.out.println(Thread.currentThread().getName() + <span class="string">&quot;---- come in&quot;</span>);        System.out.println(Thread.currentThread().getName() + <span class="string">&quot;---- park阻塞&quot;</span>);        LockSupport.park();        System.out.println(Thread.currentThread().getName() + <span class="string">&quot;---- 继续执行&quot;</span>);    &#125;, <span class="string">&quot;t1&quot;</span>);    t1.start();    TimeUnit.SECONDS.sleep(<span class="number">1</span>);    <span class="keyword">new</span> <span class="title class_">Thread</span>(() -&gt; &#123;        System.out.println(Thread.currentThread().getName() + <span class="string">&quot;---- come in&quot;</span>);        LockSupport.unpark(t1);    &#125;, <span class="string">&quot;t2&quot;</span>).start();&#125;</code></pre><p>运行结果：</p><pre><code class="highlight shell">t1---- come int1---- park阻塞t2---- come int1---- 继续执行</code></pre><p><strong>先唤醒后等待，LockSupport 同样支持</strong></p><pre><code class="highlight java"><span class="comment">/**</span><span class="comment"> * 先释放后阻塞，也可以实现线程的阻塞和唤醒</span><span class="comment"> *</span><span class="comment"> * <span class="doctag">@throws</span> InterruptedException</span><span class="comment"> */</span><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">m2</span><span class="params">()</span> <span class="keyword">throws</span> InterruptedException &#123;    <span class="type">Thread</span> <span class="variable">t1</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Thread</span>(() -&gt; &#123;        <span class="keyword">try</span> &#123;            TimeUnit.SECONDS.sleep(<span class="number">2</span>);        &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;            <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">RuntimeException</span>(e);        &#125;        System.out.println(Thread.currentThread().getName() + <span class="string">&quot;---- come in&quot;</span>);        System.out.println(Thread.currentThread().getName() + <span class="string">&quot;---- park阻塞&quot;</span>);        LockSupport.park();        System.out.println(Thread.currentThread().getName() + <span class="string">&quot;---- 继续执行&quot;</span>);    &#125;, <span class="string">&quot;t1&quot;</span>);    t1.start();    TimeUnit.SECONDS.sleep(<span class="number">1</span>);    <span class="keyword">new</span> <span class="title class_">Thread</span>(() -&gt; &#123;        System.out.println(Thread.currentThread().getName() + <span class="string">&quot;---- come in&quot;</span>);        System.out.println(Thread.currentThread().getName() + <span class="string">&quot;---- 给t1线程发通行证&quot;</span>);        LockSupport.unpark(t1);    &#125;, <span class="string">&quot;t2&quot;</span>).start();&#125;</code></pre><p>运行结果：</p><pre><code class="highlight shell">t2---- come int2---- 给t1线程发通行证t1---- come int1---- park阻塞t1---- 继续执行</code></pre><p>t1 sleep方法2秒后醒来，执行park无效，没有阻塞效果，这是因为 t2 先执行了<code>unpark(t1)</code>导致上面的park方法无效.</p><p>注意：park() &#x2F; unpark() 必须成对出现</p><p><strong>错误使用：连续执行 unpark(), 相当于只执行了一次 unpark()</strong> </p><pre><code class="highlight java"><span class="comment">/**</span><span class="comment"> * 连续执行 unpark(), 相当于只执行了一次 unpark()</span><span class="comment"> */</span><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">error1</span><span class="params">()</span> &#123;    <span class="type">Thread</span> <span class="variable">t1</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Thread</span>(() -&gt; &#123;        System.out.println(Thread.currentThread().getName() + <span class="string">&quot;\t&quot;</span> + <span class="string">&quot;---come in&quot;</span>);        System.out.println(Thread.currentThread().getName() + <span class="string">&quot;\t&quot;</span> + <span class="string">&quot;--- park1&quot;</span>);        LockSupport.park();        System.out.println(Thread.currentThread().getName() + <span class="string">&quot;\t&quot;</span> + <span class="string">&quot;--- park2&quot;</span>);        LockSupport.park();        System.out.println(Thread.currentThread().getName() + <span class="string">&quot;\t&quot;</span> + <span class="string">&quot;---被唤醒&quot;</span>);    &#125;, <span class="string">&quot;t1&quot;</span>);    t1.start();    <span class="keyword">new</span> <span class="title class_">Thread</span>(() -&gt; &#123;        LockSupport.unpark(t1);        LockSupport.unpark(t1);        System.out.println(Thread.currentThread().getName() + <span class="string">&quot;\t&quot;</span> + <span class="string">&quot;--- unpark1&quot;</span>);        System.out.println(Thread.currentThread().getName() + <span class="string">&quot;\t&quot;</span> + <span class="string">&quot;--- unpark2&quot;</span>);        <span class="keyword">try</span> &#123;            TimeUnit.SECONDS.sleep(<span class="number">3</span>);        &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;            e.printStackTrace();        &#125;    &#125;, <span class="string">&quot;t2&quot;</span>).start();&#125;</code></pre><p>运行结果：</p><pre><code class="highlight shell">t1---come int1--- park1t2--- unpark1t2--- unpark2t1--- park2</code></pre><p>t1 没有停止，继续阻塞，这是因为 t2 连续执行了两次 <code>unpark(t1)</code> ，但其实只发布了一个通行证，导致 t1 的第一次 park() 被唤醒了，但是第二次 park() 就没有通行证用来唤醒它，因此 t1 阻塞。</p><p><strong>总结：</strong></p><ul><li>Lock Support是用来创建锁和其他同步类的基本线程阻塞原语。</li><li>Lock Support是一个线程阻塞工具类， 所有的方法都是静态方法， 可以让线程在任意位置阻塞， 阻塞之后也有对应的唤醒方法。归根结底，Lock Support调用的Unsafe中的native代码。</li><li>Lock Support提供<code>park()</code> 和<code>unpark() </code>方法实现<strong>阻塞线程</strong>和<strong>解除线程阻塞</strong>的过程</li><li>Lock Support和每个使用它的线程都有一个许可(permit) 关联。</li><li>每个线程都有一个相关的 permit， permit 最多只有一个， 重复调用 <code>unpark()</code> 也不会积累凭证。</li></ul>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;一、线程中断机制&quot;&gt;&lt;a href=&quot;#一、线程中断机制&quot; class=&quot;headerlink&quot; title=&quot;一、线程中断机制&quot;&gt;&lt;/a&gt;一、线程中断机制&lt;/h1&gt;&lt;h2 id=&quot;1-什么是中断机制-？&quot;&gt;&lt;a href=&quot;#1-什么是中断机制-？&quot; class</summary>
      
    
    
    
    <category term="JUC" scheme="https://georgechan95.github.io/categories/JUC/"/>
    
    
    <category term="java" scheme="https://georgechan95.github.io/tags/java/"/>
    
    <category term="juc" scheme="https://georgechan95.github.io/tags/juc/"/>
    
  </entry>
  
  <entry>
    <title>03-JUC进阶-Java中的锁的解析</title>
    <link href="https://georgechan95.github.io/blog/219e52ea.html"/>
    <id>https://georgechan95.github.io/blog/219e52ea.html</id>
    <published>2024-09-21T06:15:20.000Z</published>
    <updated>2024-09-21T08:52:48.128Z</updated>
    
    <content type="html"><![CDATA[<h1 id="一、乐观锁和悲观锁"><a href="#一、乐观锁和悲观锁" class="headerlink" title="一、乐观锁和悲观锁"></a>一、乐观锁和悲观锁</h1><h2 id="1-悲观锁"><a href="#1-悲观锁" class="headerlink" title="1. 悲观锁"></a>1. 悲观锁</h2><p>悲观锁认为自己在使用数据的时候一定有别的线程来修改数据，因此在获取数据的时候会先加锁，确保数据不会被别的线程修改。</p><p><strong>悲观锁的实现方式</strong></p><ul><li><code>synchronized</code> 关键字</li><li><code>Lock</code> 的实现类都是悲观锁</li></ul><p><strong>适合写操作多的场景</strong>，先加锁可以保证写操作时数据正确。显示的锁定之后再操作同步资源。</p><pre><code class="highlight java"><span class="comment">//=============悲观锁的调用方式</span><span class="keyword">public</span> <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title function_">m1</span><span class="params">()</span>&#123;    <span class="comment">//加锁后的业务逻辑......</span>&#125;<span class="comment">// 保证多个线程使用的是同一个lock对象的前提下</span><span class="type">ReentrantLock</span> <span class="variable">lock</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ReentrantLock</span>();<span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">m2</span><span class="params">()</span> &#123;    lock.lock();    <span class="keyword">try</span> &#123;        <span class="comment">// 操作同步资源</span>    &#125;<span class="keyword">finally</span> &#123;        lock.unlock();    &#125;&#125;</code></pre><h2 id="2-乐观锁"><a href="#2-乐观锁" class="headerlink" title="2. 乐观锁"></a>2. 乐观锁</h2><p>乐观锁认为自己在使用数据时不会有别的线程修改数据，所以不会添加锁，只是在更新数据的时候去判断之前有没有别的线程更新了这个数据。如果这个数据没有被更新，当前线程将自己修改的数据成功写入。如果数据已经被其他线程更新，则根据不同的实现方式执行不同的操作</p><p><strong>乐观锁的实现方式</strong></p><ul><li>版本号机制Version。（只要有人提交了就会修改版本号，可以解决ABA问题）<ul><li><strong>ABA问题</strong>：再CAS中想读取一个值A，想把值A变为C，不能保证读取时的A就是赋值时的A，中间可能有个线程将A变为B再变为A。<ul><li>解决方法：Juc包提供了一个 <code>AtomicStampedReference</code>，原子更新带有版本号的引用类型，通过控制版本值的变化来解决ABA问题。</li></ul></li><li>最常采用的是CAS算法，Java原子类中的递增操作就通过CAS自旋实现的。</li></ul></li></ul><p><strong>适合读操作多的场景</strong>，不加锁的性能特点能够使其操作的性能大幅提升。</p><pre><code class="highlight java"><span class="comment">//=============乐观锁的调用方式</span><span class="comment">// 保证多个线程使用的是同一个AtomicInteger</span><span class="keyword">private</span> <span class="type">AtomicInteger</span> <span class="variable">atomicInteger</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">AtomicInteger</span>();atomicInteger.incrementAndGet();</code></pre><h1 id="二、synchronized-锁的8种情况"><a href="#二、synchronized-锁的8种情况" class="headerlink" title="二、synchronized 锁的8种情况"></a>二、synchronized 锁的8种情况</h1><p>下面通过一段代码，演示 synchronized 锁的 8 种情况</p><ol><li><p>标准访问，先打印短信还是邮件</p><pre><code class="highlight java"><span class="keyword">class</span> <span class="title class_">Phone</span> &#123;    <span class="keyword">public</span> <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title function_">sendSMS</span><span class="params">()</span> <span class="keyword">throws</span> Exception &#123;        System.out.println(<span class="string">&quot;------sendSMS&quot;</span>);    &#125;    <span class="keyword">public</span> <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title function_">sendEmail</span><span class="params">()</span> <span class="keyword">throws</span> Exception &#123;        System.out.println(<span class="string">&quot;------sendEmail&quot;</span>);    &#125;&#125;<span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Lock_8</span> &#123;    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception &#123;        <span class="type">Phone</span> <span class="variable">phone</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Phone</span>();        <span class="keyword">new</span> <span class="title class_">Thread</span>(() -&gt; &#123;            <span class="keyword">try</span> &#123;                phone.sendSMS();            &#125; <span class="keyword">catch</span> (Exception e) &#123;                e.printStackTrace();            &#125;        &#125;, <span class="string">&quot;AA&quot;</span>).start();        Thread.sleep(<span class="number">100</span>);        <span class="keyword">new</span> <span class="title class_">Thread</span>(() -&gt; &#123;            <span class="keyword">try</span> &#123;                phone.sendEmail();            &#125; <span class="keyword">catch</span> (Exception e) &#123;                e.printStackTrace();            &#125;        &#125;, <span class="string">&quot;BB&quot;</span>).start();    &#125;&#125;</code></pre><p>打印结果：</p><pre><code class="highlight shell">------sendSMS------sendEmail</code></pre><p>分析：两个方法都加了 synchronized 关键字，因为是同一个对象调用，所有是同一把锁，按照顺序执行。</p></li><li><p>停4秒在短信方法内，先打印短信还是邮件</p><pre><code class="highlight java"><span class="keyword">class</span> <span class="title class_">Phone</span> &#123;    <span class="keyword">public</span> <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title function_">sendSMS</span><span class="params">()</span> <span class="keyword">throws</span> Exception &#123;        <span class="comment">//停留4秒</span>        TimeUnit.SECONDS.sleep(<span class="number">4</span>);        System.out.println(<span class="string">&quot;------sendSMS&quot;</span>);    &#125;    <span class="keyword">public</span> <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title function_">sendEmail</span><span class="params">()</span> <span class="keyword">throws</span> Exception &#123;        System.out.println(<span class="string">&quot;------sendEmail&quot;</span>);    &#125;&#125;<span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Lock_8</span> &#123;    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception &#123;        <span class="type">Phone</span> <span class="variable">phone</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Phone</span>();        <span class="keyword">new</span> <span class="title class_">Thread</span>(() -&gt; &#123;            <span class="keyword">try</span> &#123;                phone.sendSMS();            &#125; <span class="keyword">catch</span> (Exception e) &#123;                e.printStackTrace();            &#125;        &#125;, <span class="string">&quot;AA&quot;</span>).start();        Thread.sleep(<span class="number">100</span>);        <span class="keyword">new</span> <span class="title class_">Thread</span>(() -&gt; &#123;            <span class="keyword">try</span> &#123;                phone.sendEmail();            &#125; <span class="keyword">catch</span> (Exception e) &#123;                e.printStackTrace();            &#125;        &#125;, <span class="string">&quot;BB&quot;</span>).start();    &#125;&#125;</code></pre><p>打印结果：</p><pre><code class="highlight shell">------sendSMS------sendEmail</code></pre><p>分析：两个方法都加了 synchronized 关键字，因为还是同一个对象调用，所有还是同一把锁，先拿到锁的方法执行结束后，另一个方法才能执行。</p></li><li><p>新增普通的hello方法，是先打短信还是hello</p><pre><code class="highlight java"><span class="keyword">class</span> <span class="title class_">Phone</span> &#123;    <span class="keyword">public</span> <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title function_">sendSMS</span><span class="params">()</span> <span class="keyword">throws</span> Exception &#123;        <span class="comment">//停留4秒</span>        TimeUnit.SECONDS.sleep(<span class="number">4</span>);        System.out.println(<span class="string">&quot;------sendSMS&quot;</span>);    &#125;    <span class="keyword">public</span> <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title function_">sendEmail</span><span class="params">()</span> <span class="keyword">throws</span> Exception &#123;        System.out.println(<span class="string">&quot;------sendEmail&quot;</span>);    &#125;    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">getHello</span><span class="params">()</span> &#123;        System.out.println(<span class="string">&quot;------getHello&quot;</span>);    &#125;&#125;<span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Lock_8</span> &#123;    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception &#123;        <span class="type">Phone</span> <span class="variable">phone</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Phone</span>();        <span class="keyword">new</span> <span class="title class_">Thread</span>(() -&gt; &#123;            <span class="keyword">try</span> &#123;                phone.sendSMS();            &#125; <span class="keyword">catch</span> (Exception e) &#123;                e.printStackTrace();            &#125;        &#125;, <span class="string">&quot;AA&quot;</span>).start();        Thread.sleep(<span class="number">100</span>);        <span class="keyword">new</span> <span class="title class_">Thread</span>(() -&gt; &#123;            <span class="keyword">try</span> &#123;                phone.getHello();            &#125; <span class="keyword">catch</span> (Exception e) &#123;                e.printStackTrace();            &#125;        &#125;, <span class="string">&quot;BB&quot;</span>).start();    &#125;&#125;</code></pre><p>打印结果：</p><pre><code class="highlight shell">------getHello------sendSMS</code></pre><p>分析：hello方法没有加锁，调用即执行，sendSMS有sleep阻塞。</p></li><li><p>现在有两部手机，先打印短信还是邮件</p><pre><code class="highlight java"><span class="keyword">class</span> <span class="title class_">Phone</span> &#123;    <span class="keyword">public</span> <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title function_">sendSMS</span><span class="params">()</span> <span class="keyword">throws</span> Exception &#123;        <span class="comment">//停留4秒</span>        TimeUnit.SECONDS.sleep(<span class="number">4</span>);        System.out.println(<span class="string">&quot;------sendSMS&quot;</span>);    &#125;    <span class="keyword">public</span> <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title function_">sendEmail</span><span class="params">()</span> <span class="keyword">throws</span> Exception &#123;        System.out.println(<span class="string">&quot;------sendEmail&quot;</span>);    &#125;&#125;<span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Lock_8</span> &#123;    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception &#123;        <span class="type">Phone</span> <span class="variable">phone</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Phone</span>();        <span class="type">Phone</span> <span class="variable">phone2</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Phone</span>();        <span class="keyword">new</span> <span class="title class_">Thread</span>(() -&gt; &#123;            <span class="keyword">try</span> &#123;                phone.sendSMS();            &#125; <span class="keyword">catch</span> (Exception e) &#123;                e.printStackTrace();            &#125;        &#125;, <span class="string">&quot;AA&quot;</span>).start();        Thread.sleep(<span class="number">100</span>);        <span class="keyword">new</span> <span class="title class_">Thread</span>(() -&gt; &#123;            <span class="keyword">try</span> &#123;                phone2.sendEmail();            &#125; <span class="keyword">catch</span> (Exception e) &#123;                e.printStackTrace();            &#125;        &#125;, <span class="string">&quot;BB&quot;</span>).start();    &#125;&#125;</code></pre><p>打印结果：</p><pre><code class="highlight shell">------sendEmail------sendSMS</code></pre><p>分析：synchronized 在方法上，是方法级的锁，由于是两个 phone 对象调用不同的方法，所以 sendSMS() 和 sendEmail() 持有的是不同的锁，互不影响。</p></li><li><p>两个静态同步方法，1部手机，先打印短信还是邮件</p><pre><code class="highlight java"><span class="keyword">class</span> <span class="title class_">Phone</span> &#123;    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title function_">sendSMS</span><span class="params">()</span> <span class="keyword">throws</span> Exception &#123;        <span class="comment">//停留4秒</span>        TimeUnit.SECONDS.sleep(<span class="number">4</span>);        System.out.println(<span class="string">&quot;------sendSMS&quot;</span>);    &#125;    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title function_">sendEmail</span><span class="params">()</span> <span class="keyword">throws</span> Exception &#123;        System.out.println(<span class="string">&quot;------sendEmail&quot;</span>);    &#125;&#125;<span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Lock_8</span> &#123;    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception &#123;        <span class="type">Phone</span> <span class="variable">phone</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Phone</span>();                <span class="keyword">new</span> <span class="title class_">Thread</span>(() -&gt; &#123;            <span class="keyword">try</span> &#123;                phone.sendSMS();            &#125; <span class="keyword">catch</span> (Exception e) &#123;                e.printStackTrace();            &#125;        &#125;, <span class="string">&quot;AA&quot;</span>).start();        Thread.sleep(<span class="number">100</span>);        <span class="keyword">new</span> <span class="title class_">Thread</span>(() -&gt; &#123;            <span class="keyword">try</span> &#123;                phone.sendEmail();            &#125; <span class="keyword">catch</span> (Exception e) &#123;                e.printStackTrace();            &#125;        &#125;, <span class="string">&quot;BB&quot;</span>).start();    &#125;&#125;</code></pre><p>打印结果：</p><pre><code class="highlight shell">------sendSMS------sendEmail</code></pre><p>分析：synchronized 在静态方法上，是类级别的锁，所以两个方法持有的是同一把锁，要按顺序执行</p></li><li><p>两个静态同步方法，2部手机，先打印短信还是邮件</p><pre><code class="highlight java"><span class="keyword">class</span> <span class="title class_">Phone</span> &#123;    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title function_">sendSMS</span><span class="params">()</span> <span class="keyword">throws</span> Exception &#123;        <span class="comment">//停留4秒</span>        TimeUnit.SECONDS.sleep(<span class="number">4</span>);        System.out.println(<span class="string">&quot;------sendSMS&quot;</span>);    &#125;    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title function_">sendEmail</span><span class="params">()</span> <span class="keyword">throws</span> Exception &#123;        System.out.println(<span class="string">&quot;------sendEmail&quot;</span>);    &#125;&#125;<span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Lock_8</span> &#123;    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception &#123;        <span class="type">Phone</span> <span class="variable">phone</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Phone</span>();        <span class="type">Phone</span> <span class="variable">phone2</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Phone</span>();        <span class="keyword">new</span> <span class="title class_">Thread</span>(() -&gt; &#123;            <span class="keyword">try</span> &#123;                phone.sendSMS();            &#125; <span class="keyword">catch</span> (Exception e) &#123;                e.printStackTrace();            &#125;        &#125;, <span class="string">&quot;AA&quot;</span>).start();        Thread.sleep(<span class="number">100</span>);        <span class="keyword">new</span> <span class="title class_">Thread</span>(() -&gt; &#123;            <span class="keyword">try</span> &#123;                phone2.sendEmail();            &#125; <span class="keyword">catch</span> (Exception e) &#123;                e.printStackTrace();            &#125;        &#125;, <span class="string">&quot;BB&quot;</span>).start();    &#125;&#125;</code></pre><p>打印结果：</p><pre><code class="highlight shell">------sendSMS------sendEmail</code></pre><p>分析：synchronized 在静态方法上，是类级别的锁，所以两个方法持有的是同一把锁，要按顺序执行</p></li><li><p>1个静态同步方法,1个普通同步方法，1部手机，先打印短信还是邮件</p><pre><code class="highlight java"><span class="keyword">class</span> <span class="title class_">Phone</span> &#123;    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title function_">sendSMS</span><span class="params">()</span> <span class="keyword">throws</span> Exception &#123;        <span class="comment">//停留4秒</span>        TimeUnit.SECONDS.sleep(<span class="number">4</span>);        System.out.println(<span class="string">&quot;------sendSMS&quot;</span>);    &#125;    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">getHello</span><span class="params">()</span> &#123;        System.out.println(<span class="string">&quot;------getHello&quot;</span>);    &#125;&#125;<span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Lock_8</span> &#123;    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception &#123;        <span class="type">Phone</span> <span class="variable">phone</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Phone</span>();        <span class="keyword">new</span> <span class="title class_">Thread</span>(() -&gt; &#123;            <span class="keyword">try</span> &#123;                phone.sendSMS();            &#125; <span class="keyword">catch</span> (Exception e) &#123;                e.printStackTrace();            &#125;        &#125;, <span class="string">&quot;AA&quot;</span>).start();        Thread.sleep(<span class="number">100</span>);        <span class="keyword">new</span> <span class="title class_">Thread</span>(() -&gt; &#123;            <span class="keyword">try</span> &#123;                phone.getHello();            &#125; <span class="keyword">catch</span> (Exception e) &#123;                e.printStackTrace();            &#125;        &#125;, <span class="string">&quot;BB&quot;</span>).start();    &#125;&#125;</code></pre><p>打印结果：</p><pre><code class="highlight shell">------getHello------sendSMS</code></pre><p>分析：类加锁对普通方法无限制，普通方法调用即执行。</p></li><li><p>1个静态同步方法,1个普通同步方法，2部手机，先打印短信还是邮件</p><pre><code class="highlight java"><span class="keyword">class</span> <span class="title class_">Phone</span> &#123;    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title function_">sendSMS</span><span class="params">()</span> <span class="keyword">throws</span> Exception &#123;        <span class="comment">//停留4秒</span>        TimeUnit.SECONDS.sleep(<span class="number">4</span>);        System.out.println(<span class="string">&quot;------sendSMS&quot;</span>);    &#125;    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">sendEmail</span><span class="params">()</span> <span class="keyword">throws</span> Exception &#123;        System.out.println(<span class="string">&quot;------sendEmail&quot;</span>);    &#125;&#125;<span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Lock_8</span> &#123;    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception &#123;        <span class="type">Phone</span> <span class="variable">phone</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Phone</span>();        <span class="type">Phone</span> <span class="variable">phone2</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Phone</span>();        <span class="keyword">new</span> <span class="title class_">Thread</span>(() -&gt; &#123;            <span class="keyword">try</span> &#123;                phone.sendSMS();            &#125; <span class="keyword">catch</span> (Exception e) &#123;                e.printStackTrace();            &#125;        &#125;, <span class="string">&quot;AA&quot;</span>).start();        Thread.sleep(<span class="number">100</span>);        <span class="keyword">new</span> <span class="title class_">Thread</span>(() -&gt; &#123;            <span class="keyword">try</span> &#123;                phone2.sendEmail();            &#125; <span class="keyword">catch</span> (Exception e) &#123;                e.printStackTrace();            &#125;        &#125;, <span class="string">&quot;BB&quot;</span>).start();    &#125;&#125;</code></pre><p>打印结果：</p><pre><code class="highlight shell">------sendEmail------sendSMS</code></pre><p>分析：类加锁对普通方法无限制，普通方法调用即执行。</p></li></ol><p><strong>总结：</strong></p><ul><li>synchronized 锁的是方法，则是对象锁，同个对象锁的机制要等待，不同对象锁的机制调用同一个不用等待</li><li>加了static则为class锁而不是对象锁</li><li>对于同步方法块，锁是 synchronized 括号里配置对象</li></ul><h1 id="三、字节码角度分析-synchronized-实现"><a href="#三、字节码角度分析-synchronized-实现" class="headerlink" title="三、字节码角度分析 synchronized 实现"></a>三、字节码角度分析 synchronized 实现</h1><h2 id="1-synchronized-同步代码块"><a href="#1-synchronized-同步代码块" class="headerlink" title="1. synchronized 同步代码块"></a>1. synchronized 同步代码块</h2><h3 id="1-1-文件反编译技巧"><a href="#1-1-文件反编译技巧" class="headerlink" title="1.1 文件反编译技巧"></a>1.1 文件反编译技巧</h3><ul><li><p>文件反编译 <code>javap -c ***.class</code> 文件反编译，-c表示对代码进行反汇编</p></li><li><p>假如需要更多信息 <code>javap -v ***.class</code> ，-v 即 -verbose 输出附加信息（包括行号、本地变量表、反汇编等详细信息）</p></li></ul><h3 id="1-2-synchronized-同步代码块"><a href="#1-2-synchronized-同步代码块" class="headerlink" title="1.2 synchronized 同步代码块"></a>1.2 synchronized 同步代码块</h3><pre><code class="highlight java"><span class="comment">/**</span><span class="comment"> * 锁同步代码块</span><span class="comment"> */</span><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">LockSyncDemo</span> &#123;    <span class="type">Object</span> <span class="variable">object</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Object</span>();    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">m1</span><span class="params">()</span>&#123;        <span class="keyword">synchronized</span> (object)&#123;            System.out.println(<span class="string">&quot;-----hello synchronized code block&quot;</span>);        &#125;    &#125;    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;    &#125;&#125;</code></pre><h3 id="1-3-class-文件反编译"><a href="#1-3-class-文件反编译" class="headerlink" title="1.3 class 文件反编译"></a>1.3 class 文件反编译</h3><p>执行命令 <code>javap -c LockSyncDemo.class</code></p><pre><code class="highlight shell">public class com.georg.controller.LockSyncDemo &#123;  java.lang.Object object;  public com.zhang.admin.controller.LockSyncDemo();    Code:       0: aload_0       1: invokespecial #1                  // Method java/lang/Object.&quot;&lt;init&gt;&quot;:()V       4: aload_0       5: new           #2                  // class java/lang/Object       8: dup       9: invokespecial #1                  // Method java/lang/Object.&quot;&lt;init&gt;&quot;:()V      12: putfield      #3                  // Field object:Ljava/lang/Object;      15: return  public void m1();    Code:       0: aload_0       1: getfield      #3                  // Field object:Ljava/lang/Object;       4: dup       5: astore_1       6: monitorenter        //**注****------进入锁       7: getstatic     #4                  // Field java/lang/System.out:Ljava/io/PrintStream;      10: ldc           #5                  // String -----hello synchronized code block      12: invokevirtual #6                  // Method java/io/PrintStream.println:(Ljava/lang/String;)V      15: aload_1      16: monitorexit        // **注**------退出锁      17: goto          25      20: astore_2      21: aload_1      22: monitorexit        //**注**-----这里又有一个exit, 目的当出现异常时，保证能够释放锁      23: aload_2      24: athrow      25: return    Exception table:       from    to  target type           7    17    20   any          20    23    20   any  public static void main(java.lang.String[]);    Code:       0: return&#125;</code></pre><p><strong>总结</strong></p><ul><li>synchronized 同步代码块，实现使用的是<code>moniterenter</code> 和 <code>moniterexit</code> 指令（ <code>moniterexit</code> 可能有两个）</li><li>那一定是一个enter两个exit吗？（不一样，如果主动throw一个RuntimeException，发现一个enter，一个exit，还有两个athrow）</li></ul><h2 id="2-synchronized-普通同步方法"><a href="#2-synchronized-普通同步方法" class="headerlink" title="2. synchronized 普通同步方法"></a>2. synchronized 普通同步方法</h2><pre><code class="highlight java"><span class="comment">/**</span><span class="comment"> * 锁普通的同步方法</span><span class="comment"> */</span><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">LockSyncDemo</span> &#123;    <span class="keyword">public</span> <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title function_">m2</span><span class="params">()</span>&#123;        System.out.println(<span class="string">&quot;------hello synchronized m2&quot;</span>);    &#125;    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;    &#125;&#125;</code></pre><ul><li>类似于上述操作，最后调用 <code>javap -v LockSyncDemo.class</code></li></ul><pre><code class="highlight java">.....<span class="keyword">public</span> <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title function_">m2</span><span class="params">()</span>;    descriptor: ()V    flags: ACC_PUBLIC, ACC_SYNCHRONIZED <span class="comment">//请注意该标志</span>    Code:      stack=<span class="number">2</span>, locals=<span class="number">1</span>, args_size=<span class="number">1</span>         <span class="number">0</span>: getstatic     #<span class="number">2</span>                  <span class="comment">// Field java/lang/System.out:Ljava/io/PrintStream;</span>         <span class="number">3</span>: ldc           #<span class="number">3</span>                  <span class="comment">// String ------hello synchronized m2</span>         <span class="number">5</span>: invokevirtual #<span class="number">4</span>                  <span class="comment">// Method java/io/PrintStream.println:(Ljava/lang/String;)V</span>         <span class="number">8</span>: <span class="keyword">return</span>      LineNumberTable:        line <span class="number">11</span>: <span class="number">0</span>        line <span class="number">12</span>: <span class="number">8</span>      LocalVariableTable:        Start  Length  Slot  Name   Signature            <span class="number">0</span>       <span class="number">9</span>     <span class="number">0</span>  <span class="built_in">this</span>   Lcom/zhang/admin/controller/LockSyncDemo;......</code></pre><p><strong>总结</strong></p><p>调用指令将会检查方法的 <strong>ACC_SYNCHRONIZED</strong> 访问标志是否被设置。如果设置了，执行线程会先持有monitor, 然后再执行方法，最后在方法完成（无论是正常完成还是非正常完成）时释放monitor</p><h2 id="3-synchronized-静态同步方法"><a href="#3-synchronized-静态同步方法" class="headerlink" title="3. synchronized 静态同步方法"></a>3. synchronized 静态同步方法</h2><pre><code class="highlight java"><span class="comment">/**</span><span class="comment"> * 锁静态同步方法</span><span class="comment"> */</span><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">LockSyncDemo</span> &#123;    <span class="keyword">public</span> <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title function_">m2</span><span class="params">()</span>&#123;        System.out.println(<span class="string">&quot;------hello synchronized m2&quot;</span>);    &#125;    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title function_">m3</span><span class="params">()</span>&#123;        System.out.println(<span class="string">&quot;------hello synchronized m3---static&quot;</span>);    &#125;    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;    &#125;&#125;</code></pre><ul><li>调用 <code>javap -v LockSyncDemo.class</code></li></ul><pre><code class="highlight shell"> ...... public static synchronized void m3();    descriptor: ()V    flags: ACC_PUBLIC, ACC_STATIC, ACC_SYNCHRONIZED //访问标志 区分该方法是否是静态同步方法    Code:      stack=2, locals=0, args_size=0         0: getstatic     #2                  // Field java/lang/System.out:Ljava/io/PrintStream;         3: ldc           #5                  // String ------hello synchronized m3---static         5: invokevirtual #4                  // Method java/io/PrintStream.println:(Ljava/lang/String;)V         8: return      LineNumberTable:        line 15: 0        line 16: 8......</code></pre><p><strong>总结</strong></p><p><strong>ACC_STATIC</strong> 访问标志区分该方法是否是静态同步方法。</p><h1 id="四、反编译解析-synchronized-锁的是什么"><a href="#四、反编译解析-synchronized-锁的是什么" class="headerlink" title="四、反编译解析 synchronized 锁的是什么"></a>四、反编译解析 synchronized 锁的是什么</h1><h2 id="1-管程概念"><a href="#1-管程概念" class="headerlink" title="1. 管程概念"></a>1. 管程概念</h2><ul><li>管程：Monitor（监视器），也就是我们平时说的锁。监视器锁</li><li>信号量及其操作原语“封装”在一个对象内部）管程实现了在一个时间点，最多只有一个线程在执行管程的某个子程序。 管程提供了一种机制，管程可以看做一个软件模块，它是将共享的变量和对于这些共享变量的操作封装起来，形成一个具有一定接口的功能模块，进程可以调用管程来实现线程级别的并发控制。</li><li>执行线程就要求先成功持有管程，然后才能执行方法，最后当方法完成（无论是正常完成还是非正常完成）时释放管理。在方法执行期间，执行线程持有了管程，其他任何线程都无法再获取到同一个管程。</li></ul><h2 id="2-解释为什么任何一个对象都可以成为一个锁"><a href="#2-解释为什么任何一个对象都可以成为一个锁" class="headerlink" title="2. 解释为什么任何一个对象都可以成为一个锁"></a>2. 解释为什么任何一个对象都可以成为一个锁</h2><p>Java Object 类是所有类的父类，也就是说 Java 的所有类都继承了 Object，子类可以使用 Object 的所有方法。</p><ul><li><code>ObjectMonitor.java</code> → <code>ObjectMonitor.cpp</code> → <code>objectMonitor.hpp</code></li></ul><p><code>ObjectMonitor.cpp</code> 中引入了头文件（include）<code>objectMonitor.hpp</code></p><p><img src="https://raw.githubusercontent.com/GeorgeChan95/blogimg/master/img/2024/09/21/20240921-153217.png" alt="objectMonitor.hpp"></p><ul><li><p><strong>objectMonitor.hpp</strong></p><table><thead><tr><th>属性</th><th>作用</th></tr></thead><tbody><tr><td>_owner</td><td>指向持有ObjectMonitor对象的线程</td></tr><tr><td>_WaitSet</td><td>存放处于wait状态的线程队列</td></tr><tr><td>_EntryList</td><td>存放处于等待锁block状态的线程队列</td></tr><tr><td>_recursions</td><td>锁的重入次数</td></tr><tr><td>_count</td><td>用来记录该线程获取锁的次数</td></tr></tbody></table><p><strong>因此：每个对象天生都带着一个对象监视器</strong></p></li></ul><h1 id="五、关于锁升级"><a href="#五、关于锁升级" class="headerlink" title="五、关于锁升级"></a>五、关于锁升级</h1><p>这里只是简单提及，做个了解，后面会再做深入讲解</p><p>synchronized必须作用于某个对象中，所以Java在对象的头文件存储了锁的相关信息。锁升级功能主要依赖于 MarkWord 中的锁标志位和释放偏向锁标志位。</p><p><img src="https://raw.githubusercontent.com/GeorgeChan95/blogimg/master/img/2024/09/21/20240921-153834.png" alt="锁升级"></p><h1 id="六、公平锁和非公平锁"><a href="#六、公平锁和非公平锁" class="headerlink" title="六、公平锁和非公平锁"></a>六、公平锁和非公平锁</h1><h2 id="1-案例演示"><a href="#1-案例演示" class="headerlink" title="1. 案例演示"></a>1. 案例演示</h2><h3 id="1-1-非公平锁"><a href="#1-1-非公平锁" class="headerlink" title="1.1 非公平锁"></a>1.1 非公平锁</h3><p>使用 ReentrantLock 实现抢票的案例</p><pre><code class="highlight java"><span class="keyword">class</span> <span class="title class_">Ticket</span> &#123;    <span class="keyword">private</span> <span class="type">int</span> <span class="variable">number</span> <span class="operator">=</span> <span class="number">30</span>;    <span class="keyword">private</span> <span class="type">Lock</span> <span class="variable">lock</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ReentrantLock</span>(); <span class="comment">//默认用的是非公平锁，分配的平均一点，=--》公平一点</span>    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">sale</span><span class="params">()</span> &#123;        lock.lock();        <span class="keyword">try</span> &#123;            <span class="keyword">if</span> (number &gt; <span class="number">0</span>) &#123;                System.out.println(Thread.currentThread().getName() + <span class="string">&quot;\t 卖出第: &quot;</span> + (number--) + <span class="string">&quot;\t 还剩下: &quot;</span> + number);            &#125;        &#125; <span class="keyword">finally</span> &#123;            lock.unlock();        &#125;    &#125;&#125;<span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">SaleTicketDemo</span> &#123;    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;        <span class="type">Ticket</span> <span class="variable">ticket</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Ticket</span>();        <span class="keyword">new</span> <span class="title class_">Thread</span>(() -&gt; &#123;<span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">1</span>; i &lt;= <span class="number">55</span>; i++) ticket.sale();&#125;, <span class="string">&quot;a&quot;</span>).start();        <span class="keyword">new</span> <span class="title class_">Thread</span>(() -&gt; &#123;<span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">1</span>; i &lt;= <span class="number">55</span>; i++) ticket.sale();&#125;, <span class="string">&quot;b&quot;</span>).start();        <span class="keyword">new</span> <span class="title class_">Thread</span>(() -&gt; &#123;<span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">1</span>; i &lt;= <span class="number">55</span>; i++) ticket.sale();&#125;, <span class="string">&quot;c&quot;</span>).start();    &#125;&#125;</code></pre><p>运行结果，不同的线程抢到票的几率差距很大，线程执行不公平。</p><pre><code class="highlight shell">a 卖出第: 30 还剩下: 29a 卖出第: 29 还剩下: 28a 卖出第: 28 还剩下: 27a 卖出第: 27 还剩下: 26c 卖出第: 26 还剩下: 25c 卖出第: 25 还剩下: 24c 卖出第: 24 还剩下: 23c 卖出第: 23 还剩下: 22c 卖出第: 22 还剩下: 21c 卖出第: 21 还剩下: 20c 卖出第: 20 还剩下: 19c 卖出第: 19 还剩下: 18c 卖出第: 18 还剩下: 17c 卖出第: 17 还剩下: 16c 卖出第: 16 还剩下: 15c 卖出第: 15 还剩下: 14c 卖出第: 14 还剩下: 13c 卖出第: 13 还剩下: 12c 卖出第: 12 还剩下: 11c 卖出第: 11 还剩下: 10c 卖出第: 10 还剩下: 9c 卖出第: 9 还剩下: 8c 卖出第: 8 还剩下: 7c 卖出第: 7 还剩下: 6c 卖出第: 6 还剩下: 5c 卖出第: 5 还剩下: 4c 卖出第: 4 还剩下: 3c 卖出第: 3 还剩下: 2c 卖出第: 2 还剩下: 1c 卖出第: 1 还剩下: 0</code></pre><h3 id="1-2-公平锁"><a href="#1-2-公平锁" class="headerlink" title="1.2 公平锁"></a>1.2 公平锁</h3><p>使用 ReentrantLock 实现公平抢票的案例</p><pre><code class="highlight java"><span class="keyword">class</span> <span class="title class_">Ticket</span> &#123;    <span class="keyword">private</span> <span class="type">int</span> <span class="variable">number</span> <span class="operator">=</span> <span class="number">30</span>;    <span class="keyword">private</span> <span class="type">Lock</span> <span class="variable">lock</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ReentrantLock</span>(<span class="literal">true</span>); <span class="comment">//默认用的是非公平锁，传 true 则为公平锁</span>    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">sale</span><span class="params">()</span> &#123;        lock.lock();        <span class="keyword">try</span> &#123;            <span class="keyword">if</span> (number &gt; <span class="number">0</span>) &#123;                System.out.println(Thread.currentThread().getName() + <span class="string">&quot;\t 卖出第: &quot;</span> + (number--) + <span class="string">&quot;\t 还剩下: &quot;</span> + number);            &#125;        &#125; <span class="keyword">finally</span> &#123;            lock.unlock();        &#125;    &#125;&#125;<span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">SaleTicketDemo</span> &#123;    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;        <span class="type">Ticket</span> <span class="variable">ticket</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Ticket</span>();        <span class="keyword">new</span> <span class="title class_">Thread</span>(() -&gt; &#123;<span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">1</span>; i &lt;= <span class="number">55</span>; i++) ticket.sale();&#125;, <span class="string">&quot;a&quot;</span>).start();        <span class="keyword">new</span> <span class="title class_">Thread</span>(() -&gt; &#123;<span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">1</span>; i &lt;= <span class="number">55</span>; i++) ticket.sale();&#125;, <span class="string">&quot;b&quot;</span>).start();        <span class="keyword">new</span> <span class="title class_">Thread</span>(() -&gt; &#123;<span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">1</span>; i &lt;= <span class="number">55</span>; i++) ticket.sale();&#125;, <span class="string">&quot;c&quot;</span>).start();    &#125;&#125;</code></pre><p>执行结果，每个线程都得到了较为公平的执行机会。</p><pre><code class="highlight shell">a 卖出第: 30 还剩下: 29a 卖出第: 29 还剩下: 28a 卖出第: 28 还剩下: 27a 卖出第: 27 还剩下: 26b 卖出第: 26 还剩下: 25c 卖出第: 25 还剩下: 24a 卖出第: 24 还剩下: 23b 卖出第: 23 还剩下: 22c 卖出第: 22 还剩下: 21a 卖出第: 21 还剩下: 20b 卖出第: 20 还剩下: 19c 卖出第: 19 还剩下: 18a 卖出第: 18 还剩下: 17b 卖出第: 17 还剩下: 16c 卖出第: 16 还剩下: 15a 卖出第: 15 还剩下: 14b 卖出第: 14 还剩下: 13c 卖出第: 13 还剩下: 12a 卖出第: 12 还剩下: 11b 卖出第: 11 还剩下: 10c 卖出第: 10 还剩下: 9a 卖出第: 9 还剩下: 8b 卖出第: 8 还剩下: 7c 卖出第: 7 还剩下: 6a 卖出第: 6 还剩下: 5b 卖出第: 5 还剩下: 4c 卖出第: 4 还剩下: 3a 卖出第: 3 还剩下: 2b 卖出第: 2 还剩下: 1c 卖出第: 1 还剩下: 0</code></pre><h2 id="2-公平锁-非公平锁-概念解析"><a href="#2-公平锁-非公平锁-概念解析" class="headerlink" title="2. 公平锁&#x2F;非公平锁 概念解析"></a>2. 公平锁&#x2F;非公平锁 概念解析</h2><ul><li>公平锁：是指多个线程按照申请锁的顺序来获取锁，这里类似于排队买票，先来的人先买，后来的人再队尾排着，这是公平的—– Lock lock &#x3D; new ReentrantLock(true)—表示公平锁，先来先得。</li><li>非公平锁：是指多个线程获取锁的顺序并不是按照申请的顺序，有可能后申请的线程比先申请的线程优先获取锁，在高并发环境下，有可能造成优先级反转或者饥饿的状态（某个线程一直得不到锁）—- Lock lock &#x3D; new  ReentrantLock(false)—表示非公平锁，后来的也可能先获得锁，默认为非公平锁。</li></ul><h2 id="3-关于-公平锁-非公平锁-的相关问题"><a href="#3-关于-公平锁-非公平锁-的相关问题" class="headerlink" title="3. 关于 公平锁&#x2F;非公平锁 的相关问题"></a>3. 关于 公平锁&#x2F;非公平锁 的相关问题</h2><h3 id="3-1-为什么会有公平锁-非公平锁的设计为什么默认非公平？"><a href="#3-1-为什么会有公平锁-非公平锁的设计为什么默认非公平？" class="headerlink" title="3.1 为什么会有公平锁&#x2F;非公平锁的设计为什么默认非公平？"></a>3.1 为什么会有公平锁&#x2F;非公平锁的设计为什么默认非公平？</h3><ul><li>恢复挂起的线程到真正锁的获取还是有时间差的，从开发人员来看这个时间微乎其微，但是从CPU的角度来看，这个时间差存在的还是很明显的。所以非公平锁能更充分的利用CPU 的时间片，尽量减少 CPU 空闲状态时间。</li><li>使用多线程很重要的考量点是线程切换的开销，当采用非公平锁时，当1个线程请求锁获取同步状态，然后释放同步状态，因为不需要考虑是否还有前驱节点，所以刚释放锁的线程在此刻再次获取同步状态的概率就变得非常大，所以就减少了线程的开销。</li></ul><h3 id="3-2-使⽤公平锁会有什么问题"><a href="#3-2-使⽤公平锁会有什么问题" class="headerlink" title="3.2 使⽤公平锁会有什么问题"></a>3.2 使⽤公平锁会有什么问题</h3><p>公平锁保证了排队的公平性，非公平锁霸气的忽视这个规则，所以就有可能导致排队的长时间在排队，也没有机会获取到锁，这就是传说中的 “锁饥饿”</p><h3 id="3-3-什么时候用公平？什么时候用非公平？"><a href="#3-3-什么时候用公平？什么时候用非公平？" class="headerlink" title="3.3 什么时候用公平？什么时候用非公平？"></a>3.3 什么时候用公平？什么时候用非公平？</h3><ul><li>如果为了更高的吞吐量，很显然非公平锁是比较合适的，因为节省很多线程切换时间，吞吐量自然就上去了；</li><li>否则那就用公平锁，大家公平使用。</li></ul><h1 id="七、可重入锁"><a href="#七、可重入锁" class="headerlink" title="七、可重入锁"></a>七、可重入锁</h1><h2 id="1-概念解析"><a href="#1-概念解析" class="headerlink" title="1. 概念解析"></a>1. 概念解析</h2><p><strong>可重入锁又名递归锁</strong></p><ul><li><p>是指在同一个线程在外层方法获取锁的时候，再进入该线程的内层方法会自动获取锁(前提，锁对象得是同一个对象)，不会因为之前已经获取过还没释放而阻塞。</p></li><li><p>如果是1个有 <code>synchronized</code> 修饰的递归调用方法，程序第2次进入被自己阻塞了这样递归方法也就不能继续执行下去了。所以Java中 <code>ReentrantLock</code> 和<code>synchronized</code> 都是可重入锁，可重入锁的一个优点是可一定程度避免死锁。</p></li></ul><h2 id="2-可重入锁种类"><a href="#2-可重入锁种类" class="headerlink" title="2. 可重入锁种类"></a>2. 可重入锁种类</h2><h3 id="2-1-隐式锁"><a href="#2-1-隐式锁" class="headerlink" title="2.1 隐式锁"></a>2.1 隐式锁</h3><p>隐式锁（即synchronized关键字使用的锁）默认是可重入锁</p><ul><li><p>作用于同步代码块</p><pre><code class="highlight java"><span class="keyword">static</span> <span class="type">Object</span> <span class="variable">objectLock</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Object</span>();<span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">syncBlock</span><span class="params">()</span>&#123;    <span class="keyword">new</span> <span class="title class_">Thread</span>(() -&gt; &#123;        <span class="keyword">synchronized</span> (objectLock) &#123;<span class="comment">// lock</span>            System.out.println(<span class="string">&quot;-----外层&quot;</span>);            <span class="keyword">synchronized</span> (objectLock)            &#123;                System.out.println(<span class="string">&quot;-----中层&quot;</span>);                <span class="keyword">synchronized</span> (objectLock)                &#123;                    System.out.println(<span class="string">&quot;-----内层&quot;</span>);                &#125;            &#125;        &#125;<span class="comment">//unlock</span>    &#125;,<span class="string">&quot;t1&quot;</span>).start();&#125;</code></pre><p>打印结果：</p><pre><code class="highlight plaintext">-----外层-----中层-----内层</code></pre></li><li><p>作用于同步方法中</p><pre><code class="highlight java"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ReEntryLockDemo</span>&#123;    <span class="keyword">public</span> <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title function_">m1</span><span class="params">()</span>    &#123;        <span class="comment">//指的是可重复可递归调用的锁，在外层使用之后，在内层仍然可以使用，并且不发生死锁，这样的锁就叫做可重入锁</span>        System.out.println(Thread.currentThread().getName()+<span class="string">&quot;\t&quot;</span>+<span class="string">&quot;-----come in m1&quot;</span>);        m2();        System.out.println(Thread.currentThread().getName()+<span class="string">&quot;\t-----end m1&quot;</span>);    &#125;    <span class="keyword">public</span> <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title function_">m2</span><span class="params">()</span>    &#123;        System.out.println(<span class="string">&quot;-----m2&quot;</span>);        m3();    &#125;    <span class="keyword">public</span> <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title function_">m3</span><span class="params">()</span>    &#123;        System.out.println(<span class="string">&quot;-----m3&quot;</span>);    &#125;    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span>    &#123;        <span class="type">ReEntryLockDemo</span> <span class="variable">reEntryLockDemo</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ReEntryLockDemo</span>();        reEntryLockDemo.m1();    &#125;&#125;<span class="comment">/**</span><span class="comment"> * main  -----come in m1</span><span class="comment"> * -----m2</span><span class="comment"> * -----m3</span><span class="comment"> * main  -----end m1</span><span class="comment"> */</span></code></pre><p>打印结果：</p><pre><code class="highlight java">main  -----come in m1-----m2-----m3main  -----end m1</code></pre></li><li></li></ul><h3 id="2-2-显式锁"><a href="#2-2-显式锁" class="headerlink" title="2.2 显式锁"></a>2.2 显式锁</h3><p>显式锁（即Lock）也有 ReentrantLock 这样的可重入锁。</p><ul><li>ReentrantLock 实现的显示可重入锁</li></ul><pre><code class="highlight java"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;    <span class="type">Lock</span> <span class="variable">lock</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ReentrantLock</span>();    <span class="keyword">new</span> <span class="title class_">Thread</span>(() -&gt; &#123;        lock.lock();        <span class="keyword">try</span> &#123;            System.out.println(Thread.currentThread().getName() + <span class="string">&quot;\t&quot;</span> + <span class="string">&quot;-----外层&quot;</span>);            lock.lock();            <span class="keyword">try</span> &#123;                System.out.println(Thread.currentThread().getName() + <span class="string">&quot;\t&quot;</span> + <span class="string">&quot;-----内层&quot;</span>);            &#125; <span class="keyword">finally</span> &#123;                lock.unlock();            &#125;        &#125; <span class="keyword">finally</span> &#123;            lock.unlock();        &#125;    &#125;, <span class="string">&quot;t1&quot;</span>).start();    <span class="keyword">new</span> <span class="title class_">Thread</span>(() -&gt; &#123;        lock.lock();        <span class="keyword">try</span> &#123;            System.out.println(<span class="string">&quot;------22222&quot;</span>);        &#125; <span class="keyword">finally</span> &#123;            lock.unlock();        &#125;    &#125;, <span class="string">&quot;t2&quot;</span>).start();&#125;</code></pre><p>打印结果：</p><pre><code class="highlight shell">t1-----外层t1-----内层------22222</code></pre><h2 id="3-Synchronized的可重入锁实现机理"><a href="#3-Synchronized的可重入锁实现机理" class="headerlink" title="3. Synchronized的可重入锁实现机理"></a>3. Synchronized的可重入锁实现机理</h2><p>再看 <code>ObjectMoitor.hpp</code></p><pre><code class="highlight cpp"><span class="number">140</span>行  <span class="built_in">ObjectMonitor</span>() &#123;    _header       = <span class="literal">NULL</span>;    _count        = <span class="number">0</span>; <span class="comment">//用来记录该线程获取锁的次数</span>    _waiters      = <span class="number">0</span>,    _recursions   = <span class="number">0</span>; <span class="comment">//锁的重入次数</span>    _object       = <span class="literal">NULL</span>;    _owner        = <span class="literal">NULL</span>; <span class="comment">//------最重要的----指向持有ObjectMonitor对象的线程，记录哪个线程持有了我</span>    _WaitSet      = <span class="literal">NULL</span>; <span class="comment">//存放处于wait状态的线程队列</span>    _WaitSetLock  = <span class="number">0</span> ;    _Responsible  = <span class="literal">NULL</span> ;    _succ         = <span class="literal">NULL</span> ;    _cxq          = <span class="literal">NULL</span> ;    FreeNext      = <span class="literal">NULL</span> ;    _EntryList    = <span class="literal">NULL</span> ; <span class="comment">//存放处于等待锁block状态的线程队列</span>    _SpinFreq     = <span class="number">0</span> ;    _SpinClock    = <span class="number">0</span> ;    OwnerIsThread = <span class="number">0</span> ;    _previous_owner_tid = <span class="number">0</span>;  &#125;</code></pre><ul><li><code>ObjectMoitor.hpp</code><strong>底层</strong>：每个锁对象拥有一个锁计数器和一个指向持有该锁的线程的指针。<code>_count</code> <code>_owner</code></li><li><strong>首次加锁</strong>：当执行<code>monitorenter</code>时，如果目标锁对象的计数器为零，那么说明它没有被其他线程所持有，Java虚拟机会将该锁对象的持有线程设置为当前线程，并且将其计数器<code>加1</code>。</li><li><strong>重入</strong>：在目标锁对象的计数器不为零的情况下，如果锁对象的持有线程是当前线程，那么 Java 虚拟机可以将其计数器<code>加1</code>，否则需要等待，直至持有线程释放该锁。</li><li><strong>释放锁</strong>：当执行monitorexit时，Java虚拟机则需将锁对象的计数器减1。计数器为零代表锁已被释放。</li></ul><h2 id="4-死锁及排查"><a href="#4-死锁及排查" class="headerlink" title="4. 死锁及排查"></a>4. 死锁及排查</h2><h3 id="4-1-死锁是什么"><a href="#4-1-死锁是什么" class="headerlink" title="4.1 死锁是什么"></a>4.1 死锁是什么</h3><p>死锁是指两个或两个以上的线程在执行过程中,因争夺资源而造成的一种互相等待的现象,若无外力干涉那它们都将无法推进下去，如果系统资源充足，进程的资源请求都能够得到满足，死锁出现的可能性就很低，否则就会因争夺有限的资源而陷入死锁。</p><p><img src="https://raw.githubusercontent.com/GeorgeChan95/blogimg/master/img/2024/09/21/20240921-163418.png" alt="死锁"></p><h3 id="4-2-死锁产生的原因"><a href="#4-2-死锁产生的原因" class="headerlink" title="4.2 死锁产生的原因"></a>4.2 死锁产生的原因</h3><ul><li>系统资源不足</li><li>进程运行推进的顺序不合适</li><li>资源分配不当</li></ul><h3 id="4-3-死锁代码案例"><a href="#4-3-死锁代码案例" class="headerlink" title="4.3 死锁代码案例"></a>4.3 死锁代码案例</h3><pre><code class="highlight java"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">DeadLockDemo</span> &#123;    <span class="keyword">static</span> <span class="type">Object</span> <span class="variable">lockA</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Object</span>();    <span class="keyword">static</span> <span class="type">Object</span> <span class="variable">lockB</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Object</span>();    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;        <span class="type">Thread</span> <span class="variable">a</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Thread</span>(() -&gt; &#123;            <span class="keyword">synchronized</span> (lockA) &#123;                System.out.println(Thread.currentThread().getName() + <span class="string">&quot;\t&quot;</span> + <span class="string">&quot; 自己持有A锁，期待获得B锁&quot;</span>);                <span class="keyword">try</span> &#123;                    TimeUnit.SECONDS.sleep(<span class="number">1</span>);                &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;                    e.printStackTrace();                &#125;                <span class="keyword">synchronized</span> (lockB) &#123;                    System.out.println(Thread.currentThread().getName() + <span class="string">&quot;\t 获得B锁成功&quot;</span>);                &#125;            &#125;        &#125;, <span class="string">&quot;a&quot;</span>);        a.start();        <span class="keyword">new</span> <span class="title class_">Thread</span>(() -&gt; &#123;            <span class="keyword">synchronized</span> (lockB) &#123;                System.out.println(Thread.currentThread().getName() + <span class="string">&quot;\t&quot;</span> + <span class="string">&quot; 自己持有B锁，期待获得A锁&quot;</span>);                <span class="keyword">try</span> &#123;                    TimeUnit.SECONDS.sleep(<span class="number">1</span>);                &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;                    e.printStackTrace();                &#125;                <span class="keyword">synchronized</span> (lockA) &#123;                    System.out.println(Thread.currentThread().getName() + <span class="string">&quot;\t 获得A锁成功&quot;</span>);                &#125;            &#125;        &#125;, <span class="string">&quot;b&quot;</span>).start();    &#125;&#125;</code></pre><p>运行结果：</p><pre><code class="highlight shell">a 自己持有A锁，期待获得B锁b 自己持有B锁，期待获得A锁</code></pre><p>程序运行到此没有停止，一直等待着……</p><h3 id="4-4-如何排查死锁"><a href="#4-4-如何排查死锁" class="headerlink" title="4.4 如何排查死锁"></a>4.4 如何排查死锁</h3><h4 id="4-4-1-命令行"><a href="#4-4-1-命令行" class="headerlink" title="4.4.1 命令行"></a>4.4.1 命令行</h4><ul><li><code>jps -l</code> 查看当前进程运行状况</li><li><code>jstack 进程编号</code> 查看该进程信息</li></ul><pre><code class="highlight shell">PS F:\&gt; jps -l29104 33360 com.atguigu.juc.locks.DeadLockDemo11172 org.jetbrains.jps.cmdline.Launcher27412 org.jetbrains.idea.maven.server.RemoteMavenServer3630148 org.jetbrains.idea.maven.server.RemoteMavenServer3645796 sun.tools.jps.Jps<span class="meta prompt_"></span><span class="meta prompt_">#</span><span class="language-bash"><span class="comment">####################################################################################</span></span>PS F:\&gt; jstack 333602024-09-21 16:39:01Full thread dump Java HotSpot(TM) 64-Bit Server VM (25.241-b07 mixed mode):&quot;Finalizer&quot; #3 daemon prio=8 os_prio=1 tid=0x0000000026eea000 nid=0x8df0 in Object.wait() [0x000000002a8ff000]   java.lang.Thread.State: WAITING (on object monitor)        at java.lang.Object.wait(Native Method)        - waiting on &lt;0x0000000716508ee0&gt; (a java.lang.ref.ReferenceQueue$Lock)        at java.lang.ref.ReferenceQueue.remove(ReferenceQueue.java:144)        - locked &lt;0x0000000716508ee0&gt; (a java.lang.ref.ReferenceQueue$Lock)        at java.lang.ref.ReferenceQueue.remove(ReferenceQueue.java:165)        at java.lang.ref.Finalizer$FinalizerThread.run(Finalizer.java:216)&quot;Reference Handler&quot; #2 daemon prio=10 os_prio=2 tid=0x0000000028ba8000 nid=0x3cb4 in Object.wait() [0x000000002a7ff000]   java.lang.Thread.State: WAITING (on object monitor)        at java.lang.Object.wait(Native Method)        - waiting on &lt;0x0000000716506c00&gt; (a java.lang.ref.Reference$Lock)        at java.lang.Object.wait(Object.java:502)        at java.lang.ref.Reference.tryHandlePending(Reference.java:191)        - locked &lt;0x0000000716506c00&gt; (a java.lang.ref.Reference$Lock)        at java.lang.ref.Reference$ReferenceHandler.run(Reference.java:153)&quot;VM Periodic Task Thread&quot; os_prio=2 tid=0x000000002b8e4000 nid=0x1378 waiting on conditionJNI global references: 317Found one Java-level deadlock:=============================&quot;b&quot;:  waiting to lock monitor 0x0000000028bab9f8 (object 0x00000007166f0fe8, a java.lang.Object),  which is held by &quot;a&quot;&quot;a&quot;:  waiting to lock monitor 0x0000000028bae338 (object 0x00000007166f0ff8, a java.lang.Object),  which is held by &quot;b&quot;Java stack information for the threads listed above:===================================================&quot;b&quot;:        at com.atguigu.juc.locks.DeadLockDemo.lambda$main$1(DeadLockDemo.java:44)        - waiting to lock &lt;0x00000007166f0fe8&gt; (a java.lang.Object)        - locked &lt;0x00000007166f0ff8&gt; (a java.lang.Object)        at com.atguigu.juc.locks.DeadLockDemo$$Lambda$2/1199823423.run(Unknown Source)        at java.lang.Thread.run(Thread.java:748)&quot;a&quot;:        at com.atguigu.juc.locks.DeadLockDemo.lambda$main$0(DeadLockDemo.java:27)        - waiting to lock &lt;0x00000007166f0ff8&gt; (a java.lang.Object)        - locked &lt;0x00000007166f0fe8&gt; (a java.lang.Object)        at com.atguigu.juc.locks.DeadLockDemo$$Lambda$1/1342443276.run(Unknown Source)        at java.lang.Thread.run(Thread.java:748)Found 1 deadlock.</code></pre><h4 id="4-4-2-图形化工具"><a href="#4-4-2-图形化工具" class="headerlink" title="4.4.2 图形化工具"></a>4.4.2 图形化工具</h4><p>这里使用JDK 自带的 <code>jconsole</code> 演示，此工具在jdk的安装的 <code>bin目录</code> 下，双击 jconsole.exe 打开即可。</p><p><img src="https://raw.githubusercontent.com/GeorgeChan95/blogimg/master/img/2024/09/21/20240921-164427.png" alt="image-20240921164426956"></p><h1 id="八、总结"><a href="#八、总结" class="headerlink" title="八、总结"></a>八、总结</h1><p>指针指向monitor对象（也称为管程或监视器锁）的起始地址。每个对象都存在着一个monitor与之关联，当一个monitor被某个线程持有后，它便处于锁定状态。在Java虚拟机(HotSpot)中，monitor是由ObjectMonitor实现的，其主要数据结构如下（位于HotSpot虚拟机源码ObjectMonitor.hpp,C++实现的）<br><img src="https://raw.githubusercontent.com/GeorgeChan95/blogimg/master/img/2024/09/21/20240921-165034.png" alt="锁"></p>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;一、乐观锁和悲观锁&quot;&gt;&lt;a href=&quot;#一、乐观锁和悲观锁&quot; class=&quot;headerlink&quot; title=&quot;一、乐观锁和悲观锁&quot;&gt;&lt;/a&gt;一、乐观锁和悲观锁&lt;/h1&gt;&lt;h2 id=&quot;1-悲观锁&quot;&gt;&lt;a href=&quot;#1-悲观锁&quot; class=&quot;header</summary>
      
    
    
    
    <category term="JUC" scheme="https://georgechan95.github.io/categories/JUC/"/>
    
    
    <category term="java" scheme="https://georgechan95.github.io/tags/java/"/>
    
    <category term="juc" scheme="https://georgechan95.github.io/tags/juc/"/>
    
  </entry>
  
  <entry>
    <title>02-JUC进阶-CompletableFuture</title>
    <link href="https://georgechan95.github.io/blog/7e2d78eb.html"/>
    <id>https://georgechan95.github.io/blog/7e2d78eb.html</id>
    <published>2024-09-18T14:50:00.000Z</published>
    <updated>2024-09-20T12:20:12.477Z</updated>
    
    <content type="html"><![CDATA[<h1 id="一、Future接口概述"><a href="#一、Future接口概述" class="headerlink" title="一、Future接口概述"></a>一、Future接口概述</h1><p>Future接口（FutureTask实现类）定义了操作异步任务执行一些方法，如获取异步任务的执行结果、取消异步任务的执行、判断任务是否被取消、判断任务执行是否完毕等。</p><p>举例：比如主线程让一个子线程去执行任务，子线程可能比较耗时，启动子线程开始执行任务后，主线程就去做其他事情了，忙完其他事情或者先执行完，过了一会再才去获取子任务的执行结果或变更的任务状态。</p><h1 id="二、Future接口实现类FutureTask"><a href="#二、Future接口实现类FutureTask" class="headerlink" title="二、Future接口实现类FutureTask"></a>二、Future接口实现类FutureTask</h1><h2 id="1-Future接口能干什么"><a href="#1-Future接口能干什么" class="headerlink" title="1. Future接口能干什么"></a>1. Future接口能干什么</h2><p>Future是 Java5 新加的一个接口，它提供一种异步并行计算的功能，如果主线程需要执行一个很耗时的计算任务，我们会就可以通过Future把这个任务放进异步线程中执行，主线程继续处理其他任务或者先行结束，再通过Future获取计算结果。</p><p>Future接口定义了操作异步任务执行一些方法，如获取异步任务的执行结果、取消任务的执行、判断任务是否被取消、判断任务执行是否完毕等。</p><h2 id="2-Future接口相关架构"><a href="#2-Future接口相关架构" class="headerlink" title="2. Future接口相关架构"></a>2. Future接口相关架构</h2><p><img src="https://raw.githubusercontent.com/GeorgeChan95/blogimg/master/img/2024/09/18/20240918-171237.png" alt="Future接口架构"></p><ul><li><p>目的：异步多线程任务执行且返回有结果，三个特点：多线程、有返回、异步任务（班长为老师去买水作为新启动的异步多线程任务且买到水有结果返回）</p></li><li><p>代码实现：Runnable接口+Callable接口+Future接口和FutureTask实现类。</p><pre><code class="highlight java"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">FutureTaskDemo3</span> &#123;    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> ExecutionException, InterruptedException &#123;        FutureTask&lt;String&gt; futureTask = <span class="keyword">new</span> <span class="title class_">FutureTask</span>&lt;&gt;(<span class="keyword">new</span> <span class="title class_">MyThread</span>());        <span class="type">Thread</span> <span class="variable">thread</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Thread</span>(futureTask, <span class="string">&quot;t1&quot;</span>);        <span class="comment">// 启动一个新的线程</span>        thread.start();        System.out.println(futureTask.get());    &#125;&#125;<span class="keyword">class</span> <span class="title class_">MyThread</span> <span class="keyword">implements</span> <span class="title class_">Callable</span>&lt;String&gt; &#123;    <span class="meta">@Override</span>    <span class="keyword">public</span> String <span class="title function_">call</span><span class="params">()</span> <span class="keyword">throws</span> Exception &#123;        System.out.println(Thread.currentThread().getName() + <span class="string">&quot; come in ......&quot;</span>);        <span class="keyword">return</span> <span class="string">&quot;Hello Callable&quot;</span>;    &#125;&#125;</code></pre></li></ul><h2 id="3-Future编码实战和优缺点分析"><a href="#3-Future编码实战和优缺点分析" class="headerlink" title="3. Future编码实战和优缺点分析"></a>3. Future编码实战和优缺点分析</h2><p><strong>优点</strong></p><p>Future+线程池异步多线程任务配合，能显著提高程序的运行效率。</p><p><strong>缺点</strong></p><ul><li>get() 阻塞—一旦调用get()方法求结果，一旦调用不见不散，非要等到结果才会离开，不管你是否计算完成，如果没有计算完成容易程序堵塞。</li></ul>  <pre><code class="highlight java"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">FutureTaskDemo1</span> &#123;    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> ExecutionException, InterruptedException, TimeoutException &#123;        FutureTask&lt;String&gt; futureTask = <span class="keyword">new</span> <span class="title class_">FutureTask</span>&lt;&gt;(() -&gt; &#123;            System.out.println(<span class="string">&quot;-----come in FutureTask&quot;</span>);            <span class="keyword">try</span> &#123;                TimeUnit.SECONDS.sleep(<span class="number">3</span>);            &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;                e.printStackTrace();            &#125;            <span class="keyword">return</span> <span class="string">&quot;&quot;</span> + ThreadLocalRandom.current().nextInt(<span class="number">100</span>);        &#125;);        <span class="type">Thread</span> <span class="variable">t1</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Thread</span>(futureTask, <span class="string">&quot;t1&quot;</span>);        t1.start();        <span class="comment">//3秒钟后才出来结果，还没有计算你提前来拿(只要一调用get方法，对于结果就是不见不散，会导致阻塞)</span>        <span class="comment">//System.out.println(Thread.currentThread().getName()+&quot;\t&quot;+futureTask.get());</span>        <span class="comment">//3秒钟后才出来结果，我只想等待1秒钟，过时不候</span>        System.out.println(Thread.currentThread().getName() + <span class="string">&quot;\t&quot;</span> + futureTask.get(<span class="number">1L</span>, TimeUnit.SECONDS));        System.out.println(Thread.currentThread().getName() + <span class="string">&quot;\t&quot;</span> + <span class="string">&quot; run... here&quot;</span>);    &#125;&#125;</code></pre><ul><li>isDone() 轮询—轮询的方式会耗费无谓的cpu资源，而且也不见得能及时得到计算结果，如果想要异步获取结果，通常会以轮询的方式去获取结果，尽量不要阻塞。</li></ul>  <pre><code class="highlight java"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">FutureTaskDemo2</span> &#123;    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> ExecutionException, InterruptedException &#123;        FutureTask&lt;String&gt; futureTask = <span class="keyword">new</span> <span class="title class_">FutureTask</span>&lt;&gt;(() -&gt; &#123;            System.out.println(<span class="string">&quot;-----come in FutureTask&quot;</span>);            <span class="keyword">try</span> &#123;                TimeUnit.SECONDS.sleep(<span class="number">3</span>);            &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;                e.printStackTrace();            &#125;            <span class="keyword">return</span> <span class="string">&quot;&quot;</span> + ThreadLocalRandom.current().nextInt(<span class="number">100</span>);        &#125;);        <span class="keyword">new</span> <span class="title class_">Thread</span>(futureTask, <span class="string">&quot;t1&quot;</span>).start();        System.out.println(Thread.currentThread().getName() + <span class="string">&quot;\t&quot;</span> + <span class="string">&quot;线程完成任务&quot;</span>);        <span class="comment">/**</span><span class="comment">         * 用于阻塞式获取结果,如果想要异步获取结果,通常都会以轮询的方式去获取结果</span><span class="comment">         */</span>        <span class="keyword">while</span> (<span class="literal">true</span>) &#123;            <span class="keyword">if</span> (futureTask.isDone()) &#123;                System.out.println(futureTask.get());                <span class="keyword">break</span>;            &#125;        &#125;    &#125;&#125;</code></pre><p><strong>结论：</strong>Future对于结果的获取不是很友好，只能通过阻塞或轮询的方式得到任务的结果。</p><h2 id="4-完成复杂的任务"><a href="#4-完成复杂的任务" class="headerlink" title="4. 完成复杂的任务"></a>4. 完成复杂的任务</h2><ul><li><p>回调通知（Future支持）</p><ul><li>应对Future的完成时间，完成了可以告诉我，也就是我们的回调通知</li><li>通过轮询的方式去判断任务是否完成这样非常占cpu并且代码也不优雅</li></ul></li><li><p>创建异步任务：Future+线程池组合</p><pre><code class="highlight java"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">FutureTaskDemo4</span> &#123;    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> ExecutionException, InterruptedException &#123;        <span class="comment">// 创建线程池</span>        <span class="type">ExecutorService</span> <span class="variable">executorService</span> <span class="operator">=</span> Executors.newFixedThreadPool(<span class="number">5</span>);                FutureTask&lt;String&gt; futureTask = <span class="keyword">new</span> <span class="title class_">FutureTask</span>&lt;&gt;(() -&gt; &#123;            System.out.println(Thread.currentThread().getName() + <span class="string">&quot;-----come in FutureTask&quot;</span>);            <span class="keyword">try</span> &#123;                TimeUnit.SECONDS.sleep(<span class="number">3</span>);            &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;                e.printStackTrace();            &#125;            <span class="keyword">return</span> <span class="string">&quot;&quot;</span> + ThreadLocalRandom.current().nextInt(<span class="number">100</span>);        &#125;);        <span class="comment">// 异步提交任务</span>        executorService.submit(futureTask);        System.out.println(Thread.currentThread().getName() + <span class="string">&quot;\t&quot;</span> + <span class="string">&quot;线程完成任务&quot;</span>);        <span class="comment">/**</span><span class="comment">         * 用于阻塞式获取结果,如果想要异步获取结果,通常都会以轮询的方式去获取结果</span><span class="comment">         */</span>        <span class="keyword">while</span> (<span class="literal">true</span>) &#123;            <span class="keyword">if</span> (futureTask.isDone()) &#123;                System.out.println(futureTask.get());                <span class="keyword">break</span>;            &#125;        &#125;        <span class="comment">// 关闭线程池</span>        executorService.shutdown();    &#125;&#125;</code></pre></li><li><p>多个任务前后依赖可以组合处理（Future不支持）</p><ul><li>想将多个异步任务的结果组合起来，后一个异步任务的计算结果需要前一个异步任务的值</li><li>想将两个或多个异步计算合并成为一个异步计算，这几个异步计算互相独立，同时后面这个又依赖前一个处理的结果</li></ul></li><li><p>对计算速度选最快的（Future不支持）</p><ul><li>当Future集合中某个任务最快结束时，返回结果，返回第一名处理结果</li></ul></li></ul><p><strong>结论</strong></p><ul><li>对于简单的业务场景使用 Future 完全 ok</li><li>对于复杂业务场景，使用 Future 之前提供的 API 处理起来不够优雅，这时候需要使用 CompletableFuture 以声明式的方式优雅的处理这些需求。</li><li>Future能干的，CompletableFuture 都能干</li></ul><h1 id="三、CompletableFuture对Future的改进"><a href="#三、CompletableFuture对Future的改进" class="headerlink" title="三、CompletableFuture对Future的改进"></a>三、CompletableFuture对Future的改进</h1><h2 id="1-CompletableFuture为什么会出现"><a href="#1-CompletableFuture为什么会出现" class="headerlink" title="1. CompletableFuture为什么会出现"></a>1. CompletableFuture为什么会出现</h2><ul><li>get() 方法在 Future 计算完成之前会一直处在阻塞状态下，阻塞的方式和异步编程的设计理念相违背。</li><li>isDone() 方法容易耗费 cpu 资源（cpu空转），</li><li>对于真正的异步处理我们希望是可以通过传入回调函数，在Future结束时自动调用该回调函数，这样，我们就不用等待结果</li></ul><p>jdk8 设计出 CompletableFuture，CompletableFuture 提供了一种观察者模式类似的机制，可以让任务执行完成后通知监听的一方。</p><h2 id="2-CompletableFuture-和-CompletionStage-介绍"><a href="#2-CompletableFuture-和-CompletionStage-介绍" class="headerlink" title="2. CompletableFuture 和 CompletionStage 介绍"></a>2. CompletableFuture 和 CompletionStage 介绍</h2><p><strong>类架构说明</strong>：</p><p><img src="https://raw.githubusercontent.com/GeorgeChan95/blogimg/master/img/2024/09/19/20240919-093123.png" alt="CompletableFuture"></p><p><img src="https://raw.githubusercontent.com/GeorgeChan95/blogimg/master/img/2024/09/19/20240919-093420.png" alt="CompletableFuture"></p><ul><li><strong>接口CompletionStage</strong><ul><li>代表异步计算过程中的某一个阶段，一个阶段完成以后可能会触发另外一个阶段。<ul><li>有些类似Linux系统的管道分隔符传参数</li></ul></li><li>一个阶段的执行可能是被单个阶段的完成触发，也可能是由多个阶段一起触发</li><li>一个阶段的计算执行可以是一个 function, Consumer 或者 Runnable。<ul><li>比如: <code>stage.thenApply(x -&gt; square(x).thenAccept(x -&gt; System.out.print(x)).thenRun(0)-&gt; system.out.println())</code></li></ul></li></ul></li><li><strong>类CompletableFuture</strong><ul><li>在Java8中，CompletableFuture 提供了非常强大的 Future 的扩展功能，可以帮助我们简化异步编程的复杂性，并且提供了函数式编程的能力，可以通过回调的方式处理计算结果，也提供了转换和组合 CompletableFuture 的方法,</li><li>它可能代表一个明确完成的 Future，也有可能代表一个完成阶段 (CompletionStage)，它支持在计算完成以后触发一些函数或执行某些动作。</li><li>它实现了 Future 和 CompletionStage 接口</li></ul></li></ul><h2 id="3-四个核心静态方法，创建异步任务"><a href="#3-四个核心静态方法，创建异步任务" class="headerlink" title="3. 四个核心静态方法，创建异步任务"></a>3. 四个核心静态方法，创建异步任务</h2><p>四个静态构造方法</p><p><img src="https://raw.githubusercontent.com/GeorgeChan95/blogimg/master/img/2024/09/19/20240919-094354.png" alt="CompletableFuture静态方法"></p><p><strong>对于上述Executor参数说明：若没有指定，则使用默认的 <code>ForkJoinPoolCommonPool()</code> 作为它的线程池执行异步代码，如果指定线程池，则使用我们自定义的或者特别指定的线程池执行异步代码</strong></p><h3 id="3-1-四个静态方法演示"><a href="#3-1-四个静态方法演示" class="headerlink" title="3.1 四个静态方法演示"></a>3.1 四个静态方法演示</h3><pre><code class="highlight java"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">CompletableFutureBuildDemo</span> &#123;    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> ExecutionException, InterruptedException &#123;        <span class="comment">// 自定义线程池</span>        <span class="type">ThreadPoolExecutor</span> <span class="variable">threadPoolExecutor</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ThreadPoolExecutor</span>(                <span class="number">1</span>,                <span class="number">20</span>,                <span class="number">1L</span>,                TimeUnit.SECONDS,                <span class="keyword">new</span> <span class="title class_">LinkedBlockingQueue</span>&lt;&gt;(<span class="number">50</span>),                Executors.defaultThreadFactory(),                <span class="keyword">new</span> <span class="title class_">ThreadPoolExecutor</span>.AbortPolicy());        <span class="comment">// 无返回值，默认线程池</span>        CompletableFuture&lt;Void&gt; future1 = CompletableFuture.runAsync(() -&gt; &#123;            <span class="keyword">try</span> &#123;                TimeUnit.SECONDS.sleep(<span class="number">1</span>);            &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;                <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">RuntimeException</span>(e);            &#125;            System.out.println(Thread.currentThread().getName() + <span class="string">&quot;无返回值，默认线程池：ForkJoinPool&quot;</span>);        &#125;);        System.out.println(<span class="string">&quot;future1 ==&gt; &quot;</span> + future1.get());        <span class="comment">/*</span><span class="comment">        * 打印：</span><span class="comment">        ForkJoinPool.commonPool-worker-1无返回值，默认线程池：ForkJoinPool</span><span class="comment">        future1 ==&gt; null</span><span class="comment">        * */</span>        System.out.println(<span class="string">&quot;----------------------------------------------------------&quot;</span>);        <span class="comment">// 无返回值，自定义线程池</span>        CompletableFuture&lt;Void&gt; future2 = CompletableFuture.runAsync(() -&gt; &#123;            <span class="keyword">try</span> &#123;                TimeUnit.SECONDS.sleep(<span class="number">1</span>);            &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;                <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">RuntimeException</span>(e);            &#125;            System.out.println(Thread.currentThread().getName() + <span class="string">&quot;无返回值，自定义线程池&quot;</span>);        &#125;, threadPoolExecutor);        System.out.println(<span class="string">&quot;future2 ==&gt; &quot;</span> + future2.get());        <span class="comment">/*</span><span class="comment">        * 打印：</span><span class="comment">        pool-1-thread-1无返回值，自定义线程池</span><span class="comment">        future2 ==&gt; null</span><span class="comment">        * */</span>        System.out.println(<span class="string">&quot;----------------------------------------------------------&quot;</span>);        CompletableFuture&lt;String&gt; future3 = CompletableFuture.supplyAsync(() -&gt; &#123;            <span class="keyword">try</span> &#123;                TimeUnit.SECONDS.sleep(<span class="number">1</span>);            &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;                <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">RuntimeException</span>(e);            &#125;            System.out.println(Thread.currentThread().getName() + <span class="string">&quot;有返回值，默认线程池：ForkJoinPool&quot;</span>);            <span class="keyword">return</span> <span class="string">&quot;有返回值，默认线程池：ForkJoinPool&quot;</span>;        &#125;);        System.out.println(<span class="string">&quot;future3 ==&gt; &quot;</span> + future3.get());        <span class="comment">/*</span><span class="comment">        * 打印：</span><span class="comment">        ForkJoinPool.commonPool-worker-1有返回值，默认线程池：ForkJoinPool</span><span class="comment">        future3 ==&gt; 有返回值，默认线程池：ForkJoinPool</span><span class="comment">        * */</span>        System.out.println(<span class="string">&quot;----------------------------------------------------------&quot;</span>);        CompletableFuture&lt;String&gt; future4 = CompletableFuture.supplyAsync(() -&gt; &#123;            <span class="keyword">try</span> &#123;                TimeUnit.SECONDS.sleep(<span class="number">1</span>);            &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;                <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">RuntimeException</span>(e);            &#125;            System.out.println(Thread.currentThread().getName() + <span class="string">&quot;有返回值，自定义线程池&quot;</span>);            <span class="keyword">return</span> <span class="string">&quot;有返回值，自定义线程池&quot;</span>;        &#125;, threadPoolExecutor);        System.out.println(<span class="string">&quot;future4 ==&gt; &quot;</span> + future4.get());        <span class="comment">/*</span><span class="comment">        * 打印：</span><span class="comment">        pool-1-thread-1有返回值，自定义线程池</span><span class="comment">        future4 ==&gt; 有返回值，自定义线程池</span><span class="comment">        * */</span>        <span class="comment">// 关闭线程池</span>        threadPoolExecutor.shutdown();    &#125;&#125;</code></pre><h3 id="3-2-回调方法演示"><a href="#3-2-回调方法演示" class="headerlink" title="3.2 回调方法演示"></a>3.2 回调方法演示</h3><p>CompletableFuture 减少阻塞和轮询，可以传入回调对象，当异步任务完成或者发生异常时，自动调用回调对象的回调方法。</p><pre><code class="highlight java"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">CompletableFutureUseDemo</span> &#123;    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> InterruptedException &#123;        <span class="comment">// 自定义线程池</span>        <span class="type">ThreadPoolExecutor</span> <span class="variable">threadPoolExecutor</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ThreadPoolExecutor</span>(<span class="number">1</span>,                <span class="number">20</span>,                <span class="number">1</span>,                TimeUnit.SECONDS,                <span class="keyword">new</span> <span class="title class_">LinkedBlockingQueue</span>&lt;&gt;(<span class="number">5</span>),                Executors.defaultThreadFactory(),                <span class="keyword">new</span> <span class="title class_">ThreadPoolExecutor</span>.AbortPolicy());        CompletableFuture&lt;Integer&gt; completableFuture = CompletableFuture.supplyAsync(() -&gt; &#123;            System.out.println(Thread.currentThread().getName() + <span class="string">&quot; 线程运行中...&quot;</span>);            <span class="type">int</span> <span class="variable">result</span> <span class="operator">=</span> ThreadLocalRandom.current().nextInt(<span class="number">10</span>);            <span class="keyword">try</span> &#123;                TimeUnit.SECONDS.sleep(<span class="number">1</span>);            &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;                <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">RuntimeException</span>(e);            &#125;            <span class="keyword">if</span> (result &gt; <span class="number">5</span>) &#123;                <span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">10</span> / <span class="number">0</span>;            &#125;            <span class="keyword">return</span> result;        &#125;, threadPoolExecutor).whenComplete((v, e) -&gt; &#123; <span class="comment">// 当计算完成时调用</span>            <span class="keyword">if</span> (e == <span class="literal">null</span>) &#123;                System.out.println(Thread.currentThread().getName() + <span class="string">&quot; 线程计算完成，结果为：&quot;</span> + v);            &#125;        &#125;).exceptionally(e -&gt; &#123;            e.printStackTrace();            <span class="type">String</span> <span class="variable">msg</span> <span class="operator">=</span> String.format(<span class="string">&quot;%s 线程计算出现异常，原因：%s, 错误信息：%s&quot;</span>, Thread.currentThread().getName(), e.getCause(), e.getMessage());            System.out.println(msg);            <span class="keyword">return</span> -<span class="number">1</span>;        &#125;);        System.out.println(Thread.currentThread().getName() + <span class="string">&quot; 线程先去完成其他任务&quot;</span>);        <span class="comment">// 线程不要立刻结束，否则CompletableFuture默认使用的线程池会立刻关闭：暂停3秒钟线程</span>        TimeUnit.SECONDS.sleep(<span class="number">2</span>);        <span class="comment">// 关闭自定义线程池</span>        threadPoolExecutor.shutdown();    &#125;&#125;<span class="comment">/*</span><span class="comment">无异常时打印如下：</span><span class="comment">pool-1-thread-1 线程运行中...</span><span class="comment">main 线程先去完成其他任务</span><span class="comment">pool-1-thread-1 线程计算完成，结果为：2</span><span class="comment">* */</span><span class="comment">/*</span><span class="comment">有异常时打印如下：</span><span class="comment">pool-1-thread-1 线程运行中...</span><span class="comment">main 线程先去完成其他任务</span><span class="comment">java.util.concurrent.CompletionException: java.lang.ArithmeticException: / by zero</span><span class="comment">at java.base/java.util.concurrent.CompletableFuture.encodeThrowable(CompletableFuture.java:315)</span><span class="comment">at java.base/java.util.concurrent.CompletableFuture.completeThrowable(CompletableFuture.java:320)</span><span class="comment">at java.base/java.util.concurrent.CompletableFuture$AsyncSupply.run(CompletableFuture.java:1770)</span><span class="comment">at java.base/java.util.concurrent.ThreadPoolExecutor.runWorker(ThreadPoolExecutor.java:1136)</span><span class="comment">at java.base/java.util.concurrent.ThreadPoolExecutor$Worker.run(ThreadPoolExecutor.java:635)</span><span class="comment">at java.base/java.lang.Thread.run(Thread.java:842)</span><span class="comment">Caused by: java.lang.ArithmeticException: / by zero</span><span class="comment">at com.atguigu.juc.cf.CompletableFutureUseDemo.lambda$main$0(CompletableFutureUseDemo.java:32)</span><span class="comment">at java.base/java.util.concurrent.CompletableFuture$AsyncSupply.run(CompletableFuture.java:1768)</span><span class="comment">... 3 more</span><span class="comment">pool-1-thread-1 线程计算出现异常，原因：java.lang.ArithmeticException: / by zero, 错误信息：java.lang.ArithmeticException: / by zero</span><span class="comment">* */</span></code></pre><p>CompletableFuture优点：</p><ul><li>异步任务<strong>结束</strong>时，会自动回调某个对象的方法</li><li>主线程设置好回调后，不用关心异步任务的执行，异步任务之间可以顺序执行</li><li>异步任务<strong>出错</strong>时，会自动回调某个对象的方法</li></ul><h1 id="四、函数式编程"><a href="#四、函数式编程" class="headerlink" title="四、函数式编程"></a>四、函数式编程</h1><p>Lambda表达式+Stream流式调用+Chain链式调用+Java8函数式编程</p><h2 id="1-函数式接口"><a href="#1-函数式接口" class="headerlink" title="1. 函数式接口"></a>1. 函数式接口</h2><ul><li><p>Runnable：无参数、无返回值</p><p><img src="https://raw.githubusercontent.com/GeorgeChan95/blogimg/master/img/2024/09/19/20240919-110244.png" alt="Runnable"></p></li><li><p>Function：接受一个参数，并且有返回值</p><p><img src="https://raw.githubusercontent.com/GeorgeChan95/blogimg/master/img/2024/09/19/20240919-110317.png" alt="Function"></p></li><li><p>Consumer：接受一个参数，没有返回值</p><p><img src="https://raw.githubusercontent.com/GeorgeChan95/blogimg/master/img/2024/09/19/20240919-110409.png" alt="Consumer"></p></li><li><p>BiConsumer：接受两个参数，没有返回值</p><p><img src="https://raw.githubusercontent.com/GeorgeChan95/blogimg/master/img/2024/09/19/20240919-110436.png" alt="BiConsumer"></p></li><li><p>Supplier：没有参数，有返回值</p><p><img src="https://raw.githubusercontent.com/GeorgeChan95/blogimg/master/img/2024/09/19/20240919-110455.png" alt="Supplier"></p></li></ul><p><strong>总结：</strong></p><table><thead><tr><th>函数式接口名称</th><th>方法名称</th><th>参数</th><th>返回值</th></tr></thead><tbody><tr><td>Runnable</td><td>run</td><td>无参数</td><td>无返回值</td></tr><tr><td>Function</td><td>apply</td><td>1个参数</td><td>有返回值</td></tr><tr><td>Consume</td><td>accept</td><td>1个参数</td><td>无返回值</td></tr><tr><td>Supplier</td><td>get</td><td>没有参数</td><td>有返回值</td></tr><tr><td>Biconsumer</td><td>accept</td><td>2个参数</td><td>无返回值</td></tr></tbody></table><h2 id="2-链式编程"><a href="#2-链式编程" class="headerlink" title="2. 链式编程"></a>2. 链式编程</h2><pre><code class="highlight java"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Chain</span> &#123;    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;        <span class="comment">//-------------------老式写法------------</span><span class="comment">//        Student student = new Student();</span><span class="comment">//        student.setId(1);</span><span class="comment">//        student.setMajor(&quot;cs&quot;);</span><span class="comment">//        student.setName(&quot;小卡&quot;);</span>        <span class="keyword">new</span> <span class="title class_">Student</span>().setId(<span class="number">1</span>).setName(<span class="string">&quot;大卡&quot;</span>).setMajor(<span class="string">&quot;cs&quot;</span>);    &#125;    &#125;<span class="meta">@NoArgsConstructor</span><span class="meta">@AllArgsConstructor</span><span class="meta">@Data</span><span class="meta">@Accessors(chain = true)</span><span class="comment">//开启链式编程</span><span class="keyword">class</span> <span class="title class_">Student</span>&#123;    <span class="keyword">private</span> <span class="type">int</span> id;    <span class="keyword">private</span> String name;    <span class="keyword">private</span> String major;&#125;</code></pre><h1 id="五、join-和-get-对比"><a href="#五、join-和-get-对比" class="headerlink" title="五、join 和 get 对比"></a>五、join 和 get 对比</h1><p>join 与 get 功能几乎一样，区别在于编码时是否需要抛出异常</p><ul><li>get() 方法需要抛出异常</li><li>join() 方法不需要抛出异常</li></ul><pre><code class="highlight java"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Chain</span> &#123;    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> ExecutionException, InterruptedException &#123; <span class="comment">//抛出异常</span>        CompletableFuture&lt;String&gt; completableFuture = CompletableFuture.supplyAsync(() -&gt; &#123;            <span class="keyword">return</span> <span class="string">&quot;hello 12345&quot;</span>;        &#125;);        System.out.println(completableFuture.get());    &#125;&#125;<span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Chain</span> &#123;    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span>  &#123;<span class="comment">// 不用抛出异常</span>        CompletableFuture&lt;String&gt; completableFuture = CompletableFuture.supplyAsync(() -&gt; &#123;            <span class="keyword">return</span> <span class="string">&quot;hello 12345&quot;</span>;        &#125;);        System.out.println(completableFuture.join());    &#125;&#125;</code></pre><h1 id="六、CompletableFuture-案例讲解"><a href="#六、CompletableFuture-案例讲解" class="headerlink" title="六、CompletableFuture 案例讲解"></a>六、CompletableFuture 案例讲解</h1><h2 id="1-需求说明"><a href="#1-需求说明" class="headerlink" title="1. 需求说明"></a>1. 需求说明</h2><p>电商网站比价需求分析：</p><ol><li><p>需求说明：</p></li><li><ol><li>同一款产品，同时搜索出同款产品在各大电商平台的售价</li><li>同一款产品，同时搜索出本产品在同一个电商平台下，各个入驻卖家售价是多少</li></ol></li><li><p>输出返回：</p></li><li><ol><li>出来结果希望是同款产品的在不同地方的价格清单列表，返回一个List<String></li></ol></li></ol><p>例如：《Mysql》 in jd price is 88.05  《Mysql》 in taobao price is 90.43</p><ol><li><p>解决方案，对比同一个产品在各个平台上的价格，要求获得一个清单列表</p></li><li><ol><li>step by step，按部就班，查完淘宝查京东，查完京东查天猫….</li><li>all in，万箭齐发，一口气多线程异步任务同时查询</li></ol></li></ol><h2 id="2-不使用多线程实现需求"><a href="#2-不使用多线程实现需求" class="headerlink" title="2. 不使用多线程实现需求"></a>2. 不使用多线程实现需求</h2><p>从不同的网站逐个查询，直到所有网站查询完成，返回结果。</p><pre><code class="highlight java"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">NetMallCase</span> &#123;    <span class="keyword">static</span> List&lt;NetMall&gt; list = Arrays.asList(            <span class="keyword">new</span> <span class="title class_">NetMall</span>(<span class="string">&quot;jd&quot;</span>),            <span class="keyword">new</span> <span class="title class_">NetMall</span>(<span class="string">&quot;pdd&quot;</span>),            <span class="keyword">new</span> <span class="title class_">NetMall</span>(<span class="string">&quot;taobao&quot;</span>),            <span class="keyword">new</span> <span class="title class_">NetMall</span>(<span class="string">&quot;dangdangwang&quot;</span>),            <span class="keyword">new</span> <span class="title class_">NetMall</span>(<span class="string">&quot;tmall&quot;</span>)    );    <span class="comment">/**</span><span class="comment">     * 不使用多线程，获取图书在不同平台的价格</span><span class="comment">     * <span class="doctag">@param</span> list</span><span class="comment">     * <span class="doctag">@param</span> productName</span><span class="comment">     * <span class="doctag">@return</span></span><span class="comment">     */</span>    <span class="keyword">public</span> <span class="keyword">static</span> List&lt;String&gt; <span class="title function_">getPriceByStep</span><span class="params">(List&lt;NetMall&gt; list, String productName)</span> &#123;        List&lt;String&gt; result = list.stream().map(netMall -&gt; &#123;            <span class="type">String</span> <span class="variable">str</span> <span class="operator">=</span> String.format(productName + <span class="string">&quot; in %s price is %.2f&quot;</span>, netMall.getMallName(), netMall.calcPrice(productName));            <span class="keyword">return</span> str;        &#125;).collect(Collectors.toList());        <span class="keyword">return</span> result;    &#125;    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;        <span class="type">long</span> <span class="variable">startTime</span> <span class="operator">=</span> System.currentTimeMillis();        List&lt;String&gt; resuts = getPriceByStep(list, <span class="string">&quot;mysql&quot;</span>);        <span class="keyword">for</span> (String data : resuts) &#123;            System.out.println(data);        &#125;        <span class="type">long</span> <span class="variable">endTime</span> <span class="operator">=</span> System.currentTimeMillis();        System.out.println(<span class="string">&quot;不使用多线程，costTime: &quot;</span> + (endTime - startTime) + <span class="string">&quot; 毫秒&quot;</span>);    &#125;&#125;<span class="keyword">class</span> <span class="title class_">NetMallData</span> &#123;    <span class="meta">@Getter</span>    <span class="keyword">private</span> String mallName;    <span class="keyword">public</span> <span class="title function_">NetMallData</span><span class="params">(String mallName)</span> &#123;        <span class="built_in">this</span>.mallName = mallName;    &#125;    <span class="keyword">public</span> <span class="type">double</span> <span class="title function_">calcPrice</span><span class="params">(String productName)</span> &#123;        <span class="comment">//检索需要1秒钟</span>        <span class="keyword">try</span> &#123;            TimeUnit.SECONDS.sleep(<span class="number">1</span>);        &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;            e.printStackTrace();        &#125;        <span class="keyword">return</span> ThreadLocalRandom.current().nextDouble() * <span class="number">2</span> + productName.charAt(<span class="number">0</span>);    &#125;&#125;</code></pre><p>执行结果：</p><pre><code class="highlight shell">mysql in jd price is 109.95mysql in pdd price is 109.86mysql in taobao price is 109.79mysql in dangdangwang price is 110.08mysql in tmall price is 110.55不使用多线程，costTime: 5070 毫秒</code></pre><p>多个查询逐个完成，执行效率低，执行时间长。</p><h2 id="3-使用-CompletableFuture-实现需求"><a href="#3-使用-CompletableFuture-实现需求" class="headerlink" title="3. 使用 CompletableFuture 实现需求"></a>3. 使用 CompletableFuture 实现需求</h2><pre><code class="highlight java"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">NetMallCase</span> &#123;    <span class="keyword">static</span> List&lt;NetMall&gt; list = Arrays.asList(            <span class="keyword">new</span> <span class="title class_">NetMall</span>(<span class="string">&quot;jd&quot;</span>),            <span class="keyword">new</span> <span class="title class_">NetMall</span>(<span class="string">&quot;pdd&quot;</span>),            <span class="keyword">new</span> <span class="title class_">NetMall</span>(<span class="string">&quot;taobao&quot;</span>),            <span class="keyword">new</span> <span class="title class_">NetMall</span>(<span class="string">&quot;dangdangwang&quot;</span>),            <span class="keyword">new</span> <span class="title class_">NetMall</span>(<span class="string">&quot;tmall&quot;</span>)    );    <span class="comment">/**</span><span class="comment">     * 不使用多线程，获取图书在不同平台的价格</span><span class="comment">     *</span><span class="comment">     * <span class="doctag">@param</span> list</span><span class="comment">     * <span class="doctag">@param</span> productName</span><span class="comment">     * <span class="doctag">@return</span></span><span class="comment">     */</span>    <span class="keyword">public</span> <span class="keyword">static</span> List&lt;String&gt; <span class="title function_">getPriceByStep</span><span class="params">(List&lt;NetMall&gt; list, String productName)</span> &#123;        List&lt;String&gt; result = list.stream().map(netMall -&gt; &#123;            <span class="type">String</span> <span class="variable">str</span> <span class="operator">=</span> String.format(productName + <span class="string">&quot; in %s price is %.2f&quot;</span>, netMall.getMallName(), netMall.calcPrice(productName));            <span class="keyword">return</span> str;        &#125;).collect(Collectors.toList());        <span class="keyword">return</span> result;    &#125;    <span class="comment">/**</span><span class="comment">     * 使用多线程异步的从不同平台获取图书价格</span><span class="comment">     *</span><span class="comment">     * <span class="doctag">@param</span> list</span><span class="comment">     * <span class="doctag">@param</span> productName</span><span class="comment">     * <span class="doctag">@return</span></span><span class="comment">     */</span>    <span class="keyword">public</span> <span class="keyword">static</span> List&lt;String&gt; <span class="title function_">getPriceByAsync</span><span class="params">(List&lt;NetMall&gt; list, String productName)</span> &#123;        List&lt;String&gt; results = list.stream().map(netMall -&gt;                        CompletableFuture.supplyAsync(() -&gt; String.format(productName + <span class="string">&quot; in %s price is %.2f&quot;</span>, netMall.getMallName(), netMall.calcPrice(productName))))                .collect(Collectors.toList())                .stream()                .map(CompletableFuture::join)                .collect(Collectors.toList());        <span class="keyword">return</span> results;    &#125;    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;        <span class="comment">// 使用异步多线程获取</span>        <span class="type">long</span> <span class="variable">startTime2</span> <span class="operator">=</span> System.currentTimeMillis();        List&lt;String&gt; resuts2 = getPriceByAsync(list, <span class="string">&quot;mysql&quot;</span>);        <span class="keyword">for</span> (String data : resuts2) &#123;            System.out.println(data);        &#125;        <span class="type">long</span> <span class="variable">endTime2</span> <span class="operator">=</span> System.currentTimeMillis();        System.out.println(<span class="string">&quot;使用异步多线程，costTime: &quot;</span> + (endTime2 - startTime2) + <span class="string">&quot; 毫秒&quot;</span>);    &#125;&#125;<span class="keyword">class</span> <span class="title class_">NetMallData</span> &#123;    <span class="meta">@Getter</span>    <span class="keyword">private</span> String mallName;    <span class="keyword">public</span> <span class="title function_">NetMallData</span><span class="params">(String mallName)</span> &#123;        <span class="built_in">this</span>.mallName = mallName;    &#125;    <span class="keyword">public</span> <span class="type">double</span> <span class="title function_">calcPrice</span><span class="params">(String productName)</span> &#123;        <span class="comment">//检索需要1秒钟</span>        <span class="keyword">try</span> &#123;            TimeUnit.SECONDS.sleep(<span class="number">1</span>);        &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;            e.printStackTrace();        &#125;        <span class="keyword">return</span> ThreadLocalRandom.current().nextDouble() * <span class="number">2</span> + productName.charAt(<span class="number">0</span>);    &#125;&#125;</code></pre><p>执行结果：</p><pre><code class="highlight shell">mysql in jd price is 110.91mysql in pdd price is 109.59mysql in taobao price is 109.30mysql in dangdangwang price is 110.85mysql in tmall price is 110.67使用异步多线程，costTime: 1056 毫秒</code></pre><p>使用异步多线程，执行效率大大提升。</p><h1 id="七、CompletableFuture-常用API"><a href="#七、CompletableFuture-常用API" class="headerlink" title="七、CompletableFuture 常用API"></a>七、CompletableFuture 常用API</h1><h2 id="1-获得结果和触发计算"><a href="#1-获得结果和触发计算" class="headerlink" title="1.获得结果和触发计算"></a>1.获得结果和触发计算</h2><ul><li><p>获取结果</p><ul><li><code>public T get()</code>  阻塞等待，直到得到返回结果</li><li><code>public T get(long timeout,TimeUnit unit)</code>  阻塞等待指定的时长，超时则报错：TimeOutException</li><li><code>public T join()</code>  类似于get()，区别在于不需要抛出异常</li><li><code>public T getNow(T valueIfAbsent)</code>  立即获取结果不阻塞<ul><li>计算完，返回计算完成后的结果</li><li>没算完，返回设定的valueAbsent(直接返回了备胎值xxx)</li></ul></li></ul></li><li><p>主动触发计算</p><ul><li><code>public boolean complete(T value)</code>  是否立即打断get()方法返回括号值<ul><li>(执行要2s，等待只有1s，所以还没执行完就被打断了。返回true表示打断了获取这个过程，直接返回了备胎值 complete；如果没打断，返回false 和原来的abc)</li></ul></li></ul><pre><code class="highlight java"><span class="comment">/**</span><span class="comment"> * 获得结果和触发计算</span><span class="comment"> *</span><span class="comment"> * <span class="doctag">@throws</span> InterruptedException</span><span class="comment"> * <span class="doctag">@throws</span> ExecutionException</span><span class="comment"> */</span><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">m1</span><span class="params">()</span> <span class="keyword">throws</span> InterruptedException, ExecutionException &#123;    <span class="type">ThreadPoolExecutor</span> <span class="variable">threadPoolExecutor</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ThreadPoolExecutor</span>(<span class="number">1</span>, <span class="number">20</span>, <span class="number">1L</span>, TimeUnit.SECONDS, <span class="keyword">new</span> <span class="title class_">LinkedBlockingQueue</span>&lt;&gt;(<span class="number">50</span>), Executors.defaultThreadFactory(), <span class="keyword">new</span> <span class="title class_">ThreadPoolExecutor</span>.AbortPolicy());    CompletableFuture&lt;Integer&gt; future = CompletableFuture.supplyAsync(() -&gt; &#123;        <span class="comment">//暂停几秒钟线程</span>        <span class="comment">//暂停几秒钟线程</span>        <span class="keyword">try</span> &#123;            TimeUnit.SECONDS.sleep(<span class="number">2</span>);        &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;            e.printStackTrace();        &#125;        <span class="keyword">return</span> <span class="number">1</span>;    &#125;, threadPoolExecutor);    <span class="comment">//System.out.println(future.get()); // 1</span>    <span class="comment">//System.out.println(future.get(2L,TimeUnit.SECONDS)); // 1</span>    <span class="comment">//暂停几秒钟线程</span>    <span class="keyword">try</span> &#123;        TimeUnit.SECONDS.sleep(<span class="number">1</span>);    &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;        e.printStackTrace();    &#125;    <span class="comment">//System.out.println(future.getNow(9999));</span>    System.out.println(future.complete(-<span class="number">44</span>) + <span class="string">&quot;\t&quot;</span> + future.get());        <span class="comment">// 关闭线程池</span>    threadPoolExecutor.shutdown();&#125;</code></pre><p>打印结果：</p><pre><code class="highlight shell">true-44</code></pre></li></ul><h2 id="2-对计算结果进行处理"><a href="#2-对计算结果进行处理" class="headerlink" title="2. 对计算结果进行处理"></a>2. 对计算结果进行处理</h2><ul><li><p><code>thenApply </code> 计算结果存在在依赖关系，使得线程串行化。因为依赖关系，所以一旦有异常，直接叫停。</p><pre><code class="highlight java"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">thenApplyDemo</span><span class="params">()</span> <span class="keyword">throws</span> InterruptedException &#123;    <span class="type">ThreadPoolExecutor</span> <span class="variable">threadPoolExecutor</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ThreadPoolExecutor</span>(<span class="number">1</span>, <span class="number">20</span>, <span class="number">1L</span>, TimeUnit.SECONDS, <span class="keyword">new</span> <span class="title class_">LinkedBlockingQueue</span>&lt;&gt;(<span class="number">50</span>), Executors.defaultThreadFactory(), <span class="keyword">new</span> <span class="title class_">ThreadPoolExecutor</span>.AbortPolicy());    CompletableFuture&lt;Integer&gt; completableFuture = CompletableFuture.supplyAsync(() -&gt; &#123;        <span class="type">int</span> <span class="variable">result</span> <span class="operator">=</span> ThreadLocalRandom.current().nextInt(<span class="number">10</span>);        <span class="keyword">try</span> &#123;            TimeUnit.SECONDS.sleep(<span class="number">1</span>);        &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;            <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">RuntimeException</span>(e);        &#125;        <span class="keyword">if</span> (result &gt; <span class="number">5</span>) &#123;            <span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">10</span> / <span class="number">0</span>;        &#125;        <span class="keyword">return</span> <span class="number">1</span>;    &#125;, threadPoolExecutor).thenApply(data -&gt; data + <span class="number">2</span>).whenComplete((v, e) -&gt; &#123;        <span class="keyword">if</span> (e == <span class="literal">null</span>) &#123;            System.out.println(<span class="string">&quot;执行完成，结果：&quot;</span> + v);        &#125;    &#125;).exceptionally(e -&gt; &#123;        e.printStackTrace();        <span class="type">String</span> <span class="variable">msg</span> <span class="operator">=</span> String.format(<span class="string">&quot;执行出现异常，原因：%s, 异常信息：%s&quot;</span>, e.getCause(), e.getMessage());        System.out.println(msg);        <span class="keyword">return</span> -<span class="number">1</span>;    &#125;);        System.out.println(<span class="string">&quot;执行结束，结果：&quot;</span> + completableFuture.join());    <span class="comment">// 关闭自定义线程池</span>    threadPoolExecutor.shutdown();    <span class="comment">// 主线程停留3秒</span>    TimeUnit.SECONDS.sleep(<span class="number">3</span>);&#125;</code></pre><p>正常执行结束打印：</p><pre><code class="highlight shell">执行完成，结果：3执行结束，结果：3</code></pre><p>异常执行结束打印：</p><pre><code class="highlight shell">java.util.concurrent.CompletionException: java.lang.ArithmeticException: / by zeroat java.util.concurrent.CompletableFuture.encodeThrowable(CompletableFuture.java:273)at java.util.concurrent.CompletableFuture.completeThrowable(CompletableFuture.java:280)at java.util.concurrent.CompletableFuture$AsyncSupply.run(CompletableFuture.java:1606)at java.util.concurrent.ThreadPoolExecutor.runWorker(ThreadPoolExecutor.java:1149)at java.util.concurrent.ThreadPoolExecutor$Worker.run(ThreadPoolExecutor.java:624)at java.lang.Thread.run(Thread.java:748)Caused by: java.lang.ArithmeticException: / by zeroat com.atguigu.juc.cf.CompletableFutureDemo.lambda$thenApplyDemo$0(CompletableFutureDemo.java:27)at java.util.concurrent.CompletableFuture$AsyncSupply.run(CompletableFuture.java:1604)... 3 more执行出现异常，原因：java.lang.ArithmeticException: / by zero, 异常信息：java.lang.ArithmeticException: / by zero执行结束，结果：-1</code></pre></li><li><p><code>handle </code> 类似于 thenApply，但是有异常的话仍然可以往下走一步。</p><pre><code class="highlight java"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">handleDemo</span><span class="params">()</span> <span class="keyword">throws</span> InterruptedException &#123;    <span class="comment">// 自定义线程池</span>    <span class="type">ThreadPoolExecutor</span> <span class="variable">threadPool</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ThreadPoolExecutor</span>(            <span class="number">4</span>,            <span class="number">5</span>,            <span class="number">50</span>,            TimeUnit.SECONDS,            <span class="keyword">new</span> <span class="title class_">LinkedBlockingQueue</span>&lt;&gt;(<span class="number">10</span>),            Executors.defaultThreadFactory(),            <span class="keyword">new</span> <span class="title class_">ThreadPoolExecutor</span>.AbortPolicy());    CompletableFuture.supplyAsync(() -&gt; &#123;        <span class="type">int</span> <span class="variable">result</span> <span class="operator">=</span> ThreadLocalRandom.current().nextInt(<span class="number">10</span>);        <span class="keyword">try</span> &#123;            TimeUnit.SECONDS.sleep(<span class="number">1</span>);        &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;            <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">RuntimeException</span>(e);        &#125;        <span class="keyword">if</span> (result &gt; <span class="number">5</span>) &#123;            <span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">10</span> / <span class="number">0</span>;        &#125;        <span class="keyword">return</span> <span class="number">10</span>;    &#125;, threadPool).handle((v, e) -&gt; &#123;        <span class="keyword">if</span> (e == <span class="literal">null</span>) &#123;            System.out.println(<span class="string">&quot;handle1执行完成，结果：&quot;</span> + v);        &#125; <span class="keyword">else</span> &#123;            System.out.println(<span class="string">&quot;handle1执行异常&quot;</span>);        &#125;        <span class="keyword">return</span> v + <span class="number">1</span>;    &#125;).handle((v, e) -&gt; &#123;        <span class="keyword">if</span> (e == <span class="literal">null</span>) &#123;            System.out.println(<span class="string">&quot;handle2执行完成，结果：&quot;</span> + v);        &#125; <span class="keyword">else</span> &#123;            System.out.println(<span class="string">&quot;handle2执行异常&quot;</span>);        &#125;        <span class="keyword">return</span> <span class="string">&quot;abc&quot;</span>;    &#125;).handle((v, e) -&gt; &#123;        <span class="keyword">if</span> (e == <span class="literal">null</span>) &#123;            System.out.println(<span class="string">&quot;handle3执行完成，结果：&quot;</span> + v);        &#125; <span class="keyword">else</span> &#123;            System.out.println(<span class="string">&quot;handle3执行异常&quot;</span>);        &#125;        <span class="keyword">return</span> <span class="string">&quot;xyz&quot;</span>;    &#125;).whenCompleteAsync((v, e) -&gt; &#123;        <span class="keyword">if</span> (e == <span class="literal">null</span>) &#123;            System.out.println(Thread.currentThread().getName() + <span class="string">&quot; whenComplete执行完成，结果：&quot;</span> + v);        &#125;    &#125;, threadPool).exceptionally(e -&gt; &#123;        e.printStackTrace();        <span class="type">String</span> <span class="variable">msg</span> <span class="operator">=</span> String.format(<span class="string">&quot;执行出现异常，原因：%s, 异常信息：%s&quot;</span>, e.getCause(), e.getMessage());        System.out.println(msg);        <span class="keyword">return</span> <span class="string">&quot;error&quot;</span>;    &#125;);    TimeUnit.SECONDS.sleep(<span class="number">5</span>);    <span class="comment">// 关闭线程池</span>    threadPool.shutdown();&#125;</code></pre><p>正常执行结束打印：</p><pre><code class="highlight shell">handle1执行完成，结果：10handle2执行完成，结果：11whenComplete执行完成，结果：abc</code></pre><p>异常执行结束打印：</p><pre><code class="highlight shell">handle1执行异常handle2执行异常handle3执行完成，结果：abcpool-1-thread-2 whenComplete执行完成，结果：xyz</code></pre><p><strong>注意：</strong>当 <code>supplyAsync</code> 方法执行异常时， 程序依然往下走，经过了 <code>handle1</code>、<code>handle2</code>、<code>handle3</code> ，而没有经过 <code>exceptionally</code> ，当 <code>handle3</code> 出现异常时（在<code>whenCompleteAsync</code> 上方的方法），才会经过 <code>exceptionally</code> 方法</p></li></ul><p><strong>thenApply 在实际工作中最常用</strong></p><h2 id="3-对计算结果进行消费"><a href="#3-对计算结果进行消费" class="headerlink" title="3. 对计算结果进行消费"></a>3. 对计算结果进行消费</h2><p>接收任务的处理结果，并消费处理，<strong>无返回结果|消费型函数式接口</strong>，之前的是Function</p><ul><li><p>thenAccept</p><ul><li>thenAccept(Consumer action)</li><li>任务A执行完执行B，B需要A的结果，但是任务B无返回值</li></ul><pre><code class="highlight java">System.out.println(CompletableFuture.supplyAsync(() -&gt; <span class="string">&quot;resultA&quot;</span>).thenAccept(r -&gt; System.out.println(r)).join());</code></pre></li><li><p>thenRun</p><ul><li>thenRun(Runnable runnable)</li><li>任务A执行完执行B，并且B不需要A的结果</li></ul><pre><code class="highlight java">System.out.println(CompletableFuture.supplyAsync(() -&gt; <span class="string">&quot;resultA&quot;</span>).thenRun(() -&gt; &#123;&#125;).join());</code></pre></li><li><p>thenApply</p><ul><li>thenApply(Function fn)</li><li>任务A执行完执行B，B需要A的结果，同时任务B有返回值</li></ul><pre><code class="highlight java">System.out.println(CompletableFuture.supplyAsync(() -&gt; <span class="string">&quot;resultA&quot;</span>).thenApply(resultA -&gt; resultA + <span class="string">&quot; resultB&quot;</span>).join());</code></pre></li></ul><p>示例代码：</p><pre><code class="highlight java"><span class="comment">/**</span><span class="comment"> * 对计算结果进行消费</span><span class="comment"> */</span><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">m3</span><span class="params">()</span> &#123;    CompletableFuture.supplyAsync(() -&gt; &#123;        <span class="keyword">return</span> <span class="number">1</span>;    &#125;).thenApply(f -&gt; &#123;        <span class="keyword">return</span> f + <span class="number">2</span>;    &#125;).thenApply(f -&gt; &#123;        <span class="keyword">return</span> f + <span class="number">3</span>;    &#125;).thenAccept(r -&gt; System.out.println(r));    <span class="comment">// 任务A执行完执行B，并且B不需要A的结果, 且B无返回值</span>    System.out.println(CompletableFuture.supplyAsync(() -&gt; <span class="string">&quot;resultA&quot;</span>).thenRun(() -&gt; &#123;&#125;).join());    <span class="comment">// 任务A执行完执行B，B需要A的结果，但是任务B无返回值</span>    System.out.println(CompletableFuture.supplyAsync(() -&gt; <span class="string">&quot;resultA&quot;</span>).thenAccept(r -&gt; System.out.println(r)).join());    <span class="comment">// 任务A执行完执行B，B需要A的结果，同时任务B有返回值</span>    System.out.println(CompletableFuture.supplyAsync(() -&gt; <span class="string">&quot;resultA&quot;</span>).thenApply(resultA -&gt; resultA + <span class="string">&quot; resultB&quot;</span>).join());&#125;</code></pre><h2 id="4-CompleteFuture和线程池说明（非常重要）"><a href="#4-CompleteFuture和线程池说明（非常重要）" class="headerlink" title="4. CompleteFuture和线程池说明（非常重要）"></a>4. CompleteFuture和线程池说明（非常重要）</h2><p>上面的几个方法都有普通版本和后面加<strong>Async</strong>的版本, 例如：<code>thenRun</code>、<code>thenRunAsync</code>、<code>thenApply</code>、<code>thenApplyAsync</code>、<code>whenComplete</code>、<code>whenCompleteAsync</code> ……</p><p>以 <code>thenRun</code>和<code>thenRunAsync</code>为例，有什么区别？</p><ul><li><p><code>thenRun</code> 没有传入自定义线程池，使用默认线程池 ForkJoinPool</p></li><li><p><code>thenRunAsync</code>可传入一个自定义线程池</p><ul><li>如果你执行第一个任务的时候，传入了一个自定义线程池，调用<code>thenRun</code>方法执行第二个任务的时候，则第二个任务和第一个任务是用同一个线程池。</li><li>调用<code>thenRunAsync</code>执行第二个任务的时候，则第一个任务使用的是你自己传入的线程池，第二个任务使用的是 <strong>ForkJoin线程池</strong></li></ul></li><li><p>特殊情况，任务处理太快，系统优化切换原则，直接使用main线程处理</p></li><li><p>thenRun 代码示例</p><pre><code class="highlight plaintext">private static void m7() throws InterruptedException &#123;    ThreadPoolExecutor threadPoolExecutor = new ThreadPoolExecutor(1, 20, 1L, TimeUnit.SECONDS, new LinkedBlockingQueue&lt;&gt;(50), Executors.defaultThreadFactory(), new ThreadPoolExecutor.AbortPolicy());    CompletableFuture&lt;Void&gt; completableFuture = CompletableFuture.supplyAsync(()-&gt;&#123;        try &#123;TimeUnit.MILLISECONDS.sleep(20);&#125; catch (InterruptedException e) &#123;e.printStackTrace();&#125;        System.out.println(&quot;1号任务&quot;+&quot;\t&quot;+Thread.currentThread().getName());        return &quot;abcd&quot;;    &#125;,threadPoolExecutor).thenRun(()-&gt;&#123;        try &#123;TimeUnit.MILLISECONDS.sleep(20);&#125; catch (InterruptedException e) &#123;e.printStackTrace();&#125;        System.out.println(&quot;2号任务&quot;+&quot;\t&quot;+Thread.currentThread().getName());    &#125;).thenRun(()-&gt;&#123;        try &#123;TimeUnit.MILLISECONDS.sleep(20);&#125; catch (InterruptedException e) &#123;e.printStackTrace();&#125;        System.out.println(&quot;3号任务&quot;+&quot;\t&quot;+Thread.currentThread().getName());    &#125;).thenRun(()-&gt;&#123;        try &#123;TimeUnit.MILLISECONDS.sleep(20);&#125; catch (InterruptedException e) &#123;e.printStackTrace();&#125;        System.out.println(&quot;4号任务&quot;+&quot;\t&quot;+Thread.currentThread().getName());    &#125;);    Thread.sleep(2000);    threadPoolExecutor.shutdown();&#125;</code></pre><p>  运行结果：</p><pre><code class="highlight shell">1号任务pool-1-thread-12号任务pool-1-thread-13号任务pool-1-thread-14号任务pool-1-thread-1</code></pre></li><li><p>thenRunAsync 代码示例</p><pre><code class="highlight java"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">m7</span><span class="params">()</span> <span class="keyword">throws</span> InterruptedException &#123;    <span class="type">ThreadPoolExecutor</span> <span class="variable">threadPoolExecutor</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ThreadPoolExecutor</span>(<span class="number">1</span>, <span class="number">20</span>, <span class="number">1L</span>, TimeUnit.SECONDS, <span class="keyword">new</span> <span class="title class_">LinkedBlockingQueue</span>&lt;&gt;(<span class="number">50</span>), Executors.defaultThreadFactory(), <span class="keyword">new</span> <span class="title class_">ThreadPoolExecutor</span>.AbortPolicy());    CompletableFuture&lt;Void&gt; completableFuture = CompletableFuture.supplyAsync(()-&gt;&#123;        <span class="keyword">try</span> &#123;TimeUnit.MILLISECONDS.sleep(<span class="number">20</span>);&#125; <span class="keyword">catch</span> (InterruptedException e) &#123;e.printStackTrace();&#125;        System.out.println(<span class="string">&quot;1号任务&quot;</span>+<span class="string">&quot;\t&quot;</span>+Thread.currentThread().getName());        <span class="keyword">return</span> <span class="string">&quot;abcd&quot;</span>;    &#125;,threadPoolExecutor).thenRunAsync(()-&gt;&#123;        <span class="keyword">try</span> &#123;TimeUnit.MILLISECONDS.sleep(<span class="number">20</span>);&#125; <span class="keyword">catch</span> (InterruptedException e) &#123;e.printStackTrace();&#125;        System.out.println(<span class="string">&quot;2号任务&quot;</span>+<span class="string">&quot;\t&quot;</span>+Thread.currentThread().getName());    &#125;).thenRun(()-&gt;&#123;        <span class="keyword">try</span> &#123;TimeUnit.MILLISECONDS.sleep(<span class="number">20</span>);&#125; <span class="keyword">catch</span> (InterruptedException e) &#123;e.printStackTrace();&#125;        System.out.println(<span class="string">&quot;3号任务&quot;</span>+<span class="string">&quot;\t&quot;</span>+Thread.currentThread().getName());    &#125;).thenRun(()-&gt;&#123;        <span class="keyword">try</span> &#123;TimeUnit.MILLISECONDS.sleep(<span class="number">20</span>);&#125; <span class="keyword">catch</span> (InterruptedException e) &#123;e.printStackTrace();&#125;        System.out.println(<span class="string">&quot;4号任务&quot;</span>+<span class="string">&quot;\t&quot;</span>+Thread.currentThread().getName());    &#125;);    Thread.sleep(<span class="number">2000</span>);    threadPoolExecutor.shutdown();&#125;</code></pre><p>运行结果：</p><pre><code class="highlight shell">1号任务pool-1-thread-12号任务ForkJoinPool.commonPool-worker-253号任务ForkJoinPool.commonPool-worker-254号任务ForkJoinPool.commonPool-worker-25</code></pre></li><li><p>特殊情况, 直接使用main线程处理</p><pre><code class="highlight java"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">m7</span><span class="params">()</span> <span class="keyword">throws</span> InterruptedException &#123;    <span class="type">ThreadPoolExecutor</span> <span class="variable">threadPoolExecutor</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ThreadPoolExecutor</span>(<span class="number">1</span>, <span class="number">20</span>, <span class="number">1L</span>, TimeUnit.SECONDS, <span class="keyword">new</span> <span class="title class_">LinkedBlockingQueue</span>&lt;&gt;(<span class="number">50</span>), Executors.defaultThreadFactory(), <span class="keyword">new</span> <span class="title class_">ThreadPoolExecutor</span>.AbortPolicy());    CompletableFuture&lt;Void&gt; completableFuture = CompletableFuture.supplyAsync(()-&gt;&#123;<span class="comment">//        try &#123;TimeUnit.MILLISECONDS.sleep(20);&#125; catch (InterruptedException e) &#123;e.printStackTrace();&#125;</span>        System.out.println(<span class="string">&quot;1号任务&quot;</span>+<span class="string">&quot;\t&quot;</span>+Thread.currentThread().getName());        <span class="keyword">return</span> <span class="string">&quot;abcd&quot;</span>;    &#125;,threadPoolExecutor).thenRunAsync(()-&gt;&#123;<span class="comment">//        try &#123;TimeUnit.MILLISECONDS.sleep(20);&#125; catch (InterruptedException e) &#123;e.printStackTrace();&#125;</span>        System.out.println(<span class="string">&quot;2号任务&quot;</span>+<span class="string">&quot;\t&quot;</span>+Thread.currentThread().getName());    &#125;).thenRun(()-&gt;&#123;<span class="comment">//        try &#123;TimeUnit.MILLISECONDS.sleep(20);&#125; catch (InterruptedException e) &#123;e.printStackTrace();&#125;</span>        System.out.println(<span class="string">&quot;3号任务&quot;</span>+<span class="string">&quot;\t&quot;</span>+Thread.currentThread().getName());    &#125;).thenRun(()-&gt;&#123;<span class="comment">//        try &#123;TimeUnit.MILLISECONDS.sleep(20);&#125; catch (InterruptedException e) &#123;e.printStackTrace();&#125;</span>        System.out.println(<span class="string">&quot;4号任务&quot;</span>+<span class="string">&quot;\t&quot;</span>+Thread.currentThread().getName());    &#125;);    Thread.sleep(<span class="number">2000</span>);    threadPoolExecutor.shutdown();&#125;</code></pre><p> 运行结果：</p><pre><code class="highlight shell">1号任务pool-1-thread-12号任务ForkJoinPool.commonPool-worker-253号任务main4号任务main</code></pre></li></ul><h2 id="5-对计算速度进行选用"><a href="#5-对计算速度进行选用" class="headerlink" title="5. 对计算速度进行选用"></a>5. 对计算速度进行选用</h2><ul><li>applyToEither 优先选择运行速度快的任务的结果</li></ul><pre><code class="highlight java"><span class="comment">/**</span><span class="comment"> * 对计算速度进行选用</span><span class="comment"> */</span><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">m4</span><span class="params">()</span> &#123;    System.out.println(CompletableFuture.supplyAsync(() -&gt; &#123;        <span class="comment">//暂停几秒钟线程</span>        <span class="keyword">try</span> &#123;            TimeUnit.SECONDS.sleep(<span class="number">1</span>);        &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;            e.printStackTrace();        &#125;        <span class="keyword">return</span> <span class="number">1</span>;    &#125;).applyToEither(CompletableFuture.supplyAsync(() -&gt; &#123;        <span class="keyword">try</span> &#123;            TimeUnit.SECONDS.sleep(<span class="number">2</span>);        &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;            e.printStackTrace();        &#125;        <span class="keyword">return</span> <span class="number">2</span>;    &#125;), r -&gt; &#123;        <span class="keyword">return</span> r;    &#125;).join());    <span class="comment">//暂停几秒钟线程</span>    <span class="keyword">try</span> &#123;        TimeUnit.SECONDS.sleep(<span class="number">3</span>);    &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;        e.printStackTrace();    &#125;&#125;</code></pre><p>运行结果：</p><pre><code class="highlight shell">1</code></pre><h2 id="6-对计算结果进行合并"><a href="#6-对计算结果进行合并" class="headerlink" title="6. 对计算结果进行合并"></a>6. 对计算结果进行合并</h2><ul><li><p><code>thenCombine</code> 合并</p><ul><li>两个 <code>CompletionStage</code> 任务都完成后，最终能把两个任务的结果一起交给 <code>thenCombine</code> 来处理</li><li>先完成的先等着，等待其它分支任务</li></ul><pre><code class="highlight java"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">m5</span><span class="params">()</span> <span class="keyword">throws</span> ExecutionException, InterruptedException &#123;    CompletableFuture&lt;Integer&gt; thenCombineResult = CompletableFuture.supplyAsync(() -&gt; &#123;        System.out.println(Thread.currentThread().getName() + <span class="string">&quot;\t&quot;</span> + <span class="string">&quot;---come in 1&quot;</span>);        <span class="keyword">return</span> <span class="number">10</span>;    &#125;).thenCombine(CompletableFuture.supplyAsync(() -&gt; &#123;        System.out.println(Thread.currentThread().getName() + <span class="string">&quot;\t&quot;</span> + <span class="string">&quot;---come in 2&quot;</span>);        <span class="keyword">return</span> <span class="number">20</span>;    &#125;), (x, y) -&gt; &#123;        System.out.println(Thread.currentThread().getName() + <span class="string">&quot;\t&quot;</span> + <span class="string">&quot;---come in 3&quot;</span>);        <span class="keyword">return</span> x + y;    &#125;).thenCombine(CompletableFuture.supplyAsync(() -&gt; &#123;        System.out.println(Thread.currentThread().getName() + <span class="string">&quot;\t&quot;</span> + <span class="string">&quot;---come in 4&quot;</span>);        <span class="keyword">return</span> <span class="number">30</span>;    &#125;), (a, b) -&gt; &#123;        System.out.println(Thread.currentThread().getName() + <span class="string">&quot;\t&quot;</span> + <span class="string">&quot;---come in 5&quot;</span>);        <span class="keyword">return</span> a + b;    &#125;);    System.out.println(<span class="string">&quot;-----主线程结束，END&quot;</span>);    System.out.println(thenCombineResult.get());    <span class="comment">// 主线程不要立刻结束，否则CompletableFuture默认使用的线程池会立刻关闭:</span>    <span class="keyword">try</span> &#123;        TimeUnit.SECONDS.sleep(<span class="number">10</span>);    &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;        e.printStackTrace();    &#125;&#125;</code></pre><p>打印结果：</p><pre><code class="highlight shell">ForkJoinPool.commonPool-worker-25---come in 1ForkJoinPool.commonPool-worker-25---come in 2main---come in 3ForkJoinPool.commonPool-worker-18---come in 4main---come in 5-----主线程结束，END60</code></pre></li></ul>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;一、Future接口概述&quot;&gt;&lt;a href=&quot;#一、Future接口概述&quot; class=&quot;headerlink&quot; title=&quot;一、Future接口概述&quot;&gt;&lt;/a&gt;一、Future接口概述&lt;/h1&gt;&lt;p&gt;Future接口（FutureTask实现类）定义了操作异步</summary>
      
    
    
    
    <category term="JUC" scheme="https://georgechan95.github.io/categories/JUC/"/>
    
    
    <category term="java" scheme="https://georgechan95.github.io/tags/java/"/>
    
    <category term="juc" scheme="https://georgechan95.github.io/tags/juc/"/>
    
  </entry>
  
  <entry>
    <title>01-JUC进阶-线程基础</title>
    <link href="https://georgechan95.github.io/blog/3d102971.html"/>
    <id>https://georgechan95.github.io/blog/3d102971.html</id>
    <published>2024-09-18T14:32:00.000Z</published>
    <updated>2024-09-18T08:10:02.284Z</updated>
    
    <content type="html"><![CDATA[<h1 id="一、Java多线程相关概念"><a href="#一、Java多线程相关概念" class="headerlink" title="一、Java多线程相关概念"></a>一、Java多线程相关概念</h1><ul><li><p><strong>进程</strong></p><p>是程序的⼀次执⾏，是系统进⾏资源分配和调度的独⽴单位，每⼀个进程都有它⾃⼰的内存空间和系统资源</p></li><li><p><strong>线程</strong></p><ul><li>在同⼀个进程内⼜可以执⾏多个任务，⽽这每⼀个任务我们就可以看做是⼀个线程</li><li>⼀个进程会有1个或多个线程的</li></ul></li><li><p><strong>管程</strong></p><p>Monitor(监视器)，也就是我们平时所说的锁</p><p>Monitor其实是一种同步机制，他的义务是保证（同一时间）只有一个线程可以访问被保护的数据和代码。</p><p>JVM中同步是基于进入和退出监视器对象(Monitor,管程对象)来实现的，每个对象实例都会有一个Monitor对象，</p><pre><code class="highlight java"><span class="type">Object</span> <span class="variable">o</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Object</span>();<span class="keyword">new</span> <span class="title class_">Thread</span>(() -&gt; &#123;    <span class="keyword">synchronized</span> (o)    &#123;    &#125;&#125;,<span class="string">&quot;t1&quot;</span>).start();</code></pre><p>Monitor对象会和Java对象一同创建并销毁，它底层是由C++语言来实现的。</p></li></ul><p><img src="https://raw.githubusercontent.com/GeorgeChan95/blogimg/master/img/2024/09/18/20240918-153629.png" alt="同步指令"></p><h1 id="二、用户线程和守护线程"><a href="#二、用户线程和守护线程" class="headerlink" title="二、用户线程和守护线程"></a>二、用户线程和守护线程</h1><p>Java线程分为用户线程和守护线程，<strong>线程的daemon属性为true表示是守护线程，false表示是用户线程</strong></p><ul><li><p>守护线程</p><p>是一种特殊的线程，在后台默默地完成一些系统性的服务，比如垃圾回收线程</p></li><li><p>用户线程</p><p>是系统的工作线程，它会完成这个程序需要完成的业务操作</p></li></ul><p><strong>代码示例：</strong></p><pre><code class="highlight java"><span class="comment">/**</span><span class="comment"> * &lt;p&gt;</span><span class="comment"> * 演示守护线程和用户线程</span><span class="comment"> * &lt;/p&gt;</span><span class="comment"> */</span><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">DaemonDemo</span> &#123;    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;        <span class="type">Thread</span> <span class="variable">a</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Thread</span>(() -&gt; &#123;            System.out.println(Thread.currentThread().getName() + <span class="string">&quot; come in：\t&quot;</span>                    + (Thread.currentThread().isDaemon() ? <span class="string">&quot;守护线程&quot;</span> : <span class="string">&quot;用户线程&quot;</span>));            <span class="keyword">while</span> (<span class="literal">true</span>) &#123;            &#125;        &#125;, <span class="string">&quot;a&quot;</span>);        a.setDaemon(<span class="literal">true</span>); <span class="comment">// daemon设置为true，表示该线程为守护线程</span>        <span class="comment">// setDaemon 必须在 start() 方法之前</span>        a.start();        <span class="comment">//暂停几秒钟线程</span>        <span class="keyword">try</span> &#123;            TimeUnit.SECONDS.sleep(<span class="number">2</span>);        &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;            e.printStackTrace();        &#125;        System.out.println(Thread.currentThread().getName() + <span class="string">&quot;\t&quot;</span> + <span class="string">&quot; ----task is over&quot;</span>);    &#125;&#125;</code></pre><p>运行结果：</p><pre><code class="highlight shell">a come in：守护线程main ----task is over</code></pre><p>结论：当主线程(用户线程)结束后，守护线程也随之结束了。</p><p><strong>重点</strong></p><ul><li><p>当程序中所有用户线程执行完毕之后，不管守护线程是否结束，系统都会自动退出</p><p>如果用户线程全部结束了，意味着程序需要完成的业务操作已经结束了，系统可以退出了。所以当系统只剩下守护进程的时候，java虚拟机会自动退出</p></li><li><p>设置守护线程，需要在start()方法之前进行</p></li></ul>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;一、Java多线程相关概念&quot;&gt;&lt;a href=&quot;#一、Java多线程相关概念&quot; class=&quot;headerlink&quot; title=&quot;一、Java多线程相关概念&quot;&gt;&lt;/a&gt;一、Java多线程相关概念&lt;/h1&gt;&lt;ul&gt;
&lt;li&gt;&lt;p&gt;&lt;strong&gt;进程&lt;/stron</summary>
      
    
    
    
    <category term="JUC" scheme="https://georgechan95.github.io/categories/JUC/"/>
    
    
    <category term="java" scheme="https://georgechan95.github.io/tags/java/"/>
    
    <category term="juc" scheme="https://georgechan95.github.io/tags/juc/"/>
    
  </entry>
  
  <entry>
    <title>11-CompletableFuture</title>
    <link href="https://georgechan95.github.io/blog/37d56d14.html"/>
    <id>https://georgechan95.github.io/blog/37d56d14.html</id>
    <published>2024-09-16T08:12:00.000Z</published>
    <updated>2024-09-18T07:30:50.861Z</updated>
    
    <content type="html"><![CDATA[<h1 id="一、CompletableFuture-简介"><a href="#一、CompletableFuture-简介" class="headerlink" title="一、CompletableFuture 简介"></a>一、CompletableFuture 简介</h1><p>CompletableFuture 在 Java 里面被用于异步编程，异步通常意味着非阻塞，可以使得我们的任务单独运行在与主线程分离的其他线程中，并且通过回调可以在主线程中得到异步任务的执行状态，是否完成，和是否异常等信息。</p><p>CompletableFuture 实现了 Future, CompletionStage 接口，实现了 Future接口就可以兼容现在有线程池框架，而 CompletionStage 接口才是异步编程的接口抽象，里面定义多种异步方法，通过这两者集合，从而打造出了强大的 CompletableFuture 类。</p><h1 id="二、Future-与-CompletableFuture"><a href="#二、Future-与-CompletableFuture" class="headerlink" title="二、Future 与 CompletableFuture"></a>二、Future 与 CompletableFuture</h1><p>Futrue 在 Java 里面，通常用来表示一个异步任务的引用，比如我们将任务提交到线程池里面，然后我们会得到一个 Futrue，在 Future 里面有 isDone 方法来 判断任务是否处理结束，还有 get 方法可以一直阻塞直到任务结束然后获取结果，但整体来说这种方式，还是同步的，因为需要客户端不断阻塞等待或者不断轮询才能知道任务是否完成。</p><p><strong>Future 的主要缺点如下：</strong></p><ul><li><p>不支持手动完成</p><p>我提交了一个任务，但是执行太慢了，我通过其他路径已经获取到了任务结果，现在没法把这个任务结果通知到正在执行的线程，所以必须主动取消或者一直等待它执行完成</p></li><li><p>不支持进一步的非阻塞调用</p><p>通过 Future 的 get 方法会一直阻塞到任务完成，但是想在获取任务之后执行额外的任务，因为 Future 不支持回调函数，所以无法实现这个功能</p></li><li><p>不支持链式调用</p><p>对于 Future 的执行结果，我们想继续传到下一个 Future 处理使用，从而形成一个链式的 pipline 调用，这在 Future 中是没法实现的。</p></li><li><p>不支持多个 Future 合并</p><p>比如我们有 10 个 Future 并行执行，我们想在所有的 Future 运行完毕之后，执行某些函数，是没法通过 Future 实现的。</p></li><li><p>不支持异常处理</p><p>Future 的 API 没有任何的异常处理的 api，所以在异步运行时，如果出了问题是不好定位的。</p></li></ul><h1 id="三、CompletableFuture-入门"><a href="#三、CompletableFuture-入门" class="headerlink" title="三、CompletableFuture 入门"></a>三、CompletableFuture 入门</h1><h2 id="1-使用-CompletableFuture"><a href="#1-使用-CompletableFuture" class="headerlink" title="1. 使用 CompletableFuture"></a>1. 使用 CompletableFuture</h2><p>场景:主线程里面创建一个 CompletableFuture，然后主线程调用 get 方法会阻塞，最后我们在一个子线程中使其终止。</p><pre><code class="highlight java"><span class="comment">/**</span><span class="comment"> * 主线程里面创建一个 CompletableFuture，然后主线程调用 get 方法会阻塞，最后我们在一个子线程中使其终止</span><span class="comment"> *</span><span class="comment"> * <span class="doctag">@throws</span> InterruptedException</span><span class="comment"> * <span class="doctag">@throws</span> ExecutionException</span><span class="comment"> */</span><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">method1</span><span class="params">()</span> <span class="keyword">throws</span> InterruptedException, ExecutionException &#123;    CompletableFuture&lt;String&gt; future = <span class="keyword">new</span> <span class="title class_">CompletableFuture</span>&lt;&gt;();    <span class="keyword">new</span> <span class="title class_">Thread</span>(() -&gt; &#123;        <span class="keyword">try</span> &#123;            System.out.println(Thread.currentThread().getName() + <span class="string">&quot;子线程开始干活&quot;</span>);            <span class="comment">//子线程睡 5 秒</span>            Thread.sleep(<span class="number">5000</span>);            <span class="comment">//在子线程中完成主线程</span>            future.complete(<span class="string">&quot;success&quot;</span>);        &#125; <span class="keyword">catch</span> (Exception e) &#123;            e.printStackTrace();        &#125;    &#125;, <span class="string">&quot;A&quot;</span>).start();    <span class="comment">//主线程调用 get 方法阻塞</span>    System.out.println(<span class="string">&quot;主线程调用 get 方法获取结果为: &quot;</span> + future.get());    System.out.println(<span class="string">&quot;主线程完成,阻塞结束!!!!!!&quot;</span>);&#125;</code></pre><p>打印结果:</p><pre><code class="highlight shell">A子线程开始干活主线程调用 get 方法获取结果为: success主线程完成,阻塞结束!!!!!!</code></pre><h2 id="2-没有返回值的异步任务"><a href="#2-没有返回值的异步任务" class="headerlink" title="2. 没有返回值的异步任务"></a>2. 没有返回值的异步任务</h2><pre><code class="highlight java"><span class="comment">/**</span><span class="comment">    * 没有返回值的异步任务</span><span class="comment">    *</span><span class="comment">    * <span class="doctag">@throws</span> InterruptedException</span><span class="comment">    * <span class="doctag">@throws</span> ExecutionException</span><span class="comment">    */</span>   <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">method2</span><span class="params">()</span> <span class="keyword">throws</span> InterruptedException, ExecutionException &#123;       CompletableFuture&lt;Void&gt; future = <span class="keyword">new</span> <span class="title class_">CompletableFuture</span>&lt;&gt;();       <span class="keyword">new</span> <span class="title class_">Thread</span>(() -&gt; &#123;           <span class="keyword">try</span> &#123;               System.out.println(Thread.currentThread().getName() + <span class="string">&quot;开始作业&quot;</span>);               TimeUnit.SECONDS.sleep(<span class="number">5</span>);               System.out.println(Thread.currentThread().getName() + <span class="string">&quot; 完成作业&quot;</span>);           &#125; <span class="keyword">catch</span> (Exception e) &#123;               e.printStackTrace();           &#125;       &#125;, <span class="string">&quot;线程1&quot;</span>).start();       <span class="comment">//主线程调用 get 方法阻塞</span>       future.get();       System.out.println(<span class="string">&quot;主线程结束&quot;</span>);   &#125;</code></pre><p>运行结果:</p><pre><code class="highlight shell">线程1开始作业线程1 完成作业</code></pre><h2 id="3-有返回值的异步任务"><a href="#3-有返回值的异步任务" class="headerlink" title="3. 有返回值的异步任务"></a>3. 有返回值的异步任务</h2><pre><code class="highlight java"><span class="comment">/**</span><span class="comment"> * 有返回值的异步任务</span><span class="comment"> *</span><span class="comment"> * <span class="doctag">@throws</span> InterruptedException</span><span class="comment"> * <span class="doctag">@throws</span> ExecutionException</span><span class="comment"> */</span><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">method3</span><span class="params">()</span> <span class="keyword">throws</span> InterruptedException, ExecutionException &#123;    CompletableFuture&lt;String&gt; future = CompletableFuture.supplyAsync(<span class="keyword">new</span> <span class="title class_">Supplier</span>&lt;String&gt;() &#123;        <span class="meta">@Override</span>        <span class="keyword">public</span> String <span class="title function_">get</span><span class="params">()</span> &#123;            <span class="keyword">try</span> &#123;                System.out.println(Thread.currentThread().getName() + <span class="string">&quot;开始作业&quot;</span>);                TimeUnit.SECONDS.sleep(<span class="number">5</span>);                System.out.println(Thread.currentThread().getName() + <span class="string">&quot; 完成作业&quot;</span>);            &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;                e.printStackTrace();            &#125;            <span class="keyword">return</span> <span class="string">&quot;异步结果&quot;</span>;        &#125;    &#125;);    <span class="comment">//主线程调用 get 方法阻塞</span>    future.get();    System.out.println(<span class="string">&quot;主线程结束&quot;</span>);&#125;</code></pre><p><strong>运行结果:</strong></p><pre><code class="highlight shell">ForkJoinPool.commonPool-worker-19开始作业ForkJoinPool.commonPool-worker-19 完成作业主线程结束</code></pre><h2 id="4-线程依赖"><a href="#4-线程依赖" class="headerlink" title="4. 线程依赖"></a>4. 线程依赖</h2><p>当一个线程依赖另一个线程时，可以使用 thenApply 方法来把这两个线程串行化。</p><pre><code class="highlight java"><span class="keyword">private</span> <span class="keyword">static</span> <span class="type">int</span> <span class="variable">num</span> <span class="operator">=</span> <span class="number">0</span>;<span class="comment">/**</span><span class="comment"> * 线程依赖</span><span class="comment"> * 先对一个数加 10,然后取平方</span><span class="comment"> * <span class="doctag">@throws</span> InterruptedException</span><span class="comment"> * <span class="doctag">@throws</span> ExecutionException</span><span class="comment"> */</span><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">method4</span><span class="params">()</span> <span class="keyword">throws</span> InterruptedException, ExecutionException &#123;    CompletableFuture&lt;Integer&gt; future = CompletableFuture.supplyAsync(() -&gt; &#123;        System.out.println(Thread.currentThread().getName() + <span class="string">&quot;开始对值进行 +10 操作&quot;</span>);        num += <span class="number">10</span>;        System.out.println(Thread.currentThread().getName() + <span class="string">&quot; 完成作业&quot;</span>);        <span class="keyword">return</span> num;    &#125;).thenApply(<span class="keyword">new</span> <span class="title class_">Function</span>&lt;Integer, Integer&gt;() &#123;        <span class="meta">@Override</span>        <span class="keyword">public</span> Integer <span class="title function_">apply</span><span class="params">(Integer data)</span> &#123;            System.out.println(Thread.currentThread().getName() + <span class="string">&quot;开始对值进行 取平方 操作&quot;</span>);            System.out.println(<span class="string">&quot;integer: &quot;</span> + data);            <span class="keyword">return</span> data*data;        &#125;    &#125;);    <span class="comment">//主线程调用 get 方法阻塞</span>    System.out.println(<span class="string">&quot;主线程阻塞获取结果,结果为:&quot;</span> + future.get());    System.out.println(<span class="string">&quot;主线程结束&quot;</span>);&#125;</code></pre><p>运行结果:</p><pre><code class="highlight shell">ForkJoinPool.commonPool-worker-19开始对值进行 +10 操作ForkJoinPool.commonPool-worker-19 完成作业ForkJoinPool.commonPool-worker-19开始对值进行 取平方 操作integer: 10主线程阻塞获取结果,结果为:100主线程结束</code></pre><h2 id="5-消费处理结果"><a href="#5-消费处理结果" class="headerlink" title="5. 消费处理结果"></a>5. 消费处理结果</h2><p>thenAccept 消费处理结果, 接收任务的处理结果，并消费处理，无返回结果。</p><pre><code class="highlight java"><span class="comment">/**</span><span class="comment"> * thenAccept 消费处理结果, 接收任务的处理结果，并消费处理，无返回结果。</span><span class="comment"> * </span><span class="comment"> * <span class="doctag">@throws</span> InterruptedException</span><span class="comment"> * <span class="doctag">@throws</span> ExecutionException</span><span class="comment"> */</span><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">method5</span><span class="params">()</span> <span class="keyword">throws</span> InterruptedException, ExecutionException &#123;    CompletableFuture&lt;Void&gt; completableFuture = CompletableFuture.supplyAsync(() -&gt; &#123;        System.out.println(Thread.currentThread().getName() + <span class="string">&quot;开始对值进行 +10 操作&quot;</span>);        num += <span class="number">10</span>;        System.out.println(Thread.currentThread().getName() + <span class="string">&quot; 完成作业&quot;</span>);        <span class="keyword">return</span> num;    &#125;).thenApply(data -&gt; &#123;        System.out.println(Thread.currentThread().getName() + <span class="string">&quot;开始对值进行 取平方 操作&quot;</span>);        System.out.println(<span class="string">&quot;integer: &quot;</span> + data);        <span class="keyword">return</span> data * data;    &#125;).thenAccept(integer -&gt; &#123;        System.out.println(<span class="string">&quot;子线程全部处理完成,最后调用了 accept,结果为:&quot;</span> + integer);    &#125;);    <span class="comment">//主线程调用 get 方法阻塞</span>    System.out.println(<span class="string">&quot;主线程阻塞获取结果,结果为:&quot;</span> + completableFuture.get());    System.out.println(<span class="string">&quot;主线程结束&quot;</span>);&#125;</code></pre><p>运行结果:</p><pre><code class="highlight shell">ForkJoinPool.commonPool-worker-19开始对值进行 +10 操作ForkJoinPool.commonPool-worker-19 完成作业ForkJoinPool.commonPool-worker-19开始对值进行 取平方 操作integer: 10子线程全部处理完成,最后调用了 accept,结果为:100主线程阻塞获取结果,结果为:null主线程结束</code></pre><h2 id="6-异常处理"><a href="#6-异常处理" class="headerlink" title="6. 异常处理"></a>6. 异常处理</h2><p>exceptionally 异常处理,出现异常时触发</p><pre><code class="highlight java"><span class="comment">/**</span><span class="comment"> * exceptionally 异常处理,出现异常时触发</span><span class="comment"> * <span class="doctag">@throws</span> InterruptedException</span><span class="comment"> * <span class="doctag">@throws</span> ExecutionException</span><span class="comment"> */</span><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">method6</span><span class="params">()</span> <span class="keyword">throws</span> InterruptedException, ExecutionException &#123;    CompletableFuture&lt;Integer&gt; completableFuture = CompletableFuture.supplyAsync(() -&gt; &#123;        <span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">1</span> / <span class="number">0</span>;        System.out.println(Thread.currentThread().getName() + <span class="string">&quot;开始对值进行 +10 操作&quot;</span>);        num += <span class="number">10</span>;        System.out.println(Thread.currentThread().getName() + <span class="string">&quot; 完成作业&quot;</span>);        <span class="keyword">return</span> num;    &#125;).exceptionally(throwable -&gt; &#123;        System.out.println(throwable.getMessage());        <span class="keyword">return</span> -<span class="number">1</span>;    &#125;);    <span class="comment">//主线程调用 get 方法阻塞</span>    System.out.println(<span class="string">&quot;主线程阻塞获取结果,结果为:&quot;</span> + completableFuture.get());    System.out.println(<span class="string">&quot;主线程结束&quot;</span>);&#125;</code></pre><p>执行结果:</p><pre><code class="highlight shell">java.lang.ArithmeticException: / by zero主线程阻塞获取结果,结果为:-1主线程结束</code></pre><p><strong>handle 类似于 thenAccept&#x2F;thenRun 方法,是最后一步的处理调用,但是同时可以处理异常</strong></p><pre><code class="highlight java"><span class="comment">/**</span><span class="comment"> * handle 类似于 thenAccept/thenRun 方法,是最后一步的处理调用,但是同时可以处理异常</span><span class="comment"> */</span><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">method7</span><span class="params">()</span> &#123;    System.out.println(<span class="string">&quot;主线程开始&quot;</span>);    CompletableFuture&lt;Integer&gt; future = CompletableFuture.supplyAsync(() -&gt; &#123;        System.out.println(<span class="string">&quot;加 10 任务开始&quot;</span>);        num += <span class="number">10</span>;        <span class="keyword">return</span> num;    &#125;).handle((i, ex) -&gt; &#123;        System.out.println(<span class="string">&quot;进入 handle 方法&quot;</span>);        <span class="keyword">if</span> (ex != <span class="literal">null</span>) &#123;            System.out.print(<span class="string">&quot;发生了异常,内容为:&quot;</span>);            System.out.println(ex.getMessage());            <span class="keyword">return</span> -<span class="number">1</span>;        &#125; <span class="keyword">else</span> &#123;            System.out.println(<span class="string">&quot;正常完成,内容为: &quot;</span> + i);            <span class="keyword">return</span> i;        &#125;    &#125;);&#125;</code></pre><p>运行结果:</p><pre><code class="highlight shell">主线程开始加 10 任务开始进入 handle 方法正常完成,内容为: 10</code></pre><p>发生异常时:</p><pre><code class="highlight shell">主线程开始加 10 任务开始进入 handle 方法发生了异常,内容为:java.lang.ArithmeticException: / by zero</code></pre><h2 id="7-结果合并"><a href="#7-结果合并" class="headerlink" title="7. 结果合并"></a>7. 结果合并</h2><p><strong>thenCompose 合并两个有依赖关系的 CompletableFutures 的执行结果.</strong></p><pre><code class="highlight java"><span class="comment">/**</span><span class="comment"> * thenCompose 合并两个有依赖关系的 CompletableFutures 的执行结果</span><span class="comment"> * <span class="doctag">@throws</span> ExecutionException</span><span class="comment"> * <span class="doctag">@throws</span> InterruptedException</span><span class="comment"> */</span><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">method8</span><span class="params">()</span> <span class="keyword">throws</span> ExecutionException, InterruptedException &#123;    System.out.println(<span class="string">&quot;主线程开始......&quot;</span>);    <span class="comment">//第一步加 10</span>    CompletableFuture&lt;Integer&gt; future1 = CompletableFuture.supplyAsync(() -&gt; &#123;        System.out.println(Thread.currentThread().getName() + <span class="string">&quot;线程执行num加10&quot;</span>);        num += <span class="number">10</span>;        <span class="keyword">return</span> num;    &#125;);    <span class="comment">// 合并</span>    CompletableFuture&lt;Integer&gt; future2 = future1.thenCompose(data -&gt; CompletableFuture.supplyAsync(() -&gt; &#123;        System.out.println(Thread.currentThread().getName() + <span class="string">&quot;线程执行合并&quot;</span>);        <span class="keyword">return</span> data + <span class="number">1</span>;    &#125;));    System.out.println(<span class="string">&quot;主线程阻塞获取结果: &quot;</span> + future1.get());    System.out.println(<span class="string">&quot;主线程阻塞获取结果: &quot;</span> + future2.get());&#125;</code></pre><p>执行结果:</p><pre><code class="highlight shell">主线程开始......ForkJoinPool.commonPool-worker-19线程执行num加10ForkJoinPool.commonPool-worker-5线程执行合并主线程阻塞获取结果: 10主线程阻塞获取结果: 11</code></pre><p><strong>thenCombine 合并两个没有依赖关系的 CompletableFutures 任务</strong></p><pre><code class="highlight java"><span class="comment">/**</span><span class="comment"> * thenCombine 合并两个没有依赖关系的 CompletableFutures 任务</span><span class="comment"> * <span class="doctag">@throws</span> ExecutionException</span><span class="comment"> * <span class="doctag">@throws</span> InterruptedException</span><span class="comment"> */</span><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">method9</span><span class="params">()</span> <span class="keyword">throws</span> ExecutionException, InterruptedException &#123;    System.out.println(<span class="string">&quot;主线程开始......&quot;</span>);    <span class="comment">//第一个线程加 10</span>    CompletableFuture&lt;Integer&gt; future1 = CompletableFuture.supplyAsync(() -&gt; &#123;        System.out.println(Thread.currentThread().getName() + <span class="string">&quot;线程执行num加10&quot;</span>);        num += <span class="number">10</span>;        <span class="keyword">return</span> num;    &#125;);    <span class="comment">// 第二个线程 *10</span>    CompletableFuture&lt;Integer&gt; future2 = CompletableFuture.supplyAsync(() -&gt; &#123;        System.out.println(Thread.currentThread().getName() + <span class="string">&quot;线程执行num * 10&quot;</span>);        num *= <span class="number">10</span>;        <span class="keyword">return</span> num;    &#125;);    <span class="comment">// 合并两个CompletableFuture</span>    CompletableFuture&lt;Object&gt; combine = future1.thenCombine(future2, (a, b) -&gt; &#123;        List&lt;Integer&gt; list = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();        list.add(a);        list.add(b);        <span class="keyword">return</span> list;    &#125;);    System.out.println(<span class="string">&quot;主线程阻塞获取future1结果: &quot;</span> + future1.get());    System.out.println(<span class="string">&quot;主线程阻塞获取future2结果: &quot;</span> + future2.get());    System.out.println(<span class="string">&quot;主线程阻塞获取combine结果: &quot;</span> + combine.get());&#125;</code></pre><p>执行结果:</p><pre><code class="highlight shell">主线程开始......ForkJoinPool.commonPool-worker-19线程执行num加10ForkJoinPool.commonPool-worker-5线程执行num * 10主线程阻塞获取future1结果: 10主线程阻塞获取future2结果: 100主线程阻塞获取combine结果: [10, 100]</code></pre><p><strong>合并多个任务的结果 allOf 与 anyOf</strong></p><p><strong>allOf:</strong>  一系列独立的 future 任务，等其所有的任务执行完后做一些事情</p><pre><code class="highlight java"><span class="comment">/**</span><span class="comment"> * allOf: 一系列独立的 future 任务，等其所有的任务执行完后做一些事情</span><span class="comment"> */</span><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">method10</span><span class="params">()</span> &#123;    System.out.println(<span class="string">&quot;主线程开始&quot;</span>);    List&lt;CompletableFuture&gt; list = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();    CompletableFuture&lt;Integer&gt; job1 = CompletableFuture.supplyAsync(() -&gt; &#123;        System.out.println(<span class="string">&quot;加 10 任务开始&quot;</span>);        num += <span class="number">10</span>;        <span class="keyword">return</span> num;    &#125;);    list.add(job1);    CompletableFuture&lt;Integer&gt; job2 = CompletableFuture.supplyAsync(() -&gt; &#123;        System.out.println(<span class="string">&quot;乘以 10 任务开始&quot;</span>);        num = num * <span class="number">10</span>;        <span class="keyword">return</span> num;    &#125;);    list.add(job2);    CompletableFuture&lt;Integer&gt; job3 = CompletableFuture.supplyAsync(() -&gt; &#123;        System.out.println(<span class="string">&quot;减以 10 任务开始&quot;</span>);        num = num * <span class="number">10</span>;        <span class="keyword">return</span> num;    &#125;);    list.add(job3);    CompletableFuture&lt;Integer&gt; job4 = CompletableFuture.supplyAsync(() -&gt; &#123;        System.out.println(<span class="string">&quot;除以 10 任务开始&quot;</span>);        num = num * <span class="number">10</span>;        <span class="keyword">return</span> num;    &#125;);    list.add(job4);    <span class="comment">//多任务合并</span>    List&lt;Integer&gt; collect =            list.stream().map(CompletableFuture&lt;Integer&gt;::join).collect(Collectors.toList());    System.out.println(<span class="string">&quot;所有任务执行结束,结果为: &quot;</span> + collect);&#125;</code></pre><p>运行结果:</p><pre><code class="highlight shell">主线程开始乘以 10 任务开始加 10 任务开始减以 10 任务开始除以 10 任务开始所有任务执行结束,结果为: [10, 0, 100, 1000]</code></pre><p><strong>anyOf</strong>: 只要在多个 future 里面有一个返回，整个任务就可以结束，而不需要等到每一个future 结束</p><pre><code class="highlight java"><span class="comment">/**</span><span class="comment"> * anyOf: 只要在多个 future 里面有一个返回，整个任务就可以结束，而不需要等到每一个future 结束</span><span class="comment"> * <span class="doctag">@throws</span> ExecutionException</span><span class="comment"> * <span class="doctag">@throws</span> InterruptedException</span><span class="comment"> */</span><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">method11</span><span class="params">()</span> <span class="keyword">throws</span> ExecutionException, InterruptedException &#123;    System.out.println(<span class="string">&quot;主线程开始&quot;</span>);    CompletableFuture&lt;Integer&gt;[] futures = <span class="keyword">new</span> <span class="title class_">CompletableFuture</span>[<span class="number">4</span>];    CompletableFuture&lt;Integer&gt; job1 = CompletableFuture.supplyAsync(() -&gt; &#123;        System.out.println(<span class="string">&quot;加 10 任务开始&quot;</span>);        num += <span class="number">10</span>;        <span class="keyword">return</span> num;    &#125;);    futures[<span class="number">0</span>] = job1;    CompletableFuture&lt;Integer&gt; job2 = CompletableFuture.supplyAsync(() -&gt; &#123;        System.out.println(<span class="string">&quot;乘以 10 任务开始&quot;</span>);        num = num * <span class="number">10</span>;        <span class="keyword">return</span> num;    &#125;);    futures[<span class="number">1</span>] = job2;    CompletableFuture&lt;Integer&gt; job3 = CompletableFuture.supplyAsync(() -&gt; &#123;        System.out.println(<span class="string">&quot;减以 10 任务开始&quot;</span>);        num = num * <span class="number">10</span>;        <span class="keyword">return</span> num;    &#125;);    futures[<span class="number">2</span>] = job3;    CompletableFuture&lt;Integer&gt; job4 = CompletableFuture.supplyAsync(() -&gt; &#123;        System.out.println(<span class="string">&quot;除以 10 任务开始&quot;</span>);        num = num * <span class="number">10</span>;        <span class="keyword">return</span> num;    &#125;);    futures[<span class="number">3</span>] = job4;    CompletableFuture&lt;Object&gt; future = CompletableFuture.anyOf(futures);    System.out.println(future.get());    System.out.println(<span class="string">&quot;其中一个任务执行结束,结果为: &quot;</span> + future.get());&#125;</code></pre><p>执行结果:</p><pre><code class="highlight shell">主线程开始乘以 10 任务开始加 10 任务开始减以 10 任务开始10除以 10 任务开始其中一个任务执行结束,结果为: 10</code></pre>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;一、CompletableFuture-简介&quot;&gt;&lt;a href=&quot;#一、CompletableFuture-简介&quot; class=&quot;headerlink&quot; title=&quot;一、CompletableFuture 简介&quot;&gt;&lt;/a&gt;一、CompletableFuture </summary>
      
    
    
    
    <category term="JUC" scheme="https://georgechan95.github.io/categories/JUC/"/>
    
    
    <category term="java" scheme="https://georgechan95.github.io/tags/java/"/>
    
    <category term="juc" scheme="https://georgechan95.github.io/tags/juc/"/>
    
  </entry>
  
  <entry>
    <title>10-Fork/Join</title>
    <link href="https://georgechan95.github.io/blog/31919959.html"/>
    <id>https://georgechan95.github.io/blog/31919959.html</id>
    <published>2024-09-16T05:10:00.000Z</published>
    <updated>2024-09-18T07:30:50.861Z</updated>
    
    <content type="html"><![CDATA[<h1 id="一、Fork-Join-框架简介"><a href="#一、Fork-Join-框架简介" class="headerlink" title="一、Fork&#x2F;Join 框架简介"></a>一、Fork&#x2F;Join 框架简介</h1><p>Fork&#x2F;Join 它可以将一个大的任务拆分成多个子任务进行并行处理，最后将子任务结果合并成最后的计算结果，并进行输出。Fork&#x2F;Join 框架要完成两件事情：</p><p><strong>Fork：把一个复杂任务进行分拆，大事化小</strong></p><p><strong>Join：把分拆任务的结果进行合并</strong></p><p><img src="https://raw.githubusercontent.com/GeorgeChan95/blogimg/master/img/2024/09/16/20240916-150030.png" alt="任务拆分"></p><ul><li><strong>任务分割：</strong>首先 Fork&#x2F;Join 框架需要把大的任务分割成足够小的子任务，如果子任务比较大的话还要对子任务进行继续分割</li><li><strong>执行任务并合并结果：</strong>分割的子任务分别放到双端队列里，然后几个启动线程分别从双端队列里获取任务执行。子任务执行完的结果都放在另外一个队列里，启动一个线程从队列里取数据，然后合并这些数据。</li></ul><p>在 Java 的 Fork&#x2F;Join 框架中，使用两个类完成上述操作</p><ul><li><strong>ForkJoinTask:</strong> 我们要使用 Fork&#x2F;Join 框架，首先需要创建一个 ForkJoin 任务。该类提供了在任务中执行 fork 和 join 的机制。通常情况下我们不需要直接集成 ForkJoinTask 类，只需要继承它的子类，Fork&#x2F;Join 框架提供了两个子类：<ul><li>RecursiveAction：用于没有返回结果的任务</li><li>RecursiveTask: 用于有返回结果的任务</li></ul></li><li><strong>ForkJoinPool</strong>: ForkJoinTask 需要通过 ForkJoinPool 来执行</li><li><strong>RecursiveTask</strong>: 继承后可以实现递归(自己调自己)调用的任务</li></ul><p><strong>Fork&#x2F;Join 框架的实现原理</strong></p><p>ForkJoinPool 由 ForkJoinTask 数组和 ForkJoinWorkerThread 数组组成，ForkJoinTask 数组负责将存放以及将程序提交给 ForkJoinPool，而ForkJoinWorkerThread 负责执行这些任务。</p><h1 id="二、Fork-方法"><a href="#二、Fork-方法" class="headerlink" title="二、Fork 方法"></a>二、Fork 方法</h1><p><img src="https://raw.githubusercontent.com/GeorgeChan95/blogimg/master/img/2024/09/16/20240916-150946.png" alt="ForkJoinPool继承体系"></p><p><img src="https://raw.githubusercontent.com/GeorgeChan95/blogimg/master/img/2024/09/16/20240916-151158.png" alt="ForkJoinTask继承体系"></p><p><strong>Fork 方法的实现原理：</strong> 当我们调用 ForkJoinTask 的 fork 方法时，程序会把任务放在 ForkJoinWorkerThread 的 pushTask 的 workQueue 中，异步地执行这个任务，然后立即返回结果. </p><pre><code class="highlight java"><span class="comment">/**</span><span class="comment"> * Arranges to asynchronously execute this task in the pool the</span><span class="comment"> * current task is running in, if applicable, or using the &#123;<span class="doctag">@link</span></span><span class="comment"> * ForkJoinPool#commonPool()&#125; if not &#123;<span class="doctag">@link</span> #inForkJoinPool&#125;.  While</span><span class="comment"> * it is not necessarily enforced, it is a usage error to fork a</span><span class="comment"> * task more than once unless it has completed and been</span><span class="comment"> * reinitialized.  Subsequent modifications to the state of this</span><span class="comment"> * task or any data it operates on are not necessarily</span><span class="comment"> * consistently observable by any thread other than the one</span><span class="comment"> * executing it unless preceded by a call to &#123;<span class="doctag">@link</span> #join&#125; or</span><span class="comment"> * related methods, or a call to &#123;<span class="doctag">@link</span> #isDone&#125; returning &#123;<span class="doctag">@code</span></span><span class="comment"> * true&#125;.</span><span class="comment"> *</span><span class="comment"> * <span class="doctag">@return</span> &#123;<span class="doctag">@code</span> this&#125;, to simplify usage</span><span class="comment"> */</span><span class="keyword">public</span> <span class="keyword">final</span> ForkJoinTask&lt;V&gt; <span class="title function_">fork</span><span class="params">()</span> &#123;    Thread t;    <span class="keyword">if</span> ((t = Thread.currentThread()) <span class="keyword">instanceof</span> ForkJoinWorkerThread)        ((ForkJoinWorkerThread)t).workQueue.push(<span class="built_in">this</span>);    <span class="keyword">else</span>        ForkJoinPool.common.externalPush(<span class="built_in">this</span>);    <span class="keyword">return</span> <span class="built_in">this</span>;&#125;</code></pre><p>pushTask 方法把当前任务存放在 ForkJoinTask 数组队列里。然后再调用ForkJoinPool 的 signalWork()方法唤醒或创建一个工作线程来执行任务。代码如下：</p><pre><code class="highlight java"><span class="comment">/**</span><span class="comment"> * Pushes a task. Call only by owner in unshared queues.</span><span class="comment"> *</span><span class="comment"> * <span class="doctag">@param</span> task the task. Caller must ensure non-null.</span><span class="comment"> * <span class="doctag">@throws</span> RejectedExecutionException if array cannot be resized</span><span class="comment"> */</span><span class="keyword">final</span> <span class="keyword">void</span> <span class="title function_">push</span><span class="params">(ForkJoinTask&lt;?&gt; task)</span> &#123;    ForkJoinTask&lt;?&gt;[] a;    <span class="type">int</span> <span class="variable">s</span> <span class="operator">=</span> top, d, cap, m;    <span class="type">ForkJoinPool</span> <span class="variable">p</span> <span class="operator">=</span> pool;    <span class="keyword">if</span> ((a = array) != <span class="literal">null</span> &amp;&amp; (cap = a.length) &gt; <span class="number">0</span>) &#123;        QA.setRelease(a, (m = cap - <span class="number">1</span>) &amp; s, task);        top = s + <span class="number">1</span>;        <span class="keyword">if</span> (((d = s - (<span class="type">int</span>)BASE.getAcquire(<span class="built_in">this</span>)) &amp; ~<span class="number">1</span>) == <span class="number">0</span> &amp;&amp;                p != <span class="literal">null</span>) &#123;                 <span class="comment">// size 0 or 1</span>            VarHandle.fullFence();            p.signalWork();        &#125;        <span class="keyword">else</span> <span class="keyword">if</span> (d == m)            growArray(<span class="literal">false</span>);    &#125;&#125;</code></pre><h1 id="三、join-方法"><a href="#三、join-方法" class="headerlink" title="三、join 方法"></a>三、join 方法</h1><p>Join 方法的主要作用是阻塞当前线程并等待获取结果。让我们一起看看 ForkJoinTask 的 join 方法的实现，代码如下：</p><pre><code class="highlight java"><span class="comment">/**</span><span class="comment"> * Returns the result of the computation when it</span><span class="comment"> * &#123;<span class="doctag">@linkplain</span> #isDone is done&#125;.</span><span class="comment"> * This method differs from &#123;<span class="doctag">@link</span> #get()&#125; in that abnormal</span><span class="comment"> * completion results in &#123;<span class="doctag">@code</span> RuntimeException&#125; or &#123;<span class="doctag">@code</span> Error&#125;,</span><span class="comment"> * not &#123;<span class="doctag">@code</span> ExecutionException&#125;, and that interrupts of the</span><span class="comment"> * calling thread do &lt;em&gt;not&lt;/em&gt; cause the method to abruptly</span><span class="comment"> * return by throwing &#123;<span class="doctag">@code</span> InterruptedException&#125;.</span><span class="comment"> *</span><span class="comment"> * <span class="doctag">@return</span> the computed result</span><span class="comment"> */</span><span class="keyword">public</span> <span class="keyword">final</span> V <span class="title function_">join</span><span class="params">()</span> &#123;    <span class="type">int</span> s;    <span class="keyword">if</span> (((s = doJoin()) &amp; ABNORMAL) != <span class="number">0</span>)        reportException(s);    <span class="keyword">return</span> getRawResult();&#125;</code></pre><p>它首先调用 doJoin 方法，通过 doJoin()方法得到当前任务的状态来判断返回什么结果，任务状态有 4 种：</p><p><strong>已完成（NORMAL）</strong>、<strong>被取消（CANCELLED）</strong>、<strong>信号（SIGNAL）</strong>和 <strong>出现异常（EXCEPTIONAL）</strong></p><ul><li>如果任务状态是已完成，则直接返回任务结果。</li><li>如果任务状态是被取消，则直接抛出 CancellationException</li><li>如果任务状态是抛出异常，则直接抛出对应的异常</li></ul><p><strong>分析一下 doJoin 方法的实现</strong></p><pre><code class="highlight java"><span class="comment">/**</span><span class="comment"> * Implementation for join, get, quietlyJoin. Directly handles</span><span class="comment"> * only cases of already-completed, external wait, and</span><span class="comment"> * unfork+exec.  Others are relayed to ForkJoinPool.awaitJoin.</span><span class="comment"> *</span><span class="comment"> * <span class="doctag">@return</span> status upon completion</span><span class="comment"> */</span><span class="keyword">private</span> <span class="type">int</span> <span class="title function_">doJoin</span><span class="params">()</span> &#123;    <span class="type">int</span> s; Thread t; ForkJoinWorkerThread wt; ForkJoinPool.WorkQueue w;    <span class="keyword">return</span> (s = status) &lt; <span class="number">0</span> ? s :            ((t = Thread.currentThread()) <span class="keyword">instanceof</span> ForkJoinWorkerThread) ?                    (w = (wt = (ForkJoinWorkerThread)t).workQueue).                            tryUnpush(<span class="built_in">this</span>) &amp;&amp; (s = doExec()) &lt; <span class="number">0</span> ? s :                            wt.pool.awaitJoin(w, <span class="built_in">this</span>, <span class="number">0L</span>) :                    externalAwaitDone();&#125;<span class="comment">/**</span><span class="comment"> * Primary execution method for stolen tasks. Unless done, calls</span><span class="comment"> * exec and records status if completed, but doesn&#x27;t wait for</span><span class="comment"> * completion otherwise.</span><span class="comment"> *</span><span class="comment"> * <span class="doctag">@return</span> status on exit from this method</span><span class="comment"> */</span><span class="keyword">final</span> <span class="type">int</span> <span class="title function_">doExec</span><span class="params">()</span> &#123;    <span class="type">int</span> s; <span class="type">boolean</span> completed;    <span class="keyword">if</span> ((s = status) &gt;= <span class="number">0</span>) &#123;        <span class="keyword">try</span> &#123;            completed = exec();        &#125; <span class="keyword">catch</span> (Throwable rex) &#123;            completed = <span class="literal">false</span>;            s = setExceptionalCompletion(rex);        &#125;        <span class="keyword">if</span> (completed)            s = setDone();    &#125;    <span class="keyword">return</span> s;&#125;</code></pre><p>在 doJoin()方法流程如下:</p><ul><li>首先通过查看任务的状态，看任务是否已经执行完成，如果执行完成，则直接返回任务状态；</li><li>如果没有执行完，则从任务数组里取出任务并执行。</li><li>如果任务顺利执行完成，则设置任务状态为 NORMAL，如果出现异常，则记录异常，并将任务状态设置为 EXCEPTIONAL。</li></ul><h1 id="四、Fork-Join-框架的异常处理"><a href="#四、Fork-Join-框架的异常处理" class="headerlink" title="四、Fork&#x2F;Join 框架的异常处理"></a>四、Fork&#x2F;Join 框架的异常处理</h1><p>ForkJoinTask 在执行的时候可能会抛出异常，但是我们没办法在主线程里直接捕获异常，所以 ForkJoinTask 提供了 isCompletedAbnormally() 方法来检查任务是否已经抛出异常或已经被取消了，并且可以通过 ForkJoinTask 的 getException 方法获取异常。</p><p>getException 方法返回 Throwable 对象，如果任务被取消了则返回 CancellationException。如果任务没有完成或者没有抛出异常则返回 null。</p><h1 id="五、入门案例"><a href="#五、入门案例" class="headerlink" title="五、入门案例"></a>五、入门案例</h1><p><strong>场景: 生成一个计算任务，计算 1+2+3………+100 每 10 个数切分一个子任务</strong></p><pre><code class="highlight java"><span class="keyword">class</span> <span class="title class_">MyTask</span> <span class="keyword">extends</span> <span class="title class_">RecursiveTask</span>&lt;Integer&gt; &#123;    <span class="comment">//拆分差值不能超过10，计算10以内运算</span>    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">Integer</span> <span class="variable">VALUE</span> <span class="operator">=</span> <span class="number">10</span>;    <span class="keyword">private</span> <span class="type">int</span> begin ;<span class="comment">//拆分开始值</span>    <span class="keyword">private</span> <span class="type">int</span> end;<span class="comment">//拆分结束值</span>    <span class="keyword">private</span> <span class="type">int</span> result ; <span class="comment">//返回结果</span>    <span class="comment">//创建有参数构造</span>    <span class="keyword">public</span> <span class="title function_">MyTask</span><span class="params">(<span class="type">int</span> begin,<span class="type">int</span> end)</span> &#123;        <span class="built_in">this</span>.begin = begin;        <span class="built_in">this</span>.end = end;    &#125;    <span class="comment">//拆分和合并过程</span>    <span class="meta">@Override</span>    <span class="keyword">protected</span> Integer <span class="title function_">compute</span><span class="params">()</span> &#123;<span class="comment">//        System.out.println(Thread.currentThread().getName() + &quot;, begin: &quot; + begin + &quot;, end: &quot; + end);</span>        <span class="comment">//判断相加两个数值是否大于10</span>        <span class="keyword">if</span>((end-begin)&lt;=VALUE) &#123;            <span class="comment">//相加操作</span>            <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> begin; i &lt;=end; i++) &#123;                result = result+i;            &#125;        &#125; <span class="keyword">else</span> &#123;<span class="comment">// 递归调用,切分为 2 个小任务</span>            <span class="comment">//获取中间值</span>            <span class="type">int</span> <span class="variable">middle</span> <span class="operator">=</span> (begin+end)/<span class="number">2</span>;            <span class="comment">//拆分左边</span>            <span class="type">MyTask</span> <span class="variable">task01</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">MyTask</span>(begin,middle);            <span class="comment">//拆分右边</span>            <span class="type">MyTask</span> <span class="variable">task02</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">MyTask</span>(middle+<span class="number">1</span>,end);            <span class="comment">// 执行:异步</span>            task01.fork();            task02.fork();            <span class="comment">// 同步阻塞获取执行结果</span>            result = task01.join()+task02.join();        &#125;        <span class="keyword">return</span> result;    &#125;&#125;<span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ForkJoinDemo</span> &#123;    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> ExecutionException, InterruptedException &#123;        <span class="comment">//创建MyTask对象</span>        <span class="type">MyTask</span> <span class="variable">myTask</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">MyTask</span>(<span class="number">0</span>,<span class="number">100</span>);        <span class="comment">//创建分支合并池对象</span>        <span class="type">ForkJoinPool</span> <span class="variable">forkJoinPool</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ForkJoinPool</span>();        ForkJoinTask&lt;Integer&gt; forkJoinTask = forkJoinPool.submit(myTask);        <span class="comment">//获取最终合并之后结果</span>        <span class="type">Integer</span> <span class="variable">result</span> <span class="operator">=</span> forkJoinTask.get();        System.out.println(result);        <span class="comment">//关闭池对象</span>        forkJoinPool.shutdown();    &#125;&#125;</code></pre>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;一、Fork-Join-框架简介&quot;&gt;&lt;a href=&quot;#一、Fork-Join-框架简介&quot; class=&quot;headerlink&quot; title=&quot;一、Fork&amp;#x2F;Join 框架简介&quot;&gt;&lt;/a&gt;一、Fork&amp;#x2F;Join 框架简介&lt;/h1&gt;&lt;p&gt;Fork</summary>
      
    
    
    
    <category term="JUC" scheme="https://georgechan95.github.io/categories/JUC/"/>
    
    
    <category term="java" scheme="https://georgechan95.github.io/tags/java/"/>
    
    <category term="juc" scheme="https://georgechan95.github.io/tags/juc/"/>
    
  </entry>
  
</feed>
