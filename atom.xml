<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>George&#39;s Blog</title>
  
  <subtitle>个人邮箱：george_95@126.com</subtitle>
  <link href="https://georgechan95.github.io/atom.xml" rel="self"/>
  
  <link href="https://georgechan95.github.io/"/>
  <updated>2024-09-23T08:11:09.507Z</updated>
  <id>https://georgechan95.github.io/</id>
  
  <author>
    <name>George</name>
    
  </author>
  
  <generator uri="https://hexo.io/">Hexo</generator>
  
  <entry>
    <title>04-JUC进阶-LockSupport与线程中断</title>
    <link href="https://georgechan95.github.io/blog/19653fb9.html"/>
    <id>https://georgechan95.github.io/blog/19653fb9.html</id>
    <published>2024-09-23T12:51:50.000Z</published>
    <updated>2024-09-23T08:11:09.507Z</updated>
    
    <content type="html"><![CDATA[<h1 id="一、线程中断机制"><a href="#一、线程中断机制" class="headerlink" title="一、线程中断机制"></a>一、线程中断机制</h1><h2 id="1-什么是中断机制-？"><a href="#1-什么是中断机制-？" class="headerlink" title="1. 什么是中断机制 ？"></a>1. 什么是中断机制 ？</h2><p>首先一个线程不应该由其他线程来强制中断或停止，而是应该由线程自己自行停止。所以，<code>Thread.stop</code> , <code>Thread.suspend</code> , <code>Thread.resume</code> 都已经被废弃了。</p><p>其次在Java中没有办法立即停止一条线程，然而停止线程却显得尤为重要，如取消一个耗时操作。因此，Java提供了一种用于停止线程的机制——中断。</p><p><strong>中断只是一种协作机制，Java没有给中断增加任何语法，中断的过程完全需要程序员自己实现。</strong></p><ul><li>若要中断一个线程，你需要手动调用该线程的interrupt方法，<strong>该方法也仅仅是将线程对象的中断标识设成true</strong>；</li><li>接着你需要自己写代码不断地检测当前线程的标识位，如果为true，表示别的线程要求这条线程中断，</li><li>此时究竟该做什么需要你自己写代码实现。</li><li>每个线程对象中都有一个标识，用于表示线程是否被中断；该标识位为true表示中断，为false表示未中断；</li><li>通过调用线程对象的 <code>interrupt</code> 方法将该线程的标识位设为 true ；可以在别的线程中调用，也可以在自己的线程中调用。</li></ul><h2 id="2-中断的相关API方法"><a href="#2-中断的相关API方法" class="headerlink" title="2. 中断的相关API方法"></a>2. 中断的相关API方法</h2><p><img src="https://raw.githubusercontent.com/GeorgeChan95/blogimg/master/img/2024/09/23/20240923-094444.png" alt="线程中断API"></p><table><thead><tr><th>API</th><th>描述</th></tr></thead><tbody><tr><td>public void interrupt()</td><td>实例方法，<br/>实例方法 <code>interrupt()</code> 仅仅是设置线程的中断状态为true，不会停止线程</td></tr><tr><td><strong>public static boolean interrupted()</strong></td><td><strong>静态方法</strong>，<code>Thread.interrupted();</code>  <br/>判断线程是否被中断，并清除当前中断状态<br/>这个方法做了两件事：<br/>1 返回当前线程的中断状态<br/>2 将当前线程的中断状态设为false<br/> <br/>这个方法有点不好理解，因为连续调用两次的结果可能不一样。</td></tr><tr><td>public boolean isInterrupted()</td><td>实例方法，<br/>判断当前线程是否被中断（通过检查中断标志位）</td></tr></tbody></table><h3 id="2-1-通过一个-volatile-变量实现"><a href="#2-1-通过一个-volatile-变量实现" class="headerlink" title="2.1 通过一个 volatile 变量实现"></a>2.1 通过一个 volatile 变量实现</h3><ul><li>volatile保证了可见性，t2修改了标志位后能马上被t1看到</li></ul><pre><code class="highlight java"><span class="comment">/**</span><span class="comment"> * volatile变量实现线程中断</span><span class="comment"> *</span><span class="comment"> * <span class="doctag">@throws</span> InterruptedException</span><span class="comment"> */</span><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">volatileStopThread</span><span class="params">()</span> <span class="keyword">throws</span> InterruptedException &#123;    <span class="keyword">new</span> <span class="title class_">Thread</span>(() -&gt; &#123;        <span class="keyword">while</span> (!isStop) &#123;            System.out.println(<span class="string">&quot;------- t1 run&quot;</span>);        &#125;        System.out.println(<span class="string">&quot;===== t1 is stop =====&quot;</span>);    &#125;, <span class="string">&quot;t1&quot;</span>).start();    <span class="comment">// 让线程t1运行50毫秒后，中断线程运行</span>    Thread.sleep(<span class="number">10</span>);    <span class="keyword">new</span> <span class="title class_">Thread</span>(() -&gt; &#123;        isStop = <span class="literal">true</span>;        System.out.println(<span class="string">&quot;------- t2 stop: &quot;</span> + isStop);    &#125;, <span class="string">&quot;t2&quot;</span>).start();&#125;</code></pre><h3 id="2-2-通过-AtomicBoolean（原子布尔型）"><a href="#2-2-通过-AtomicBoolean（原子布尔型）" class="headerlink" title="2.2 通过 AtomicBoolean（原子布尔型）"></a>2.2 通过 AtomicBoolean（原子布尔型）</h3><pre><code class="highlight java"><span class="comment">/**</span><span class="comment"> * 通过AtomicBoolean变量实现线程中断</span><span class="comment"> *</span><span class="comment"> * <span class="doctag">@throws</span> InterruptedException</span><span class="comment"> */</span><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">atomicBooleanStopThread</span><span class="params">()</span> <span class="keyword">throws</span> InterruptedException &#123;    <span class="keyword">new</span> <span class="title class_">Thread</span>(() -&gt; &#123;        <span class="keyword">while</span> (!flag.get()) &#123;            System.out.println(<span class="string">&quot;------- t1 run&quot;</span>);        &#125;        System.out.println(<span class="string">&quot;===== t1 is stop =====&quot;</span>);    &#125;, <span class="string">&quot;t1&quot;</span>).start();    <span class="comment">// 让线程t1运行50毫秒后，中断线程运行</span>    Thread.sleep(<span class="number">50</span>);    <span class="keyword">new</span> <span class="title class_">Thread</span>(() -&gt; &#123;        flag.set(<span class="literal">true</span>);        System.out.println(<span class="string">&quot;------- t2 stop: &quot;</span> + flag.get());    &#125;, <span class="string">&quot;t2&quot;</span>).start();&#125;</code></pre><h3 id="2-3-通过Thread类自带的中断api方法实现"><a href="#2-3-通过Thread类自带的中断api方法实现" class="headerlink" title="2.3 通过Thread类自带的中断api方法实现"></a>2.3 通过Thread类自带的中断api方法实现</h3><pre><code class="highlight java"><span class="comment">/**</span><span class="comment"> * 通过Thread类自带的中断api方法实现</span><span class="comment"> *</span><span class="comment"> * <span class="doctag">@throws</span> InterruptedException</span><span class="comment"> */</span><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">threadApiInterruptThread</span><span class="params">()</span> <span class="keyword">throws</span> InterruptedException &#123;    <span class="type">Thread</span> <span class="variable">t1</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Thread</span>(() -&gt; &#123;        <span class="keyword">while</span> (!Thread.currentThread().isInterrupted()) &#123;            System.out.println(<span class="string">&quot;------- t1 run&quot;</span>);        &#125;        System.out.println(<span class="string">&quot;===== t1 is stop =====&quot;</span>);    &#125;, <span class="string">&quot;t1&quot;</span>);    t1.start();    <span class="comment">// 让线程t1运行50毫秒后，中断线程运行</span>    Thread.sleep(<span class="number">50</span>);    <span class="keyword">new</span> <span class="title class_">Thread</span>(() -&gt; &#123;        <span class="comment">// t1线程中断标识设置为true，等待县城自我中断</span>        t1.interrupt();        System.out.println(<span class="string">&quot;------- t2 stop: &quot;</span> + <span class="literal">true</span>);    &#125;, <span class="string">&quot;t2&quot;</span>).start();&#125;</code></pre><h2 id="3-中断API源码分析"><a href="#3-中断API源码分析" class="headerlink" title="3. 中断API源码分析"></a>3. 中断API源码分析</h2><ul><li><strong>实例方法interrupt()，没有返回值</strong></li></ul><pre><code class="highlight java"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">interrupt</span><span class="params">()</span> &#123;    <span class="keyword">if</span> (<span class="built_in">this</span> != Thread.currentThread())        checkAccess();    <span class="keyword">synchronized</span> (blockerLock) &#123;        <span class="type">Interruptible</span> <span class="variable">b</span> <span class="operator">=</span> blocker;        <span class="keyword">if</span> (b != <span class="literal">null</span>) &#123;            interrupt0();           <span class="comment">// Just to set the interrupt flag</span>            b.interrupt(<span class="built_in">this</span>);            <span class="keyword">return</span>;        &#125;    &#125;    interrupt0();&#125;<span class="comment">//Thread.java</span><span class="comment">/* Some private helper methods */</span><span class="keyword">private</span> <span class="keyword">native</span> <span class="keyword">void</span> <span class="title function_">setPriority0</span><span class="params">(<span class="type">int</span> newPriority)</span>;<span class="keyword">private</span> <span class="keyword">native</span> <span class="keyword">void</span> <span class="title function_">stop0</span><span class="params">(Object o)</span>;<span class="keyword">private</span> <span class="keyword">native</span> <span class="keyword">void</span> <span class="title function_">suspend0</span><span class="params">()</span>;<span class="keyword">private</span> <span class="keyword">native</span> <span class="keyword">void</span> <span class="title function_">resume0</span><span class="params">()</span>;<span class="keyword">private</span> <span class="keyword">native</span> <span class="keyword">void</span> <span class="title function_">interrupt0</span><span class="params">()</span>;  <span class="comment">//---------------------------调用了c底层原生方法</span><span class="keyword">private</span> <span class="keyword">native</span> <span class="keyword">void</span> <span class="title function_">setNativeName</span><span class="params">(String name)</span>;</code></pre><ul><li><strong>实例方法 isInterrupted，返回布尔值</strong></li></ul><pre><code class="highlight java"><span class="comment">/**</span><span class="comment"> * Tests whether this thread has been interrupted.  The &lt;i&gt;interrupted</span><span class="comment"> * status&lt;/i&gt; of the thread is unaffected by this method.</span><span class="comment"> *</span><span class="comment"> * &lt;p&gt;A thread interruption ignored because a thread was not alive</span><span class="comment"> * at the time of the interrupt will be reflected by this method</span><span class="comment"> * returning false.</span><span class="comment"> *</span><span class="comment"> * <span class="doctag">@return</span>  &lt;code&gt;true&lt;/code&gt; if this thread has been interrupted;</span><span class="comment"> *          &lt;code&gt;false&lt;/code&gt; otherwise.</span><span class="comment"> * <span class="doctag">@see</span>     #interrupted()</span><span class="comment"> * <span class="doctag">@revised</span> 6.0</span><span class="comment"> */</span><span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">isInterrupted</span><span class="params">()</span> &#123;    <span class="keyword">return</span> isInterrupted(<span class="literal">false</span>);&#125;<span class="comment">//Thread.java</span><span class="keyword">private</span> <span class="keyword">native</span> <span class="type">boolean</span> <span class="title function_">isInterrupted</span><span class="params">(<span class="type">boolean</span> ClearInterrupted)</span>;<span class="comment">//也调用了c底层</span></code></pre><p><strong>中断API相关说明：</strong></p><p>具体来说，当对一个线程，调用 interrupt() 时：</p><ul><li>如果线程处于<strong>正常活动状态</strong>，那么会将该线程的中断标志设置为 true，仅此而已。被设置中断标志的线程将继续正常运行，不受影响。所以， interrupt() 并不能真正的中断线程，需要被调用的线程自己进行配合才行（即：代码自行实现中断逻辑）。</li><li>如果线程处于被阻塞状态（例如处于sleep, wait, join 等状态），在别的线程中调用当前线程对象的interrupt方法，那么线程将立即退出被阻塞状态（中断状态将被清除），并抛出一个InterruptedException异常。（ 关于这一点，<code>interrupt()</code> 方法的注释有明确的说明，）</li><li>中断<strong>不活动的线程</strong>不会产生任何影响，具体看下面案例</li></ul><h3 id="3-1-当前线程的中断标识为true，是不是线程就立刻停止？"><a href="#3-1-当前线程的中断标识为true，是不是线程就立刻停止？" class="headerlink" title="3.1 当前线程的中断标识为true，是不是线程就立刻停止？"></a>3.1 <strong>当前线程的中断标识为true，是不是线程就立刻停止？</strong></h3><p>答案：否， 仅仅设置了一个中断状态为true。</p><pre><code class="highlight java"><span class="comment">/**</span><span class="comment"> * 中断为true后，并不是立刻stop程序</span><span class="comment"> */</span><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">m4</span><span class="params">()</span> &#123;    <span class="comment">//中断为true后，并不是立刻stop程序</span>    <span class="type">Thread</span> <span class="variable">t1</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Thread</span>(() -&gt; &#123;        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">1</span>; i &lt;= <span class="number">800</span>; i++) &#123;            System.out.println(<span class="string">&quot;------i: &quot;</span> + i);        &#125;        System.out.println(<span class="string">&quot;t1.interrupt()调用之后02： &quot;</span> + Thread.currentThread().isInterrupted());    &#125;, <span class="string">&quot;t1&quot;</span>);    t1.start();    System.out.println(<span class="string">&quot;t1.interrupt()调用之前,t1线程的中断标识默认值： &quot;</span> + t1.isInterrupted());    <span class="keyword">try</span> &#123;        TimeUnit.MILLISECONDS.sleep(<span class="number">3</span>);    &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;        e.printStackTrace();    &#125;    <span class="comment">//实例方法interrupt()仅仅是设置线程的中断状态位设置为true，不会停止线程</span>    t1.interrupt();    <span class="comment">//活动状态,t1线程还在执行中</span>    System.out.println(<span class="string">&quot;t1.interrupt()调用之后01： &quot;</span> + t1.isInterrupted());    <span class="keyword">try</span> &#123;        TimeUnit.MILLISECONDS.sleep(<span class="number">3000</span>);    &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;        e.printStackTrace();    &#125;    <span class="comment">//非活动状态,t1线程不在执行中，已经结束执行了, 此时调用 isInterrupted() 方法不起作用，中断状态标识位返回：false</span>    System.out.println(<span class="string">&quot;t1.interrupt()调用之后03： &quot;</span> + t1.isInterrupted());&#125;</code></pre><p>运行结果：</p><pre><code class="highlight shell">t1.interrupt()调用之前,t1线程的中断标识默认值： false------i: 1------i: 2------i: 3......------i: 645t1.interrupt()调用之后01： true // ------此处中断标志位设置为了true,但是t1仍然在运行------i: 646......------i: 798------i: 799------i: 800t1.interrupt()调用之后02： truet1.interrupt()调用之后03： false //中断不活动的线程不会产生任何影响，线程结束后应该是自动变为了false</code></pre><h3 id="3-2-中断异常代码案例："><a href="#3-2-中断异常代码案例：" class="headerlink" title="3.2 中断异常代码案例："></a>3.2 <strong>中断异常代码案例：</strong></h3><p>当线程处于 <code>wait</code> 、<code>join</code> 、<code>sleep</code> 时，此时调用 <code>interrupt()</code> 方法，会触发 <strong>中断异常</strong>， 且会导致程序无限循环. 因为 InterruptedException，将会把中断状态清除。</p><pre><code class="highlight java"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">m5</span><span class="params">()</span> &#123;    <span class="type">Thread</span> <span class="variable">t1</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Thread</span>(() -&gt; &#123;        <span class="keyword">while</span> (<span class="literal">true</span>) &#123;            <span class="keyword">if</span> (Thread.currentThread().isInterrupted()) &#123;                System.out.println(<span class="string">&quot;-----isInterrupted() = true，程序结束。&quot;</span>);                <span class="keyword">break</span>;            &#125;            <span class="keyword">try</span> &#123;                Thread.sleep(<span class="number">500</span>);            &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;<span class="comment">//                    Thread.currentThread().interrupt(); //线程的中断标志位为false,无法停下，需要再次掉interrupt()设置true</span>                e.printStackTrace();            &#125;            System.out.println(<span class="string">&quot;------hello Interrupt&quot;</span>);        &#125;    &#125;, <span class="string">&quot;t1&quot;</span>);    t1.start();    <span class="keyword">try</span> &#123;        TimeUnit.SECONDS.sleep(<span class="number">3</span>);    &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;        e.printStackTrace();    &#125;    <span class="keyword">new</span> <span class="title class_">Thread</span>(() -&gt; &#123;        t1.interrupt();<span class="comment">//修改t1线程的中断标志位为true</span>    &#125;, <span class="string">&quot;t2&quot;</span>).start();&#125;</code></pre><p><strong>运行结果：</strong></p><p>当调用 t1.interrupt(); 时，代码发生了异常，但 t1 依然在运行，没有结束掉</p><pre><code class="highlight shell">------hello Interrupt------hello Interruptjava.lang.InterruptedException: sleep interruptedat java.lang.Thread.sleep(Native Method)at com.atguigu.juc.interrupt.InterruptDemo.lambda$m5$0(InterruptDemo.java:34)at java.lang.Thread.run(Thread.java:748)------hello Interrupt------hello Interrupt------hello Interrupt......</code></pre><p><strong>解决方法：</strong></p><p>在 catch (InterruptedException e)  处添加 <code>Thread.currentThread().interrupt();</code> 发生异常后，再次调用代码执行中断，程序发生异常后依然可以正常结束；</p><pre><code class="highlight shell">------hello Interrupt------hello Interrupt------hello Interrupt------hello Interrupt------hello Interruptjava.lang.InterruptedException: sleep interruptedat java.lang.Thread.sleep(Native Method)at com.atguigu.juc.interrupt.InterruptDemo.lambda$m5$0(InterruptDemo.java:34)at java.lang.Thread.run(Thread.java:748)------hello Interrupt-----isInterrupted() = true，程序结束。</code></pre><h3 id="3-3-对静态方法-Thread-interrupted-的理解"><a href="#3-3-对静态方法-Thread-interrupted-的理解" class="headerlink" title="3.3 对静态方法 Thread.interrupted() 的理解"></a>3.3 对静态方法 Thread.interrupted() 的理解</h3><p><code>public static boolean interrupted()</code> </p><ul><li><p>静态方法，Thread.interrupted(); 判断线程是否被中断，并清除当前中断状态这个方法做了两件事：</p><ul><li>1 返回当前线程的中断状态</li><li>2 将当前线程的中断状态设为false</li></ul><p>注意：此方法连续调用两次的结果可能不一样</p></li></ul><pre><code class="highlight java"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;    System.out.println(Thread.currentThread().getName()+<span class="string">&quot;---&quot;</span>+Thread.interrupted()); <span class="comment">// main---false</span>    System.out.println(Thread.currentThread().getName()+<span class="string">&quot;---&quot;</span>+Thread.interrupted()); <span class="comment">// main---false</span>    System.out.println(<span class="string">&quot;111111&quot;</span>);    Thread.currentThread().interrupt();<span class="comment">///----false---&gt; true</span>    System.out.println(<span class="string">&quot;222222&quot;</span>);    System.out.println(Thread.currentThread().getName()+<span class="string">&quot;---&quot;</span>+Thread.interrupted()); <span class="comment">// main---true</span>    System.out.println(Thread.currentThread().getName()+<span class="string">&quot;---&quot;</span>+Thread.interrupted()); <span class="comment">// main---false</span>&#125;</code></pre><p>运行结果：</p><pre><code class="highlight shell">main---falsemain---false111111222222main---truemain---false</code></pre><p><strong>对比 <code>interrupted()</code> 与 <code>isInterrupted()</code> 源码</strong></p><pre><code class="highlight java"><span class="keyword">public</span> <span class="keyword">static</span> <span class="type">boolean</span> <span class="title function_">interrupted</span><span class="params">()</span> &#123;    <span class="keyword">return</span> currentThread().isInterrupted(<span class="literal">true</span>);&#125;<span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">isInterrupted</span><span class="params">()</span> &#123;    <span class="keyword">return</span> isInterrupted(<span class="literal">false</span>);&#125;<span class="comment">/**</span><span class="comment"> * Tests if some Thread has been interrupted.  The interrupted state</span><span class="comment"> * is reset or not based on the value of ClearInterrupted that is</span><span class="comment"> * passed.</span><span class="comment"> */</span><span class="keyword">private</span> <span class="keyword">native</span> <span class="type">boolean</span> <span class="title function_">isInterrupted</span><span class="params">(<span class="type">boolean</span> ClearInterrupted)</span>;</code></pre><p>他们在底层都调用了native方法 isInterrupted() , 只不过传入参数ClearInterrupted一个传参传了<code>true</code>，一个传了<code>false</code>。</p><ul><li>静态方法<code>interrupted() </code>中<code>true</code>表示清空当前中断状态。</li><li>实例方法<code>isInterrupted</code> 则不会。</li></ul><h2 id="4-总结"><a href="#4-总结" class="headerlink" title="4. 总结"></a>4. 总结</h2><p>线程中断相关的方法：</p><ul><li><p><code>interrupt()</code> 方法是一个实例方法</p><p>它通知目标线程中断，也就是设置目标线程的中断标志位为true，中断标志位表示当前线程已经被中断了。</p></li><li><p><code>isInterrupted()</code> 方法也是一个实例方法</p><p>它判断当前线程是否被中断（通过检查中断标志位）并获取中断标志</p></li><li><p>Thread类的静态方法 <code>interrupted()</code></p><p>返回当前线程的中断状态(boolean类型)且将当前线程的中断状态设为false，此方法调用之后会清除当前线程的中断标志位的状态（将中断标志置为false了），返回当前值并清零置false</p></li></ul><h1 id="二、LockSupport是什么"><a href="#二、LockSupport是什么" class="headerlink" title="二、LockSupport是什么"></a>二、LockSupport是什么</h1><p><code>LockSupport</code> 是用来创建锁和其他同步类的基本线程阻塞原语，其中 <code>park()</code> 和 <code>unpack()</code> 而作用分别是阻塞线程和解除阻塞线程.</p><p><img src="https://raw.githubusercontent.com/GeorgeChan95/blogimg/master/img/2024/09/23/20240923-133129.png" alt="LockSupport"></p><h1 id="三、线程等待唤醒机制"><a href="#三、线程等待唤醒机制" class="headerlink" title="三、线程等待唤醒机制"></a>三、线程等待唤醒机制</h1><h2 id="1-3种让线程等待和唤醒的方法"><a href="#1-3种让线程等待和唤醒的方法" class="headerlink" title="1. 3种让线程等待和唤醒的方法"></a>1. 3种让线程等待和唤醒的方法</h2><ul><li>使用Object中的<code>wait()</code>方法让线程等待，使用Object中的<code>notify()</code>方法唤醒线程</li><li>使用JUC包中<code>Condition</code>的<code>await()</code>方法让线程等待，使用<code>signal()</code>方法唤醒线程</li><li><code>LockSupport</code>类可以阻塞当前线程以及唤醒指定被阻塞的线程</li></ul><h2 id="2-Object类中的-wait-和-notify-方法实现线程等待和唤醒"><a href="#2-Object类中的-wait-和-notify-方法实现线程等待和唤醒" class="headerlink" title="2. Object类中的 wait 和 notify 方法实现线程等待和唤醒"></a>2. Object类中的 wait 和 notify 方法实现线程等待和唤醒</h2><p><strong>正确使用 wait &#x2F; notify</strong> </p><ul><li>wait 和 notify 都必须在 synchronized 覆盖的代码块中</li><li>必须先执行 wait， 再执行 notify</li></ul><pre><code class="highlight java"><span class="comment">/**</span><span class="comment"> * 正确使用 wait / notify 实现线程的等待和唤醒</span><span class="comment"> *</span><span class="comment"> * <span class="doctag">@throws</span> InterruptedException</span><span class="comment"> */</span><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">normal</span><span class="params">()</span> <span class="keyword">throws</span> InterruptedException &#123;    <span class="keyword">new</span> <span class="title class_">Thread</span>(() -&gt; &#123;        <span class="keyword">synchronized</span> (object) &#123;            <span class="keyword">try</span> &#123;                System.out.println(Thread.currentThread().getName() + <span class="string">&quot; ---- t1释放锁&quot;</span>);                <span class="comment">// wait方法会释放锁，给其他线程获取锁的机会</span>                object.wait();                System.out.println(Thread.currentThread().getName() + <span class="string">&quot; ---- t1重新获取锁&quot;</span>);            &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;                <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">RuntimeException</span>(e);            &#125;        &#125;    &#125;, <span class="string">&quot;t1&quot;</span>).start();    TimeUnit.SECONDS.sleep(<span class="number">1</span>);    <span class="keyword">new</span> <span class="title class_">Thread</span>(() -&gt; &#123;        <span class="keyword">synchronized</span> (object) &#123;            System.out.println(Thread.currentThread().getName() + <span class="string">&quot;---- notify&quot;</span>);            object.notify(); <span class="comment">// notify执行，让 t1 线程重新获取锁</span>        &#125;    &#125;, <span class="string">&quot;t2&quot;</span>).start();&#125;</code></pre><p>运行结果：</p><pre><code class="highlight shell">t1 ---- t1释放锁t2---- notifyt1 ---- t1重新获取锁</code></pre><p><strong>错误使用—： 去掉 synchronized</strong></p><pre><code class="highlight java"><span class="comment">/**</span><span class="comment"> * 错误方式—： 去掉 synchronized</span><span class="comment"> *</span><span class="comment"> * <span class="doctag">@throws</span> InterruptedException</span><span class="comment"> */</span><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">error1</span><span class="params">()</span> <span class="keyword">throws</span> InterruptedException &#123;    <span class="keyword">new</span> <span class="title class_">Thread</span>(() -&gt; &#123;        <span class="keyword">try</span> &#123;            System.out.println(Thread.currentThread().getName() + <span class="string">&quot; ---- t1释放锁&quot;</span>);            <span class="comment">// wait方法会释放锁，给其他线程获取锁的机会</span>            object.wait();            System.out.println(Thread.currentThread().getName() + <span class="string">&quot; ---- t1重新获取锁&quot;</span>);        &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;            <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">RuntimeException</span>(e);        &#125;    &#125;, <span class="string">&quot;t1&quot;</span>).start();    TimeUnit.SECONDS.sleep(<span class="number">1</span>);    <span class="keyword">new</span> <span class="title class_">Thread</span>(() -&gt; &#123;        System.out.println(Thread.currentThread().getName() + <span class="string">&quot;---- notify&quot;</span>);        object.notify(); <span class="comment">// notify执行，让 t1 线程重新获取锁</span>    &#125;, <span class="string">&quot;t2&quot;</span>).start();&#125;</code></pre><p>运行结果：</p><pre><code class="highlight shell">t1 ---- t1释放锁Exception in thread &quot;t1&quot; java.lang.IllegalMonitorStateExceptionat java.lang.Object.wait(Native Method)at java.lang.Object.wait(Object.java:502)at com.atguigu.juc.interrupt.SynchronizedDemo.lambda$error1$2(SynchronizedDemo.java:59)at java.lang.Thread.run(Thread.java:748)t2---- notifyException in thread &quot;t2&quot; java.lang.IllegalMonitorStateExceptionat java.lang.Object.notify(Native Method)at com.atguigu.juc.interrupt.SynchronizedDemo.lambda$error1$3(SynchronizedDemo.java:70)at java.lang.Thread.run(Thread.java:748)</code></pre><p><strong>错误使用二：把notify和wait的执行顺序对换</strong></p><pre><code class="highlight java"><span class="comment">/**</span><span class="comment"> * 错误使用二：把notify和wait的执行顺序对换</span><span class="comment"> *</span><span class="comment"> * <span class="doctag">@throws</span> InterruptedException</span><span class="comment"> */</span><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">error2</span><span class="params">()</span> <span class="keyword">throws</span> InterruptedException &#123;    <span class="keyword">new</span> <span class="title class_">Thread</span>(() -&gt; &#123;        <span class="keyword">try</span> &#123;            TimeUnit.SECONDS.sleep(<span class="number">2</span>); <span class="comment">// t1 线程先停2秒，等待t2线程执行结束</span>        &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;            <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">RuntimeException</span>(e);        &#125;        <span class="keyword">synchronized</span> (object) &#123;            <span class="keyword">try</span> &#123;                System.out.println(Thread.currentThread().getName() + <span class="string">&quot; ---- t1释放锁&quot;</span>);                <span class="comment">// wait方法会释放锁，给其他线程获取锁的机会</span>                object.wait();                System.out.println(Thread.currentThread().getName() + <span class="string">&quot; ---- t1重新获取锁&quot;</span>);            &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;                <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">RuntimeException</span>(e);            &#125;        &#125;    &#125;, <span class="string">&quot;t1&quot;</span>).start();    TimeUnit.SECONDS.sleep(<span class="number">1</span>);    <span class="keyword">new</span> <span class="title class_">Thread</span>(() -&gt; &#123;        <span class="keyword">synchronized</span> (object) &#123;            System.out.println(Thread.currentThread().getName() + <span class="string">&quot;---- notify&quot;</span>);            object.notify(); <span class="comment">// notify执行，让 t1 线程重新获取锁</span>        &#125;    &#125;, <span class="string">&quot;t2&quot;</span>).start();&#125;</code></pre><p>运行结果：</p><pre><code class="highlight shell">t2---- notifyt1 ---- t1释放锁</code></pre><p>现象：t1 线程没有结束掉。</p><p><strong>总结：</strong></p><ul><li>wait和notify方法必须要在<strong>同步</strong>块或者方法里面，且必须<strong>成对</strong>出现使用</li><li>先wait后notify才可以,<strong>顺序不能错</strong></li></ul><h2 id="3-Condition接口中的-await-后-signal-方法实现线程的等待和唤醒"><a href="#3-Condition接口中的-await-后-signal-方法实现线程的等待和唤醒" class="headerlink" title="3. Condition接口中的 await 后 signal 方法实现线程的等待和唤醒"></a>3. Condition接口中的 await 后 signal 方法实现线程的等待和唤醒</h2><p><strong>正确使用 await &#x2F; signal</strong> </p><ul><li>await 和 signal 都必须在 lock() &#x2F; unlock() 覆盖的代码块中</li><li>必须先执行 await ， 再执行 signal</li></ul><pre><code class="highlight java"><span class="comment">/**</span><span class="comment"> * 正确使用 Lock 的 await / signal 实现对线程的等待和唤醒</span><span class="comment"> * <span class="doctag">@throws</span> InterruptedException</span><span class="comment"> */</span><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">normal</span><span class="params">()</span> <span class="keyword">throws</span> InterruptedException &#123;    <span class="type">Lock</span> <span class="variable">lock</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ReentrantLock</span>();    <span class="type">Condition</span> <span class="variable">condition</span> <span class="operator">=</span> lock.newCondition();    <span class="keyword">new</span> <span class="title class_">Thread</span>(() -&gt; &#123;        <span class="keyword">try</span> &#123;            lock.lock();            System.out.println(Thread.currentThread().getName() + <span class="string">&quot;---- t1 释放锁&quot;</span>);            condition.await();            System.out.println(Thread.currentThread().getName() + <span class="string">&quot;---- t1 重新获取锁&quot;</span>);        &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;            <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">RuntimeException</span>(e);        &#125; <span class="keyword">finally</span> &#123;            lock.unlock();        &#125;    &#125;, <span class="string">&quot;t1&quot;</span>).start();    TimeUnit.SECONDS.sleep(<span class="number">1</span>);    <span class="keyword">new</span> <span class="title class_">Thread</span>(() -&gt; &#123;        <span class="keyword">try</span> &#123;            lock.lock();            System.out.println(Thread.currentThread().getName() + <span class="string">&quot;---- t2唤醒t1线程&quot;</span>);            condition.signal();        &#125; <span class="keyword">finally</span> &#123;            lock.unlock();        &#125;    &#125;, <span class="string">&quot;t2&quot;</span>).start();&#125;</code></pre><p>运行结果：</p><pre><code class="highlight shell">t1---- t1 释放锁t2---- t2唤醒t1线程t1---- t1 重新获取锁</code></pre><p><strong>错误使用一：await 和 signal 不在 lock() &#x2F; unlock() 覆盖的代码块中</strong></p><p>报错： java.lang.IllegalMonitorStateException</p><p><strong>错误使用二：必须先执行 signal ， 再执行 await</strong></p><p>线程没有正确的停止</p><h2 id="4-Object和Condition使用的限制条件"><a href="#4-Object和Condition使用的限制条件" class="headerlink" title="4. Object和Condition使用的限制条件"></a>4. Object和Condition使用的限制条件</h2><ul><li>线程先要获得并持有锁，必须在锁块(synchronized或lock)中</li><li>必须要先等待后唤醒，线程才能够被唤醒</li></ul><h2 id="5-LockSupport类中的park等待和unpark唤醒"><a href="#5-LockSupport类中的park等待和unpark唤醒" class="headerlink" title="5. LockSupport类中的park等待和unpark唤醒"></a>5. LockSupport类中的park等待和unpark唤醒</h2><h3 id="5-1-概念解析"><a href="#5-1-概念解析" class="headerlink" title="5.1 概念解析"></a>5.1 概念解析</h3><p>LockSupport 通过 <code>park()</code> 和 <code>unpark(thread)</code> 方法来实现阻塞和唤醒线程的操作</p><p><strong>官网解释</strong></p><p><img src="https://raw.githubusercontent.com/GeorgeChan95/blogimg/master/img/2024/09/23/20240923-145605.png" alt="LockSupport"></p><p>LockSupport是用来创建锁和其他同步类的基本线程阻塞原语。</p><ul><li>LockSupport类使用了一种名为Permit（许可）的概念来做到阻塞和唤醒线程的功能， 每个线程都有一个许可(permit)，</li><li>permit只有两个值1和零，默认是零。</li><li>可以把许可看成是一种(0,1)信号量（Semaphore），但与 Semaphore 不同的是，许可的累加上限是1。</li></ul><h3 id="5-2-主要方法"><a href="#5-2-主要方法" class="headerlink" title="5.2 主要方法"></a>5.2 主要方法</h3><h4 id="5-2-1-API"><a href="#5-2-1-API" class="headerlink" title="5.2.1 API"></a>5.2.1 API</h4><p><img src="https://raw.githubusercontent.com/GeorgeChan95/blogimg/master/img/2024/09/23/20240923-150101.png" alt="LockSupport API"></p><h4 id="5-2-2-阻塞"><a href="#5-2-2-阻塞" class="headerlink" title="5.2.2 阻塞"></a>5.2.2 阻塞</h4><ul><li><code>park() / park(Object blocker)</code></li><li>阻塞当前线程 &#x2F; 阻塞传入的具体线程</li></ul><p>调用<code>LockSupport.park()</code>时，发现它调用了<code>unsafe类</code>，并且默认传了一个0</p><pre><code class="highlight java"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">park</span><span class="params">()</span> &#123;    UNSAFE.park(<span class="literal">false</span>, <span class="number">0L</span>);&#125;</code></pre><ul><li>permit默认是零，所以一开始调用<code>park()</code>方法，当前线程就会阻塞，直到别的线程将当前线程的permit设置为1时，park方法会被唤醒，然后会将permit再次设置为零并返回。</li></ul><h4 id="5-2-3-唤醒"><a href="#5-2-3-唤醒" class="headerlink" title="5.2.3 唤醒"></a>5.2.3 唤醒</h4><p><code>unpark(Thread thread)</code> , 唤醒处于阻塞状态的指定线程</p><pre><code class="highlight java"><span class="comment">/**</span><span class="comment"> * Makes available the permit for the given thread, if it</span><span class="comment"> * was not already available.  If the thread was blocked on</span><span class="comment"> * &#123;<span class="doctag">@code</span> park&#125; then it will unblock.  Otherwise, its next call</span><span class="comment"> * to &#123;<span class="doctag">@code</span> park&#125; is guaranteed not to block. This operation</span><span class="comment"> * is not guaranteed to have any effect at all if the given</span><span class="comment"> * thread has not been started.</span><span class="comment"> *</span><span class="comment"> * <span class="doctag">@param</span> thread the thread to unpark, or &#123;<span class="doctag">@code</span> null&#125;, in which case</span><span class="comment"> *        this operation has no effect</span><span class="comment"> */</span><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">unpark</span><span class="params">(Thread thread)</span> &#123;    <span class="keyword">if</span> (thread != <span class="literal">null</span>)        UNSAFE.unpark(thread);&#125;</code></pre><p>调用<code>LockSupport.unpark();</code>时，也调用了<code>unsafe类</code></p><ul><li>调用unpark(thread)方法后，就会将 thread线程的许可 permit 设置成<strong>1</strong>(注意多次调用 unpark 方法，不会累加，permit 值还是1)会自动唤醒 thread 线程，即之前阻塞中的 LockSupport.park() 方法会立即返回。</li></ul><h3 id="5-3-LockSupport-代码示例"><a href="#5-3-LockSupport-代码示例" class="headerlink" title="5.3 LockSupport 代码示例"></a>5.3 LockSupport 代码示例</h3><p><strong>正常+无锁块要求</strong></p><pre><code class="highlight java"><span class="comment">/**</span><span class="comment"> * 正常使用，无锁块要求</span><span class="comment"> * 先阻塞后释放，可以实现线程的阻塞和唤醒</span><span class="comment"> *</span><span class="comment"> * <span class="doctag">@throws</span> InterruptedException</span><span class="comment"> */</span><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">m1</span><span class="params">()</span> <span class="keyword">throws</span> InterruptedException &#123;    <span class="type">Thread</span> <span class="variable">t1</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Thread</span>(() -&gt; &#123;        System.out.println(Thread.currentThread().getName() + <span class="string">&quot;---- come in&quot;</span>);        System.out.println(Thread.currentThread().getName() + <span class="string">&quot;---- park阻塞&quot;</span>);        LockSupport.park();        System.out.println(Thread.currentThread().getName() + <span class="string">&quot;---- 继续执行&quot;</span>);    &#125;, <span class="string">&quot;t1&quot;</span>);    t1.start();    TimeUnit.SECONDS.sleep(<span class="number">1</span>);    <span class="keyword">new</span> <span class="title class_">Thread</span>(() -&gt; &#123;        System.out.println(Thread.currentThread().getName() + <span class="string">&quot;---- come in&quot;</span>);        LockSupport.unpark(t1);    &#125;, <span class="string">&quot;t2&quot;</span>).start();&#125;</code></pre><p>运行结果：</p><pre><code class="highlight shell">t1---- come int1---- park阻塞t2---- come int1---- 继续执行</code></pre><p><strong>先唤醒后等待，LockSupport 同样支持</strong></p><pre><code class="highlight java"><span class="comment">/**</span><span class="comment"> * 先释放后阻塞，也可以实现线程的阻塞和唤醒</span><span class="comment"> *</span><span class="comment"> * <span class="doctag">@throws</span> InterruptedException</span><span class="comment"> */</span><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">m2</span><span class="params">()</span> <span class="keyword">throws</span> InterruptedException &#123;    <span class="type">Thread</span> <span class="variable">t1</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Thread</span>(() -&gt; &#123;        <span class="keyword">try</span> &#123;            TimeUnit.SECONDS.sleep(<span class="number">2</span>);        &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;            <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">RuntimeException</span>(e);        &#125;        System.out.println(Thread.currentThread().getName() + <span class="string">&quot;---- come in&quot;</span>);        System.out.println(Thread.currentThread().getName() + <span class="string">&quot;---- park阻塞&quot;</span>);        LockSupport.park();        System.out.println(Thread.currentThread().getName() + <span class="string">&quot;---- 继续执行&quot;</span>);    &#125;, <span class="string">&quot;t1&quot;</span>);    t1.start();    TimeUnit.SECONDS.sleep(<span class="number">1</span>);    <span class="keyword">new</span> <span class="title class_">Thread</span>(() -&gt; &#123;        System.out.println(Thread.currentThread().getName() + <span class="string">&quot;---- come in&quot;</span>);        System.out.println(Thread.currentThread().getName() + <span class="string">&quot;---- 给t1线程发通行证&quot;</span>);        LockSupport.unpark(t1);    &#125;, <span class="string">&quot;t2&quot;</span>).start();&#125;</code></pre><p>运行结果：</p><pre><code class="highlight shell">t2---- come int2---- 给t1线程发通行证t1---- come int1---- park阻塞t1---- 继续执行</code></pre><p>t1 sleep方法2秒后醒来，执行park无效，没有阻塞效果，这是因为 t2 先执行了<code>unpark(t1)</code>导致上面的park方法无效.</p><p>注意：park() &#x2F; unpark() 必须成对出现</p><p><strong>错误使用：连续执行 unpark(), 相当于只执行了一次 unpark()</strong> </p><pre><code class="highlight java"><span class="comment">/**</span><span class="comment"> * 连续执行 unpark(), 相当于只执行了一次 unpark()</span><span class="comment"> */</span><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">error1</span><span class="params">()</span> &#123;    <span class="type">Thread</span> <span class="variable">t1</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Thread</span>(() -&gt; &#123;        System.out.println(Thread.currentThread().getName() + <span class="string">&quot;\t&quot;</span> + <span class="string">&quot;---come in&quot;</span>);        System.out.println(Thread.currentThread().getName() + <span class="string">&quot;\t&quot;</span> + <span class="string">&quot;--- park1&quot;</span>);        LockSupport.park();        System.out.println(Thread.currentThread().getName() + <span class="string">&quot;\t&quot;</span> + <span class="string">&quot;--- park2&quot;</span>);        LockSupport.park();        System.out.println(Thread.currentThread().getName() + <span class="string">&quot;\t&quot;</span> + <span class="string">&quot;---被唤醒&quot;</span>);    &#125;, <span class="string">&quot;t1&quot;</span>);    t1.start();    <span class="keyword">new</span> <span class="title class_">Thread</span>(() -&gt; &#123;        LockSupport.unpark(t1);        LockSupport.unpark(t1);        System.out.println(Thread.currentThread().getName() + <span class="string">&quot;\t&quot;</span> + <span class="string">&quot;--- unpark1&quot;</span>);        System.out.println(Thread.currentThread().getName() + <span class="string">&quot;\t&quot;</span> + <span class="string">&quot;--- unpark2&quot;</span>);        <span class="keyword">try</span> &#123;            TimeUnit.SECONDS.sleep(<span class="number">3</span>);        &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;            e.printStackTrace();        &#125;    &#125;, <span class="string">&quot;t2&quot;</span>).start();&#125;</code></pre><p>运行结果：</p><pre><code class="highlight shell">t1---come int1--- park1t2--- unpark1t2--- unpark2t1--- park2</code></pre><p>t1 没有停止，继续阻塞，这是因为 t2 连续执行了两次 <code>unpark(t1)</code> ，但其实只发布了一个通行证，导致 t1 的第一次 park() 被唤醒了，但是第二次 park() 就没有通行证用来唤醒它，因此 t1 阻塞。</p><p><strong>总结：</strong></p><ul><li>Lock Support是用来创建锁和其他同步类的基本线程阻塞原语。</li><li>Lock Support是一个线程阻塞工具类， 所有的方法都是静态方法， 可以让线程在任意位置阻塞， 阻塞之后也有对应的唤醒方法。归根结底，Lock Support调用的Unsafe中的native代码。</li><li>Lock Support提供<code>park()</code> 和<code>unpark() </code>方法实现<strong>阻塞线程</strong>和<strong>解除线程阻塞</strong>的过程</li><li>Lock Support和每个使用它的线程都有一个许可(permit) 关联。</li><li>每个线程都有一个相关的 permit， permit 最多只有一个， 重复调用 <code>unpark()</code> 也不会积累凭证。</li></ul>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;一、线程中断机制&quot;&gt;&lt;a href=&quot;#一、线程中断机制&quot; class=&quot;headerlink&quot; title=&quot;一、线程中断机制&quot;&gt;&lt;/a&gt;一、线程中断机制&lt;/h1&gt;&lt;h2 id=&quot;1-什么是中断机制-？&quot;&gt;&lt;a href=&quot;#1-什么是中断机制-？&quot; class</summary>
      
    
    
    
    <category term="JUC" scheme="https://georgechan95.github.io/categories/JUC/"/>
    
    
    <category term="juc" scheme="https://georgechan95.github.io/tags/juc/"/>
    
    <category term="java" scheme="https://georgechan95.github.io/tags/java/"/>
    
  </entry>
  
  <entry>
    <title>03-JUC进阶-Java中的锁的解析</title>
    <link href="https://georgechan95.github.io/blog/219e52ea.html"/>
    <id>https://georgechan95.github.io/blog/219e52ea.html</id>
    <published>2024-09-21T06:15:20.000Z</published>
    <updated>2024-09-21T08:52:48.128Z</updated>
    
    <content type="html"><![CDATA[<h1 id="一、乐观锁和悲观锁"><a href="#一、乐观锁和悲观锁" class="headerlink" title="一、乐观锁和悲观锁"></a>一、乐观锁和悲观锁</h1><h2 id="1-悲观锁"><a href="#1-悲观锁" class="headerlink" title="1. 悲观锁"></a>1. 悲观锁</h2><p>悲观锁认为自己在使用数据的时候一定有别的线程来修改数据，因此在获取数据的时候会先加锁，确保数据不会被别的线程修改。</p><p><strong>悲观锁的实现方式</strong></p><ul><li><code>synchronized</code> 关键字</li><li><code>Lock</code> 的实现类都是悲观锁</li></ul><p><strong>适合写操作多的场景</strong>，先加锁可以保证写操作时数据正确。显示的锁定之后再操作同步资源。</p><pre><code class="highlight java"><span class="comment">//=============悲观锁的调用方式</span><span class="keyword">public</span> <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title function_">m1</span><span class="params">()</span>&#123;    <span class="comment">//加锁后的业务逻辑......</span>&#125;<span class="comment">// 保证多个线程使用的是同一个lock对象的前提下</span><span class="type">ReentrantLock</span> <span class="variable">lock</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ReentrantLock</span>();<span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">m2</span><span class="params">()</span> &#123;    lock.lock();    <span class="keyword">try</span> &#123;        <span class="comment">// 操作同步资源</span>    &#125;<span class="keyword">finally</span> &#123;        lock.unlock();    &#125;&#125;</code></pre><h2 id="2-乐观锁"><a href="#2-乐观锁" class="headerlink" title="2. 乐观锁"></a>2. 乐观锁</h2><p>乐观锁认为自己在使用数据时不会有别的线程修改数据，所以不会添加锁，只是在更新数据的时候去判断之前有没有别的线程更新了这个数据。如果这个数据没有被更新，当前线程将自己修改的数据成功写入。如果数据已经被其他线程更新，则根据不同的实现方式执行不同的操作</p><p><strong>乐观锁的实现方式</strong></p><ul><li>版本号机制Version。（只要有人提交了就会修改版本号，可以解决ABA问题）<ul><li><strong>ABA问题</strong>：再CAS中想读取一个值A，想把值A变为C，不能保证读取时的A就是赋值时的A，中间可能有个线程将A变为B再变为A。<ul><li>解决方法：Juc包提供了一个 <code>AtomicStampedReference</code>，原子更新带有版本号的引用类型，通过控制版本值的变化来解决ABA问题。</li></ul></li><li>最常采用的是CAS算法，Java原子类中的递增操作就通过CAS自旋实现的。</li></ul></li></ul><p><strong>适合读操作多的场景</strong>，不加锁的性能特点能够使其操作的性能大幅提升。</p><pre><code class="highlight java"><span class="comment">//=============乐观锁的调用方式</span><span class="comment">// 保证多个线程使用的是同一个AtomicInteger</span><span class="keyword">private</span> <span class="type">AtomicInteger</span> <span class="variable">atomicInteger</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">AtomicInteger</span>();atomicInteger.incrementAndGet();</code></pre><h1 id="二、synchronized-锁的8种情况"><a href="#二、synchronized-锁的8种情况" class="headerlink" title="二、synchronized 锁的8种情况"></a>二、synchronized 锁的8种情况</h1><p>下面通过一段代码，演示 synchronized 锁的 8 种情况</p><ol><li><p>标准访问，先打印短信还是邮件</p><pre><code class="highlight java"><span class="keyword">class</span> <span class="title class_">Phone</span> &#123;    <span class="keyword">public</span> <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title function_">sendSMS</span><span class="params">()</span> <span class="keyword">throws</span> Exception &#123;        System.out.println(<span class="string">&quot;------sendSMS&quot;</span>);    &#125;    <span class="keyword">public</span> <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title function_">sendEmail</span><span class="params">()</span> <span class="keyword">throws</span> Exception &#123;        System.out.println(<span class="string">&quot;------sendEmail&quot;</span>);    &#125;&#125;<span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Lock_8</span> &#123;    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception &#123;        <span class="type">Phone</span> <span class="variable">phone</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Phone</span>();        <span class="keyword">new</span> <span class="title class_">Thread</span>(() -&gt; &#123;            <span class="keyword">try</span> &#123;                phone.sendSMS();            &#125; <span class="keyword">catch</span> (Exception e) &#123;                e.printStackTrace();            &#125;        &#125;, <span class="string">&quot;AA&quot;</span>).start();        Thread.sleep(<span class="number">100</span>);        <span class="keyword">new</span> <span class="title class_">Thread</span>(() -&gt; &#123;            <span class="keyword">try</span> &#123;                phone.sendEmail();            &#125; <span class="keyword">catch</span> (Exception e) &#123;                e.printStackTrace();            &#125;        &#125;, <span class="string">&quot;BB&quot;</span>).start();    &#125;&#125;</code></pre><p>打印结果：</p><pre><code class="highlight shell">------sendSMS------sendEmail</code></pre><p>分析：两个方法都加了 synchronized 关键字，因为是同一个对象调用，所有是同一把锁，按照顺序执行。</p></li><li><p>停4秒在短信方法内，先打印短信还是邮件</p><pre><code class="highlight java"><span class="keyword">class</span> <span class="title class_">Phone</span> &#123;    <span class="keyword">public</span> <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title function_">sendSMS</span><span class="params">()</span> <span class="keyword">throws</span> Exception &#123;        <span class="comment">//停留4秒</span>        TimeUnit.SECONDS.sleep(<span class="number">4</span>);        System.out.println(<span class="string">&quot;------sendSMS&quot;</span>);    &#125;    <span class="keyword">public</span> <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title function_">sendEmail</span><span class="params">()</span> <span class="keyword">throws</span> Exception &#123;        System.out.println(<span class="string">&quot;------sendEmail&quot;</span>);    &#125;&#125;<span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Lock_8</span> &#123;    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception &#123;        <span class="type">Phone</span> <span class="variable">phone</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Phone</span>();        <span class="keyword">new</span> <span class="title class_">Thread</span>(() -&gt; &#123;            <span class="keyword">try</span> &#123;                phone.sendSMS();            &#125; <span class="keyword">catch</span> (Exception e) &#123;                e.printStackTrace();            &#125;        &#125;, <span class="string">&quot;AA&quot;</span>).start();        Thread.sleep(<span class="number">100</span>);        <span class="keyword">new</span> <span class="title class_">Thread</span>(() -&gt; &#123;            <span class="keyword">try</span> &#123;                phone.sendEmail();            &#125; <span class="keyword">catch</span> (Exception e) &#123;                e.printStackTrace();            &#125;        &#125;, <span class="string">&quot;BB&quot;</span>).start();    &#125;&#125;</code></pre><p>打印结果：</p><pre><code class="highlight shell">------sendSMS------sendEmail</code></pre><p>分析：两个方法都加了 synchronized 关键字，因为还是同一个对象调用，所有还是同一把锁，先拿到锁的方法执行结束后，另一个方法才能执行。</p></li><li><p>新增普通的hello方法，是先打短信还是hello</p><pre><code class="highlight java"><span class="keyword">class</span> <span class="title class_">Phone</span> &#123;    <span class="keyword">public</span> <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title function_">sendSMS</span><span class="params">()</span> <span class="keyword">throws</span> Exception &#123;        <span class="comment">//停留4秒</span>        TimeUnit.SECONDS.sleep(<span class="number">4</span>);        System.out.println(<span class="string">&quot;------sendSMS&quot;</span>);    &#125;    <span class="keyword">public</span> <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title function_">sendEmail</span><span class="params">()</span> <span class="keyword">throws</span> Exception &#123;        System.out.println(<span class="string">&quot;------sendEmail&quot;</span>);    &#125;    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">getHello</span><span class="params">()</span> &#123;        System.out.println(<span class="string">&quot;------getHello&quot;</span>);    &#125;&#125;<span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Lock_8</span> &#123;    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception &#123;        <span class="type">Phone</span> <span class="variable">phone</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Phone</span>();        <span class="keyword">new</span> <span class="title class_">Thread</span>(() -&gt; &#123;            <span class="keyword">try</span> &#123;                phone.sendSMS();            &#125; <span class="keyword">catch</span> (Exception e) &#123;                e.printStackTrace();            &#125;        &#125;, <span class="string">&quot;AA&quot;</span>).start();        Thread.sleep(<span class="number">100</span>);        <span class="keyword">new</span> <span class="title class_">Thread</span>(() -&gt; &#123;            <span class="keyword">try</span> &#123;                phone.getHello();            &#125; <span class="keyword">catch</span> (Exception e) &#123;                e.printStackTrace();            &#125;        &#125;, <span class="string">&quot;BB&quot;</span>).start();    &#125;&#125;</code></pre><p>打印结果：</p><pre><code class="highlight shell">------getHello------sendSMS</code></pre><p>分析：hello方法没有加锁，调用即执行，sendSMS有sleep阻塞。</p></li><li><p>现在有两部手机，先打印短信还是邮件</p><pre><code class="highlight java"><span class="keyword">class</span> <span class="title class_">Phone</span> &#123;    <span class="keyword">public</span> <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title function_">sendSMS</span><span class="params">()</span> <span class="keyword">throws</span> Exception &#123;        <span class="comment">//停留4秒</span>        TimeUnit.SECONDS.sleep(<span class="number">4</span>);        System.out.println(<span class="string">&quot;------sendSMS&quot;</span>);    &#125;    <span class="keyword">public</span> <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title function_">sendEmail</span><span class="params">()</span> <span class="keyword">throws</span> Exception &#123;        System.out.println(<span class="string">&quot;------sendEmail&quot;</span>);    &#125;&#125;<span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Lock_8</span> &#123;    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception &#123;        <span class="type">Phone</span> <span class="variable">phone</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Phone</span>();        <span class="type">Phone</span> <span class="variable">phone2</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Phone</span>();        <span class="keyword">new</span> <span class="title class_">Thread</span>(() -&gt; &#123;            <span class="keyword">try</span> &#123;                phone.sendSMS();            &#125; <span class="keyword">catch</span> (Exception e) &#123;                e.printStackTrace();            &#125;        &#125;, <span class="string">&quot;AA&quot;</span>).start();        Thread.sleep(<span class="number">100</span>);        <span class="keyword">new</span> <span class="title class_">Thread</span>(() -&gt; &#123;            <span class="keyword">try</span> &#123;                phone2.sendEmail();            &#125; <span class="keyword">catch</span> (Exception e) &#123;                e.printStackTrace();            &#125;        &#125;, <span class="string">&quot;BB&quot;</span>).start();    &#125;&#125;</code></pre><p>打印结果：</p><pre><code class="highlight shell">------sendEmail------sendSMS</code></pre><p>分析：synchronized 在方法上，是方法级的锁，由于是两个 phone 对象调用不同的方法，所以 sendSMS() 和 sendEmail() 持有的是不同的锁，互不影响。</p></li><li><p>两个静态同步方法，1部手机，先打印短信还是邮件</p><pre><code class="highlight java"><span class="keyword">class</span> <span class="title class_">Phone</span> &#123;    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title function_">sendSMS</span><span class="params">()</span> <span class="keyword">throws</span> Exception &#123;        <span class="comment">//停留4秒</span>        TimeUnit.SECONDS.sleep(<span class="number">4</span>);        System.out.println(<span class="string">&quot;------sendSMS&quot;</span>);    &#125;    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title function_">sendEmail</span><span class="params">()</span> <span class="keyword">throws</span> Exception &#123;        System.out.println(<span class="string">&quot;------sendEmail&quot;</span>);    &#125;&#125;<span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Lock_8</span> &#123;    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception &#123;        <span class="type">Phone</span> <span class="variable">phone</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Phone</span>();                <span class="keyword">new</span> <span class="title class_">Thread</span>(() -&gt; &#123;            <span class="keyword">try</span> &#123;                phone.sendSMS();            &#125; <span class="keyword">catch</span> (Exception e) &#123;                e.printStackTrace();            &#125;        &#125;, <span class="string">&quot;AA&quot;</span>).start();        Thread.sleep(<span class="number">100</span>);        <span class="keyword">new</span> <span class="title class_">Thread</span>(() -&gt; &#123;            <span class="keyword">try</span> &#123;                phone.sendEmail();            &#125; <span class="keyword">catch</span> (Exception e) &#123;                e.printStackTrace();            &#125;        &#125;, <span class="string">&quot;BB&quot;</span>).start();    &#125;&#125;</code></pre><p>打印结果：</p><pre><code class="highlight shell">------sendSMS------sendEmail</code></pre><p>分析：synchronized 在静态方法上，是类级别的锁，所以两个方法持有的是同一把锁，要按顺序执行</p></li><li><p>两个静态同步方法，2部手机，先打印短信还是邮件</p><pre><code class="highlight java"><span class="keyword">class</span> <span class="title class_">Phone</span> &#123;    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title function_">sendSMS</span><span class="params">()</span> <span class="keyword">throws</span> Exception &#123;        <span class="comment">//停留4秒</span>        TimeUnit.SECONDS.sleep(<span class="number">4</span>);        System.out.println(<span class="string">&quot;------sendSMS&quot;</span>);    &#125;    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title function_">sendEmail</span><span class="params">()</span> <span class="keyword">throws</span> Exception &#123;        System.out.println(<span class="string">&quot;------sendEmail&quot;</span>);    &#125;&#125;<span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Lock_8</span> &#123;    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception &#123;        <span class="type">Phone</span> <span class="variable">phone</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Phone</span>();        <span class="type">Phone</span> <span class="variable">phone2</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Phone</span>();        <span class="keyword">new</span> <span class="title class_">Thread</span>(() -&gt; &#123;            <span class="keyword">try</span> &#123;                phone.sendSMS();            &#125; <span class="keyword">catch</span> (Exception e) &#123;                e.printStackTrace();            &#125;        &#125;, <span class="string">&quot;AA&quot;</span>).start();        Thread.sleep(<span class="number">100</span>);        <span class="keyword">new</span> <span class="title class_">Thread</span>(() -&gt; &#123;            <span class="keyword">try</span> &#123;                phone2.sendEmail();            &#125; <span class="keyword">catch</span> (Exception e) &#123;                e.printStackTrace();            &#125;        &#125;, <span class="string">&quot;BB&quot;</span>).start();    &#125;&#125;</code></pre><p>打印结果：</p><pre><code class="highlight shell">------sendSMS------sendEmail</code></pre><p>分析：synchronized 在静态方法上，是类级别的锁，所以两个方法持有的是同一把锁，要按顺序执行</p></li><li><p>1个静态同步方法,1个普通同步方法，1部手机，先打印短信还是邮件</p><pre><code class="highlight java"><span class="keyword">class</span> <span class="title class_">Phone</span> &#123;    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title function_">sendSMS</span><span class="params">()</span> <span class="keyword">throws</span> Exception &#123;        <span class="comment">//停留4秒</span>        TimeUnit.SECONDS.sleep(<span class="number">4</span>);        System.out.println(<span class="string">&quot;------sendSMS&quot;</span>);    &#125;    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">getHello</span><span class="params">()</span> &#123;        System.out.println(<span class="string">&quot;------getHello&quot;</span>);    &#125;&#125;<span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Lock_8</span> &#123;    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception &#123;        <span class="type">Phone</span> <span class="variable">phone</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Phone</span>();        <span class="keyword">new</span> <span class="title class_">Thread</span>(() -&gt; &#123;            <span class="keyword">try</span> &#123;                phone.sendSMS();            &#125; <span class="keyword">catch</span> (Exception e) &#123;                e.printStackTrace();            &#125;        &#125;, <span class="string">&quot;AA&quot;</span>).start();        Thread.sleep(<span class="number">100</span>);        <span class="keyword">new</span> <span class="title class_">Thread</span>(() -&gt; &#123;            <span class="keyword">try</span> &#123;                phone.getHello();            &#125; <span class="keyword">catch</span> (Exception e) &#123;                e.printStackTrace();            &#125;        &#125;, <span class="string">&quot;BB&quot;</span>).start();    &#125;&#125;</code></pre><p>打印结果：</p><pre><code class="highlight shell">------getHello------sendSMS</code></pre><p>分析：类加锁对普通方法无限制，普通方法调用即执行。</p></li><li><p>1个静态同步方法,1个普通同步方法，2部手机，先打印短信还是邮件</p><pre><code class="highlight java"><span class="keyword">class</span> <span class="title class_">Phone</span> &#123;    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title function_">sendSMS</span><span class="params">()</span> <span class="keyword">throws</span> Exception &#123;        <span class="comment">//停留4秒</span>        TimeUnit.SECONDS.sleep(<span class="number">4</span>);        System.out.println(<span class="string">&quot;------sendSMS&quot;</span>);    &#125;    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">sendEmail</span><span class="params">()</span> <span class="keyword">throws</span> Exception &#123;        System.out.println(<span class="string">&quot;------sendEmail&quot;</span>);    &#125;&#125;<span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Lock_8</span> &#123;    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception &#123;        <span class="type">Phone</span> <span class="variable">phone</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Phone</span>();        <span class="type">Phone</span> <span class="variable">phone2</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Phone</span>();        <span class="keyword">new</span> <span class="title class_">Thread</span>(() -&gt; &#123;            <span class="keyword">try</span> &#123;                phone.sendSMS();            &#125; <span class="keyword">catch</span> (Exception e) &#123;                e.printStackTrace();            &#125;        &#125;, <span class="string">&quot;AA&quot;</span>).start();        Thread.sleep(<span class="number">100</span>);        <span class="keyword">new</span> <span class="title class_">Thread</span>(() -&gt; &#123;            <span class="keyword">try</span> &#123;                phone2.sendEmail();            &#125; <span class="keyword">catch</span> (Exception e) &#123;                e.printStackTrace();            &#125;        &#125;, <span class="string">&quot;BB&quot;</span>).start();    &#125;&#125;</code></pre><p>打印结果：</p><pre><code class="highlight shell">------sendEmail------sendSMS</code></pre><p>分析：类加锁对普通方法无限制，普通方法调用即执行。</p></li></ol><p><strong>总结：</strong></p><ul><li>synchronized 锁的是方法，则是对象锁，同个对象锁的机制要等待，不同对象锁的机制调用同一个不用等待</li><li>加了static则为class锁而不是对象锁</li><li>对于同步方法块，锁是 synchronized 括号里配置对象</li></ul><h1 id="三、字节码角度分析-synchronized-实现"><a href="#三、字节码角度分析-synchronized-实现" class="headerlink" title="三、字节码角度分析 synchronized 实现"></a>三、字节码角度分析 synchronized 实现</h1><h2 id="1-synchronized-同步代码块"><a href="#1-synchronized-同步代码块" class="headerlink" title="1. synchronized 同步代码块"></a>1. synchronized 同步代码块</h2><h3 id="1-1-文件反编译技巧"><a href="#1-1-文件反编译技巧" class="headerlink" title="1.1 文件反编译技巧"></a>1.1 文件反编译技巧</h3><ul><li><p>文件反编译 <code>javap -c ***.class</code> 文件反编译，-c表示对代码进行反汇编</p></li><li><p>假如需要更多信息 <code>javap -v ***.class</code> ，-v 即 -verbose 输出附加信息（包括行号、本地变量表、反汇编等详细信息）</p></li></ul><h3 id="1-2-synchronized-同步代码块"><a href="#1-2-synchronized-同步代码块" class="headerlink" title="1.2 synchronized 同步代码块"></a>1.2 synchronized 同步代码块</h3><pre><code class="highlight java"><span class="comment">/**</span><span class="comment"> * 锁同步代码块</span><span class="comment"> */</span><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">LockSyncDemo</span> &#123;    <span class="type">Object</span> <span class="variable">object</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Object</span>();    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">m1</span><span class="params">()</span>&#123;        <span class="keyword">synchronized</span> (object)&#123;            System.out.println(<span class="string">&quot;-----hello synchronized code block&quot;</span>);        &#125;    &#125;    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;    &#125;&#125;</code></pre><h3 id="1-3-class-文件反编译"><a href="#1-3-class-文件反编译" class="headerlink" title="1.3 class 文件反编译"></a>1.3 class 文件反编译</h3><p>执行命令 <code>javap -c LockSyncDemo.class</code></p><pre><code class="highlight shell">public class com.georg.controller.LockSyncDemo &#123;  java.lang.Object object;  public com.zhang.admin.controller.LockSyncDemo();    Code:       0: aload_0       1: invokespecial #1                  // Method java/lang/Object.&quot;&lt;init&gt;&quot;:()V       4: aload_0       5: new           #2                  // class java/lang/Object       8: dup       9: invokespecial #1                  // Method java/lang/Object.&quot;&lt;init&gt;&quot;:()V      12: putfield      #3                  // Field object:Ljava/lang/Object;      15: return  public void m1();    Code:       0: aload_0       1: getfield      #3                  // Field object:Ljava/lang/Object;       4: dup       5: astore_1       6: monitorenter        //**注****------进入锁       7: getstatic     #4                  // Field java/lang/System.out:Ljava/io/PrintStream;      10: ldc           #5                  // String -----hello synchronized code block      12: invokevirtual #6                  // Method java/io/PrintStream.println:(Ljava/lang/String;)V      15: aload_1      16: monitorexit        // **注**------退出锁      17: goto          25      20: astore_2      21: aload_1      22: monitorexit        //**注**-----这里又有一个exit, 目的当出现异常时，保证能够释放锁      23: aload_2      24: athrow      25: return    Exception table:       from    to  target type           7    17    20   any          20    23    20   any  public static void main(java.lang.String[]);    Code:       0: return&#125;</code></pre><p><strong>总结</strong></p><ul><li>synchronized 同步代码块，实现使用的是<code>moniterenter</code> 和 <code>moniterexit</code> 指令（ <code>moniterexit</code> 可能有两个）</li><li>那一定是一个enter两个exit吗？（不一样，如果主动throw一个RuntimeException，发现一个enter，一个exit，还有两个athrow）</li></ul><h2 id="2-synchronized-普通同步方法"><a href="#2-synchronized-普通同步方法" class="headerlink" title="2. synchronized 普通同步方法"></a>2. synchronized 普通同步方法</h2><pre><code class="highlight java"><span class="comment">/**</span><span class="comment"> * 锁普通的同步方法</span><span class="comment"> */</span><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">LockSyncDemo</span> &#123;    <span class="keyword">public</span> <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title function_">m2</span><span class="params">()</span>&#123;        System.out.println(<span class="string">&quot;------hello synchronized m2&quot;</span>);    &#125;    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;    &#125;&#125;</code></pre><ul><li>类似于上述操作，最后调用 <code>javap -v LockSyncDemo.class</code></li></ul><pre><code class="highlight java">.....<span class="keyword">public</span> <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title function_">m2</span><span class="params">()</span>;    descriptor: ()V    flags: ACC_PUBLIC, ACC_SYNCHRONIZED <span class="comment">//请注意该标志</span>    Code:      stack=<span class="number">2</span>, locals=<span class="number">1</span>, args_size=<span class="number">1</span>         <span class="number">0</span>: getstatic     #<span class="number">2</span>                  <span class="comment">// Field java/lang/System.out:Ljava/io/PrintStream;</span>         <span class="number">3</span>: ldc           #<span class="number">3</span>                  <span class="comment">// String ------hello synchronized m2</span>         <span class="number">5</span>: invokevirtual #<span class="number">4</span>                  <span class="comment">// Method java/io/PrintStream.println:(Ljava/lang/String;)V</span>         <span class="number">8</span>: <span class="keyword">return</span>      LineNumberTable:        line <span class="number">11</span>: <span class="number">0</span>        line <span class="number">12</span>: <span class="number">8</span>      LocalVariableTable:        Start  Length  Slot  Name   Signature            <span class="number">0</span>       <span class="number">9</span>     <span class="number">0</span>  <span class="built_in">this</span>   Lcom/zhang/admin/controller/LockSyncDemo;......</code></pre><p><strong>总结</strong></p><p>调用指令将会检查方法的 <strong>ACC_SYNCHRONIZED</strong> 访问标志是否被设置。如果设置了，执行线程会先持有monitor, 然后再执行方法，最后在方法完成（无论是正常完成还是非正常完成）时释放monitor</p><h2 id="3-synchronized-静态同步方法"><a href="#3-synchronized-静态同步方法" class="headerlink" title="3. synchronized 静态同步方法"></a>3. synchronized 静态同步方法</h2><pre><code class="highlight java"><span class="comment">/**</span><span class="comment"> * 锁静态同步方法</span><span class="comment"> */</span><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">LockSyncDemo</span> &#123;    <span class="keyword">public</span> <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title function_">m2</span><span class="params">()</span>&#123;        System.out.println(<span class="string">&quot;------hello synchronized m2&quot;</span>);    &#125;    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title function_">m3</span><span class="params">()</span>&#123;        System.out.println(<span class="string">&quot;------hello synchronized m3---static&quot;</span>);    &#125;    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;    &#125;&#125;</code></pre><ul><li>调用 <code>javap -v LockSyncDemo.class</code></li></ul><pre><code class="highlight shell"> ...... public static synchronized void m3();    descriptor: ()V    flags: ACC_PUBLIC, ACC_STATIC, ACC_SYNCHRONIZED //访问标志 区分该方法是否是静态同步方法    Code:      stack=2, locals=0, args_size=0         0: getstatic     #2                  // Field java/lang/System.out:Ljava/io/PrintStream;         3: ldc           #5                  // String ------hello synchronized m3---static         5: invokevirtual #4                  // Method java/io/PrintStream.println:(Ljava/lang/String;)V         8: return      LineNumberTable:        line 15: 0        line 16: 8......</code></pre><p><strong>总结</strong></p><p><strong>ACC_STATIC</strong> 访问标志区分该方法是否是静态同步方法。</p><h1 id="四、反编译解析-synchronized-锁的是什么"><a href="#四、反编译解析-synchronized-锁的是什么" class="headerlink" title="四、反编译解析 synchronized 锁的是什么"></a>四、反编译解析 synchronized 锁的是什么</h1><h2 id="1-管程概念"><a href="#1-管程概念" class="headerlink" title="1. 管程概念"></a>1. 管程概念</h2><ul><li>管程：Monitor（监视器），也就是我们平时说的锁。监视器锁</li><li>信号量及其操作原语“封装”在一个对象内部）管程实现了在一个时间点，最多只有一个线程在执行管程的某个子程序。 管程提供了一种机制，管程可以看做一个软件模块，它是将共享的变量和对于这些共享变量的操作封装起来，形成一个具有一定接口的功能模块，进程可以调用管程来实现线程级别的并发控制。</li><li>执行线程就要求先成功持有管程，然后才能执行方法，最后当方法完成（无论是正常完成还是非正常完成）时释放管理。在方法执行期间，执行线程持有了管程，其他任何线程都无法再获取到同一个管程。</li></ul><h2 id="2-解释为什么任何一个对象都可以成为一个锁"><a href="#2-解释为什么任何一个对象都可以成为一个锁" class="headerlink" title="2. 解释为什么任何一个对象都可以成为一个锁"></a>2. 解释为什么任何一个对象都可以成为一个锁</h2><p>Java Object 类是所有类的父类，也就是说 Java 的所有类都继承了 Object，子类可以使用 Object 的所有方法。</p><ul><li><code>ObjectMonitor.java</code> → <code>ObjectMonitor.cpp</code> → <code>objectMonitor.hpp</code></li></ul><p><code>ObjectMonitor.cpp</code> 中引入了头文件（include）<code>objectMonitor.hpp</code></p><p><img src="https://raw.githubusercontent.com/GeorgeChan95/blogimg/master/img/2024/09/21/20240921-153217.png" alt="objectMonitor.hpp"></p><ul><li><p><strong>objectMonitor.hpp</strong></p><table><thead><tr><th>属性</th><th>作用</th></tr></thead><tbody><tr><td>_owner</td><td>指向持有ObjectMonitor对象的线程</td></tr><tr><td>_WaitSet</td><td>存放处于wait状态的线程队列</td></tr><tr><td>_EntryList</td><td>存放处于等待锁block状态的线程队列</td></tr><tr><td>_recursions</td><td>锁的重入次数</td></tr><tr><td>_count</td><td>用来记录该线程获取锁的次数</td></tr></tbody></table><p><strong>因此：每个对象天生都带着一个对象监视器</strong></p></li></ul><h1 id="五、关于锁升级"><a href="#五、关于锁升级" class="headerlink" title="五、关于锁升级"></a>五、关于锁升级</h1><p>这里只是简单提及，做个了解，后面会再做深入讲解</p><p>synchronized必须作用于某个对象中，所以Java在对象的头文件存储了锁的相关信息。锁升级功能主要依赖于 MarkWord 中的锁标志位和释放偏向锁标志位。</p><p><img src="https://raw.githubusercontent.com/GeorgeChan95/blogimg/master/img/2024/09/21/20240921-153834.png" alt="锁升级"></p><h1 id="六、公平锁和非公平锁"><a href="#六、公平锁和非公平锁" class="headerlink" title="六、公平锁和非公平锁"></a>六、公平锁和非公平锁</h1><h2 id="1-案例演示"><a href="#1-案例演示" class="headerlink" title="1. 案例演示"></a>1. 案例演示</h2><h3 id="1-1-非公平锁"><a href="#1-1-非公平锁" class="headerlink" title="1.1 非公平锁"></a>1.1 非公平锁</h3><p>使用 ReentrantLock 实现抢票的案例</p><pre><code class="highlight java"><span class="keyword">class</span> <span class="title class_">Ticket</span> &#123;    <span class="keyword">private</span> <span class="type">int</span> <span class="variable">number</span> <span class="operator">=</span> <span class="number">30</span>;    <span class="keyword">private</span> <span class="type">Lock</span> <span class="variable">lock</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ReentrantLock</span>(); <span class="comment">//默认用的是非公平锁，分配的平均一点，=--》公平一点</span>    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">sale</span><span class="params">()</span> &#123;        lock.lock();        <span class="keyword">try</span> &#123;            <span class="keyword">if</span> (number &gt; <span class="number">0</span>) &#123;                System.out.println(Thread.currentThread().getName() + <span class="string">&quot;\t 卖出第: &quot;</span> + (number--) + <span class="string">&quot;\t 还剩下: &quot;</span> + number);            &#125;        &#125; <span class="keyword">finally</span> &#123;            lock.unlock();        &#125;    &#125;&#125;<span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">SaleTicketDemo</span> &#123;    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;        <span class="type">Ticket</span> <span class="variable">ticket</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Ticket</span>();        <span class="keyword">new</span> <span class="title class_">Thread</span>(() -&gt; &#123;<span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">1</span>; i &lt;= <span class="number">55</span>; i++) ticket.sale();&#125;, <span class="string">&quot;a&quot;</span>).start();        <span class="keyword">new</span> <span class="title class_">Thread</span>(() -&gt; &#123;<span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">1</span>; i &lt;= <span class="number">55</span>; i++) ticket.sale();&#125;, <span class="string">&quot;b&quot;</span>).start();        <span class="keyword">new</span> <span class="title class_">Thread</span>(() -&gt; &#123;<span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">1</span>; i &lt;= <span class="number">55</span>; i++) ticket.sale();&#125;, <span class="string">&quot;c&quot;</span>).start();    &#125;&#125;</code></pre><p>运行结果，不同的线程抢到票的几率差距很大，线程执行不公平。</p><pre><code class="highlight shell">a 卖出第: 30 还剩下: 29a 卖出第: 29 还剩下: 28a 卖出第: 28 还剩下: 27a 卖出第: 27 还剩下: 26c 卖出第: 26 还剩下: 25c 卖出第: 25 还剩下: 24c 卖出第: 24 还剩下: 23c 卖出第: 23 还剩下: 22c 卖出第: 22 还剩下: 21c 卖出第: 21 还剩下: 20c 卖出第: 20 还剩下: 19c 卖出第: 19 还剩下: 18c 卖出第: 18 还剩下: 17c 卖出第: 17 还剩下: 16c 卖出第: 16 还剩下: 15c 卖出第: 15 还剩下: 14c 卖出第: 14 还剩下: 13c 卖出第: 13 还剩下: 12c 卖出第: 12 还剩下: 11c 卖出第: 11 还剩下: 10c 卖出第: 10 还剩下: 9c 卖出第: 9 还剩下: 8c 卖出第: 8 还剩下: 7c 卖出第: 7 还剩下: 6c 卖出第: 6 还剩下: 5c 卖出第: 5 还剩下: 4c 卖出第: 4 还剩下: 3c 卖出第: 3 还剩下: 2c 卖出第: 2 还剩下: 1c 卖出第: 1 还剩下: 0</code></pre><h3 id="1-2-公平锁"><a href="#1-2-公平锁" class="headerlink" title="1.2 公平锁"></a>1.2 公平锁</h3><p>使用 ReentrantLock 实现公平抢票的案例</p><pre><code class="highlight java"><span class="keyword">class</span> <span class="title class_">Ticket</span> &#123;    <span class="keyword">private</span> <span class="type">int</span> <span class="variable">number</span> <span class="operator">=</span> <span class="number">30</span>;    <span class="keyword">private</span> <span class="type">Lock</span> <span class="variable">lock</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ReentrantLock</span>(<span class="literal">true</span>); <span class="comment">//默认用的是非公平锁，传 true 则为公平锁</span>    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">sale</span><span class="params">()</span> &#123;        lock.lock();        <span class="keyword">try</span> &#123;            <span class="keyword">if</span> (number &gt; <span class="number">0</span>) &#123;                System.out.println(Thread.currentThread().getName() + <span class="string">&quot;\t 卖出第: &quot;</span> + (number--) + <span class="string">&quot;\t 还剩下: &quot;</span> + number);            &#125;        &#125; <span class="keyword">finally</span> &#123;            lock.unlock();        &#125;    &#125;&#125;<span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">SaleTicketDemo</span> &#123;    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;        <span class="type">Ticket</span> <span class="variable">ticket</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Ticket</span>();        <span class="keyword">new</span> <span class="title class_">Thread</span>(() -&gt; &#123;<span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">1</span>; i &lt;= <span class="number">55</span>; i++) ticket.sale();&#125;, <span class="string">&quot;a&quot;</span>).start();        <span class="keyword">new</span> <span class="title class_">Thread</span>(() -&gt; &#123;<span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">1</span>; i &lt;= <span class="number">55</span>; i++) ticket.sale();&#125;, <span class="string">&quot;b&quot;</span>).start();        <span class="keyword">new</span> <span class="title class_">Thread</span>(() -&gt; &#123;<span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">1</span>; i &lt;= <span class="number">55</span>; i++) ticket.sale();&#125;, <span class="string">&quot;c&quot;</span>).start();    &#125;&#125;</code></pre><p>执行结果，每个线程都得到了较为公平的执行机会。</p><pre><code class="highlight shell">a 卖出第: 30 还剩下: 29a 卖出第: 29 还剩下: 28a 卖出第: 28 还剩下: 27a 卖出第: 27 还剩下: 26b 卖出第: 26 还剩下: 25c 卖出第: 25 还剩下: 24a 卖出第: 24 还剩下: 23b 卖出第: 23 还剩下: 22c 卖出第: 22 还剩下: 21a 卖出第: 21 还剩下: 20b 卖出第: 20 还剩下: 19c 卖出第: 19 还剩下: 18a 卖出第: 18 还剩下: 17b 卖出第: 17 还剩下: 16c 卖出第: 16 还剩下: 15a 卖出第: 15 还剩下: 14b 卖出第: 14 还剩下: 13c 卖出第: 13 还剩下: 12a 卖出第: 12 还剩下: 11b 卖出第: 11 还剩下: 10c 卖出第: 10 还剩下: 9a 卖出第: 9 还剩下: 8b 卖出第: 8 还剩下: 7c 卖出第: 7 还剩下: 6a 卖出第: 6 还剩下: 5b 卖出第: 5 还剩下: 4c 卖出第: 4 还剩下: 3a 卖出第: 3 还剩下: 2b 卖出第: 2 还剩下: 1c 卖出第: 1 还剩下: 0</code></pre><h2 id="2-公平锁-非公平锁-概念解析"><a href="#2-公平锁-非公平锁-概念解析" class="headerlink" title="2. 公平锁&#x2F;非公平锁 概念解析"></a>2. 公平锁&#x2F;非公平锁 概念解析</h2><ul><li>公平锁：是指多个线程按照申请锁的顺序来获取锁，这里类似于排队买票，先来的人先买，后来的人再队尾排着，这是公平的—– Lock lock &#x3D; new ReentrantLock(true)—表示公平锁，先来先得。</li><li>非公平锁：是指多个线程获取锁的顺序并不是按照申请的顺序，有可能后申请的线程比先申请的线程优先获取锁，在高并发环境下，有可能造成优先级反转或者饥饿的状态（某个线程一直得不到锁）—- Lock lock &#x3D; new  ReentrantLock(false)—表示非公平锁，后来的也可能先获得锁，默认为非公平锁。</li></ul><h2 id="3-关于-公平锁-非公平锁-的相关问题"><a href="#3-关于-公平锁-非公平锁-的相关问题" class="headerlink" title="3. 关于 公平锁&#x2F;非公平锁 的相关问题"></a>3. 关于 公平锁&#x2F;非公平锁 的相关问题</h2><h3 id="3-1-为什么会有公平锁-非公平锁的设计为什么默认非公平？"><a href="#3-1-为什么会有公平锁-非公平锁的设计为什么默认非公平？" class="headerlink" title="3.1 为什么会有公平锁&#x2F;非公平锁的设计为什么默认非公平？"></a>3.1 为什么会有公平锁&#x2F;非公平锁的设计为什么默认非公平？</h3><ul><li>恢复挂起的线程到真正锁的获取还是有时间差的，从开发人员来看这个时间微乎其微，但是从CPU的角度来看，这个时间差存在的还是很明显的。所以非公平锁能更充分的利用CPU 的时间片，尽量减少 CPU 空闲状态时间。</li><li>使用多线程很重要的考量点是线程切换的开销，当采用非公平锁时，当1个线程请求锁获取同步状态，然后释放同步状态，因为不需要考虑是否还有前驱节点，所以刚释放锁的线程在此刻再次获取同步状态的概率就变得非常大，所以就减少了线程的开销。</li></ul><h3 id="3-2-使⽤公平锁会有什么问题"><a href="#3-2-使⽤公平锁会有什么问题" class="headerlink" title="3.2 使⽤公平锁会有什么问题"></a>3.2 使⽤公平锁会有什么问题</h3><p>公平锁保证了排队的公平性，非公平锁霸气的忽视这个规则，所以就有可能导致排队的长时间在排队，也没有机会获取到锁，这就是传说中的 “锁饥饿”</p><h3 id="3-3-什么时候用公平？什么时候用非公平？"><a href="#3-3-什么时候用公平？什么时候用非公平？" class="headerlink" title="3.3 什么时候用公平？什么时候用非公平？"></a>3.3 什么时候用公平？什么时候用非公平？</h3><ul><li>如果为了更高的吞吐量，很显然非公平锁是比较合适的，因为节省很多线程切换时间，吞吐量自然就上去了；</li><li>否则那就用公平锁，大家公平使用。</li></ul><h1 id="七、可重入锁"><a href="#七、可重入锁" class="headerlink" title="七、可重入锁"></a>七、可重入锁</h1><h2 id="1-概念解析"><a href="#1-概念解析" class="headerlink" title="1. 概念解析"></a>1. 概念解析</h2><p><strong>可重入锁又名递归锁</strong></p><ul><li><p>是指在同一个线程在外层方法获取锁的时候，再进入该线程的内层方法会自动获取锁(前提，锁对象得是同一个对象)，不会因为之前已经获取过还没释放而阻塞。</p></li><li><p>如果是1个有 <code>synchronized</code> 修饰的递归调用方法，程序第2次进入被自己阻塞了这样递归方法也就不能继续执行下去了。所以Java中 <code>ReentrantLock</code> 和<code>synchronized</code> 都是可重入锁，可重入锁的一个优点是可一定程度避免死锁。</p></li></ul><h2 id="2-可重入锁种类"><a href="#2-可重入锁种类" class="headerlink" title="2. 可重入锁种类"></a>2. 可重入锁种类</h2><h3 id="2-1-隐式锁"><a href="#2-1-隐式锁" class="headerlink" title="2.1 隐式锁"></a>2.1 隐式锁</h3><p>隐式锁（即synchronized关键字使用的锁）默认是可重入锁</p><ul><li><p>作用于同步代码块</p><pre><code class="highlight java"><span class="keyword">static</span> <span class="type">Object</span> <span class="variable">objectLock</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Object</span>();<span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">syncBlock</span><span class="params">()</span>&#123;    <span class="keyword">new</span> <span class="title class_">Thread</span>(() -&gt; &#123;        <span class="keyword">synchronized</span> (objectLock) &#123;<span class="comment">// lock</span>            System.out.println(<span class="string">&quot;-----外层&quot;</span>);            <span class="keyword">synchronized</span> (objectLock)            &#123;                System.out.println(<span class="string">&quot;-----中层&quot;</span>);                <span class="keyword">synchronized</span> (objectLock)                &#123;                    System.out.println(<span class="string">&quot;-----内层&quot;</span>);                &#125;            &#125;        &#125;<span class="comment">//unlock</span>    &#125;,<span class="string">&quot;t1&quot;</span>).start();&#125;</code></pre><p>打印结果：</p><pre><code class="highlight plaintext">-----外层-----中层-----内层</code></pre></li><li><p>作用于同步方法中</p><pre><code class="highlight java"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ReEntryLockDemo</span>&#123;    <span class="keyword">public</span> <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title function_">m1</span><span class="params">()</span>    &#123;        <span class="comment">//指的是可重复可递归调用的锁，在外层使用之后，在内层仍然可以使用，并且不发生死锁，这样的锁就叫做可重入锁</span>        System.out.println(Thread.currentThread().getName()+<span class="string">&quot;\t&quot;</span>+<span class="string">&quot;-----come in m1&quot;</span>);        m2();        System.out.println(Thread.currentThread().getName()+<span class="string">&quot;\t-----end m1&quot;</span>);    &#125;    <span class="keyword">public</span> <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title function_">m2</span><span class="params">()</span>    &#123;        System.out.println(<span class="string">&quot;-----m2&quot;</span>);        m3();    &#125;    <span class="keyword">public</span> <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title function_">m3</span><span class="params">()</span>    &#123;        System.out.println(<span class="string">&quot;-----m3&quot;</span>);    &#125;    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span>    &#123;        <span class="type">ReEntryLockDemo</span> <span class="variable">reEntryLockDemo</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ReEntryLockDemo</span>();        reEntryLockDemo.m1();    &#125;&#125;<span class="comment">/**</span><span class="comment"> * main  -----come in m1</span><span class="comment"> * -----m2</span><span class="comment"> * -----m3</span><span class="comment"> * main  -----end m1</span><span class="comment"> */</span></code></pre><p>打印结果：</p><pre><code class="highlight java">main  -----come in m1-----m2-----m3main  -----end m1</code></pre></li><li></li></ul><h3 id="2-2-显式锁"><a href="#2-2-显式锁" class="headerlink" title="2.2 显式锁"></a>2.2 显式锁</h3><p>显式锁（即Lock）也有 ReentrantLock 这样的可重入锁。</p><ul><li>ReentrantLock 实现的显示可重入锁</li></ul><pre><code class="highlight java"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;    <span class="type">Lock</span> <span class="variable">lock</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ReentrantLock</span>();    <span class="keyword">new</span> <span class="title class_">Thread</span>(() -&gt; &#123;        lock.lock();        <span class="keyword">try</span> &#123;            System.out.println(Thread.currentThread().getName() + <span class="string">&quot;\t&quot;</span> + <span class="string">&quot;-----外层&quot;</span>);            lock.lock();            <span class="keyword">try</span> &#123;                System.out.println(Thread.currentThread().getName() + <span class="string">&quot;\t&quot;</span> + <span class="string">&quot;-----内层&quot;</span>);            &#125; <span class="keyword">finally</span> &#123;                lock.unlock();            &#125;        &#125; <span class="keyword">finally</span> &#123;            lock.unlock();        &#125;    &#125;, <span class="string">&quot;t1&quot;</span>).start();    <span class="keyword">new</span> <span class="title class_">Thread</span>(() -&gt; &#123;        lock.lock();        <span class="keyword">try</span> &#123;            System.out.println(<span class="string">&quot;------22222&quot;</span>);        &#125; <span class="keyword">finally</span> &#123;            lock.unlock();        &#125;    &#125;, <span class="string">&quot;t2&quot;</span>).start();&#125;</code></pre><p>打印结果：</p><pre><code class="highlight shell">t1-----外层t1-----内层------22222</code></pre><h2 id="3-Synchronized的可重入锁实现机理"><a href="#3-Synchronized的可重入锁实现机理" class="headerlink" title="3. Synchronized的可重入锁实现机理"></a>3. Synchronized的可重入锁实现机理</h2><p>再看 <code>ObjectMoitor.hpp</code></p><pre><code class="highlight cpp"><span class="number">140</span>行  <span class="built_in">ObjectMonitor</span>() &#123;    _header       = <span class="literal">NULL</span>;    _count        = <span class="number">0</span>; <span class="comment">//用来记录该线程获取锁的次数</span>    _waiters      = <span class="number">0</span>,    _recursions   = <span class="number">0</span>; <span class="comment">//锁的重入次数</span>    _object       = <span class="literal">NULL</span>;    _owner        = <span class="literal">NULL</span>; <span class="comment">//------最重要的----指向持有ObjectMonitor对象的线程，记录哪个线程持有了我</span>    _WaitSet      = <span class="literal">NULL</span>; <span class="comment">//存放处于wait状态的线程队列</span>    _WaitSetLock  = <span class="number">0</span> ;    _Responsible  = <span class="literal">NULL</span> ;    _succ         = <span class="literal">NULL</span> ;    _cxq          = <span class="literal">NULL</span> ;    FreeNext      = <span class="literal">NULL</span> ;    _EntryList    = <span class="literal">NULL</span> ; <span class="comment">//存放处于等待锁block状态的线程队列</span>    _SpinFreq     = <span class="number">0</span> ;    _SpinClock    = <span class="number">0</span> ;    OwnerIsThread = <span class="number">0</span> ;    _previous_owner_tid = <span class="number">0</span>;  &#125;</code></pre><ul><li><code>ObjectMoitor.hpp</code><strong>底层</strong>：每个锁对象拥有一个锁计数器和一个指向持有该锁的线程的指针。<code>_count</code> <code>_owner</code></li><li><strong>首次加锁</strong>：当执行<code>monitorenter</code>时，如果目标锁对象的计数器为零，那么说明它没有被其他线程所持有，Java虚拟机会将该锁对象的持有线程设置为当前线程，并且将其计数器<code>加1</code>。</li><li><strong>重入</strong>：在目标锁对象的计数器不为零的情况下，如果锁对象的持有线程是当前线程，那么 Java 虚拟机可以将其计数器<code>加1</code>，否则需要等待，直至持有线程释放该锁。</li><li><strong>释放锁</strong>：当执行monitorexit时，Java虚拟机则需将锁对象的计数器减1。计数器为零代表锁已被释放。</li></ul><h2 id="4-死锁及排查"><a href="#4-死锁及排查" class="headerlink" title="4. 死锁及排查"></a>4. 死锁及排查</h2><h3 id="4-1-死锁是什么"><a href="#4-1-死锁是什么" class="headerlink" title="4.1 死锁是什么"></a>4.1 死锁是什么</h3><p>死锁是指两个或两个以上的线程在执行过程中,因争夺资源而造成的一种互相等待的现象,若无外力干涉那它们都将无法推进下去，如果系统资源充足，进程的资源请求都能够得到满足，死锁出现的可能性就很低，否则就会因争夺有限的资源而陷入死锁。</p><p><img src="https://raw.githubusercontent.com/GeorgeChan95/blogimg/master/img/2024/09/21/20240921-163418.png" alt="死锁"></p><h3 id="4-2-死锁产生的原因"><a href="#4-2-死锁产生的原因" class="headerlink" title="4.2 死锁产生的原因"></a>4.2 死锁产生的原因</h3><ul><li>系统资源不足</li><li>进程运行推进的顺序不合适</li><li>资源分配不当</li></ul><h3 id="4-3-死锁代码案例"><a href="#4-3-死锁代码案例" class="headerlink" title="4.3 死锁代码案例"></a>4.3 死锁代码案例</h3><pre><code class="highlight java"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">DeadLockDemo</span> &#123;    <span class="keyword">static</span> <span class="type">Object</span> <span class="variable">lockA</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Object</span>();    <span class="keyword">static</span> <span class="type">Object</span> <span class="variable">lockB</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Object</span>();    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;        <span class="type">Thread</span> <span class="variable">a</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Thread</span>(() -&gt; &#123;            <span class="keyword">synchronized</span> (lockA) &#123;                System.out.println(Thread.currentThread().getName() + <span class="string">&quot;\t&quot;</span> + <span class="string">&quot; 自己持有A锁，期待获得B锁&quot;</span>);                <span class="keyword">try</span> &#123;                    TimeUnit.SECONDS.sleep(<span class="number">1</span>);                &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;                    e.printStackTrace();                &#125;                <span class="keyword">synchronized</span> (lockB) &#123;                    System.out.println(Thread.currentThread().getName() + <span class="string">&quot;\t 获得B锁成功&quot;</span>);                &#125;            &#125;        &#125;, <span class="string">&quot;a&quot;</span>);        a.start();        <span class="keyword">new</span> <span class="title class_">Thread</span>(() -&gt; &#123;            <span class="keyword">synchronized</span> (lockB) &#123;                System.out.println(Thread.currentThread().getName() + <span class="string">&quot;\t&quot;</span> + <span class="string">&quot; 自己持有B锁，期待获得A锁&quot;</span>);                <span class="keyword">try</span> &#123;                    TimeUnit.SECONDS.sleep(<span class="number">1</span>);                &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;                    e.printStackTrace();                &#125;                <span class="keyword">synchronized</span> (lockA) &#123;                    System.out.println(Thread.currentThread().getName() + <span class="string">&quot;\t 获得A锁成功&quot;</span>);                &#125;            &#125;        &#125;, <span class="string">&quot;b&quot;</span>).start();    &#125;&#125;</code></pre><p>运行结果：</p><pre><code class="highlight shell">a 自己持有A锁，期待获得B锁b 自己持有B锁，期待获得A锁</code></pre><p>程序运行到此没有停止，一直等待着……</p><h3 id="4-4-如何排查死锁"><a href="#4-4-如何排查死锁" class="headerlink" title="4.4 如何排查死锁"></a>4.4 如何排查死锁</h3><h4 id="4-4-1-命令行"><a href="#4-4-1-命令行" class="headerlink" title="4.4.1 命令行"></a>4.4.1 命令行</h4><ul><li><code>jps -l</code> 查看当前进程运行状况</li><li><code>jstack 进程编号</code> 查看该进程信息</li></ul><pre><code class="highlight shell">PS F:\&gt; jps -l29104 33360 com.atguigu.juc.locks.DeadLockDemo11172 org.jetbrains.jps.cmdline.Launcher27412 org.jetbrains.idea.maven.server.RemoteMavenServer3630148 org.jetbrains.idea.maven.server.RemoteMavenServer3645796 sun.tools.jps.Jps<span class="meta prompt_"></span><span class="meta prompt_">#</span><span class="language-bash"><span class="comment">####################################################################################</span></span>PS F:\&gt; jstack 333602024-09-21 16:39:01Full thread dump Java HotSpot(TM) 64-Bit Server VM (25.241-b07 mixed mode):&quot;Finalizer&quot; #3 daemon prio=8 os_prio=1 tid=0x0000000026eea000 nid=0x8df0 in Object.wait() [0x000000002a8ff000]   java.lang.Thread.State: WAITING (on object monitor)        at java.lang.Object.wait(Native Method)        - waiting on &lt;0x0000000716508ee0&gt; (a java.lang.ref.ReferenceQueue$Lock)        at java.lang.ref.ReferenceQueue.remove(ReferenceQueue.java:144)        - locked &lt;0x0000000716508ee0&gt; (a java.lang.ref.ReferenceQueue$Lock)        at java.lang.ref.ReferenceQueue.remove(ReferenceQueue.java:165)        at java.lang.ref.Finalizer$FinalizerThread.run(Finalizer.java:216)&quot;Reference Handler&quot; #2 daemon prio=10 os_prio=2 tid=0x0000000028ba8000 nid=0x3cb4 in Object.wait() [0x000000002a7ff000]   java.lang.Thread.State: WAITING (on object monitor)        at java.lang.Object.wait(Native Method)        - waiting on &lt;0x0000000716506c00&gt; (a java.lang.ref.Reference$Lock)        at java.lang.Object.wait(Object.java:502)        at java.lang.ref.Reference.tryHandlePending(Reference.java:191)        - locked &lt;0x0000000716506c00&gt; (a java.lang.ref.Reference$Lock)        at java.lang.ref.Reference$ReferenceHandler.run(Reference.java:153)&quot;VM Periodic Task Thread&quot; os_prio=2 tid=0x000000002b8e4000 nid=0x1378 waiting on conditionJNI global references: 317Found one Java-level deadlock:=============================&quot;b&quot;:  waiting to lock monitor 0x0000000028bab9f8 (object 0x00000007166f0fe8, a java.lang.Object),  which is held by &quot;a&quot;&quot;a&quot;:  waiting to lock monitor 0x0000000028bae338 (object 0x00000007166f0ff8, a java.lang.Object),  which is held by &quot;b&quot;Java stack information for the threads listed above:===================================================&quot;b&quot;:        at com.atguigu.juc.locks.DeadLockDemo.lambda$main$1(DeadLockDemo.java:44)        - waiting to lock &lt;0x00000007166f0fe8&gt; (a java.lang.Object)        - locked &lt;0x00000007166f0ff8&gt; (a java.lang.Object)        at com.atguigu.juc.locks.DeadLockDemo$$Lambda$2/1199823423.run(Unknown Source)        at java.lang.Thread.run(Thread.java:748)&quot;a&quot;:        at com.atguigu.juc.locks.DeadLockDemo.lambda$main$0(DeadLockDemo.java:27)        - waiting to lock &lt;0x00000007166f0ff8&gt; (a java.lang.Object)        - locked &lt;0x00000007166f0fe8&gt; (a java.lang.Object)        at com.atguigu.juc.locks.DeadLockDemo$$Lambda$1/1342443276.run(Unknown Source)        at java.lang.Thread.run(Thread.java:748)Found 1 deadlock.</code></pre><h4 id="4-4-2-图形化工具"><a href="#4-4-2-图形化工具" class="headerlink" title="4.4.2 图形化工具"></a>4.4.2 图形化工具</h4><p>这里使用JDK 自带的 <code>jconsole</code> 演示，此工具在jdk的安装的 <code>bin目录</code> 下，双击 jconsole.exe 打开即可。</p><p><img src="https://raw.githubusercontent.com/GeorgeChan95/blogimg/master/img/2024/09/21/20240921-164427.png" alt="image-20240921164426956"></p><h1 id="八、总结"><a href="#八、总结" class="headerlink" title="八、总结"></a>八、总结</h1><p>指针指向monitor对象（也称为管程或监视器锁）的起始地址。每个对象都存在着一个monitor与之关联，当一个monitor被某个线程持有后，它便处于锁定状态。在Java虚拟机(HotSpot)中，monitor是由ObjectMonitor实现的，其主要数据结构如下（位于HotSpot虚拟机源码ObjectMonitor.hpp,C++实现的）<br><img src="https://raw.githubusercontent.com/GeorgeChan95/blogimg/master/img/2024/09/21/20240921-165034.png" alt="锁"></p>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;一、乐观锁和悲观锁&quot;&gt;&lt;a href=&quot;#一、乐观锁和悲观锁&quot; class=&quot;headerlink&quot; title=&quot;一、乐观锁和悲观锁&quot;&gt;&lt;/a&gt;一、乐观锁和悲观锁&lt;/h1&gt;&lt;h2 id=&quot;1-悲观锁&quot;&gt;&lt;a href=&quot;#1-悲观锁&quot; class=&quot;header</summary>
      
    
    
    
    <category term="JUC" scheme="https://georgechan95.github.io/categories/JUC/"/>
    
    
    <category term="juc" scheme="https://georgechan95.github.io/tags/juc/"/>
    
    <category term="java" scheme="https://georgechan95.github.io/tags/java/"/>
    
  </entry>
  
  <entry>
    <title>02-JUC进阶-CompletableFuture</title>
    <link href="https://georgechan95.github.io/blog/7e2d78eb.html"/>
    <id>https://georgechan95.github.io/blog/7e2d78eb.html</id>
    <published>2024-09-18T14:50:00.000Z</published>
    <updated>2024-09-20T12:20:12.477Z</updated>
    
    <content type="html"><![CDATA[<h1 id="一、Future接口概述"><a href="#一、Future接口概述" class="headerlink" title="一、Future接口概述"></a>一、Future接口概述</h1><p>Future接口（FutureTask实现类）定义了操作异步任务执行一些方法，如获取异步任务的执行结果、取消异步任务的执行、判断任务是否被取消、判断任务执行是否完毕等。</p><p>举例：比如主线程让一个子线程去执行任务，子线程可能比较耗时，启动子线程开始执行任务后，主线程就去做其他事情了，忙完其他事情或者先执行完，过了一会再才去获取子任务的执行结果或变更的任务状态。</p><h1 id="二、Future接口实现类FutureTask"><a href="#二、Future接口实现类FutureTask" class="headerlink" title="二、Future接口实现类FutureTask"></a>二、Future接口实现类FutureTask</h1><h2 id="1-Future接口能干什么"><a href="#1-Future接口能干什么" class="headerlink" title="1. Future接口能干什么"></a>1. Future接口能干什么</h2><p>Future是 Java5 新加的一个接口，它提供一种异步并行计算的功能，如果主线程需要执行一个很耗时的计算任务，我们会就可以通过Future把这个任务放进异步线程中执行，主线程继续处理其他任务或者先行结束，再通过Future获取计算结果。</p><p>Future接口定义了操作异步任务执行一些方法，如获取异步任务的执行结果、取消任务的执行、判断任务是否被取消、判断任务执行是否完毕等。</p><h2 id="2-Future接口相关架构"><a href="#2-Future接口相关架构" class="headerlink" title="2. Future接口相关架构"></a>2. Future接口相关架构</h2><p><img src="https://raw.githubusercontent.com/GeorgeChan95/blogimg/master/img/2024/09/18/20240918-171237.png" alt="Future接口架构"></p><ul><li><p>目的：异步多线程任务执行且返回有结果，三个特点：多线程、有返回、异步任务（班长为老师去买水作为新启动的异步多线程任务且买到水有结果返回）</p></li><li><p>代码实现：Runnable接口+Callable接口+Future接口和FutureTask实现类。</p><pre><code class="highlight java"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">FutureTaskDemo3</span> &#123;    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> ExecutionException, InterruptedException &#123;        FutureTask&lt;String&gt; futureTask = <span class="keyword">new</span> <span class="title class_">FutureTask</span>&lt;&gt;(<span class="keyword">new</span> <span class="title class_">MyThread</span>());        <span class="type">Thread</span> <span class="variable">thread</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Thread</span>(futureTask, <span class="string">&quot;t1&quot;</span>);        <span class="comment">// 启动一个新的线程</span>        thread.start();        System.out.println(futureTask.get());    &#125;&#125;<span class="keyword">class</span> <span class="title class_">MyThread</span> <span class="keyword">implements</span> <span class="title class_">Callable</span>&lt;String&gt; &#123;    <span class="meta">@Override</span>    <span class="keyword">public</span> String <span class="title function_">call</span><span class="params">()</span> <span class="keyword">throws</span> Exception &#123;        System.out.println(Thread.currentThread().getName() + <span class="string">&quot; come in ......&quot;</span>);        <span class="keyword">return</span> <span class="string">&quot;Hello Callable&quot;</span>;    &#125;&#125;</code></pre></li></ul><h2 id="3-Future编码实战和优缺点分析"><a href="#3-Future编码实战和优缺点分析" class="headerlink" title="3. Future编码实战和优缺点分析"></a>3. Future编码实战和优缺点分析</h2><p><strong>优点</strong></p><p>Future+线程池异步多线程任务配合，能显著提高程序的运行效率。</p><p><strong>缺点</strong></p><ul><li>get() 阻塞—一旦调用get()方法求结果，一旦调用不见不散，非要等到结果才会离开，不管你是否计算完成，如果没有计算完成容易程序堵塞。</li></ul>  <pre><code class="highlight java"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">FutureTaskDemo1</span> &#123;    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> ExecutionException, InterruptedException, TimeoutException &#123;        FutureTask&lt;String&gt; futureTask = <span class="keyword">new</span> <span class="title class_">FutureTask</span>&lt;&gt;(() -&gt; &#123;            System.out.println(<span class="string">&quot;-----come in FutureTask&quot;</span>);            <span class="keyword">try</span> &#123;                TimeUnit.SECONDS.sleep(<span class="number">3</span>);            &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;                e.printStackTrace();            &#125;            <span class="keyword">return</span> <span class="string">&quot;&quot;</span> + ThreadLocalRandom.current().nextInt(<span class="number">100</span>);        &#125;);        <span class="type">Thread</span> <span class="variable">t1</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Thread</span>(futureTask, <span class="string">&quot;t1&quot;</span>);        t1.start();        <span class="comment">//3秒钟后才出来结果，还没有计算你提前来拿(只要一调用get方法，对于结果就是不见不散，会导致阻塞)</span>        <span class="comment">//System.out.println(Thread.currentThread().getName()+&quot;\t&quot;+futureTask.get());</span>        <span class="comment">//3秒钟后才出来结果，我只想等待1秒钟，过时不候</span>        System.out.println(Thread.currentThread().getName() + <span class="string">&quot;\t&quot;</span> + futureTask.get(<span class="number">1L</span>, TimeUnit.SECONDS));        System.out.println(Thread.currentThread().getName() + <span class="string">&quot;\t&quot;</span> + <span class="string">&quot; run... here&quot;</span>);    &#125;&#125;</code></pre><ul><li>isDone() 轮询—轮询的方式会耗费无谓的cpu资源，而且也不见得能及时得到计算结果，如果想要异步获取结果，通常会以轮询的方式去获取结果，尽量不要阻塞。</li></ul>  <pre><code class="highlight java"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">FutureTaskDemo2</span> &#123;    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> ExecutionException, InterruptedException &#123;        FutureTask&lt;String&gt; futureTask = <span class="keyword">new</span> <span class="title class_">FutureTask</span>&lt;&gt;(() -&gt; &#123;            System.out.println(<span class="string">&quot;-----come in FutureTask&quot;</span>);            <span class="keyword">try</span> &#123;                TimeUnit.SECONDS.sleep(<span class="number">3</span>);            &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;                e.printStackTrace();            &#125;            <span class="keyword">return</span> <span class="string">&quot;&quot;</span> + ThreadLocalRandom.current().nextInt(<span class="number">100</span>);        &#125;);        <span class="keyword">new</span> <span class="title class_">Thread</span>(futureTask, <span class="string">&quot;t1&quot;</span>).start();        System.out.println(Thread.currentThread().getName() + <span class="string">&quot;\t&quot;</span> + <span class="string">&quot;线程完成任务&quot;</span>);        <span class="comment">/**</span><span class="comment">         * 用于阻塞式获取结果,如果想要异步获取结果,通常都会以轮询的方式去获取结果</span><span class="comment">         */</span>        <span class="keyword">while</span> (<span class="literal">true</span>) &#123;            <span class="keyword">if</span> (futureTask.isDone()) &#123;                System.out.println(futureTask.get());                <span class="keyword">break</span>;            &#125;        &#125;    &#125;&#125;</code></pre><p><strong>结论：</strong>Future对于结果的获取不是很友好，只能通过阻塞或轮询的方式得到任务的结果。</p><h2 id="4-完成复杂的任务"><a href="#4-完成复杂的任务" class="headerlink" title="4. 完成复杂的任务"></a>4. 完成复杂的任务</h2><ul><li><p>回调通知（Future支持）</p><ul><li>应对Future的完成时间，完成了可以告诉我，也就是我们的回调通知</li><li>通过轮询的方式去判断任务是否完成这样非常占cpu并且代码也不优雅</li></ul></li><li><p>创建异步任务：Future+线程池组合</p><pre><code class="highlight java"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">FutureTaskDemo4</span> &#123;    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> ExecutionException, InterruptedException &#123;        <span class="comment">// 创建线程池</span>        <span class="type">ExecutorService</span> <span class="variable">executorService</span> <span class="operator">=</span> Executors.newFixedThreadPool(<span class="number">5</span>);                FutureTask&lt;String&gt; futureTask = <span class="keyword">new</span> <span class="title class_">FutureTask</span>&lt;&gt;(() -&gt; &#123;            System.out.println(Thread.currentThread().getName() + <span class="string">&quot;-----come in FutureTask&quot;</span>);            <span class="keyword">try</span> &#123;                TimeUnit.SECONDS.sleep(<span class="number">3</span>);            &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;                e.printStackTrace();            &#125;            <span class="keyword">return</span> <span class="string">&quot;&quot;</span> + ThreadLocalRandom.current().nextInt(<span class="number">100</span>);        &#125;);        <span class="comment">// 异步提交任务</span>        executorService.submit(futureTask);        System.out.println(Thread.currentThread().getName() + <span class="string">&quot;\t&quot;</span> + <span class="string">&quot;线程完成任务&quot;</span>);        <span class="comment">/**</span><span class="comment">         * 用于阻塞式获取结果,如果想要异步获取结果,通常都会以轮询的方式去获取结果</span><span class="comment">         */</span>        <span class="keyword">while</span> (<span class="literal">true</span>) &#123;            <span class="keyword">if</span> (futureTask.isDone()) &#123;                System.out.println(futureTask.get());                <span class="keyword">break</span>;            &#125;        &#125;        <span class="comment">// 关闭线程池</span>        executorService.shutdown();    &#125;&#125;</code></pre></li><li><p>多个任务前后依赖可以组合处理（Future不支持）</p><ul><li>想将多个异步任务的结果组合起来，后一个异步任务的计算结果需要前一个异步任务的值</li><li>想将两个或多个异步计算合并成为一个异步计算，这几个异步计算互相独立，同时后面这个又依赖前一个处理的结果</li></ul></li><li><p>对计算速度选最快的（Future不支持）</p><ul><li>当Future集合中某个任务最快结束时，返回结果，返回第一名处理结果</li></ul></li></ul><p><strong>结论</strong></p><ul><li>对于简单的业务场景使用 Future 完全 ok</li><li>对于复杂业务场景，使用 Future 之前提供的 API 处理起来不够优雅，这时候需要使用 CompletableFuture 以声明式的方式优雅的处理这些需求。</li><li>Future能干的，CompletableFuture 都能干</li></ul><h1 id="三、CompletableFuture对Future的改进"><a href="#三、CompletableFuture对Future的改进" class="headerlink" title="三、CompletableFuture对Future的改进"></a>三、CompletableFuture对Future的改进</h1><h2 id="1-CompletableFuture为什么会出现"><a href="#1-CompletableFuture为什么会出现" class="headerlink" title="1. CompletableFuture为什么会出现"></a>1. CompletableFuture为什么会出现</h2><ul><li>get() 方法在 Future 计算完成之前会一直处在阻塞状态下，阻塞的方式和异步编程的设计理念相违背。</li><li>isDone() 方法容易耗费 cpu 资源（cpu空转），</li><li>对于真正的异步处理我们希望是可以通过传入回调函数，在Future结束时自动调用该回调函数，这样，我们就不用等待结果</li></ul><p>jdk8 设计出 CompletableFuture，CompletableFuture 提供了一种观察者模式类似的机制，可以让任务执行完成后通知监听的一方。</p><h2 id="2-CompletableFuture-和-CompletionStage-介绍"><a href="#2-CompletableFuture-和-CompletionStage-介绍" class="headerlink" title="2. CompletableFuture 和 CompletionStage 介绍"></a>2. CompletableFuture 和 CompletionStage 介绍</h2><p><strong>类架构说明</strong>：</p><p><img src="https://raw.githubusercontent.com/GeorgeChan95/blogimg/master/img/2024/09/19/20240919-093123.png" alt="CompletableFuture"></p><p><img src="https://raw.githubusercontent.com/GeorgeChan95/blogimg/master/img/2024/09/19/20240919-093420.png" alt="CompletableFuture"></p><ul><li><strong>接口CompletionStage</strong><ul><li>代表异步计算过程中的某一个阶段，一个阶段完成以后可能会触发另外一个阶段。<ul><li>有些类似Linux系统的管道分隔符传参数</li></ul></li><li>一个阶段的执行可能是被单个阶段的完成触发，也可能是由多个阶段一起触发</li><li>一个阶段的计算执行可以是一个 function, Consumer 或者 Runnable。<ul><li>比如: <code>stage.thenApply(x -&gt; square(x).thenAccept(x -&gt; System.out.print(x)).thenRun(0)-&gt; system.out.println())</code></li></ul></li></ul></li><li><strong>类CompletableFuture</strong><ul><li>在Java8中，CompletableFuture 提供了非常强大的 Future 的扩展功能，可以帮助我们简化异步编程的复杂性，并且提供了函数式编程的能力，可以通过回调的方式处理计算结果，也提供了转换和组合 CompletableFuture 的方法,</li><li>它可能代表一个明确完成的 Future，也有可能代表一个完成阶段 (CompletionStage)，它支持在计算完成以后触发一些函数或执行某些动作。</li><li>它实现了 Future 和 CompletionStage 接口</li></ul></li></ul><h2 id="3-四个核心静态方法，创建异步任务"><a href="#3-四个核心静态方法，创建异步任务" class="headerlink" title="3. 四个核心静态方法，创建异步任务"></a>3. 四个核心静态方法，创建异步任务</h2><p>四个静态构造方法</p><p><img src="https://raw.githubusercontent.com/GeorgeChan95/blogimg/master/img/2024/09/19/20240919-094354.png" alt="CompletableFuture静态方法"></p><p><strong>对于上述Executor参数说明：若没有指定，则使用默认的 <code>ForkJoinPoolCommonPool()</code> 作为它的线程池执行异步代码，如果指定线程池，则使用我们自定义的或者特别指定的线程池执行异步代码</strong></p><h3 id="3-1-四个静态方法演示"><a href="#3-1-四个静态方法演示" class="headerlink" title="3.1 四个静态方法演示"></a>3.1 四个静态方法演示</h3><pre><code class="highlight java"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">CompletableFutureBuildDemo</span> &#123;    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> ExecutionException, InterruptedException &#123;        <span class="comment">// 自定义线程池</span>        <span class="type">ThreadPoolExecutor</span> <span class="variable">threadPoolExecutor</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ThreadPoolExecutor</span>(                <span class="number">1</span>,                <span class="number">20</span>,                <span class="number">1L</span>,                TimeUnit.SECONDS,                <span class="keyword">new</span> <span class="title class_">LinkedBlockingQueue</span>&lt;&gt;(<span class="number">50</span>),                Executors.defaultThreadFactory(),                <span class="keyword">new</span> <span class="title class_">ThreadPoolExecutor</span>.AbortPolicy());        <span class="comment">// 无返回值，默认线程池</span>        CompletableFuture&lt;Void&gt; future1 = CompletableFuture.runAsync(() -&gt; &#123;            <span class="keyword">try</span> &#123;                TimeUnit.SECONDS.sleep(<span class="number">1</span>);            &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;                <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">RuntimeException</span>(e);            &#125;            System.out.println(Thread.currentThread().getName() + <span class="string">&quot;无返回值，默认线程池：ForkJoinPool&quot;</span>);        &#125;);        System.out.println(<span class="string">&quot;future1 ==&gt; &quot;</span> + future1.get());        <span class="comment">/*</span><span class="comment">        * 打印：</span><span class="comment">        ForkJoinPool.commonPool-worker-1无返回值，默认线程池：ForkJoinPool</span><span class="comment">        future1 ==&gt; null</span><span class="comment">        * */</span>        System.out.println(<span class="string">&quot;----------------------------------------------------------&quot;</span>);        <span class="comment">// 无返回值，自定义线程池</span>        CompletableFuture&lt;Void&gt; future2 = CompletableFuture.runAsync(() -&gt; &#123;            <span class="keyword">try</span> &#123;                TimeUnit.SECONDS.sleep(<span class="number">1</span>);            &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;                <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">RuntimeException</span>(e);            &#125;            System.out.println(Thread.currentThread().getName() + <span class="string">&quot;无返回值，自定义线程池&quot;</span>);        &#125;, threadPoolExecutor);        System.out.println(<span class="string">&quot;future2 ==&gt; &quot;</span> + future2.get());        <span class="comment">/*</span><span class="comment">        * 打印：</span><span class="comment">        pool-1-thread-1无返回值，自定义线程池</span><span class="comment">        future2 ==&gt; null</span><span class="comment">        * */</span>        System.out.println(<span class="string">&quot;----------------------------------------------------------&quot;</span>);        CompletableFuture&lt;String&gt; future3 = CompletableFuture.supplyAsync(() -&gt; &#123;            <span class="keyword">try</span> &#123;                TimeUnit.SECONDS.sleep(<span class="number">1</span>);            &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;                <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">RuntimeException</span>(e);            &#125;            System.out.println(Thread.currentThread().getName() + <span class="string">&quot;有返回值，默认线程池：ForkJoinPool&quot;</span>);            <span class="keyword">return</span> <span class="string">&quot;有返回值，默认线程池：ForkJoinPool&quot;</span>;        &#125;);        System.out.println(<span class="string">&quot;future3 ==&gt; &quot;</span> + future3.get());        <span class="comment">/*</span><span class="comment">        * 打印：</span><span class="comment">        ForkJoinPool.commonPool-worker-1有返回值，默认线程池：ForkJoinPool</span><span class="comment">        future3 ==&gt; 有返回值，默认线程池：ForkJoinPool</span><span class="comment">        * */</span>        System.out.println(<span class="string">&quot;----------------------------------------------------------&quot;</span>);        CompletableFuture&lt;String&gt; future4 = CompletableFuture.supplyAsync(() -&gt; &#123;            <span class="keyword">try</span> &#123;                TimeUnit.SECONDS.sleep(<span class="number">1</span>);            &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;                <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">RuntimeException</span>(e);            &#125;            System.out.println(Thread.currentThread().getName() + <span class="string">&quot;有返回值，自定义线程池&quot;</span>);            <span class="keyword">return</span> <span class="string">&quot;有返回值，自定义线程池&quot;</span>;        &#125;, threadPoolExecutor);        System.out.println(<span class="string">&quot;future4 ==&gt; &quot;</span> + future4.get());        <span class="comment">/*</span><span class="comment">        * 打印：</span><span class="comment">        pool-1-thread-1有返回值，自定义线程池</span><span class="comment">        future4 ==&gt; 有返回值，自定义线程池</span><span class="comment">        * */</span>        <span class="comment">// 关闭线程池</span>        threadPoolExecutor.shutdown();    &#125;&#125;</code></pre><h3 id="3-2-回调方法演示"><a href="#3-2-回调方法演示" class="headerlink" title="3.2 回调方法演示"></a>3.2 回调方法演示</h3><p>CompletableFuture 减少阻塞和轮询，可以传入回调对象，当异步任务完成或者发生异常时，自动调用回调对象的回调方法。</p><pre><code class="highlight java"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">CompletableFutureUseDemo</span> &#123;    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> InterruptedException &#123;        <span class="comment">// 自定义线程池</span>        <span class="type">ThreadPoolExecutor</span> <span class="variable">threadPoolExecutor</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ThreadPoolExecutor</span>(<span class="number">1</span>,                <span class="number">20</span>,                <span class="number">1</span>,                TimeUnit.SECONDS,                <span class="keyword">new</span> <span class="title class_">LinkedBlockingQueue</span>&lt;&gt;(<span class="number">5</span>),                Executors.defaultThreadFactory(),                <span class="keyword">new</span> <span class="title class_">ThreadPoolExecutor</span>.AbortPolicy());        CompletableFuture&lt;Integer&gt; completableFuture = CompletableFuture.supplyAsync(() -&gt; &#123;            System.out.println(Thread.currentThread().getName() + <span class="string">&quot; 线程运行中...&quot;</span>);            <span class="type">int</span> <span class="variable">result</span> <span class="operator">=</span> ThreadLocalRandom.current().nextInt(<span class="number">10</span>);            <span class="keyword">try</span> &#123;                TimeUnit.SECONDS.sleep(<span class="number">1</span>);            &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;                <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">RuntimeException</span>(e);            &#125;            <span class="keyword">if</span> (result &gt; <span class="number">5</span>) &#123;                <span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">10</span> / <span class="number">0</span>;            &#125;            <span class="keyword">return</span> result;        &#125;, threadPoolExecutor).whenComplete((v, e) -&gt; &#123; <span class="comment">// 当计算完成时调用</span>            <span class="keyword">if</span> (e == <span class="literal">null</span>) &#123;                System.out.println(Thread.currentThread().getName() + <span class="string">&quot; 线程计算完成，结果为：&quot;</span> + v);            &#125;        &#125;).exceptionally(e -&gt; &#123;            e.printStackTrace();            <span class="type">String</span> <span class="variable">msg</span> <span class="operator">=</span> String.format(<span class="string">&quot;%s 线程计算出现异常，原因：%s, 错误信息：%s&quot;</span>, Thread.currentThread().getName(), e.getCause(), e.getMessage());            System.out.println(msg);            <span class="keyword">return</span> -<span class="number">1</span>;        &#125;);        System.out.println(Thread.currentThread().getName() + <span class="string">&quot; 线程先去完成其他任务&quot;</span>);        <span class="comment">// 线程不要立刻结束，否则CompletableFuture默认使用的线程池会立刻关闭：暂停3秒钟线程</span>        TimeUnit.SECONDS.sleep(<span class="number">2</span>);        <span class="comment">// 关闭自定义线程池</span>        threadPoolExecutor.shutdown();    &#125;&#125;<span class="comment">/*</span><span class="comment">无异常时打印如下：</span><span class="comment">pool-1-thread-1 线程运行中...</span><span class="comment">main 线程先去完成其他任务</span><span class="comment">pool-1-thread-1 线程计算完成，结果为：2</span><span class="comment">* */</span><span class="comment">/*</span><span class="comment">有异常时打印如下：</span><span class="comment">pool-1-thread-1 线程运行中...</span><span class="comment">main 线程先去完成其他任务</span><span class="comment">java.util.concurrent.CompletionException: java.lang.ArithmeticException: / by zero</span><span class="comment">at java.base/java.util.concurrent.CompletableFuture.encodeThrowable(CompletableFuture.java:315)</span><span class="comment">at java.base/java.util.concurrent.CompletableFuture.completeThrowable(CompletableFuture.java:320)</span><span class="comment">at java.base/java.util.concurrent.CompletableFuture$AsyncSupply.run(CompletableFuture.java:1770)</span><span class="comment">at java.base/java.util.concurrent.ThreadPoolExecutor.runWorker(ThreadPoolExecutor.java:1136)</span><span class="comment">at java.base/java.util.concurrent.ThreadPoolExecutor$Worker.run(ThreadPoolExecutor.java:635)</span><span class="comment">at java.base/java.lang.Thread.run(Thread.java:842)</span><span class="comment">Caused by: java.lang.ArithmeticException: / by zero</span><span class="comment">at com.atguigu.juc.cf.CompletableFutureUseDemo.lambda$main$0(CompletableFutureUseDemo.java:32)</span><span class="comment">at java.base/java.util.concurrent.CompletableFuture$AsyncSupply.run(CompletableFuture.java:1768)</span><span class="comment">... 3 more</span><span class="comment">pool-1-thread-1 线程计算出现异常，原因：java.lang.ArithmeticException: / by zero, 错误信息：java.lang.ArithmeticException: / by zero</span><span class="comment">* */</span></code></pre><p>CompletableFuture优点：</p><ul><li>异步任务<strong>结束</strong>时，会自动回调某个对象的方法</li><li>主线程设置好回调后，不用关心异步任务的执行，异步任务之间可以顺序执行</li><li>异步任务<strong>出错</strong>时，会自动回调某个对象的方法</li></ul><h1 id="四、函数式编程"><a href="#四、函数式编程" class="headerlink" title="四、函数式编程"></a>四、函数式编程</h1><p>Lambda表达式+Stream流式调用+Chain链式调用+Java8函数式编程</p><h2 id="1-函数式接口"><a href="#1-函数式接口" class="headerlink" title="1. 函数式接口"></a>1. 函数式接口</h2><ul><li><p>Runnable：无参数、无返回值</p><p><img src="https://raw.githubusercontent.com/GeorgeChan95/blogimg/master/img/2024/09/19/20240919-110244.png" alt="Runnable"></p></li><li><p>Function：接受一个参数，并且有返回值</p><p><img src="https://raw.githubusercontent.com/GeorgeChan95/blogimg/master/img/2024/09/19/20240919-110317.png" alt="Function"></p></li><li><p>Consumer：接受一个参数，没有返回值</p><p><img src="https://raw.githubusercontent.com/GeorgeChan95/blogimg/master/img/2024/09/19/20240919-110409.png" alt="Consumer"></p></li><li><p>BiConsumer：接受两个参数，没有返回值</p><p><img src="https://raw.githubusercontent.com/GeorgeChan95/blogimg/master/img/2024/09/19/20240919-110436.png" alt="BiConsumer"></p></li><li><p>Supplier：没有参数，有返回值</p><p><img src="https://raw.githubusercontent.com/GeorgeChan95/blogimg/master/img/2024/09/19/20240919-110455.png" alt="Supplier"></p></li></ul><p><strong>总结：</strong></p><table><thead><tr><th>函数式接口名称</th><th>方法名称</th><th>参数</th><th>返回值</th></tr></thead><tbody><tr><td>Runnable</td><td>run</td><td>无参数</td><td>无返回值</td></tr><tr><td>Function</td><td>apply</td><td>1个参数</td><td>有返回值</td></tr><tr><td>Consume</td><td>accept</td><td>1个参数</td><td>无返回值</td></tr><tr><td>Supplier</td><td>get</td><td>没有参数</td><td>有返回值</td></tr><tr><td>Biconsumer</td><td>accept</td><td>2个参数</td><td>无返回值</td></tr></tbody></table><h2 id="2-链式编程"><a href="#2-链式编程" class="headerlink" title="2. 链式编程"></a>2. 链式编程</h2><pre><code class="highlight java"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Chain</span> &#123;    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;        <span class="comment">//-------------------老式写法------------</span><span class="comment">//        Student student = new Student();</span><span class="comment">//        student.setId(1);</span><span class="comment">//        student.setMajor(&quot;cs&quot;);</span><span class="comment">//        student.setName(&quot;小卡&quot;);</span>        <span class="keyword">new</span> <span class="title class_">Student</span>().setId(<span class="number">1</span>).setName(<span class="string">&quot;大卡&quot;</span>).setMajor(<span class="string">&quot;cs&quot;</span>);    &#125;    &#125;<span class="meta">@NoArgsConstructor</span><span class="meta">@AllArgsConstructor</span><span class="meta">@Data</span><span class="meta">@Accessors(chain = true)</span><span class="comment">//开启链式编程</span><span class="keyword">class</span> <span class="title class_">Student</span>&#123;    <span class="keyword">private</span> <span class="type">int</span> id;    <span class="keyword">private</span> String name;    <span class="keyword">private</span> String major;&#125;</code></pre><h1 id="五、join-和-get-对比"><a href="#五、join-和-get-对比" class="headerlink" title="五、join 和 get 对比"></a>五、join 和 get 对比</h1><p>join 与 get 功能几乎一样，区别在于编码时是否需要抛出异常</p><ul><li>get() 方法需要抛出异常</li><li>join() 方法不需要抛出异常</li></ul><pre><code class="highlight java"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Chain</span> &#123;    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> ExecutionException, InterruptedException &#123; <span class="comment">//抛出异常</span>        CompletableFuture&lt;String&gt; completableFuture = CompletableFuture.supplyAsync(() -&gt; &#123;            <span class="keyword">return</span> <span class="string">&quot;hello 12345&quot;</span>;        &#125;);        System.out.println(completableFuture.get());    &#125;&#125;<span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Chain</span> &#123;    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span>  &#123;<span class="comment">// 不用抛出异常</span>        CompletableFuture&lt;String&gt; completableFuture = CompletableFuture.supplyAsync(() -&gt; &#123;            <span class="keyword">return</span> <span class="string">&quot;hello 12345&quot;</span>;        &#125;);        System.out.println(completableFuture.join());    &#125;&#125;</code></pre><h1 id="六、CompletableFuture-案例讲解"><a href="#六、CompletableFuture-案例讲解" class="headerlink" title="六、CompletableFuture 案例讲解"></a>六、CompletableFuture 案例讲解</h1><h2 id="1-需求说明"><a href="#1-需求说明" class="headerlink" title="1. 需求说明"></a>1. 需求说明</h2><p>电商网站比价需求分析：</p><ol><li><p>需求说明：</p></li><li><ol><li>同一款产品，同时搜索出同款产品在各大电商平台的售价</li><li>同一款产品，同时搜索出本产品在同一个电商平台下，各个入驻卖家售价是多少</li></ol></li><li><p>输出返回：</p></li><li><ol><li>出来结果希望是同款产品的在不同地方的价格清单列表，返回一个List<String></li></ol></li></ol><p>例如：《Mysql》 in jd price is 88.05  《Mysql》 in taobao price is 90.43</p><ol><li><p>解决方案，对比同一个产品在各个平台上的价格，要求获得一个清单列表</p></li><li><ol><li>step by step，按部就班，查完淘宝查京东，查完京东查天猫….</li><li>all in，万箭齐发，一口气多线程异步任务同时查询</li></ol></li></ol><h2 id="2-不使用多线程实现需求"><a href="#2-不使用多线程实现需求" class="headerlink" title="2. 不使用多线程实现需求"></a>2. 不使用多线程实现需求</h2><p>从不同的网站逐个查询，直到所有网站查询完成，返回结果。</p><pre><code class="highlight java"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">NetMallCase</span> &#123;    <span class="keyword">static</span> List&lt;NetMall&gt; list = Arrays.asList(            <span class="keyword">new</span> <span class="title class_">NetMall</span>(<span class="string">&quot;jd&quot;</span>),            <span class="keyword">new</span> <span class="title class_">NetMall</span>(<span class="string">&quot;pdd&quot;</span>),            <span class="keyword">new</span> <span class="title class_">NetMall</span>(<span class="string">&quot;taobao&quot;</span>),            <span class="keyword">new</span> <span class="title class_">NetMall</span>(<span class="string">&quot;dangdangwang&quot;</span>),            <span class="keyword">new</span> <span class="title class_">NetMall</span>(<span class="string">&quot;tmall&quot;</span>)    );    <span class="comment">/**</span><span class="comment">     * 不使用多线程，获取图书在不同平台的价格</span><span class="comment">     * <span class="doctag">@param</span> list</span><span class="comment">     * <span class="doctag">@param</span> productName</span><span class="comment">     * <span class="doctag">@return</span></span><span class="comment">     */</span>    <span class="keyword">public</span> <span class="keyword">static</span> List&lt;String&gt; <span class="title function_">getPriceByStep</span><span class="params">(List&lt;NetMall&gt; list, String productName)</span> &#123;        List&lt;String&gt; result = list.stream().map(netMall -&gt; &#123;            <span class="type">String</span> <span class="variable">str</span> <span class="operator">=</span> String.format(productName + <span class="string">&quot; in %s price is %.2f&quot;</span>, netMall.getMallName(), netMall.calcPrice(productName));            <span class="keyword">return</span> str;        &#125;).collect(Collectors.toList());        <span class="keyword">return</span> result;    &#125;    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;        <span class="type">long</span> <span class="variable">startTime</span> <span class="operator">=</span> System.currentTimeMillis();        List&lt;String&gt; resuts = getPriceByStep(list, <span class="string">&quot;mysql&quot;</span>);        <span class="keyword">for</span> (String data : resuts) &#123;            System.out.println(data);        &#125;        <span class="type">long</span> <span class="variable">endTime</span> <span class="operator">=</span> System.currentTimeMillis();        System.out.println(<span class="string">&quot;不使用多线程，costTime: &quot;</span> + (endTime - startTime) + <span class="string">&quot; 毫秒&quot;</span>);    &#125;&#125;<span class="keyword">class</span> <span class="title class_">NetMallData</span> &#123;    <span class="meta">@Getter</span>    <span class="keyword">private</span> String mallName;    <span class="keyword">public</span> <span class="title function_">NetMallData</span><span class="params">(String mallName)</span> &#123;        <span class="built_in">this</span>.mallName = mallName;    &#125;    <span class="keyword">public</span> <span class="type">double</span> <span class="title function_">calcPrice</span><span class="params">(String productName)</span> &#123;        <span class="comment">//检索需要1秒钟</span>        <span class="keyword">try</span> &#123;            TimeUnit.SECONDS.sleep(<span class="number">1</span>);        &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;            e.printStackTrace();        &#125;        <span class="keyword">return</span> ThreadLocalRandom.current().nextDouble() * <span class="number">2</span> + productName.charAt(<span class="number">0</span>);    &#125;&#125;</code></pre><p>执行结果：</p><pre><code class="highlight shell">mysql in jd price is 109.95mysql in pdd price is 109.86mysql in taobao price is 109.79mysql in dangdangwang price is 110.08mysql in tmall price is 110.55不使用多线程，costTime: 5070 毫秒</code></pre><p>多个查询逐个完成，执行效率低，执行时间长。</p><h2 id="3-使用-CompletableFuture-实现需求"><a href="#3-使用-CompletableFuture-实现需求" class="headerlink" title="3. 使用 CompletableFuture 实现需求"></a>3. 使用 CompletableFuture 实现需求</h2><pre><code class="highlight java"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">NetMallCase</span> &#123;    <span class="keyword">static</span> List&lt;NetMall&gt; list = Arrays.asList(            <span class="keyword">new</span> <span class="title class_">NetMall</span>(<span class="string">&quot;jd&quot;</span>),            <span class="keyword">new</span> <span class="title class_">NetMall</span>(<span class="string">&quot;pdd&quot;</span>),            <span class="keyword">new</span> <span class="title class_">NetMall</span>(<span class="string">&quot;taobao&quot;</span>),            <span class="keyword">new</span> <span class="title class_">NetMall</span>(<span class="string">&quot;dangdangwang&quot;</span>),            <span class="keyword">new</span> <span class="title class_">NetMall</span>(<span class="string">&quot;tmall&quot;</span>)    );    <span class="comment">/**</span><span class="comment">     * 不使用多线程，获取图书在不同平台的价格</span><span class="comment">     *</span><span class="comment">     * <span class="doctag">@param</span> list</span><span class="comment">     * <span class="doctag">@param</span> productName</span><span class="comment">     * <span class="doctag">@return</span></span><span class="comment">     */</span>    <span class="keyword">public</span> <span class="keyword">static</span> List&lt;String&gt; <span class="title function_">getPriceByStep</span><span class="params">(List&lt;NetMall&gt; list, String productName)</span> &#123;        List&lt;String&gt; result = list.stream().map(netMall -&gt; &#123;            <span class="type">String</span> <span class="variable">str</span> <span class="operator">=</span> String.format(productName + <span class="string">&quot; in %s price is %.2f&quot;</span>, netMall.getMallName(), netMall.calcPrice(productName));            <span class="keyword">return</span> str;        &#125;).collect(Collectors.toList());        <span class="keyword">return</span> result;    &#125;    <span class="comment">/**</span><span class="comment">     * 使用多线程异步的从不同平台获取图书价格</span><span class="comment">     *</span><span class="comment">     * <span class="doctag">@param</span> list</span><span class="comment">     * <span class="doctag">@param</span> productName</span><span class="comment">     * <span class="doctag">@return</span></span><span class="comment">     */</span>    <span class="keyword">public</span> <span class="keyword">static</span> List&lt;String&gt; <span class="title function_">getPriceByAsync</span><span class="params">(List&lt;NetMall&gt; list, String productName)</span> &#123;        List&lt;String&gt; results = list.stream().map(netMall -&gt;                        CompletableFuture.supplyAsync(() -&gt; String.format(productName + <span class="string">&quot; in %s price is %.2f&quot;</span>, netMall.getMallName(), netMall.calcPrice(productName))))                .collect(Collectors.toList())                .stream()                .map(CompletableFuture::join)                .collect(Collectors.toList());        <span class="keyword">return</span> results;    &#125;    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;        <span class="comment">// 使用异步多线程获取</span>        <span class="type">long</span> <span class="variable">startTime2</span> <span class="operator">=</span> System.currentTimeMillis();        List&lt;String&gt; resuts2 = getPriceByAsync(list, <span class="string">&quot;mysql&quot;</span>);        <span class="keyword">for</span> (String data : resuts2) &#123;            System.out.println(data);        &#125;        <span class="type">long</span> <span class="variable">endTime2</span> <span class="operator">=</span> System.currentTimeMillis();        System.out.println(<span class="string">&quot;使用异步多线程，costTime: &quot;</span> + (endTime2 - startTime2) + <span class="string">&quot; 毫秒&quot;</span>);    &#125;&#125;<span class="keyword">class</span> <span class="title class_">NetMallData</span> &#123;    <span class="meta">@Getter</span>    <span class="keyword">private</span> String mallName;    <span class="keyword">public</span> <span class="title function_">NetMallData</span><span class="params">(String mallName)</span> &#123;        <span class="built_in">this</span>.mallName = mallName;    &#125;    <span class="keyword">public</span> <span class="type">double</span> <span class="title function_">calcPrice</span><span class="params">(String productName)</span> &#123;        <span class="comment">//检索需要1秒钟</span>        <span class="keyword">try</span> &#123;            TimeUnit.SECONDS.sleep(<span class="number">1</span>);        &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;            e.printStackTrace();        &#125;        <span class="keyword">return</span> ThreadLocalRandom.current().nextDouble() * <span class="number">2</span> + productName.charAt(<span class="number">0</span>);    &#125;&#125;</code></pre><p>执行结果：</p><pre><code class="highlight shell">mysql in jd price is 110.91mysql in pdd price is 109.59mysql in taobao price is 109.30mysql in dangdangwang price is 110.85mysql in tmall price is 110.67使用异步多线程，costTime: 1056 毫秒</code></pre><p>使用异步多线程，执行效率大大提升。</p><h1 id="七、CompletableFuture-常用API"><a href="#七、CompletableFuture-常用API" class="headerlink" title="七、CompletableFuture 常用API"></a>七、CompletableFuture 常用API</h1><h2 id="1-获得结果和触发计算"><a href="#1-获得结果和触发计算" class="headerlink" title="1.获得结果和触发计算"></a>1.获得结果和触发计算</h2><ul><li><p>获取结果</p><ul><li><code>public T get()</code>  阻塞等待，直到得到返回结果</li><li><code>public T get(long timeout,TimeUnit unit)</code>  阻塞等待指定的时长，超时则报错：TimeOutException</li><li><code>public T join()</code>  类似于get()，区别在于不需要抛出异常</li><li><code>public T getNow(T valueIfAbsent)</code>  立即获取结果不阻塞<ul><li>计算完，返回计算完成后的结果</li><li>没算完，返回设定的valueAbsent(直接返回了备胎值xxx)</li></ul></li></ul></li><li><p>主动触发计算</p><ul><li><code>public boolean complete(T value)</code>  是否立即打断get()方法返回括号值<ul><li>(执行要2s，等待只有1s，所以还没执行完就被打断了。返回true表示打断了获取这个过程，直接返回了备胎值 complete；如果没打断，返回false 和原来的abc)</li></ul></li></ul><pre><code class="highlight java"><span class="comment">/**</span><span class="comment"> * 获得结果和触发计算</span><span class="comment"> *</span><span class="comment"> * <span class="doctag">@throws</span> InterruptedException</span><span class="comment"> * <span class="doctag">@throws</span> ExecutionException</span><span class="comment"> */</span><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">m1</span><span class="params">()</span> <span class="keyword">throws</span> InterruptedException, ExecutionException &#123;    <span class="type">ThreadPoolExecutor</span> <span class="variable">threadPoolExecutor</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ThreadPoolExecutor</span>(<span class="number">1</span>, <span class="number">20</span>, <span class="number">1L</span>, TimeUnit.SECONDS, <span class="keyword">new</span> <span class="title class_">LinkedBlockingQueue</span>&lt;&gt;(<span class="number">50</span>), Executors.defaultThreadFactory(), <span class="keyword">new</span> <span class="title class_">ThreadPoolExecutor</span>.AbortPolicy());    CompletableFuture&lt;Integer&gt; future = CompletableFuture.supplyAsync(() -&gt; &#123;        <span class="comment">//暂停几秒钟线程</span>        <span class="comment">//暂停几秒钟线程</span>        <span class="keyword">try</span> &#123;            TimeUnit.SECONDS.sleep(<span class="number">2</span>);        &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;            e.printStackTrace();        &#125;        <span class="keyword">return</span> <span class="number">1</span>;    &#125;, threadPoolExecutor);    <span class="comment">//System.out.println(future.get()); // 1</span>    <span class="comment">//System.out.println(future.get(2L,TimeUnit.SECONDS)); // 1</span>    <span class="comment">//暂停几秒钟线程</span>    <span class="keyword">try</span> &#123;        TimeUnit.SECONDS.sleep(<span class="number">1</span>);    &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;        e.printStackTrace();    &#125;    <span class="comment">//System.out.println(future.getNow(9999));</span>    System.out.println(future.complete(-<span class="number">44</span>) + <span class="string">&quot;\t&quot;</span> + future.get());        <span class="comment">// 关闭线程池</span>    threadPoolExecutor.shutdown();&#125;</code></pre><p>打印结果：</p><pre><code class="highlight shell">true-44</code></pre></li></ul><h2 id="2-对计算结果进行处理"><a href="#2-对计算结果进行处理" class="headerlink" title="2. 对计算结果进行处理"></a>2. 对计算结果进行处理</h2><ul><li><p><code>thenApply </code> 计算结果存在在依赖关系，使得线程串行化。因为依赖关系，所以一旦有异常，直接叫停。</p><pre><code class="highlight java"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">thenApplyDemo</span><span class="params">()</span> <span class="keyword">throws</span> InterruptedException &#123;    <span class="type">ThreadPoolExecutor</span> <span class="variable">threadPoolExecutor</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ThreadPoolExecutor</span>(<span class="number">1</span>, <span class="number">20</span>, <span class="number">1L</span>, TimeUnit.SECONDS, <span class="keyword">new</span> <span class="title class_">LinkedBlockingQueue</span>&lt;&gt;(<span class="number">50</span>), Executors.defaultThreadFactory(), <span class="keyword">new</span> <span class="title class_">ThreadPoolExecutor</span>.AbortPolicy());    CompletableFuture&lt;Integer&gt; completableFuture = CompletableFuture.supplyAsync(() -&gt; &#123;        <span class="type">int</span> <span class="variable">result</span> <span class="operator">=</span> ThreadLocalRandom.current().nextInt(<span class="number">10</span>);        <span class="keyword">try</span> &#123;            TimeUnit.SECONDS.sleep(<span class="number">1</span>);        &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;            <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">RuntimeException</span>(e);        &#125;        <span class="keyword">if</span> (result &gt; <span class="number">5</span>) &#123;            <span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">10</span> / <span class="number">0</span>;        &#125;        <span class="keyword">return</span> <span class="number">1</span>;    &#125;, threadPoolExecutor).thenApply(data -&gt; data + <span class="number">2</span>).whenComplete((v, e) -&gt; &#123;        <span class="keyword">if</span> (e == <span class="literal">null</span>) &#123;            System.out.println(<span class="string">&quot;执行完成，结果：&quot;</span> + v);        &#125;    &#125;).exceptionally(e -&gt; &#123;        e.printStackTrace();        <span class="type">String</span> <span class="variable">msg</span> <span class="operator">=</span> String.format(<span class="string">&quot;执行出现异常，原因：%s, 异常信息：%s&quot;</span>, e.getCause(), e.getMessage());        System.out.println(msg);        <span class="keyword">return</span> -<span class="number">1</span>;    &#125;);        System.out.println(<span class="string">&quot;执行结束，结果：&quot;</span> + completableFuture.join());    <span class="comment">// 关闭自定义线程池</span>    threadPoolExecutor.shutdown();    <span class="comment">// 主线程停留3秒</span>    TimeUnit.SECONDS.sleep(<span class="number">3</span>);&#125;</code></pre><p>正常执行结束打印：</p><pre><code class="highlight shell">执行完成，结果：3执行结束，结果：3</code></pre><p>异常执行结束打印：</p><pre><code class="highlight shell">java.util.concurrent.CompletionException: java.lang.ArithmeticException: / by zeroat java.util.concurrent.CompletableFuture.encodeThrowable(CompletableFuture.java:273)at java.util.concurrent.CompletableFuture.completeThrowable(CompletableFuture.java:280)at java.util.concurrent.CompletableFuture$AsyncSupply.run(CompletableFuture.java:1606)at java.util.concurrent.ThreadPoolExecutor.runWorker(ThreadPoolExecutor.java:1149)at java.util.concurrent.ThreadPoolExecutor$Worker.run(ThreadPoolExecutor.java:624)at java.lang.Thread.run(Thread.java:748)Caused by: java.lang.ArithmeticException: / by zeroat com.atguigu.juc.cf.CompletableFutureDemo.lambda$thenApplyDemo$0(CompletableFutureDemo.java:27)at java.util.concurrent.CompletableFuture$AsyncSupply.run(CompletableFuture.java:1604)... 3 more执行出现异常，原因：java.lang.ArithmeticException: / by zero, 异常信息：java.lang.ArithmeticException: / by zero执行结束，结果：-1</code></pre></li><li><p><code>handle </code> 类似于 thenApply，但是有异常的话仍然可以往下走一步。</p><pre><code class="highlight java"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">handleDemo</span><span class="params">()</span> <span class="keyword">throws</span> InterruptedException &#123;    <span class="comment">// 自定义线程池</span>    <span class="type">ThreadPoolExecutor</span> <span class="variable">threadPool</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ThreadPoolExecutor</span>(            <span class="number">4</span>,            <span class="number">5</span>,            <span class="number">50</span>,            TimeUnit.SECONDS,            <span class="keyword">new</span> <span class="title class_">LinkedBlockingQueue</span>&lt;&gt;(<span class="number">10</span>),            Executors.defaultThreadFactory(),            <span class="keyword">new</span> <span class="title class_">ThreadPoolExecutor</span>.AbortPolicy());    CompletableFuture.supplyAsync(() -&gt; &#123;        <span class="type">int</span> <span class="variable">result</span> <span class="operator">=</span> ThreadLocalRandom.current().nextInt(<span class="number">10</span>);        <span class="keyword">try</span> &#123;            TimeUnit.SECONDS.sleep(<span class="number">1</span>);        &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;            <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">RuntimeException</span>(e);        &#125;        <span class="keyword">if</span> (result &gt; <span class="number">5</span>) &#123;            <span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">10</span> / <span class="number">0</span>;        &#125;        <span class="keyword">return</span> <span class="number">10</span>;    &#125;, threadPool).handle((v, e) -&gt; &#123;        <span class="keyword">if</span> (e == <span class="literal">null</span>) &#123;            System.out.println(<span class="string">&quot;handle1执行完成，结果：&quot;</span> + v);        &#125; <span class="keyword">else</span> &#123;            System.out.println(<span class="string">&quot;handle1执行异常&quot;</span>);        &#125;        <span class="keyword">return</span> v + <span class="number">1</span>;    &#125;).handle((v, e) -&gt; &#123;        <span class="keyword">if</span> (e == <span class="literal">null</span>) &#123;            System.out.println(<span class="string">&quot;handle2执行完成，结果：&quot;</span> + v);        &#125; <span class="keyword">else</span> &#123;            System.out.println(<span class="string">&quot;handle2执行异常&quot;</span>);        &#125;        <span class="keyword">return</span> <span class="string">&quot;abc&quot;</span>;    &#125;).handle((v, e) -&gt; &#123;        <span class="keyword">if</span> (e == <span class="literal">null</span>) &#123;            System.out.println(<span class="string">&quot;handle3执行完成，结果：&quot;</span> + v);        &#125; <span class="keyword">else</span> &#123;            System.out.println(<span class="string">&quot;handle3执行异常&quot;</span>);        &#125;        <span class="keyword">return</span> <span class="string">&quot;xyz&quot;</span>;    &#125;).whenCompleteAsync((v, e) -&gt; &#123;        <span class="keyword">if</span> (e == <span class="literal">null</span>) &#123;            System.out.println(Thread.currentThread().getName() + <span class="string">&quot; whenComplete执行完成，结果：&quot;</span> + v);        &#125;    &#125;, threadPool).exceptionally(e -&gt; &#123;        e.printStackTrace();        <span class="type">String</span> <span class="variable">msg</span> <span class="operator">=</span> String.format(<span class="string">&quot;执行出现异常，原因：%s, 异常信息：%s&quot;</span>, e.getCause(), e.getMessage());        System.out.println(msg);        <span class="keyword">return</span> <span class="string">&quot;error&quot;</span>;    &#125;);    TimeUnit.SECONDS.sleep(<span class="number">5</span>);    <span class="comment">// 关闭线程池</span>    threadPool.shutdown();&#125;</code></pre><p>正常执行结束打印：</p><pre><code class="highlight shell">handle1执行完成，结果：10handle2执行完成，结果：11whenComplete执行完成，结果：abc</code></pre><p>异常执行结束打印：</p><pre><code class="highlight shell">handle1执行异常handle2执行异常handle3执行完成，结果：abcpool-1-thread-2 whenComplete执行完成，结果：xyz</code></pre><p><strong>注意：</strong>当 <code>supplyAsync</code> 方法执行异常时， 程序依然往下走，经过了 <code>handle1</code>、<code>handle2</code>、<code>handle3</code> ，而没有经过 <code>exceptionally</code> ，当 <code>handle3</code> 出现异常时（在<code>whenCompleteAsync</code> 上方的方法），才会经过 <code>exceptionally</code> 方法</p></li></ul><p><strong>thenApply 在实际工作中最常用</strong></p><h2 id="3-对计算结果进行消费"><a href="#3-对计算结果进行消费" class="headerlink" title="3. 对计算结果进行消费"></a>3. 对计算结果进行消费</h2><p>接收任务的处理结果，并消费处理，<strong>无返回结果|消费型函数式接口</strong>，之前的是Function</p><ul><li><p>thenAccept</p><ul><li>thenAccept(Consumer action)</li><li>任务A执行完执行B，B需要A的结果，但是任务B无返回值</li></ul><pre><code class="highlight java">System.out.println(CompletableFuture.supplyAsync(() -&gt; <span class="string">&quot;resultA&quot;</span>).thenAccept(r -&gt; System.out.println(r)).join());</code></pre></li><li><p>thenRun</p><ul><li>thenRun(Runnable runnable)</li><li>任务A执行完执行B，并且B不需要A的结果</li></ul><pre><code class="highlight java">System.out.println(CompletableFuture.supplyAsync(() -&gt; <span class="string">&quot;resultA&quot;</span>).thenRun(() -&gt; &#123;&#125;).join());</code></pre></li><li><p>thenApply</p><ul><li>thenApply(Function fn)</li><li>任务A执行完执行B，B需要A的结果，同时任务B有返回值</li></ul><pre><code class="highlight java">System.out.println(CompletableFuture.supplyAsync(() -&gt; <span class="string">&quot;resultA&quot;</span>).thenApply(resultA -&gt; resultA + <span class="string">&quot; resultB&quot;</span>).join());</code></pre></li></ul><p>示例代码：</p><pre><code class="highlight java"><span class="comment">/**</span><span class="comment"> * 对计算结果进行消费</span><span class="comment"> */</span><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">m3</span><span class="params">()</span> &#123;    CompletableFuture.supplyAsync(() -&gt; &#123;        <span class="keyword">return</span> <span class="number">1</span>;    &#125;).thenApply(f -&gt; &#123;        <span class="keyword">return</span> f + <span class="number">2</span>;    &#125;).thenApply(f -&gt; &#123;        <span class="keyword">return</span> f + <span class="number">3</span>;    &#125;).thenAccept(r -&gt; System.out.println(r));    <span class="comment">// 任务A执行完执行B，并且B不需要A的结果, 且B无返回值</span>    System.out.println(CompletableFuture.supplyAsync(() -&gt; <span class="string">&quot;resultA&quot;</span>).thenRun(() -&gt; &#123;&#125;).join());    <span class="comment">// 任务A执行完执行B，B需要A的结果，但是任务B无返回值</span>    System.out.println(CompletableFuture.supplyAsync(() -&gt; <span class="string">&quot;resultA&quot;</span>).thenAccept(r -&gt; System.out.println(r)).join());    <span class="comment">// 任务A执行完执行B，B需要A的结果，同时任务B有返回值</span>    System.out.println(CompletableFuture.supplyAsync(() -&gt; <span class="string">&quot;resultA&quot;</span>).thenApply(resultA -&gt; resultA + <span class="string">&quot; resultB&quot;</span>).join());&#125;</code></pre><h2 id="4-CompleteFuture和线程池说明（非常重要）"><a href="#4-CompleteFuture和线程池说明（非常重要）" class="headerlink" title="4. CompleteFuture和线程池说明（非常重要）"></a>4. CompleteFuture和线程池说明（非常重要）</h2><p>上面的几个方法都有普通版本和后面加<strong>Async</strong>的版本, 例如：<code>thenRun</code>、<code>thenRunAsync</code>、<code>thenApply</code>、<code>thenApplyAsync</code>、<code>whenComplete</code>、<code>whenCompleteAsync</code> ……</p><p>以 <code>thenRun</code>和<code>thenRunAsync</code>为例，有什么区别？</p><ul><li><p><code>thenRun</code> 没有传入自定义线程池，使用默认线程池 ForkJoinPool</p></li><li><p><code>thenRunAsync</code>可传入一个自定义线程池</p><ul><li>如果你执行第一个任务的时候，传入了一个自定义线程池，调用<code>thenRun</code>方法执行第二个任务的时候，则第二个任务和第一个任务是用同一个线程池。</li><li>调用<code>thenRunAsync</code>执行第二个任务的时候，则第一个任务使用的是你自己传入的线程池，第二个任务使用的是 <strong>ForkJoin线程池</strong></li></ul></li><li><p>特殊情况，任务处理太快，系统优化切换原则，直接使用main线程处理</p></li><li><p>thenRun 代码示例</p><pre><code class="highlight plaintext">private static void m7() throws InterruptedException &#123;    ThreadPoolExecutor threadPoolExecutor = new ThreadPoolExecutor(1, 20, 1L, TimeUnit.SECONDS, new LinkedBlockingQueue&lt;&gt;(50), Executors.defaultThreadFactory(), new ThreadPoolExecutor.AbortPolicy());    CompletableFuture&lt;Void&gt; completableFuture = CompletableFuture.supplyAsync(()-&gt;&#123;        try &#123;TimeUnit.MILLISECONDS.sleep(20);&#125; catch (InterruptedException e) &#123;e.printStackTrace();&#125;        System.out.println(&quot;1号任务&quot;+&quot;\t&quot;+Thread.currentThread().getName());        return &quot;abcd&quot;;    &#125;,threadPoolExecutor).thenRun(()-&gt;&#123;        try &#123;TimeUnit.MILLISECONDS.sleep(20);&#125; catch (InterruptedException e) &#123;e.printStackTrace();&#125;        System.out.println(&quot;2号任务&quot;+&quot;\t&quot;+Thread.currentThread().getName());    &#125;).thenRun(()-&gt;&#123;        try &#123;TimeUnit.MILLISECONDS.sleep(20);&#125; catch (InterruptedException e) &#123;e.printStackTrace();&#125;        System.out.println(&quot;3号任务&quot;+&quot;\t&quot;+Thread.currentThread().getName());    &#125;).thenRun(()-&gt;&#123;        try &#123;TimeUnit.MILLISECONDS.sleep(20);&#125; catch (InterruptedException e) &#123;e.printStackTrace();&#125;        System.out.println(&quot;4号任务&quot;+&quot;\t&quot;+Thread.currentThread().getName());    &#125;);    Thread.sleep(2000);    threadPoolExecutor.shutdown();&#125;</code></pre><p>  运行结果：</p><pre><code class="highlight shell">1号任务pool-1-thread-12号任务pool-1-thread-13号任务pool-1-thread-14号任务pool-1-thread-1</code></pre></li><li><p>thenRunAsync 代码示例</p><pre><code class="highlight java"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">m7</span><span class="params">()</span> <span class="keyword">throws</span> InterruptedException &#123;    <span class="type">ThreadPoolExecutor</span> <span class="variable">threadPoolExecutor</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ThreadPoolExecutor</span>(<span class="number">1</span>, <span class="number">20</span>, <span class="number">1L</span>, TimeUnit.SECONDS, <span class="keyword">new</span> <span class="title class_">LinkedBlockingQueue</span>&lt;&gt;(<span class="number">50</span>), Executors.defaultThreadFactory(), <span class="keyword">new</span> <span class="title class_">ThreadPoolExecutor</span>.AbortPolicy());    CompletableFuture&lt;Void&gt; completableFuture = CompletableFuture.supplyAsync(()-&gt;&#123;        <span class="keyword">try</span> &#123;TimeUnit.MILLISECONDS.sleep(<span class="number">20</span>);&#125; <span class="keyword">catch</span> (InterruptedException e) &#123;e.printStackTrace();&#125;        System.out.println(<span class="string">&quot;1号任务&quot;</span>+<span class="string">&quot;\t&quot;</span>+Thread.currentThread().getName());        <span class="keyword">return</span> <span class="string">&quot;abcd&quot;</span>;    &#125;,threadPoolExecutor).thenRunAsync(()-&gt;&#123;        <span class="keyword">try</span> &#123;TimeUnit.MILLISECONDS.sleep(<span class="number">20</span>);&#125; <span class="keyword">catch</span> (InterruptedException e) &#123;e.printStackTrace();&#125;        System.out.println(<span class="string">&quot;2号任务&quot;</span>+<span class="string">&quot;\t&quot;</span>+Thread.currentThread().getName());    &#125;).thenRun(()-&gt;&#123;        <span class="keyword">try</span> &#123;TimeUnit.MILLISECONDS.sleep(<span class="number">20</span>);&#125; <span class="keyword">catch</span> (InterruptedException e) &#123;e.printStackTrace();&#125;        System.out.println(<span class="string">&quot;3号任务&quot;</span>+<span class="string">&quot;\t&quot;</span>+Thread.currentThread().getName());    &#125;).thenRun(()-&gt;&#123;        <span class="keyword">try</span> &#123;TimeUnit.MILLISECONDS.sleep(<span class="number">20</span>);&#125; <span class="keyword">catch</span> (InterruptedException e) &#123;e.printStackTrace();&#125;        System.out.println(<span class="string">&quot;4号任务&quot;</span>+<span class="string">&quot;\t&quot;</span>+Thread.currentThread().getName());    &#125;);    Thread.sleep(<span class="number">2000</span>);    threadPoolExecutor.shutdown();&#125;</code></pre><p>运行结果：</p><pre><code class="highlight shell">1号任务pool-1-thread-12号任务ForkJoinPool.commonPool-worker-253号任务ForkJoinPool.commonPool-worker-254号任务ForkJoinPool.commonPool-worker-25</code></pre></li><li><p>特殊情况, 直接使用main线程处理</p><pre><code class="highlight java"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">m7</span><span class="params">()</span> <span class="keyword">throws</span> InterruptedException &#123;    <span class="type">ThreadPoolExecutor</span> <span class="variable">threadPoolExecutor</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ThreadPoolExecutor</span>(<span class="number">1</span>, <span class="number">20</span>, <span class="number">1L</span>, TimeUnit.SECONDS, <span class="keyword">new</span> <span class="title class_">LinkedBlockingQueue</span>&lt;&gt;(<span class="number">50</span>), Executors.defaultThreadFactory(), <span class="keyword">new</span> <span class="title class_">ThreadPoolExecutor</span>.AbortPolicy());    CompletableFuture&lt;Void&gt; completableFuture = CompletableFuture.supplyAsync(()-&gt;&#123;<span class="comment">//        try &#123;TimeUnit.MILLISECONDS.sleep(20);&#125; catch (InterruptedException e) &#123;e.printStackTrace();&#125;</span>        System.out.println(<span class="string">&quot;1号任务&quot;</span>+<span class="string">&quot;\t&quot;</span>+Thread.currentThread().getName());        <span class="keyword">return</span> <span class="string">&quot;abcd&quot;</span>;    &#125;,threadPoolExecutor).thenRunAsync(()-&gt;&#123;<span class="comment">//        try &#123;TimeUnit.MILLISECONDS.sleep(20);&#125; catch (InterruptedException e) &#123;e.printStackTrace();&#125;</span>        System.out.println(<span class="string">&quot;2号任务&quot;</span>+<span class="string">&quot;\t&quot;</span>+Thread.currentThread().getName());    &#125;).thenRun(()-&gt;&#123;<span class="comment">//        try &#123;TimeUnit.MILLISECONDS.sleep(20);&#125; catch (InterruptedException e) &#123;e.printStackTrace();&#125;</span>        System.out.println(<span class="string">&quot;3号任务&quot;</span>+<span class="string">&quot;\t&quot;</span>+Thread.currentThread().getName());    &#125;).thenRun(()-&gt;&#123;<span class="comment">//        try &#123;TimeUnit.MILLISECONDS.sleep(20);&#125; catch (InterruptedException e) &#123;e.printStackTrace();&#125;</span>        System.out.println(<span class="string">&quot;4号任务&quot;</span>+<span class="string">&quot;\t&quot;</span>+Thread.currentThread().getName());    &#125;);    Thread.sleep(<span class="number">2000</span>);    threadPoolExecutor.shutdown();&#125;</code></pre><p> 运行结果：</p><pre><code class="highlight shell">1号任务pool-1-thread-12号任务ForkJoinPool.commonPool-worker-253号任务main4号任务main</code></pre></li></ul><h2 id="5-对计算速度进行选用"><a href="#5-对计算速度进行选用" class="headerlink" title="5. 对计算速度进行选用"></a>5. 对计算速度进行选用</h2><ul><li>applyToEither 优先选择运行速度快的任务的结果</li></ul><pre><code class="highlight java"><span class="comment">/**</span><span class="comment"> * 对计算速度进行选用</span><span class="comment"> */</span><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">m4</span><span class="params">()</span> &#123;    System.out.println(CompletableFuture.supplyAsync(() -&gt; &#123;        <span class="comment">//暂停几秒钟线程</span>        <span class="keyword">try</span> &#123;            TimeUnit.SECONDS.sleep(<span class="number">1</span>);        &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;            e.printStackTrace();        &#125;        <span class="keyword">return</span> <span class="number">1</span>;    &#125;).applyToEither(CompletableFuture.supplyAsync(() -&gt; &#123;        <span class="keyword">try</span> &#123;            TimeUnit.SECONDS.sleep(<span class="number">2</span>);        &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;            e.printStackTrace();        &#125;        <span class="keyword">return</span> <span class="number">2</span>;    &#125;), r -&gt; &#123;        <span class="keyword">return</span> r;    &#125;).join());    <span class="comment">//暂停几秒钟线程</span>    <span class="keyword">try</span> &#123;        TimeUnit.SECONDS.sleep(<span class="number">3</span>);    &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;        e.printStackTrace();    &#125;&#125;</code></pre><p>运行结果：</p><pre><code class="highlight shell">1</code></pre><h2 id="6-对计算结果进行合并"><a href="#6-对计算结果进行合并" class="headerlink" title="6. 对计算结果进行合并"></a>6. 对计算结果进行合并</h2><ul><li><p><code>thenCombine</code> 合并</p><ul><li>两个 <code>CompletionStage</code> 任务都完成后，最终能把两个任务的结果一起交给 <code>thenCombine</code> 来处理</li><li>先完成的先等着，等待其它分支任务</li></ul><pre><code class="highlight java"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">m5</span><span class="params">()</span> <span class="keyword">throws</span> ExecutionException, InterruptedException &#123;    CompletableFuture&lt;Integer&gt; thenCombineResult = CompletableFuture.supplyAsync(() -&gt; &#123;        System.out.println(Thread.currentThread().getName() + <span class="string">&quot;\t&quot;</span> + <span class="string">&quot;---come in 1&quot;</span>);        <span class="keyword">return</span> <span class="number">10</span>;    &#125;).thenCombine(CompletableFuture.supplyAsync(() -&gt; &#123;        System.out.println(Thread.currentThread().getName() + <span class="string">&quot;\t&quot;</span> + <span class="string">&quot;---come in 2&quot;</span>);        <span class="keyword">return</span> <span class="number">20</span>;    &#125;), (x, y) -&gt; &#123;        System.out.println(Thread.currentThread().getName() + <span class="string">&quot;\t&quot;</span> + <span class="string">&quot;---come in 3&quot;</span>);        <span class="keyword">return</span> x + y;    &#125;).thenCombine(CompletableFuture.supplyAsync(() -&gt; &#123;        System.out.println(Thread.currentThread().getName() + <span class="string">&quot;\t&quot;</span> + <span class="string">&quot;---come in 4&quot;</span>);        <span class="keyword">return</span> <span class="number">30</span>;    &#125;), (a, b) -&gt; &#123;        System.out.println(Thread.currentThread().getName() + <span class="string">&quot;\t&quot;</span> + <span class="string">&quot;---come in 5&quot;</span>);        <span class="keyword">return</span> a + b;    &#125;);    System.out.println(<span class="string">&quot;-----主线程结束，END&quot;</span>);    System.out.println(thenCombineResult.get());    <span class="comment">// 主线程不要立刻结束，否则CompletableFuture默认使用的线程池会立刻关闭:</span>    <span class="keyword">try</span> &#123;        TimeUnit.SECONDS.sleep(<span class="number">10</span>);    &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;        e.printStackTrace();    &#125;&#125;</code></pre><p>打印结果：</p><pre><code class="highlight shell">ForkJoinPool.commonPool-worker-25---come in 1ForkJoinPool.commonPool-worker-25---come in 2main---come in 3ForkJoinPool.commonPool-worker-18---come in 4main---come in 5-----主线程结束，END60</code></pre></li></ul>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;一、Future接口概述&quot;&gt;&lt;a href=&quot;#一、Future接口概述&quot; class=&quot;headerlink&quot; title=&quot;一、Future接口概述&quot;&gt;&lt;/a&gt;一、Future接口概述&lt;/h1&gt;&lt;p&gt;Future接口（FutureTask实现类）定义了操作异步</summary>
      
    
    
    
    <category term="JUC" scheme="https://georgechan95.github.io/categories/JUC/"/>
    
    
    <category term="juc" scheme="https://georgechan95.github.io/tags/juc/"/>
    
    <category term="java" scheme="https://georgechan95.github.io/tags/java/"/>
    
  </entry>
  
  <entry>
    <title>01-JUC进阶-线程基础</title>
    <link href="https://georgechan95.github.io/blog/3d102971.html"/>
    <id>https://georgechan95.github.io/blog/3d102971.html</id>
    <published>2024-09-18T14:32:00.000Z</published>
    <updated>2024-09-18T08:10:02.284Z</updated>
    
    <content type="html"><![CDATA[<h1 id="一、Java多线程相关概念"><a href="#一、Java多线程相关概念" class="headerlink" title="一、Java多线程相关概念"></a>一、Java多线程相关概念</h1><ul><li><p><strong>进程</strong></p><p>是程序的⼀次执⾏，是系统进⾏资源分配和调度的独⽴单位，每⼀个进程都有它⾃⼰的内存空间和系统资源</p></li><li><p><strong>线程</strong></p><ul><li>在同⼀个进程内⼜可以执⾏多个任务，⽽这每⼀个任务我们就可以看做是⼀个线程</li><li>⼀个进程会有1个或多个线程的</li></ul></li><li><p><strong>管程</strong></p><p>Monitor(监视器)，也就是我们平时所说的锁</p><p>Monitor其实是一种同步机制，他的义务是保证（同一时间）只有一个线程可以访问被保护的数据和代码。</p><p>JVM中同步是基于进入和退出监视器对象(Monitor,管程对象)来实现的，每个对象实例都会有一个Monitor对象，</p><pre><code class="highlight java"><span class="type">Object</span> <span class="variable">o</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Object</span>();<span class="keyword">new</span> <span class="title class_">Thread</span>(() -&gt; &#123;    <span class="keyword">synchronized</span> (o)    &#123;    &#125;&#125;,<span class="string">&quot;t1&quot;</span>).start();</code></pre><p>Monitor对象会和Java对象一同创建并销毁，它底层是由C++语言来实现的。</p></li></ul><p><img src="https://raw.githubusercontent.com/GeorgeChan95/blogimg/master/img/2024/09/18/20240918-153629.png" alt="同步指令"></p><h1 id="二、用户线程和守护线程"><a href="#二、用户线程和守护线程" class="headerlink" title="二、用户线程和守护线程"></a>二、用户线程和守护线程</h1><p>Java线程分为用户线程和守护线程，<strong>线程的daemon属性为true表示是守护线程，false表示是用户线程</strong></p><ul><li><p>守护线程</p><p>是一种特殊的线程，在后台默默地完成一些系统性的服务，比如垃圾回收线程</p></li><li><p>用户线程</p><p>是系统的工作线程，它会完成这个程序需要完成的业务操作</p></li></ul><p><strong>代码示例：</strong></p><pre><code class="highlight java"><span class="comment">/**</span><span class="comment"> * &lt;p&gt;</span><span class="comment"> * 演示守护线程和用户线程</span><span class="comment"> * &lt;/p&gt;</span><span class="comment"> */</span><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">DaemonDemo</span> &#123;    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;        <span class="type">Thread</span> <span class="variable">a</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Thread</span>(() -&gt; &#123;            System.out.println(Thread.currentThread().getName() + <span class="string">&quot; come in：\t&quot;</span>                    + (Thread.currentThread().isDaemon() ? <span class="string">&quot;守护线程&quot;</span> : <span class="string">&quot;用户线程&quot;</span>));            <span class="keyword">while</span> (<span class="literal">true</span>) &#123;            &#125;        &#125;, <span class="string">&quot;a&quot;</span>);        a.setDaemon(<span class="literal">true</span>); <span class="comment">// daemon设置为true，表示该线程为守护线程</span>        <span class="comment">// setDaemon 必须在 start() 方法之前</span>        a.start();        <span class="comment">//暂停几秒钟线程</span>        <span class="keyword">try</span> &#123;            TimeUnit.SECONDS.sleep(<span class="number">2</span>);        &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;            e.printStackTrace();        &#125;        System.out.println(Thread.currentThread().getName() + <span class="string">&quot;\t&quot;</span> + <span class="string">&quot; ----task is over&quot;</span>);    &#125;&#125;</code></pre><p>运行结果：</p><pre><code class="highlight shell">a come in：守护线程main ----task is over</code></pre><p>结论：当主线程(用户线程)结束后，守护线程也随之结束了。</p><p><strong>重点</strong></p><ul><li><p>当程序中所有用户线程执行完毕之后，不管守护线程是否结束，系统都会自动退出</p><p>如果用户线程全部结束了，意味着程序需要完成的业务操作已经结束了，系统可以退出了。所以当系统只剩下守护进程的时候，java虚拟机会自动退出</p></li><li><p>设置守护线程，需要在start()方法之前进行</p></li></ul>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;一、Java多线程相关概念&quot;&gt;&lt;a href=&quot;#一、Java多线程相关概念&quot; class=&quot;headerlink&quot; title=&quot;一、Java多线程相关概念&quot;&gt;&lt;/a&gt;一、Java多线程相关概念&lt;/h1&gt;&lt;ul&gt;
&lt;li&gt;&lt;p&gt;&lt;strong&gt;进程&lt;/stron</summary>
      
    
    
    
    <category term="JUC" scheme="https://georgechan95.github.io/categories/JUC/"/>
    
    
    <category term="juc" scheme="https://georgechan95.github.io/tags/juc/"/>
    
    <category term="java" scheme="https://georgechan95.github.io/tags/java/"/>
    
  </entry>
  
  <entry>
    <title>11-CompletableFuture</title>
    <link href="https://georgechan95.github.io/blog/37d56d14.html"/>
    <id>https://georgechan95.github.io/blog/37d56d14.html</id>
    <published>2024-09-16T08:12:00.000Z</published>
    <updated>2024-09-18T07:30:50.861Z</updated>
    
    <content type="html"><![CDATA[<h1 id="一、CompletableFuture-简介"><a href="#一、CompletableFuture-简介" class="headerlink" title="一、CompletableFuture 简介"></a>一、CompletableFuture 简介</h1><p>CompletableFuture 在 Java 里面被用于异步编程，异步通常意味着非阻塞，可以使得我们的任务单独运行在与主线程分离的其他线程中，并且通过回调可以在主线程中得到异步任务的执行状态，是否完成，和是否异常等信息。</p><p>CompletableFuture 实现了 Future, CompletionStage 接口，实现了 Future接口就可以兼容现在有线程池框架，而 CompletionStage 接口才是异步编程的接口抽象，里面定义多种异步方法，通过这两者集合，从而打造出了强大的 CompletableFuture 类。</p><h1 id="二、Future-与-CompletableFuture"><a href="#二、Future-与-CompletableFuture" class="headerlink" title="二、Future 与 CompletableFuture"></a>二、Future 与 CompletableFuture</h1><p>Futrue 在 Java 里面，通常用来表示一个异步任务的引用，比如我们将任务提交到线程池里面，然后我们会得到一个 Futrue，在 Future 里面有 isDone 方法来 判断任务是否处理结束，还有 get 方法可以一直阻塞直到任务结束然后获取结果，但整体来说这种方式，还是同步的，因为需要客户端不断阻塞等待或者不断轮询才能知道任务是否完成。</p><p><strong>Future 的主要缺点如下：</strong></p><ul><li><p>不支持手动完成</p><p>我提交了一个任务，但是执行太慢了，我通过其他路径已经获取到了任务结果，现在没法把这个任务结果通知到正在执行的线程，所以必须主动取消或者一直等待它执行完成</p></li><li><p>不支持进一步的非阻塞调用</p><p>通过 Future 的 get 方法会一直阻塞到任务完成，但是想在获取任务之后执行额外的任务，因为 Future 不支持回调函数，所以无法实现这个功能</p></li><li><p>不支持链式调用</p><p>对于 Future 的执行结果，我们想继续传到下一个 Future 处理使用，从而形成一个链式的 pipline 调用，这在 Future 中是没法实现的。</p></li><li><p>不支持多个 Future 合并</p><p>比如我们有 10 个 Future 并行执行，我们想在所有的 Future 运行完毕之后，执行某些函数，是没法通过 Future 实现的。</p></li><li><p>不支持异常处理</p><p>Future 的 API 没有任何的异常处理的 api，所以在异步运行时，如果出了问题是不好定位的。</p></li></ul><h1 id="三、CompletableFuture-入门"><a href="#三、CompletableFuture-入门" class="headerlink" title="三、CompletableFuture 入门"></a>三、CompletableFuture 入门</h1><h2 id="1-使用-CompletableFuture"><a href="#1-使用-CompletableFuture" class="headerlink" title="1. 使用 CompletableFuture"></a>1. 使用 CompletableFuture</h2><p>场景:主线程里面创建一个 CompletableFuture，然后主线程调用 get 方法会阻塞，最后我们在一个子线程中使其终止。</p><pre><code class="highlight java"><span class="comment">/**</span><span class="comment"> * 主线程里面创建一个 CompletableFuture，然后主线程调用 get 方法会阻塞，最后我们在一个子线程中使其终止</span><span class="comment"> *</span><span class="comment"> * <span class="doctag">@throws</span> InterruptedException</span><span class="comment"> * <span class="doctag">@throws</span> ExecutionException</span><span class="comment"> */</span><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">method1</span><span class="params">()</span> <span class="keyword">throws</span> InterruptedException, ExecutionException &#123;    CompletableFuture&lt;String&gt; future = <span class="keyword">new</span> <span class="title class_">CompletableFuture</span>&lt;&gt;();    <span class="keyword">new</span> <span class="title class_">Thread</span>(() -&gt; &#123;        <span class="keyword">try</span> &#123;            System.out.println(Thread.currentThread().getName() + <span class="string">&quot;子线程开始干活&quot;</span>);            <span class="comment">//子线程睡 5 秒</span>            Thread.sleep(<span class="number">5000</span>);            <span class="comment">//在子线程中完成主线程</span>            future.complete(<span class="string">&quot;success&quot;</span>);        &#125; <span class="keyword">catch</span> (Exception e) &#123;            e.printStackTrace();        &#125;    &#125;, <span class="string">&quot;A&quot;</span>).start();    <span class="comment">//主线程调用 get 方法阻塞</span>    System.out.println(<span class="string">&quot;主线程调用 get 方法获取结果为: &quot;</span> + future.get());    System.out.println(<span class="string">&quot;主线程完成,阻塞结束!!!!!!&quot;</span>);&#125;</code></pre><p>打印结果:</p><pre><code class="highlight shell">A子线程开始干活主线程调用 get 方法获取结果为: success主线程完成,阻塞结束!!!!!!</code></pre><h2 id="2-没有返回值的异步任务"><a href="#2-没有返回值的异步任务" class="headerlink" title="2. 没有返回值的异步任务"></a>2. 没有返回值的异步任务</h2><pre><code class="highlight java"><span class="comment">/**</span><span class="comment">    * 没有返回值的异步任务</span><span class="comment">    *</span><span class="comment">    * <span class="doctag">@throws</span> InterruptedException</span><span class="comment">    * <span class="doctag">@throws</span> ExecutionException</span><span class="comment">    */</span>   <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">method2</span><span class="params">()</span> <span class="keyword">throws</span> InterruptedException, ExecutionException &#123;       CompletableFuture&lt;Void&gt; future = <span class="keyword">new</span> <span class="title class_">CompletableFuture</span>&lt;&gt;();       <span class="keyword">new</span> <span class="title class_">Thread</span>(() -&gt; &#123;           <span class="keyword">try</span> &#123;               System.out.println(Thread.currentThread().getName() + <span class="string">&quot;开始作业&quot;</span>);               TimeUnit.SECONDS.sleep(<span class="number">5</span>);               System.out.println(Thread.currentThread().getName() + <span class="string">&quot; 完成作业&quot;</span>);           &#125; <span class="keyword">catch</span> (Exception e) &#123;               e.printStackTrace();           &#125;       &#125;, <span class="string">&quot;线程1&quot;</span>).start();       <span class="comment">//主线程调用 get 方法阻塞</span>       future.get();       System.out.println(<span class="string">&quot;主线程结束&quot;</span>);   &#125;</code></pre><p>运行结果:</p><pre><code class="highlight shell">线程1开始作业线程1 完成作业</code></pre><h2 id="3-有返回值的异步任务"><a href="#3-有返回值的异步任务" class="headerlink" title="3. 有返回值的异步任务"></a>3. 有返回值的异步任务</h2><pre><code class="highlight java"><span class="comment">/**</span><span class="comment"> * 有返回值的异步任务</span><span class="comment"> *</span><span class="comment"> * <span class="doctag">@throws</span> InterruptedException</span><span class="comment"> * <span class="doctag">@throws</span> ExecutionException</span><span class="comment"> */</span><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">method3</span><span class="params">()</span> <span class="keyword">throws</span> InterruptedException, ExecutionException &#123;    CompletableFuture&lt;String&gt; future = CompletableFuture.supplyAsync(<span class="keyword">new</span> <span class="title class_">Supplier</span>&lt;String&gt;() &#123;        <span class="meta">@Override</span>        <span class="keyword">public</span> String <span class="title function_">get</span><span class="params">()</span> &#123;            <span class="keyword">try</span> &#123;                System.out.println(Thread.currentThread().getName() + <span class="string">&quot;开始作业&quot;</span>);                TimeUnit.SECONDS.sleep(<span class="number">5</span>);                System.out.println(Thread.currentThread().getName() + <span class="string">&quot; 完成作业&quot;</span>);            &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;                e.printStackTrace();            &#125;            <span class="keyword">return</span> <span class="string">&quot;异步结果&quot;</span>;        &#125;    &#125;);    <span class="comment">//主线程调用 get 方法阻塞</span>    future.get();    System.out.println(<span class="string">&quot;主线程结束&quot;</span>);&#125;</code></pre><p><strong>运行结果:</strong></p><pre><code class="highlight shell">ForkJoinPool.commonPool-worker-19开始作业ForkJoinPool.commonPool-worker-19 完成作业主线程结束</code></pre><h2 id="4-线程依赖"><a href="#4-线程依赖" class="headerlink" title="4. 线程依赖"></a>4. 线程依赖</h2><p>当一个线程依赖另一个线程时，可以使用 thenApply 方法来把这两个线程串行化。</p><pre><code class="highlight java"><span class="keyword">private</span> <span class="keyword">static</span> <span class="type">int</span> <span class="variable">num</span> <span class="operator">=</span> <span class="number">0</span>;<span class="comment">/**</span><span class="comment"> * 线程依赖</span><span class="comment"> * 先对一个数加 10,然后取平方</span><span class="comment"> * <span class="doctag">@throws</span> InterruptedException</span><span class="comment"> * <span class="doctag">@throws</span> ExecutionException</span><span class="comment"> */</span><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">method4</span><span class="params">()</span> <span class="keyword">throws</span> InterruptedException, ExecutionException &#123;    CompletableFuture&lt;Integer&gt; future = CompletableFuture.supplyAsync(() -&gt; &#123;        System.out.println(Thread.currentThread().getName() + <span class="string">&quot;开始对值进行 +10 操作&quot;</span>);        num += <span class="number">10</span>;        System.out.println(Thread.currentThread().getName() + <span class="string">&quot; 完成作业&quot;</span>);        <span class="keyword">return</span> num;    &#125;).thenApply(<span class="keyword">new</span> <span class="title class_">Function</span>&lt;Integer, Integer&gt;() &#123;        <span class="meta">@Override</span>        <span class="keyword">public</span> Integer <span class="title function_">apply</span><span class="params">(Integer data)</span> &#123;            System.out.println(Thread.currentThread().getName() + <span class="string">&quot;开始对值进行 取平方 操作&quot;</span>);            System.out.println(<span class="string">&quot;integer: &quot;</span> + data);            <span class="keyword">return</span> data*data;        &#125;    &#125;);    <span class="comment">//主线程调用 get 方法阻塞</span>    System.out.println(<span class="string">&quot;主线程阻塞获取结果,结果为:&quot;</span> + future.get());    System.out.println(<span class="string">&quot;主线程结束&quot;</span>);&#125;</code></pre><p>运行结果:</p><pre><code class="highlight shell">ForkJoinPool.commonPool-worker-19开始对值进行 +10 操作ForkJoinPool.commonPool-worker-19 完成作业ForkJoinPool.commonPool-worker-19开始对值进行 取平方 操作integer: 10主线程阻塞获取结果,结果为:100主线程结束</code></pre><h2 id="5-消费处理结果"><a href="#5-消费处理结果" class="headerlink" title="5. 消费处理结果"></a>5. 消费处理结果</h2><p>thenAccept 消费处理结果, 接收任务的处理结果，并消费处理，无返回结果。</p><pre><code class="highlight java"><span class="comment">/**</span><span class="comment"> * thenAccept 消费处理结果, 接收任务的处理结果，并消费处理，无返回结果。</span><span class="comment"> * </span><span class="comment"> * <span class="doctag">@throws</span> InterruptedException</span><span class="comment"> * <span class="doctag">@throws</span> ExecutionException</span><span class="comment"> */</span><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">method5</span><span class="params">()</span> <span class="keyword">throws</span> InterruptedException, ExecutionException &#123;    CompletableFuture&lt;Void&gt; completableFuture = CompletableFuture.supplyAsync(() -&gt; &#123;        System.out.println(Thread.currentThread().getName() + <span class="string">&quot;开始对值进行 +10 操作&quot;</span>);        num += <span class="number">10</span>;        System.out.println(Thread.currentThread().getName() + <span class="string">&quot; 完成作业&quot;</span>);        <span class="keyword">return</span> num;    &#125;).thenApply(data -&gt; &#123;        System.out.println(Thread.currentThread().getName() + <span class="string">&quot;开始对值进行 取平方 操作&quot;</span>);        System.out.println(<span class="string">&quot;integer: &quot;</span> + data);        <span class="keyword">return</span> data * data;    &#125;).thenAccept(integer -&gt; &#123;        System.out.println(<span class="string">&quot;子线程全部处理完成,最后调用了 accept,结果为:&quot;</span> + integer);    &#125;);    <span class="comment">//主线程调用 get 方法阻塞</span>    System.out.println(<span class="string">&quot;主线程阻塞获取结果,结果为:&quot;</span> + completableFuture.get());    System.out.println(<span class="string">&quot;主线程结束&quot;</span>);&#125;</code></pre><p>运行结果:</p><pre><code class="highlight shell">ForkJoinPool.commonPool-worker-19开始对值进行 +10 操作ForkJoinPool.commonPool-worker-19 完成作业ForkJoinPool.commonPool-worker-19开始对值进行 取平方 操作integer: 10子线程全部处理完成,最后调用了 accept,结果为:100主线程阻塞获取结果,结果为:null主线程结束</code></pre><h2 id="6-异常处理"><a href="#6-异常处理" class="headerlink" title="6. 异常处理"></a>6. 异常处理</h2><p>exceptionally 异常处理,出现异常时触发</p><pre><code class="highlight java"><span class="comment">/**</span><span class="comment"> * exceptionally 异常处理,出现异常时触发</span><span class="comment"> * <span class="doctag">@throws</span> InterruptedException</span><span class="comment"> * <span class="doctag">@throws</span> ExecutionException</span><span class="comment"> */</span><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">method6</span><span class="params">()</span> <span class="keyword">throws</span> InterruptedException, ExecutionException &#123;    CompletableFuture&lt;Integer&gt; completableFuture = CompletableFuture.supplyAsync(() -&gt; &#123;        <span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">1</span> / <span class="number">0</span>;        System.out.println(Thread.currentThread().getName() + <span class="string">&quot;开始对值进行 +10 操作&quot;</span>);        num += <span class="number">10</span>;        System.out.println(Thread.currentThread().getName() + <span class="string">&quot; 完成作业&quot;</span>);        <span class="keyword">return</span> num;    &#125;).exceptionally(throwable -&gt; &#123;        System.out.println(throwable.getMessage());        <span class="keyword">return</span> -<span class="number">1</span>;    &#125;);    <span class="comment">//主线程调用 get 方法阻塞</span>    System.out.println(<span class="string">&quot;主线程阻塞获取结果,结果为:&quot;</span> + completableFuture.get());    System.out.println(<span class="string">&quot;主线程结束&quot;</span>);&#125;</code></pre><p>执行结果:</p><pre><code class="highlight shell">java.lang.ArithmeticException: / by zero主线程阻塞获取结果,结果为:-1主线程结束</code></pre><p><strong>handle 类似于 thenAccept&#x2F;thenRun 方法,是最后一步的处理调用,但是同时可以处理异常</strong></p><pre><code class="highlight java"><span class="comment">/**</span><span class="comment"> * handle 类似于 thenAccept/thenRun 方法,是最后一步的处理调用,但是同时可以处理异常</span><span class="comment"> */</span><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">method7</span><span class="params">()</span> &#123;    System.out.println(<span class="string">&quot;主线程开始&quot;</span>);    CompletableFuture&lt;Integer&gt; future = CompletableFuture.supplyAsync(() -&gt; &#123;        System.out.println(<span class="string">&quot;加 10 任务开始&quot;</span>);        num += <span class="number">10</span>;        <span class="keyword">return</span> num;    &#125;).handle((i, ex) -&gt; &#123;        System.out.println(<span class="string">&quot;进入 handle 方法&quot;</span>);        <span class="keyword">if</span> (ex != <span class="literal">null</span>) &#123;            System.out.print(<span class="string">&quot;发生了异常,内容为:&quot;</span>);            System.out.println(ex.getMessage());            <span class="keyword">return</span> -<span class="number">1</span>;        &#125; <span class="keyword">else</span> &#123;            System.out.println(<span class="string">&quot;正常完成,内容为: &quot;</span> + i);            <span class="keyword">return</span> i;        &#125;    &#125;);&#125;</code></pre><p>运行结果:</p><pre><code class="highlight shell">主线程开始加 10 任务开始进入 handle 方法正常完成,内容为: 10</code></pre><p>发生异常时:</p><pre><code class="highlight shell">主线程开始加 10 任务开始进入 handle 方法发生了异常,内容为:java.lang.ArithmeticException: / by zero</code></pre><h2 id="7-结果合并"><a href="#7-结果合并" class="headerlink" title="7. 结果合并"></a>7. 结果合并</h2><p><strong>thenCompose 合并两个有依赖关系的 CompletableFutures 的执行结果.</strong></p><pre><code class="highlight java"><span class="comment">/**</span><span class="comment"> * thenCompose 合并两个有依赖关系的 CompletableFutures 的执行结果</span><span class="comment"> * <span class="doctag">@throws</span> ExecutionException</span><span class="comment"> * <span class="doctag">@throws</span> InterruptedException</span><span class="comment"> */</span><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">method8</span><span class="params">()</span> <span class="keyword">throws</span> ExecutionException, InterruptedException &#123;    System.out.println(<span class="string">&quot;主线程开始......&quot;</span>);    <span class="comment">//第一步加 10</span>    CompletableFuture&lt;Integer&gt; future1 = CompletableFuture.supplyAsync(() -&gt; &#123;        System.out.println(Thread.currentThread().getName() + <span class="string">&quot;线程执行num加10&quot;</span>);        num += <span class="number">10</span>;        <span class="keyword">return</span> num;    &#125;);    <span class="comment">// 合并</span>    CompletableFuture&lt;Integer&gt; future2 = future1.thenCompose(data -&gt; CompletableFuture.supplyAsync(() -&gt; &#123;        System.out.println(Thread.currentThread().getName() + <span class="string">&quot;线程执行合并&quot;</span>);        <span class="keyword">return</span> data + <span class="number">1</span>;    &#125;));    System.out.println(<span class="string">&quot;主线程阻塞获取结果: &quot;</span> + future1.get());    System.out.println(<span class="string">&quot;主线程阻塞获取结果: &quot;</span> + future2.get());&#125;</code></pre><p>执行结果:</p><pre><code class="highlight shell">主线程开始......ForkJoinPool.commonPool-worker-19线程执行num加10ForkJoinPool.commonPool-worker-5线程执行合并主线程阻塞获取结果: 10主线程阻塞获取结果: 11</code></pre><p><strong>thenCombine 合并两个没有依赖关系的 CompletableFutures 任务</strong></p><pre><code class="highlight java"><span class="comment">/**</span><span class="comment"> * thenCombine 合并两个没有依赖关系的 CompletableFutures 任务</span><span class="comment"> * <span class="doctag">@throws</span> ExecutionException</span><span class="comment"> * <span class="doctag">@throws</span> InterruptedException</span><span class="comment"> */</span><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">method9</span><span class="params">()</span> <span class="keyword">throws</span> ExecutionException, InterruptedException &#123;    System.out.println(<span class="string">&quot;主线程开始......&quot;</span>);    <span class="comment">//第一个线程加 10</span>    CompletableFuture&lt;Integer&gt; future1 = CompletableFuture.supplyAsync(() -&gt; &#123;        System.out.println(Thread.currentThread().getName() + <span class="string">&quot;线程执行num加10&quot;</span>);        num += <span class="number">10</span>;        <span class="keyword">return</span> num;    &#125;);    <span class="comment">// 第二个线程 *10</span>    CompletableFuture&lt;Integer&gt; future2 = CompletableFuture.supplyAsync(() -&gt; &#123;        System.out.println(Thread.currentThread().getName() + <span class="string">&quot;线程执行num * 10&quot;</span>);        num *= <span class="number">10</span>;        <span class="keyword">return</span> num;    &#125;);    <span class="comment">// 合并两个CompletableFuture</span>    CompletableFuture&lt;Object&gt; combine = future1.thenCombine(future2, (a, b) -&gt; &#123;        List&lt;Integer&gt; list = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();        list.add(a);        list.add(b);        <span class="keyword">return</span> list;    &#125;);    System.out.println(<span class="string">&quot;主线程阻塞获取future1结果: &quot;</span> + future1.get());    System.out.println(<span class="string">&quot;主线程阻塞获取future2结果: &quot;</span> + future2.get());    System.out.println(<span class="string">&quot;主线程阻塞获取combine结果: &quot;</span> + combine.get());&#125;</code></pre><p>执行结果:</p><pre><code class="highlight shell">主线程开始......ForkJoinPool.commonPool-worker-19线程执行num加10ForkJoinPool.commonPool-worker-5线程执行num * 10主线程阻塞获取future1结果: 10主线程阻塞获取future2结果: 100主线程阻塞获取combine结果: [10, 100]</code></pre><p><strong>合并多个任务的结果 allOf 与 anyOf</strong></p><p><strong>allOf:</strong>  一系列独立的 future 任务，等其所有的任务执行完后做一些事情</p><pre><code class="highlight java"><span class="comment">/**</span><span class="comment"> * allOf: 一系列独立的 future 任务，等其所有的任务执行完后做一些事情</span><span class="comment"> */</span><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">method10</span><span class="params">()</span> &#123;    System.out.println(<span class="string">&quot;主线程开始&quot;</span>);    List&lt;CompletableFuture&gt; list = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();    CompletableFuture&lt;Integer&gt; job1 = CompletableFuture.supplyAsync(() -&gt; &#123;        System.out.println(<span class="string">&quot;加 10 任务开始&quot;</span>);        num += <span class="number">10</span>;        <span class="keyword">return</span> num;    &#125;);    list.add(job1);    CompletableFuture&lt;Integer&gt; job2 = CompletableFuture.supplyAsync(() -&gt; &#123;        System.out.println(<span class="string">&quot;乘以 10 任务开始&quot;</span>);        num = num * <span class="number">10</span>;        <span class="keyword">return</span> num;    &#125;);    list.add(job2);    CompletableFuture&lt;Integer&gt; job3 = CompletableFuture.supplyAsync(() -&gt; &#123;        System.out.println(<span class="string">&quot;减以 10 任务开始&quot;</span>);        num = num * <span class="number">10</span>;        <span class="keyword">return</span> num;    &#125;);    list.add(job3);    CompletableFuture&lt;Integer&gt; job4 = CompletableFuture.supplyAsync(() -&gt; &#123;        System.out.println(<span class="string">&quot;除以 10 任务开始&quot;</span>);        num = num * <span class="number">10</span>;        <span class="keyword">return</span> num;    &#125;);    list.add(job4);    <span class="comment">//多任务合并</span>    List&lt;Integer&gt; collect =            list.stream().map(CompletableFuture&lt;Integer&gt;::join).collect(Collectors.toList());    System.out.println(<span class="string">&quot;所有任务执行结束,结果为: &quot;</span> + collect);&#125;</code></pre><p>运行结果:</p><pre><code class="highlight shell">主线程开始乘以 10 任务开始加 10 任务开始减以 10 任务开始除以 10 任务开始所有任务执行结束,结果为: [10, 0, 100, 1000]</code></pre><p><strong>anyOf</strong>: 只要在多个 future 里面有一个返回，整个任务就可以结束，而不需要等到每一个future 结束</p><pre><code class="highlight java"><span class="comment">/**</span><span class="comment"> * anyOf: 只要在多个 future 里面有一个返回，整个任务就可以结束，而不需要等到每一个future 结束</span><span class="comment"> * <span class="doctag">@throws</span> ExecutionException</span><span class="comment"> * <span class="doctag">@throws</span> InterruptedException</span><span class="comment"> */</span><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">method11</span><span class="params">()</span> <span class="keyword">throws</span> ExecutionException, InterruptedException &#123;    System.out.println(<span class="string">&quot;主线程开始&quot;</span>);    CompletableFuture&lt;Integer&gt;[] futures = <span class="keyword">new</span> <span class="title class_">CompletableFuture</span>[<span class="number">4</span>];    CompletableFuture&lt;Integer&gt; job1 = CompletableFuture.supplyAsync(() -&gt; &#123;        System.out.println(<span class="string">&quot;加 10 任务开始&quot;</span>);        num += <span class="number">10</span>;        <span class="keyword">return</span> num;    &#125;);    futures[<span class="number">0</span>] = job1;    CompletableFuture&lt;Integer&gt; job2 = CompletableFuture.supplyAsync(() -&gt; &#123;        System.out.println(<span class="string">&quot;乘以 10 任务开始&quot;</span>);        num = num * <span class="number">10</span>;        <span class="keyword">return</span> num;    &#125;);    futures[<span class="number">1</span>] = job2;    CompletableFuture&lt;Integer&gt; job3 = CompletableFuture.supplyAsync(() -&gt; &#123;        System.out.println(<span class="string">&quot;减以 10 任务开始&quot;</span>);        num = num * <span class="number">10</span>;        <span class="keyword">return</span> num;    &#125;);    futures[<span class="number">2</span>] = job3;    CompletableFuture&lt;Integer&gt; job4 = CompletableFuture.supplyAsync(() -&gt; &#123;        System.out.println(<span class="string">&quot;除以 10 任务开始&quot;</span>);        num = num * <span class="number">10</span>;        <span class="keyword">return</span> num;    &#125;);    futures[<span class="number">3</span>] = job4;    CompletableFuture&lt;Object&gt; future = CompletableFuture.anyOf(futures);    System.out.println(future.get());    System.out.println(<span class="string">&quot;其中一个任务执行结束,结果为: &quot;</span> + future.get());&#125;</code></pre><p>执行结果:</p><pre><code class="highlight shell">主线程开始乘以 10 任务开始加 10 任务开始减以 10 任务开始10除以 10 任务开始其中一个任务执行结束,结果为: 10</code></pre>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;一、CompletableFuture-简介&quot;&gt;&lt;a href=&quot;#一、CompletableFuture-简介&quot; class=&quot;headerlink&quot; title=&quot;一、CompletableFuture 简介&quot;&gt;&lt;/a&gt;一、CompletableFuture </summary>
      
    
    
    
    <category term="JUC" scheme="https://georgechan95.github.io/categories/JUC/"/>
    
    
    <category term="juc" scheme="https://georgechan95.github.io/tags/juc/"/>
    
    <category term="java" scheme="https://georgechan95.github.io/tags/java/"/>
    
  </entry>
  
  <entry>
    <title>10-Fork/Join</title>
    <link href="https://georgechan95.github.io/blog/31919959.html"/>
    <id>https://georgechan95.github.io/blog/31919959.html</id>
    <published>2024-09-16T05:10:00.000Z</published>
    <updated>2024-09-18T07:30:50.861Z</updated>
    
    <content type="html"><![CDATA[<h1 id="一、Fork-Join-框架简介"><a href="#一、Fork-Join-框架简介" class="headerlink" title="一、Fork&#x2F;Join 框架简介"></a>一、Fork&#x2F;Join 框架简介</h1><p>Fork&#x2F;Join 它可以将一个大的任务拆分成多个子任务进行并行处理，最后将子任务结果合并成最后的计算结果，并进行输出。Fork&#x2F;Join 框架要完成两件事情：</p><p><strong>Fork：把一个复杂任务进行分拆，大事化小</strong></p><p><strong>Join：把分拆任务的结果进行合并</strong></p><p><img src="https://raw.githubusercontent.com/GeorgeChan95/blogimg/master/img/2024/09/16/20240916-150030.png" alt="任务拆分"></p><ul><li><strong>任务分割：</strong>首先 Fork&#x2F;Join 框架需要把大的任务分割成足够小的子任务，如果子任务比较大的话还要对子任务进行继续分割</li><li><strong>执行任务并合并结果：</strong>分割的子任务分别放到双端队列里，然后几个启动线程分别从双端队列里获取任务执行。子任务执行完的结果都放在另外一个队列里，启动一个线程从队列里取数据，然后合并这些数据。</li></ul><p>在 Java 的 Fork&#x2F;Join 框架中，使用两个类完成上述操作</p><ul><li><strong>ForkJoinTask:</strong> 我们要使用 Fork&#x2F;Join 框架，首先需要创建一个 ForkJoin 任务。该类提供了在任务中执行 fork 和 join 的机制。通常情况下我们不需要直接集成 ForkJoinTask 类，只需要继承它的子类，Fork&#x2F;Join 框架提供了两个子类：<ul><li>RecursiveAction：用于没有返回结果的任务</li><li>RecursiveTask: 用于有返回结果的任务</li></ul></li><li><strong>ForkJoinPool</strong>: ForkJoinTask 需要通过 ForkJoinPool 来执行</li><li><strong>RecursiveTask</strong>: 继承后可以实现递归(自己调自己)调用的任务</li></ul><p><strong>Fork&#x2F;Join 框架的实现原理</strong></p><p>ForkJoinPool 由 ForkJoinTask 数组和 ForkJoinWorkerThread 数组组成，ForkJoinTask 数组负责将存放以及将程序提交给 ForkJoinPool，而ForkJoinWorkerThread 负责执行这些任务。</p><h1 id="二、Fork-方法"><a href="#二、Fork-方法" class="headerlink" title="二、Fork 方法"></a>二、Fork 方法</h1><p><img src="https://raw.githubusercontent.com/GeorgeChan95/blogimg/master/img/2024/09/16/20240916-150946.png" alt="ForkJoinPool继承体系"></p><p><img src="https://raw.githubusercontent.com/GeorgeChan95/blogimg/master/img/2024/09/16/20240916-151158.png" alt="ForkJoinTask继承体系"></p><p><strong>Fork 方法的实现原理：</strong> 当我们调用 ForkJoinTask 的 fork 方法时，程序会把任务放在 ForkJoinWorkerThread 的 pushTask 的 workQueue 中，异步地执行这个任务，然后立即返回结果. </p><pre><code class="highlight java"><span class="comment">/**</span><span class="comment"> * Arranges to asynchronously execute this task in the pool the</span><span class="comment"> * current task is running in, if applicable, or using the &#123;<span class="doctag">@link</span></span><span class="comment"> * ForkJoinPool#commonPool()&#125; if not &#123;<span class="doctag">@link</span> #inForkJoinPool&#125;.  While</span><span class="comment"> * it is not necessarily enforced, it is a usage error to fork a</span><span class="comment"> * task more than once unless it has completed and been</span><span class="comment"> * reinitialized.  Subsequent modifications to the state of this</span><span class="comment"> * task or any data it operates on are not necessarily</span><span class="comment"> * consistently observable by any thread other than the one</span><span class="comment"> * executing it unless preceded by a call to &#123;<span class="doctag">@link</span> #join&#125; or</span><span class="comment"> * related methods, or a call to &#123;<span class="doctag">@link</span> #isDone&#125; returning &#123;<span class="doctag">@code</span></span><span class="comment"> * true&#125;.</span><span class="comment"> *</span><span class="comment"> * <span class="doctag">@return</span> &#123;<span class="doctag">@code</span> this&#125;, to simplify usage</span><span class="comment"> */</span><span class="keyword">public</span> <span class="keyword">final</span> ForkJoinTask&lt;V&gt; <span class="title function_">fork</span><span class="params">()</span> &#123;    Thread t;    <span class="keyword">if</span> ((t = Thread.currentThread()) <span class="keyword">instanceof</span> ForkJoinWorkerThread)        ((ForkJoinWorkerThread)t).workQueue.push(<span class="built_in">this</span>);    <span class="keyword">else</span>        ForkJoinPool.common.externalPush(<span class="built_in">this</span>);    <span class="keyword">return</span> <span class="built_in">this</span>;&#125;</code></pre><p>pushTask 方法把当前任务存放在 ForkJoinTask 数组队列里。然后再调用ForkJoinPool 的 signalWork()方法唤醒或创建一个工作线程来执行任务。代码如下：</p><pre><code class="highlight java"><span class="comment">/**</span><span class="comment"> * Pushes a task. Call only by owner in unshared queues.</span><span class="comment"> *</span><span class="comment"> * <span class="doctag">@param</span> task the task. Caller must ensure non-null.</span><span class="comment"> * <span class="doctag">@throws</span> RejectedExecutionException if array cannot be resized</span><span class="comment"> */</span><span class="keyword">final</span> <span class="keyword">void</span> <span class="title function_">push</span><span class="params">(ForkJoinTask&lt;?&gt; task)</span> &#123;    ForkJoinTask&lt;?&gt;[] a;    <span class="type">int</span> <span class="variable">s</span> <span class="operator">=</span> top, d, cap, m;    <span class="type">ForkJoinPool</span> <span class="variable">p</span> <span class="operator">=</span> pool;    <span class="keyword">if</span> ((a = array) != <span class="literal">null</span> &amp;&amp; (cap = a.length) &gt; <span class="number">0</span>) &#123;        QA.setRelease(a, (m = cap - <span class="number">1</span>) &amp; s, task);        top = s + <span class="number">1</span>;        <span class="keyword">if</span> (((d = s - (<span class="type">int</span>)BASE.getAcquire(<span class="built_in">this</span>)) &amp; ~<span class="number">1</span>) == <span class="number">0</span> &amp;&amp;                p != <span class="literal">null</span>) &#123;                 <span class="comment">// size 0 or 1</span>            VarHandle.fullFence();            p.signalWork();        &#125;        <span class="keyword">else</span> <span class="keyword">if</span> (d == m)            growArray(<span class="literal">false</span>);    &#125;&#125;</code></pre><h1 id="三、join-方法"><a href="#三、join-方法" class="headerlink" title="三、join 方法"></a>三、join 方法</h1><p>Join 方法的主要作用是阻塞当前线程并等待获取结果。让我们一起看看 ForkJoinTask 的 join 方法的实现，代码如下：</p><pre><code class="highlight java"><span class="comment">/**</span><span class="comment"> * Returns the result of the computation when it</span><span class="comment"> * &#123;<span class="doctag">@linkplain</span> #isDone is done&#125;.</span><span class="comment"> * This method differs from &#123;<span class="doctag">@link</span> #get()&#125; in that abnormal</span><span class="comment"> * completion results in &#123;<span class="doctag">@code</span> RuntimeException&#125; or &#123;<span class="doctag">@code</span> Error&#125;,</span><span class="comment"> * not &#123;<span class="doctag">@code</span> ExecutionException&#125;, and that interrupts of the</span><span class="comment"> * calling thread do &lt;em&gt;not&lt;/em&gt; cause the method to abruptly</span><span class="comment"> * return by throwing &#123;<span class="doctag">@code</span> InterruptedException&#125;.</span><span class="comment"> *</span><span class="comment"> * <span class="doctag">@return</span> the computed result</span><span class="comment"> */</span><span class="keyword">public</span> <span class="keyword">final</span> V <span class="title function_">join</span><span class="params">()</span> &#123;    <span class="type">int</span> s;    <span class="keyword">if</span> (((s = doJoin()) &amp; ABNORMAL) != <span class="number">0</span>)        reportException(s);    <span class="keyword">return</span> getRawResult();&#125;</code></pre><p>它首先调用 doJoin 方法，通过 doJoin()方法得到当前任务的状态来判断返回什么结果，任务状态有 4 种：</p><p><strong>已完成（NORMAL）</strong>、<strong>被取消（CANCELLED）</strong>、<strong>信号（SIGNAL）</strong>和 <strong>出现异常（EXCEPTIONAL）</strong></p><ul><li>如果任务状态是已完成，则直接返回任务结果。</li><li>如果任务状态是被取消，则直接抛出 CancellationException</li><li>如果任务状态是抛出异常，则直接抛出对应的异常</li></ul><p><strong>分析一下 doJoin 方法的实现</strong></p><pre><code class="highlight java"><span class="comment">/**</span><span class="comment"> * Implementation for join, get, quietlyJoin. Directly handles</span><span class="comment"> * only cases of already-completed, external wait, and</span><span class="comment"> * unfork+exec.  Others are relayed to ForkJoinPool.awaitJoin.</span><span class="comment"> *</span><span class="comment"> * <span class="doctag">@return</span> status upon completion</span><span class="comment"> */</span><span class="keyword">private</span> <span class="type">int</span> <span class="title function_">doJoin</span><span class="params">()</span> &#123;    <span class="type">int</span> s; Thread t; ForkJoinWorkerThread wt; ForkJoinPool.WorkQueue w;    <span class="keyword">return</span> (s = status) &lt; <span class="number">0</span> ? s :            ((t = Thread.currentThread()) <span class="keyword">instanceof</span> ForkJoinWorkerThread) ?                    (w = (wt = (ForkJoinWorkerThread)t).workQueue).                            tryUnpush(<span class="built_in">this</span>) &amp;&amp; (s = doExec()) &lt; <span class="number">0</span> ? s :                            wt.pool.awaitJoin(w, <span class="built_in">this</span>, <span class="number">0L</span>) :                    externalAwaitDone();&#125;<span class="comment">/**</span><span class="comment"> * Primary execution method for stolen tasks. Unless done, calls</span><span class="comment"> * exec and records status if completed, but doesn&#x27;t wait for</span><span class="comment"> * completion otherwise.</span><span class="comment"> *</span><span class="comment"> * <span class="doctag">@return</span> status on exit from this method</span><span class="comment"> */</span><span class="keyword">final</span> <span class="type">int</span> <span class="title function_">doExec</span><span class="params">()</span> &#123;    <span class="type">int</span> s; <span class="type">boolean</span> completed;    <span class="keyword">if</span> ((s = status) &gt;= <span class="number">0</span>) &#123;        <span class="keyword">try</span> &#123;            completed = exec();        &#125; <span class="keyword">catch</span> (Throwable rex) &#123;            completed = <span class="literal">false</span>;            s = setExceptionalCompletion(rex);        &#125;        <span class="keyword">if</span> (completed)            s = setDone();    &#125;    <span class="keyword">return</span> s;&#125;</code></pre><p>在 doJoin()方法流程如下:</p><ul><li>首先通过查看任务的状态，看任务是否已经执行完成，如果执行完成，则直接返回任务状态；</li><li>如果没有执行完，则从任务数组里取出任务并执行。</li><li>如果任务顺利执行完成，则设置任务状态为 NORMAL，如果出现异常，则记录异常，并将任务状态设置为 EXCEPTIONAL。</li></ul><h1 id="四、Fork-Join-框架的异常处理"><a href="#四、Fork-Join-框架的异常处理" class="headerlink" title="四、Fork&#x2F;Join 框架的异常处理"></a>四、Fork&#x2F;Join 框架的异常处理</h1><p>ForkJoinTask 在执行的时候可能会抛出异常，但是我们没办法在主线程里直接捕获异常，所以 ForkJoinTask 提供了 isCompletedAbnormally() 方法来检查任务是否已经抛出异常或已经被取消了，并且可以通过 ForkJoinTask 的 getException 方法获取异常。</p><p>getException 方法返回 Throwable 对象，如果任务被取消了则返回 CancellationException。如果任务没有完成或者没有抛出异常则返回 null。</p><h1 id="五、入门案例"><a href="#五、入门案例" class="headerlink" title="五、入门案例"></a>五、入门案例</h1><p><strong>场景: 生成一个计算任务，计算 1+2+3………+100 每 10 个数切分一个子任务</strong></p><pre><code class="highlight java"><span class="keyword">class</span> <span class="title class_">MyTask</span> <span class="keyword">extends</span> <span class="title class_">RecursiveTask</span>&lt;Integer&gt; &#123;    <span class="comment">//拆分差值不能超过10，计算10以内运算</span>    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">Integer</span> <span class="variable">VALUE</span> <span class="operator">=</span> <span class="number">10</span>;    <span class="keyword">private</span> <span class="type">int</span> begin ;<span class="comment">//拆分开始值</span>    <span class="keyword">private</span> <span class="type">int</span> end;<span class="comment">//拆分结束值</span>    <span class="keyword">private</span> <span class="type">int</span> result ; <span class="comment">//返回结果</span>    <span class="comment">//创建有参数构造</span>    <span class="keyword">public</span> <span class="title function_">MyTask</span><span class="params">(<span class="type">int</span> begin,<span class="type">int</span> end)</span> &#123;        <span class="built_in">this</span>.begin = begin;        <span class="built_in">this</span>.end = end;    &#125;    <span class="comment">//拆分和合并过程</span>    <span class="meta">@Override</span>    <span class="keyword">protected</span> Integer <span class="title function_">compute</span><span class="params">()</span> &#123;<span class="comment">//        System.out.println(Thread.currentThread().getName() + &quot;, begin: &quot; + begin + &quot;, end: &quot; + end);</span>        <span class="comment">//判断相加两个数值是否大于10</span>        <span class="keyword">if</span>((end-begin)&lt;=VALUE) &#123;            <span class="comment">//相加操作</span>            <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> begin; i &lt;=end; i++) &#123;                result = result+i;            &#125;        &#125; <span class="keyword">else</span> &#123;<span class="comment">// 递归调用,切分为 2 个小任务</span>            <span class="comment">//获取中间值</span>            <span class="type">int</span> <span class="variable">middle</span> <span class="operator">=</span> (begin+end)/<span class="number">2</span>;            <span class="comment">//拆分左边</span>            <span class="type">MyTask</span> <span class="variable">task01</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">MyTask</span>(begin,middle);            <span class="comment">//拆分右边</span>            <span class="type">MyTask</span> <span class="variable">task02</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">MyTask</span>(middle+<span class="number">1</span>,end);            <span class="comment">// 执行:异步</span>            task01.fork();            task02.fork();            <span class="comment">// 同步阻塞获取执行结果</span>            result = task01.join()+task02.join();        &#125;        <span class="keyword">return</span> result;    &#125;&#125;<span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ForkJoinDemo</span> &#123;    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> ExecutionException, InterruptedException &#123;        <span class="comment">//创建MyTask对象</span>        <span class="type">MyTask</span> <span class="variable">myTask</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">MyTask</span>(<span class="number">0</span>,<span class="number">100</span>);        <span class="comment">//创建分支合并池对象</span>        <span class="type">ForkJoinPool</span> <span class="variable">forkJoinPool</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ForkJoinPool</span>();        ForkJoinTask&lt;Integer&gt; forkJoinTask = forkJoinPool.submit(myTask);        <span class="comment">//获取最终合并之后结果</span>        <span class="type">Integer</span> <span class="variable">result</span> <span class="operator">=</span> forkJoinTask.get();        System.out.println(result);        <span class="comment">//关闭池对象</span>        forkJoinPool.shutdown();    &#125;&#125;</code></pre>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;一、Fork-Join-框架简介&quot;&gt;&lt;a href=&quot;#一、Fork-Join-框架简介&quot; class=&quot;headerlink&quot; title=&quot;一、Fork&amp;#x2F;Join 框架简介&quot;&gt;&lt;/a&gt;一、Fork&amp;#x2F;Join 框架简介&lt;/h1&gt;&lt;p&gt;Fork</summary>
      
    
    
    
    <category term="JUC" scheme="https://georgechan95.github.io/categories/JUC/"/>
    
    
    <category term="juc" scheme="https://georgechan95.github.io/tags/juc/"/>
    
    <category term="java" scheme="https://georgechan95.github.io/tags/java/"/>
    
  </entry>
  
  <entry>
    <title>09-ThreadPool-线程池</title>
    <link href="https://georgechan95.github.io/blog/a0197c15.html"/>
    <id>https://georgechan95.github.io/blog/a0197c15.html</id>
    <published>2024-09-13T12:10:08.000Z</published>
    <updated>2024-09-18T07:30:50.861Z</updated>
    
    <content type="html"><![CDATA[<h1 id="一、线程池简介"><a href="#一、线程池简介" class="headerlink" title="一、线程池简介"></a>一、线程池简介</h1><p>线程池（英语：thread pool）：一种线程使用模式。线程过多会带来调度开销，进而影响缓存局部性和整体性能。而线程池维护着多个线程，等待着监督管理者分配可并发执行的任务。这避免了在处理短时间任务时创建与销毁线程的代价。线程池不仅能够保证内核的充分利用，还能防止过分调度。</p><p>例子： 10 年前单核 CPU 电脑，假的多线程，像马戏团小丑玩多个球，CPU 需要来回切换。 现在是多核电脑，多个线程各自跑在独立的 CPU 上，不用切换效率高</p><p><strong>线程池的优势：</strong> 线程池做的工作只要是控制运行的线程数量，处理过程中将任务放入队列，然后在线程创建后启动这些任务，如果线程数量超过了最大数量，超出数量的线程排队等候，等其他线程执行完毕，再从队列中取出任务来执行。</p><p><strong>它的主要特点为：</strong></p><ul><li>降低资源消耗: 通过重复利用已创建的线程降低线程创建和销毁造成的销耗。</li><li>提高响应速度: 当任务到达时，任务可以不需要等待线程创建就能立即执行。</li><li>提高线程的可管理性: 线程是稀缺资源，如果无限制的创建，不仅会销耗系统资源，还会降低系统的稳定性，使用线程池可以进行统一的分配，调优和监控。</li><li><strong>Java</strong> <strong>中的线程池是通过</strong> <strong>Executor</strong> <strong>框架实现的，该框架中用到了</strong> <strong>Executor，Executors,  ExecutorService，ThreadPoolExecutor这几个类</strong></li></ul><p><img src="https://raw.githubusercontent.com/GeorgeChan95/blogimg/master/img/2024/09/16/20240916-103643.png" alt="Executors继承体系"></p><h1 id="二、线程池参数说明"><a href="#二、线程池参数说明" class="headerlink" title="二、线程池参数说明"></a>二、线程池参数说明</h1><p>介绍 5 种类型的线程池</p><h2 id="1-常用参数-重点"><a href="#1-常用参数-重点" class="headerlink" title="1. 常用参数(重点)"></a>1. 常用参数(重点)</h2><ul><li>corePoolSize 线程池的核心线程数</li><li>maximumPoolSize 能容纳的最大线程数</li><li>keepAliveTime 空闲线程存活时间</li><li>unit 存活的时间单位</li><li>workQueue 存放提交但未执行任务的队列</li><li>threadFactory 创建线程的工厂类</li><li>handler 等待队列满后的拒绝策略</li></ul><p>线程池中，有三个重要的参数，决定影响了拒绝策略：corePoolSize - 核心线程数，也即最小的线程数。workQueue - 阻塞队列 。 maximumPoolSize - 最大线程数</p><p>当提交任务数大于 corePoolSize 的时候，会优先将任务放到 workQueue 阻塞队列中。当阻塞队列饱和后，会扩充线程池中线程数，直到达到 maximumPoolSize 最大线程数配置。此时，再多余的任务，则会触发线程池的拒绝策略了。</p><p>总结起来，也就是一句话，当提交的任务数大于（<code>workQueue.size()</code> + <code>maximumPoolSize</code> ），就会触发线程池的拒绝策略。</p><h2 id="2-拒绝策略-重点"><a href="#2-拒绝策略-重点" class="headerlink" title="2. 拒绝策略(重点)"></a>2. 拒绝策略(重点)</h2><ul><li><strong>CallerRunsPolicy</strong>: 当触发拒绝策略，只要线程池没有关闭的话，则使用调用线程直接运行任务。一般并发比较小，性能要求不高，不允许失败。但是，由于调用者自己运行任务，如果任务提交速度过快，可能导致程序阻塞，性能效率上必然的损失较大</li><li><strong>AbortPolicy</strong>: 丢弃任务，并抛出拒绝执行 RejectedExecutionException 异常信息。线程池默认的拒绝策略。必须处理好抛出的异常，否则会打断当前的执行流程，影响后续的任务执行。</li><li><strong>DiscardPolicy</strong>: 直接丢弃，其他啥都没有</li><li><strong>DiscardOldestPolicy</strong>: 当触发拒绝策略，只要线程池没有关闭的话，丢弃阻塞队列 workQueue 中最老的一个任务，并将新任务加入</li></ul><h1 id="三、线程池的种类与创建"><a href="#三、线程池的种类与创建" class="headerlink" title="三、线程池的种类与创建"></a>三、线程池的种类与创建</h1><h2 id="1-newCachedThreadPool-常用"><a href="#1-newCachedThreadPool-常用" class="headerlink" title="1. newCachedThreadPool(常用)"></a>1. newCachedThreadPool(常用)</h2><p><strong>作用</strong>：创建一个可缓存线程池，如果线程池长度超过处理需要，可灵活回收空闲线程，若无可回收，则新建线程.</p><p><strong>特点</strong>: </p><ul><li>线程池中数量没有固定，可达到最大值（<code>Interger. MAX_VALUE</code>）</li><li>线程池中的线程可进行缓存重复利用和回收（回收默认时间为 1 分钟）</li><li>当线程池中，没有可用线程，会重新创建一个线程</li></ul><p><strong>创建方式：</strong></p><pre><code class="highlight java"><span class="comment">/**</span><span class="comment"> * 可缓存线程池</span><span class="comment"> *</span><span class="comment"> * <span class="doctag">@return</span></span><span class="comment"> */</span><span class="keyword">public</span> <span class="keyword">static</span> ExecutorService <span class="title function_">newCachedThreadPool</span><span class="params">()</span> &#123;    <span class="comment">/**</span><span class="comment">     * corePoolSize 线程池的核心线程数</span><span class="comment">     * maximumPoolSize 能容纳的最大线程数</span><span class="comment">     * keepAliveTime 空闲线程存活时间</span><span class="comment">     * unit 存活的时间单位</span><span class="comment">     * workQueue 存放提交但未执行任务的队列</span><span class="comment">     * threadFactory 创建线程的工厂类:可以省略</span><span class="comment">     * handler 等待队列满后的拒绝策略:可以省略</span><span class="comment">     */</span>    <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">ThreadPoolExecutor</span>(<span class="number">0</span>,            Integer.MAX_VALUE,            <span class="number">60L</span>,            TimeUnit.SECONDS,            <span class="keyword">new</span> <span class="title class_">SynchronousQueue</span>&lt;&gt;(),            Executors.defaultThreadFactory(),            <span class="keyword">new</span> <span class="title class_">ThreadPoolExecutor</span>.AbortPolicy());&#125;</code></pre><p><strong>场景:</strong> 适用于创建一个可无限扩大的线程池，服务器负载压力较轻，执行时间较短，任务多的场景</p><h2 id="2-newFixedThreadPool-常用"><a href="#2-newFixedThreadPool-常用" class="headerlink" title="2. newFixedThreadPool(常用)"></a>2. newFixedThreadPool(常用)</h2><p><strong>作用</strong>：创建一个可重用固定线程数的线程池，以共享的无界队列方式来运行这些线程。在任意点，在大多数线程会处于处理任务的活动状态。如果在所有线程处于活动状态时提交附加任务，则在有可用线程之前，附加任务将在队列中等待。如果在关闭前的执行期间由于失败而导致任何线程终止，那么一个新线程将代替它执行后续的任务（如果需要）。在某个线程被显式地关闭之前，池中的线程将一直存在。</p><p><strong>特征：</strong></p><ul><li>线程池中的线程处于一定的量，可以很好的控制线程的并发量</li><li>线程可以重复被使用，在显示关闭之前，都将一直存在</li><li>超出一定量的线程被提交时候需在队列中等待</li></ul><p><strong>创建方式</strong>：</p><pre><code class="highlight java"><span class="comment">/**</span><span class="comment"> * 固定长度线程池</span><span class="comment"> * <span class="doctag">@return</span></span><span class="comment"> */</span><span class="keyword">public</span> <span class="keyword">static</span> ExecutorService <span class="title function_">newFixedThreadPool</span><span class="params">()</span>&#123;    <span class="comment">/**</span><span class="comment">     * corePoolSize 线程池的核心线程数</span><span class="comment">     * maximumPoolSize 能容纳的最大线程数</span><span class="comment">     * keepAliveTime 空闲线程存活时间</span><span class="comment">     * unit 存活的时间单位</span><span class="comment">     * workQueue 存放提交但未执行任务的队列</span><span class="comment">     * threadFactory 创建线程的工厂类:可以省略</span><span class="comment">     * handler 等待队列满后的拒绝策略:可以省略</span><span class="comment">     */</span>    <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">ThreadPoolExecutor</span>(<span class="number">10</span>,            <span class="number">10</span>,            <span class="number">0L</span>,            TimeUnit.SECONDS,            <span class="keyword">new</span> <span class="title class_">LinkedBlockingQueue</span>&lt;&gt;(),            Executors.defaultThreadFactory(),            <span class="keyword">new</span> <span class="title class_">ThreadPoolExecutor</span>.AbortPolicy());&#125;</code></pre><p><strong>场景:</strong> 适用于可以预测线程数量的业务中，或者服务器负载较重，对线程数有严格限制的场景</p><h2 id="3-newSingleThreadExecutor-常用"><a href="#3-newSingleThreadExecutor-常用" class="headerlink" title="3. newSingleThreadExecutor(常用)"></a>3. newSingleThreadExecutor(常用)</h2><p><strong>作用</strong>：创建一个使用单个 worker 线程的 Executor，以无界队列方式来运行该线程。（注意，如果因为在关闭前的执行期间出现失败而终止了此单个线程，那么如果需要，一个新线程将代替它执行后续的任务）。可保证顺序地执行各个任务，并且在任意给定的时间不会有多个线程是活动的。与其他等效的 newFixedThreadPool 不同，可保证无需重新配置此方法所返回的执行程序即可使用其他的线程。</p><p><strong>特征：</strong> 线程池中最多执行 1 个线程，之后提交的线程活动将会排在队列中以此执行</p><p><strong>创建方式：</strong></p><pre><code class="highlight java"><span class="comment">/**</span><span class="comment"> * 单一线程池</span><span class="comment"> *</span><span class="comment"> * <span class="doctag">@return</span></span><span class="comment"> */</span><span class="keyword">public</span> <span class="keyword">static</span> ExecutorService <span class="title function_">newSingleThreadExecutor</span><span class="params">()</span> &#123;    <span class="comment">/**</span><span class="comment">    * corePoolSize 线程池的核心线程数</span><span class="comment">    * maximumPoolSize 能容纳的最大线程数</span><span class="comment">    * keepAliveTime 空闲线程存活时间</span><span class="comment">    * unit 存活的时间单位</span><span class="comment">    * workQueue 存放提交但未执行任务的队列</span><span class="comment">    * threadFactory 创建线程的工厂类:可以省略</span><span class="comment">    * handler 等待队列满后的拒绝策略:可以省略</span><span class="comment">    */</span>    <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">ThreadPoolExecutor</span>(<span class="number">1</span>,            <span class="number">1</span>,            <span class="number">0L</span>,            TimeUnit.SECONDS,            <span class="keyword">new</span> <span class="title class_">LinkedBlockingQueue</span>&lt;&gt;(),            Executors.defaultThreadFactory(),            <span class="keyword">new</span> <span class="title class_">ThreadPoolExecutor</span>.AbortPolicy());&#125;</code></pre><p><strong>场景:</strong> 适用于需要保证顺序执行各个任务，并且在任意时间点，不会同时有多个线程的场景</p><h2 id="4-newScheduleThreadPool-了解"><a href="#4-newScheduleThreadPool-了解" class="headerlink" title="4. newScheduleThreadPool(了解)"></a>4. newScheduleThreadPool(了解)</h2><p><strong>作用:</strong> 线程池支持定时以及周期性执行任务，创建一个 corePoolSize 为传入参数，最大线程数为整形的最大数的线程池</p><p><strong>特征:</strong></p><ul><li>线程池中具有指定数量的线程，即便是空线程也将保留 </li><li>可定时或者延迟执行线程活动</li></ul><p><strong>创建方式:</strong></p><pre><code class="highlight java"><span class="keyword">public</span> <span class="keyword">static</span> ScheduledExecutorService <span class="title function_">newScheduledThreadPool</span><span class="params">(<span class="type">int</span> corePoolSize,</span><span class="params">                                                              ThreadFactory threadFactory)</span> &#123;    <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">ScheduledThreadPoolExecutor</span>(corePoolSize,                                           threadFactory);&#125;</code></pre><p><strong>场景:</strong> 适用于需要多个后台线程执行周期任务的场景</p><h2 id="5-newWorkStealingPool"><a href="#5-newWorkStealingPool" class="headerlink" title="5. newWorkStealingPool"></a>5. newWorkStealingPool</h2><p>jdk1.8 提供的线程池，底层使用的是 ForkJoinPool 实现，创建一个拥有多个任务队列的线程池，可以减少连接数，创建当前可用 cpu 核数的线程来并行执行任务</p><p><strong>创建方式:</strong></p><pre><code class="highlight java"><span class="keyword">public</span> <span class="keyword">static</span> ExecutorService <span class="title function_">newWorkStealingPool</span><span class="params">(<span class="type">int</span> parallelism)</span> &#123;    <span class="comment">/**</span><span class="comment">     * parallelism：并行级别，通常默认为 JVM 可用的处理器个数</span><span class="comment">     * factory：用于创建 ForkJoinPool 中使用的线程。</span><span class="comment">     * handler：用于处理工作线程未处理的异常，默认为 null</span><span class="comment">     * asyncMode：用于控制 WorkQueue 的工作模式:队列---反队列</span><span class="comment">     */</span>    <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">ForkJoinPool</span>(parallelism,            ForkJoinPool.defaultForkJoinWorkerThreadFactory,            <span class="literal">null</span>,            <span class="literal">true</span>);&#125;</code></pre><p><strong>场景:</strong> 适用于大耗时，可并行执行的场景</p><h1 id="四、线程池入门案例"><a href="#四、线程池入门案例" class="headerlink" title="四、线程池入门案例"></a>四、线程池入门案例</h1><p><strong>场景: 火车站 3 个售票口, 10 个用户买票</strong></p><pre><code class="highlight java"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ThreadPoolDemo1</span> &#123;    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;        <span class="comment">//一池五线程</span>        <span class="type">ExecutorService</span> <span class="variable">threadPool1</span> <span class="operator">=</span> Executors.newFixedThreadPool(<span class="number">3</span>); <span class="comment">//5个窗口</span>        <span class="comment">//一池一线程</span>        <span class="type">ExecutorService</span> <span class="variable">threadPool2</span> <span class="operator">=</span> Executors.newSingleThreadExecutor(); <span class="comment">//一个窗口</span>        <span class="comment">//一池可扩容线程</span>        <span class="type">ExecutorService</span> <span class="variable">threadPool3</span> <span class="operator">=</span> Executors.newCachedThreadPool();        <span class="comment">// 创建当前可用的CPU核数的线程数的线程池</span>        <span class="type">ExecutorService</span> <span class="variable">threadPool4</span> <span class="operator">=</span> Executors.newWorkStealingPool();        <span class="comment">//10个顾客请求</span>        <span class="keyword">try</span> &#123;            <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">1</span>; i &lt;= <span class="number">10</span>; i++) &#123;                <span class="keyword">final</span> <span class="type">int</span> <span class="variable">num</span> <span class="operator">=</span> i;                <span class="comment">//执行</span>                threadPool1.execute(() -&gt; &#123;                    System.out.println(Thread.currentThread().getName() + <span class="string">&quot;开始办理业务&quot;</span> + num);                    <span class="keyword">try</span> &#123;                        TimeUnit.SECONDS.sleep(<span class="number">5</span>);                    &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;                        e.printStackTrace();                    &#125;                    System.out.println(Thread.currentThread().getName() + <span class="string">&quot;结束办理业务&quot;</span> + num);                &#125;);            &#125;        &#125; <span class="keyword">catch</span> (Exception e) &#123;            e.printStackTrace();        &#125; <span class="keyword">finally</span> &#123;            <span class="comment">//关闭线程池</span>            threadPool1.shutdown();        &#125;    &#125;&#125;</code></pre><p><strong>运行结果:</strong></p><pre><code class="highlight shell">pool-1-thread-1开始办理业务1pool-1-thread-2开始办理业务2pool-1-thread-3开始办理业务3pool-1-thread-2结束办理业务2pool-1-thread-1结束办理业务1pool-1-thread-1开始办理业务5pool-1-thread-3结束办理业务3pool-1-thread-2开始办理业务4pool-1-thread-3开始办理业务6pool-1-thread-1结束办理业务5pool-1-thread-3结束办理业务6pool-1-thread-3开始办理业务8pool-1-thread-2结束办理业务4pool-1-thread-2开始办理业务9pool-1-thread-1开始办理业务7pool-1-thread-2结束办理业务9pool-1-thread-2开始办理业务10pool-1-thread-1结束办理业务7pool-1-thread-3结束办理业务8pool-1-thread-2结束办理业务10</code></pre><h1 id="五、线程池底层工作原理-重要"><a href="#五、线程池底层工作原理-重要" class="headerlink" title="五、线程池底层工作原理(重要)"></a>五、线程池底层工作原理(重要)</h1><p><img src="https://raw.githubusercontent.com/GeorgeChan95/blogimg/master/img/2024/09/16/20240916-115726.png" alt="线程池底层工作原理"></p><ul><li>在创建了线程池后，线程池中的线程数为零</li><li>当调用 execute()方法添加一个请求任务时，线程池会做出如下判断<ul><li>如果正在运行的线程数量小于 corePoolSize，那么马上创建线程运行这个任务；</li><li>如果正在运行的线程数量大于或等于 corePoolSize，那么将这个任务放入队列；</li><li>如果这个时候队列满了且正在运行的线程数量还小于maximumPoolSize，那么还是要创建非核心线程立刻运行这个任务；</li><li>如果队列满了且正在运行的线程数量大于或等于 maximumPoolSize，那么线程池会启动饱和拒绝策略来执行。</li></ul></li><li>当一个线程完成任务时，它会从队列中取下一个任务来执行</li><li>当一个线程无事可做超过一定的时间（keepAliveTime）时，线程会判断<ul><li>如果当前运行的线程数大于 corePoolSize，那么这个线程就被停掉。</li><li>所以线程池的所有任务完成后，它最终会收缩到 corePoolSize 的大小。</li></ul></li></ul><p><img src="https://raw.githubusercontent.com/GeorgeChan95/blogimg/master/img/2024/09/16/20240916-120237.png" alt="JDK内置拒绝策略"></p><h1 id="六、注意事项-重要"><a href="#六、注意事项-重要" class="headerlink" title="六、注意事项(重要)"></a>六、注意事项(重要)</h1><ul><li><p>项目中创建多线程时，使用常见的三种线程池创建方式，单一、可变、定长都有一定问题，原因是 FixedThreadPool 和 SingleThreadExecutor 底层都是用 LinkedBlockingQueue 实现的，这个队列最大长度为 Integer.MAX_VALUE，容易导致 OOM。所以实际生产一般自己通过 ThreadPoolExecutor 的 7 个参数，自定义线程池</p></li><li><p>创建线程池推荐适用 ThreadPoolExecutor 及其 7 个参数手动创建</p><ul><li>corePoolSize 线程池的核心线程数</li><li>maximumPoolSize 能容纳的最大线程数</li><li>keepAliveTime 空闲线程存活时间</li><li>unit 存活的时间单位</li><li>workQueue 存放提交但未执行任务的队列</li><li>threadFactory 创建线程的工厂类</li><li>handler 等待队列满后的拒绝策略</li></ul></li><li><p>为什么不允许适用不允许 Executors.的方式手动创建线程池,如下图</p></li></ul><p><img src="https://raw.githubusercontent.com/GeorgeChan95/blogimg/master/img/2024/09/16/20240916-120936.png" alt="阿里巴巴开发手册关于线程池创建要求"></p><pre><code class="highlight java"><span class="comment">//自定义线程池创建</span><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ThreadPoolDemo2</span> &#123;    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;        <span class="type">ExecutorService</span> <span class="variable">threadPool</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ThreadPoolExecutor</span>(                <span class="number">2</span>,                <span class="number">5</span>,                <span class="number">2L</span>,                TimeUnit.SECONDS,                <span class="keyword">new</span> <span class="title class_">ArrayBlockingQueue</span>&lt;&gt;(<span class="number">3</span>),                Executors.defaultThreadFactory(),                <span class="keyword">new</span> <span class="title class_">ThreadPoolExecutor</span>.AbortPolicy()        );        <span class="comment">//10个顾客请求</span>        <span class="keyword">try</span> &#123;            <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">1</span>; i &lt;=<span class="number">10</span>; i++) &#123;                <span class="comment">//执行</span>                threadPool.execute(()-&gt;&#123;                    System.out.println(Thread.currentThread().getName()+<span class="string">&quot; 办理业务&quot;</span>);                &#125;);            &#125;        &#125;<span class="keyword">catch</span> (Exception e) &#123;            e.printStackTrace();        &#125;<span class="keyword">finally</span> &#123;            <span class="comment">//关闭</span>            threadPool.shutdown();        &#125;    &#125;&#125;</code></pre>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;一、线程池简介&quot;&gt;&lt;a href=&quot;#一、线程池简介&quot; class=&quot;headerlink&quot; title=&quot;一、线程池简介&quot;&gt;&lt;/a&gt;一、线程池简介&lt;/h1&gt;&lt;p&gt;线程池（英语：thread pool）：一种线程使用模式。线程过多会带来调度开销，进而影响缓存局部性</summary>
      
    
    
    
    <category term="JUC" scheme="https://georgechan95.github.io/categories/JUC/"/>
    
    
    <category term="juc" scheme="https://georgechan95.github.io/tags/juc/"/>
    
    <category term="java" scheme="https://georgechan95.github.io/tags/java/"/>
    
  </entry>
  
  <entry>
    <title>08-阻塞队列BlockingQueue</title>
    <link href="https://georgechan95.github.io/blog/a6760d1f.html"/>
    <id>https://georgechan95.github.io/blog/a6760d1f.html</id>
    <published>2024-09-07T09:30:00.000Z</published>
    <updated>2024-09-13T00:27:39.289Z</updated>
    
    <content type="html"><![CDATA[<h1 id="一、阻塞队列概述"><a href="#一、阻塞队列概述" class="headerlink" title="一、阻塞队列概述"></a>一、阻塞队列概述</h1><p>阻塞队列，顾名思义，首先它是一个队列, 通过一个共享的队列，可以使得数据由队列的一端输入，从另外一端输出；</p><img src="https://raw.githubusercontent.com/GeorgeChan95/blogimg/master/img/2024/09/07/20240907-173358" alt="阻塞队列" style="zoom:50%;" /><ul><li>当队列是空的，从队列中获取元素的操作将会被阻塞</li><li>当队列是满的，从队列中添加元素的操作将会被阻塞</li><li>试图从空的队列中获取元素的线程将会被阻塞，直到其他线程往空的队列插入新的元素</li><li>试图向已满的队列中添加新元素的线程将会被阻塞，直到其他线程从队列中移除一个或多个元素或者完全清空，使队列变得空闲起来并后续新增</li></ul><p>常用的队列主要有以下两种：</p><ul><li>先进先出（FIFO）：先插入的队列的元素也最先出队列，类似于排队的功能。从某种程度上来说这种队列也体现了一种公平性</li><li>后进先出（LIFO）：后插入队列的元素最先出队列，这种队列优先处理最近发生的事件(栈)</li></ul><p>在多线程领域：所谓阻塞，在某些情况下会挂起线程（即阻塞），一旦条件满足，被挂起的线程又会自动被唤起</p><p><strong>为什么需要 BlockingQueue?</strong></p><p>好处是我们不需要关心什么时候需要阻塞线程，什么时候需要唤醒线程，因为这一切 BlockingQueue 都给你一手包办了.</p><p>在 concurrent 包发布以前，在多线程环境下，我们每个程序员都必须去自己控制这些细节，尤其还要兼顾效率和线程安全，而这会给我们的程序带来不小的复杂度。多线程环境中，通过队列可以很容易实现数据共享，比如经典的“生产者”和“消费者”模型中，通过队列可以很便利地实现两者之间的数据共享。假设我们有若干生产者线程，另外又有若干个消费者线程。如果生产者线程需要把准备好的数据共享给消费者线程，利用队列的方式来传递数据，就可以很方便地解决他们之间的数据共享问题。但如果生产者和消费者在某个时间段内，万一发生数据处理速度不匹配的情况呢？理想情况下，如果生产者产出数据的速度大于消费者消费的速度，并且当生产出来的数据累积到一定程度的时候，那么生产者必须暂停等待一下（阻塞生产者线程），以便等待消费者线程把累积的数据处理完毕，反之亦然。</p><ul><li>当队列中没有数据的情况下，消费者端的所有线程都会被自动阻塞（挂起），直到有数据放入队列</li><li>当队列中填满数据的情况下，生产者端的所有线程都会被自动阻塞（挂起），直到队列中有空的位置，线程被自动唤醒</li></ul><h1 id="二、BlockingQueue-核心方法"><a href="#二、BlockingQueue-核心方法" class="headerlink" title="二、BlockingQueue 核心方法"></a>二、BlockingQueue 核心方法</h1><table><thead><tr><th align="center">方法类型</th><th align="center">抛出异常</th><th align="center">特殊值</th><th align="center">阻塞</th><th align="center">超时</th></tr></thead><tbody><tr><td align="center">插入</td><td align="center">add(e)</td><td align="center">offer()</td><td align="center">put(e)</td><td align="center">offer(e,time,unit)</td></tr><tr><td align="center">移除</td><td align="center">remove()</td><td align="center">poll()</td><td align="center">take()</td><td align="center">poll(time,unit)</td></tr><tr><td align="center">检查</td><td align="center">element()</td><td align="center">peek()</td><td align="center">-</td><td align="center">-</td></tr></tbody></table><table><thead><tr><th>抛出异常</th><th>当阻塞队列满时，再往队列里add插入元素会抛出IllegalStateException:Queue full <br />当阻塞队列空时，再往队列里remove移除元素会抛出NoSuchElementException</th></tr></thead><tbody><tr><td><strong>特殊值</strong></td><td>插入方法，成功true，失败false 移除方法，成功返回出队列的元素，列表里没有就返回null</td></tr><tr><td><strong>阻塞</strong></td><td>当阻塞队列满时，生产者线程继续往队列里put元素，队列会一直阻塞生产者线程知道put数据或响应中断退出 当阻塞队列空时，消费者线程视图从队列里take元素，队列会一直阻塞消费者线程直到队列可用</td></tr><tr><td><strong>超时</strong></td><td>当阻塞队列满时，队列会阻塞生产者线程一定时间，超过限时后生产者线程会退出</td></tr></tbody></table><h2 id="1-放入数据"><a href="#1-放入数据" class="headerlink" title="1. 放入数据"></a>1. 放入数据</h2><ul><li>offer(Object):表示如果可能的话,将 Object 加到 BlockingQueue 里,即如果 BlockingQueue 可以容纳,则返回 true,否则返回 false.<strong>（本方法不阻塞当前执行方法的线程）</strong></li><li>offer(E o, long timeout, TimeUnit unit)：可以设定等待的时间，如果在指定的时间内，还不能往队列中加入 BlockingQueue，则返回失败</li><li>put(Object):把 Object 加到 BlockingQueue 里,如果 BlockQueue 没有空间,则调用此方法的线程被阻断直到 BlockingQueue 里面有空间再继续.</li></ul><h2 id="2-获取数据"><a href="#2-获取数据" class="headerlink" title="2. 获取数据"></a>2. 获取数据</h2><ul><li>poll(time): 取走 BlockingQueue 里排在首位的对象,若不能立即取出,则可以等time 参数规定的时间,取不到时返回 null</li><li>poll(long timeout, TimeUnit unit)：从 BlockingQueue 取出一个队首的对象，如果在指定时间内，队列一旦有数据可取，则立即返回队列中的数据。否则知道时间超时还没有数据可取，返回失败。</li><li>take(): 取走 BlockingQueue 里排在首位的对象,若 BlockingQueue 为空,<strong>阻断进入等待状态直到 BlockingQueue 有新的数据被加入</strong>;</li><li>drainTo(): 一次性从 BlockingQueue 获取所有可用的数据对象（还可以指定获取数据的个数），通过该方法，可以提升获取数据效率；不需要多次分批加锁或释放锁。</li></ul><h1 id="三、入门案例"><a href="#三、入门案例" class="headerlink" title="三、入门案例"></a>三、入门案例</h1><pre><code class="highlight java"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">BlockingQueueTest</span> &#123;    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> InterruptedException &#123;        <span class="comment">/********************* 第一种: 抛出异常 ***********************/</span>        BlockingQueue&lt;Object&gt; bQueue1 = <span class="keyword">new</span> <span class="title class_">ArrayBlockingQueue</span>&lt;&gt;(<span class="number">3</span>);        System.out.println(bQueue1.add(<span class="string">&quot;a&quot;</span>)); <span class="comment">// true</span>        System.out.println(bQueue1.add(<span class="string">&quot;b&quot;</span>)); <span class="comment">// true</span>        System.out.println(bQueue1.add(<span class="string">&quot;c&quot;</span>)); <span class="comment">// true</span><span class="comment">//        System.out.println(bQueue1.add(&quot;d&quot;)); // Exception in thread &quot;main&quot; java.lang.IllegalStateException: Queue full</span>        <span class="comment">// 检查</span>        System.out.println(bQueue1.element()); <span class="comment">// a</span>        System.out.println(bQueue1.remove()); <span class="comment">// a</span>        System.out.println(bQueue1.remove()); <span class="comment">// b</span>        System.out.println(bQueue1.element()); <span class="comment">// c</span>                <span class="comment">/********************* 第二种: 特殊值 ***********************/</span>        BlockingQueue&lt;Object&gt; bQueue2 = <span class="keyword">new</span> <span class="title class_">ArrayBlockingQueue</span>&lt;&gt;(<span class="number">3</span>);        System.out.println(bQueue2.offer(<span class="string">&quot;e&quot;</span>)); <span class="comment">// true</span>        System.out.println(bQueue2.offer(<span class="string">&quot;f&quot;</span>)); <span class="comment">// true</span>        System.out.println(bQueue2.offer(<span class="string">&quot;g&quot;</span>)); <span class="comment">// true</span>        System.out.println(bQueue2.offer(<span class="string">&quot;h&quot;</span>)); <span class="comment">// false</span>        System.out.println(bQueue2.peek()); <span class="comment">// e</span>        System.out.println(bQueue2.poll()); <span class="comment">// e</span>        System.out.println(bQueue2.poll()); <span class="comment">// f</span>                <span class="comment">/********************* 第三种: 阻塞 ***********************/</span>        BlockingQueue&lt;Object&gt; bQueue3 = <span class="keyword">new</span> <span class="title class_">ArrayBlockingQueue</span>&lt;&gt;(<span class="number">3</span>);        bQueue3.put(<span class="string">&quot;j&quot;</span>);        bQueue3.put(<span class="string">&quot;k&quot;</span>);        bQueue3.put(<span class="string">&quot;l&quot;</span>);        System.out.println(bQueue3.take()); <span class="comment">// j</span>        bQueue3.put(<span class="string">&quot;m&quot;</span>);        System.out.println(<span class="string">&quot;m&quot;</span>); <span class="comment">// m</span>        bQueue3.put(<span class="string">&quot;n&quot;</span>); <span class="comment">// 阻塞</span>                <span class="comment">/********************* 第四种: 超时 ***********************/</span>        BlockingQueue&lt;Object&gt; bQueue4 = <span class="keyword">new</span> <span class="title class_">ArrayBlockingQueue</span>&lt;&gt;(<span class="number">3</span>);        System.out.println(bQueue4.offer(<span class="string">&quot;o&quot;</span>, <span class="number">3</span>, TimeUnit.SECONDS)); <span class="comment">// true</span>        System.out.println(bQueue4.offer(<span class="string">&quot;p&quot;</span>, <span class="number">3</span>, TimeUnit.SECONDS)); <span class="comment">// true</span>        System.out.println(bQueue4.offer(<span class="string">&quot;q&quot;</span>, <span class="number">3</span>, TimeUnit.SECONDS)); <span class="comment">// true</span>        System.out.println(bQueue4.offer(<span class="string">&quot;r&quot;</span>, <span class="number">3</span>, TimeUnit.SECONDS)); <span class="comment">// false</span>        System.out.println(bQueue4.poll(<span class="number">2</span>, TimeUnit.SECONDS)); <span class="comment">// o</span>        System.out.println(bQueue4.poll(<span class="number">2</span>, TimeUnit.SECONDS)); <span class="comment">// p</span>        System.out.println(bQueue4.poll(<span class="number">2</span>, TimeUnit.SECONDS)); <span class="comment">// q</span>        System.out.println(bQueue4.poll(<span class="number">2</span>, TimeUnit.SECONDS)); <span class="comment">// null</span>    &#125;&#125;</code></pre><h1 id="四、常见的-BlockingQueue"><a href="#四、常见的-BlockingQueue" class="headerlink" title="四、常见的 BlockingQueue"></a>四、常见的 BlockingQueue</h1><h2 id="1-ArrayBlockingQueue-常用"><a href="#1-ArrayBlockingQueue-常用" class="headerlink" title="1. ArrayBlockingQueue(常用)"></a>1. ArrayBlockingQueue(常用)</h2><p><strong>由数组结构组成的有界阻塞队列</strong></p><p>基于数组的阻塞队列实现，在 ArrayBlockingQueue 内部，维护了一个定长数组，以便缓存队列中的数据对象，这是一个常用的阻塞队列，除了一个定长数组外，ArrayBlockingQueue 内部还保存着两个整形变量，分别标识着队列的头部和尾部在数组中的位置。</p><p>ArrayBlockingQueue 在生产者放入数据和消费者获取数据，都是共用同一个锁对象，由此也意味着两者无法真正并行运行，这点尤其不同于LinkedBlockingQueue；按照实现原理来分析，ArrayBlockingQueue完全可以采用分离锁，从而实现生产者和消费者操作的完全并行运行。Doug Lea之所以没这样去做，也许是因为ArrayBlockingQueue的数据写入和获取操作已经足够轻巧，以至于引入独立的锁机制，除了给代码带来额外的复杂性外，其在性能上完全占不到任何便宜。ArrayBlockingQueue和LinkedBlockingQueue间还有一个明显的不同之处在于，前者在插入或删除元素时不会产生或销毁任何额外的对象实例，而后者则会生成一个额外的Node对象。这在长时间内需要高效并发地处理大批量数据的系统中，其对于GC的影响还是存在一定的区别。而在创建ArrayBlockingQueue时，我们还可以控制对象的内部锁是否采用公平锁，默认采用非公平锁。</p><h2 id="2-LinkedBlockingQueue-常用"><a href="#2-LinkedBlockingQueue-常用" class="headerlink" title="2. LinkedBlockingQueue(常用)"></a>2. LinkedBlockingQueue(常用)</h2><p><strong>由链表结构组成的有界（但大小默认值为integer.MAX_VALUE）阻塞队列。</strong></p><p>基于链表的阻塞队列，同ArrayListBlockingQueue类似，其内部也维持着一个数据缓冲队列（该队列由一个链表构成），当生产者往队列中放入一个数据时，队列会从生产者手中获取数据，并缓存在队列内部，而生产者立即返回；只有当队列缓冲区达到最大值缓存容量时（LinkedBlockingQueue可以通过构造函数指定该值），才会阻塞生产者队列，直到消费者从队列中消费掉一份数据，生产者线程会被唤醒，反之对于消费者这端的处理也基于同样的原理。而LinkedBlockingQueue之所以能够高效的处理并发数据，还因为其对于生产者端和消费者端分别采用了独立的锁来控制数据同步，这也意味着在高并发的情况下生产者和消费者可以并行地操作队列中的数据，以此来提高整个队列的并发性能。</p><p><strong>ArrayBlockingQueue</strong> 和 <strong>LinkedBlockingQueue</strong> 是两个最普通也是最常用的阻塞队列，一般情况下，在处理多线程间的生产者消费者问题，使用这两个类足以。</p><h2 id="3-DelayQueue"><a href="#3-DelayQueue" class="headerlink" title="3. DelayQueue"></a>3. DelayQueue</h2><p><strong>使用优先级队列实现的延迟无界阻塞队列。</strong></p><p>DelayQueue中的元素只有当其指定的延迟时间到了，才能够从队列中获取到该元素。DelayQueue是一个没有大小限制的队列，因此往队列中插入数据的操作（生产者）永远不会被阻塞，而只有获取数据的操作（消费者）才会被阻塞。</p><h2 id="4-PriorityBlockingQueue"><a href="#4-PriorityBlockingQueue" class="headerlink" title="4. PriorityBlockingQueue"></a>4. PriorityBlockingQueue</h2><p><strong>支持优先级排序的无界阻塞队列。</strong></p><p>基于优先级的阻塞队列（优先级的判断通过构造函数传入的Compator对象来决定），但需要注意的是PriorityBlockingQueue并<strong>不会阻塞数据生产者，而只会在没有可消费的数据时，阻塞数据的消费者</strong>。</p><h2 id="5-SynchronousQueue"><a href="#5-SynchronousQueue" class="headerlink" title="5. SynchronousQueue"></a>5. SynchronousQueue</h2><p><strong>不存储元素的阻塞队列，也即单个元素的队列。</strong></p><p>一种无缓冲的等待队列，类似于无中介的直接交易，有点像原始社会中的生产者和消费者，生产者拿着产品去集市销售给产品的最终消费者，而消费者必须亲自去集市找到所要商品的直接生产者，如果一方没有找到合适的目标，那么对不起，大家都在集市等待。相对于有缓冲的BlockingQueue来说，少了一个中间经销商的环节（缓冲区），如果有经销商，生产者直接把产品批发给经销商，而无需在意经销商最终会将这些产品卖给那些消费者，由于经销商可以库存一部分商品，因此相对于直接交易模式，总体来说采用中间经销商的模式会吞吐量高一些（可以批量买卖）；但另一方面，又因为经销商的引入，使得产品从生产者到消费者中间增加了额外的交易环节，单个产品的及时响应性能可能会降低。</p><p>声明一个SynchronousQueue有两种不同的方式，它们之间有着不太一样的行为。</p><p><strong>公平模式和非公平模式的区别</strong>:</p><ul><li>公平模式：SynchronousQueue会采用公平锁，并配合一个FIFO队列来阻塞多余的生产者和消费者，从而体现整体的公平策略；</li><li>非公平模式（SynchronousQueue默认）：SynchronousQueue采用非公平锁，同时配合一个LIFO队列来管理多余的生产者和消费者，而后一种模式，如果生产者和消费者的处理速度有差距，则很容易出现饥渴的情况，即可能有某些生产者或者是消费者的数据永远都得不到处理。</li></ul><h2 id="6-LinkedTransferQueue"><a href="#6-LinkedTransferQueue" class="headerlink" title="6. LinkedTransferQueue"></a>6. LinkedTransferQueue</h2><p><strong>由链表组成的无界阻塞队列。</strong></p><p>LinkedTransferQueue 是一个由链表结构组成的无界阻塞 TransferQueue 队列。相对于其他阻塞队列，LinkedTransferQueue 多了 tryTransfer 和 transfer 方法.</p><p>LinkedTransferQueue 采用一种预占模式。意思就是消费者线程取元素时，如果队列不为空，则直接取走数据，若队列为空，那就生成一个节点（节点元素为 null）入队，然后消费者线程被等待在这个节点上，后面生产者线程入队时发现有一个元素为 null 的节点，生产者线程就不入队了，直接就将元素填充到该节点，并唤醒该节点等待的线程，被唤醒的消费者线程取走元素，从调用的方法返回。</p><h2 id="7-LinkedBlockingDeque"><a href="#7-LinkedBlockingDeque" class="headerlink" title="7.  LinkedBlockingDeque"></a>7.  LinkedBlockingDeque</h2><p><strong>由链表组成的双向阻塞队列</strong></p><p>LinkedBlockingDeque 是一个由链表结构组成的双向阻塞队列，即可以从队列的两端插入和移除元素。对于一些指定的操作，在插入或者获取队列元素时如果队列状态不允许该操作可能会阻塞住该线程直到队列状态变更为允许操作，这里的阻塞一般有两种情况</p><ul><li><p>插入元素时: 如果当前队列已满将会进入阻塞状态，一直等到队列有空的位置时再将该元素插入，该操作可以通过设置超时参数，超时后返回 false 表示操作失败，也可以不设置超时参数一直阻塞，中断后抛出 InterruptedException 异常</p></li><li><p>读取元素时: 如果当前队列为空会阻塞住直到队列不为空然后返回元素，同样可以通过设置超时参数</p></li></ul>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;一、阻塞队列概述&quot;&gt;&lt;a href=&quot;#一、阻塞队列概述&quot; class=&quot;headerlink&quot; title=&quot;一、阻塞队列概述&quot;&gt;&lt;/a&gt;一、阻塞队列概述&lt;/h1&gt;&lt;p&gt;阻塞队列，顾名思义，首先它是一个队列, 通过一个共享的队列，可以使得数据由队列的一端输入，从</summary>
      
    
    
    
    <category term="JUC" scheme="https://georgechan95.github.io/categories/JUC/"/>
    
    
    <category term="juc" scheme="https://georgechan95.github.io/tags/juc/"/>
    
    <category term="java" scheme="https://georgechan95.github.io/tags/java/"/>
    
  </entry>
  
  <entry>
    <title>07-JUC辅助类CountDownLatch、CyclicBarrier、Semaphore</title>
    <link href="https://georgechan95.github.io/blog/838e7581.html"/>
    <id>https://georgechan95.github.io/blog/838e7581.html</id>
    <published>2024-09-07T05:00:00.000Z</published>
    <updated>2024-09-07T07:42:20.066Z</updated>
    
    <content type="html"><![CDATA[<p>JUC 中提供了三种常用的辅助类，通过这些辅助类可以很好的解决线程数量过多时 Lock 锁的频繁操作。这三种辅助类为：</p><ul><li>CountDownLatch: 减少计数</li><li>CyclicBarrier: 循环栅栏</li><li>Semaphore: 信号灯</li></ul><h1 id="一、减少计数-CountDownLatch"><a href="#一、减少计数-CountDownLatch" class="headerlink" title="一、减少计数 CountDownLatch"></a>一、减少计数 CountDownLatch</h1><h2 id="1-概述"><a href="#1-概述" class="headerlink" title="1. 概述"></a>1. 概述</h2><p>该类的构造方法为 <code>CountDownLatch(int count)</code> 构造一个用给定计数初始化的 <code>CountDownLatch</code> </p><p>在这里插入代码片</p><pre><code class="highlight java"><span class="comment">/**</span><span class="comment"> * Constructs a &#123;<span class="doctag">@code</span> CountDownLatch&#125; initialized with the given count.</span><span class="comment"> *</span><span class="comment"> * <span class="doctag">@param</span> count the number of times &#123;<span class="doctag">@link</span> #countDown&#125; must be invoked</span><span class="comment"> *        before threads can pass through &#123;<span class="doctag">@link</span> #await&#125;</span><span class="comment"> * <span class="doctag">@throws</span> IllegalArgumentException if &#123;<span class="doctag">@code</span> count&#125; is negative</span><span class="comment"> */</span><span class="keyword">public</span> <span class="title function_">CountDownLatch</span><span class="params">(<span class="type">int</span> count)</span> &#123;    <span class="keyword">if</span> (count &lt; <span class="number">0</span>) <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">IllegalArgumentException</span>(<span class="string">&quot;count &lt; 0&quot;</span>);    <span class="built_in">this</span>.sync = <span class="keyword">new</span> <span class="title class_">Sync</span>(count);&#125;</code></pre><p>CountDownLatch 类可以设置一个计数器，然后通过 countDown 方法来进行减 1 的操作，使用 await 方法等待计数器不大于 0，然后继续执行 await 方法之后的语句。具体步骤可以演化为<strong>定义一个类，减1操作，并等待到0，为0执行结果</strong>。</p><p><strong>两个常用的主要方法</strong></p><ul><li>await() 使当前线程在锁存器倒计数至零之前一直在等待，除非线程被中断</li></ul><pre><code class="highlight java"><span class="comment">/**</span><span class="comment"> * Causes the current thread to wait until the latch has counted down to</span><span class="comment"> * zero, unless the thread is &#123;<span class="doctag">@linkplain</span> Thread#interrupt interrupted&#125;.</span><span class="comment"> *</span><span class="comment"> * &lt;p&gt;If the current count is zero then this method returns immediately.</span><span class="comment"> *</span><span class="comment"> * &lt;p&gt;If the current count is greater than zero then the current</span><span class="comment"> * thread becomes disabled for thread scheduling purposes and lies</span><span class="comment"> * dormant until one of two things happen:</span><span class="comment"> * &lt;ul&gt;</span><span class="comment"> * &lt;li&gt;The count reaches zero due to invocations of the</span><span class="comment"> * &#123;<span class="doctag">@link</span> #countDown&#125; method; or</span><span class="comment"> * &lt;li&gt;Some other thread &#123;<span class="doctag">@linkplain</span> Thread#interrupt interrupts&#125;</span><span class="comment"> * the current thread.</span><span class="comment"> * &lt;/ul&gt;</span><span class="comment"> *</span><span class="comment"> * &lt;p&gt;If the current thread:</span><span class="comment"> * &lt;ul&gt;</span><span class="comment"> * &lt;li&gt;has its interrupted status set on entry to this method; or</span><span class="comment"> * &lt;li&gt;is &#123;<span class="doctag">@linkplain</span> Thread#interrupt interrupted&#125; while waiting,</span><span class="comment"> * &lt;/ul&gt;</span><span class="comment"> * then &#123;<span class="doctag">@link</span> InterruptedException&#125; is thrown and the current thread&#x27;s</span><span class="comment"> * interrupted status is cleared.</span><span class="comment"> *</span><span class="comment"> * <span class="doctag">@throws</span> InterruptedException if the current thread is interrupted</span><span class="comment"> *         while waiting</span><span class="comment"> */</span><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">await</span><span class="params">()</span> <span class="keyword">throws</span> InterruptedException &#123;    sync.acquireSharedInterruptibly(<span class="number">1</span>);&#125;</code></pre><ul><li>countDown()递减锁存器的计数，如果计数达到零，将释放所有等待的线程</li></ul><pre><code class="highlight java"><span class="comment">/**</span><span class="comment"> * Decrements the count of the latch, releasing all waiting threads if</span><span class="comment"> * the count reaches zero.</span><span class="comment"> *</span><span class="comment"> * &lt;p&gt;If the current count is greater than zero then it is decremented.</span><span class="comment"> * If the new count is zero then all waiting threads are re-enabled for</span><span class="comment"> * thread scheduling purposes.</span><span class="comment"> *</span><span class="comment"> * &lt;p&gt;If the current count equals zero then nothing happens.</span><span class="comment"> */</span><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">countDown</span><span class="params">()</span> &#123;    sync.releaseShared(<span class="number">1</span>);&#125;<span class="comment">/**</span><span class="comment"> * Releases in shared mode.  Implemented by unblocking one or more</span><span class="comment"> * threads if &#123;<span class="doctag">@link</span> #tryReleaseShared&#125; returns true.</span><span class="comment"> *</span><span class="comment"> * <span class="doctag">@param</span> arg the release argument.  This value is conveyed to</span><span class="comment"> *        &#123;<span class="doctag">@link</span> #tryReleaseShared&#125; but is otherwise uninterpreted</span><span class="comment"> *        and can represent anything you like.</span><span class="comment"> * <span class="doctag">@return</span> the value returned from &#123;<span class="doctag">@link</span> #tryReleaseShared&#125;</span><span class="comment"> */</span><span class="keyword">public</span> <span class="keyword">final</span> <span class="type">boolean</span> <span class="title function_">releaseShared</span><span class="params">(<span class="type">int</span> arg)</span> &#123;    <span class="keyword">if</span> (tryReleaseShared(arg)) &#123;        signalNext(head);        <span class="keyword">return</span> <span class="literal">true</span>;    &#125;    <span class="keyword">return</span> <span class="literal">false</span>;&#125;</code></pre><h2 id="2-案例演示"><a href="#2-案例演示" class="headerlink" title="2. 案例演示"></a>2. 案例演示</h2><p>6个同学陆续离开教室之后，班长才能锁门</p><p><strong>演示没有CountDownLatch的情况</strong></p><p>如果不加 CountDownLatch类，会出现线程混乱执行，同学还未离开教室班长就已经锁门了</p><pre><code class="highlight java"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">NoCountDownLatch</span> &#123;    <span class="comment">//6个同学陆续离开教室之后，班长锁门</span>    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> InterruptedException &#123;        <span class="comment">// 创建六个线程，模拟六个学生</span>        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">1</span>; i &lt;=<span class="number">6</span>; i++) &#123;            <span class="keyword">new</span> <span class="title class_">Thread</span>(()-&gt;&#123;                System.out.println(Thread.currentThread().getName()+<span class="string">&quot;离开教室&quot;</span>);            &#125;,String.valueOf(i)).start();        &#125;        System.out.println(Thread.currentThread().getName()+<span class="string">&quot;锁门&quot;</span>);    &#125;&#125;</code></pre><p>运行结果：</p><pre><code class="highlight shell">5离开教室main锁门2离开教室1离开教室6离开教室3离开教室4离开教室</code></pre><p><strong>添加CountDownLatch</strong></p><pre><code class="highlight java"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">CountDownLatchDemo</span> &#123;    <span class="comment">//6个同学陆续离开教室之后，班长锁门</span>    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> InterruptedException &#123;        <span class="type">CountDownLatch</span> <span class="variable">countDownLatch</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">CountDownLatch</span>(<span class="number">6</span>);        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">1</span>; i &lt;= <span class="number">6</span>; i++) &#123;            <span class="keyword">new</span> <span class="title class_">Thread</span>(() -&gt; &#123;                System.out.println(Thread.currentThread().getName() + <span class="string">&quot; 号同学离开了教室&quot;</span>);                <span class="comment">// 计数器减1</span>                countDownLatch.countDown();            &#125;, String.valueOf(i)).start();        &#125;        <span class="comment">// 阻塞，等待计数器为0后，继续往下执行</span>        countDownLatch.await();        System.out.println(Thread.currentThread().getName() + <span class="string">&quot;执行了关门操作&quot;</span>);    &#125;&#125;</code></pre><p>运行结果：</p><pre><code class="highlight shell">2 号同学离开了教室5 号同学离开了教室6 号同学离开了教室1 号同学离开了教室4 号同学离开了教室3 号同学离开了教室main执行了关门操作</code></pre><h1 id="二、循环栅栏-CyclicBarrier"><a href="#二、循环栅栏-CyclicBarrier" class="headerlink" title="二、循环栅栏 CyclicBarrier"></a>二、循环栅栏 CyclicBarrier</h1><h2 id="1-概述-1"><a href="#1-概述-1" class="headerlink" title="1. 概述"></a>1. 概述</h2><p>CyclicBarrier 字面意思是环栅栏，是 JUC 下的一个并发工具，跟 CountDownLatch 很相似，都可以使线程先等待然后再执行，但是它的功能比 CountDownLatch 更加复杂和强大， CountDownLatch 是一个或者多个线程等待另外一批线程执行完毕后，在接着执行，而 CyclicBarrier 是等待一批线程到达某个状态之后再同时开始执行，回环的意思是当所有的线程被释放后，CyclicBarrier 可以被重启，也就是可以重复使用。</p><p><img src="https://raw.githubusercontent.com/GeorgeChan95/blogimg/master/img/2024/09/07/20240907-141817.png" alt="CyclicBarrier"></p><p>常用的构造方法有：**CyclicBarrier(int parties，Runnable barrierAction)**，其底层代码如下</p><pre><code class="highlight java"><span class="keyword">public</span> <span class="title function_">CyclicBarrier</span><span class="params">(<span class="type">int</span> parties, Runnable barrierAction)</span> &#123;    <span class="keyword">if</span> (parties &lt;= <span class="number">0</span>) <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">IllegalArgumentException</span>();    <span class="built_in">this</span>.parties = parties;    <span class="built_in">this</span>.count = parties;    <span class="comment">// 最后需要执行的方法</span>    <span class="built_in">this</span>.barrierCommand = barrierAction;&#125;</code></pre><p>创建一个新的CyclicBarrier，它将在<strong>给定数量的参与者</strong>（线程）处于等待状态时启动，并在启动barrier时执行**给定的屏障操作，*<em>该操作由最后一个*<em>进入barrier的线程操作</em></em></p><p>常用的方法有：</p><p><strong>await()</strong> 在所有的参与者都已经在此barrier上调用await方法之前一直等待。</p><pre><code class="highlight java"><span class="keyword">public</span> <span class="type">int</span> <span class="title function_">await</span><span class="params">()</span> <span class="keyword">throws</span> InterruptedException, BrokenBarrierException &#123;    <span class="keyword">try</span> &#123;        <span class="keyword">return</span> dowait(<span class="literal">false</span>, <span class="number">0L</span>);    &#125; <span class="keyword">catch</span> (TimeoutException toe) &#123;        <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">Error</span>(toe); <span class="comment">// cannot happen</span>    &#125;&#125;<span class="keyword">private</span> <span class="type">int</span> <span class="title function_">dowait</span><span class="params">(<span class="type">boolean</span> timed, <span class="type">long</span> nanos)</span>    <span class="keyword">throws</span> InterruptedException, BrokenBarrierException,TimeoutException &#123;    <span class="keyword">final</span> <span class="type">ReentrantLock</span> <span class="variable">lock</span> <span class="operator">=</span> <span class="built_in">this</span>.lock;    <span class="comment">// 同步锁</span>    lock.lock();    <span class="keyword">try</span> &#123;        <span class="keyword">final</span> <span class="type">Generation</span> <span class="variable">g</span> <span class="operator">=</span> generation;        <span class="keyword">if</span> (g.broken)            <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">BrokenBarrierException</span>();        <span class="keyword">if</span> (Thread.interrupted()) &#123;            breakBarrier();            <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">InterruptedException</span>();        &#125;<span class="comment">// 每次执行 CyclicBarrier 一次障碍数会加一，距离目标障碍数-1</span>        <span class="type">int</span> <span class="variable">index</span> <span class="operator">=</span> --count;        <span class="comment">// 当达到目标障碍数执行if内代码</span>        <span class="keyword">if</span> (index == <span class="number">0</span>) &#123;  <span class="comment">// tripped</span>            <span class="type">boolean</span> <span class="variable">ranAction</span> <span class="operator">=</span> <span class="literal">false</span>;            <span class="keyword">try</span> &#123;                <span class="keyword">final</span> <span class="type">Runnable</span> <span class="variable">command</span> <span class="operator">=</span> barrierCommand;                <span class="keyword">if</span> (command != <span class="literal">null</span>)                    <span class="comment">// 执行Runnable代码</span>                    command.run();                ranAction = <span class="literal">true</span>;                nextGeneration();                <span class="comment">// 返回0</span>                <span class="keyword">return</span> <span class="number">0</span>;            &#125; <span class="keyword">finally</span> &#123;                <span class="keyword">if</span> (!ranAction)                    breakBarrier();            &#125;        &#125;        <span class="comment">// 循环，直到触发、中断、中断或超时  </span>        <span class="keyword">for</span> (;;) &#123;            <span class="keyword">try</span> &#123;                <span class="keyword">if</span> (!timed)                    trip.await();                <span class="keyword">else</span> <span class="keyword">if</span> (nanos &gt; <span class="number">0L</span>)                    nanos = trip.awaitNanos(nanos);            &#125; <span class="keyword">catch</span> (InterruptedException ie) &#123;                <span class="keyword">if</span> (g == generation &amp;&amp; ! g.broken) &#123;                    breakBarrier();                    <span class="keyword">throw</span> ie;                &#125; <span class="keyword">else</span> &#123;                    <span class="comment">// We&#x27;re about to finish waiting even if we had not</span>                    <span class="comment">// been interrupted, so this interrupt is deemed to</span>                    <span class="comment">// &quot;belong&quot; to subsequent execution.</span>                    Thread.currentThread().interrupt();                &#125;            &#125;            <span class="keyword">if</span> (g.broken)                <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">BrokenBarrierException</span>();            <span class="keyword">if</span> (g != generation)                <span class="keyword">return</span> index;            <span class="keyword">if</span> (timed &amp;&amp; nanos &lt;= <span class="number">0L</span>) &#123;                breakBarrier();                <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">TimeoutException</span>();            &#125;        &#125;    &#125; <span class="keyword">finally</span> &#123;        lock.unlock();    &#125;&#125;</code></pre><p>从底层代码可知， CyclicBarrier 的构造方法第一个参数是目标障碍数，每次执行 CyclicBarrier 一次障碍数会+1，如果达到了目标障碍数，才会执行 cyclicBarrier.await()之后的语句。可以将 CyclicBarrier 理解为+1 操作（指与目标障碍数的距离）</p><h2 id="2-案例演示-1"><a href="#2-案例演示-1" class="headerlink" title="2. 案例演示"></a>2. 案例演示</h2><p><strong>代码案例：集齐7颗龙珠就可以召唤神龙</strong></p><pre><code class="highlight java"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">CyclicBarrirtTest</span> &#123;    <span class="keyword">private</span> <span class="keyword">static</span> <span class="type">Integer</span> <span class="variable">NUMBER</span> <span class="operator">=</span> <span class="number">7</span>;    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;        <span class="comment">// 每次执行 CyclicBarrier 一次障碍数会加一，如果达到了目标障碍数，才会执行 cyclicBarrier.await()之后的语句。</span>        <span class="type">CyclicBarrier</span> <span class="variable">cyclicBarrier</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">CyclicBarrier</span>(NUMBER, () -&gt; System.out.println(<span class="string">&quot;集齐7颗龙珠，可以召唤神龙了&quot;</span>));        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">1</span>; i &lt;= <span class="number">7</span>; i++) &#123;            <span class="keyword">new</span> <span class="title class_">Thread</span>(() -&gt; &#123;                System.out.println(Thread.currentThread().getName() + <span class="string">&quot; 号龙珠已收集&quot;</span>);                <span class="keyword">try</span> &#123;                    <span class="comment">// 执行 await() 方法，障碍数 +1</span>                    cyclicBarrier.await();                &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;                    <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">RuntimeException</span>(e);                &#125; <span class="keyword">catch</span> (BrokenBarrierException e) &#123;                    <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">RuntimeException</span>(e);                &#125;            &#125;, String.valueOf(i)).start();        &#125;    &#125;&#125;</code></pre><p><strong>执行结果</strong></p><pre><code class="highlight shell">5 号龙珠已收集1 号龙珠已收集4 号龙珠已收集2 号龙珠已收集6 号龙珠已收集3 号龙珠已收集7 号龙珠已收集集齐7颗龙珠，可以召唤神龙了</code></pre><h1 id="三、信号灯-Semaphore"><a href="#三、信号灯-Semaphore" class="headerlink" title="三、信号灯 Semaphore"></a>三、信号灯 Semaphore</h1><h2 id="1-概述-2"><a href="#1-概述-2" class="headerlink" title="1. 概述"></a>1. 概述</h2><p>信号量(Semaphore)，又被称为信号灯，在多线程环境下用于协调各个线程, 以保证它们能够正确、合理的使用公共资源。信号量维护了一个许可集，我们在初始化Semaphore时需要为这个许可集传入一个数量值，该数量值代表同一时间能访问共享资源的线程数量。</p><p>线程可以通过acquire()方法获取到一个许可，然后对共享资源进行操作。注意如果许可集已分配完了，那么线程将进入等待状态，直到其他线程释放许可才有机会再获取许可，线程释放一个许可通过release()方法完成，”许可”将被归还给Semaphore。</p><p><strong>具体常用的构造方法有：</strong></p><p>Semaphore(int permits) 创建具有给定的许可数和非公平的公平设置的 Semapore</p><pre><code class="highlight java"><span class="keyword">public</span> <span class="title function_">Semaphore</span><span class="params">(<span class="type">int</span> <span class="keyword">permits</span>)</span> &#123;    <span class="comment">// 默认创建非公平锁</span>    sync = <span class="keyword">new</span> <span class="title class_">NonfairSync</span>(<span class="keyword">permits</span>);&#125;<span class="keyword">public</span> <span class="title function_">Semaphore</span><span class="params">(<span class="type">int</span> <span class="keyword">permits</span>, <span class="type">boolean</span> fair)</span> &#123;    <span class="comment">// fair为true时，为公平锁</span>    sync = fair ? <span class="keyword">new</span> <span class="title class_">FairSync</span>(<span class="keyword">permits</span>) : <span class="keyword">new</span> <span class="title class_">NonfairSync</span>(<span class="keyword">permits</span>);&#125;</code></pre><p><strong>具体常用的方法有：</strong></p><p>acquire()从此信号量获取一个许可，在获取到许可前一直将线程阻塞。</p><p>release()释放一个许可，将其返回给信号量</p><pre><code class="highlight java"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">acquire</span><span class="params">()</span> <span class="keyword">throws</span> InterruptedException &#123;    <span class="comment">// 阻塞当前线程</span>    sync.acquireSharedInterruptibly(<span class="number">1</span>);&#125;<span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">release</span><span class="params">()</span> &#123;    <span class="comment">// 释放一个许可</span>    sync.releaseShared(<span class="number">1</span>);&#125;</code></pre><p>设置许可数量 <code>Semaphore semaphore = new Semaphore(3);</code></p><p><strong>一般 acquire(）都会抛出异常，release 在 finally 中执行</strong></p><h2 id="2-案例演示-2"><a href="#2-案例演示-2" class="headerlink" title="2. 案例演示"></a>2. 案例演示</h2><p>6辆汽车，停3个车位</p><pre><code class="highlight java"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">SemaphoreTest</span> &#123;    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;        <span class="comment">//创建Semaphore，设置许可数量</span>        <span class="type">Semaphore</span> <span class="variable">semaphore</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Semaphore</span>(<span class="number">3</span>);        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">1</span>; i &lt;= <span class="number">6</span>; i++) &#123;            <span class="keyword">new</span> <span class="title class_">Thread</span>(() -&gt; &#123;                <span class="keyword">try</span> &#123;                    <span class="comment">// 获取许可，在获取到前，线程阻塞</span>                    semaphore.acquire();                    System.out.println(Thread.currentThread().getName() + <span class="string">&quot; 找到了车位&quot;</span>);                    <span class="comment">// 设置停车时间</span>                    TimeUnit.SECONDS.sleep(<span class="keyword">new</span> <span class="title class_">Random</span>().nextInt(<span class="number">5</span>));                    <span class="comment">// 离开车位</span>                    System.out.println(Thread.currentThread().getName()+<span class="string">&quot;------离开了车位&quot;</span>);                &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;                    <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">RuntimeException</span>(e);                &#125; <span class="keyword">finally</span> &#123;                    <span class="comment">// 释放许可</span>                    semaphore.release();                &#125;            &#125;, <span class="string">&quot;车辆&quot;</span> + i).start();        &#125;    &#125;&#125;</code></pre><p><strong>执行结果：</strong></p><pre><code class="highlight shell">车辆1 找到了车位车辆3 找到了车位车辆2 找到了车位车辆1------离开了车位车辆4 找到了车位车辆2------离开了车位车辆5 找到了车位车辆5------离开了车位车辆6 找到了车位车辆3------离开了车位车辆6------离开了车位车辆4------离开了车位</code></pre>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;JUC 中提供了三种常用的辅助类，通过这些辅助类可以很好的解决线程数量过多时 Lock 锁的频繁操作。这三种辅助类为：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;CountDownLatch: 减少计数&lt;/li&gt;
&lt;li&gt;CyclicBarrier: 循环栅栏&lt;/li&gt;
&lt;li&gt;Semap</summary>
      
    
    
    
    <category term="JUC" scheme="https://georgechan95.github.io/categories/JUC/"/>
    
    
    <category term="juc" scheme="https://georgechan95.github.io/tags/juc/"/>
    
    <category term="java" scheme="https://georgechan95.github.io/tags/java/"/>
    
  </entry>
  
  <entry>
    <title>06-Callable &amp; Future 接口</title>
    <link href="https://georgechan95.github.io/blog/f60e37c5.html"/>
    <id>https://georgechan95.github.io/blog/f60e37c5.html</id>
    <published>2024-09-06T14:10:00.000Z</published>
    <updated>2024-09-07T02:21:37.284Z</updated>
    
    <content type="html"><![CDATA[<h1 id="一、Callable接口"><a href="#一、Callable接口" class="headerlink" title="一、Callable接口"></a>一、Callable接口</h1><p><strong>创建线程的多种方式：</strong></p><ul><li>继承Thread类</li><li>实现Runnable接口</li><li>Callable接口</li><li>线程池</li></ul><h2 id="1-Callable接口创建线程"><a href="#1-Callable接口创建线程" class="headerlink" title="1. Callable接口创建线程"></a>1. Callable接口创建线程</h2><p>目前学习了有两种创建线程的方法，一种是通过创建 Thread 类，另一种是通过使用 Runnable 创建线程，但是 Runnable 缺少的一项功能是，当线程终止时（即 run()完成时），我们无法使线程返回结果。为了支持此功能，Java 中提供了 Callable 接口</p><p><strong>比较Runnable接口和Callable接口</strong></p><ul><li>Callable 中的 call() 计算结果，如果无法计算结果，会抛出异常</li><li>Runnable 中的 run() 使用实现接口 Runnable 的对象创建一个线程时，启动该线程将导致在独立执行的线程中调用该对象的run方法总的来说：run() 没有返回值，不会抛出异常。而 call() 有返回值，会抛出异常</li></ul><p>因为Thread的构造函数中没有Callable接口的参数设置,直接替换不可以，只能用下面这种线程创建方法（找一个类，即和 Runnable 接口有关系，又和 Callable 接口有关系）, 发现 Runnable 接口有实现类 FutureTask（中间对象）, FutureTask 的构造函数有Callable参数，通过 FutureTask 创建线程对象</p><p><strong>Callable使用示例：</strong></p><pre><code class="highlight java"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">CallableTest</span> &#123;    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> ExecutionException, InterruptedException &#123;        <span class="comment">// Runable 调用线程</span>        <span class="keyword">new</span> <span class="title class_">Thread</span>(() -&gt; &#123;            System.out.println(Thread.currentThread().getName() + <span class="string">&quot;执行了run方法&quot;</span>);        &#125;, <span class="string">&quot;Runable&quot;</span>).start();        <span class="comment">// 使用Callable调用线程</span>        FutureTask&lt;String&gt; futureTask = <span class="keyword">new</span> <span class="title class_">FutureTask</span>&lt;&gt;(() -&gt; &#123;            System.out.println(Thread.currentThread().getName() +  <span class="string">&quot;执行了call方法&quot;</span>);            <span class="keyword">return</span> <span class="string">&quot;Callable的call方法返回结果&quot;</span>;        &#125;);        <span class="keyword">new</span> <span class="title class_">Thread</span>(futureTask, <span class="string">&quot;Callable&quot;</span>).start();        <span class="type">String</span> <span class="variable">result</span> <span class="operator">=</span> futureTask.get();        System.out.println(result);    &#125;&#125;</code></pre><p><strong>执行结果：</strong></p><pre><code class="highlight shell">Runable执行了run方法Callable执行了call方法Callable的call方法返回结果</code></pre><p><strong>实现Callable接口的写法</strong></p><pre><code class="highlight java"><span class="comment">//比较两个接口</span><span class="comment">//实现Runnable接口</span><span class="keyword">class</span> <span class="title class_">MyThread1</span> <span class="keyword">implements</span> <span class="title class_">Runnable</span> &#123;    <span class="meta">@Override</span>    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span> &#123;        System.out.println(Thread.currentThread().getName() + <span class="string">&quot;执行了run方法&quot;</span>);    &#125;&#125;<span class="comment">//实现Callable接口</span><span class="keyword">class</span> <span class="title class_">MyThread2</span> <span class="keyword">implements</span> <span class="title class_">Callable</span> &#123;    <span class="meta">@Override</span>    <span class="keyword">public</span> Integer <span class="title function_">call</span><span class="params">()</span> <span class="keyword">throws</span> Exception &#123;        System.out.println(Thread.currentThread().getName()+<span class="string">&quot; come in callable&quot;</span>);        <span class="keyword">return</span> <span class="number">200</span>;    &#125;&#125;<span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Demo1</span> &#123;    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> ExecutionException, InterruptedException &#123;        <span class="comment">//Runnable接口创建线程</span>        <span class="keyword">new</span> <span class="title class_">Thread</span>(<span class="keyword">new</span> <span class="title class_">MyThread1</span>(),<span class="string">&quot;MyThread1&quot;</span>).start();        <span class="comment">//Callable接口,报错，没有这个类型的构造方法</span>       <span class="comment">// new Thread(new MyThread2(),&quot;BB&quot;).start();</span>        <span class="comment">//FutureTask</span>        FutureTask&lt;Integer&gt; futureTask1 = <span class="keyword">new</span> <span class="title class_">FutureTask</span>&lt;&gt;(<span class="keyword">new</span> <span class="title class_">MyThread2</span>());        <span class="comment">//lam表达式</span>        FutureTask&lt;Integer&gt; futureTask2 = <span class="keyword">new</span> <span class="title class_">FutureTask</span>&lt;&gt;(()-&gt;&#123;            System.out.println(Thread.currentThread().getName()+<span class="string">&quot; come in callable&quot;</span>);            <span class="keyword">return</span> <span class="number">1024</span>;        &#125;);        <span class="comment">//创建一个线程</span>        <span class="keyword">new</span> <span class="title class_">Thread</span>(futureTask2,<span class="string">&quot;futureTask2&quot;</span>).start();        <span class="keyword">new</span> <span class="title class_">Thread</span>(futureTask1,<span class="string">&quot;futureTask1&quot;</span>).start();        <span class="keyword">while</span>(!futureTask2.isDone()) &#123;            System.out.println(<span class="string">&quot;futureTask2 wait.....&quot;</span>);        &#125;        <span class="comment">//调用FutureTask的get方法</span>        System.out.println(<span class="string">&quot;futureTask2结果：&quot;</span> + futureTask2.get());        System.out.println(<span class="string">&quot;futureTask1结果：&quot;</span> + futureTask1.get());        System.out.println(Thread.currentThread().getName()+<span class="string">&quot; come over&quot;</span>);    &#125;&#125;</code></pre><p><strong>执行结果：</strong></p><pre><code class="highlight shell">futureTask2 wait.....futureTask2 wait.....MyThread1执行了run方法futureTask2 wait.....futureTask1 come in callablefutureTask2 come in callablefutureTask2 wait.....futureTask2 wait.....futureTask2结果：1024futureTask1结果：200main come over</code></pre><h2 id="2-Future-接口"><a href="#2-Future-接口" class="headerlink" title="2. Future 接口"></a>2. Future 接口</h2><p>当 call（）方法完成时，结果必须存储在主线程已知的对象中，以便主线程可以知道该线程返回的结果。为此，可以使用 Future 对象。</p><p>将 Future 视为保存结果的对象–它可能暂时不保存结果，但将来会保存（一旦Callable 返回）。Future 基本上是主线程可以跟踪进度以及其他线程的结果的一种方式。要实现此接口，必须重写 5 种方法，这里列出了重要的方法,如下:</p><ul><li><p><strong>public boolean cancel (boolean mayInterruptIfRunning)</strong> 用于停止任务。</p><p>如果尚未启动，它将停止任务。如果已启动，则仅在 mayInterruptIfRunning 为 true时才会中断任务。</p></li><li><p><strong>public boolean isCancelled()</strong></p><p>观察任务是否取消成功</p></li><li><p><strong>public V get() throws InterruptedException, ExecutionException</strong> 用于获取任务的结果。</p><p>如果任务完成，它将立即返回结果，否则将等待任务完成，然后返回结果。</p></li><li><p><strong>public V get(long timeout, TimeUnit unit) throws InterruptedException, ExecutionException, TimeoutException</strong></p><p>在指定时间内尝试获取执行结果，若超时则抛出超时异常</p></li><li><p><strong>public boolean isDone()</strong> 如果任务完成，则返回 true，否则返回 false</p></li></ul><p><strong>使用示例：</strong></p><pre><code class="highlight java"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">FutureTest</span> &#123;    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception &#123;        <span class="comment">// 创建一个线程池</span>        <span class="type">ExecutorService</span> <span class="variable">executor</span> <span class="operator">=</span> Executors.newFixedThreadPool(<span class="number">1</span>);        <span class="comment">// 初始化一个任务</span>        Callable&lt;String&gt; task = <span class="keyword">new</span> <span class="title class_">Task</span>();        <span class="comment">// 提交任务并获得Future的实例</span>        Future&lt;String&gt; future = executor.submit(task);        <span class="comment">// 从Future获取异步执行返回的结果(可能会阻塞等待结果)</span>        <span class="type">String</span> <span class="variable">result</span> <span class="operator">=</span>future.get();        System.out.println(<span class="string">&quot;任务执行结果：&quot;</span> +  result);        <span class="comment">// 任务执行完毕之后，关闭线程池（可选）</span>        executor.shutdown();    &#125;&#125;<span class="keyword">class</span> <span class="title class_">Task</span> <span class="keyword">implements</span> <span class="title class_">Callable</span>&lt;String&gt; &#123;    <span class="meta">@Override</span>    <span class="keyword">public</span> String <span class="title function_">call</span><span class="params">()</span> <span class="keyword">throws</span> Exception &#123;        <span class="comment">// 执行下载某文件任务，并返回文件名称</span>        System.out.println(<span class="string">&quot;thread name:&quot;</span> +  Thread.currentThread().getName() + <span class="string">&quot; 开始执行下载任务&quot;</span>);        <span class="keyword">return</span> <span class="string">&quot;xxx.png&quot;</span>;    &#125;&#125;</code></pre><p><strong>执行结果：</strong></p><pre><code class="highlight shell">thread name:pool-1-thread-1 开始执行下载任务任务执行结果：xxx.png</code></pre><p>多次调用 <code>future.get()</code> 方法，<code>call()</code> 方法中的打印语句不会重复执行，直接返回了结果，因为 Future 在第一次调用 get() 方法时缓存了结果。</p><h1 id="二、FutureTask"><a href="#二、FutureTask" class="headerlink" title="二、FutureTask"></a>二、FutureTask</h1><p>Java 库具有具体的 FutureTask 类型，该类型实现 Runnable 和 Future，并方便地将两种功能组合在一起。 可以通过为其构造函数提供 Callable 来创建FutureTask。然后，将 FutureTask 对象提供给 Thread 的构造函数以创建Thread 对象。因此，间接地使用 Callable 创建线程。</p><p><strong>核心原理:(重点)</strong></p><p>在主线程中需要执行比较耗时的操作时，但又不想阻塞主线程时，可以把这些作业交给 Future 对象在后台完成</p><ul><li>当主线程将来需要时，就可以通过 Future 对象获得后台作业的计算结果或者执行状态</li><li>一般 FutureTask 多用于耗时的计算，主线程可以在完成自己的任务后，再去获取结果。</li><li>仅在计算完成时才能检索结果；如果计算尚未完成，则阻塞 get 方法</li><li>一旦计算完成，就不能再重新开始或取消计算</li><li>get 方法而获取结果只有在计算完成时获取，否则会一直阻塞直到任务转入完成状态，然后会返回结果或者抛出异常</li><li>get 只计算一次,因此 get 方法放到最后</li></ul><p><strong>总结：</strong></p><ul><li>在主线程中需要执行比较耗时的操作时，但又不想阻塞主线程时，可以把这些作业交给 Future 对象在后台完成, 当主线程将来需要时，就可以通过 Future对象获得后台作业的计算结果或者执行状态</li><li>一般 FutureTask 多用于耗时的计算，主线程可以在完成自己的任务后，再去获取结果</li><li>仅在计算完成时才能检索结果；如果计算尚未完成，则阻塞 get 方法。一旦计算完成，就不能再重新开始或取消计算。get 方法而获取结果只有在计算完成时获取，否则会一直阻塞直到任务转入完成状态，然后会返回结果或者抛出异常。</li><li>只计算一次</li></ul>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;一、Callable接口&quot;&gt;&lt;a href=&quot;#一、Callable接口&quot; class=&quot;headerlink&quot; title=&quot;一、Callable接口&quot;&gt;&lt;/a&gt;一、Callable接口&lt;/h1&gt;&lt;p&gt;&lt;strong&gt;创建线程的多种方式：&lt;/strong&gt;&lt;/p</summary>
      
    
    
    
    <category term="JUC" scheme="https://georgechan95.github.io/categories/JUC/"/>
    
    
    <category term="juc" scheme="https://georgechan95.github.io/tags/juc/"/>
    
    <category term="java" scheme="https://georgechan95.github.io/tags/java/"/>
    
  </entry>
  
  <entry>
    <title>05-公平锁和非公平锁，死锁，可重入锁</title>
    <link href="https://georgechan95.github.io/blog/f184587f.html"/>
    <id>https://georgechan95.github.io/blog/f184587f.html</id>
    <published>2024-09-05T12:12:00.000Z</published>
    <updated>2024-09-06T01:55:57.616Z</updated>
    
    <content type="html"><![CDATA[<h1 id="一、synchronized-锁的8种情况"><a href="#一、synchronized-锁的8种情况" class="headerlink" title="一、synchronized 锁的8种情况"></a>一、synchronized 锁的8种情况</h1><p>下面通过一段代码，演示 synchronized 锁的 8 种情况</p><ol><li><p>标准访问，先打印短信还是邮件</p><pre><code class="highlight java"><span class="keyword">class</span> <span class="title class_">Phone</span> &#123;    <span class="keyword">public</span> <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title function_">sendSMS</span><span class="params">()</span> <span class="keyword">throws</span> Exception &#123;        System.out.println(<span class="string">&quot;------sendSMS&quot;</span>);    &#125;    <span class="keyword">public</span> <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title function_">sendEmail</span><span class="params">()</span> <span class="keyword">throws</span> Exception &#123;        System.out.println(<span class="string">&quot;------sendEmail&quot;</span>);    &#125;&#125;<span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Lock_8</span> &#123;    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception &#123;        <span class="type">Phone</span> <span class="variable">phone</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Phone</span>();        <span class="keyword">new</span> <span class="title class_">Thread</span>(() -&gt; &#123;            <span class="keyword">try</span> &#123;                phone.sendSMS();            &#125; <span class="keyword">catch</span> (Exception e) &#123;                e.printStackTrace();            &#125;        &#125;, <span class="string">&quot;AA&quot;</span>).start();        Thread.sleep(<span class="number">100</span>);        <span class="keyword">new</span> <span class="title class_">Thread</span>(() -&gt; &#123;            <span class="keyword">try</span> &#123;                phone.sendEmail();            &#125; <span class="keyword">catch</span> (Exception e) &#123;                e.printStackTrace();            &#125;        &#125;, <span class="string">&quot;BB&quot;</span>).start();    &#125;&#125;</code></pre><p>打印结果：</p><pre><code class="highlight shell">------sendSMS------sendEmail</code></pre><p>分析：两个方法都加了 synchronized 关键字，因为是同一个对象调用，所有是同一把锁，按照顺序执行。</p></li><li><p>停4秒在短信方法内，先打印短信还是邮件</p><pre><code class="highlight java"><span class="keyword">class</span> <span class="title class_">Phone</span> &#123;    <span class="keyword">public</span> <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title function_">sendSMS</span><span class="params">()</span> <span class="keyword">throws</span> Exception &#123;        <span class="comment">//停留4秒</span>        TimeUnit.SECONDS.sleep(<span class="number">4</span>);        System.out.println(<span class="string">&quot;------sendSMS&quot;</span>);    &#125;    <span class="keyword">public</span> <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title function_">sendEmail</span><span class="params">()</span> <span class="keyword">throws</span> Exception &#123;        System.out.println(<span class="string">&quot;------sendEmail&quot;</span>);    &#125;&#125;<span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Lock_8</span> &#123;    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception &#123;        <span class="type">Phone</span> <span class="variable">phone</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Phone</span>();        <span class="keyword">new</span> <span class="title class_">Thread</span>(() -&gt; &#123;            <span class="keyword">try</span> &#123;                phone.sendSMS();            &#125; <span class="keyword">catch</span> (Exception e) &#123;                e.printStackTrace();            &#125;        &#125;, <span class="string">&quot;AA&quot;</span>).start();        Thread.sleep(<span class="number">100</span>);        <span class="keyword">new</span> <span class="title class_">Thread</span>(() -&gt; &#123;            <span class="keyword">try</span> &#123;                phone.sendEmail();            &#125; <span class="keyword">catch</span> (Exception e) &#123;                e.printStackTrace();            &#125;        &#125;, <span class="string">&quot;BB&quot;</span>).start();    &#125;&#125;</code></pre><p>打印结果：</p><pre><code class="highlight shell">------sendSMS------sendEmail</code></pre><p>分析：两个方法都加了 synchronized 关键字，因为还是同一个对象调用，所有还是同一把锁，先拿到锁的方法执行结束后，另一个方法才能执行。</p></li><li><p>新增普通的hello方法，是先打短信还是hello</p><pre><code class="highlight java"><span class="keyword">class</span> <span class="title class_">Phone</span> &#123;    <span class="keyword">public</span> <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title function_">sendSMS</span><span class="params">()</span> <span class="keyword">throws</span> Exception &#123;        <span class="comment">//停留4秒</span>        TimeUnit.SECONDS.sleep(<span class="number">4</span>);        System.out.println(<span class="string">&quot;------sendSMS&quot;</span>);    &#125;    <span class="keyword">public</span> <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title function_">sendEmail</span><span class="params">()</span> <span class="keyword">throws</span> Exception &#123;        System.out.println(<span class="string">&quot;------sendEmail&quot;</span>);    &#125;    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">getHello</span><span class="params">()</span> &#123;        System.out.println(<span class="string">&quot;------getHello&quot;</span>);    &#125;&#125;<span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Lock_8</span> &#123;    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception &#123;        <span class="type">Phone</span> <span class="variable">phone</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Phone</span>();        <span class="keyword">new</span> <span class="title class_">Thread</span>(() -&gt; &#123;            <span class="keyword">try</span> &#123;                phone.sendSMS();            &#125; <span class="keyword">catch</span> (Exception e) &#123;                e.printStackTrace();            &#125;        &#125;, <span class="string">&quot;AA&quot;</span>).start();        Thread.sleep(<span class="number">100</span>);        <span class="keyword">new</span> <span class="title class_">Thread</span>(() -&gt; &#123;            <span class="keyword">try</span> &#123;                phone.getHello();            &#125; <span class="keyword">catch</span> (Exception e) &#123;                e.printStackTrace();            &#125;        &#125;, <span class="string">&quot;BB&quot;</span>).start();    &#125;&#125;</code></pre><p>打印结果：</p><pre><code class="highlight shell">------getHello------sendSMS</code></pre><p>分析：hello方法没有加锁，调用即执行，sendSMS有sleep阻塞。</p></li><li><p>现在有两部手机，先打印短信还是邮件</p><pre><code class="highlight java"><span class="keyword">class</span> <span class="title class_">Phone</span> &#123;    <span class="keyword">public</span> <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title function_">sendSMS</span><span class="params">()</span> <span class="keyword">throws</span> Exception &#123;        <span class="comment">//停留4秒</span>        TimeUnit.SECONDS.sleep(<span class="number">4</span>);        System.out.println(<span class="string">&quot;------sendSMS&quot;</span>);    &#125;    <span class="keyword">public</span> <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title function_">sendEmail</span><span class="params">()</span> <span class="keyword">throws</span> Exception &#123;        System.out.println(<span class="string">&quot;------sendEmail&quot;</span>);    &#125;&#125;<span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Lock_8</span> &#123;    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception &#123;        <span class="type">Phone</span> <span class="variable">phone</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Phone</span>();        <span class="type">Phone</span> <span class="variable">phone2</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Phone</span>();        <span class="keyword">new</span> <span class="title class_">Thread</span>(() -&gt; &#123;            <span class="keyword">try</span> &#123;                phone.sendSMS();            &#125; <span class="keyword">catch</span> (Exception e) &#123;                e.printStackTrace();            &#125;        &#125;, <span class="string">&quot;AA&quot;</span>).start();        Thread.sleep(<span class="number">100</span>);        <span class="keyword">new</span> <span class="title class_">Thread</span>(() -&gt; &#123;            <span class="keyword">try</span> &#123;                phone2.sendEmail();            &#125; <span class="keyword">catch</span> (Exception e) &#123;                e.printStackTrace();            &#125;        &#125;, <span class="string">&quot;BB&quot;</span>).start();    &#125;&#125;</code></pre><p>打印结果：</p><pre><code class="highlight shell">------sendEmail------sendSMS</code></pre><p>分析：synchronized 在方法上，是方法级的锁，由于是两个 phone 对象调用不同的方法，所以 sendSMS() 和 sendEmail() 持有的是不同的锁，互不影响。</p></li><li><p>两个静态同步方法，1部手机，先打印短信还是邮件</p><pre><code class="highlight java"><span class="keyword">class</span> <span class="title class_">Phone</span> &#123;    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title function_">sendSMS</span><span class="params">()</span> <span class="keyword">throws</span> Exception &#123;        <span class="comment">//停留4秒</span>        TimeUnit.SECONDS.sleep(<span class="number">4</span>);        System.out.println(<span class="string">&quot;------sendSMS&quot;</span>);    &#125;    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title function_">sendEmail</span><span class="params">()</span> <span class="keyword">throws</span> Exception &#123;        System.out.println(<span class="string">&quot;------sendEmail&quot;</span>);    &#125;&#125;<span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Lock_8</span> &#123;    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception &#123;        <span class="type">Phone</span> <span class="variable">phone</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Phone</span>();                <span class="keyword">new</span> <span class="title class_">Thread</span>(() -&gt; &#123;            <span class="keyword">try</span> &#123;                phone.sendSMS();            &#125; <span class="keyword">catch</span> (Exception e) &#123;                e.printStackTrace();            &#125;        &#125;, <span class="string">&quot;AA&quot;</span>).start();        Thread.sleep(<span class="number">100</span>);        <span class="keyword">new</span> <span class="title class_">Thread</span>(() -&gt; &#123;            <span class="keyword">try</span> &#123;                phone.sendEmail();            &#125; <span class="keyword">catch</span> (Exception e) &#123;                e.printStackTrace();            &#125;        &#125;, <span class="string">&quot;BB&quot;</span>).start();    &#125;&#125;</code></pre><p>打印结果：</p><pre><code class="highlight shell">------sendSMS------sendEmail</code></pre><p>分析：synchronized 在静态方法上，是类级别的锁，所以两个方法持有的是同一把锁，要按顺序执行</p></li><li><p>两个静态同步方法，2部手机，先打印短信还是邮件</p><pre><code class="highlight java"><span class="keyword">class</span> <span class="title class_">Phone</span> &#123;    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title function_">sendSMS</span><span class="params">()</span> <span class="keyword">throws</span> Exception &#123;        <span class="comment">//停留4秒</span>        TimeUnit.SECONDS.sleep(<span class="number">4</span>);        System.out.println(<span class="string">&quot;------sendSMS&quot;</span>);    &#125;    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title function_">sendEmail</span><span class="params">()</span> <span class="keyword">throws</span> Exception &#123;        System.out.println(<span class="string">&quot;------sendEmail&quot;</span>);    &#125;&#125;<span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Lock_8</span> &#123;    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception &#123;        <span class="type">Phone</span> <span class="variable">phone</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Phone</span>();        <span class="type">Phone</span> <span class="variable">phone2</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Phone</span>();        <span class="keyword">new</span> <span class="title class_">Thread</span>(() -&gt; &#123;            <span class="keyword">try</span> &#123;                phone.sendSMS();            &#125; <span class="keyword">catch</span> (Exception e) &#123;                e.printStackTrace();            &#125;        &#125;, <span class="string">&quot;AA&quot;</span>).start();        Thread.sleep(<span class="number">100</span>);        <span class="keyword">new</span> <span class="title class_">Thread</span>(() -&gt; &#123;            <span class="keyword">try</span> &#123;                phone2.sendEmail();            &#125; <span class="keyword">catch</span> (Exception e) &#123;                e.printStackTrace();            &#125;        &#125;, <span class="string">&quot;BB&quot;</span>).start();    &#125;&#125;</code></pre><p>打印结果：</p><pre><code class="highlight shell">------sendSMS------sendEmail</code></pre><p>分析：synchronized 在静态方法上，是类级别的锁，所以两个方法持有的是同一把锁，要按顺序执行</p></li><li><p>1个静态同步方法,1个普通同步方法，1部手机，先打印短信还是邮件</p><pre><code class="highlight java"><span class="keyword">class</span> <span class="title class_">Phone</span> &#123;    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title function_">sendSMS</span><span class="params">()</span> <span class="keyword">throws</span> Exception &#123;        <span class="comment">//停留4秒</span>        TimeUnit.SECONDS.sleep(<span class="number">4</span>);        System.out.println(<span class="string">&quot;------sendSMS&quot;</span>);    &#125;    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">getHello</span><span class="params">()</span> &#123;        System.out.println(<span class="string">&quot;------getHello&quot;</span>);    &#125;&#125;<span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Lock_8</span> &#123;    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception &#123;        <span class="type">Phone</span> <span class="variable">phone</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Phone</span>();        <span class="keyword">new</span> <span class="title class_">Thread</span>(() -&gt; &#123;            <span class="keyword">try</span> &#123;                phone.sendSMS();            &#125; <span class="keyword">catch</span> (Exception e) &#123;                e.printStackTrace();            &#125;        &#125;, <span class="string">&quot;AA&quot;</span>).start();        Thread.sleep(<span class="number">100</span>);        <span class="keyword">new</span> <span class="title class_">Thread</span>(() -&gt; &#123;            <span class="keyword">try</span> &#123;                phone.getHello();            &#125; <span class="keyword">catch</span> (Exception e) &#123;                e.printStackTrace();            &#125;        &#125;, <span class="string">&quot;BB&quot;</span>).start();    &#125;&#125;</code></pre><p>打印结果：</p><pre><code class="highlight shell">------getHello------sendSMS</code></pre><p>分析：类加锁对普通方法无限制，普通方法调用即执行。</p></li><li><p>1个静态同步方法,1个普通同步方法，2部手机，先打印短信还是邮件</p><pre><code class="highlight java"><span class="keyword">class</span> <span class="title class_">Phone</span> &#123;    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title function_">sendSMS</span><span class="params">()</span> <span class="keyword">throws</span> Exception &#123;        <span class="comment">//停留4秒</span>        TimeUnit.SECONDS.sleep(<span class="number">4</span>);        System.out.println(<span class="string">&quot;------sendSMS&quot;</span>);    &#125;    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">sendEmail</span><span class="params">()</span> <span class="keyword">throws</span> Exception &#123;        System.out.println(<span class="string">&quot;------sendEmail&quot;</span>);    &#125;&#125;<span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Lock_8</span> &#123;    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception &#123;        <span class="type">Phone</span> <span class="variable">phone</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Phone</span>();        <span class="type">Phone</span> <span class="variable">phone2</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Phone</span>();        <span class="keyword">new</span> <span class="title class_">Thread</span>(() -&gt; &#123;            <span class="keyword">try</span> &#123;                phone.sendSMS();            &#125; <span class="keyword">catch</span> (Exception e) &#123;                e.printStackTrace();            &#125;        &#125;, <span class="string">&quot;AA&quot;</span>).start();        Thread.sleep(<span class="number">100</span>);        <span class="keyword">new</span> <span class="title class_">Thread</span>(() -&gt; &#123;            <span class="keyword">try</span> &#123;                phone2.sendEmail();            &#125; <span class="keyword">catch</span> (Exception e) &#123;                e.printStackTrace();            &#125;        &#125;, <span class="string">&quot;BB&quot;</span>).start();    &#125;&#125;</code></pre><p>打印结果：</p><pre><code class="highlight shell">------sendEmail------sendSMS</code></pre><p>分析：类加锁对普通方法无限制，普通方法调用即执行。</p></li></ol><p><strong>总结：</strong></p><ul><li>synchronized 锁的是方法，则是对象锁，同个对象锁的机制要等待，不同对象锁的机制调用同一个不用等待</li><li>加了static则为class锁而不是对象锁</li><li>对于同步方法块，锁是 synchronized 括号里配置对象</li></ul><h1 id="二、公平锁和非公平锁"><a href="#二、公平锁和非公平锁" class="headerlink" title="二、公平锁和非公平锁"></a>二、公平锁和非公平锁</h1><ul><li><strong>公平锁</strong>：效率相对低 ，但是cpu 的利用高了</li><li><strong>非公平锁</strong>：效率高，但是线程容易饿死（所有的工作，有一个线程完成）</li></ul><p><strong>用法：</strong> 在创建可重入锁时，向构造器中传入true</p><pre><code class="highlight java"><span class="keyword">private</span> <span class="keyword">final</span> <span class="type">ReentrantLock</span> <span class="variable">lock</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ReentrantLock</span>(<span class="literal">true</span>);</code></pre><p>因为 ReentrantLock 的构造器源码如下：</p><pre><code class="highlight java"><span class="comment">/**</span><span class="comment"> * Creates an instance of &#123;<span class="doctag">@code</span> ReentrantLock&#125;.</span><span class="comment"> * This is equivalent to using &#123;<span class="doctag">@code</span> ReentrantLock(false)&#125;.</span><span class="comment"> */</span><span class="keyword">public</span> <span class="title function_">ReentrantLock</span><span class="params">()</span> &#123;    sync = <span class="keyword">new</span> <span class="title class_">NonfairSync</span>();&#125;<span class="comment">/**</span><span class="comment"> * Creates an instance of &#123;<span class="doctag">@code</span> ReentrantLock&#125; with the</span><span class="comment"> * given fairness policy.</span><span class="comment"> *</span><span class="comment"> * <span class="doctag">@param</span> fair &#123;<span class="doctag">@code</span> true&#125; if this lock should use a fair ordering policy</span><span class="comment"> */</span><span class="keyword">public</span> <span class="title function_">ReentrantLock</span><span class="params">(<span class="type">boolean</span> fair)</span> &#123;    sync = fair ? <span class="keyword">new</span> <span class="title class_">FairSync</span>() : <span class="keyword">new</span> <span class="title class_">NonfairSync</span>();&#125;</code></pre><h1 id="三、可重入锁"><a href="#三、可重入锁" class="headerlink" title="三、可重入锁"></a>三、可重入锁</h1><p><code>synchronized</code> 和 <code>lock</code> 都是可重入锁</p><ul><li>sychronized是隐式锁，不用手工上锁与解锁，而lock为显示锁，需要手工上锁与解锁</li><li>可重入锁也叫递归锁</li></ul><p>而且有了可重入锁之后，在拿到外层的第一把锁之后就可以一直进入到内层结构</p><p><strong>嵌套实现代码 他能进入下一个锁内而不会出现死锁</strong></p><p><strong>synchronized的示例代码</strong></p><pre><code class="highlight java"><span class="comment">/**</span><span class="comment"> * 演示可重入锁是什么意思，可重入，就是可以重复获取相同的锁而不会出现死锁</span><span class="comment"> * synchronized和ReentrantLock都是可重入的</span><span class="comment"> * */</span><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">WhatReentrantSynchronized</span> &#123;    <span class="comment">// 创建一个锁对象</span>    <span class="keyword">static</span> <span class="type">Object</span> <span class="variable">mylock</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Object</span>();    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;        <span class="keyword">new</span> <span class="title class_">Thread</span>(()-&gt;&#123;            <span class="comment">// 创建第一个锁</span>            <span class="keyword">synchronized</span> (mylock)&#123;                System.out.println(<span class="string">&quot;这是第一层锁&quot;</span>);                <span class="keyword">synchronized</span> (mylock)&#123;                    System.out.println(<span class="string">&quot;这是第二层锁&quot;</span>);                &#125;            &#125;        &#125;).start();    &#125;&#125;</code></pre><p>打印结果：</p><pre><code class="highlight shell">这是第一层锁这是第二层锁</code></pre><p><strong>ReentrantLock的示例代码</strong></p><pre><code class="highlight java"><span class="comment">/**</span><span class="comment"> * lock和unlock的数量必须一致，否则会出现死锁</span><span class="comment"> * */</span><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">WhatReentrantLock</span> &#123;    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;        <span class="type">ReentrantLock</span> <span class="variable">lock</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ReentrantLock</span>();        <span class="keyword">new</span> <span class="title class_">Thread</span>(() -&gt; &#123;            lock.lock();            <span class="keyword">try</span> &#123;                System.out.println(Thread.currentThread().getName() + <span class="string">&quot; 获取到第一把锁&quot;</span>);                lock.lock();                <span class="keyword">try</span> &#123;                    System.out.println(Thread.currentThread().getName() + <span class="string">&quot; 获取到第二把锁&quot;</span>);                &#125; <span class="keyword">finally</span> &#123;                    lock.unlock();                &#125;            &#125; <span class="keyword">finally</span> &#123;                lock.unlock();            &#125;        &#125;).start();    &#125;&#125;</code></pre><p><strong>打印结果</strong></p><pre><code class="highlight shell">Thread-0 获取到第一把锁Thread-0 获取到第二把锁</code></pre><h1 id="四、死锁"><a href="#四、死锁" class="headerlink" title="四、死锁"></a>四、死锁</h1><p><strong>两个或以上的进程因为争夺资源而造成互相等待资源的现象称为死锁</strong></p><p><img src="https://raw.githubusercontent.com/GeorgeChan95/blogimg/master/img/2024/09/06/20240906-093325.png" alt="死锁"></p><p><strong>产生死锁的原因：</strong></p><ol><li>系统资源不足</li><li>系统资源分配不当</li><li>进程运行顺序不当</li></ol><p><strong>我们有时候不知道是否是死锁 。那么怎么来验证呢？ （电脑配置的有环境变量，在命令窗口）</strong></p><ol><li>jps 类似于linux中的 <code>ps -ef</code>查看进程号</li><li>jstack 自带的堆栈跟踪工具</li></ol><p><strong>具体死锁的操作代码实列</strong></p><pre><code class="highlight java"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">DeadLock</span> &#123;    <span class="comment">//创建两个对象</span>    <span class="keyword">static</span> <span class="type">Object</span> <span class="variable">a</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Object</span>();    <span class="keyword">static</span> <span class="type">Object</span> <span class="variable">b</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Object</span>();    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;        <span class="keyword">new</span> <span class="title class_">Thread</span>(()-&gt;&#123;            <span class="keyword">synchronized</span> (a) &#123;                System.out.println(Thread.currentThread().getName()+<span class="string">&quot; 持有锁a，试图获取锁b&quot;</span>);                <span class="keyword">try</span> &#123;                    TimeUnit.SECONDS.sleep(<span class="number">1</span>);                &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;                    e.printStackTrace();                &#125;                <span class="keyword">synchronized</span> (b) &#123;                    System.out.println(Thread.currentThread().getName()+<span class="string">&quot; 获取锁b&quot;</span>);                &#125;            &#125;        &#125;,<span class="string">&quot;A&quot;</span>).start();        <span class="keyword">new</span> <span class="title class_">Thread</span>(()-&gt;&#123;            <span class="keyword">synchronized</span> (b) &#123;                System.out.println(Thread.currentThread().getName()+<span class="string">&quot; 持有锁b，试图获取锁a&quot;</span>);                <span class="keyword">try</span> &#123;                    TimeUnit.SECONDS.sleep(<span class="number">1</span>);                &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;                    e.printStackTrace();                &#125;                <span class="keyword">synchronized</span> (a) &#123;                    System.out.println(Thread.currentThread().getName()+<span class="string">&quot; 获取锁a&quot;</span>);                &#125;            &#125;        &#125;,<span class="string">&quot;B&quot;</span>).start();    &#125;&#125;</code></pre><p>运行程序，结果如下：</p><pre><code class="highlight shell">A 持有锁a，试图获取锁bB 持有锁b，试图获取锁a</code></pre><p>程序处于暂停状态</p><p><strong>使用 jstack 查看线程的情况</strong></p><pre><code class="highlight shell">PS E:\testWorkspace\juc-demo&gt; jps -l 69860 sun.tools.jps.Jps51436 com.atguigu.sync.DeadLock<span class="meta prompt_"># </span><span class="language-bash">当前执行的线程是 51436</span><span class="meta prompt_"></span><span class="meta prompt_"># </span><span class="language-bash">使用jstack 查看线程信息</span>PS E:\testWorkspace\juc-demo&gt; jstack 514362024-09-06 09:48:06Full thread dump Java HotSpot(TM) 64-Bit Server VM (17.0.11+7-LTS-207 mixed mode, sharing):Threads class SMR info:_java_thread_list=0x000001f8fc26e0c0, length=15, elements=&#123;0x000001f8b9f86ff0, 0x000001f8b9f87e70, 0x000001f8b9f9b8c0, 0x000001f8b9f9f2a0,0x000001f8b9f9fc60, 0x000001f8b9fa1630, 0x000001f8b9fa23d0, 0x000001f8b9fb37d0,0x000001f8b9fabf10, 0x000001f8b9f75300, 0x000001f8fc278d40, 0x000001f8fc279220,0x000001f8fc296e80, 0x000001f8fc29c1b0, 0x000001f88d7a7660&#125;&quot;Reference Handler&quot; #2 daemon prio=10 os_prio=2 cpu=0.00ms elapsed=196.10s tid=0x000001f8b9f86ff0 nid=0x10408 waiting on condition  [0x0000006af2dff000]   java.lang.Thread.State: RUNNABLE        at java.lang.ref.Reference.waitForReferencePendingList(java.base@17.0.11/Native Method)        at java.lang.ref.Reference.processPendingReferences(java.base@17.0.11/Reference.java:253)        at java.lang.ref.Reference$ReferenceHandler.run(java.base@17.0.11/Reference.java:215)&quot;Finalizer&quot; #3 daemon prio=8 os_prio=1 cpu=0.00ms elapsed=196.10s tid=0x000001f8b9f87e70 nid=0x9508 in Object.wait()  [0x0000006af2eff000]   java.lang.Thread.State: WAITING (on object monitor)        at java.lang.Object.wait(java.base@17.0.11/Native Method)        - waiting on &lt;0x000000062280d5d0&gt; (a java.lang.ref.ReferenceQueue$Lock)        at java.lang.ref.ReferenceQueue.remove(java.base@17.0.11/ReferenceQueue.java:155)        - locked &lt;0x000000062280d5d0&gt; (a java.lang.ref.ReferenceQueue$Lock)        at java.lang.ref.ReferenceQueue.remove(java.base@17.0.11/ReferenceQueue.java:176)        at java.lang.ref.Finalizer$FinalizerThread.run(java.base@17.0.11/Finalizer.java:172)&quot;Signal Dispatcher&quot; #4 daemon prio=9 os_prio=2 cpu=0.00ms elapsed=196.09s tid=0x000001f8b9f9b8c0 nid=0x11780 waiting on condition  [0x0000000000000000]   java.lang.Thread.State: RUNNABLE&quot;Attach Listener&quot; #5 daemon prio=5 os_prio=2 cpu=0.00ms elapsed=196.09s tid=0x000001f8b9f9f2a0 nid=0x11468 waiting on condition  [0x0000000000000000]   java.lang.Thread.State: RUNNABLE&quot;Service Thread&quot; #6 daemon prio=9 os_prio=0 cpu=0.00ms elapsed=196.09s tid=0x000001f8b9f9fc60 nid=0x10d90 runnable  [0x0000000000000000]   java.lang.Thread.State: RUNNABLE&quot;Monitor Deflation Thread&quot; #7 daemon prio=9 os_prio=0 cpu=0.00ms elapsed=196.09s tid=0x000001f8b9fa1630 nid=0x116e0 runnable  [0x0000000000000000]   java.lang.Thread.State: RUNNABLE&quot;C2 CompilerThread0&quot; #8 daemon prio=9 os_prio=2 cpu=0.00ms elapsed=196.09s tid=0x000001f8b9fa23d0 nid=0xb2f8 waiting on condition  [0x0000000000000000]   java.lang.Thread.State: RUNNABLE   No compile task&quot;C1 CompilerThread0&quot; #16 daemon prio=9 os_prio=2 cpu=0.00ms elapsed=196.09s tid=0x000001f8b9fb37d0 nid=0x11040 waiting on condition  [0x0000000000000000]   java.lang.Thread.State: RUNNABLE   No compile task&quot;Sweeper thread&quot; #20 daemon prio=9 os_prio=2 cpu=0.00ms elapsed=196.09s tid=0x000001f8b9fabf10 nid=0x11170 runnable  [0x0000000000000000]   java.lang.Thread.State: RUNNABLE&quot;Common-Cleaner&quot; #21 daemon prio=8 os_prio=1 cpu=0.00ms elapsed=196.09s tid=0x000001f8b9f75300 nid=0x10a7c in Object.wait()  [0x0000006af36fe000]   java.lang.Thread.State: TIMED_WAITING (on object monitor)        at java.lang.Object.wait(java.base@17.0.11/Native Method)        - waiting on &lt;0x00000006229199a8&gt; (a java.lang.ref.ReferenceQueue$Lock)        at java.lang.ref.ReferenceQueue.remove(java.base@17.0.11/ReferenceQueue.java:155)        - locked &lt;0x00000006229199a8&gt; (a java.lang.ref.ReferenceQueue$Lock)        at jdk.internal.ref.CleanerImpl.run(java.base@17.0.11/CleanerImpl.java:140)        at java.lang.Thread.run(java.base@17.0.11/Thread.java:842)        at jdk.internal.misc.InnocuousThread.run(java.base@17.0.11/InnocuousThread.java:162)&quot;Monitor Ctrl-Break&quot; #22 daemon prio=5 os_prio=0 cpu=0.00ms elapsed=196.07s tid=0x000001f8fc278d40 nid=0x11118 runnable  [0x0000006af3bfe000]   java.lang.Thread.State: RUNNABLE        at sun.nio.ch.SocketDispatcher.read0(java.base@17.0.11/Native Method)        at sun.nio.ch.SocketDispatcher.read(java.base@17.0.11/SocketDispatcher.java:46)        at sun.nio.ch.NioSocketImpl.tryRead(java.base@17.0.11/NioSocketImpl.java:266)        at sun.nio.ch.NioSocketImpl.implRead(java.base@17.0.11/NioSocketImpl.java:317)        at sun.nio.ch.NioSocketImpl.read(java.base@17.0.11/NioSocketImpl.java:355)        at sun.nio.ch.NioSocketImpl$1.read(java.base@17.0.11/NioSocketImpl.java:808)        at java.net.Socket$SocketInputStream.read(java.base@17.0.11/Socket.java:966)        at sun.nio.cs.StreamDecoder.readBytes(java.base@17.0.11/StreamDecoder.java:270)        at sun.nio.cs.StreamDecoder.implRead(java.base@17.0.11/StreamDecoder.java:313)        at sun.nio.cs.StreamDecoder.read(java.base@17.0.11/StreamDecoder.java:188)        - locked &lt;0x0000000622afa510&gt; (a java.io.InputStreamReader)        at java.io.InputStreamReader.read(java.base@17.0.11/InputStreamReader.java:177)        at java.io.BufferedReader.fill(java.base@17.0.11/BufferedReader.java:162)        at java.io.BufferedReader.readLine(java.base@17.0.11/BufferedReader.java:329)        - locked &lt;0x0000000622afa510&gt; (a java.io.InputStreamReader)        at java.io.BufferedReader.readLine(java.base@17.0.11/BufferedReader.java:396)        at com.intellij.rt.execution.application.AppMainV2$1.run(AppMainV2.java:53)&quot;Notification Thread&quot; #23 daemon prio=9 os_prio=0 cpu=0.00ms elapsed=196.07s tid=0x000001f8fc279220 nid=0xbde4 runnable  [0x0000000000000000]   java.lang.Thread.State: RUNNABLE&quot;A&quot; #24 prio=5 os_prio=0 cpu=0.00ms elapsed=196.07s tid=0x000001f8fc296e80 nid=0x10308 waiting for monitor entry  [0x0000006af3eff000]   java.lang.Thread.State: BLOCKED (on object monitor)        at com.atguigu.sync.DeadLock.lambda$main$0(DeadLock.java:24)        - waiting to lock &lt;0x0000000622b5ee98&gt; (a java.lang.Object)        - locked &lt;0x0000000622b5ee88&gt; (a java.lang.Object)        at com.atguigu.sync.DeadLock$$Lambda$14/0x000001f8bc001200.run(Unknown Source)        at java.lang.Thread.run(java.base@17.0.11/Thread.java:842)&quot;B&quot; #25 prio=5 os_prio=0 cpu=0.00ms elapsed=196.07s tid=0x000001f8fc29c1b0 nid=0xf378 waiting for monitor entry  [0x0000006af3ffe000]   java.lang.Thread.State: BLOCKED (on object monitor)        at com.atguigu.sync.DeadLock.lambda$main$1(DeadLock.java:38)        - waiting to lock &lt;0x0000000622b5ee88&gt; (a java.lang.Object)        - locked &lt;0x0000000622b5ee98&gt; (a java.lang.Object)        at com.atguigu.sync.DeadLock$$Lambda$15/0x000001f8bc001418.run(Unknown Source)        at java.lang.Thread.run(java.base@17.0.11/Thread.java:842)&quot;DestroyJavaVM&quot; #26 prio=5 os_prio=0 cpu=0.00ms elapsed=196.07s tid=0x000001f88d7a7660 nid=0x5df0 waiting on condition  [0x0000000000000000]   java.lang.Thread.State: RUNNABLE&quot;VM Thread&quot; os_prio=2 cpu=0.00ms elapsed=196.10s tid=0x000001f8b9f813d0 nid=0x1157c runnable&quot;GC Thread#0&quot; os_prio=2 cpu=0.00ms elapsed=196.12s tid=0x000001f88d854e60 nid=0xe388 runnable&quot;G1 Main Marker&quot; os_prio=2 cpu=0.00ms elapsed=196.11s tid=0x000001f88d865c40 nid=0x111a8 runnable&quot;G1 Conc#0&quot; os_prio=2 cpu=0.00ms elapsed=196.11s tid=0x000001f88d866650 nid=0x8228 runnable&quot;G1 Refine#0&quot; os_prio=2 cpu=0.00ms elapsed=196.11s tid=0x000001f8b9ebd4d0 nid=0x4888 runnable&quot;G1 Service&quot; os_prio=2 cpu=0.00ms elapsed=196.11s tid=0x000001f8b9ebdf00 nid=0x80b4 runnable&quot;VM Periodic Task Thread&quot; os_prio=2 cpu=0.00ms elapsed=196.07s tid=0x000001f8b9ddc390 nid=0x11520 waiting on conditionJNI global refs: 23, weak refs: 0Found one Java-level deadlock:=============================&quot;A&quot;:  waiting to lock monitor 0x000001f8fc29f130 (object 0x0000000622b5ee98, a java.lang.Object),  which is held by &quot;B&quot;&quot;B&quot;:  waiting to lock monitor 0x000001f8fc2a00f0 (object 0x0000000622b5ee88, a java.lang.Object),  which is held by &quot;A&quot;Java stack information for the threads listed above:===================================================&quot;A&quot;:        at com.atguigu.sync.DeadLock.lambda$main$0(DeadLock.java:24)        - waiting to lock &lt;0x0000000622b5ee98&gt; (a java.lang.Object)        - locked &lt;0x0000000622b5ee88&gt; (a java.lang.Object)        at com.atguigu.sync.DeadLock$$Lambda$14/0x000001f8bc001200.run(Unknown Source)        at java.lang.Thread.run(java.base@17.0.11/Thread.java:842)&quot;B&quot;:        at com.atguigu.sync.DeadLock.lambda$main$1(DeadLock.java:38)        - waiting to lock &lt;0x0000000622b5ee88&gt; (a java.lang.Object)        - locked &lt;0x0000000622b5ee98&gt; (a java.lang.Object)        at com.atguigu.sync.DeadLock$$Lambda$15/0x000001f8bc001418.run(Unknown Source)        at java.lang.Thread.run(java.base@17.0.11/Thread.java:842)Found 1 deadlock.</code></pre><p>从 jstack 打印的日志可以看出，发生了死锁</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;一、synchronized-锁的8种情况&quot;&gt;&lt;a href=&quot;#一、synchronized-锁的8种情况&quot; class=&quot;headerlink&quot; title=&quot;一、synchronized 锁的8种情况&quot;&gt;&lt;/a&gt;一、synchronized 锁的8种情况&lt;/</summary>
      
    
    
    
    <category term="JUC" scheme="https://georgechan95.github.io/categories/JUC/"/>
    
    
    <category term="juc" scheme="https://georgechan95.github.io/tags/juc/"/>
    
    <category term="java" scheme="https://georgechan95.github.io/tags/java/"/>
    
  </entry>
  
  <entry>
    <title>04-集合的线程安全</title>
    <link href="https://georgechan95.github.io/blog/9a09d992.html"/>
    <id>https://georgechan95.github.io/blog/9a09d992.html</id>
    <published>2024-09-04T13:09:05.000Z</published>
    <updated>2024-09-06T01:07:26.519Z</updated>
    
    <content type="html"><![CDATA[<h1 id="一、ArrayList线程安全的操作"><a href="#一、ArrayList线程安全的操作" class="headerlink" title="一、ArrayList线程安全的操作"></a>一、ArrayList线程安全的操作</h1><h2 id="1-集合不安全的演示"><a href="#1-集合不安全的演示" class="headerlink" title="1. 集合不安全的演示"></a>1. 集合不安全的演示</h2><pre><code class="highlight java"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">NotSafeDemo</span> &#123;    <span class="comment">/**</span><span class="comment">     * 多个线程同时对集合进行修改</span><span class="comment">     * <span class="doctag">@param</span> args</span><span class="comment">     */</span>    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;        <span class="type">List</span> <span class="variable">list</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ArrayList</span>();        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; <span class="number">100</span>; i++) &#123;            <span class="keyword">new</span> <span class="title class_">Thread</span>(() -&gt;&#123;                list.add(UUID.randomUUID().toString());                System.out.println(list);            &#125;, <span class="string">&quot;线程&quot;</span> + i).start();        &#125;    &#125;&#125;</code></pre><p><strong>运行结果：</strong></p><pre><code class="highlight shell">Exception in thread &quot;线程93&quot; java.util.ConcurrentModificationExceptionat java.base/java.util.ArrayList$Itr.checkForComodification(ArrayList.java:1013)at java.base/java.util.ArrayList$Itr.next(ArrayList.java:967)at java.base/java.util.AbstractCollection.toString(AbstractCollection.java:456)at java.base/java.lang.String.valueOf(String.java:4222)at java.base/java.io.PrintStream.println(PrintStream.java:1047)</code></pre><p><strong>ArrayList add() 方法原码</strong></p><pre><code class="highlight java"><span class="comment">/**</span><span class="comment"> * Appends the specified element to the end of this list.</span><span class="comment"> *</span><span class="comment"> * <span class="doctag">@param</span> e element to be appended to this list</span><span class="comment"> * <span class="doctag">@return</span> &#123;<span class="doctag">@code</span> true&#125; (as specified by &#123;<span class="doctag">@link</span> Collection#add&#125;)</span><span class="comment"> */</span><span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">add</span><span class="params">(E e)</span> &#123;    modCount++;    add(e, elementData, size);    <span class="keyword">return</span> <span class="literal">true</span>;&#125;</code></pre><p>add() 方法没有加锁，是不安全的操作。</p><p><strong>如何去解决 List 类型的线程安全问题?</strong></p><h2 id="2-Vector"><a href="#2-Vector" class="headerlink" title="2. Vector"></a>2. Vector</h2><p>Vector 是<strong>矢量队列</strong>，它是 JDK1.0 版本添加的类。继承于 AbstractList，实现了 List, RandomAccess, Cloneable 这些接口。 Vector 继承了 AbstractList，实现了 List；所以，<strong>它是一个队列，支持相关的添加、删除、修改、遍历等功能</strong>。 Vector 实现了 RandmoAccess 接口，即<strong>提供了随机访问功能</strong>。RandmoAccess 是 java 中用来被 List 实现，为 List 提供快速访问功能的。在Vector 中，我们即可以通过元素的序号快速获取元素对象；这就是快速随机访问。 Vector 实现了 Cloneable 接口，即实现 clone()函数。它能被克隆。</p><p><strong>和 ArrayList 不同，Vector 中的操作是线程安全的。</strong></p><p>使用 <strong>Vector</strong> 对 Demo 进行修改</p><pre><code class="highlight java"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">VectorDemo</span> &#123;    <span class="comment">/**</span><span class="comment">     * 多个线程同时对集合进行修改</span><span class="comment">     * <span class="doctag">@param</span> args</span><span class="comment">     */</span>    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;        <span class="type">List</span> <span class="variable">list</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Vector</span>();        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; <span class="number">100</span>; i++) &#123;            <span class="keyword">new</span> <span class="title class_">Thread</span>(() -&gt;&#123;                list.add(UUID.randomUUID().toString());                System.out.println(list);            &#125;, <span class="string">&quot;线程&quot;</span> + i).start();        &#125;    &#125;&#125;</code></pre><p><strong>运行结果：无异常</strong></p><p>查看Vector add() 方法</p><pre><code class="highlight java"><span class="comment">/**</span><span class="comment"> * Appends the specified element to the end of this Vector.</span><span class="comment"> *</span><span class="comment"> * <span class="doctag">@param</span> e element to be appended to this Vector</span><span class="comment"> * <span class="doctag">@return</span> &#123;<span class="doctag">@code</span> true&#125; (as specified by &#123;<span class="doctag">@link</span> Collection#add&#125;)</span><span class="comment"> * <span class="doctag">@since</span> 1.2</span><span class="comment"> */</span><span class="keyword">public</span> <span class="keyword">synchronized</span> <span class="type">boolean</span> <span class="title function_">add</span><span class="params">(E e)</span> &#123;    modCount++;    add(e, elementData, elementCount);    <span class="keyword">return</span> <span class="literal">true</span>;&#125;</code></pre><p><code>add()</code> 方法添加了 <code>synchronized</code> 这是线程安全的操作。</p><h2 id="3-Collections"><a href="#3-Collections" class="headerlink" title="3. Collections"></a>3. Collections</h2><p>Collections 提供了方法 synchronizedList 保证 list 是同步线程安全的。</p><pre><code class="highlight java"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">CollectionsDemo</span> &#123;    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;        List&lt;Object&gt; list = Collections.synchronizedList(<span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;());        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; <span class="number">100</span>; i++) &#123;            <span class="keyword">new</span> <span class="title class_">Thread</span>(() -&gt;&#123;                list.add(UUID.randomUUID().toString());                System.out.println(list);            &#125;, <span class="string">&quot;线程&quot;</span> + i).start();        &#125;    &#125;&#125;</code></pre><p><strong>运行结果：没有异常</strong></p><p><strong>查看原码：</strong></p><pre><code class="highlight java"><span class="comment">/**</span><span class="comment"> * Returns a synchronized (thread-safe) list backed by the specified</span><span class="comment"> * list.  In order to guarantee serial access, it is critical that</span><span class="comment"> * &lt;strong&gt;all&lt;/strong&gt; access to the backing list is accomplished</span><span class="comment"> * through the returned list.&lt;p&gt;</span><span class="comment"> *</span><span class="comment"> * It is imperative that the user manually synchronize on the returned</span><span class="comment"> * list when traversing it via &#123;<span class="doctag">@link</span> Iterator&#125;, &#123;<span class="doctag">@link</span> Spliterator&#125;</span><span class="comment"> * or &#123;<span class="doctag">@link</span> Stream&#125;:</span><span class="comment"> * &lt;pre&gt;</span><span class="comment"> *  List list = Collections.synchronizedList(new ArrayList());</span><span class="comment"> *      ...</span><span class="comment"> *  synchronized (list) &#123;</span><span class="comment"> *      Iterator i = list.iterator(); // Must be in synchronized block</span><span class="comment"> *      while (i.hasNext())</span><span class="comment"> *          foo(i.next());</span><span class="comment"> *  &#125;</span><span class="comment"> * &lt;/pre&gt;</span><span class="comment"> * Failure to follow this advice may result in non-deterministic behavior.</span><span class="comment"> *</span><span class="comment"> * &lt;p&gt;The returned list will be serializable if the specified list is</span><span class="comment"> * serializable.</span><span class="comment"> *</span><span class="comment"> * <span class="doctag">@param</span>  &lt;T&gt; the class of the objects in the list</span><span class="comment"> * <span class="doctag">@param</span>  list the list to be &quot;wrapped&quot; in a synchronized list.</span><span class="comment"> * <span class="doctag">@return</span> a synchronized view of the specified list.</span><span class="comment"> */</span><span class="keyword">public</span> <span class="keyword">static</span> &lt;T&gt; List&lt;T&gt; <span class="title function_">synchronizedList</span><span class="params">(List&lt;T&gt; list)</span> &#123;    <span class="keyword">return</span> (list <span class="keyword">instanceof</span> RandomAccess ?            <span class="keyword">new</span> <span class="title class_">SynchronizedRandomAccessList</span>&lt;&gt;(list) :            <span class="keyword">new</span> <span class="title class_">SynchronizedList</span>&lt;&gt;(list));&#125;</code></pre><h2 id="4-CopyOnWriteArrayList-重点"><a href="#4-CopyOnWriteArrayList-重点" class="headerlink" title="4. CopyOnWriteArrayList (重点)"></a>4. CopyOnWriteArrayList (重点)</h2><p>CopyOnWriteArrayList 是线程安全的 ArrayList，具有以下特性：</p><ul><li>它最适合于具有以下特征的应用程序：List 大小通常保持很小，只读操作远多于可变操作，需要在遍历期间防止线程间的冲突。</li><li>它是线程安全的。</li><li>因为通常需要复制整个基础数组，所以可变操作（add()、set() 和 remove() 等等）的开销很大</li><li>迭代器支持 hasNext(), next()等不可变操作，但不支持可变 remove()等操作。</li><li>使用迭代器进行遍历的速度很快，并且不会与其他线程发生冲突。在构造迭代器时，迭代器依赖于不变的数组快照。</li></ul><p>当我们往一个容器添加元素的时候，不直接往当前容器添加，而是先将当前容器进行 Copy，复制出一个新的容器，然后新的容器里添加元素，添加完元素之后，再将原容器的引用指向新的容器。</p><p><strong>这时候会抛出来一个新的问题，也就是数据不一致的问题。如果写线程还没来得及写完并切换引用，其他的线程就会读到了脏数据</strong></p><p><strong>代码示例</strong></p><pre><code class="highlight java"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">CopyOnWriteArrayListDemo</span> &#123;    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;        CopyOnWriteArrayList&lt;String&gt; list = <span class="keyword">new</span> <span class="title class_">CopyOnWriteArrayList</span>&lt;&gt;();        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; <span class="number">100</span>; i++) &#123;            <span class="keyword">new</span> <span class="title class_">Thread</span>(() -&gt;&#123;                list.add(UUID.randomUUID().toString());                System.out.println(list);            &#125;, <span class="string">&quot;线程&quot;</span> + i).start();        &#125;    &#125;&#125;</code></pre><p>运行结果：没有线程安全问题</p><p>下面从“动态数组”和“线程安全”两个方面进一步对CopyOnWriteArrayList 的原理进行说明。</p><ul><li><strong>“动态数组”机制</strong><ul><li>它内部有个“volatile 数组”(array)来保持数据。在“添加&#x2F;修改&#x2F;删除”数据时，都会新建一个数组，并将更新后的数据拷贝到新建的数组中，最后再将该数组赋值给“volatile 数组”, 这就是它叫做 CopyOnWriteArrayList 的原因</li><li><strong>由于它在“添加&#x2F;修改&#x2F;删除”数据时，都会新建数组，所以涉及到修改数据的操作，CopyOnWriteArrayList 效率很低；但是单单只是进行遍历查找的话，效率比较高。</strong></li></ul></li><li><strong>“线程安全”机制</strong><ul><li>通过 volatile 和互斥锁来实现的。</li><li>通过“volatile 数组”来保存数据的。一个线程读取 volatile 数组时，总能看到其它线程对该 volatile 变量最后的写入；就这样，通过 volatile 提供了“读取到的数据总是最新的”这个机制的保证。</li><li>通过互斥锁来保护数据。在“添加&#x2F;修改&#x2F;删除”数据时，会先“获取互斥锁”，再修改完毕之后，先将数据更新到 “volatile 数组” 中，然后再 “释放互斥锁”，就达到了保护数据的目的。</li></ul></li></ul><h1 id="二、HashSet-线程安全的操作"><a href="#二、HashSet-线程安全的操作" class="headerlink" title="二、HashSet 线程安全的操作"></a>二、HashSet 线程安全的操作</h1><p>解决方案 CopyOnWriteArraySet</p><pre><code class="highlight java"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">CopyOnWriteArraySetDemo</span> &#123;    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;        <span class="comment">// 线程不安全的操作</span><span class="comment">//        HashSet&lt;String&gt; set = new HashSet&lt;&gt;();</span>        <span class="comment">// 线程安全的操作</span>        CopyOnWriteArraySet&lt;String&gt; set = <span class="keyword">new</span> <span class="title class_">CopyOnWriteArraySet</span>&lt;&gt;();        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; <span class="number">1000</span>; i++) &#123;            <span class="keyword">new</span> <span class="title class_">Thread</span>(() -&gt;&#123;                set.add(UUID.randomUUID().toString());                System.out.println(set);            &#125;, <span class="string">&quot;线程&quot;</span> + i).start();        &#125;    &#125;&#125;</code></pre><h1 id="三、HashMap-线程安全的操作"><a href="#三、HashMap-线程安全的操作" class="headerlink" title="三、HashMap 线程安全的操作"></a>三、HashMap 线程安全的操作</h1><p>解决方案 ConcurrentHashMap</p><pre><code class="highlight java"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ConcurrentHashMapDemo</span> &#123;    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;        <span class="comment">// 线程不安全的操作</span><span class="comment">//        HashMap&lt;String, String&gt; map = new HashMap&lt;&gt;();</span>        <span class="comment">// 线程安全的操作</span>        ConcurrentHashMap&lt;String, String&gt; map = <span class="keyword">new</span> <span class="title class_">ConcurrentHashMap</span>&lt;&gt;();        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; <span class="number">1000</span>; i++) &#123;            <span class="keyword">new</span> <span class="title class_">Thread</span>(() -&gt;&#123;                map.put(UUID.randomUUID().toString(), <span class="string">&quot;1&quot;</span>);                System.out.println(map.values());            &#125;, <span class="string">&quot;线程&quot;</span> + i).start();        &#125;    &#125;&#125;</code></pre>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;一、ArrayList线程安全的操作&quot;&gt;&lt;a href=&quot;#一、ArrayList线程安全的操作&quot; class=&quot;headerlink&quot; title=&quot;一、ArrayList线程安全的操作&quot;&gt;&lt;/a&gt;一、ArrayList线程安全的操作&lt;/h1&gt;&lt;h2 id=&quot;1</summary>
      
    
    
    
    <category term="JUC" scheme="https://georgechan95.github.io/categories/JUC/"/>
    
    
    <category term="juc" scheme="https://georgechan95.github.io/tags/juc/"/>
    
    <category term="java" scheme="https://georgechan95.github.io/tags/java/"/>
    
  </entry>
  
  <entry>
    <title>03-线程间通信</title>
    <link href="https://georgechan95.github.io/blog/bd2134da.html"/>
    <id>https://georgechan95.github.io/blog/bd2134da.html</id>
    <published>2024-09-04T12:06:00.000Z</published>
    <updated>2024-09-04T00:31:04.024Z</updated>
    
    <content type="html"><![CDATA[<h1 id="一、线程间通信"><a href="#一、线程间通信" class="headerlink" title="一、线程间通信"></a>一、线程间通信</h1><p>线程间通信的模型有两种：共享内存和消息传递，以下方式都是基本这两种模型来实现的。我们来基本一道面试常见的题目来分析</p><p><strong>场景—两个线程，一个线程对当前数值加 1，另一个线程对当前数值减 1,要求用线程间通信</strong></p><h2 id="1-synchronized-方案"><a href="#1-synchronized-方案" class="headerlink" title="1. synchronized 方案"></a>1. synchronized 方案</h2><pre><code class="highlight java"><span class="keyword">class</span> <span class="title class_">TestVolatile</span> &#123;    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;        <span class="type">DemoClass</span> <span class="variable">demoClass</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">DemoClass</span>();        <span class="keyword">new</span> <span class="title class_">Thread</span>(() -&gt; &#123;            <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; <span class="number">10</span>; i++) &#123;                <span class="keyword">try</span> &#123;                    demoClass.increment();                &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;                    <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">RuntimeException</span>(e);                &#125;            &#125;        &#125;, <span class="string">&quot;线程A&quot;</span>).start();        <span class="keyword">new</span> <span class="title class_">Thread</span>(() -&gt; &#123;            <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; <span class="number">10</span>; i++) &#123;                <span class="keyword">try</span> &#123;                    demoClass.decrement();                &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;                    <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">RuntimeException</span>(e);                &#125;            &#125;        &#125;, <span class="string">&quot;线程B&quot;</span>).start();    &#125;&#125;<span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">DemoClass</span> &#123;    <span class="keyword">private</span> <span class="type">int</span> <span class="variable">number</span> <span class="operator">=</span> <span class="number">0</span>;    <span class="keyword">public</span> <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title function_">increment</span><span class="params">()</span> <span class="keyword">throws</span> InterruptedException &#123;        <span class="keyword">while</span> (number != <span class="number">0</span>) &#123;            <span class="built_in">this</span>.wait();        &#125;        number++;        System.out.println(Thread.currentThread().getName() + <span class="string">&quot;执行了加1操作，当前值为：&quot;</span> + number);        notifyAll();    &#125;    <span class="keyword">public</span> <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title function_">decrement</span><span class="params">()</span> <span class="keyword">throws</span> InterruptedException &#123;        <span class="keyword">while</span> (number != <span class="number">1</span>) &#123;            <span class="built_in">this</span>.wait();        &#125;        number--;        System.out.println(Thread.currentThread().getName() + <span class="string">&quot;执行了减1操作，当前值为：&quot;</span> + number);        notifyAll();    &#125;&#125;</code></pre><h2 id="2-Lock-方案"><a href="#2-Lock-方案" class="headerlink" title="2. Lock 方案"></a>2. Lock 方案</h2><pre><code class="highlight java"><span class="keyword">class</span> <span class="title class_">ShareNum</span> &#123;    <span class="keyword">private</span> <span class="type">int</span> <span class="variable">number</span> <span class="operator">=</span> <span class="number">0</span>;    <span class="keyword">private</span> <span class="type">ReentrantLock</span> <span class="variable">lock</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ReentrantLock</span>(<span class="literal">true</span>);    <span class="keyword">private</span> <span class="type">Condition</span> <span class="variable">condition</span> <span class="operator">=</span> lock.newCondition();    <span class="comment">// ++操作</span>    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">increase</span><span class="params">()</span> &#123;        <span class="comment">// 上锁</span>        lock.lock();        <span class="keyword">try</span> &#123;            <span class="keyword">while</span> (number != <span class="number">0</span>) &#123;                condition.await();            &#125;            <span class="comment">// 执行 ++ 操作</span>            number++;            System.out.println(Thread.currentThread().getName() + <span class="string">&quot;执行了 ++ 操作，当前number值为：&quot;</span> + number);            <span class="comment">// 唤醒其它线程</span>            condition.signalAll();        &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;            <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">RuntimeException</span>(e);        &#125; <span class="keyword">finally</span> &#123;            <span class="comment">// 解锁</span>            lock.unlock();        &#125;    &#125;    <span class="comment">// -- 操作</span>    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">decrease</span><span class="params">()</span> &#123;        <span class="comment">// 上锁</span>        lock.lock();        <span class="keyword">try</span> &#123;            <span class="keyword">while</span> (number != <span class="number">1</span>) &#123;                condition.await();            &#125;            <span class="comment">// 执行 -- 操作</span>            number--;            System.out.println(Thread.currentThread().getName() + <span class="string">&quot;执行了 -- 操作，当前number值为：&quot;</span> + number);            <span class="comment">// 唤醒其它线程</span>            condition.signalAll();        &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;            <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">RuntimeException</span>(e);        &#125; <span class="keyword">finally</span> &#123;            <span class="comment">// 解锁</span>            lock.unlock();        &#125;    &#125;&#125;<span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ConditionDemo</span> &#123;    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;        <span class="type">ShareNum</span> <span class="variable">shareNum</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ShareNum</span>();        <span class="keyword">new</span> <span class="title class_">Thread</span>(() -&gt; &#123;            <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; <span class="number">10</span>; i++) &#123;                shareNum.increase();            &#125;        &#125;, <span class="string">&quot;AA&quot;</span>).start();        <span class="keyword">new</span> <span class="title class_">Thread</span>(() -&gt; &#123;            <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; <span class="number">10</span>; i++) &#123;                shareNum.decrease();            &#125;        &#125;, <span class="string">&quot;BB&quot;</span>).start();        <span class="keyword">new</span> <span class="title class_">Thread</span>(() -&gt; &#123;            <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; <span class="number">10</span>; i++) &#123;                shareNum.increase();            &#125;        &#125;, <span class="string">&quot;CC&quot;</span>).start();        <span class="keyword">new</span> <span class="title class_">Thread</span>(() -&gt; &#123;            <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; <span class="number">10</span>; i++) &#123;                shareNum.decrease();            &#125;        &#125;, <span class="string">&quot;DD&quot;</span>).start();    &#125;&#125;</code></pre><h1 id="二、线程间定制化通信"><a href="#二、线程间定制化通信" class="headerlink" title="二、线程间定制化通信"></a>二、线程间定制化通信</h1><h2 id="1-案例介绍"><a href="#1-案例介绍" class="headerlink" title="1. 案例介绍"></a>1. 案例介绍</h2><p><strong>A 线程打印 5 次 A，B 线程打印 10 次 B，C 线程打印 15 次 C,按照此顺序循环 10 轮</strong></p><h2 id="2-实现过程"><a href="#2-实现过程" class="headerlink" title="2. 实现过程"></a>2. 实现过程</h2><pre><code class="highlight java"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">PrintTest</span> &#123;    <span class="comment">// 线程通信标识：0-线程A  1-线程B  2-线程C</span>    <span class="keyword">private</span> <span class="type">int</span> <span class="variable">number</span> <span class="operator">=</span> <span class="number">0</span>;    <span class="comment">// 创建锁</span>    <span class="keyword">private</span> <span class="type">Lock</span> <span class="variable">lock</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ReentrantLock</span>();    <span class="comment">// 线程A的通信钥匙</span>    <span class="keyword">private</span> <span class="type">Condition</span> <span class="variable">conditionA</span> <span class="operator">=</span>lock.newCondition();    <span class="comment">// 线程B的通信钥匙</span>    <span class="keyword">private</span> <span class="type">Condition</span> <span class="variable">conditionB</span> <span class="operator">=</span>lock.newCondition();    <span class="comment">// 线程C的通信钥匙</span>    <span class="keyword">private</span> <span class="type">Condition</span> <span class="variable">conditionC</span> <span class="operator">=</span>lock.newCondition();    <span class="comment">/**</span><span class="comment">     * 打印五次A</span><span class="comment">     */</span>    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">printA</span><span class="params">(<span class="type">int</span> round)</span> &#123;        <span class="keyword">try</span> &#123;            lock.lock();            <span class="keyword">while</span> (number != <span class="number">0</span>) &#123;                conditionA.await(); <span class="comment">// 等待并释放锁</span>            &#125;            <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; <span class="number">5</span>; i++) &#123;                System.out.println(<span class="string">&quot;第 &quot;</span> + round + <span class="string">&quot;轮：&quot;</span> + Thread.currentThread().getName() + <span class="string">&quot;执行中，开始打印：=== A ===&quot;</span>);            &#125;            <span class="comment">// 打印B</span>            number = <span class="number">1</span>;            conditionB.signal();        &#125; <span class="keyword">catch</span> (Exception e) &#123;        &#125; <span class="keyword">finally</span> &#123;            lock.unlock();        &#125;    &#125;    <span class="comment">/**</span><span class="comment">     * 打印10次B</span><span class="comment">     */</span>    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">printB</span><span class="params">(<span class="type">int</span> round)</span> &#123;        <span class="keyword">try</span> &#123;            lock.lock();            <span class="keyword">while</span> (number != <span class="number">1</span>) &#123;                conditionB.await(); <span class="comment">// 等待并释放锁</span>            &#125;            <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; <span class="number">10</span>; i++) &#123;                System.out.println(<span class="string">&quot;第 &quot;</span> + round + <span class="string">&quot;轮：&quot;</span> + Thread.currentThread().getName() + <span class="string">&quot;执行中，开始打印：=== B ===&quot;</span>);            &#125;            <span class="comment">// 打印B</span>            number = <span class="number">2</span>;            conditionC.signal();        &#125; <span class="keyword">catch</span> (Exception e) &#123;        &#125; <span class="keyword">finally</span> &#123;            lock.unlock();        &#125;    &#125;    <span class="comment">/**</span><span class="comment">     * 打印15次C</span><span class="comment">     */</span>    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">printC</span><span class="params">(<span class="type">int</span> round)</span> &#123;        <span class="keyword">try</span> &#123;            lock.lock();            <span class="keyword">while</span> (number != <span class="number">2</span>) &#123;                conditionC.await(); <span class="comment">// 等待并释放锁</span>            &#125;            <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; <span class="number">15</span>; i++) &#123;                System.out.println(<span class="string">&quot;第 &quot;</span> + round + <span class="string">&quot;轮：&quot;</span> + Thread.currentThread().getName() + <span class="string">&quot;执行中，开始打印：=== C ===&quot;</span>);            &#125;            <span class="comment">// 打印B</span>            number = <span class="number">0</span>;            conditionA.signal();        &#125; <span class="keyword">catch</span> (Exception e) &#123;        &#125; <span class="keyword">finally</span> &#123;            lock.unlock();        &#125;    &#125;&#125;<span class="keyword">class</span> <span class="title class_">MainClass</span> &#123;    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;        <span class="type">PrintTest</span> <span class="variable">printTest</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">PrintTest</span>();        <span class="keyword">new</span> <span class="title class_">Thread</span>(() -&gt; &#123;            <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; <span class="number">10</span>; i++) &#123;                printTest.printA(i);            &#125;        &#125;, <span class="string">&quot;线程A&quot;</span>).start();        <span class="keyword">new</span> <span class="title class_">Thread</span>(() -&gt; &#123;            <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; <span class="number">10</span>; i++) &#123;                printTest.printB(i);            &#125;        &#125;, <span class="string">&quot;线程B&quot;</span>).start();        <span class="keyword">new</span> <span class="title class_">Thread</span>(() -&gt; &#123;            <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; <span class="number">10</span>; i++) &#123;                printTest.printC(i);            &#125;        &#125;, <span class="string">&quot;线程C&quot;</span>).start();    &#125;&#125;</code></pre>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;一、线程间通信&quot;&gt;&lt;a href=&quot;#一、线程间通信&quot; class=&quot;headerlink&quot; title=&quot;一、线程间通信&quot;&gt;&lt;/a&gt;一、线程间通信&lt;/h1&gt;&lt;p&gt;线程间通信的模型有两种：共享内存和消息传递，以下方式都是基本这两种模型来实现的。我们来基本一道面试常</summary>
      
    
    
    
    <category term="JUC" scheme="https://georgechan95.github.io/categories/JUC/"/>
    
    
    <category term="juc" scheme="https://georgechan95.github.io/tags/juc/"/>
    
    <category term="java" scheme="https://georgechan95.github.io/tags/java/"/>
    
  </entry>
  
  <entry>
    <title>02-Lock接口</title>
    <link href="https://georgechan95.github.io/blog/850dac3c.html"/>
    <id>https://georgechan95.github.io/blog/850dac3c.html</id>
    <published>2024-08-30T11:27:00.000Z</published>
    <updated>2024-09-03T23:45:00.212Z</updated>
    
    <content type="html"><![CDATA[<h1 id="一、Synchronized"><a href="#一、Synchronized" class="headerlink" title="一、Synchronized"></a>一、Synchronized</h1><h2 id="1-Synchronized-关键字回顾"><a href="#1-Synchronized-关键字回顾" class="headerlink" title="1. Synchronized 关键字回顾"></a>1. Synchronized 关键字回顾</h2><p>synchronized 是 Java 中的关键字，是一种同步锁。它修饰的对象有以下几种：</p><ul><li><p>修饰一个代码块，被修饰的代码块称为同步语句块，其作用的范围是 大括号{} 括起来的代码，作用的对象是调用这个代码块的对象；</p></li><li><p>修饰一个方法，被修饰的方法称为同步方法，其作用的范围是整个方法，作用的对象是调用这个方法的对象；</p><p>虽然可以使用 synchronized 来定义方法，但 synchronized 并不属于方法定义的一部分，因此，<strong>synchronized 关键字不能被继承</strong>。如果在父类中的某个方法使用了 synchronized 关键字，而在子类中覆盖了这个方法，在子类中的这个方法默认情况下并不是同步的，而必须显式地在子类的这个方法中加上synchronized 关键字才可以。当然，还可以在子类方法中调用父类中相应的方法，这样虽然子类中的方法不是同步的，但子类调用了父类的同步方法，因此，子类的方法也就相当于同步了。</p></li><li><p>修改一个静态的方法，其作用的范围是整个静态方法，作用的对象是这个类的所有对象；</p></li><li><p>修改一个类，其作用的范围是 synchronized 后面括号括起来的部分，作用主的对象是这个类的所有对象。</p></li></ul><h2 id="2-Synchronized案例"><a href="#2-Synchronized案例" class="headerlink" title="2. Synchronized案例"></a>2. Synchronized案例</h2><p>使用 synchronized 完成售票案例</p><pre><code class="highlight java"><span class="comment">//第一步  创建资源类，定义属性和和操作方法</span><span class="keyword">class</span> <span class="title class_">Ticket</span> &#123;    <span class="comment">//票数</span>    <span class="keyword">private</span> <span class="type">int</span> <span class="variable">number</span> <span class="operator">=</span> <span class="number">30</span>;    <span class="comment">//操作方法：卖票</span>    <span class="keyword">public</span> <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title function_">sale</span><span class="params">()</span> &#123;        <span class="comment">//判断：是否有票</span>        <span class="keyword">if</span>(number &gt; <span class="number">0</span>) &#123;            System.out.println(Thread.currentThread().getName()+<span class="string">&quot; : 卖出：&quot;</span>+(number--)+<span class="string">&quot; 剩下：&quot;</span>+number);        &#125;    &#125;&#125;<span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">SaleTicket</span> &#123;    <span class="comment">//第二步 创建多个线程，调用资源类的操作方法</span>    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;        <span class="comment">//创建Ticket对象</span>        <span class="type">Ticket</span> <span class="variable">ticket</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Ticket</span>();        <span class="comment">//创建三个线程</span>        <span class="keyword">new</span> <span class="title class_">Thread</span>(<span class="keyword">new</span> <span class="title class_">Runnable</span>() &#123;            <span class="meta">@Override</span>            <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span> &#123;                <span class="comment">//调用卖票方法</span>                <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; <span class="number">40</span>; i++) &#123;                    ticket.sale();                &#125;            &#125;        &#125;,<span class="string">&quot;AA&quot;</span>).start();        <span class="keyword">new</span> <span class="title class_">Thread</span>(<span class="keyword">new</span> <span class="title class_">Runnable</span>() &#123;            <span class="meta">@Override</span>            <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span> &#123;                <span class="comment">//调用卖票方法</span>                <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; <span class="number">40</span>; i++) &#123;                    ticket.sale();                &#125;            &#125;        &#125;,<span class="string">&quot;BB&quot;</span>).start();        <span class="keyword">new</span> <span class="title class_">Thread</span>(<span class="keyword">new</span> <span class="title class_">Runnable</span>() &#123;            <span class="meta">@Override</span>            <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span> &#123;                <span class="comment">//调用卖票方法</span>                <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; <span class="number">40</span>; i++) &#123;                    ticket.sale();                &#125;            &#125;        &#125;,<span class="string">&quot;CC&quot;</span>).start();    &#125;&#125;</code></pre><ul><li>注意：Synchronized 不是公平锁，所以执行这个程序有可能会出现某个线程把票卖完，而其它线程没有执行机会的情况</li></ul><p>如果一个代码块被 synchronized 修饰了，当一个线程获取了对应的锁，并执行该代码块时，其他线程便只能一直等待，等待获取锁的线程释放锁，而这里获取锁的线程释放锁只会有两种情况：</p><ul><li>获取锁的线程执行完了该代码块，然后线程释放对锁的占有；</li><li>线程执行发生异常，此时 JVM 会让线程自动释放锁</li></ul><p>那么如果这个获取锁的线程由于要等待 IO 或者其他原因（比如调用 sleep方法）被阻塞了，但是又没有释放锁，其他线程便只能干巴巴地等待，试想一下，这多么影响程序执行效率。因此就需要有一种机制可以不让等待的线程一直无期限地等待下去（比如只等待一定的时间或者能够响应中断），通过 Lock 就可以办到。</p><h1 id="二、Lock接口"><a href="#二、Lock接口" class="headerlink" title="二、Lock接口"></a>二、Lock接口</h1><p>Lock 锁实现提供了比使用同步方法和语句可以获得的更广泛的锁操作。它们允许更灵活的结构，可能具有非常不同的属性，并且可能支持多个关联的条件对象。Lock 提供了比 synchronized 更多的功能。</p><p>Lock 与的 Synchronized 区别：</p><ul><li>Lock 不是 Java 语言内置的，synchronized 是 Java 语言的关键字，因此是内置特性。Lock 是一个类，通过这个类可以实现同步访问；</li><li>Lock 和 synchronized 有一点非常大的不同，采用 synchronized 不需要用户去手动释放锁，当 synchronized 方法或者 synchronized 代码块执行完之后，系统会自动让线程释放对锁的占用；而 Lock 则必须要用户去手动释放锁，如果没有主动释放锁，就有可能导致出现死锁现象。</li></ul><h2 id="1-Lock-接口"><a href="#1-Lock-接口" class="headerlink" title="1. Lock 接口"></a>1. Lock 接口</h2><p>接口代码路径：<code>java.util.concurrent.locks.Lock</code></p><pre><code class="highlight java"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">Lock</span> &#123;    <span class="comment">/**</span><span class="comment">     * Acquires the lock.</span><span class="comment">     */</span>    <span class="keyword">void</span> <span class="title function_">lock</span><span class="params">()</span>;    <span class="comment">/**</span><span class="comment">     * Acquires the lock unless the current thread is</span><span class="comment">     * &#123;<span class="doctag">@linkplain</span> Thread#interrupt interrupted&#125;.</span><span class="comment">     */</span>    <span class="keyword">void</span> <span class="title function_">lockInterruptibly</span><span class="params">()</span> <span class="keyword">throws</span> InterruptedException;    <span class="comment">/**</span><span class="comment">     * Acquires the lock only if it is free at the time of invocation.</span><span class="comment">     */</span>    <span class="type">boolean</span> <span class="title function_">tryLock</span><span class="params">()</span>;    <span class="comment">/**</span><span class="comment">     * Acquires the lock if it is free within the given waiting time and the</span><span class="comment">     * current thread has not been &#123;<span class="doctag">@linkplain</span> Thread#interrupt interrupted&#125;.</span><span class="comment">     */</span>    <span class="type">boolean</span> <span class="title function_">tryLock</span><span class="params">(<span class="type">long</span> time, TimeUnit unit)</span> <span class="keyword">throws</span> InterruptedException;    <span class="comment">/**</span><span class="comment">     * Releases the lock.</span><span class="comment">     */</span>    <span class="keyword">void</span> <span class="title function_">unlock</span><span class="params">()</span>;    <span class="comment">/**</span><span class="comment">     * Returns a new &#123;<span class="doctag">@link</span> Condition&#125; instance that is bound to this</span><span class="comment">     */</span>    Condition <span class="title function_">newCondition</span><span class="params">()</span>;&#125;</code></pre><p>下面来逐个讲述 Lock 接口中每个方法的使用</p><h3 id="1-1-lock-方法"><a href="#1-1-lock-方法" class="headerlink" title="1.1 lock() 方法"></a>1.1 <code>lock()</code> 方法</h3><p>lock()方法是平常使用得最多的一个方法，就是用来获取锁。如果锁已被其他线程获取，则进行等待。</p><p>采用 Lock，必须主动去释放锁，并且在发生异常时，不会自动释放锁。因此一般来说，使用 Lock 必须在 <code>try&#123;&#125;catch&#123;&#125;</code> 块中进行，并且将释放锁的操作放在<code>finally</code> 块中进行，以保证锁一定被被释放，防止死锁的发生。通常使用 Lock来进行同步的话，是以下面这种形式去使用的：</p><pre><code class="highlight java">lock.lock();<span class="keyword">try</span> &#123;<span class="comment">//处理任务</span>&#125; <span class="keyword">catch</span> (Exception e) &#123;&#125; <span class="keyword">finally</span> &#123;    lock.unlock(); <span class="comment">//释放锁</span>&#125;</code></pre><p><strong>测试案例：买票</strong></p><p>三个售票员，同时卖30张票，不能超卖。</p><p>使用 <code>ReentrantLock</code></p><pre><code class="highlight java"><span class="comment">// 定义资源类、属性、方法</span><span class="keyword">class</span> <span class="title class_">LTickets</span> &#123;    <span class="comment">//票数量</span>    <span class="keyword">private</span> <span class="type">int</span> <span class="variable">num</span> <span class="operator">=</span> <span class="number">30</span>;    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">getNum</span><span class="params">()</span> &#123;        <span class="keyword">return</span> num;    &#125;    <span class="comment">// 创建可重入锁</span>    <span class="keyword">private</span> <span class="type">ReentrantLock</span> <span class="variable">lock</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ReentrantLock</span>(<span class="literal">true</span>);    <span class="comment">//卖票方法</span>    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">sale</span><span class="params">()</span> &#123;        <span class="comment">//上锁</span>        lock.lock();        <span class="keyword">try</span> &#123;            <span class="comment">// 判断是否还有票</span>            <span class="keyword">if</span> (num &gt; <span class="number">0</span>) &#123;                System.out.println(Thread.currentThread().getName() + <span class="string">&quot; 卖出1张票,还剩：&quot;</span> + --num +<span class="string">&quot; 张票&quot;</span>);            &#125;        &#125; <span class="keyword">finally</span> &#123;            <span class="comment">// 解锁</span>            lock.unlock();        &#125;    &#125;&#125;<span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ReentrantLockDemo</span> &#123;    <span class="comment">//第二步 创建多个线程，调用资源类的操作方法</span>    <span class="comment">//创建三个线程</span>    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;        <span class="type">LTickets</span> <span class="variable">lTickets</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">LTickets</span>();        <span class="keyword">new</span> <span class="title class_">Thread</span>(() -&gt; &#123;            <span class="keyword">while</span> (lTickets.getNum() &gt; <span class="number">0</span>) &#123;                lTickets.sale();            &#125;        &#125;, <span class="string">&quot;售票员1&quot;</span>).start();        <span class="keyword">new</span> <span class="title class_">Thread</span>(() -&gt; &#123;            <span class="keyword">while</span> (lTickets.getNum() &gt; <span class="number">0</span>) &#123;                lTickets.sale();            &#125;        &#125;, <span class="string">&quot;售票员2&quot;</span>).start();        <span class="keyword">new</span> <span class="title class_">Thread</span>(() -&gt; &#123;            <span class="keyword">while</span> (lTickets.getNum() &gt; <span class="number">0</span>) &#123;                lTickets.sale();            &#125;        &#125;, <span class="string">&quot;售票员3&quot;</span>).start();    &#125;&#125;</code></pre><p><strong>运行结果</strong></p><pre><code class="highlight txt">售票员1 卖出1张票,还剩：29 张票售票员2 卖出1张票,还剩：28 张票售票员3 卖出1张票,还剩：27 张票......售票员3 卖出1张票,还剩：3 张票售票员1 卖出1张票,还剩：2 张票售票员2 卖出1张票,还剩：1 张票售票员3 卖出1张票,还剩：0 张票</code></pre><h3 id="1-2-newCondition-方法"><a href="#1-2-newCondition-方法" class="headerlink" title="1.2 newCondition() 方法"></a>1.2 <code>newCondition()</code> 方法</h3><p>关键字 <code>synchronized</code> 与 <code>wait()</code> &#x2F; <code>notify()</code> 这两个方法一起使用可以实现等待&#x2F;通知模式， Lock 锁的 <code>newContition()</code> 方法返回 Condition 对象，Condition 类也可以实现等待&#x2F;通知模式。</p><p>用 <code>notify()</code> 通知时，JVM 会随机唤醒某个等待的线程， 使用 Condition 类可以进行选择性通知， Condition 比较常用的两个方法：</p><ul><li><code>await()</code> 会使当前线程等待,同时会释放锁,当其他线程调用 <code>signal()</code> 时,线程会重新获得锁并继续执行。</li><li><code>signal()</code> 用于唤醒一个等待的线程。</li></ul><p>注意：在调用 Condition 的 <code>await()/signal()</code> 方法前，也需要线程持有相关的 Lock 锁，调用 <code>await()</code> 后线程会释放这个锁，在 <code>singal()</code> 调用后会从当前Condition 对象的等待队列中，唤醒 一个线程，唤醒的线程尝试获得锁， 一旦获得锁成功就继续执行。</p><h4 id="测试案例"><a href="#测试案例" class="headerlink" title="测试案例"></a>测试案例</h4><p>当前有一个变量 number，初始值是0，创建四个线程同时修改次变量，线程AA、线程CC对变量做++操作， 线程BB、线程DD对变量做–操作。每个线程都执行10次</p><pre><code class="highlight java"><span class="keyword">class</span> <span class="title class_">ShareNum</span> &#123;    <span class="keyword">private</span> <span class="type">int</span> <span class="variable">number</span> <span class="operator">=</span> <span class="number">0</span>;    <span class="keyword">private</span> <span class="type">ReentrantLock</span> <span class="variable">lock</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ReentrantLock</span>(<span class="literal">true</span>);    <span class="keyword">private</span> <span class="type">Condition</span> <span class="variable">condition</span> <span class="operator">=</span> lock.newCondition();    <span class="comment">// ++操作</span>    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">increase</span><span class="params">()</span> &#123;        <span class="comment">// 上锁</span>        lock.lock();        <span class="keyword">try</span> &#123;            <span class="keyword">while</span> (number != <span class="number">0</span>) &#123;                condition.await();            &#125;            <span class="comment">// 执行 ++ 操作</span>            number++;            System.out.println(Thread.currentThread().getName() + <span class="string">&quot;执行了 ++ 操作，当前number值为：&quot;</span> + number);            <span class="comment">// 唤醒其它线程</span>            condition.signalAll();        &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;            <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">RuntimeException</span>(e);        &#125; <span class="keyword">finally</span> &#123;            <span class="comment">// 解锁</span>            lock.unlock();        &#125;    &#125;    <span class="comment">// -- 操作</span>    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">decrease</span><span class="params">()</span> &#123;        <span class="comment">// 上锁</span>        lock.lock();        <span class="keyword">try</span> &#123;            <span class="keyword">while</span> (number != <span class="number">1</span>) &#123;                condition.await();            &#125;            <span class="comment">// 执行 -- 操作</span>            number--;            System.out.println(Thread.currentThread().getName() + <span class="string">&quot;执行了 -- 操作，当前number值为：&quot;</span> + number);            <span class="comment">// 唤醒其它线程</span>            condition.signalAll();        &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;            <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">RuntimeException</span>(e);        &#125; <span class="keyword">finally</span> &#123;            <span class="comment">// 解锁</span>            lock.unlock();        &#125;    &#125;&#125;<span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ConditionDemo</span> &#123;    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;        <span class="type">ShareNum</span> <span class="variable">shareNum</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ShareNum</span>();        <span class="keyword">new</span> <span class="title class_">Thread</span>(() -&gt; &#123;            <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; <span class="number">10</span>; i++) &#123;                shareNum.increase();            &#125;        &#125;, <span class="string">&quot;AA&quot;</span>).start();        <span class="keyword">new</span> <span class="title class_">Thread</span>(() -&gt; &#123;            <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; <span class="number">10</span>; i++) &#123;                shareNum.decrease();            &#125;        &#125;, <span class="string">&quot;BB&quot;</span>).start();        <span class="keyword">new</span> <span class="title class_">Thread</span>(() -&gt; &#123;            <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; <span class="number">10</span>; i++) &#123;                shareNum.increase();            &#125;        &#125;, <span class="string">&quot;CC&quot;</span>).start();        <span class="keyword">new</span> <span class="title class_">Thread</span>(() -&gt; &#123;            <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; <span class="number">10</span>; i++) &#123;                shareNum.decrease();            &#125;        &#125;, <span class="string">&quot;DD&quot;</span>).start();    &#125;&#125;</code></pre><h1 id="三、ReentrantLock"><a href="#三、ReentrantLock" class="headerlink" title="三、ReentrantLock"></a>三、ReentrantLock</h1><p>重入锁简单来说一个线程可以重复获取锁资源，虽然ReentrantLock不像synchronized关键字一样支持隐式的重入锁，但是在调用lock方法时，它会判断当前尝试获取锁的线程，是否等于已经拥有锁的线程，如果成立则不会被阻塞。</p><p>还有ReentrantLock在创建的时候，可以通构造方法指定创建公平锁还是非公平锁。</p><h2 id="1-代码示例"><a href="#1-代码示例" class="headerlink" title="1.  代码示例"></a>1.  代码示例</h2><pre><code class="highlight java"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ReentrantLockTest</span> &#123;    <span class="keyword">private</span> ArrayList&lt;Integer&gt; arrayList = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> InterruptedException &#123;        <span class="keyword">final</span> <span class="type">ReentrantLockTest</span> <span class="variable">test</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ReentrantLockTest</span>();        <span class="comment">// 锁放在这里，保证两个线程使用的是同一把锁</span>        <span class="type">Lock</span> <span class="variable">lock</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ReentrantLock</span>(); <span class="comment">//注意这个地方</span>        <span class="keyword">new</span> <span class="title class_">Thread</span>(() -&gt; &#123;            test.insert(Thread.currentThread(), lock);        &#125;).start();        <span class="keyword">new</span> <span class="title class_">Thread</span>(() -&gt; &#123;            test.insert(Thread.currentThread(), lock);        &#125;).start();        Thread.sleep(<span class="number">1000</span>);    &#125;    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">insert</span><span class="params">(Thread thread, Lock lock)</span> &#123;        lock.lock();        <span class="keyword">try</span> &#123;            System.out.println(thread.getName()+<span class="string">&quot;得到了锁&quot;</span>);            <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;<span class="number">5</span>;i++) &#123;                arrayList.add(i);            &#125;        &#125; <span class="keyword">catch</span> (Exception e) &#123;            <span class="comment">// <span class="doctag">TODO:</span> handle exception</span>        &#125;<span class="keyword">finally</span> &#123;            System.out.println(thread.getName()+<span class="string">&quot;释放了锁&quot;</span>);            lock.unlock();        &#125;    &#125;    <span class="comment">/**</span><span class="comment">     * 计算总数</span><span class="comment">     */</span>    <span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">count</span><span class="params">()</span> &#123;        <span class="type">int</span> <span class="variable">size</span> <span class="operator">=</span> arrayList.size();        System.out.println(<span class="string">&quot;总数为：&quot;</span> + size);    &#125;&#125;</code></pre><p><strong>运行结果</strong></p><pre><code class="highlight shell">Thread-0得到了锁Thread-0释放了锁Thread-1得到了锁Thread-1释放了锁</code></pre><h1 id="四、ReadWriteLock-读写锁"><a href="#四、ReadWriteLock-读写锁" class="headerlink" title="四、ReadWriteLock 读写锁"></a>四、ReadWriteLock 读写锁</h1><h2 id="1-乐观锁和悲观锁"><a href="#1-乐观锁和悲观锁" class="headerlink" title="1. 乐观锁和悲观锁"></a>1. 乐观锁和悲观锁</h2><p><strong>悲观锁( synchronized 键字和 Lock 的实现类都是悲观锁)</strong></p><ul><li><p>什么是悲观锁？认为自己在使用数据的时候一定有别的线程来修改数据，因此在获取数据的时候会先加锁，确保数据不会被别的线程修改，这样别人想拿数据就被挡住，直到悲观锁被释放，悲观锁中的共享资源每次只给一个线程使用，其它线程阻塞，用完后再把资源转让给其它线程</p></li><li><p>但是在效率方面，处理加锁的机制会产生额外的开销，还有增加产生<strong>死锁</strong>的机会。另外还会降低并行性，如果已经锁定了一个线程A，其他线程就必须等待该线程A处理完才可以处理</p></li><li><p>悲观锁适合写操作多的场景，先加锁可以保证写操作时数据正确(写操作包括增删改)、显式的锁定之后再操作同步资源</p><p><code>synchronized</code>关键字和<code>Lock</code>的实现类都是悲观锁，<strong>数据库中的行锁，表锁，读锁(共享锁)，写锁(排他锁)，均为悲观锁，表锁会发生死锁，读锁和写锁都会发生死锁现象。</strong></p></li><li><p>悲观锁不支持并发</p></li></ul><p><img src="https://raw.githubusercontent.com/GeorgeChan95/blogimg/master/img/2024/09/03/20240903-195057.png" alt="悲观锁"></p><p><strong>乐观锁</strong></p><ul><li>概念：乐观锁认为自己在使用数据时不会有别的线程修改数据，所以不会添加锁，只是在更新数据的时候去判断之前有没有别的线程更新了这个数据。如果这个数据没有被更新,当前线程将自己修改的数据成功写入。如果数据已经被其他线程更新，则根据不同的实现方式执行不同的操作</li><li>乐观锁在Java中通过使用无锁编程来实现，最常采用的是CAS算法，Java原子类中的递增操作就通过CAS自旋实现的，适合读操作多的场景，不加锁的特点能够使其读操作的性能大幅度提升</li></ul><p><img src="https://raw.githubusercontent.com/GeorgeChan95/blogimg/master/img/2024/09/03/20240903-195152.png" alt="乐观锁"></p><p><strong>乐观锁一般有两种实现方式</strong></p><ul><li>采用版本号机制</li><li>CAS算法实现</li></ul><pre><code class="highlight java"><span class="comment">//悲观锁的调用方式</span><span class="keyword">public</span> <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title function_">m1</span><span class="params">()</span> &#123;    <span class="comment">//加锁后的业务逻辑</span>&#125;<span class="comment">//保证多个线程使用的是同一个lock对象的前提下</span><span class="type">ReetrantLock</span> <span class="variable">lock</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ReentrantLock</span>();<span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">m2</span><span class="params">()</span>&#123;    lock.lock();    <span class="keyword">try</span> &#123;        <span class="comment">//操作同步资源</span>    &#125; <span class="keyword">finally</span> &#123;        lock.unlock();    &#125;&#125;<span class="comment">//乐观锁的调用方式</span><span class="comment">//保证多个线程使用的是同一个AtomicInteger</span><span class="keyword">private</span>  AtomicInteger atomicIntege=<span class="keyword">new</span> <span class="title class_">AtomicInteger</span>();atomicIntege.incrementAndGet();</code></pre><h2 id="2-读写锁ReadWriteLock"><a href="#2-读写锁ReadWriteLock" class="headerlink" title="2. 读写锁ReadWriteLock"></a>2. 读写锁ReadWriteLock</h2><h3 id="2-1-读写锁概述"><a href="#2-1-读写锁概述" class="headerlink" title="2.1 读写锁概述"></a>2.1 读写锁概述</h3><p>我们开发中应该能够遇到这样的一种情况，对共享资源有读和写的操作，且写操作没有读操作那么频繁。在没有写操作的时候，多个线程同时读一个资源没有任何问题，所以应该<strong>允许多个线程同时读取共享资源</strong>；但是当一个<strong>写者线程在写这些共享资源时，就不允许其他线程进行访问</strong>。</p><p>读写锁实际是一种特殊的自旋锁，它把对共享资源的访问者划分成读者和写者，读者只对共享资源进行读访问，写者则需要对共享资源进行写操作。我们将读操作相关的锁，称为读锁，因为可以共享读，我们也称为“<strong>共享锁</strong>”，将写操作相关的锁，称为<strong>写锁、排他锁、独占锁</strong>。<strong>每次可以多个线程的读者进行读访问，但是一次只能由一个写者线程进行写操作，即写操作是独占式的。</strong></p><p>读写锁适合于对数据结构的读次数比写次数多得多的情况。因为读模式锁定时可以共享, 以写模式锁住时意味着独占, 所以读写锁又叫<strong>共享-独占锁</strong>。</p><h3 id="2-2-ReadWriteLock读写锁"><a href="#2-2-ReadWriteLock读写锁" class="headerlink" title="2.2 ReadWriteLock读写锁"></a>2.2 ReadWriteLock读写锁</h3><p>针对上面这种场景，Java的并发包下提供了读写锁 <code>ReadWriteLock</code>（接口） | <code>ReentrantReadWriteLock</code>（实现类）。</p><p><code>ReadWriteLock</code> 维护了一对相关的锁，一个用于只读操作， 另一个用于写入操作。<strong>只要没有 writer</strong>，<strong>读取锁可以由多个 reader 线程同时保持</strong>。写入锁是<strong>独占</strong>的。</p><pre><code class="highlight java"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">ReadWriteLock</span> &#123;<span class="comment">// 读锁</span>    Lock <span class="title function_">readLock</span><span class="params">()</span>;<span class="comment">// 写锁</span>    Lock <span class="title function_">writeLock</span><span class="params">()</span>;&#125;</code></pre><p>ReadWriteLock 读取操作通常不会改变共享资源，<strong>但执行写入操作时，必须独占方式来获取锁</strong>。</p><ul><li>对于读取操作占多数的数据结构。 <strong>ReadWriteLock 能提供比独占锁更高的并发性</strong>。</li><li>而对于只读的数据结构，其中包含的不变性可以完全不需要考虑加锁操作。</li><li>读&#x2F;写锁使用后都需要分别关闭，跟<code>Lock</code>最后也需要手动关闭是一样一样的。</li><li>ReadWriteLock是比<code>lock</code>锁更加细粒度的控制</li></ul><h3 id="2-3-ReentrantReadWriteLock实现类"><a href="#2-3-ReentrantReadWriteLock实现类" class="headerlink" title="2.3 ReentrantReadWriteLock实现类"></a>2.3 ReentrantReadWriteLock实现类</h3><p><code>ReentrantReadWriteLock</code>实现了<code>ReadWriteLock</code>接口，下面是它的源码</p><pre><code class="highlight java"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ReentrantReadWriteLock</span> <span class="keyword">implements</span> <span class="title class_">ReadWriteLock</span>,java.io.Serializable &#123;    <span class="comment">/** 读锁 */</span>    <span class="keyword">private</span> <span class="keyword">final</span> ReentrantReadWriteLock.ReadLock readerLock;    <span class="comment">/** 写锁 */</span>    <span class="keyword">private</span> <span class="keyword">final</span> ReentrantReadWriteLock.WriteLock writerLock;    <span class="keyword">final</span> Sync sync;    <span class="comment">/** 使用默认（非公平）的排序属性创建一个新的</span><span class="comment">ReentrantReadWriteLock */</span>    <span class="keyword">public</span> <span class="title function_">ReentrantReadWriteLock</span><span class="params">()</span> &#123;        <span class="built_in">this</span>(<span class="literal">false</span>);    &#125;    <span class="comment">/** 使用给定的公平策略创建一个新的 ReentrantReadWriteLock */</span>    <span class="keyword">public</span> <span class="title function_">ReentrantReadWriteLock</span><span class="params">(<span class="type">boolean</span> fair)</span> &#123;        sync = fair ? <span class="keyword">new</span> <span class="title class_">FairSync</span>() : <span class="keyword">new</span> <span class="title class_">NonfairSync</span>();        readerLock = <span class="keyword">new</span> <span class="title class_">ReadLock</span>(<span class="built_in">this</span>);        writerLock = <span class="keyword">new</span> <span class="title class_">WriteLock</span>(<span class="built_in">this</span>);    &#125;    <span class="comment">/** 返回用于写入操作的锁 */</span>    <span class="keyword">public</span> ReentrantReadWriteLock.WriteLock <span class="title function_">writeLock</span><span class="params">()</span> &#123; <span class="keyword">return</span>        writerLock; &#125;    <span class="comment">/** 返回用于读取操作的锁 */</span>    <span class="keyword">public</span> ReentrantReadWriteLock.ReadLock <span class="title function_">readLock</span><span class="params">()</span> &#123; <span class="keyword">return</span>        readerLock; &#125;    <span class="keyword">abstract</span> <span class="keyword">static</span> <span class="keyword">class</span> <span class="title class_">Sync</span> <span class="keyword">extends</span> <span class="title class_">AbstractQueuedSynchronizer</span> &#123;&#125;    <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">class</span> <span class="title class_">NonfairSync</span> <span class="keyword">extends</span> <span class="title class_">Sync</span> &#123;&#125;    <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">class</span> <span class="title class_">FairSync</span> <span class="keyword">extends</span> <span class="title class_">Sync</span> &#123;&#125;    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">class</span> <span class="title class_">ReadLock</span> <span class="keyword">implements</span> <span class="title class_">Lock</span>, java.io.Serializable &#123;&#125;    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">class</span> <span class="title class_">WriteLock</span> <span class="keyword">implements</span> <span class="title class_">Lock</span>, java.io.Serializable &#123;&#125;&#125;</code></pre><h3 id="2-4-读写锁注意点"><a href="#2-4-读写锁注意点" class="headerlink" title="2.4 读写锁注意点"></a>2.4 读写锁注意点</h3><p>当读写锁是<strong>写加锁状态</strong>时, 在这个锁被解锁之前, 所有试图对这个锁加锁的线程都会被阻塞</p><p>当读写锁在<strong>读加锁状态</strong>时，所有试图以读模式对它进行加锁的线程都可以得到访问权，但是如果线程希望以写模式对此锁进行加锁, 它必须直到所有的线程释放锁.</p><p><strong>线程想要进入读锁的前提条件：</strong></p><ul><li>不存在其他线程的写锁</li><li>没有写请求, 或者有写请求，但调用线程和持有锁的线程是同一个(可重入锁)</li></ul><p><strong>线程进入写锁的前提条件：</strong></p><ul><li>没有读者线程正在访问</li><li>没有其他写者线程正在访问</li></ul><p><strong>通常, 当读写锁处于读模式锁住状态时，如果有另外线程试图以写模式加锁，读写锁通常会阻塞随后的读模式锁请求，这样可以避免读模式锁长期占用，而等待的写模式锁请求长期阻塞</strong></p><h3 id="2-5-读写锁的特点"><a href="#2-5-读写锁的特点" class="headerlink" title="2.5 读写锁的特点"></a>2.5 读写锁的特点</h3><ul><li><strong>公平选择性：</strong><ul><li>非公平模式（默认）<ul><li>当以非公平初始化时，读锁和写锁的获取的顺序是不确定的。非公平锁主张竞争获取，可能会延缓一个或多个读或写线程，但是会比公平锁有更高的吞吐量。</li></ul></li><li>公平模式<ul><li>当以公平模式初始化时，线程将会以队列的顺序获取锁。当当前线程释放锁后，等待时间最长的写锁线程就会被分配写锁；或者有一组读线程组等待时间比写线程长，那么这组读线程组将会被分配读锁。</li><li>当有写线程持有写锁或者有等待的写线程时，一个尝试获取公平的读锁（非重入）的线程就会阻塞。这个线程直到等待时间最长的写锁获得锁后并释放掉锁后才能获取到读锁。</li></ul></li></ul></li><li><strong>可重入</strong><ul><li>读锁和写锁都支持线程重进入。但是写锁可以获得读锁，读锁不能获得写锁。因为读锁是共享的，写锁是独占式的。</li></ul></li><li><strong>锁降级</strong><ul><li>遵循获取写锁、获取读锁再释放写锁的次序，写锁能够降级成为读锁。</li></ul></li><li><strong>支持中断锁的获取</strong><ul><li>在读锁和写锁的获取过程中支持中断</li></ul></li><li><strong>监控</strong><ul><li>提供一些辅助方法，例如hasQueuedThreads方法查询是否有线程正在等待获取读锁或写锁、isWriteLocked方法查询写锁是否被任何线程持有等等</li></ul></li></ul><h3 id="2-6-案例演示"><a href="#2-6-案例演示" class="headerlink" title="2.6 案例演示"></a>2.6 案例演示</h3><p>场景：我们通过一个缓存的小案例来，在没有使用锁的情况下，实现存储和读取的功能，并通过在多个线程的并发下。：使用 ReentrantReadWriteLock 对一个 hashmap 集合进行读和写的并发操作</p><p><strong>volatile关键字</strong>：表示数据会不断发生变化，多个线程可见性，禁止指令重排序</p><blockquote><p>没有锁的情况</p></blockquote><pre><code class="highlight java"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ReentrantReadWriteLockDemo</span> &#123;    <span class="comment">//创建 map 集合</span>    <span class="keyword">private</span> <span class="keyword">volatile</span> Map&lt;String, Object&gt; map = <span class="keyword">new</span> <span class="title class_">HashMap</span>&lt;&gt;();    <span class="comment">//放数据</span>    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">put</span><span class="params">(String key, Object value)</span> &#123;        System.out.println(Thread.currentThread().getName() + <span class="string">&quot;正在写数据&quot;</span> + key);        <span class="comment">//放数据</span>        map.put(key, value);        System.out.println(Thread.currentThread().getName() + <span class="string">&quot;写完了&quot;</span> + key);    &#125;    <span class="comment">//取数据</span>    <span class="keyword">public</span> Object <span class="title function_">get</span><span class="params">(String key)</span> &#123;        <span class="type">Object</span> <span class="variable">result</span> <span class="operator">=</span> <span class="literal">null</span>;        System.out.println(Thread.currentThread().getName() + <span class="string">&quot;正在取数据&quot;</span> + key);        <span class="comment">//        TimeUnit.MICROSECONDS.sleep(300);</span>        result = map.get(key);        System.out.println(Thread.currentThread().getName() + <span class="string">&quot;取完数据了&quot;</span> + key);        <span class="keyword">return</span> result;    &#125;    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;        <span class="type">ReentrantReadWriteLockDemo</span> <span class="variable">demo</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ReentrantReadWriteLockDemo</span>();        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">1</span>; i &lt;= <span class="number">5</span>; i++) &#123;            <span class="keyword">final</span> <span class="type">int</span> <span class="variable">number</span> <span class="operator">=</span> i;            <span class="keyword">new</span> <span class="title class_">Thread</span>(() -&gt; &#123;<span class="comment">//5个线程放数据</span>                demo.put(String.valueOf(number), number);            &#125;, String.valueOf(i)).start();        &#125;        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">1</span>; i &lt;= <span class="number">5</span>; i++) &#123;            <span class="keyword">final</span> <span class="type">int</span> <span class="variable">number</span> <span class="operator">=</span> i;            <span class="keyword">new</span> <span class="title class_">Thread</span>(() -&gt; &#123;<span class="comment">//5个线程取数据</span>                demo.get(String.valueOf(number));            &#125;, String.valueOf(i)).start();        &#125;    &#125;&#125;</code></pre><p><strong>执行结果：</strong></p><pre><code class="highlight shell">1正在取数据12正在取数据24正在写数据43正在写数据33正在取数据32取完数据了24正在取数据41取完数据了14取完数据了42正在写数据23取完数据了34写完了41正在写数据13写完了32写完了25正在取数据51写完了15取完数据了55正在写数据55写完了5</code></pre><p>可以看出在一个写线程写数据的时候，有其他线程进入，这显然是不行的。</p><blockquote><p><strong>使用ReadWriteLock读&#x2F;写锁解决缓存并发问题</strong></p></blockquote><pre><code class="highlight java"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ReentrantReadWriteLockDemo</span> &#123;    <span class="comment">//创建 map 集合</span>    <span class="keyword">private</span> <span class="keyword">volatile</span> Map&lt;String, Object&gt; map = <span class="keyword">new</span> <span class="title class_">HashMap</span>&lt;&gt;();    <span class="comment">//创建读写锁对象</span>    <span class="keyword">private</span> <span class="type">ReadWriteLock</span> <span class="variable">rwLock</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ReentrantReadWriteLock</span>();    <span class="comment">//放数据</span>    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">put</span><span class="params">(String key, Object value)</span> &#123;        <span class="comment">//添加写锁</span>        rwLock.writeLock().lock();        <span class="keyword">try</span> &#123;            System.out.println(Thread.currentThread().getName() + <span class="string">&quot;正在写数据&quot;</span> + key);            <span class="comment">//暂停一会</span>            TimeUnit.MICROSECONDS.sleep(<span class="number">300</span>);            <span class="comment">//放数据</span>            map.put(key, value);            System.out.println(Thread.currentThread().getName() + <span class="string">&quot;写完了&quot;</span> + key);        &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;            e.printStackTrace();        &#125; <span class="keyword">finally</span> &#123;            <span class="comment">//释放写锁</span>            rwLock.writeLock().unlock();        &#125;    &#125;    <span class="comment">//取数据</span>    <span class="keyword">public</span> Object <span class="title function_">get</span><span class="params">(String key)</span> &#123;        <span class="comment">//添加读锁</span>        rwLock.readLock().lock();        <span class="type">Object</span> <span class="variable">result</span> <span class="operator">=</span> <span class="literal">null</span>;        <span class="keyword">try</span> &#123;            System.out.println(Thread.currentThread().getName() + <span class="string">&quot;正在取数据&quot;</span> + key);            <span class="comment">//暂停一会</span>            TimeUnit.MICROSECONDS.sleep(<span class="number">300</span>);            result = map.get(key);            System.out.println(Thread.currentThread().getName() + <span class="string">&quot;取完数据了&quot;</span> + key);        &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;            e.printStackTrace();        &#125; <span class="keyword">finally</span> &#123;            <span class="comment">//释放读锁</span>            rwLock.readLock().unlock();        &#125;        <span class="keyword">return</span> result;    &#125;    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;        <span class="type">ReentrantReadWriteLockDemo</span> <span class="variable">demo</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ReentrantReadWriteLockDemo</span>();        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">1</span>; i &lt;= <span class="number">5</span>; i++) &#123;            <span class="keyword">final</span> <span class="type">int</span> <span class="variable">number</span> <span class="operator">=</span> i;            <span class="keyword">new</span> <span class="title class_">Thread</span>(() -&gt; &#123;<span class="comment">//5个线程放数据</span>                demo.put(String.valueOf(number), number);            &#125;, String.valueOf(i)).start();        &#125;        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">1</span>; i &lt;= <span class="number">5</span>; i++) &#123;            <span class="keyword">final</span> <span class="type">int</span> <span class="variable">number</span> <span class="operator">=</span> i;            <span class="keyword">new</span> <span class="title class_">Thread</span>(() -&gt; &#123;<span class="comment">//5个线程取数据</span>                demo.get(String.valueOf(number));            &#125;, String.valueOf(i)).start();        &#125;    &#125;&#125;</code></pre><p><strong>执行结果：</strong></p><pre><code class="highlight shell">1正在写数据11写完了12正在写数据22写完了23正在写数据33写完了34正在写数据44写完了45正在写数据55写完了51正在取数据12正在取数据24正在取数据43正在取数据35正在取数据52取完数据了21取完数据了15取完数据了53取完数据了34取完数据了4</code></pre><p>从结果可以看出，写操作是唯一独占的，多个线程不能同时写，必须等一个线程写完了另外一个线程才能进去，而读的时候是共享的，多个线程可以一起读数据。</p><h3 id="2-7-总结-重点"><a href="#2-7-总结-重点" class="headerlink" title="2.7 总结(重点)"></a>2.7 总结(重点)</h3><p>与传统锁不同的是读写锁的规则是可以共享读，但只能一个写，即不能同时存在读写线程，总结起来为：读读不互斥，读写互斥，写写互斥。而一般的传统独占锁是：读读互斥，读写互斥，写写互斥，而场景中往往读远远大于写，读写锁就是为了这种优化而创建出来的一种机制。注意是读远远大于写，一般情况下独占锁的效率低来源于高并发下对临界区的激烈竞争导致线程上下文切换。因此当并发不是很高的情况下，读写锁由于需要额外维护读锁的状态，可能还不如独占锁的效率高。因此需要根据实际情况选择使用。</p><ul><li><strong>ReentrantReadWriteLock和Synchonized、ReentrantLock比较起来有哪些区别呢？或者有哪些优势呢？</strong></li><li>Synchonized、ReentrantLock是属于传统独占锁，读、写操作每次都只能是一个人访问，效率比较低。</li><li>而ReentrantReadWriteLock读操作可以共享，提升性能，允许多人一起读操作，而写操作还是每次一个人访问。</li><li>当然ReentrantReadWriteLock优势是有，但是也存在一些缺陷，容易造成<strong>锁饥饿</strong>，因为如果是读线程先拿到锁的话，并且后续有很多读线程，但只有一个写线程，很有可能这个写线程拿不到锁，它可能要等到所有读线程读完才能进入，就可能会造成一种一直读，没有写的现象。</li></ul><h2 id="3-锁降级"><a href="#3-锁降级" class="headerlink" title="3. 锁降级"></a>3. 锁降级</h2><h3 id="3-1-概述"><a href="#3-1-概述" class="headerlink" title="3.1 概述"></a>3.1 概述</h3><p><strong>概念：</strong></p><p>锁降级的意思就是<strong>写锁降级为读锁</strong>。而读锁是不可以升级为写锁的。如果当前线程拥有写锁，然后将其释放，最后再获取读锁，这种分段完成的过程不能称之为锁降级。锁降级是指把持住（当前拥有的）写锁，再获取到读锁，随后释放（先前拥有的）写锁的过程，最后释放读锁的过程。</p><p><strong>编程模型：</strong></p><p>获取写锁—&gt;获取读锁—&gt;释放写锁—&gt;释放读锁</p><p><strong>代码演示</strong></p><pre><code class="highlight java"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ReadWriteLockDemo2</span> &#123;    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;        <span class="type">ReentrantReadWriteLock</span> <span class="variable">reentrantReadWriteLock</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ReentrantReadWriteLock</span>();        <span class="comment">// 获取读锁</span>        ReentrantReadWriteLock.<span class="type">WriteLock</span> <span class="variable">writeLock</span> <span class="operator">=</span> reentrantReadWriteLock.writeLock();        <span class="comment">// 获取写锁</span>        ReentrantReadWriteLock.<span class="type">ReadLock</span> <span class="variable">readLock</span> <span class="operator">=</span> reentrantReadWriteLock.readLock();                <span class="comment">//1、获取到写锁</span>        writeLock.lock();        System.out.println(<span class="string">&quot;获取到了写锁&quot;</span>);                <span class="comment">//2、获取到读锁</span>        readLock.lock();        System.out.println(<span class="string">&quot;继续获取到读锁&quot;</span>);        <span class="comment">//3、释放写锁</span>        writeLock.unlock();   <span class="comment">//4、 释放读锁</span>        readLock.unlock();    &#125;&#125;</code></pre><p>结果：</p><pre><code class="highlight shell">获取到了写锁继续获取到读锁</code></pre><p>也许大家觉得看不出什么，但是如果将获取读锁那一行代码调到获取写锁上方去，可能结果就完全不一样拉。</p><pre><code class="highlight java"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ReadWriteLockDemo2</span> &#123;    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;        <span class="type">ReentrantReadWriteLock</span> <span class="variable">reentrantReadWriteLock</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ReentrantReadWriteLock</span>();        <span class="comment">// 获取读锁</span>        ReentrantReadWriteLock.<span class="type">WriteLock</span> <span class="variable">writeLock</span> <span class="operator">=</span> reentrantReadWriteLock.writeLock();        <span class="comment">// 获取写锁</span>        ReentrantReadWriteLock.<span class="type">ReadLock</span> <span class="variable">readLock</span> <span class="operator">=</span> reentrantReadWriteLock.readLock();        <span class="comment">//1、 获取到读锁</span>        readLock.lock();        System.out.println(<span class="string">&quot;获取到了读锁&quot;</span>);        writeLock.lock();        System.out.println(<span class="string">&quot;继续获取到写锁&quot;</span>);        writeLock.unlock();        readLock.unlock();    &#125;&#125;</code></pre><p>结果：执行到读锁就停止了，即读锁不能升级为写锁。</p><pre><code class="highlight shell">获取到了读锁</code></pre><p><strong>原因：</strong></p><p>因为在线程持有读锁的情况下，该线程不能取得写锁（因为获取写锁的前提条件是，当前没有读者线程，也没有其他写者线程，如果发现当前的读锁被占用，就马上获取失败，不管读锁是不是被当前线程持有)。</p><p>但是在线程持有写锁的情况下，该线程可以继续获取读锁（获取读锁时如果发现写锁被占用，只有写锁没有被当前线程占用的情况才会获取失败）。</p><p>当线程获取读锁的时候，可能有其他线程同时也在持有读锁，因此不能把获取读锁的线程“升级”为写锁；而对于获得写锁的线程，它一定独占了读写锁，因此可以继续让它获取读锁，当它同时获取了写锁和读锁后，还可以先释放写锁继续持有读锁，这样一个写锁就“降级”为了读锁。</p><h3 id="3-2-使用场景"><a href="#3-2-使用场景" class="headerlink" title="3.2 使用场景"></a>3.2 使用场景</h3><p>对于数据比较敏感, 需要在对数据修改以后, 获取到修改后的值, 并进行接下来的其它操作.</p><p>我们来看个比较实在的案例：</p><pre><code class="highlight java"><span class="keyword">import</span> java.util.HashMap;<span class="keyword">import</span> java.util.Map;<span class="keyword">import</span> java.util.concurrent.locks.Lock;<span class="keyword">import</span> java.util.concurrent.locks.ReadWriteLock;<span class="keyword">import</span> java.util.concurrent.locks.ReentrantReadWriteLock;<span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">CacheDemo</span> &#123;    <span class="comment">/**</span><span class="comment">     * 缓存器,这里假设需要存储1000左右个缓存对象，按照默认的负载因子0.75，则容量=750，大概估计每一个节点链表长度为5个</span><span class="comment">     * 那么数组长度大概为：150,又有雨设置map大小一般为2的指数，则最近的数字为：128</span><span class="comment">     */</span>    <span class="keyword">private</span> Map&lt;String, Object&gt; map = <span class="keyword">new</span> <span class="title class_">HashMap</span>&lt;&gt;(<span class="number">128</span>);    <span class="keyword">private</span> <span class="type">ReadWriteLock</span> <span class="variable">rwl</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ReentrantReadWriteLock</span>();    <span class="keyword">private</span> Lock writeLock=rwl.writeLock();    <span class="keyword">private</span> Lock readLock=rwl.readLock();    <span class="keyword">public</span> Object <span class="title function_">get</span><span class="params">(String id)</span> &#123;        <span class="type">Object</span> <span class="variable">value</span> <span class="operator">=</span> <span class="literal">null</span>;        readLock.lock();<span class="comment">//首先开启读锁，从缓存中去取</span>        <span class="keyword">try</span> &#123;            <span class="comment">//如果缓存中没有  释放读锁，上写锁</span>            <span class="keyword">if</span> (map.get(id) == <span class="literal">null</span>) &#123;                 readLock.unlock();                writeLock.lock();                <span class="keyword">try</span> &#123;                    <span class="comment">//防止多写线程重复查询赋值</span>                    <span class="keyword">if</span> (value == <span class="literal">null</span>) &#123;                        <span class="comment">//此时可以去数据库中查找，这里简单的模拟一下</span>                        value = <span class="string">&quot;redis-value&quot;</span>;                      &#125;                    <span class="comment">//加读锁降级写锁,不明白的可以查看上面锁降级的原理与保持读取数据原子性的讲解</span>                    readLock.lock();                 &#125; <span class="keyword">finally</span> &#123;                    <span class="comment">//释放写锁</span>                    writeLock.unlock();                 &#125;            &#125;        &#125; <span class="keyword">finally</span> &#123;            <span class="comment">//最后释放读锁</span>            readLock.unlock();         &#125;        <span class="keyword">return</span> value;    &#125;&#125;</code></pre><p>如果不使用锁降级功能，如先释放写锁，然后获得读锁，在这个获取读锁的过程中，可能会有其他线程竞争到写锁 或者是更新数据 则获得的数据是其他线程更新的数据，可能会造成数据的污染，即产生脏读的问题。</p><h3 id="3-4-锁降级的必要性"><a href="#3-4-锁降级的必要性" class="headerlink" title="3.4 锁降级的必要性"></a>3.4 锁降级的必要性</h3><p>锁降级中读锁的获取是否必要呢？</p><p>答案是必要的。主要是为了保证数据的可见性，如果当前线程不获取读锁而是直接释放写锁， 假设此刻另一个线程（记作线程T）获取了写锁并修改了数据，那么当前线程无法感知线程T的数据更新。如果当前线程获取读锁，即遵循锁降级的步骤，则线程T将会被阻塞，直到当前线程使用数据并释放读锁之后，线程T才能获取写锁进行数据更新。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;一、Synchronized&quot;&gt;&lt;a href=&quot;#一、Synchronized&quot; class=&quot;headerlink&quot; title=&quot;一、Synchronized&quot;&gt;&lt;/a&gt;一、Synchronized&lt;/h1&gt;&lt;h2 id=&quot;1-Synchronized-关键</summary>
      
    
    
    
    <category term="JUC" scheme="https://georgechan95.github.io/categories/JUC/"/>
    
    
    <category term="juc" scheme="https://georgechan95.github.io/tags/juc/"/>
    
    <category term="java" scheme="https://georgechan95.github.io/tags/java/"/>
    
  </entry>
  
  <entry>
    <title>01-多线程的基本概念</title>
    <link href="https://georgechan95.github.io/blog/4e6bd685.html"/>
    <id>https://georgechan95.github.io/blog/4e6bd685.html</id>
    <published>2024-08-30T11:03:01.000Z</published>
    <updated>2024-08-31T03:39:29.138Z</updated>
    
    <content type="html"><![CDATA[<h1 id="一、进程和线程"><a href="#一、进程和线程" class="headerlink" title="一、进程和线程"></a>一、进程和线程</h1><ul><li>进程（Process）是计算机中的程序关于某数据集合上的一次运行活动，是系统进行资源分配和调度的基本单位，是操作系统结构的基础。在早期面向进程设计的计算机结构中，进程是程序的基本执行实体；在当代面向线程设计的计算机结构中，进程是线程的容器。程序是指令、数据及其组织形式的描述，进程是程序的实体。</li><li>线程（thread）是操作系统能够进行运算调度的最小单位。它被包含在进程之中，是进程中的实际运作单位。一条线程指的是进程中一个单一顺序的控制流，一个进程中可以并发多个线程，每条线程并行执行不同的任务。</li></ul><p>总结来说：</p><ul><li>进程：指在系统中正在运行的一个应用程序；程序一旦运行就是进程；进程是资源分配的最小单位</li><li>线程：系统分配处理器时间资源的基本单元，或者说进程之内独立执行的一个单元执行流。线程时程序执行的最小单位</li></ul><h1 id="二、线程的状态"><a href="#二、线程的状态" class="headerlink" title="二、线程的状态"></a>二、线程的状态</h1><p>进入 java.lang.Thread 类，找到内部类 State ，代码如下</p><pre><code class="highlight java"><span class="keyword">public</span> <span class="keyword">enum</span> <span class="title class_">State</span> &#123;        <span class="comment">/**</span><span class="comment">         * Thread state for a thread which has not yet started.</span><span class="comment">         */</span>        NEW,(新建)        <span class="comment">/**</span><span class="comment">         * Thread state for a runnable thread.  A thread in the runnable</span><span class="comment">         * state is executing in the Java virtual machine but it may</span><span class="comment">         * be waiting for other resources from the operating system</span><span class="comment">         * such as processor.</span><span class="comment">         */</span>        RUNNABLE,（准备就绪）        <span class="comment">/**</span><span class="comment">         * Thread state for a thread blocked waiting for a monitor lock.</span><span class="comment">         * A thread in the blocked state is waiting for a monitor lock</span><span class="comment">         * to enter a synchronized block/method or</span><span class="comment">         * reenter a synchronized block/method after calling</span><span class="comment">         * &#123;<span class="doctag">@link</span> Object#wait() Object.wait&#125;.</span><span class="comment">         */</span>        BLOCKED,（阻塞）        <span class="comment">/**</span><span class="comment">         * Thread state for a waiting thread.</span><span class="comment">         * A thread is in the waiting state due to calling one of the</span><span class="comment">         * following methods:</span><span class="comment">         * &lt;ul&gt;</span><span class="comment">         *   &lt;li&gt;&#123;<span class="doctag">@link</span> Object#wait() Object.wait&#125; with no timeout&lt;/li&gt;</span><span class="comment">         *   &lt;li&gt;&#123;<span class="doctag">@link</span> #join() Thread.join&#125; with no timeout&lt;/li&gt;</span><span class="comment">         *   &lt;li&gt;&#123;<span class="doctag">@link</span> LockSupport#park() LockSupport.park&#125;&lt;/li&gt;</span><span class="comment">         * &lt;/ul&gt;</span><span class="comment">         *</span><span class="comment">         * &lt;p&gt;A thread in the waiting state is waiting for another thread to</span><span class="comment">         * perform a particular action.</span><span class="comment">         *</span><span class="comment">         * For example, a thread that has called &lt;tt&gt;Object.wait()&lt;/tt&gt;</span><span class="comment">         * on an object is waiting for another thread to call</span><span class="comment">         * &lt;tt&gt;Object.notify()&lt;/tt&gt; or &lt;tt&gt;Object.notifyAll()&lt;/tt&gt; on</span><span class="comment">         * that object. A thread that has called &lt;tt&gt;Thread.join()&lt;/tt&gt;</span><span class="comment">         * is waiting for a specified thread to terminate.</span><span class="comment">         */</span>        WAITING,（不限时间等待）        <span class="comment">/**</span><span class="comment">         * Thread state for a waiting thread with a specified waiting time.</span><span class="comment">         * A thread is in the timed waiting state due to calling one of</span><span class="comment">         * the following methods with a specified positive waiting time:</span><span class="comment">         * &lt;ul&gt;</span><span class="comment">         *   &lt;li&gt;&#123;<span class="doctag">@link</span> #sleep Thread.sleep&#125;&lt;/li&gt;</span><span class="comment">         *   &lt;li&gt;&#123;<span class="doctag">@link</span> Object#wait(long) Object.wait&#125; with timeout&lt;/li&gt;</span><span class="comment">         *   &lt;li&gt;&#123;<span class="doctag">@link</span> #join(long) Thread.join&#125; with timeout&lt;/li&gt;</span><span class="comment">         *   &lt;li&gt;&#123;<span class="doctag">@link</span> LockSupport#parkNanos LockSupport.parkNanos&#125;&lt;/li&gt;</span><span class="comment">         *   &lt;li&gt;&#123;<span class="doctag">@link</span> LockSupport#parkUntil LockSupport.parkUntil&#125;&lt;/li&gt;</span><span class="comment">         * &lt;/ul&gt;</span><span class="comment">         */</span>        TIMED_WAITING,（限时等待）        <span class="comment">/**</span><span class="comment">         * Thread state for a terminated thread.</span><span class="comment">         * The thread has completed execution.</span><span class="comment">         */</span>        TERMINATED;(终结)&#125;</code></pre><ul><li>NEW,(新建)</li><li>RUNNABLE,（准备就绪）</li><li>BLOCKED,（阻塞）</li><li>WAITING,（不限时等待）</li><li>TIMED_WAITING,（限时等待）</li><li>TERMINATED;(终结)</li></ul><h1 id="三、wait和sleep"><a href="#三、wait和sleep" class="headerlink" title="三、wait和sleep"></a>三、wait和sleep</h1><ul><li>sleep 是 Thread 的静态方法，wait 是 Object 的方法，任何对象实例都能调用。</li><li>sleep 不会释放锁，它也不需要占用锁；wait会释放锁，但调用它的前提是当前线程占有锁（即代码要在synchronized中）</li><li>它们都可以被 <code>interrupt</code> 方法中断</li></ul><p><img src="https://raw.githubusercontent.com/GeorgeChan95/blogimg/master/img/2024/08/30/20240830-191847.png" alt="线程状态"></p><h1 id="四、并发与并行"><a href="#四、并发与并行" class="headerlink" title="四、并发与并行"></a>四、并发与并行</h1><ul><li>并发：同一时间间隔内多个线程正在执行，实际上是宏观上并行，微观上串行</li><li>并行：同一时刻多个线程正在执行</li></ul><h1 id="五、管程（monitor）"><a href="#五、管程（monitor）" class="headerlink" title="五、管程（monitor）"></a>五、管程（monitor）</h1><p>管程(monitor)是保证了同一时刻只有一个进程在管程内活动,即管程内定义的操作在同一时刻只被一个进程调用(由编译器实现).但是这样并不能保证进程以设计的顺序执行。</p><p>JVM 中同步是基于进入和退出管程(monitor)对象实现的，每个对象都会有一个管程(monitor)对象，管程(monitor)会随着 java 对象一同创建和销毁。</p><p>执行线程首先要持有管程对象，然后才能执行方法，当方法完成之后会释放管程，方法在执行时候会持有管程，其他线程无法再获取同一个管程</p><h1 id="六、用户线程和守护线程"><a href="#六、用户线程和守护线程" class="headerlink" title="六、用户线程和守护线程"></a>六、用户线程和守护线程</h1><ul><li><strong>用户线程</strong>：自定义线程</li><li><strong>守护线程</strong>:运行在后台,是一种特殊的线程,比如垃圾回收</li><li>当主线程结束后,用户线程还在运行,JVM 存活</li><li>如果没有用户线程,都是守护线程,JVM 结束</li></ul>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;一、进程和线程&quot;&gt;&lt;a href=&quot;#一、进程和线程&quot; class=&quot;headerlink&quot; title=&quot;一、进程和线程&quot;&gt;&lt;/a&gt;一、进程和线程&lt;/h1&gt;&lt;ul&gt;
&lt;li&gt;进程（Process）是计算机中的程序关于某数据集合上的一次运行活动，是系统进行资源分配</summary>
      
    
    
    
    <category term="JUC" scheme="https://georgechan95.github.io/categories/JUC/"/>
    
    
    <category term="juc" scheme="https://georgechan95.github.io/tags/juc/"/>
    
    <category term="java" scheme="https://georgechan95.github.io/tags/java/"/>
    
  </entry>
  
  <entry>
    <title>第二十五章-分析GC日志</title>
    <link href="https://georgechan95.github.io/blog/1b0522f4.html"/>
    <id>https://georgechan95.github.io/blog/1b0522f4.html</id>
    <published>2024-08-28T13:36:08.000Z</published>
    <updated>2024-08-28T08:47:45.286Z</updated>
    
    <content type="html"><![CDATA[<h1 id="一、GC日志参数"><a href="#一、GC日志参数" class="headerlink" title="一、GC日志参数"></a>一、GC日志参数</h1><ul><li><p><code>-verbose:gc</code></p><p>输出gc日志信息，默认输出到标准输出</p></li><li><p><code>-XX:+PrintGC</code></p><p>输出GC日志。类似：-verbose:gc</p></li><li><p><code>-XX:+PrintGCDetails</code></p><p>在发生垃圾回收时打印内存回收详细的日志，并在进程退出时输出当前内存各区域分配情况</p></li><li><p><code>-XX:+PrintGCTimeStamps</code></p><p>输出GC发生时的时间截</p></li><li><p><code>-XX:+PrintGCDateStamps</code></p><p>输出GC发生时的时间戳（以日期的形式，如 2013-05-04T21:53:59.234+0800)</p></li><li><p><code>-XX:+PrintHeapAtGC</code></p><p>每一次GC前和GC后，都打印堆信息</p></li><li><p><code>-Xloggc:&lt;file&gt;</code></p><p>表示把GC日志写入到一个文件中去，而不是打印到标准输出中</p></li></ul><h1 id="二、GC日志格式"><a href="#二、GC日志格式" class="headerlink" title="二、GC日志格式"></a>二、GC日志格式</h1><h2 id="1-GC分类"><a href="#1-GC分类" class="headerlink" title="1. GC分类"></a>1. GC分类</h2><p>针对 HotSpot VM 的实现，它里面的GC按照回收区域又分为两大种类型：一种是部分收集（Partial GC), 一种是整堆收集（Full GC)</p><h3 id="1-1-部分收集"><a href="#1-1-部分收集" class="headerlink" title="1.1 部分收集"></a>1.1 部分收集</h3><p>不是完整收集整个Java堆的垃圾收集。</p><p>其中又分为：</p><ul><li>新生代收集（Minor GC&#x2F;Young GC):只是新生代（Eden\S0,S1)的垃圾收集</li><li>老年代收集（Major GC&#x2F;old GC):只是老年代的垃圾收集。<ul><li>目前，只有CMSGC会有单独收集老年代的行为。</li><li>注意，很多时候Major GC会和Full GC混淆使用，需要具体分辨是老年代回收还是整堆回收。</li></ul></li><li>混合收集（Mixed GC):收集整个新生代以及部分老年代的垃圾收集。<ul><li>目前，只有G1GC会有这种行为</li></ul></li></ul><h3 id="1-2-整堆收集（Full-GC"><a href="#1-2-整堆收集（Full-GC" class="headerlink" title="1.2 整堆收集（Full GC)"></a>1.2 整堆收集（Full GC)</h3><p>收集整个java堆和方法区的垃圾收集。</p><p><strong>哪些情况会触发Full GC?</strong></p><ul><li>老年代空间不足</li><li>方法区空间不足</li><li>显式调用System.gc()</li><li>Minor GC进入老年代的数据的平均大小大于老年代的可用内存</li><li>大对象直接进入老年代，而老年代的可用空间不足</li></ul><h2 id="2-GC日志分类"><a href="#2-GC日志分类" class="headerlink" title="2. GC日志分类"></a>2. GC日志分类</h2><h3 id="2-1-MinorGC"><a href="#2-1-MinorGC" class="headerlink" title="2.1 MinorGC"></a>2.1 MinorGC</h3><p>MinorGC(或young GC或YGC)日志：</p><p>[GC (Allocation Failure) [PSYoungGen: 131584K-&gt;7195K(153088K)] 131584K-&gt;7203K(502784K), 0.0334432 secs] [Times: user&#x3D;0.02 sys&#x3D;0.00, real&#x3D;0.04 secs]</p><p><img src="https://raw.githubusercontent.com/GeorgeChan95/blogimg/master/img/2024/08/28/20240828-140528.png" alt="minorGC日志解析"></p><h3 id="2-2-FullGC"><a href="#2-2-FullGC" class="headerlink" title="2.2 FullGC"></a>2.2 FullGC</h3><p>[Full GC (Metadata GC Threshold) [PSYoungGen: 2848K-&gt;0K(158720K)] [ParOldGen: 32816K-&gt;19441K(349696K)] 35664K-&gt;19441K(508416K), [Metaspace: 34044K-&gt;34044K(1079296K)], 0.1156700 secs] [Times: user&#x3D;0.09 sys&#x3D;0.00, real&#x3D;0.12 secs]</p><p><img src="https://raw.githubusercontent.com/GeorgeChan95/blogimg/master/img/2024/08/28/20240828-140956.png" alt="fullGC日志解析"></p><h2 id="3-GC日志结构剖析"><a href="#3-GC日志结构剖析" class="headerlink" title="3. GC日志结构剖析"></a>3. GC日志结构剖析</h2><h3 id="3-1-垃圾收集器"><a href="#3-1-垃圾收集器" class="headerlink" title="3.1  垃圾收集器"></a>3.1  垃圾收集器</h3><ul><li>使用 <code>Serial</code> 收集器在新生代的名字是 <code>Default New Generation</code> , 因此显示的是”[DefNew”</li><li>使用 <code>ParNew</code> 收集器在新生代的名字会变成”[ParNew” , 意思是”Parallel New Generation”</li><li>使用 <code>Parallel Scavenge</code> 收集器在新生代的名字是”[PSYoungGen”,这里的JDK1.7使用的就是<code>PSYoungGen</code></li><li>使用 <code>Parallel Old Generation</code> 收集器在老年代的名字是”[ParOldGen”</li><li>使用G1收集器的话，会显示为”garbage-first heap”</li></ul><p><strong>Allocation Failure</strong></p><p>表明本次引起GC的原因是因为在年轻代中没有足够的空间能够存储新的数据了。</p><h3 id="3-2-GC前后情况"><a href="#3-2-GC前后情况" class="headerlink" title="3.2 GC前后情况"></a>3.2 GC前后情况</h3><p>通过图示，我们可以发现GC日志格式的规律一般都是：GC前内存占用 一&gt; GC后内存占用（该区域内存总大小）</p><p>[PSYoungGen: 5986K -&gt; 696K(8704K)] 5986K -&gt; 704K(9216K)</p><p>中括号内：GC回收前年轻代堆大小，回收后大小，(<strong>年轻代堆总大小</strong>）</p><p>括号外：GC回收前年轻代和老年代大小，回收后大小，(<strong>年轻代和老年代总大小</strong>）</p><h3 id="3-3-GC时间"><a href="#3-3-GC时间" class="headerlink" title="3.3 GC时间"></a>3.3 GC时间</h3><p>GC日志中有三个时间：user , sys 和 real</p><ul><li><strong>user</strong> - 进程执行用户态代码（核心之外）所使用的时间。这是执行此进程所使用的实际CPU时间，其他进程和此进程阻塞的时间并不包括在内。在垃圾收集的情况下，表示GC线程执行所使用的CPU总时间。</li><li><strong>sys</strong> - 进程在内核态消耗的CPU时间，即在内核执行系统调用或等待系统事件所使用的CPU时间</li><li><strong>real</strong> - 程序从开始到结束所用的时钟时间。这个时间包括其他进程使用的时间片和进程阻塞的时间（比如等待I&#x2F;0完成）。对于并行gc,这个数字应该接近（用户时间+系统时间）除以垃圾收集器使用的线程数。</li></ul><p>由于多核的原因，一般的GC事件中，real time是小于 <code>sys + user time</code> 的，因为一般是多个线程并发的去做 GC,所以real time是要小于 sys+user time 的。<br> 如果 <code>real &gt; sys+user</code> 的话，则你的应用可能存在下列问题：IO负载非常重 或者是CPU不够用。</p><h2 id="4-Minor-GC-日志解析"><a href="#4-Minor-GC-日志解析" class="headerlink" title="4. Minor GC 日志解析"></a>4. Minor GC 日志解析</h2><p>2024-08-28T15:09:58.253+0800: 2.004: [GC (Allocation Failure) [PSYoungGen: 138937K-&gt;7465K(153088K)] 138945K-&gt;7473K(502784K), 0.0261046 secs] [Times: user&#x3D;0.01 sys&#x3D;0.00, real&#x3D;0.03 secs]</p><ul><li><p>2024-08-28T15:09:58.253+0800</p><p><strong>日志打印时间日期格式</strong></p></li><li><p>2.004</p><p><strong>gc发生时，Java虚拟机启动以来经过的秒数</strong></p></li><li><p>[GC (Allocation Failure) </p><p><strong>发生了一次垃圾回收，这是一次MinorGC</strong></p><p>它不区分新生代还是老年代GC，括号里的内容是gc发生的原因，这里的Allocation Failure的原因是新生代中没有足够区域能够存放需要分配的数据而失败</p></li><li><p>[PSYoungGen: 138937K-&gt;7465K(153088K)] </p><ul><li>PSYoungGen：表示GC发生的区域，区域名称与使用的GC收集器是密切相关的<ul><li>Serial收集器：Default New Generation 显示Defnew</li><li>ParNew收集器：ParNew</li><li>Parallel Scanvenge收集器：PSYoung</li><li>老年代和新生代同理，也是和收集器名称相关</li></ul></li><li>138937K-&gt;7465K(153088K)：GC前该内存区域已使用容量-&gt;GC后该区域容量(该区域总容量)<ul><li>如果是新生代，总容量则会显示整个新生代内存的9&#x2F;10，即eden+from&#x2F;to区</li><li>如果是老年代，总容量则是全身内存大小，无变化</li></ul></li></ul></li><li><p>138945K-&gt;7473K(502784K)</p><p>虽然本次是Minor GC，只会进行新生代的垃圾收集，但是也肯定会打印堆中总容量相关信息</p><p>在显示完区域容量GC的情况之后，会接着显示整个堆内存区域的GC情况：GC前堆内存已使用容量-&gt;GC后堆内存容量（堆内存总容量），并且堆内存总容量 &#x3D; 9&#x2F;10 新生代 + 老年代，然后堆内存总容量肯定小于初始化的内存大小</p></li><li><p>0.0261046 secs</p><p>整个GC所花费的时间，单位是秒</p></li><li><p>[Times: user&#x3D;0.01 sys&#x3D;0.00, real&#x3D;0.03 secs]</p><ul><li>user：指CPU工作在用户态所花费的时间</li><li>sys：指CPU工作在内核态所花费的时间</li><li>real：指在此次事件中所花费的总时间</li></ul></li></ul><h2 id="5-Full-GC-日志解析"><a href="#5-Full-GC-日志解析" class="headerlink" title="5. Full GC 日志解析"></a>5. Full GC 日志解析</h2><p>2024-08-28T15:10:01.578+0800: 5.329: [Full GC (Metadata GC Threshold) [PSYoungGen: 3264K-&gt;0K(163840K)] [ParOldGen: 6227K-&gt;7621K(349696K)] 9491K-&gt;7621K(513536K), [Metaspace: 20472K-&gt;20472K(1067008K)], 0.0627380 secs] [Times: user&#x3D;0.04 sys&#x3D;0.00, real&#x3D;0.06 secs]</p><h3 id="5-1-日志分解与解释"><a href="#5-1-日志分解与解释" class="headerlink" title="5.1 日志分解与解释"></a>5.1 日志分解与解释</h3><pre><code class="highlight plaintext">2024-08-28T15:10:01.578+0800: 5.329: [Full GC (Metadata GC Threshold) [PSYoungGen: 3264K-&gt;0K(163840K)] [ParOldGen: 6227K-&gt;7621K(349696K)] 9491K-&gt;7621K(513536K), [Metaspace: 20472K-&gt;20472K(1067008K)], 0.0627380 secs] [Times: user=0.04 sys=0.00, real=0.06 secs]</code></pre><ol><li><strong>时间戳</strong>: <code>2024-08-28T15:10:01.578+0800</code><ul><li>这表示日志条目的日期和时间。<code>+0800</code> 表示时区偏移量（例如，北京时间为 UTC+8）。</li></ul></li><li><strong>GC 事件触发时间</strong>: <code>5.329</code><ul><li>表示从 JVM 启动到 GC 事件发生的时间，单位是秒。这表明在 JVM 启动后的 5.329 秒，发生了一个 Full GC。</li></ul></li><li><strong>GC 类型</strong>: <code>[Full GC (Metadata GC Threshold)]</code><ul><li><code>Full GC</code> 表示一次 Full Garbage Collection，即对整个堆（包括年轻代和老年代）进行的垃圾回收。</li><li><code>Metadata GC Threshold</code> 是此次 GC 的触发原因。它表明是因为元数据（如类的元信息）达到了特定的阈值，导致了 Full GC。<ul><li>Full GC (Ergonomics) : JVM , 自适应调整导致的GC</li><li>Full GC(System) : 调用了System.gc()方法</li></ul></li></ul></li><li><strong>年轻代回收</strong>: <code>[PSYoungGen: 3264K-&gt;0K(163840K)]</code><ul><li><strong>PSYoungGen</strong>: 使用 Parallel Scavenge（并行清除）垃圾回收器的年轻代（Young Generation）。</li><li><code>3264K-&gt;0K</code>: 表示在回收前年轻代占用 3264 KB 内存，回收后占用 0 KB。</li><li><code>(163840K)</code>: 年轻代的总容量是 163840 KB（160 MB）。</li></ul></li><li><strong>老年代回收</strong>: <code>[ParOldGen: 6227K-&gt;7621K(349696K)]</code><ul><li><strong>ParOldGen</strong>: 使用并行老年代垃圾回收器（Parallel Old Generation）。</li><li><code>6227K-&gt;7621K</code>: 表示在回收前老年代占用 6227 KB 内存，回收后增加到 7621 KB。这通常表示有一些对象从年轻代晋升到老年代。</li><li><code>(349696K)</code>: 老年代的总容量是 349696 KB（341.5 MB）。</li></ul></li><li><strong>堆总内存使用情况</strong>: <code>9491K-&gt;7621K(513536K)</code><ul><li><code>9491K-&gt;7621K</code>: 表示在 GC 前整个堆（年轻代 + 老年代）使用的总内存为 9491 KB，GC 后减少到 7621 KB。</li><li><code>(513536K)</code>: 堆的总容量是 513536 KB（501.25 MB）。</li></ul></li><li><strong>元空间（Metaspace）</strong>: <code>[Metaspace: 20472K-&gt;20472K(1067008K)]</code><ul><li><code>20472K-&gt;20472K</code>: 表示元空间（用于存储类的元数据）的使用量在 GC 前后保持不变，为 20472 KB。</li><li><code>(1067008K)</code>: 元空间的总容量是 1067008 KB（1042 MB）。</li></ul></li><li><strong>GC 事件耗时</strong>: <code>0.0627380 secs</code><ul><li>表示 GC 事件的总持续时间为 0.0627380 秒（约 62 毫秒）。</li></ul></li><li><strong>GC 时间分解</strong>: <code>[Times: user=0.04 sys=0.00, real=0.06 secs]</code><ul><li><code>user=0.04</code>: 用户态 CPU 时间（多个 CPU 线程的总和）是 0.04 秒。</li><li><code>sys=0.00</code>: 内核态 CPU 时间是 0.00 秒。</li><li><code>real=0.06</code>: 真实时间，即 GC 事件的墙钟时间是 0.06 秒。这个值通常比 <code>user</code> 和 <code>sys</code> 时间之和略大，反映了多线程并行执行的情况。</li></ul></li></ol><h1 id="三、GC日志分析工具"><a href="#三、GC日志分析工具" class="headerlink" title="三、GC日志分析工具"></a>三、GC日志分析工具</h1><p>上节介绍了GC日志的打印及含义，但是GC日志看起来比较麻烦，本节将会介绍一下GC日志可视化分析工具GCeasy和GCviewer等。通过GC日志可视化分析工具，我们可以很方便的看到JVM各个分代的内存使用情况、垃圾回收次数、垃圾回收的原因、垃圾回收占用的时间、吞吐量等，这些指标在我们进行JVM调优的时候是很有用的。</p><p>如果想把GC日志存到文件的话，是下面这个参数：</p><pre><code class="highlight shell">-Xloggc:/path/to/gc.log<span class="meta prompt_"># </span><span class="language-bash">示例</span>java -Xms512m -Xmx512m -XX:+PrintGCDetails -XX:+PrintGCDateStamps -Xloggc:/opt/module/ioms/ioms-ums/gc-%t.log -jar ioms-ums.jar --spring.profiles.active=dev</code></pre><p>然后就可以用一些工具去分析这些gc日志。</p><p><strong>示例代码1</strong></p><pre><code class="highlight java"><span class="comment">/**</span><span class="comment"> * 测试生成详细的日志文件</span><span class="comment"> *</span><span class="comment"> * -Xms60m -Xmx60m -XX:SurvivorRatio=8 -XX:+PrintGCDetails -XX:+PrintGCDateStamps -XX:+PrintHeapAtGC -Xloggc:d:/gc-log-%t.log</span><span class="comment"> *</span><span class="comment"> */</span><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">GCLogTest</span> &#123;    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;        ArrayList&lt;<span class="type">byte</span>[]&gt; list = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; <span class="number">5000</span>; i++) &#123;            <span class="type">byte</span>[] arr = <span class="keyword">new</span> <span class="title class_">byte</span>[<span class="number">1024</span> * <span class="number">50</span>];<span class="comment">//50KB</span>            list.add(arr);            <span class="keyword">try</span> &#123;                Thread.sleep(<span class="number">30</span>);            &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;                e.printStackTrace();            &#125;        &#125;    &#125;&#125;</code></pre><p><strong>示例代码2</strong></p><pre><code class="highlight java"><span class="comment">/**</span><span class="comment"> * java.lang.OutOfMemoryError: Metaspace异常演示：</span><span class="comment"> *</span><span class="comment"> * -Xms60m -Xmx60m -XX:MetaspaceSize=10m -XX:MaxMetaspaceSize=10m -XX:SurvivorRatio=8 -XX:+PrintGCDetails -XX:+PrintGCTimeStamps -XX:+PrintGCDateStamps -XX:+PrintHeapAtGC -Xloggc:d:/meta-log-%t.log</span><span class="comment"> *</span><span class="comment"> */</span><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">MetaspaceOOM</span> <span class="keyword">extends</span> <span class="title class_">ClassLoader</span> &#123;    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;        <span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> <span class="number">0</span>;        <span class="keyword">try</span> &#123;            <span class="type">MetaspaceOOM</span> <span class="variable">test</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">MetaspaceOOM</span>();            <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; <span class="number">10000</span>; i++) &#123;                <span class="comment">//创建ClassWriter对象，用于生成类的二进制字节码</span>                <span class="type">ClassWriter</span> <span class="variable">classWriter</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ClassWriter</span>(<span class="number">0</span>);                <span class="comment">//指明版本号，修饰符，类名，包名，父类，接口</span>                classWriter.visit(Opcodes.V1_8, Opcodes.ACC_PUBLIC, <span class="string">&quot;Class&quot;</span> + i, <span class="literal">null</span>, <span class="string">&quot;java/lang/Object&quot;</span>, <span class="literal">null</span>);                <span class="comment">//返回byte[]</span>                <span class="type">byte</span>[] code = classWriter.toByteArray();                <span class="comment">//类的加载</span>                test.defineClass(<span class="string">&quot;Class&quot;</span> + i, code, <span class="number">0</span>, code.length);<span class="comment">//Class对象</span>                j++;            &#125;        &#125; <span class="keyword">finally</span> &#123;            System.out.println(j);        &#125;    &#125;&#125;</code></pre><h2 id="1-GCeasy"><a href="#1-GCeasy" class="headerlink" title="1. GCeasy"></a>1. GCeasy</h2><p><strong>基本概述</strong></p><p>GCeasy——一款超好用的在线分析GC日志的网站官网地址：<a href="https://gceasy.io/gc-dashboard.jsp">https://gceasy.io/gc-dashboard.jsp</a></p><p>GCeasy是一款在线的GC日志分析器，可以通过GC日志分析进行内存泄漏检测、GC暂停原因分析、JVM配置建议优化等功能，而且是可以免费使用的（有一些服务是收费的）。</p><p><img src="https://raw.githubusercontent.com/GeorgeChan95/blogimg/master/img/2024/08/28/20240828-160343.png" alt="GCeasy官网"></p><p><strong>分析结果</strong></p><p><img src="https://raw.githubusercontent.com/GeorgeChan95/blogimg/master/img/2024/08/28/20240828-160459.png" alt="内存分析"></p><p><img src="https://raw.githubusercontent.com/GeorgeChan95/blogimg/master/img/2024/08/28/20240828-160520.png" alt="gc时间分析"></p><p><img src="https://raw.githubusercontent.com/GeorgeChan95/blogimg/master/img/2024/08/28/20240828-160833.png" alt="堆的使用"></p><p><img src="https://raw.githubusercontent.com/GeorgeChan95/blogimg/master/img/2024/08/28/20240828-160741.png" alt="GC统计"></p><p>等等……</p><h2 id="2-GCViewer"><a href="#2-GCViewer" class="headerlink" title="2. GCViewer"></a>2. GCViewer</h2><h3 id="2-1-基本概述"><a href="#2-1-基本概述" class="headerlink" title="2.1 基本概述"></a>2.1 基本概述</h3><p><code>GCViewer</code> 是一个免费的、开源的分析小工具，用于可视化查看由SUN&#x2F;Oracle,IBM,HP和BEA Java虚拟机产生的垃圾收集器的日志。</p><p>GCViewer用于可视化Java VM选项 <code>-verbose:gc</code> 和.NET生成的数据 <code>-Xloggc:&lt;file&gt;</code> 。它还计算与垃圾回收相关的性能指标（吞吐量，累积的暂停，最长的暂停等）。当通过更改世代大小或设置初始堆大小来调整特定应用程序的垃圾回收时，此功能非常有用。</p><h3 id="2-2-安装"><a href="#2-2-安装" class="headerlink" title="2.2 安装"></a>2.2 安装</h3><p><strong>下载GCViewer工具</strong></p><ul><li>源码下载: <a href="https://github.com/chewiebug/GCViewer">https://github.com/chewiebug/GCViewer</a></li><li>运行版本下载: <a href="https://github.com/chewiebug/GCViewer/wiki/Changelog">https://github.com/chewiebug/GCViewer/wiki/Changelog</a></li></ul><h3 id="2-3-启动GCViewer-gui"><a href="#2-3-启动GCViewer-gui" class="headerlink" title="2.3 启动GCViewer(gui)"></a>2.3 启动GCViewer(gui)</h3><p>需双击 <code>gcviewer-1.3x.jar</code></p><p>或</p><p>需要运行java1.8 vm</p><pre><code class="highlight shell">java -jar gcviewer-1.3x.jar</code></pre><p><img src="https://raw.githubusercontent.com/GeorgeChan95/blogimg/master/img/2024/08/28/20240828-162437.png" alt="GCViewer"></p><p>很难用！！！</p><h2 id="3-其他工具"><a href="#3-其他工具" class="headerlink" title="3. 其他工具"></a>3. 其他工具</h2><h3 id="3-1-GChisto"><a href="#3-1-GChisto" class="headerlink" title="3.1 GChisto"></a>3.1 GChisto</h3><p><code>GChisto</code> 是一款专业分析gc日志的工具，可以通过gc日志来分析 : MinorGC、Full GC的次数、频率、持续时间等，通过列表、报表、图表等不同形式来反应gc的情况。</p><p>虽然界面略显粗糙，但是功能还是不错的。</p><p>官网上没有下载的地方，需要自己从SVN上拉下来编译，不过这个工具似乎没怎么维护了，存在不少bug</p><h3 id="3-2-HPjmeter"><a href="#3-2-HPjmeter" class="headerlink" title="3.2 HPjmeter"></a>3.2 HPjmeter</h3><p>工具很强大，但只能打开由以下参数生成的 <code>GC log</code> , <code>-verbose:gc</code> <code>-Xloggc:gc.log</code> 。添加其他参数生成的 gc.log无法打开</p><p>HPjmeter集成了以前的 <code>HPjtune</code> 功能，可以分析在HP机器上产生的垃圾回收日志文件</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;一、GC日志参数&quot;&gt;&lt;a href=&quot;#一、GC日志参数&quot; class=&quot;headerlink&quot; title=&quot;一、GC日志参数&quot;&gt;&lt;/a&gt;一、GC日志参数&lt;/h1&gt;&lt;ul&gt;
&lt;li&gt;&lt;p&gt;&lt;code&gt;-verbose:gc&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;输出gc日</summary>
      
    
    
    
    <category term="JVM" scheme="https://georgechan95.github.io/categories/JVM/"/>
    
    
    <category term="java" scheme="https://georgechan95.github.io/tags/java/"/>
    
    <category term="jvm" scheme="https://georgechan95.github.io/tags/jvm/"/>
    
  </entry>
  
  <entry>
    <title>第二十四章-JVM运行时参数</title>
    <link href="https://georgechan95.github.io/blog/944806143.html"/>
    <id>https://georgechan95.github.io/blog/944806143.html</id>
    <published>2024-08-27T10:30:10.000Z</published>
    <updated>2024-08-28T04:17:33.350Z</updated>
    
    <content type="html"><![CDATA[<h1 id="一、JVM参数选项"><a href="#一、JVM参数选项" class="headerlink" title="一、JVM参数选项"></a>一、JVM参数选项</h1><p>官网地址：<a href="https://docs.oracle.com/javase/8/docs/technotes/tools/unix/java.html">https://docs.oracle.com/javase/8/docs/technotes/tools/unix/java.html</a></p><h2 id="1-类型一：标准参数选项"><a href="#1-类型一：标准参数选项" class="headerlink" title="1. 类型一：标准参数选项"></a>1. 类型一：标准参数选项</h2><h3 id="1-1-特点"><a href="#1-1-特点" class="headerlink" title="1.1 特点"></a>1.1 特点</h3><ul><li>比较稳定，后续版本基本不会变化</li><li>以 <code>-</code> 开头</li></ul><h3 id="1-2-各种选项"><a href="#1-2-各种选项" class="headerlink" title="1.2 各种选项"></a>1.2 各种选项</h3><p>运行 <code>java</code> 或者 <code>java-help</code> 可以看到所有的标准选项</p><pre><code class="highlight shell">C:\Users\kd&gt;java -help用法: java [-options] class [args...]           (执行类)   或  java [-options] -jar jarfile [args...]           (执行 jar 文件)其中选项包括:    -d32          使用 32 位数据模型 (如果可用)    -d64          使用 64 位数据模型 (如果可用)    -server       选择 &quot;server&quot; VM                  默认 VM 是 server.    -cp &lt;目录和 zip/jar 文件的类搜索路径&gt;    -classpath &lt;目录和 zip/jar 文件的类搜索路径&gt;                  用 ; 分隔的目录, JAR 档案                  和 ZIP 档案列表, 用于搜索类文件。    -D&lt;名称&gt;=&lt;值&gt;                  设置系统属性    -verbose:[class|gc|jni]                  启用详细输出    -version      输出产品版本并退出    -version:&lt;值&gt;                  警告: 此功能已过时, 将在                  未来发行版中删除。                  需要指定的版本才能运行    -showversion  输出产品版本并继续    -jre-restrict-search | -no-jre-restrict-search                  警告: 此功能已过时, 将在                  未来发行版中删除。                  在版本搜索中包括/排除用户专用 JRE    -? -help      输出此帮助消息    -X            输出非标准选项的帮助    -ea[:&lt;packagename&gt;...|:&lt;classname&gt;]    -enableassertions[:&lt;packagename&gt;...|:&lt;classname&gt;]                  按指定的粒度启用断言    -da[:&lt;packagename&gt;...|:&lt;classname&gt;]    -disableassertions[:&lt;packagename&gt;...|:&lt;classname&gt;]                  禁用具有指定粒度的断言    -esa | -enablesystemassertions                  启用系统断言    -dsa | -disablesystemassertions                  禁用系统断言    -agentlib:&lt;libname&gt;[=&lt;选项&gt;]                  加载本机代理库 &lt;libname&gt;, 例如 -agentlib:hprof                  另请参阅 -agentlib:jdwp=help 和 -agentlib:hprof=help    -agentpath:&lt;pathname&gt;[=&lt;选项&gt;]                  按完整路径名加载本机代理库    -javaagent:&lt;jarpath&gt;[=&lt;选项&gt;]                  加载 Java 编程语言代理, 请参阅 java.lang.instrument    -splash:&lt;imagepath&gt;                  使用指定的图像显示启动屏幕有关详细信息, 请参阅 http://www.oracle.com/technetwork/java/javase/documentation/index.html。</code></pre><h3 id="1-3-补充内容-server-与-client"><a href="#1-3-补充内容-server-与-client" class="headerlink" title="1.3 补充内容 -server 与 -client"></a>1.3 补充内容 -server 与 -client</h3><p><code>Hotspot JVM</code> 有两种模式，分别是 <code>server</code> 和 <code>client</code> , 分别通过 <code>-server</code> 和 <code>-client</code> 模式设置</p><ul><li><p>在32位Windows系统上，默认使用Client类型的JVM。要想使用 <code>Server</code> 模式，则机器配置至少有2个以上的CPU和2G以上的物理内存。<code>client</code> 模式适用于对内存要求较小的桌面应用程序，默认使用Serial串行垃圾收集器</p></li><li><p>64位机器上只支持server模式的JVM,适用于需要大内存的应用程序，默认使用并行垃圾收集器关于server和client的官网介绍为：<a href="https://docs.oracle.com/javase/8/docs/technotes/guides/vm/index.html">https://docs.oracle.com/javase/8/docs/technotes/guides/vm/index.html</a></p><p><img src="https://raw.githubusercontent.com/GeorgeChan95/blogimg/master/img/2024/08/27/20240827-184239.png" alt="server模式"></p></li></ul><h2 id="2-类型二：-X参数选项"><a href="#2-类型二：-X参数选项" class="headerlink" title="2. 类型二：-X参数选项"></a>2. 类型二：-X参数选项</h2><h3 id="2-1-特点"><a href="#2-1-特点" class="headerlink" title="2.1 特点"></a>2.1 特点</h3><ul><li>非标准化参数</li><li>功能还是比较稳定的，但官方说后续高版本可能变更</li><li>以 <code>-X</code> 开头</li></ul><h3 id="2-2-各种选项"><a href="#2-2-各种选项" class="headerlink" title="2.2 各种选项"></a>2.2 各种选项</h3><p>直接在DOS窗口中运行 <code>java -X</code> 命令可以看到所有的X选项</p><pre><code class="highlight shell">C:\Users\kd&gt;java -X    -Xmixed           混合模式执行 (默认)    -Xint             仅解释模式执行    -Xbootclasspath:&lt;用 ; 分隔的目录和 zip/jar 文件&gt;                      设置搜索路径以引导类和资源    -Xbootclasspath/a:&lt;用 ; 分隔的目录和 zip/jar 文件&gt;                      附加在引导类路径末尾    -Xbootclasspath/p:&lt;用 ; 分隔的目录和 zip/jar 文件&gt;                      置于引导类路径之前    -Xdiag            显示附加诊断消息    -Xnoclassgc       禁用类垃圾收集    -Xincgc           启用增量垃圾收集    -Xloggc:&lt;file&gt;    将 GC 状态记录在文件中 (带时间戳)    -Xbatch           禁用后台编译    -Xms&lt;size&gt;        设置初始 Java 堆大小    -Xmx&lt;size&gt;        设置最大 Java 堆大小    -Xss&lt;size&gt;        设置 Java 线程堆栈大小    -Xprof            输出 cpu 配置文件数据    -Xfuture          启用最严格的检查, 预期将来的默认值    -Xrs              减少 Java/VM 对操作系统信号的使用 (请参阅文档)    -Xcheck:jni       对 JNI 函数执行其他检查    -Xshare:off       不尝试使用共享类数据    -Xshare:auto      在可能的情况下使用共享类数据 (默认)    -Xshare:on        要求使用共享类数据, 否则将失败。    -XshowSettings    显示所有设置并继续    -XshowSettings:all                      显示所有设置并继续    -XshowSettings:vm 显示所有与 vm 相关的设置并继续    -XshowSettings:properties                      显示所有属性设置并继续    -XshowSettings:locale                      显示所有与区域设置相关的设置并继续-X 选项是非标准选项, 如有更改, 恕不另行通知。</code></pre><h3 id="2-3-JVM的JIT编译模式相关的选项"><a href="#2-3-JVM的JIT编译模式相关的选项" class="headerlink" title="2.3 JVM的JIT编译模式相关的选项"></a>2.3 JVM的JIT编译模式相关的选项</h3><ul><li><p><code>-Xint</code> : 只使用解释器：所有字节码都被解释执行，这个模式的速度是很慢的</p></li><li><p><code>-Xcomp</code> : 只使用编译器：所有字节码第一次使用就被编译成本地代码，然后在执行</p></li><li><p>-Xmixed : 混合模式：这是默认模式，刚开始的时候使用解释器慢慢解释执行，后来让JIT即时编译器根据程序运行的情况，有选择地将某些热点代码提前编译并缓存在本地，在执行的时候效率就非常高了</p><p><img src="https://raw.githubusercontent.com/GeorgeChan95/blogimg/master/img/2024/08/27/20240827-185220.png" alt="默认使用混合模式"></p></li></ul><h3 id="2-4-参数特别说明"><a href="#2-4-参数特别说明" class="headerlink" title="2.4 参数特别说明"></a>2.4 参数特别说明</h3><ul><li><code>-Xms&lt;size&gt;</code> ：设置初始Java堆大小，等价于 <code>-XX:InitialHeapSize</code></li><li><code>-Xmx&lt;size&gt;</code> ：设置最大Java堆大小，等价于 <code>-XX:MaxHeapSize</code></li><li><code>-Xss&lt;size&gt;</code> ：设置Java线程堆栈大小，等价于 <code>-XX:ThreadStackSize</code></li></ul><p>单位：k&#x2F;K、m&#x2F;M、g&#x2F;G<br>设置：-Xmx、-Xms 最好设置成一样的值，避免扩容带来的损耗</p><h2 id="3-类型三：-XX参数选项"><a href="#3-类型三：-XX参数选项" class="headerlink" title="3. 类型三：-XX参数选项"></a>3. 类型三：-XX参数选项</h2><h3 id="3-1-特点"><a href="#3-1-特点" class="headerlink" title="3.1 特点"></a>3.1 特点</h3><ul><li>非标准化参数</li><li>使用的最多的参数类型</li><li>这类选项属于实验性，不稳定</li><li>以 <code>-XX</code> 开头</li></ul><h3 id="3-2-作用"><a href="#3-2-作用" class="headerlink" title="3.2 作用"></a>3.2 作用</h3><p>用于开发和调试JVM</p><h3 id="3-3-分类"><a href="#3-3-分类" class="headerlink" title="3.3 分类"></a>3.3 分类</h3><h4 id="3-3-1-Boolean类型格式"><a href="#3-3-1-Boolean类型格式" class="headerlink" title="3.3.1 Boolean类型格式"></a>3.3.1 Boolean类型格式</h4><ul><li><p><code>-XX:+&lt;option&gt;</code>  表示启用option属性</p></li><li><p><code>-XX:-&lt;option&gt;</code>  表示禁用option属性</p></li></ul><p><strong>举例</strong></p><ul><li><p><code>-XX:+UseParallelGC</code> 选择垃圾收集器为并行收集器</p></li><li><p><code>-XX:+UseG1GC</code> 表示启用G1收集器</p></li><li><p><code>-XX:+UseAdaptiveSizePolicy</code> 自动选择年轻代区大小和相应的Survivor区比例</p></li></ul><p><strong>说明</strong></p><p>说明：因为有的指令默认是开启的，所以可以使用 <code>-</code> 关闭</p><h4 id="3-3-2-非Boolean类型格式（key-value类型）"><a href="#3-3-2-非Boolean类型格式（key-value类型）" class="headerlink" title="3.3.2 非Boolean类型格式（key-value类型）"></a>3.3.2 非Boolean类型格式（key-value类型）</h4><ul><li><p>数值型格式 <code>-XX:&lt;option&gt;=&lt;number&gt;</code></p><p><code>number</code> 表示数值，<code>number</code> 可以带上单位</p><p>比如：<br><code>m</code> 、<code>M</code> 表示 兆<br><code>k</code> 、<code>K</code> 表示 <code>Kb</code><br><code>g</code> 、<code>G</code> 表示 <code>g</code> ( 例如 : <code>32k</code> 跟 <code>32768</code> 是一样的效果 ）</p><p><strong>举例</strong></p><ul><li><p>设置新生代初始大小为1024兆</p><pre><code class="highlight shell">-XX:NewSize=1024m</code></pre></li><li><p>设置GC停顿时间：500毫秒</p><pre><code class="highlight shell">-XX:MaxGCPauseMillis=500</code></pre></li><li><p>设置吞吐量</p><pre><code class="highlight shell">-XX:GCTimeRatio=19</code></pre></li><li><p>新生代与老年代的比例</p><pre><code class="highlight shell">-XX:NewRatio=2</code></pre></li></ul></li><li><p>非数值型格式 <code>-XX:&lt;name&gt;=&lt;string&gt;</code></p><p><strong>举例</strong></p><ul><li><p>指定heap转存文件的存储路径</p><pre><code class="highlight shell">-XX:HeapDumpPath=/usr/local/heapdump.hprof</code></pre></li></ul></li></ul><h3 id="3-4-特别参数说明"><a href="#3-4-特别参数说明" class="headerlink" title="3.4 特别参数说明"></a>3.4 特别参数说明</h3><p><code>-XX:+PrintFlagsFinal</code> : 输出所有参数的名称和默认值</p><p>默认不包括 <code>Diagnostic</code>(诊断) 和 <code>Experimental</code>(实验) 的参数</p><p>可以配合 <code>-XX:+UnlockDiagnosticVMOptions</code> 和 <code>-XX:UnlockExperimentalVMOptions</code> 使用</p><h1 id="二、添加JVM参数选项"><a href="#二、添加JVM参数选项" class="headerlink" title="二、添加JVM参数选项"></a>二、添加JVM参数选项</h1><h2 id="1-Eclipse"><a href="#1-Eclipse" class="headerlink" title="1. Eclipse"></a>1. Eclipse</h2><ol><li><p>在空白处单击右键，选择Run As，在选择Run Configurations……</p><p><img src="https://raw.githubusercontent.com/GeorgeChan95/blogimg/master/img/2024/08/27/20240827-192230.png" alt="eclipse添加JVM选项1"></p></li><li><p>设置虚拟机参数</p><p><img src="https://raw.githubusercontent.com/GeorgeChan95/blogimg/master/img/2024/08/27/20240827-192311.png" alt="eclipse添加JVM选项2"></p></li></ol><h2 id="2-IDEA"><a href="#2-IDEA" class="headerlink" title="2. IDEA"></a>2. IDEA</h2><ol><li><p>Edit Configurations…</p><p><img src="https://raw.githubusercontent.com/GeorgeChan95/blogimg/master/img/2024/08/27/20240827-192358.png" alt="IDEA添加JVM选项1"></p></li><li><p>设置虚拟机参数</p><p><img src="https://raw.githubusercontent.com/GeorgeChan95/blogimg/master/img/2024/08/27/20240827-192428.png" alt="IDEA添加JVM选项2"></p></li></ol><h2 id="3-运行jar包"><a href="#3-运行jar包" class="headerlink" title="3. 运行jar包"></a>3. 运行jar包</h2><p>java -Xms500m -Xmx500m -XX:+PrintGCDetails -XX:+PrintGCTimeStamps -jar demo.jar</p><p>这是在java -jar demo.jar中的java -jar之间添加了虚拟机配置信息</p><h2 id="4-通过Tomcat运行war包"><a href="#4-通过Tomcat运行war包" class="headerlink" title="4. 通过Tomcat运行war包"></a>4. 通过Tomcat运行war包</h2><ul><li>Linux系统下可以在 tomcat&#x2F;bin&#x2F;catalina.sh 中添加类似如下配置：JAVA_OPTS&#x3D;”-Xms512M -Xmx1024M”</li><li>Windows系统下载 catalina.bat 中添加类似如下配置：set “JAVA_OPTS&#x3D;-Xms512M -Xmx1024M”</li></ul><h2 id="5-程序运行过程中"><a href="#5-程序运行过程中" class="headerlink" title="5. 程序运行过程中"></a>5. 程序运行过程中</h2><p><code>jinfo</code> 不仅可以查看运行时某一个 Java 虚拟机参数的实际取值，甚至可以在运行时修改部分参数，并使之立即生效。</p><p>但是，并非所有参数都支持动态修改。参数只有被标记为 manageable 的 flag 可以被实时修改。其实，这个修改能力是极其有限的。</p><p><strong>查看被标记为 manageable 的参数</strong></p><p><code>java -XX:+PrintFlagsFinal -version | grep &quot;manageable&quot;</code> 可以查看标记为 <code>manageable</code> 的参数</p><pre><code class="highlight shell">root@ubuntu:~# java -XX:+PrintFlagsFinal -version | grep &quot;manageable&quot;     intx CMSAbortablePrecleanWaitMillis            = 100                                 &#123;manageable&#125;     intx CMSTriggerInterval                        = -1                                  &#123;manageable&#125;     intx CMSWaitDuration                           = 2000                                &#123;manageable&#125;     bool HeapDumpAfterFullGC                       = false                               &#123;manageable&#125;     bool HeapDumpBeforeFullGC                      = false                               &#123;manageable&#125;     bool HeapDumpOnOutOfMemoryError                = false                               &#123;manageable&#125;    ccstr HeapDumpPath                              =                                     &#123;manageable&#125;    uintx MaxHeapFreeRatio                          = 100                                 &#123;manageable&#125;    uintx MinHeapFreeRatio                          = 0                                   &#123;manageable&#125;     bool PrintClassHistogram                       = false                               &#123;manageable&#125;     bool PrintClassHistogramAfterFullGC            = false                               &#123;manageable&#125;     bool PrintClassHistogramBeforeFullGC           = false                               &#123;manageable&#125;     bool PrintConcurrentLocks                      = false                               &#123;manageable&#125;     bool PrintGC                                   = false                               &#123;manageable&#125;     bool PrintGCDateStamps                         = false                               &#123;manageable&#125;     bool PrintGCDetails                            = false                               &#123;manageable&#125;     bool PrintGCID                                 = false                               &#123;manageable&#125;     bool PrintGCTimeStamps                         = false                               &#123;manageable&#125;java version &quot;1.8.0_261&quot;Java(TM) SE Runtime Environment (build 1.8.0_261-b12)Java HotSpot(TM) 64-Bit Server VM (build 25.261-b12, mixed mode)</code></pre><ul><li><p>设置非Boolean类型参数</p><p><code>jinfo -flag &lt;name&gt;=&lt;value&gt; &lt;pid&gt;</code></p></li><li><p>设置Boolean类型参数</p><p><code>jinfo -flag [+|-] &lt;name&gt; &lt;pid&gt;</code></p><p>示例： jinfo -flag +PrintGCDetails 29536</p></li></ul><h1 id="三、常用的JVM参数选项"><a href="#三、常用的JVM参数选项" class="headerlink" title="三、常用的JVM参数选项"></a>三、常用的JVM参数选项</h1><h2 id="1-打印设置的XX选项及值"><a href="#1-打印设置的XX选项及值" class="headerlink" title="1. 打印设置的XX选项及值"></a>1. 打印设置的XX选项及值</h2><ul><li><p>-XX:+PrintCommandLineFlags 可以让程序运行前打印出用户手动设置或者JVM自动设置的XX选项</p></li><li><p>-XX:+PrintFlagsInitial 表示打印出所有XX选项的默认值</p></li><li><p>-XX:+PrintFlagsFinal 表示打印出XX选项在运行程序时生效的值</p><p>如果值的前面加上了 <code>:=</code> ，说明该值不是初始值，该值可能被 jvm 自动改变了，也可能被我们设置的参数改变了，如下所示：</p><p><img src="https://raw.githubusercontent.com/GeorgeChan95/blogimg/master/img/2024/08/27/20240827-200720.png" alt="PrintFlagsFinal"></p></li><li><p>-XX:+PrintVMOptions 打印JVM的参数</p></li></ul><h2 id="2-堆、栈、方法区等内存大小设置"><a href="#2-堆、栈、方法区等内存大小设置" class="headerlink" title="2. 堆、栈、方法区等内存大小设置"></a>2. 堆、栈、方法区等内存大小设置</h2><h3 id="2-1-栈"><a href="#2-1-栈" class="headerlink" title="2.1 栈"></a>2.1 栈</h3><ul><li>-Xss128k 或 -XX:ThreadStackSize&#x3D;128k ：设置每个线程的栈大小为128k</li></ul><h3 id="2-2-堆内存"><a href="#2-2-堆内存" class="headerlink" title="2.2 堆内存"></a>2.2 堆内存</h3><ul><li>-Xms3550m 或 -XX:InitialHeapSize&#x3D;3550m ：设置JVM初始堆内存为3550M</li><li>-Xmx3550m 或 -XX:MaxHeapSize&#x3D;3550m ：设置JVM最大堆内存为3550M</li><li>-Xmn2g ：设置年轻代大小为2G, 官方推荐配置为整个堆大小的3&#x2F;8</li><li>-XX:NewSize&#x3D;1024m：设置年轻代初始值为1024M</li><li>-XX:MaxNewSize&#x3D;1024m ：设置年轻代最大值为1024M</li><li>-XX:SurvivorRatio&#x3D;8 ：设置年轻代中Eden区与一个Survivor区的比值，默认为8</li><li>-XX:+UseAdaptiveSizePolicy ：自动选择各区大小比例</li><li>-XX:NewRatio&#x3D;4 ：设置<strong>老年代</strong>与<strong>年轻代</strong>（包括1个Eden和2个Survivor区）的比值</li><li>-XX:PretenureSizeThreadshold&#x3D;1024 ：设置让大于此阀值的对象直接分配在老年代，单位为字节<br>只对Serial、ParNew收集器有效</li><li>-XX:MaxTenuringThreshold&#x3D;15 ：新生代每次 <code>MinorGC</code> 后，还存活的对象年龄 + 1 , 当对象的年龄大于设置的这个值时就进入老年代,默认值为15</li><li>-XX:+PrintTenuringDistribution ：每次 <code>MinorGC</code> 后打印出当前使用的 <code>Survivor</code> 中对象的年龄分布</li><li>-XX:TargetSurvivorRatio ：<code>MinorGC</code> 结束后 <code>Survivor</code> 区域中占用空间的期望比例</li></ul><h3 id="2-3-方法区"><a href="#2-3-方法区" class="headerlink" title="2.3 方法区"></a>2.3 方法区</h3><h4 id="2-3-1-永久代"><a href="#2-3-1-永久代" class="headerlink" title="2.3.1 永久代"></a>2.3.1 永久代</h4><ul><li>-XX:PermSize&#x3D;256m  ：设置<strong>永久代初始值</strong>为256M</li><li>-XX:MaxPermSize&#x3D;256m ：设置永久代最大值为256M</li></ul><h4 id="2-3-2-元空间"><a href="#2-3-2-元空间" class="headerlink" title="2.3.2 元空间"></a>2.3.2 元空间</h4><ul><li>-XX:MetaspaceSize ：初始空间大小</li><li>-XX:MaxMetaspaceSize ：最大空间，默认没有限制</li><li>-XX:+UseCompressedOops ：压缩对象指针</li><li>-XX:+UseCompressedClassPointers ：压缩类指针</li><li>-XX:CompressedClassSpaceSize ：设置Klass Metaspace的大小，默认1G</li></ul><h3 id="2-4-直接内存"><a href="#2-4-直接内存" class="headerlink" title="2.4 直接内存"></a>2.4 直接内存</h3><ul><li>-XX:MaxDirectMemorySize ：指定 DirectMemory 容量，若未指定，则默认与Java堆最大值一样</li></ul><h2 id="3-OutOfMemory相关的选项"><a href="#3-OutOfMemory相关的选项" class="headerlink" title="3. OutOfMemory相关的选项"></a>3. OutOfMemory相关的选项</h2><ul><li><p>-XX:+HeapDumpOnOutOfMemoryError ：内存出现OOM的时候，把Heap转存（Dump)到文件以便后续分析</p></li><li><p>-XX:+HeapDumpBeforeFullGC ：在出现FullGC之前，生成Heap转储文件</p></li><li><p><code>-XX:HeapDumpPath=&lt;path&gt;</code> ：指定heap转存文件的存储路径</p></li><li><p>-XX:OnOutOfMemoryError ：指定一个程序或者脚本的路径，当发生OOM的时候，去执行这个脚本</p><p><strong>举例：</strong></p><p>以部署在linux系统 <code>/opt/Server</code> 目录下的 <code>ioms-ums.jar</code> 为例</p><ul><li><p>在 <code>run.sh</code> 启动脚本中添加jvm参数：</p><pre><code class="highlight shell">-XX:OnOutOfMemoryError=/opt/Server/restart.sh</code></pre></li><li><p>restart.sh 脚本</p><ul><li><p>linux环境：</p><pre><code class="highlight shell"><span class="meta prompt_">#</span><span class="language-bash">!/bin/bash</span>pid=$(ps -ef|grep ioms-ums.jar|awk &#x27;&#123;if($8==&quot;java&quot;) &#123;print $2&#125;&#125;&#x27;)kill -9 $pidcd /opt/Server/;sh run.sh</code></pre></li><li><p>Windows环境：</p><pre><code class="highlight shell">echo offwmic process where Name=&#x27;java.exe&#x27; deletecd D:\Serverstart run.bat</code></pre></li></ul></li></ul></li></ul><h2 id="4-垃圾收集器相关选项"><a href="#4-垃圾收集器相关选项" class="headerlink" title="4. 垃圾收集器相关选项"></a>4. 垃圾收集器相关选项</h2><p>7款经典收集器与垃圾分代之间的关系 :</p><p><img src="https://raw.githubusercontent.com/GeorgeChan95/blogimg/master/img/2024/08/27/20240827-203512.png" alt="垃圾收集器分代关系"></p><p>垃圾收集器的组合关系 :</p><p><img src="https://raw.githubusercontent.com/GeorgeChan95/blogimg/master/img/2024/08/27/20240827-203533.png" alt="垃圾收集器的组合关系"></p><h3 id="4-1-查看默认垃圾收集器"><a href="#4-1-查看默认垃圾收集器" class="headerlink" title="4.1 查看默认垃圾收集器"></a>4.1 查看默认垃圾收集器</h3><ul><li><p><code>-XX:+PrintCommandLineFlags</code> 查看命令行相关参数（包含使用的垃圾收集器）</p></li><li><p><code>jinfo -flag 相关垃圾回收器参数 进程ID</code>，作用：使用命令行指令</p><ul><li><p>注意：只能修改被标记为 manageable 的参数</p><p>java -XX:+PrintFlagsFinal -version | grep “manageable”</p></li></ul><p>示例：jinfo -flag +PrintGCDetails 29536</p></li></ul><h3 id="4-2-Serial回收器"><a href="#4-2-Serial回收器" class="headerlink" title="4.2 Serial回收器"></a>4.2 Serial回收器</h3><p><code>Serial</code> 收集器作为HotSpot中client模式下的 <strong>默认新生代垃圾收集器</strong>。<code>Serial Old</code> 是运行在 <code>Client</code> 模式下默认的老年代的垃圾回收器。</p><ul><li><p><code>-XX:+UseSerialGC</code></p><p>指定年轻代和老年代都使用串行收集器</p><p>等价于新生代用 <code>Serial GC</code> , 且老年代用 <code>Serial Old GC</code> 。可以获得最高的单线程收集效率</p></li></ul><h3 id="4-3-ParNew回收器"><a href="#4-3-ParNew回收器" class="headerlink" title="4.3 ParNew回收器"></a>4.3 ParNew回收器</h3><ul><li><p><code>-XX:+UseParNewGC</code></p><p>手动指定使用 <code>ParNew</code> 收集器执行内存回收任务。</p><p>它表示年轻代使用并行收集器，不影响老年代。</p></li><li><p><code>-XX:ParallelGCThreads=N</code></p><p>限制线程数量，默认开启和CPU数据相同的线程数</p></li></ul><h3 id="4-4-Parallel回收器"><a href="#4-4-Parallel回收器" class="headerlink" title="4.4 Parallel回收器"></a>4.4 Parallel回收器</h3><ul><li><p><code>-XX:+UseParallelGC</code> </p><p>手动指定<strong>年轻代</strong>使用 <code>Parallel</code> <strong>并行收集器</strong>执行内存回收任务</p></li><li><p><code>-XX:+UseParallelOldGC</code></p><p>手动指定老年代都是使用并行回收收集器。</p></li></ul><p>分别适用于新生代和老年代。默认jdk8是开启的。</p><p>上面两个参数，默认开启一个，另一个也会被开启。（互相激活）</p><ul><li><p><code>-XX:ParallelGCThreads</code> </p><p>设置年轻代并行收集器的线程数。<br>一般地，最好与CPU数量相等，以避免过多的线程数影响垃圾收集性能。</p><p>在默认情况下，当CPU数量小于8个，ParallelGCThreads的值等于CPU数量。<br>当CPU数量大于8个，ParallelGCThreads 的值 &#x3D; 3 + [ 5 * CPU_Count] &#x2F; 8 ]</p></li><li><p><code>-XX:MaxGCPauseMillis</code></p><p>设置垃圾收集器<strong>最大停顿时间</strong>（即STW的时间）。单位是毫秒。</p><ul><li>为了尽可能地把停顿时间控制在 <code>MaxGCPauseMills</code> 以内，收集器在工作时会调整Java堆大小 或 其他一些参数。</li><li>对于用户来讲，停顿时间越短体验越好。但是在服务器端，我们注重高并发，整体的吞吐量。所以服务器端适合Parallel , 进行控制。</li><li>该参数使用需谨慎。</li></ul></li><li><p><code>-XX:GCTimeRatio</code></p><p>垃圾收集时间占总时间的比例（ &#x3D;1 &#x2F; ( N + 1 ) )。用于衡量<strong>吞吐量</strong>的大小。</p><ul><li>取值范围（ 0 , 100 )。默认值99 , 也就是垃圾回收时间不超过1%</li><li>与前一个 <code>-XX:MaxGCPauseMillis</code> 参数有一定矛盾性。暂停时间越长，Radio参数就容易超过设定的比例</li></ul></li><li><p><code>-XX:+UseAdaptiveSizePolicy</code></p><p>设置 <code>Parallel Scavenge</code> 收集器具有自适应调节策略</p><ul><li><p>在这种模式下，<strong>年轻代</strong>的大小、<code>Eden</code> 和 <code>Survivor</code> 的比例、晋升<strong>老年代</strong>的对象年龄等参数会被自动调整，已达到在<strong>堆大小</strong>、<strong>吞吐量</strong>和<strong>停顿时间</strong>之间的平衡点。</p></li><li><p>在手动调优比较困难的场合，可以直接使用这种自适应的方式，仅指定虚拟机的<strong>最大堆</strong>、目标的<strong>吞吐量</strong>（ <code>GCTimeRatio</code> )和<strong>停顿时间</strong>（ <code>MaxGCPauseMills</code> ) , 让虚拟机自己完成调优工作。</p></li></ul></li></ul><h3 id="4-5-CMS回收器"><a href="#4-5-CMS回收器" class="headerlink" title="4.5 CMS回收器"></a>4.5 CMS回收器</h3><ul><li><p><code>-XX:+UseConcMarkSweepGC</code></p><p>手动指定使用CMS 收集器执行内存回收任务</p><ul><li>开启该参数后会自动将 <code>-XX:+UseParNewGC</code> 打开。即：ParNew ( Young区用）+ CMS(Old区用）+ <code>Serial Old</code> 的组合。</li></ul></li><li><p><code>-XX:CMSlnitiatingoccupanyFraction</code></p><p>设置堆内存使用率的阀值，一旦达到该阀值，便开始进行回收。</p><ul><li>JDK5及以前版本的默认值为68 , 即当老年代的空间使用率达到68%时，会执行一次CMS回收。JDK6及以上版本默认值为92%</li><li>如果内存增长缓慢，则可以设置一个稍大的值，大的阙值可以有效降低CMS的触发频率，减少老年代回收的次数可以较为明显地改善应用程序性能。反之，如果应用程序内存使用率增长很快，则应该降低这个阙值，以避免频繁触发老年代串行收集器。因此通过该选项便可以有效降低Full GC 的执行次数。</li></ul></li><li><p><code>-XX:+UseCMSComlpactAtFullCollection</code></p><p>用于指定在执行完Full GC后对内存空间进行压缩整理，以此避免内存碎片的产生。</p><ul><li>不过由于内存压缩整理过程无法并发执行，所带来的问题就是停顿时间变得更长了。</li></ul></li><li><p><code>-XX:CMSFullGCsBeforeCompaction</code></p><p>设置在执行多少次 <code>Full GC</code> 后对内存空间进行压缩整理。</p></li><li><p>-XX:ParallelCMSThreads</p><p>设置CMS的线程数量</p><ul><li>CMS默认启动的线程数是（ParallelGCThreads + 3 ) &#x2F; 4 , <code>ParallelGCThreads</code> 是<strong>年轻代并行收集器</strong>的线程数。当CPU资源比较紧张时，受到CMS收集器线程的影响，应用程序的性能在垃圾回收阶段可能会非常糟糕。</li></ul></li></ul><p><strong>补充参数</strong></p><ul><li><p><code>-XX:ConcGCThreads</code></p><p>设置并发垃圾收集的线程数，默认该值是基于 <code>ParallelGCThreads</code> 计算出来的；</p></li><li><p><code>-XX:+UseCMSInitiatingOccupancyonly</code></p><p>是否动态可调，用这个参数可以使CMS一直按 <code>CMSInitiatingOccupancyFraction</code> 设定的值启动</p></li><li><p><code>-XX:+CMSScavengeBeforeRemark</code></p><p>强制hotspot虚拟机在 <code>cms remark</code> 阶段之前做一次 <code>minor gc</code> ,用于提高 <code>remark</code> 阶段的速度；</p></li><li><p><code>-XX:+CMSClassUnloadingEnable</code></p><p>如果有的话，启用回收Perm区（JDK8之前）</p></li><li><p><code>-XX:+CMSParallelInitialEnabled</code></p><p>用于开启 <code>CMS initial-mark</code> 阶段采用多线程的方式进行标记，用于提高标记速度，在Java8开始已经默认开启；</p></li><li><p><code>-XX:+CMSParallelRemarkEnabled</code></p><p>用户开启<code>CMS remark</code> 阶段采用多线程的方式进行重新标记 , 默认开启；</p></li><li><p><code>-XX:+ExplicitGCInvokesConcurrent</code> <code>-XX:+ExplicitGCInvokesConcurrentAndUnloadsClasses</code></p><p>这两个参数用户指定hotspot虚拟在执行 <code>System.gc()</code> 时使用CMS周期；</p></li><li><p><code>-XX:+CMSPrecleaningEnabled</code></p><p>指定CMS是否需要进行 <code>Pre cleaning</code> 这个阶段</p></li></ul><p><strong>特别说明</strong></p><p>JDK9新特性：<code>CMS</code> 被标记为 <code>Deprecate</code> 了（JEP291)</p><ul><li>如果对JDK9及以上版本的 <code>HotSpot</code> 虚拟机使用参数 <code>-XX:+UseConcMarkSweepGC</code> 来开启CMS收集器的话，用户会收到一个警告信息，提示CMS未来将会被废弃。</li></ul><p>JDK14新特性：删除CMS垃圾回收器（JEP363)</p><ul><li><p>移除了CMS垃圾收集器，如果在JDK14中使用 <code>-XX:+UseConcMarkSweepGC</code> 的话 , JVM不会报错，只是给出一个warning信息，但是不会exit。JVM会自动回退以默认GC方式启动JVM</p><p><img src="https://raw.githubusercontent.com/GeorgeChan95/blogimg/master/img/2024/08/28/20240828-081410.png" alt="JDK14 CMS"></p></li></ul><h3 id="4-6-G1回收器"><a href="#4-6-G1回收器" class="headerlink" title="4.6 G1回收器"></a>4.6 G1回收器</h3><p>如果使用G1垃圾收集器，不建议设置-Xmn和-XX:NewRatio，毕竟可能影响G1的自动调节</p><ul><li><p><code>-XX:+UseG1GC</code></p><p>手动指定使用G1收集器执行内存回收任务。</p></li><li><p><code>-XX:G1HeapRegionSize</code></p><p>设置每个Region的大小。值是2的幂，范围是1MB到32MB之间，目标是根据最小的Java堆大小划分出约2048个区域。默认是堆内存的1&#x2F;2000。</p></li><li><p><code>-XX:MaxGCPauseMillis</code></p><p>设置期望达到的最大GC停顿时间指标（JVM会尽力实现，但不保证达到）。默认值是200ms</p></li><li><p><code>-XX:ParallelGCThread</code>  设置STW时GC线程数的值。最多设置为8</p></li><li><p><code>-XX:ConcGCThreads</code></p><p>设置并发标记的线程数。将n设置为并行垃圾回收线程数（ParallelGCThreads)的1&#x2F;4左右。</p></li><li><p><code>-XX:InitiatingHeapOccupancyPercent</code></p><p>设置触发并发GC周期的Java堆占用率阈值。超过此值，就触发GC。默认值是45。</p></li><li><p><code>-XX:G1NewSizePercent</code> <code>-XX:G1MaxNewSizePercent</code></p><p>新生代占用整个堆内存的最小百分比（默认5%)、最大百分比（默认60%)</p></li><li><p><code>-XX:G1ReservePercent=10</code></p><p>保留内存区域，防止 <code>to space</code> (Survivor中的to区）溢出</p></li></ul><p><strong>Mixed GC调优参数</strong></p><p>注意：G1收集器主要涉及到Mixed GC,Mixed GC会回收young区和部分old区。</p><p>G1关于Mixed GC调优常用参数：</p><ul><li><p><code>-XX:InitiatingHeapOccupancyPercent</code></p><p>设置堆占用率的百分比（0到100)达到这个数值的时候触发global concurrent marking(全局并发标记）,默认为 45%。值为0表示间断进行全局并发标记。</p></li><li><p><code>-XX:G1MixedGCLiveThresholdPercent</code></p><p>设置old区的region被回收时候的对象占比，默认占用率为85%。只有old区的region中存活的对象占用达到了这个百分比 , 才会在Mixed GC中被回收。</p></li><li><p><code>-XX:G1HeapWastePercent</code></p><p>在global concurrent marking(全局并发标记）结束之后，可以知道所有的区有多少空间要被回收，在每次young GC之后和再次发生Mixed GC之前，会检查垃圾占比是否达到此参数，只有达到了，下次才会发生 Mixed GC。</p></li><li><p><code>-XX:G1MixedGCCountTarget</code></p><p>一次global concurrent marking(全局并发标记）之后，最多执行Mixed GC的次数，默认是8。</p></li><li><p><code>-XX:G1OldCSetRegionThresholdPercent</code></p><p>设置Mixed GC收集周期中要收集的Old region数的上限。默认值是Java堆的10%</p></li></ul><h3 id="4-7-怎么选择垃圾回收器"><a href="#4-7-怎么选择垃圾回收器" class="headerlink" title="4.7 怎么选择垃圾回收器"></a>4.7 怎么选择垃圾回收器</h3><ul><li>优先调整堆的大小让JVM自适应完成。</li><li>如果内存小于100M,使用串行收集器</li><li>如果是单核、单机程序，并且没有停顿时间的要求，串行收集器</li><li>如果是多CPU、需要高吞吐量、允许停顿时间超过1秒，选择并行或者JVM自己选择</li><li>如果是多CPU、追求低停顿时间，需快速响应（比如延迟不能超过1秒，如互联网应用),使用并发收集器。官方推荐G1,性能高。现在互联网的项目，基本都是使用G1。</li></ul><p>特别说明：</p><ol><li>没有最好的收集器，更没有万能的收集；</li><li>调优永远是针对特定场景、特定需求，不存在一劳永逸的收集器</li></ol><h2 id="5-GC日志相关选项"><a href="#5-GC日志相关选项" class="headerlink" title="5. GC日志相关选项"></a>5. GC日志相关选项</h2><p>强烈建议看下这篇博客：<a href="https://cloud.tencent.com/developer/article/1916565">https://cloud.tencent.com/developer/article/1916565</a></p><h3 id="5-1-常用参数"><a href="#5-1-常用参数" class="headerlink" title="5.1 常用参数"></a>5.1 常用参数</h3><ul><li><p><code>-verbose:gc</code></p><p>输出gc日志信息，默认输出到标准输出<br>可以独立使用</p></li><li><p><code>-XX:+PrintGC</code></p><p>等同于 <code>-verbose:gc</code> 表示打开简化的GC日志<br>可以独立使用</p></li><li><p><code>-XX:+PrintGCDetails</code></p><p>在发生垃圾回收时打印内存回收详细的日志，并在进程退出时输出当前内存各区域分配情况<br>可以独立使用</p></li><li><p><code>-XX:+PrintGCTimeStamps</code></p><p>输出GC发生时的时间截<br>不可以独立使用，需要配合-XX:+PrintGCDetails使用</p></li><li><p><code>-XX:+PrintGCDateStamps</code></p><p>输出GC发生时的时间戳（以日期的形式，如 2013-05-04T21:53:59.234+0800)<br>不可以独立使用，需要配合-XX:+PrintGCDetails使用</p></li><li><p><code>-XX:+PrintHeapAtGC</code></p><p>每一次GC前和GC后，都打印堆信息<br>可以独立使用</p></li><li><p><code>-Xloggc:&lt;file&gt;</code></p><p>把GC日志写入到一个文件中去，而不是打印到标准输出中</p><pre><code class="highlight shell">java -Xms4096m -Xmx4096m -Xloggc:/tm/gc-%t.log -jar ioms-ums.jar<span class="meta prompt_"># </span><span class="language-bash">或</span>java  -Xms4096m -Xmx4096m -Xloggc:/tm/gc-%t.log -XX:+UseGCLogFileRotation -XX:NumberOfGCLogFiles=3 -XX:GCLogFileSize=512k -jar ioms-ums.jar</code></pre></li></ul><h3 id="5-2-其他参数"><a href="#5-2-其他参数" class="headerlink" title="5.2 其他参数"></a>5.2 其他参数</h3><ul><li><p><code>-XX:+TraceClassLoading</code></p><p>监控类的加载</p></li><li><p><code>-XX:+PrintGCApplicationStoppedTime</code></p><p>打印GC时线程的停顿时间</p></li><li><p><code>-XX:+PrintGCApplicationConcurrentTime</code></p><p>垃圾收集之前打印出应用未中断的执行时间</p></li><li><p><code>-XX:+PrintReferenceGC</code></p><p>记录回收了多少种不同引用类型的引用</p></li><li><p><code>-XX:+PrintTenuringDistribution</code></p><p>让JVM在每次MinorGC后打印出当前使用的Survivor中对象的年龄分布</p></li><li><p><code>-XX:+UseGCLogFileRotation</code></p><p>启用GC日志文件的自动转储</p></li><li><p><code>-XX:NumberOfGClogFiles=1</code></p><p>GC日志文件的循环数目</p></li><li><p><code>-XX:GCLogFileSize=1M</code></p><p>控制GC日志文件的大小</p></li></ul><pre><code class="highlight shell">java  -Xms4096m -Xmx4096m -Xloggc:/tm/gc-%t.log -XX:+UseGCLogFileRotation -XX:NumberOfGCLogFiles=3 -XX:GCLogFileSize=512k -jar ioms-ums.jar</code></pre><h2 id="6-其他参数"><a href="#6-其他参数" class="headerlink" title="6. 其他参数"></a>6. 其他参数</h2><ul><li><p><code>-XX:+DisableExplicitGC</code></p><p>禁止hotspot执行System.gc(),默认禁用</p></li><li><p><code>-XX:ReservedCodeCacheSize=&lt;n&gt;[g|m|k]</code>  <code>-XX:InitialCodeCacheSize=&lt;n&gt;[g|m|k]</code></p><p>指定代码缓存的大小</p></li><li><p><code>-XX:+UseCodeCacheFlushing</code></p><p>使用该参数让jvm放弃一些被编译的代码，避免代码缓存被占满时JVM切换到interpreted-only的情况</p></li><li><p><code>XX:+DoEscapeAnalysis</code>  开启逃逸分析（jdk1.8默认开启）</p></li><li><p><code>-XX:+UseBiasedLocking</code>  开启偏向锁</p></li><li><p><code>-XX:+UseLargePages</code>  开启使用大页面</p></li><li><p><code>-XX:+UseTLAB</code>  使用TLAB,默认打开</p></li><li><p><code>-XX:+PrintTLAB</code>  打印TLAB的使用情况</p></li><li><p><code>-XX:TLABSize</code>  设置TLAB大小</p></li></ul><h1 id="四、通过Java代码获取JVM参数"><a href="#四、通过Java代码获取JVM参数" class="headerlink" title="四、通过Java代码获取JVM参数"></a>四、通过Java代码获取JVM参数</h1><p>Java提供了 <code>java.lang.management</code> 包用于监视和管理Java虚拟机和Java运行时中的其他组件，它允许本地和远程监控和管理运行的Java虚拟机。<br> 其中 <code>ManagementFactory</code> 这个类还是挺常用的。另外还有Runtime类也可以获取一些内存、CPU核数等相关的数据。</p><p>通过这些api可以监控我们的应用服务器的堆内存使用情况，设置一些阀值进行报警等处理。</p><pre><code class="highlight java"><span class="keyword">package</span> com.cpucode.java.operating.parameters;<span class="keyword">import</span> java.lang.management.ManagementFactory;<span class="keyword">import</span> java.lang.management.MemoryMXBean;<span class="keyword">import</span> java.lang.management.MemoryUsage;<span class="comment">/**</span><span class="comment"> * 监控我们的应用服务器的堆内存使用情况，设置一些阈值进行报警等处理</span><span class="comment"> */</span><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">MemoryMonitor</span> &#123;    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;        <span class="type">MemoryMXBean</span> <span class="variable">memoryMXBean</span> <span class="operator">=</span> ManagementFactory.getMemoryMXBean();        <span class="type">MemoryUsage</span> <span class="variable">usage</span> <span class="operator">=</span> memoryMXBean.getHeapMemoryUsage();        System.out.println(<span class="string">&quot;INIT HEAP: &quot;</span> + usage.getInit() / <span class="number">1024</span> / <span class="number">1024</span> + <span class="string">&quot;m&quot;</span>);        System.out.println(<span class="string">&quot;MAX HEAP: &quot;</span> + usage.getMax() / <span class="number">1024</span> / <span class="number">1024</span> + <span class="string">&quot;m&quot;</span>);        System.out.println(<span class="string">&quot;USE HEAP: &quot;</span> + usage.getUsed() / <span class="number">1024</span> / <span class="number">1024</span> + <span class="string">&quot;m&quot;</span>);        System.out.println(<span class="string">&quot;\nFull Information:&quot;</span>);        System.out.println(<span class="string">&quot;Heap Memory Usage: &quot;</span> + memoryMXBean.getHeapMemoryUsage());        System.out.println(<span class="string">&quot;Non-Heap Memory Usage: &quot;</span> + memoryMXBean.getNonHeapMemoryUsage());        System.out.println(<span class="string">&quot;=======================通过java来获取相关系统状态============================ &quot;</span>);        <span class="comment">// 当前堆内存大小</span>        System.out.println(<span class="string">&quot;当前堆内存大小totalMemory &quot;</span> + (<span class="type">int</span>) Runtime.getRuntime().totalMemory() / <span class="number">1024</span> / <span class="number">1024</span> + <span class="string">&quot;m&quot;</span>);        <span class="comment">// 空闲堆内存大小</span>        System.out.println(<span class="string">&quot;空闲堆内存大小freeMemory &quot;</span> + (<span class="type">int</span>) Runtime.getRuntime().freeMemory() / <span class="number">1024</span> / <span class="number">1024</span> + <span class="string">&quot;m&quot;</span>);        <span class="comment">// 最大可用总堆内存大小</span>        System.out.println(<span class="string">&quot;最大可用总堆内存maxMemory &quot;</span> + Runtime.getRuntime().maxMemory() / <span class="number">1024</span> / <span class="number">1024</span> + <span class="string">&quot;m&quot;</span>);    &#125;&#125;</code></pre><p><strong>通过Runtime获取</strong></p><pre><code class="highlight java"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">HeapSpaceInitial</span> &#123;<span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span>&#123;<span class="comment">//返回Java虚拟机中的堆内存总量</span><span class="type">long</span> <span class="variable">initialMemory</span> <span class="operator">=</span> Runtime.getRuntime().totalMemory() / <span class="number">1024</span> / <span class="number">1024</span>;<span class="comment">//返回Java虚拟机试图使用的最大堆内存量</span><span class="type">long</span> <span class="variable">maxMemory</span> <span class="operator">=</span> Runtime.getRuntime().maxMemory() / <span class="number">1024</span> / <span class="number">1024</span>;System.out.println(<span class="string">&quot;-Xms:&quot;</span> + initialMemory + <span class="string">&quot;M&quot;</span>);System.out.println(<span class="string">&quot;-Xmx:&quot;</span> + maxMemory + <span class="string">&quot;M&quot;</span>);System.out.println(<span class="string">&quot;系统内存大小为：&quot;</span> + maxMemory * <span class="number">4.0</span> / <span class="number">1024</span> + <span class="string">&quot;G&quot;</span>);System.out.println(<span class="string">&quot;系统内存大小为：&quot;</span> + initialMemory * <span class="number">64.0</span> / <span class="number">1024</span> + <span class="string">&quot;G&quot;</span>);&#125;&#125;</code></pre>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;一、JVM参数选项&quot;&gt;&lt;a href=&quot;#一、JVM参数选项&quot; class=&quot;headerlink&quot; title=&quot;一、JVM参数选项&quot;&gt;&lt;/a&gt;一、JVM参数选项&lt;/h1&gt;&lt;p&gt;官网地址：&lt;a href=&quot;https://docs.oracle.com/java</summary>
      
    
    
    
    <category term="JVM" scheme="https://georgechan95.github.io/categories/JVM/"/>
    
    
    <category term="java" scheme="https://georgechan95.github.io/tags/java/"/>
    
    <category term="jvm" scheme="https://georgechan95.github.io/tags/jvm/"/>
    
  </entry>
  
  <entry>
    <title>第二十三章-使用OQL语言查询对象信息</title>
    <link href="https://georgechan95.github.io/blog/490498600.html"/>
    <id>https://georgechan95.github.io/blog/490498600.html</id>
    <published>2024-08-24T07:02:10.000Z</published>
    <updated>2024-08-28T04:17:33.348Z</updated>
    
    <content type="html"><![CDATA[<p>MAT支持一种类似于SQL的查询语言OQL（Object Query Language）。OQL使用类SQL语法，可以在堆中进行对象的查找和筛选。</p><p><img src="https://raw.githubusercontent.com/GeorgeChan95/blogimg/master/img/2024/08/24/20240824-150903.png" alt="在MAT中使用OQL语句"></p><h2 id="1-SELECT子句"><a href="#1-SELECT子句" class="headerlink" title="1. SELECT子句"></a>1. SELECT子句</h2><p>在MAT中，Select子句的格式与SQL基本一致，用于指定要显示的列。Select子句中可以使用“＊”，查看结果对象的引用实例（相当于outgoing references）。</p><pre><code class="highlight sql"><span class="keyword">SELECT</span> <span class="operator">*</span> <span class="keyword">FROM</span> java.util.Vector v</code></pre><p>使用“OBJECTS”关键字，可以将返回结果集中的项以对象的形式显示。</p><pre><code class="highlight sql"><span class="keyword">SELECT</span> objects v.elementData <span class="keyword">FROM</span> java.util.Vector v<span class="keyword">SELECT</span> OBJECTS s.value <span class="keyword">FROM</span> java.lang.String s</code></pre><p>在Select子句中，使用“AS RETAINED SET”关键字可以得到所得对象的保留集。</p><pre><code class="highlight sql"><span class="keyword">SELECT</span> <span class="keyword">AS</span> RETAINED <span class="keyword">SET</span> <span class="operator">*</span><span class="keyword">FROM</span> com.atguigu.mat.Student</code></pre><p>“DISTINCT”关键字用于在结果集中去除重复对象。</p><pre><code class="highlight sql"><span class="keyword">SELECT</span> <span class="keyword">DISTINCT</span> OBJECTS classof(s) <span class="keyword">FROM</span> java.lang.String s</code></pre><h2 id="2-FROM子句"><a href="#2-FROM子句" class="headerlink" title="2. FROM子句"></a>2. FROM子句</h2><p>From子句用于指定查询范围，它可以指定类名、正则表达式或者对象地址。</p><pre><code class="highlight sql"><span class="keyword">SELECT</span> <span class="operator">*</span> <span class="keyword">FROM</span> java.lang.String s</code></pre><p>使用正则表达式，限定搜索范围，输出所有com.atguigu包下所有类的实例</p><pre><code class="highlight sql"><span class="keyword">SELECT</span> <span class="operator">*</span> <span class="keyword">FROM</span> &quot;com\.atguigu\..*&quot;</code></pre><p>使用类的地址进行搜索。使用类的地址的好处是可以区分被不同ClassLoader加载的同一种类型。</p><pre><code class="highlight sql"><span class="keyword">select</span> <span class="operator">*</span> <span class="keyword">from</span> <span class="number">0x37a0b4d</span></code></pre><h2 id="3-WHERE子句"><a href="#3-WHERE子句" class="headerlink" title="3. WHERE子句"></a>3. WHERE子句</h2><p>Where子句用于指定OQL的查询条件。OQL查询将只返回满足Where子句指定条件的对象。Where子句的格式与传统SQL极为相似。</p><p>返回长度大于1000的byte[]数组。</p><pre><code class="highlight sql"><span class="keyword">SELECT</span> <span class="operator">*</span> <span class="keyword">FROM</span> byte[] s <span class="keyword">WHERE</span> s.<span class="variable">@length</span><span class="operator">&gt;</span><span class="number">1000</span></code></pre><p><img src="https://raw.githubusercontent.com/GeorgeChan95/blogimg/master/img/2024/08/24/20240824-151855.png" alt="长度大于1000的byte[]数组"></p><p><img src="https://raw.githubusercontent.com/GeorgeChan95/blogimg/master/img/2024/08/24/20240824-151942.png" alt="查看对象被谁引用"></p><p>返回包含“java”子字符串的所有字符串，使用“LIKE”操作符，“LIKE”操作符的操作参数为正则表达式。</p><pre><code class="highlight sql"><span class="keyword">SELECT</span> <span class="operator">*</span> <span class="keyword">FROM</span> java.lang.String s <span class="keyword">WHERE</span> toString(s) <span class="keyword">LIKE</span> &quot;.*java.*&quot;</code></pre><p>返回所有value域不为null的字符串，使用“＝”操作符。</p><pre><code class="highlight sql"><span class="keyword">SELECT</span> <span class="operator">*</span> <span class="keyword">FROM</span> java.lang.String s <span class="keyword">where</span> s.value<span class="operator">!=</span><span class="keyword">null</span></code></pre><p>返回数组长度大于15，并且深堆大于1000字节的所有Vector对象。</p><pre><code class="highlight sql"><span class="keyword">SELECT</span> <span class="operator">*</span> <span class="keyword">FROM</span> java.util.Vector v <span class="keyword">WHERE</span> v.elementData.<span class="variable">@length</span><span class="operator">&gt;</span><span class="number">15</span> <span class="keyword">AND</span> v.<span class="variable">@retainedHeapSize</span><span class="operator">&gt;</span><span class="number">1000</span></code></pre><h2 id="4-内置对象与方法"><a href="#4-内置对象与方法" class="headerlink" title="4. 内置对象与方法"></a>4. 内置对象与方法</h2><p>OQL中可以访问堆内对象的属性，也可以访问堆内代理对象的属性。访问堆内对象的属性时，格式如下，其中alias为对象名称：</p><p><code>[ &lt;alias&gt;. ] &lt;field&gt; . &lt;field&gt;. &lt;field&gt;</code></p><p>访问java.io.File对象的path属性，并进一步访问path的value属性：</p><pre><code class="highlight sql"><span class="keyword">SELECT</span> toString(f.path.value) <span class="keyword">FROM</span> java.io.File f</code></pre><p>显示String对象的内容、objectid和objectAddress。</p><pre><code class="highlight sql"><span class="keyword">SELECT</span> s.toString(),s.<span class="variable">@objectId</span>, s.<span class="variable">@objectAddress</span> <span class="keyword">FROM</span> java.lang.String s</code></pre><p>显示java.util.Vector内部数组的长度。</p><pre><code class="highlight sql"><span class="keyword">SELECT</span> v.elementData.<span class="variable">@length</span> <span class="keyword">FROM</span> java.util.Vector v</code></pre><p>显示所有的java.util.Vector对象及其子类型</p><pre><code class="highlight sql"><span class="keyword">select</span> <span class="operator">*</span> <span class="keyword">from</span> INSTANCEOF java.util.Vector</code></pre>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;MAT支持一种类似于SQL的查询语言OQL（Object Query Language）。OQL使用类SQL语法，可以在堆中进行对象的查找和筛选。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://raw.githubusercontent.com/GeorgeChan95</summary>
      
    
    
    
    <category term="JVM" scheme="https://georgechan95.github.io/categories/JVM/"/>
    
    
    <category term="java" scheme="https://georgechan95.github.io/tags/java/"/>
    
    <category term="jvm" scheme="https://georgechan95.github.io/tags/jvm/"/>
    
  </entry>
  
  <entry>
    <title>第二十三章-浅堆-深堆-内存泄漏</title>
    <link href="https://georgechan95.github.io/blog/1471620196.html"/>
    <id>https://georgechan95.github.io/blog/1471620196.html</id>
    <published>2024-08-24T05:04:37.000Z</published>
    <updated>2024-08-28T04:17:33.349Z</updated>
    
    <content type="html"><![CDATA[<h1 id="一、浅堆与深堆"><a href="#一、浅堆与深堆" class="headerlink" title="一、浅堆与深堆"></a>一、浅堆与深堆</h1><h2 id="1-shallow-heap-浅堆"><a href="#1-shallow-heap-浅堆" class="headerlink" title="1. shallow heap(浅堆)"></a>1. shallow heap(浅堆)</h2><p>shallow heap是对象本身的大小，不包括其引用的对象。<br>对于非数组类型：shallow heap就是对象与其成员变量加在一起的大小。<br>对于数组类型：shallow heap就是数组各个元素大小之和。</p><h2 id="2-retained-heap-保留集"><a href="#2-retained-heap-保留集" class="headerlink" title="2. retained heap(保留集)"></a>2. retained heap(保留集)</h2><p>对象remainder heap 大小 &#x3D; 对象shallow heap大小 + 对象直接或者间接引用的对象大小（排除被GC ROOT直接引用的对象）。<br>如下图所示：</p><p><img src="https://raw.githubusercontent.com/GeorgeChan95/blogimg/master/img/2024/08/20/20240820-194720.png" alt="对象引用关系"></p><p><strong>对象引用关系</strong><br>OBJECT A 的 remainder heap &#x3D; OBJECT A 的 shallow heap<br>OBJECT B的 remainder heap &#x3D; OBJECT B 的 shallow heap + OBJECT C 的对象大小 + OBJECT E 的对象大小</p><p>所以对象的remainder heap其实接近进行垃圾回收时，清除该对象时所能获取的堆内存大小（有的对象可能还被其他对象引用，垃圾回收时，不能清除）。</p><p>下面是用mat对从服务器上面dump出来Java虚拟机内存进行解析之后的结果：</p><p><img src="https://raw.githubusercontent.com/GeorgeChan95/blogimg/master/img/2024/08/20/20240820-194952.png" alt="内存分析"></p><p><strong>Java内存解析结果</strong></p><p>其中，Objects为类的对象的个数。Shallow Heap是这些对象自身大小之和，Remainder Heap是这些对象自身以及这些对象直接或者间接引用的对象大小总和。</p><h2 id="3-补充：对象实际大小"><a href="#3-补充：对象实际大小" class="headerlink" title="3. 补充：对象实际大小"></a>3. 补充：对象实际大小</h2><p>另外一个常用的概念是对象的实际大小。这里，对象的实际大小定义为一个对象所能触及的所有对象的浅堆大小之和，也就是通常意义上我们说的对象大小。与深堆相比，似乎这个在日常开发中更为直观和被人接受，但实际上，<strong>这个概念和垃圾回收无关</strong>。</p><p>下图显示了一个简单的对象引用关系图，对象A引用了C和D，对象B引用了C和E。那么对象A的浅堆大小只是A本身，不含C和D，而A的实际大小为A、C、D三者之和。而A的深堆大小为A与D之和，由于对象C还可以通过对象B访问到，因此不在对象A的深堆范围内。</p><p><img src="https://raw.githubusercontent.com/GeorgeChan95/blogimg/master/img/2024/08/20/20240820-195149.png" alt="对象引用关系"></p><h2 id="4-案例分析：StudentTrace"><a href="#4-案例分析：StudentTrace" class="headerlink" title="4. 案例分析：StudentTrace"></a>4. 案例分析：StudentTrace</h2><p><strong>案例代码</strong></p><pre><code class="highlight java"><span class="comment">/**</span><span class="comment"> * 有一个学生浏览网页的记录程序，它将记录 每个学生访问过的网站地址。</span><span class="comment"> * 它由三个部分组成：Student、WebPage和StudentTrace三个类</span><span class="comment"> *</span><span class="comment"> *  -XX:+HeapDumpBeforeFullGC -XX:HeapDumpPath=d:\student.hprof</span><span class="comment"> */</span><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">StudentTrace</span> &#123;    <span class="keyword">static</span> List&lt;WebPage&gt; webpages = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;WebPage&gt;();    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">createWebPages</span><span class="params">()</span> &#123;        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; <span class="number">100</span>; i++) &#123;            <span class="type">WebPage</span> <span class="variable">wp</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">WebPage</span>();            wp.setUrl(<span class="string">&quot;http://www.&quot;</span> + Integer.toString(i) + <span class="string">&quot;.com&quot;</span>);            wp.setContent(Integer.toString(i));            webpages.add(wp);        &#125;    &#125;    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;        createWebPages();<span class="comment">//创建了100个网页</span>        <span class="comment">//创建3个学生对象</span>        <span class="type">Student</span> <span class="variable">st3</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Student</span>(<span class="number">3</span>, <span class="string">&quot;Tom&quot;</span>);        <span class="type">Student</span> <span class="variable">st5</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Student</span>(<span class="number">5</span>, <span class="string">&quot;Jerry&quot;</span>);        <span class="type">Student</span> <span class="variable">st7</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Student</span>(<span class="number">7</span>, <span class="string">&quot;Lily&quot;</span>);        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; webpages.size(); i++) &#123;            <span class="keyword">if</span> (i % st3.getId() == <span class="number">0</span>)                st3.visit(webpages.get(i));            <span class="keyword">if</span> (i % st5.getId() == <span class="number">0</span>)                st5.visit(webpages.get(i));            <span class="keyword">if</span> (i % st7.getId() == <span class="number">0</span>)                st7.visit(webpages.get(i));        &#125;        webpages.clear();        System.gc();    &#125;&#125;<span class="keyword">class</span> <span class="title class_">Student</span> &#123;    <span class="keyword">private</span> <span class="type">int</span> id;    <span class="keyword">private</span> String name;    <span class="keyword">private</span> List&lt;WebPage&gt; history = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();    <span class="keyword">public</span> <span class="title function_">Student</span><span class="params">(<span class="type">int</span> id, String name)</span> &#123;        <span class="built_in">super</span>();        <span class="built_in">this</span>.id = id;        <span class="built_in">this</span>.name = name;    &#125;    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">getId</span><span class="params">()</span> &#123;        <span class="keyword">return</span> id;    &#125;    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setId</span><span class="params">(<span class="type">int</span> id)</span> &#123;        <span class="built_in">this</span>.id = id;    &#125;    <span class="keyword">public</span> String <span class="title function_">getName</span><span class="params">()</span> &#123;        <span class="keyword">return</span> name;    &#125;    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setName</span><span class="params">(String name)</span> &#123;        <span class="built_in">this</span>.name = name;    &#125;    <span class="keyword">public</span> List&lt;WebPage&gt; <span class="title function_">getHistory</span><span class="params">()</span> &#123;        <span class="keyword">return</span> history;    &#125;    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setHistory</span><span class="params">(List&lt;WebPage&gt; history)</span> &#123;        <span class="built_in">this</span>.history = history;    &#125;    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">visit</span><span class="params">(WebPage wp)</span> &#123;        <span class="keyword">if</span> (wp != <span class="literal">null</span>) &#123;            history.add(wp);        &#125;    &#125;&#125;<span class="keyword">class</span> <span class="title class_">WebPage</span> &#123;    <span class="keyword">private</span> String url;    <span class="keyword">private</span> String content;    <span class="keyword">public</span> String <span class="title function_">getUrl</span><span class="params">()</span> &#123;        <span class="keyword">return</span> url;    &#125;    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setUrl</span><span class="params">(String url)</span> &#123;        <span class="built_in">this</span>.url = url;    &#125;    <span class="keyword">public</span> String <span class="title function_">getContent</span><span class="params">()</span> &#123;        <span class="keyword">return</span> content;    &#125;    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setContent</span><span class="params">(String content)</span> &#123;        <span class="built_in">this</span>.content = content;    &#125;&#125;</code></pre><p><img src="https://raw.githubusercontent.com/GeorgeChan95/blogimg/master/img/2024/08/20/20240820-200332.png" alt="线程对象追踪"></p><p><strong>结论：</strong><br>elementData 数组的浅堆是80个字节，而 elementData 数组中的所有 WebPage 对象的深堆之和是1208个字节，所以加在一起就是 elementData 数组的深堆之和，也就是1288个字节</p><p><strong>解析：</strong></p><p>默认采用了指针压缩则为12字节，没有采用则为16字节（数组还需要加上数组长度）。</p><p>1.为什么有152字节和144字节：因为我们的URL和content存在两种情况<br>        URL:”<a href="http://www.7.com"、content:"7"-----URL:"http://www.14.com"、content:"14">http://www.7.com&quot;、content:&quot;7&quot;-----URL:&quot;http://www.14.com&quot;、content:&quot;14</a>“<br>        第一种URL长度为16，底层的char数组的占用空间为(【】方括号里面整个都属于对象头，分开写方便大家理解)<br>            【普通对象头(12) + 数组长度(4)】 + 16个字符(32) &#x3D; 48字节，符合8字节对齐<br>            同理content 占用 【普通对象头(12) +数组长度(4)】+ 一个字符(2) &#x3D; 18字节,八字节对齐&#x3D;24字节<br>        第二种URL长度为17，底层的插入数组的占用空间为<br>            【普通对象头(12) + 数组长度(4)】 + 17个字符(34) &#x3D; 50字节，不符合8字节对齐，对齐为56<br>            同理content 占用 【普通对象头(12) +数组长度(4)】+ 两个字符(4) &#x3D; 20字节,八字节对齐&#x3D;24字节<br>        所以第一种总字节为48 + 24 &#x3D; 72,第二种总字节为56 + 24 &#x3D; 80<br>        因此第二种比第一种多了8字节，所以是152和144。<br>        (为什么总大小是152而不是72是因为我们只计算了String底层的char数组的区别没有计算各变量本身的浅堆,<br>        因为结构都相同，所以差别就差在内容的占用上)</p><p>2.为什么最终结果是1288<br>        首先ElementData数组本身的浅堆大小为<br>        【普通对象头(12) + 数组长度(4)】 + 数组内容【15个Obejct引用&#x3D;16*4】 &#x3D; 76,八字节对齐&#x3D;80字节<br>        15个Object分为13个152字节+2个144字节，总大小为&#x3D;2264字节<br>        7号和其他student重复的有0、21、42、63、84、35、70总计6个152和1一个144<br>        所以2264 - 6 * 152 - 144 &#x3D; 1208字节<br>    所以ElementData本身的浅堆80 + 仅能通过它到达的浅堆1208 &#x3D; 1288</p><h1 id="二、支配树（Dominator-Tree）"><a href="#二、支配树（Dominator-Tree）" class="headerlink" title="二、支配树（Dominator Tree）"></a>二、支配树（Dominator Tree）</h1><p>支配树的概念源自<strong>图论</strong>。</p><p>MAT提供了一个称为<strong>支配树</strong>（Dominator Tree)的对象图。支配树体现了<strong>对象实例</strong>间的支配关系。在对象引用图中，所有指向对象B的路径都经过对象A , 则认为对象A支配对象B。如果对象A是离对象B最近的一个支配对象 ，则认为对象A为对象B的<strong>直接支配者</strong>。支配树是基于<strong>对象间的引用图</strong>所建立的，它有以下基本性质：</p><ul><li>对象A的子树（所有被对象A支配的对象集合）表示对象A的保留集（retained set) , 即深堆</li><li>如果对象A支配对象B , 那么对象A的直接支配者也支配对象B</li><li>支配树的边与对象引用图的边不直接对应</li></ul><p>如下图所示：</p><p>左图表示<strong>对象引用图</strong>，右图表示左图所对应的<strong>支配树</strong>。</p><p>对象A和B由根对象直接支配，由于在到对象C的路径中，可以经过A , 也可以经过B , 因此对象C的直接支配者也是根对象。<br>对象F与对象D相互引用 ，因为到对象F的所有路径必然经过对象D , 因此，对象D是对象F的直接支配者 。<br>而到对象D的所有路径中，必然经过对象C , 即使是从对象F到对象D的引用 ，从根节点出发，也是经过对象C的，所以 ，对象D的直接支配者为对象C。</p><p><img src="https://raw.githubusercontent.com/GeorgeChan95/blogimg/master/img/2024/08/22/20240822-184127.png" alt="支配树"></p><p>同理，对象E支配对象G。到达对象H的可以通过对象D , 也可以通过对象E , 因此对象D和E都不能支配对象H , 而经过对象C既可以到达D也可以到达E , 因此<strong>对象C为对象H的直接支配者</strong>。</p><p>在MAT中，单击工具栏上的对象支配树按钮，可以打开<strong>对象支配树</strong>视图。</p><p><img src="https://raw.githubusercontent.com/GeorgeChan95/blogimg/master/img/2024/08/22/20240822-184933.png" alt="MAT通过dump文件查看对象支配树"></p><p>下图显示了对象支配树视图的一部分。该截图显示部分Lily学生的history队列的直接支配对象。即当Lily对象被回收，也会一并回收的所有对象。显然能被3或者5整除的网页不会出现在该列表中，因为它们同时被另外两名学生对象引用。</p><h1 id="三、内存泄漏"><a href="#三、内存泄漏" class="headerlink" title="三、内存泄漏"></a>三、内存泄漏</h1><h2 id="1-内存泄漏（memory-leak）"><a href="#1-内存泄漏（memory-leak）" class="headerlink" title="1. 内存泄漏（memory leak）"></a>1. 内存泄漏（memory leak）</h2><p>可达性分析算法来判断对象是否是不再使用的对象，本质都是判断一个对象是否还被引用。那么对于这种情况下，由于代码的实现不同就会出现很多种内存泄漏问题（让JVM误以为此对象还在引用中，无法回收，造成内存泄漏）。</p><ul><li>是否还被使用？是</li><li>是否还被需要？否</li></ul><p><img src="https://raw.githubusercontent.com/GeorgeChan95/blogimg/master/img/2024/08/24/20240824-135555.png" alt="内存泄漏"></p><p>严格来说，只有对象不会再被程序用到了，但是GC又不能回收他们的情况，才叫内存泄漏。但实际情况很多时候一些不太好的实践（或疏忽）会导致对象的生命周期变得很长甚至导致OOM，也可以叫做宽泛意义上的“内存泄漏”。</p><p>如下图，当Y生命周期结束的时候，X依然引用着Y，这时候，垃圾回收期是不会回收对象Y的；如果对象X还引用着生命周期比较短的A、B、C，对象A又引用着对象 a、b、c，这样就可能造成大量无用的对象不能被回收，进而占据了内存资源，造成内存泄漏，直到内存溢出。</p><p><img src="https://raw.githubusercontent.com/GeorgeChan95/blogimg/master/img/2024/08/24/20240824-135602.png" alt="内存泄漏示意"></p><p>申请了内存用完了不释放，比如一共有1024M的内存，分配了512M的内存一直不回收，那么可以用的内存只有512M了，仿佛泄露掉了一部分；通俗一点讲的话，内存泄漏就是【占着茅坑不拉shi】。</p><h2 id="2-内存溢出（out-of-memory）"><a href="#2-内存溢出（out-of-memory）" class="headerlink" title="2. 内存溢出（out of memory）"></a>2. 内存溢出（out of memory）</h2><p>申请内存时，没有足够的内存可以使用；通俗一点儿讲，一个厕所就三个坑，有两个站着茅坑不走的（内存泄漏），剩下最后一个坑，厕所表示接待压力很大，这时候一下子来了两个人，坑位（内存）就不够了，内存泄漏变成内存溢出了。可见，内存泄漏和内存溢出的关系：内存泄漏的增多，最终会导致内存溢出。</p><p><strong>泄漏的分类</strong></p><ul><li><p>经常发生：发生内存泄露的代码会被多次执行，每次执行，泄露一块内存；</p></li><li><p>偶然发生：在某些特定情况下才会发生</p></li><li><p>一次性：发生内存泄露的方法只会执行一次；</p></li><li><p>隐式泄漏：一直占着内存不释放，直到执行结束；严格的说这个不算内存泄漏，因为最终释放掉了，但是如果执行时间特别长，也可能会导致内存耗尽。</p></li></ul><h2 id="3-Java中内存泄露的8种情况"><a href="#3-Java中内存泄露的8种情况" class="headerlink" title="3. Java中内存泄露的8种情况"></a>3. Java中内存泄露的8种情况</h2><h3 id="3-1-静态集合类"><a href="#3-1-静态集合类" class="headerlink" title="3.1 静态集合类"></a>3.1 静态集合类</h3><p>静态集合类，如 HashMap、LinkedList 等等。如果这些容器为静态的，那么它们的生命周期与JVM程序一致，则容器中的对象在程序结束之前将不能被释放，从而造成内存泄漏。简单而言，长生命周期的对象持有短生命周期对象的引用，尽管短生命周期的对象不再使用，但是因为长生命周期对象持有它的引用而导致不能被回收。</p><pre><code class="highlight java"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">MemoryLeak</span> &#123;    <span class="keyword">static</span> <span class="type">List</span> <span class="variable">list</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ArrayList</span>();    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">oomTests</span><span class="params">()</span>&#123;        Object obj＝<span class="keyword">new</span> <span class="title class_">Object</span>();<span class="comment">//局部变量</span>        list.add(obj);    &#125;&#125;</code></pre><h3 id="3-2-单例模式"><a href="#3-2-单例模式" class="headerlink" title="3.2 单例模式"></a>3.2 单例模式</h3><p>单例模式，和静态集合导致内存泄露的原因类似，因为单例的静态特性，它的生命周期和 JVM 的生命周期一样长，所以如果单例对象如果持有外部对象的引用，那么这个外部对象也不会被回收，那么就会造成内存泄漏。</p><h3 id="3-3-内部类持有外部类"><a href="#3-3-内部类持有外部类" class="headerlink" title="3.3 内部类持有外部类"></a>3.3 内部类持有外部类</h3><p>内部类持有外部类，如果一个外部类的实例对象的方法返回了一个内部类的实例对象。这个内部类对象被长期引用了，即使那个外部类实例对象不再被使用，但由于内部类持有外部类的实例对象，这个外部类对象将不会被垃圾回收，这也会造成内存泄漏。</p><h3 id="3-4-各种连接，如数据库连接、网络连接和IO连接等"><a href="#3-4-各种连接，如数据库连接、网络连接和IO连接等" class="headerlink" title="3.4 各种连接，如数据库连接、网络连接和IO连接等"></a>3.4 各种连接，如数据库连接、网络连接和IO连接等</h3><p>在对数据库进行操作的过程中，首先需要建立与数据库的连接，当不再使用时，需要调用close方法来释放与数据库的连接。只有连接被关闭后，垃圾回收器才会回收对应的对象。否则，如果在访问数据库的过程中，对Connection、Statement或ResultSet不显性地关闭，将会造成大量的对象无法被回收，从而引起内存泄漏。</p><pre><code class="highlight java"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;    <span class="keyword">try</span>&#123;        <span class="type">Connection</span> <span class="variable">conn</span> <span class="operator">=</span><span class="literal">null</span>;        Class.forName(<span class="string">&quot;com.mysql.jdbc.Driver&quot;</span>);        conn =DriverManager.getConnection(<span class="string">&quot;url&quot;</span>,<span class="string">&quot;&quot;</span>,<span class="string">&quot;&quot;</span>);        <span class="type">Statement</span> <span class="variable">stmt</span> <span class="operator">=</span>conn.createStatement();        <span class="type">ResultSet</span> <span class="variable">rs</span> <span class="operator">=</span>stmt.executeQuery(<span class="string">&quot;....&quot;</span>);    &#125; <span class="keyword">catch</span>（Exception e）&#123;<span class="comment">//异常日志</span>    &#125; <span class="keyword">finally</span> &#123;        <span class="comment">// 1．关闭结果集 Statement</span>        <span class="comment">// 2．关闭声明的对象 ResultSet</span>        <span class="comment">// 3．关闭连接 Connection</span>    &#125;&#125;</code></pre><h3 id="3-5-变量不合理的作用域"><a href="#3-5-变量不合理的作用域" class="headerlink" title="3.5 变量不合理的作用域"></a>3.5 变量不合理的作用域</h3><p>变量不合理的作用域。一般而言，一个变量的定义的作用范围大于其使用范围，很有可能会造成内存泄漏。另一方面，如果没有及时地把对象设置为null，很有可能导致内存泄漏的发生。</p><pre><code class="highlight java"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">UsingRandom</span> &#123;    <span class="keyword">private</span> String msg;    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">receiveMsg</span><span class="params">()</span>&#123;        readFromNet();<span class="comment">//从网络中接受数据保存到msg中</span>        saveDB();<span class="comment">//把msg保存到数据库中</span>    &#125;&#125;</code></pre><p>如上面这个伪代码，通过 readFromNet 方法把接受的消息保存在变量msg中，然后调用saveDB方法把msg的内容保存到数据库中，此时msg已经就没用了，由于msg的生命周期与对象的生命周期相同，此时msg还不能回收，因此造成了内存泄漏。实际上这个msg变量可以放在receiveMsg方法内部，当方法使用完，那么msg的生命周期也就结束，此时就可以回收了。还有一种方法，在使用完msg后，把msg设置为null，这样垃圾回收器也会回收msg的内存空间。</p><h3 id="3-6-改变哈希值"><a href="#3-6-改变哈希值" class="headerlink" title="3.6 改变哈希值"></a>3.6 改变哈希值</h3><p>改变哈希值，当一个对象被存储进 HashSet 集合中以后，就不能修改这个对象中的那些参与计算哈希值的字段了。</p><p>否则，对象修改后的哈希值与最初存储进HashSet集合中时的哈希值就不同了，在这种情况下，即使在 contains 方法使用该对象的当前引用作为的参数去HashSet集合中检索对象，也将返回找不到对象的结果，这也会导致无法从HashSet集合中单独删除当前对象，造成内存泄漏。</p><p>这也是 String 为什么被设置成了不可变类型，我们可以放心地把 String 存入 HashSet，或者把String 当做 HashMap 的 key 值；</p><p>当我们想把自己定义的类保存到散列表的时候，需要保证对象的 hashCode 不可变。</p><pre><code class="highlight java"><span class="comment">/**</span><span class="comment"> * 例1</span><span class="comment"> */</span><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ChangeHashCode</span> &#123;    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;        <span class="type">HashSet</span> <span class="variable">set</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">HashSet</span>();        <span class="type">Person</span> <span class="variable">p1</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Person</span>(<span class="number">1001</span>, <span class="string">&quot;AA&quot;</span>);        <span class="type">Person</span> <span class="variable">p2</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Person</span>(<span class="number">1002</span>, <span class="string">&quot;BB&quot;</span>);        set.add(p1);        set.add(p2);        p1.name = <span class="string">&quot;CC&quot;</span>;<span class="comment">//导致了内存的泄漏</span>        set.remove(p1); <span class="comment">//删除失败</span>        System.out.println(set);        set.add(<span class="keyword">new</span> <span class="title class_">Person</span>(<span class="number">1001</span>, <span class="string">&quot;CC&quot;</span>));        System.out.println(set);        set.add(<span class="keyword">new</span> <span class="title class_">Person</span>(<span class="number">1001</span>, <span class="string">&quot;AA&quot;</span>));        System.out.println(set);    &#125;&#125;<span class="keyword">class</span> <span class="title class_">Person</span> &#123;    <span class="type">int</span> id;    String name;    <span class="keyword">public</span> <span class="title function_">Person</span><span class="params">(<span class="type">int</span> id, String name)</span> &#123;        <span class="built_in">this</span>.id = id;        <span class="built_in">this</span>.name = name;    &#125;    <span class="meta">@Override</span>    <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">equals</span><span class="params">(Object o)</span> &#123;        <span class="keyword">if</span> (<span class="built_in">this</span> == o) <span class="keyword">return</span> <span class="literal">true</span>;        <span class="keyword">if</span> (!(o <span class="keyword">instanceof</span> Person)) <span class="keyword">return</span> <span class="literal">false</span>;        <span class="type">Person</span> <span class="variable">person</span> <span class="operator">=</span> (Person) o;        <span class="keyword">if</span> (id != person.id) <span class="keyword">return</span> <span class="literal">false</span>;        <span class="keyword">return</span> name != <span class="literal">null</span> ? name.equals(person.name) : person.name == <span class="literal">null</span>;    &#125;    <span class="meta">@Override</span>    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">hashCode</span><span class="params">()</span> &#123;        <span class="type">int</span> <span class="variable">result</span> <span class="operator">=</span> id;        result = <span class="number">31</span> * result + (name != <span class="literal">null</span> ? name.hashCode() : <span class="number">0</span>);        <span class="keyword">return</span> result;    &#125;    <span class="meta">@Override</span>    <span class="keyword">public</span> String <span class="title function_">toString</span><span class="params">()</span> &#123;        <span class="keyword">return</span> <span class="string">&quot;Person&#123;&quot;</span> +                <span class="string">&quot;id=&quot;</span> + id +                <span class="string">&quot;, name=&#x27;&quot;</span> + name + <span class="string">&#x27;\&#x27;&#x27;</span> +                <span class="string">&#x27;&#125;&#x27;</span>;    &#125;&#125;</code></pre><pre><code class="highlight java"><span class="comment">/**</span><span class="comment"> * 例2</span><span class="comment"> */</span><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ChangeHashCode1</span> &#123;    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;        HashSet&lt;Point&gt; hs = <span class="keyword">new</span> <span class="title class_">HashSet</span>&lt;Point&gt;();        <span class="type">Point</span> <span class="variable">cc</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Point</span>();        cc.setX(<span class="number">10</span>);<span class="comment">//hashCode = 41</span>        hs.add(cc);        cc.setX(<span class="number">20</span>);<span class="comment">//hashCode = 51  此行为导致了内存的泄漏</span>        System.out.println(<span class="string">&quot;hs.remove = &quot;</span> + hs.remove(cc));<span class="comment">//false</span>        hs.add(cc);        System.out.println(<span class="string">&quot;hs.size = &quot;</span> + hs.size());<span class="comment">//size = 2</span>        System.out.println(hs);    &#125;&#125;<span class="keyword">class</span> <span class="title class_">Point</span> &#123;    <span class="type">int</span> x;    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">getX</span><span class="params">()</span> &#123;        <span class="keyword">return</span> x;    &#125;    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setX</span><span class="params">(<span class="type">int</span> x)</span> &#123;        <span class="built_in">this</span>.x = x;    &#125;    <span class="meta">@Override</span>    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">hashCode</span><span class="params">()</span> &#123;        <span class="keyword">final</span> <span class="type">int</span> <span class="variable">prime</span> <span class="operator">=</span> <span class="number">31</span>;        <span class="type">int</span> <span class="variable">result</span> <span class="operator">=</span> <span class="number">1</span>;        result = prime * result + x;        <span class="keyword">return</span> result;    &#125;    <span class="meta">@Override</span>    <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">equals</span><span class="params">(Object obj)</span> &#123;        <span class="keyword">if</span> (<span class="built_in">this</span> == obj) <span class="keyword">return</span> <span class="literal">true</span>;        <span class="keyword">if</span> (obj == <span class="literal">null</span>) <span class="keyword">return</span> <span class="literal">false</span>;        <span class="keyword">if</span> (getClass() != obj.getClass()) <span class="keyword">return</span> <span class="literal">false</span>;        <span class="type">Point</span> <span class="variable">other</span> <span class="operator">=</span> (Point) obj;        <span class="keyword">if</span> (x != other.x) <span class="keyword">return</span> <span class="literal">false</span>;        <span class="keyword">return</span> <span class="literal">true</span>;    &#125;    <span class="meta">@Override</span>    <span class="keyword">public</span> String <span class="title function_">toString</span><span class="params">()</span> &#123;        <span class="keyword">return</span> <span class="string">&quot;Point&#123;&quot;</span> +                <span class="string">&quot;x=&quot;</span> + x +                <span class="string">&#x27;&#125;&#x27;</span>;    &#125;&#125;</code></pre><h3 id="3-7-缓存泄露"><a href="#3-7-缓存泄露" class="headerlink" title="3.7 缓存泄露"></a>3.7 缓存泄露</h3><p>内存泄漏的另一个常见来源是缓存，一旦你把对象引用放入到缓存中，他就很容易遗忘。比如：之前项目在一次上线的时候，应用启动奇慢直到夯死，就是因为代码中会加载一个表中的数据到缓存（内存）中，测试环境只有几百条数据，但是生产环境有几百万的数据。</p><p>对于这个问题，可以使用WeakHashMap代表缓存，此种Map的特点是，当除了自身有对key的引用外，此key没有其他引用那么此map会自动丢弃此值。</p><p>public class MapTest {<br>    static Map wMap &#x3D; new WeakHashMap();<br>    static Map map &#x3D; new HashMap();</p><pre><code class="highlight java"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">MapTest</span> &#123;    <span class="keyword">static</span> <span class="type">Map</span> <span class="variable">wMap</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">WeakHashMap</span>();    <span class="keyword">static</span> <span class="type">Map</span> <span class="variable">map</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">HashMap</span>();    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;        init();        testWeakHashMap();        testHashMap();    &#125;    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">init</span><span class="params">()</span> &#123;        <span class="type">String</span> <span class="variable">ref1</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">String</span>(<span class="string">&quot;obejct1&quot;</span>);        <span class="type">String</span> <span class="variable">ref2</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">String</span>(<span class="string">&quot;obejct2&quot;</span>);        <span class="type">String</span> <span class="variable">ref3</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">String</span>(<span class="string">&quot;obejct3&quot;</span>);        <span class="type">String</span> <span class="variable">ref4</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">String</span>(<span class="string">&quot;obejct4&quot;</span>);        wMap.put(ref1, <span class="string">&quot;cacheObject1&quot;</span>);        wMap.put(ref2, <span class="string">&quot;cacheObject2&quot;</span>);        map.put(ref3, <span class="string">&quot;cacheObject3&quot;</span>);        map.put(ref4, <span class="string">&quot;cacheObject4&quot;</span>);        System.out.println(<span class="string">&quot;String引用ref1，ref2，ref3，ref4 消失&quot;</span>);    &#125;    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">testWeakHashMap</span><span class="params">()</span> &#123;        System.out.println(<span class="string">&quot;WeakHashMap GC之前&quot;</span>);        <span class="keyword">for</span> (Object o : wMap.entrySet()) &#123;            System.out.println(o);        &#125;        <span class="keyword">try</span> &#123;            System.gc();            TimeUnit.SECONDS.sleep(<span class="number">5</span>);        &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;            e.printStackTrace();        &#125;        System.out.println(<span class="string">&quot;WeakHashMap GC之后&quot;</span>);        <span class="keyword">for</span> (Object o : wMap.entrySet()) &#123;            System.out.println(o);        &#125;    &#125;    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">testHashMap</span><span class="params">()</span> &#123;        System.out.println(<span class="string">&quot;HashMap GC之前&quot;</span>);        <span class="keyword">for</span> (Object o : map.entrySet()) &#123;            System.out.println(o);        &#125;        <span class="keyword">try</span> &#123;            System.gc();            TimeUnit.SECONDS.sleep(<span class="number">5</span>);        &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;            e.printStackTrace();        &#125;        System.out.println(<span class="string">&quot;HashMap GC之后&quot;</span>);        <span class="keyword">for</span> (Object o : map.entrySet()) &#123;            System.out.println(o);        &#125;    &#125;&#125;</code></pre><p>上面代码和图示主演演示WeakHashMap如何自动释放缓存对象，当init函数执行完成后，局部变量字符串引用weakd1，weakd2，d1，d2都会消失，此时只有静态map中保存中对字符串对象的引用，可以看到，调用gc之后，HashMap的没有被回收，而WeakHashMap里面的缓存被回收了。</p><h3 id="3-8-监听器和其他回调"><a href="#3-8-监听器和其他回调" class="headerlink" title="3.8 监听器和其他回调"></a>3.8 监听器和其他回调</h3><p>内存泄漏第三个常见来源是监听器和其他回调，如果客户端在你实现的API中注册回调，却没有显示的取消，那么就会积聚。</p><p>需要确保回调立即被当作垃圾回收的最佳方法是只保存它的弱引用，例如将他们保存成为WeakHashMap中的键。</p><h1 id="四、内存泄露案例分析"><a href="#四、内存泄露案例分析" class="headerlink" title="四、内存泄露案例分析"></a>四、内存泄露案例分析</h1><pre><code class="highlight java"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Stack</span> &#123;    <span class="keyword">private</span> Object[] elements;    <span class="keyword">private</span> <span class="type">int</span> <span class="variable">size</span> <span class="operator">=</span> <span class="number">0</span>;    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">int</span> <span class="variable">DEFAULT_INITIAL_CAPACITY</span> <span class="operator">=</span> <span class="number">16</span>;    <span class="keyword">public</span> <span class="title function_">Stack</span><span class="params">()</span> &#123;        elements = <span class="keyword">new</span> <span class="title class_">Object</span>[DEFAULT_INITIAL_CAPACITY];    &#125;    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">push</span><span class="params">(Object e)</span> &#123; <span class="comment">//入栈</span>        ensureCapacity();        elements[size++] = e;    &#125;    <span class="keyword">public</span> Object <span class="title function_">pop</span><span class="params">()</span> &#123; <span class="comment">//出栈</span>        <span class="keyword">if</span> (size == <span class="number">0</span>)            <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">EmptyStackException</span>();        <span class="keyword">return</span> elements[--size];    &#125;    <span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">ensureCapacity</span><span class="params">()</span> &#123;        <span class="keyword">if</span> (elements.length == size)            elements = Arrays.copyOf(elements, <span class="number">2</span> * size + <span class="number">1</span>);    &#125;&#125;</code></pre><p>上述程序并没有明显的错误，但是这段程序有一个内存泄漏，随着GC活动的增加，或者内存占用的不断增加，程序性能的降低就会表现出来，严重时可导致内存泄漏，但是这种失败情况相对较少。</p><p>代码的主要问题在pop函数，下面通过这张图示展现。假设这个栈一直增长，增长后如下图所示</p><p><img src="https://raw.githubusercontent.com/GeorgeChan95/blogimg/master/img/2024/08/24/20240824-145444.png" alt="pop方法内存泄漏"></p><p>当进行大量的pop操作时，由于引用未进行置空，gc是不会释放的，如下图所示</p><p><img src="https://raw.githubusercontent.com/GeorgeChan95/blogimg/master/img/2024/08/24/20240824-145558.png" alt="pop方法内存泄漏2"></p><p>从上图中看以看出，如果栈先增长，再收缩，那么从栈中弹出的对象将不会被当作垃圾回收，即使程序不再使用栈中的这些队象，他们也不会回收，因为栈中仍然保存这对象的引用，俗称过期引用，这个内存泄露很隐蔽。</p><p>将代码中的pop()方法变成如下方法：</p><pre><code class="highlight java"><span class="keyword">public</span> Object <span class="title function_">pop</span><span class="params">()</span> &#123;    <span class="keyword">if</span> (size == <span class="number">0</span>)        <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">EmptyStackException</span>();    <span class="type">Object</span> <span class="variable">result</span> <span class="operator">=</span> elements[--size];    elements[size] = <span class="literal">null</span>;    <span class="keyword">return</span> result;&#125;</code></pre><p>一旦引用过期，清空这些引用，将引用置空。</p><p><img src="https://raw.githubusercontent.com/GeorgeChan95/blogimg/master/img/2024/08/24/20240824-145718.png" alt="pop方法解决内存泄漏"></p>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;一、浅堆与深堆&quot;&gt;&lt;a href=&quot;#一、浅堆与深堆&quot; class=&quot;headerlink&quot; title=&quot;一、浅堆与深堆&quot;&gt;&lt;/a&gt;一、浅堆与深堆&lt;/h1&gt;&lt;h2 id=&quot;1-shallow-heap-浅堆&quot;&gt;&lt;a href=&quot;#1-shallow-heap-浅</summary>
      
    
    
    
    <category term="JVM" scheme="https://georgechan95.github.io/categories/JVM/"/>
    
    
    <category term="java" scheme="https://georgechan95.github.io/tags/java/"/>
    
    <category term="jvm" scheme="https://georgechan95.github.io/tags/jvm/"/>
    
  </entry>
  
  <entry>
    <title>第二十三章-JVM监控及诊断工具-GUI篇</title>
    <link href="https://georgechan95.github.io/blog/971417975.html"/>
    <id>https://georgechan95.github.io/blog/971417975.html</id>
    <published>2024-08-16T13:00:00.000Z</published>
    <updated>2024-08-28T04:17:33.353Z</updated>
    
    <content type="html"><![CDATA[<h1 id="一、工具概述"><a href="#一、工具概述" class="headerlink" title="一、工具概述"></a>一、工具概述</h1><p>使用命令行工具或组合能帮您获取目标Java应用性能相关的基础信息，但它们存在下列局限：</p><ul><li><p>无法获取方法级别的分析数据，如方法间的调用关系、各方法的调用次数和调用时间等（这对定位应用性能瓶颈至关重要）。</p></li><li><p>要求用户登录到目标 Java 应用所在的宿主机上，使用起来不是很方便。</p></li><li><p>分析数据通过终端输出，结果展示不够直观。</p></li></ul><p>为此，JDK提供了一些内存泄漏的分析工具，如 jconsole，jvisualvm 等，用于辅助开发人员定位问题，但是这些工具很多时候并不足以满足快速定位的需求。所以这里我们介绍的工具相对多一些、丰富一些。</p><h2 id="1-JDK自带的工具"><a href="#1-JDK自带的工具" class="headerlink" title="1. JDK自带的工具"></a>1. JDK自带的工具</h2><ul><li><p>jconsole：JDK自带的可视化监控工具。查看Java应用程序的运行概况、监控堆信息、永久区（或元空间）使用情况、类加载情况等 </p></li><li><p>Visual VM：Visual VM是一个工具，它提供了一个可视界面，用于查看Java虚拟机上运行的基于Java技术的应用程序的详细信息。 </p></li><li><p>JMC：Java Mission Control，内置Java Flight Recorder。能够以极低的性能开销收集Java虚拟机的性能数据。</p></li></ul><h2 id="2-第三方工具"><a href="#2-第三方工具" class="headerlink" title="2. 第三方工具"></a>2. 第三方工具</h2><ul><li><p>MAT：MAT（Memory Analyzer Tool）是基于 Eclipse 的内存分析工具，是一个快速、功能丰富的 Java heap 分析工具，它可以帮助我们查找内存泄漏和减少内存消耗 </p></li><li><p>JProfiler：商业软件，需要付费。功能强大。 </p></li><li><p>Arthas：Alibaba 开源的 java 诊断工具。</p></li><li><p>Btrace：java 运行时追踪工具。</p></li></ul><h2 id="3-服务端开启远程监控"><a href="#3-服务端开启远程监控" class="headerlink" title="3. 服务端开启远程监控"></a>3. 服务端开启远程监控</h2><p>Jconsole、JVisual、JMC 可视化工具，调用本地监控直接使用对应的命令行即可，但 Linux 无法使用可视化工具，Java 程序基本都部署到 Linux 服务器。需要开启 <strong>远程调用服务器</strong>，可以使用JMX代理实现.</p><h3 id="3-1-JMX"><a href="#3-1-JMX" class="headerlink" title="3.1 JMX"></a>3.1 JMX</h3><p>JMX (Java Management Extensions) 是 Java 提供的一套标准 API,用于管理和监控 Java 应用程序的各种性能指标和使用情况。这里主要使用远程访问的功能。</p><p><strong>JMX 启动参数：</strong></p><ul><li>-Dcom.sun.management.jmxremote 远程开启开关</li><li>-Dcom.sun.management.jmxremote.port&#x3D;1808 jmx远程调用端口</li><li>-Dcom.sun.management.jmxremote.rmi.port&#x3D;1808 添加 rmi 端口<ul><li>JMX 和 RMI，是两种相关联的技术，JMX 使用 RMI 作为远程管理工具来管理和监控 Java 程序，RMI 为 JMX 提供了远程连接所需的远程调用和通信机制。</li></ul></li><li>-Dcom.sun.management.jmxremote.authenticate&#x3D;false 不开启验证</li><li>-Dcom.sun.management.jmxremote.ssl&#x3D;false 不为ssl连接</li><li>-Djava.rmi.server.hostname&#x3D;192.168.6.203 服务器所在ip或者域名</li><li>-Dcom.sun.management.jmxremote.pwd.file&#x3D;&#x2F;opt&#x2F;module&#x2F;jdk1.8.0_261&#x2F;jre&#x2F;lib&#x2F;management&#x2F;jmxremote.password 配置JMX远程连接用户名和密码</li></ul><h4 id="3-1-1-无密码方式开启JMX远程连接"><a href="#3-1-1-无密码方式开启JMX远程连接" class="headerlink" title="3.1.1  无密码方式开启JMX远程连接"></a>3.1.1  无密码方式开启JMX远程连接</h4><p>jar 包程序启动一般为：</p><pre><code class="highlight shell">java -jar xxx.jar</code></pre><p>添加参数后：</p><pre><code class="highlight shell">java -Xmx512m -Xms512m -Xmn512m \-Dcom.sun.management.jmxremote \-Dcom.sun.management.jmxremote.port=1808 \-Dcom.sun.management.jmxremote.rmi.port=1808 \-Dcom.sun.management.jmxremote.authenticate=false \-Dcom.sun.management.jmxremote.ssl=false \-Djava.rmi.server.hostname=192.168.6.203 \-jar xxx.jar \--spring.profiles.active=prod</code></pre><p>启动服务后,使用 Jconsole、Visual VM、JProfiler 等连接服务端, 这里以 Jconsole 连接监控远程服务举例:</p><p><img src="https://raw.githubusercontent.com/GeorgeChan95/blogimg/master/img/2024/08/17/20240817-143557.png" alt="Jconsole无密码远程连接"></p><p><img src="https://raw.githubusercontent.com/GeorgeChan95/blogimg/master/img/2024/08/17/20240817-143715.png" alt="Jconsole无密码远程连接2"></p><p><img src="https://raw.githubusercontent.com/GeorgeChan95/blogimg/master/img/2024/08/17/20240817-143747.png" alt="Jconsole无密码远程连接3"></p><h4 id="3-1-2-有密码方式开启JMX远程连接"><a href="#3-1-2-有密码方式开启JMX远程连接" class="headerlink" title="3.1.2  有密码方式开启JMX远程连接"></a>3.1.2  有密码方式开启JMX远程连接</h4><p><strong>配置JMX密码文件</strong></p><pre><code class="highlight shell"><span class="meta prompt_"># </span><span class="language-bash">进入JMX配置文件目录</span>cd /opt/module/jdk1.8.0_261/jre/lib/management<span class="meta prompt_"></span><span class="meta prompt_"># </span><span class="language-bash">复制JMX密码文件</span>cp jmxremote.password.template jmxremote.password<span class="meta prompt_"></span><span class="meta prompt_"># </span><span class="language-bash">编辑密码文件, 修改 连接用户名/密码(这里设置为 controlRole / 123456)</span>vim jmxremote.password<span class="meta prompt_"></span><span class="meta prompt_"># </span><span class="language-bash">保存密码配置文件</span>wq!<span class="meta prompt_"></span><span class="meta prompt_"># </span><span class="language-bash">配置权限文件为600</span>chmod 600 jmxremote.password jmxremote.access</code></pre><p><img src="https://raw.githubusercontent.com/GeorgeChan95/blogimg/master/img/2024/08/17/20240817-144220.png" alt="jmxremote.password"></p><p>到这里密码配置就结束了</p><p><strong>启动Java服务</strong></p><pre><code class="highlight shell">java -Xmx512m -Xms512m -Xmn512m \-Dcom.sun.management.jmxremote \-Dcom.sun.management.jmxremote.port=1808 \-Dcom.sun.management.jmxremote.rmi.port=1808 \-Dcom.sun.management.jmxremote.authenticate=true \-Dcom.sun.management.jmxremote.ssl=false \-Djava.rmi.server.hostname=192.168.6.203 \-Dcom.sun.management.jmxremote.pwd.file=/opt/module/jdk1.8.0_261/jre/lib/management/jmxremote.password \-jar ioms-ums.jar \--spring.profiles.active=dev</code></pre><p><strong>使用Jconsole、Visual VM、JProfiler 等连接服务端,</strong> 这里以 Jconsole 连接监控远程服务举例:</p><p><img src="https://raw.githubusercontent.com/GeorgeChan95/blogimg/master/img/2024/08/17/20240817-144556.png" alt="Jconsole有密码远程连接"></p><p><strong>注意: 服务器防火墙要开放JMX监控端口</strong></p><h1 id="二、JConsole"><a href="#二、JConsole" class="headerlink" title="二、JConsole"></a>二、JConsole</h1><h2 id="1-基本概述"><a href="#1-基本概述" class="headerlink" title="1. 基本概述"></a>1. 基本概述</h2><ul><li><p>jconsole：从Java5开始，在JDK中自带的 java 监控和管理控制台。</p></li><li><p>用于对JVM中内存、线程和类等的监控，是一个基于JMX（java management extensions）的GUI性能监控工具。</p></li><li><p>官方地址：<a href="https://docs.oracle.com/javase/7/docs/technotes/guides/management/jconsole.html">https://docs.oracle.com/javase/7/docs/technotes/guides/management/jconsole.html</a></p></li></ul><h2 id="2-启动"><a href="#2-启动" class="headerlink" title="2. 启动"></a>2. 启动</h2><ul><li>方式一: 在jdk安装目录中找到jconsole.exe，双击该可执行文件就可以</li><li>方式二: 打开DOS窗口，直接输入jconsole就可以了</li></ul><h2 id="3-连接"><a href="#3-连接" class="headerlink" title="3. 连接"></a>3. 连接</h2><h3 id="3-1-本地连接"><a href="#3-1-本地连接" class="headerlink" title="3.1 本地连接"></a>3.1 本地连接</h3><p><strong>注意：本地连接要求 启动jconsole的用户 和 运行当前程序的用户 是同一个用户</strong></p><p>具体操作如下：</p><ol><li>在jdk的 bin 目录下,双击 jconsole.exe , 即可启动 jconsole</li></ol><p><img src="https://raw.githubusercontent.com/GeorgeChan95/blogimg/master/img/2024/08/17/20240817-150254.png" alt="启动jconsole"></p><ol start="2"><li>选择 <code>本地进程</code> , 选择要监控的程序 <code>PID</code> , 点击 <code>连接</code></li></ol><p><img src="https://raw.githubusercontent.com/GeorgeChan95/blogimg/master/img/2024/08/17/20240817-150504.png" alt="选择本地进程"></p><ol start="3"><li>点击 <code>不安全的连接</code></li></ol><p><img src="https://raw.githubusercontent.com/GeorgeChan95/blogimg/master/img/2024/08/17/20240817-150632.png" alt="不安全的连接"></p><ol start="4"><li>进入控制台页面</li></ol><p><img src="https://raw.githubusercontent.com/GeorgeChan95/blogimg/master/img/2024/08/17/20240817-150830.png" alt="控制台页面"></p><h3 id="3-2-远程连接"><a href="#3-2-远程连接" class="headerlink" title="3.2 远程连接"></a>3.2 远程连接</h3><p>见上一章节,第三部分 : <strong>服务端开启远程监控</strong></p><h3 id="3-3-Advanced"><a href="#3-3-Advanced" class="headerlink" title="3.3  Advanced"></a>3.3  Advanced</h3><p>使用一个特殊的URL连接JMX代理。一般情况使用自己定制的连接器而不是RMI提供的连接器来连接JMX代理，或者是一个使用JDK1.4的实现了JMX和JMX Rmote的应用</p><h2 id="4-主要作用"><a href="#4-主要作用" class="headerlink" title="4. 主要作用"></a>4. 主要作用</h2><h3 id="4-1-概览"><a href="#4-1-概览" class="headerlink" title="4.1 概览"></a>4.1 概览</h3><p><img src="https://raw.githubusercontent.com/GeorgeChan95/blogimg/master/img/2024/08/17/20240817-152123.png" alt="概览"></p><h3 id="4-2-内存"><a href="#4-2-内存" class="headerlink" title="4.2 内存"></a>4.2 内存</h3><p><img src="https://raw.githubusercontent.com/GeorgeChan95/blogimg/master/img/2024/08/17/20240817-152302.png" alt="内存"></p><p>可以在这里点 <code>执行GC</code> 手动进行一次 GC操作.</p><h3 id="4-3-线程"><a href="#4-3-线程" class="headerlink" title="4.3 线程"></a>4.3 线程</h3><p><img src="https://raw.githubusercontent.com/GeorgeChan95/blogimg/master/img/2024/08/17/20240817-152336.png" alt="监控程序线程"></p><h4 id="4-3-1-根据线程检测死锁"><a href="#4-3-1-根据线程检测死锁" class="headerlink" title="4.3.1 根据线程检测死锁"></a>4.3.1 根据线程检测死锁</h4><p>在线程监控中点击 <code>检测死锁</code> 检查程序中是否线程发生了 <code>死锁</code></p><p><img src="https://raw.githubusercontent.com/GeorgeChan95/blogimg/master/img/2024/08/17/20240817-152513.png" alt="检测死锁"></p><h3 id="4-4-加载的类"><a href="#4-4-加载的类" class="headerlink" title="4.4 加载的类"></a>4.4 加载的类</h3><p><img src="https://raw.githubusercontent.com/GeorgeChan95/blogimg/master/img/2024/08/17/20240817-152534.png" alt="加载的类"></p><h3 id="4-5-VM概要"><a href="#4-5-VM概要" class="headerlink" title="4.5 VM概要"></a>4.5 VM概要</h3><p><img src="https://raw.githubusercontent.com/GeorgeChan95/blogimg/master/img/2024/08/17/20240817-152015.png" alt="VM概要"></p><h1 id="三、Visual-VM"><a href="#三、Visual-VM" class="headerlink" title="三、Visual VM"></a>三、Visual VM</h1><ul><li><p>jvisualvm和visual vm的区别：</p><p>visual vm 是单独下载的工具，然后将 visual vm 结合到 jdk 中就变成了 jvisualvm，仅仅是添加了一个j而已，这个j应该是 java 的用处，所以说 jvisualvm 其实就是 visual vm</p></li></ul><h2 id="1-基本概述-1"><a href="#1-基本概述-1" class="headerlink" title="1. 基本概述"></a>1. 基本概述</h2><ul><li>Visual VM是一个功能强大的多合一故障诊断和性能监控的可视化工具。</li><li>它集成了多个JDK命令行工具，使用 Visual VM 可用于显示虚拟机进程及进程的配置和环境信息( jps,jinfo )，监视应用程序的CPU、GC、堆、方法区及线程的信息( jstat、jstack )等，甚至代替 JConsole。</li><li>在JDK6 Update 7以后，Visua1 VM 便作为JDK的一部分发布( Visual VM 在 JDK&#x2F;bin 目录下)，即:它完全免费。</li><li>此外，Visual VM 也可以作为独立的软件安装:</li></ul><p>首页: <a href="https://visualvm.github.io/index.html">https://visualvm.github.io/index.html</a></p><p><img src="https://raw.githubusercontent.com/GeorgeChan95/blogimg/master/img/2024/08/17/20240817-155000.png" alt="Visual VM 官网"></p><h2 id="2-使用方式："><a href="#2-使用方式：" class="headerlink" title="2. 使用方式："></a>2. 使用方式：</h2><ul><li><p>方式一: 在jdk安装目录中找到 <code>jvisualvm.exe</code> ，然后双击执行即可</p><p><img src="https://raw.githubusercontent.com/GeorgeChan95/blogimg/master/img/2024/08/17/20240817-155239.png" alt="jvisualvm.exe"></p></li><li><p>方式二: 打开DOS窗口，输入 <code>jvisualvm</code> 就可以打开该软件</p></li></ul><h2 id="3-主要功能"><a href="#3-主要功能" class="headerlink" title="3. 主要功能"></a>3. 主要功能</h2><ul><li><p>生成&#x2F;读取堆内存&#x2F;线程快照</p></li><li><p>查看JVM参数和系统属性</p></li><li><p>查看运行中的虚拟机进程</p></li><li><p>程序资源的实时监控</p></li><li><p>JMX代理连接、远程环境监控、CPU分析和内存分析</p></li></ul><h2 id="2-插件的安装"><a href="#2-插件的安装" class="headerlink" title="2. 插件的安装"></a>2. 插件的安装</h2><p>Visual VM 的一大特点是支持插件扩展，并且插件安装非常方便。我们既可以通过离线下载插件文件 *.nbm，然后在Plugin对话框的已下载页面下，添加已下载的插件。也可以在可用插件页面下,在线安装插件。(这里建议安装上: VisualGc )</p><ul><li><strong>离线安装</strong></li></ul><p>插件地址 : <a href="https://visualvm.github.io/pluginscenters.html">https://visualvm.github.io/pluginscenters.html</a></p><p><img src="https://raw.githubusercontent.com/GeorgeChan95/blogimg/master/img/2024/08/17/20240817-160134.png" alt="选择Visual VM 版本"></p><p><img src="https://raw.githubusercontent.com/GeorgeChan95/blogimg/master/img/2024/08/17/20240817-160236.png" alt="插件下载中心"></p><p>点击需要的插件, 即可下载.</p><p><img src="https://raw.githubusercontent.com/GeorgeChan95/blogimg/master/img/2024/08/17/20240817-160649.png" alt="点击添加插件"></p><p><img src="https://raw.githubusercontent.com/GeorgeChan95/blogimg/master/img/2024/08/17/20240817-161349.png" alt="选择插件"></p><p><img src="https://raw.githubusercontent.com/GeorgeChan95/blogimg/master/img/2024/08/17/20240817-161450.png" alt="点击安装"></p><p><img src="https://raw.githubusercontent.com/GeorgeChan95/blogimg/master/img/2024/08/17/20240817-161516.png" alt="安装成功"></p><ul><li><strong>在线安装</strong></li></ul><p><img src="https://raw.githubusercontent.com/GeorgeChan95/blogimg/master/img/2024/08/17/20240817-160540.png" alt="在线安装"></p><ul><li><strong>IDEA 安装 VisualVM Launcher 插件</strong></li></ul><p>“File” →→ “Settings” →→ “Plugins” 打开插件安装界面。</p><p><img src="https://raw.githubusercontent.com/GeorgeChan95/blogimg/master/img/2024/08/18/20240818-090501.png" alt="安装VisualVM插件"></p><p>插件安装好之后，重启IDEA，然后再打开 “Settings” 配置界面，找到 “VisualVM Launcher”，配置 Visual VM 的路径和JDK，如下：</p><p><img src="https://raw.githubusercontent.com/GeorgeChan95/blogimg/master/img/2024/08/18/20240818-091155.png" alt="配置Visual VM 插件"></p><p><strong>IDEA 启动并连接 Visual VM</strong></p><p><img src="https://raw.githubusercontent.com/GeorgeChan95/blogimg/master/img/2024/08/18/20240818-091648.png" alt="IDEA 启动并连接 Visual VM"></p><h2 id="3-连接方式"><a href="#3-连接方式" class="headerlink" title="3. 连接方式"></a>3. 连接方式</h2><h3 id="3-1-本地连接-1"><a href="#3-1-本地连接-1" class="headerlink" title="3.1 本地连接"></a>3.1 本地连接</h3><p>打开 Visual VM , 选择一个运行中的本地进程即可.</p><p><img src="https://raw.githubusercontent.com/GeorgeChan95/blogimg/master/img/2024/08/17/20240817-165644.png" alt="Visual VM 本地连接"></p><h3 id="3-2-远程连接-1"><a href="#3-2-远程连接-1" class="headerlink" title="3.2 远程连接"></a>3.2 远程连接</h3><ul><li>1-确定远程服务器的ip地址</li><li>2-添加JMX（通过JMX技术具体监控远程服务器哪个Java进程）</li><li>3-修改bin&#x2F;catalina.sh文件，连接远程的tomcat</li><li>4-在 ..&#x2F;conf 中添加 jmxremote.access 和 jmxremote.password 文件</li><li>5-将服务器地址改成公网ip地址</li><li>6-设置阿里云安全策略和防火墙策略</li><li>7-启动tomcat，查看tomcat启动日志和端口监听</li><li>8-JMX中输入端口号、用户名、密码登录</li></ul><p><strong>实操远程连接</strong></p><ul><li><p>服务器设置开启 JMX 远程监控端口</p><ul><li>具体参考 第一章节: <strong>服务端开启远程监控</strong></li></ul></li><li><p>Visual VM 添加远程连接</p><p><img src="https://raw.githubusercontent.com/GeorgeChan95/blogimg/master/img/2024/08/17/20240817-170109.png" alt="添加JMX连接"></p></li></ul><p><img src="https://raw.githubusercontent.com/GeorgeChan95/blogimg/master/img/2024/08/17/20240817-170302.png" alt="设置JMX连接参数"></p><p><img src="https://raw.githubusercontent.com/GeorgeChan95/blogimg/master/img/2024/08/17/20240817-170434.png" alt="JMX连接成功"></p><h2 id="4-主要功能"><a href="#4-主要功能" class="headerlink" title="4. 主要功能"></a>4. 主要功能</h2><h3 id="4-1-生成-读取堆内存快照"><a href="#4-1-生成-读取堆内存快照" class="headerlink" title="4.1 生成&#x2F;读取堆内存快照"></a>4.1 生成&#x2F;读取堆内存快照</h3><h4 id="4-1-1-生成dump文件"><a href="#4-1-1-生成dump文件" class="headerlink" title="4.1.1 生成dump文件"></a>4.1.1 生成dump文件</h4><ul><li><p>方式一: 在左侧列表, 右击运行的进程, 直接生成 堆Dump</p><p><img src="https://raw.githubusercontent.com/GeorgeChan95/blogimg/master/img/2024/08/18/20240818-103735.png" alt="直接生成 堆Dump"></p></li><li><p>方式二: 在 监视器TAB 标签页中, 点击 <code>堆Dump</code> 生成dump文件</p><p><img src="https://raw.githubusercontent.com/GeorgeChan95/blogimg/master/img/2024/08/18/20240818-103929.png" alt="监视器生成dump"></p></li></ul><p>注意：<br>生成堆内存快照如下图：</p><p><img src="https://raw.githubusercontent.com/GeorgeChan95/blogimg/master/img/2024/08/18/20240818-104053.png" alt="生成的dump文件"></p><p>这些快照存储在内存中，当线程停止的时候快照就会丢失，如果还想利用，可以将快照进行另存为操作，如下图：</p><p><img src="https://raw.githubusercontent.com/GeorgeChan95/blogimg/master/img/2024/08/18/20240818-104222.png" alt="导出dump文件"></p><h4 id="4-1-2-导入dump文件"><a href="#4-1-2-导入dump文件" class="headerlink" title="4.1.2 导入dump文件"></a>4.1.2 导入dump文件</h4><p><img src="https://raw.githubusercontent.com/GeorgeChan95/blogimg/master/img/2024/08/18/20240818-104415.png" alt="导入dump文件"></p><p>选择要导入的dump文件</p><p><img src="https://raw.githubusercontent.com/GeorgeChan95/blogimg/master/img/2024/08/18/20240818-104701.png" alt="选择dump文件"></p><h3 id="4-2-查看JVM参数和系统属性"><a href="#4-2-查看JVM参数和系统属性" class="headerlink" title="4.2 查看JVM参数和系统属性"></a>4.2 查看JVM参数和系统属性</h3><p><img src="https://raw.githubusercontent.com/GeorgeChan95/blogimg/master/img/2024/08/18/20240818-105215.png" alt="JVM参数和系统属性"></p><h3 id="4-3-查看运行中的虚拟机进程"><a href="#4-3-查看运行中的虚拟机进程" class="headerlink" title="4.3 查看运行中的虚拟机进程"></a>4.3 查看运行中的虚拟机进程</h3><p><img src="https://raw.githubusercontent.com/GeorgeChan95/blogimg/master/img/2024/08/18/20240818-105620.png" alt="查看进程"></p><p>其中每个进程号都代表一个进程</p><h3 id="4-4-生成-读取线程快照"><a href="#4-4-生成-读取线程快照" class="headerlink" title="4.4 生成&#x2F;读取线程快照"></a>4.4 生成&#x2F;读取线程快照</h3><h4 id="4-4-1-生成线程快照"><a href="#4-4-1-生成线程快照" class="headerlink" title="4.4.1 生成线程快照"></a>4.4.1 生成线程快照</h4><p><img src="https://raw.githubusercontent.com/GeorgeChan95/blogimg/master/img/2024/08/18/20240818-105802.png" alt="生成线程快照"></p><p><img src="https://raw.githubusercontent.com/GeorgeChan95/blogimg/master/img/2024/08/18/20240818-105902.png" alt="生成线程快照结果"></p><h4 id="4-4-2-装入线程快照"><a href="#4-4-2-装入线程快照" class="headerlink" title="4.4.2 装入线程快照"></a>4.4.2 装入线程快照</h4><p><img src="https://raw.githubusercontent.com/GeorgeChan95/blogimg/master/img/2024/08/18/20240818-110025.png" alt="装入线程快照"></p><p><img src="https://raw.githubusercontent.com/GeorgeChan95/blogimg/master/img/2024/08/18/20240818-110101.png" alt="选择快照文件"></p><h3 id="4-5-程序资源的实时监控"><a href="#4-5-程序资源的实时监控" class="headerlink" title="4.5 程序资源的实时监控"></a>4.5 程序资源的实时监控</h3><p><img src="https://raw.githubusercontent.com/GeorgeChan95/blogimg/master/img/2024/08/18/20240818-110304.png" alt="程序资源的实时监控"></p><ul><li>可以同时查看 CPU、线程、堆 的使用情况</li><li>可以查看类的加载数量</li><li>可以手动点击进行一次 GC</li></ul><h3 id="4-6-其他功能"><a href="#4-6-其他功能" class="headerlink" title="4.6 其他功能"></a>4.6 其他功能</h3><ul><li>JMX代理连接</li><li>远程环境监控</li><li>CPU分析和内存分析</li></ul><h1 id="四、Eclipse-MAT"><a href="#四、Eclipse-MAT" class="headerlink" title="四、Eclipse MAT"></a>四、Eclipse MAT</h1><h2 id="1-基本概述-2"><a href="#1-基本概述-2" class="headerlink" title="1. 基本概述"></a>1. 基本概述</h2><p>MAT（Memory Analyzer Tool）工具是一款功能强大的Java堆内存分析器。可以用于查找内存泄漏以及查看内存消耗情况。</p><p>MAT是基于Eclipse开发的，不仅可以单独使用，还可以作为插件的形式嵌入在Eclipse中使用。是一款免费的性能分析工具，使用起来非常方便。大家可以在 <a href="https://www.eclipse.org/mat/downloads.php">https://www.eclipse.org/mat/downloads.php</a> 下载并使用MAT</p><h3 id="1-1-安装MAT"><a href="#1-1-安装MAT" class="headerlink" title="1.1 安装MAT"></a>1.1 安装MAT</h3><ul><li>打开官网, 下载 MAT, 注意: 我的JDK是 1.8版本的, 需要下载 MAT 1.11.0 版本</li></ul><p><img src="https://raw.githubusercontent.com/GeorgeChan95/blogimg/master/img/2024/08/18/20240818-124733.png" alt="image-20240818124732612"></p><ul><li><p>解压安装包, 双击 <code>MemoryAnalyzer.exe</code> 即可启动</p><p><img src="https://raw.githubusercontent.com/GeorgeChan95/blogimg/master/img/2024/08/18/20240818-125715.png" alt="启动MAT"></p></li><li><p>解决JDK版本不兼容问题</p><p><img src="https://raw.githubusercontent.com/GeorgeChan95/blogimg/master/img/2024/08/18/20240818-125807.png" alt="JDK版本不兼容"></p><p>打开MAT的安装目录，找到配置文件 <code>MemoryAnalyzer.ini</code>：</p><p><img src="https://raw.githubusercontent.com/GeorgeChan95/blogimg/master/img/2024/08/18/20240818-142434.png" alt="MemoryAnalyzer.ini"></p><p>打开这个文件，在文件中如下两行,指定jdk版本。</p><p><img src="https://raw.githubusercontent.com/GeorgeChan95/blogimg/master/img/2024/08/18/20240818-142411.png" alt="指定jdk版本"></p><p><strong>注意事项</strong></p><ul><li>写在开头</li><li>必须小写-vm</li><li>必须 换行 写成2行</li></ul><p>保存之后，再次尝试，顺利启动。</p></li></ul><p><strong>还可以在 Eclipse 中以插件的方式安装</strong></p><p><img src="https://raw.githubusercontent.com/GeorgeChan95/blogimg/master/img/2024/08/18/20240818-123902.png" alt="eclipse安装MAT插件"></p><h2 id="2-获取堆dump文件"><a href="#2-获取堆dump文件" class="headerlink" title="2. 获取堆dump文件"></a>2. 获取堆dump文件</h2><p>MAT可以分析heap dump文件。在进行内存分析时，只要获得了反映当前设备内存映像的 hprof 文件,通过 MAT 打开就可以直观地看到当前的内存信息。</p><p>一般说来，这些内存信息包含：</p><ul><li>所有的对象信息，包括对象实例、成员变量、存储于栈中的基本类型值和存储于堆中的其他对象的引用值。</li><li>所有的类信息，包括 classloader、类名称、父类、静态变量等</li><li>GCRoot 到所有的这些对象的引用路径</li><li>线程信息，包括线程的调用栈及此线程的线程局部变量(TLS)</li></ul><p><strong>两点说明：</strong></p><ul><li><p>说明1：</p><p>缺点: MAT 不是一个万能工具，它并不能处理所有类型的堆存储文件。但是比较主流的厂家和格式，例如 Sun，HP，SAP 所采用的 HPROF 二进制堆存储文件，以及 IBM 的 PHD 堆存储文件等都能被很好的解析。</p></li><li><p>说明2:</p><p>最吸引人的还是能够快速为开发人员生成<strong>内存泄漏报表</strong>，方便定位问题和分析问题。虽然MAT有如此强大的功能，但是内存分析也没有简单到一键完成的程度，很多内存问题还是需要我们从MAT展现给我们的信息当中通过经验和直觉来判断才能发现。</p><p><img src="https://raw.githubusercontent.com/GeorgeChan95/blogimg/master/img/2024/08/20/20240820-183317.png" alt="生成内存泄漏报表"></p></li></ul><h3 id="2-1-生成dump文件"><a href="#2-1-生成dump文件" class="headerlink" title="2.1 生成dump文件"></a>2.1 生成dump文件</h3><ul><li><p>方法一: 通过 jmap 工具生成，可以生成任意一个java进程的 dump 文件;</p></li><li><p>方法二: 通过配置JVM参数生成。</p><ul><li>选项 “ -XX:+HeapDumpOn0utOfMemoryError “或” -XX:+HeapDumpBeforeFullGc “</li><li>选项 “ -XX:HeapDumpPath “ 所代表的含义就是当程序出现 OutofMemory 时，将会在相应的目录下生成一份 dump 文件。如果不指定选项 “ -XX:HeapDumpPath ”则在当前目录下生成dump文件。</li></ul><p>对比:考虑到生产环境中几乎不可能在线对其进行分析，大都是采用离线分析，因此使用 jmap + MAT 工具是最常见的组合。</p></li><li><p>方法三: 使用 VisualVM 可以导出堆dump文件</p></li><li><p>方法四: 使用MAT既可以打开一个已有的堆快照，也可以通过MAT直接从活动Java程序中导出堆快照该功能将借助jps列出当前正在运行的 Java 进程，以供选择并获取快照。</p><p><img src="https://raw.githubusercontent.com/GeorgeChan95/blogimg/master/img/2024/08/20/20240820-184556.png" alt="MAT导出dump文件"></p></li></ul><h2 id="3-分析堆dump文件"><a href="#3-分析堆dump文件" class="headerlink" title="3. 分析堆dump文件"></a>3. 分析堆dump文件</h2><h3 id="3-1-histogram-直方图"><a href="#3-1-histogram-直方图" class="headerlink" title="3.1 histogram(直方图)"></a>3.1 histogram(直方图)</h3><p>展示了各个类的实例数目以及这些实例的 Shallow heap 或者 Retained heap 的总和</p><p><img src="https://raw.githubusercontent.com/GeorgeChan95/blogimg/master/img/2024/08/20/20240820-190530.png" alt="生成直方图"></p><p>点击上面两个红框其中任意一个，都可以生成直方图，生成具体内容：</p><p><img src="https://raw.githubusercontent.com/GeorgeChan95/blogimg/master/img/2024/08/20/20240820-190927.png" alt="直方图内容"></p><h3 id="3-2-thread-overview"><a href="#3-2-thread-overview" class="headerlink" title="3.2 thread overview"></a>3.2 thread overview</h3><ul><li>查看系统中的Java线程</li><li>查看局部变量的信息</li></ul><p><img src="https://raw.githubusercontent.com/GeorgeChan95/blogimg/master/img/2024/08/20/20240820-191717.png" alt="线程概览"></p><p><img src="https://raw.githubusercontent.com/GeorgeChan95/blogimg/master/img/2024/08/20/20240820-192456.png" alt="线程明细"></p><h3 id="3-3-获得对象互相引用的关系"><a href="#3-3-获得对象互相引用的关系" class="headerlink" title="3.3 获得对象互相引用的关系"></a>3.3 获得对象互相引用的关系</h3><ul><li><p>with outgoing references 变量引用了谁</p><p>​<img src="https://raw.githubusercontent.com/GeorgeChan95/blogimg/master/img/2024/08/20/20240820-193043.png" alt="outgoing"></p><p><img src="https://raw.githubusercontent.com/GeorgeChan95/blogimg/master/img/2024/08/20/20240820-193139.png" alt="引用结果"></p></li><li><p>with incoming references 谁引用了该变量</p><p><img src="https://raw.githubusercontent.com/GeorgeChan95/blogimg/master/img/2024/08/20/20240820-193245.png" alt="incoming"></p><p><img src="https://raw.githubusercontent.com/GeorgeChan95/blogimg/master/img/2024/08/20/20240820-193409.png" alt="引用结果"></p></li></ul><h3 id="3-4-浅堆与深堆"><a href="#3-4-浅堆与深堆" class="headerlink" title="3.4 浅堆与深堆"></a>3.4 浅堆与深堆</h3><h4 id="3-4-1-shallow-heap-浅堆"><a href="#3-4-1-shallow-heap-浅堆" class="headerlink" title="3.4.1 shallow heap(浅堆)"></a>3.4.1 shallow heap(浅堆)</h4><p>shallow heap是对象本身的大小，不包括其引用的对象。<br>对于非数组类型：shallow heap就是对象与其成员变量加在一起的大小。<br>对于数组类型：shallow heap就是数组各个元素大小之和。</p><h4 id="3-4-2-retained-heap-保留集"><a href="#3-4-2-retained-heap-保留集" class="headerlink" title="3.4.2 retained heap(保留集)"></a>3.4.2 retained heap(保留集)</h4><p>对象remainder heap 大小 &#x3D; 对象shallow heap大小 + 对象直接或者间接引用的对象大小（排除被GC ROOT直接引用的对象）。<br>如下图所示：</p><p><img src="https://raw.githubusercontent.com/GeorgeChan95/blogimg/master/img/2024/08/20/20240820-194720.png" alt="对象引用关系"></p><p><strong>对象引用关系</strong><br>OBJECT A 的 remainder heap &#x3D; OBJECT A 的 shallow heap<br>OBJECT B的 remainder heap &#x3D; OBJECT B 的 shallow heap + OBJECT C 的对象大小 + OBJECT E 的对象大小</p><p>所以对象的remainder heap其实接近进行垃圾回收时，清除该对象时所能获取的堆内存大小（有的对象可能还被其他对象引用，垃圾回收时，不能清除）。</p><p>下面是用mat对从服务器上面dump出来Java虚拟机内存进行解析之后的结果：</p><p><img src="https://raw.githubusercontent.com/GeorgeChan95/blogimg/master/img/2024/08/20/20240820-194952.png" alt="内存分析"></p><p><strong>Java内存解析结果</strong></p><p>其中，Objects为类的对象的个数。Shallow Heap是这些对象自身大小之和，Remainder Heap是这些对象自身以及这些对象直接或者间接引用的对象大小总和。</p><h4 id="3-4-3-补充：对象实际大小"><a href="#3-4-3-补充：对象实际大小" class="headerlink" title="3.4.3 补充：对象实际大小"></a>3.4.3 补充：对象实际大小</h4><p>另外一个常用的概念是对象的实际大小。这里，对象的实际大小定义为一个对象所能触及的所有对象的浅堆大小之和，也就是通常意义上我们说的对象大小。与深堆相比，似乎这个在日常开发中更为直观和被人接受，但实际上，<strong>这个概念和垃圾回收无关</strong>。</p><p>下图显示了一个简单的对象引用关系图，对象A引用了C和D，对象B引用了C和E。那么对象A的浅堆大小只是A本身，不含C和D，而A的实际大小为A、C、D三者之和。而A的深堆大小为A与D之和，由于对象C还可以通过对象B访问到，因此不在对象A的深堆范围内。</p><p><img src="https://raw.githubusercontent.com/GeorgeChan95/blogimg/master/img/2024/08/20/20240820-195149.png" alt="对象引用关系"></p><h4 id="3-4-4-案例分析：StudentTrace"><a href="#3-4-4-案例分析：StudentTrace" class="headerlink" title="3.4.4 案例分析：StudentTrace"></a>3.4.4 案例分析：StudentTrace</h4><p><strong>案例代码</strong></p><pre><code class="highlight java"><span class="comment">/**</span><span class="comment"> * 有一个学生浏览网页的记录程序，它将记录 每个学生访问过的网站地址。</span><span class="comment"> * 它由三个部分组成：Student、WebPage和StudentTrace三个类</span><span class="comment"> *</span><span class="comment"> *  -XX:+HeapDumpBeforeFullGC -XX:HeapDumpPath=d:\student.hprof</span><span class="comment"> */</span><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">StudentTrace</span> &#123;    <span class="keyword">static</span> List&lt;WebPage&gt; webpages = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;WebPage&gt;();    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">createWebPages</span><span class="params">()</span> &#123;        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; <span class="number">100</span>; i++) &#123;            <span class="type">WebPage</span> <span class="variable">wp</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">WebPage</span>();            wp.setUrl(<span class="string">&quot;http://www.&quot;</span> + Integer.toString(i) + <span class="string">&quot;.com&quot;</span>);            wp.setContent(Integer.toString(i));            webpages.add(wp);        &#125;    &#125;    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;        createWebPages();<span class="comment">//创建了100个网页</span>        <span class="comment">//创建3个学生对象</span>        <span class="type">Student</span> <span class="variable">st3</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Student</span>(<span class="number">3</span>, <span class="string">&quot;Tom&quot;</span>);        <span class="type">Student</span> <span class="variable">st5</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Student</span>(<span class="number">5</span>, <span class="string">&quot;Jerry&quot;</span>);        <span class="type">Student</span> <span class="variable">st7</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Student</span>(<span class="number">7</span>, <span class="string">&quot;Lily&quot;</span>);        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; webpages.size(); i++) &#123;            <span class="keyword">if</span> (i % st3.getId() == <span class="number">0</span>)                st3.visit(webpages.get(i));            <span class="keyword">if</span> (i % st5.getId() == <span class="number">0</span>)                st5.visit(webpages.get(i));            <span class="keyword">if</span> (i % st7.getId() == <span class="number">0</span>)                st7.visit(webpages.get(i));        &#125;        webpages.clear();        System.gc();    &#125;&#125;<span class="keyword">class</span> <span class="title class_">Student</span> &#123;    <span class="keyword">private</span> <span class="type">int</span> id;    <span class="keyword">private</span> String name;    <span class="keyword">private</span> List&lt;WebPage&gt; history = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();    <span class="keyword">public</span> <span class="title function_">Student</span><span class="params">(<span class="type">int</span> id, String name)</span> &#123;        <span class="built_in">super</span>();        <span class="built_in">this</span>.id = id;        <span class="built_in">this</span>.name = name;    &#125;    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">getId</span><span class="params">()</span> &#123;        <span class="keyword">return</span> id;    &#125;    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setId</span><span class="params">(<span class="type">int</span> id)</span> &#123;        <span class="built_in">this</span>.id = id;    &#125;    <span class="keyword">public</span> String <span class="title function_">getName</span><span class="params">()</span> &#123;        <span class="keyword">return</span> name;    &#125;    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setName</span><span class="params">(String name)</span> &#123;        <span class="built_in">this</span>.name = name;    &#125;    <span class="keyword">public</span> List&lt;WebPage&gt; <span class="title function_">getHistory</span><span class="params">()</span> &#123;        <span class="keyword">return</span> history;    &#125;    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setHistory</span><span class="params">(List&lt;WebPage&gt; history)</span> &#123;        <span class="built_in">this</span>.history = history;    &#125;    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">visit</span><span class="params">(WebPage wp)</span> &#123;        <span class="keyword">if</span> (wp != <span class="literal">null</span>) &#123;            history.add(wp);        &#125;    &#125;&#125;<span class="keyword">class</span> <span class="title class_">WebPage</span> &#123;    <span class="keyword">private</span> String url;    <span class="keyword">private</span> String content;    <span class="keyword">public</span> String <span class="title function_">getUrl</span><span class="params">()</span> &#123;        <span class="keyword">return</span> url;    &#125;    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setUrl</span><span class="params">(String url)</span> &#123;        <span class="built_in">this</span>.url = url;    &#125;    <span class="keyword">public</span> String <span class="title function_">getContent</span><span class="params">()</span> &#123;        <span class="keyword">return</span> content;    &#125;    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setContent</span><span class="params">(String content)</span> &#123;        <span class="built_in">this</span>.content = content;    &#125;&#125;</code></pre><p><img src="https://raw.githubusercontent.com/GeorgeChan95/blogimg/master/img/2024/08/20/20240820-200332.png" alt="线程对象追踪"></p><p><strong>结论：</strong><br>elementData 数组的浅堆是80个字节，而 elementData 数组中的所有 WebPage 对象的深堆之和是1208个字节，所以加在一起就是 elementData 数组的深堆之和，也就是1288个字节</p><p><strong>解析：</strong></p><p>默认采用了指针压缩则为12字节，没有采用则为16字节（数组还需要加上数组长度）。</p><p>1.为什么有152字节和144字节：因为我们的URL和content存在两种情况<br>        URL:”<a href="http://www.7.com"、content:"7"-----URL:"http://www.14.com"、content:"14">http://www.7.com&quot;、content:&quot;7&quot;-----URL:&quot;http://www.14.com&quot;、content:&quot;14</a>“<br>        第一种URL长度为16，底层的char数组的占用空间为(【】方括号里面整个都属于对象头，分开写方便大家理解)<br>            【普通对象头(12) + 数组长度(4)】 + 16个字符(32) &#x3D; 48字节，符合8字节对齐<br>            同理content 占用 【普通对象头(12) +数组长度(4)】+ 一个字符(2) &#x3D; 18字节,八字节对齐&#x3D;24字节<br>        第二种URL长度为17，底层的插入数组的占用空间为<br>            【普通对象头(12) + 数组长度(4)】 + 17个字符(34) &#x3D; 50字节，不符合8字节对齐，对齐为56<br>            同理content 占用 【普通对象头(12) +数组长度(4)】+ 两个字符(4) &#x3D; 20字节,八字节对齐&#x3D;24字节<br>        所以第一种总字节为48 + 24 &#x3D; 72,第二种总字节为56 + 24 &#x3D; 80<br>        因此第二种比第一种多了8字节，所以是152和144。<br>        (为什么总大小是152而不是72是因为我们只计算了String底层的char数组的区别没有计算各变量本身的浅堆,<br>        因为结构都相同，所以差别就差在内容的占用上)</p><p>2.为什么最终结果是1288<br>        首先ElementData数组本身的浅堆大小为<br>        【普通对象头(12) + 数组长度(4)】 + 数组内容【15个Obejct引用&#x3D;16*4】 &#x3D; 76,八字节对齐&#x3D;80字节<br>        15个Object分为13个152字节+2个144字节，总大小为&#x3D;2264字节<br>        7号和其他student重复的有0、21、42、63、84、35、70总计6个152和1一个144<br>        所以2264 - 6 * 152 - 144 &#x3D; 1208字节<br>    所以ElementData本身的浅堆80 + 仅能通过它到达的浅堆1208 &#x3D; 1288</p><h3 id="3-5-支配树"><a href="#3-5-支配树" class="headerlink" title="3.5 支配树"></a>3.5 支配树</h3><p>支配树的概念源自<strong>图论</strong>。</p><p>MAT提供了一个称为<strong>支配树</strong>（Dominator Tree)的对象图。支配树体现了<strong>对象实例</strong>间的支配关系。在对象引用图中，所有指向对象B的路径都经过对象A , 则认为对象A支配对象B。如果对象A是离对象B最近的一个支配对象 ，则认为对象A为对象B的<strong>直接支配者</strong>。支配树是基于<strong>对象间的引用图</strong>所建立的，它有以下基本性质：</p><ul><li>对象A的子树（所有被对象A支配的对象集合）表示对象A的保留集（retained set) , 即深堆</li><li>如果对象A支配对象B , 那么对象A的直接支配者也支配对象B</li><li>支配树的边与对象引用图的边不直接对应</li></ul><p>如下图所示：</p><p>左图表示<strong>对象引用图</strong>，右图表示左图所对应的<strong>支配树</strong>。</p><p>对象A和B由根对象直接支配，由于在到对象C的路径中，可以经过A , 也可以经过B , 因此对象C的直接支配者也是根对象。<br>对象F与对象D相互引用 ，因为到对象F的所有路径必然经过对象D , 因此，对象D是对象F的直接支配者 。<br>而到对象D的所有路径中，必然经过对象C , 即使是从对象F到对象D的引用 ，从根节点出发，也是经过对象C的，所以 ，对象D的直接支配者为对象C。</p><p><img src="https://raw.githubusercontent.com/GeorgeChan95/blogimg/master/img/2024/08/22/20240822-184127.png" alt="支配树"></p><p>同理，对象E支配对象G。到达对象H的可以通过对象D , 也可以通过对象E , 因此对象D和E都不能支配对象H , 而经过对象C既可以到达D也可以到达E , 因此<strong>对象C为对象H的直接支配者</strong>。</p><p>在MAT中，单击工具栏上的对象支配树按钮，可以打开<strong>对象支配树</strong>视图。</p><p><img src="https://raw.githubusercontent.com/GeorgeChan95/blogimg/master/img/2024/08/22/20240822-184933.png" alt="MAT通过dump文件查看对象支配树"></p><p>下图显示了对象支配树视图的一部分。该截图显示部分Lily学生的history队列的直接支配对象。即当Lily对象被回收，也会一并回收的所有对象。显然能被3或者5整除的网页不会出现在该列表中，因为它们同时被另外两名学生对象引用。</p><h2 id="4-案例：Tomcat堆溢出分析"><a href="#4-案例：Tomcat堆溢出分析" class="headerlink" title="4. 案例：Tomcat堆溢出分析"></a>4. 案例：Tomcat堆溢出分析</h2><h3 id="4-1-说明"><a href="#4-1-说明" class="headerlink" title="4.1 说明"></a>4.1 说明</h3><p>Tomcat是最常用的Java Servlet容器之一，同时也可以当做单独的Web服务器使用。<br> Tomcat本身使用Java实现，并运行于Java虚拟机之上。在大规模请求时，Tomcat有可能会因为无法承受压力而发生内存溢出错误。这里根据一个被压垮的Tomcat的堆快照文件，来分析Tomcat在崩溃时的内部情况。</p><h3 id="4-2-分析过程"><a href="#4-2-分析过程" class="headerlink" title="4.2 分析过程"></a>4.2 分析过程</h3><p><img src="https://raw.githubusercontent.com/GeorgeChan95/blogimg/master/img/2024/08/22/20240822-191115.png" alt="Tomcat溢出分析图1"></p><p><img src="https://raw.githubusercontent.com/GeorgeChan95/blogimg/master/img/2024/08/22/20240822-191318.png" alt="Tomcat溢出分析图2"></p><p><img src="https://raw.githubusercontent.com/GeorgeChan95/blogimg/master/img/2024/08/22/20240822-191325.png" alt="Tomcat溢出分析图3"></p><p><img src="https://raw.githubusercontent.com/GeorgeChan95/blogimg/master/img/2024/08/22/20240822-191331.png" alt="Tomcat溢出分析图4"></p><p><img src="https://raw.githubusercontent.com/GeorgeChan95/blogimg/master/img/2024/08/22/20240822-191337.png" alt="Tomcat溢出分析图5"></p><p><img src="https://raw.githubusercontent.com/GeorgeChan95/blogimg/master/img/2024/08/22/20240822-191343.png" alt="Tomcat溢出分析图6"></p><p><img src="https://raw.githubusercontent.com/GeorgeChan95/blogimg/master/img/2024/08/22/20240822-191350.png" alt="Tomcat溢出分析图6-2"></p><p><img src="https://raw.githubusercontent.com/GeorgeChan95/blogimg/master/img/2024/08/22/20240822-191356.png" alt="Tomcat溢出分析图7"></p><p><img src="https://raw.githubusercontent.com/GeorgeChan95/blogimg/master/img/2024/08/22/20240822-191405.png" alt="Tomcat溢出分析图8"></p><h1 id="五、JProfiler"><a href="#五、JProfiler" class="headerlink" title="五、JProfiler"></a>五、JProfiler</h1><h2 id="1-基本概述-3"><a href="#1-基本概述-3" class="headerlink" title="1. 基本概述"></a>1. 基本概述</h2><h3 id="1-1-介绍"><a href="#1-1-介绍" class="headerlink" title="1.1 介绍"></a>1.1 介绍</h3><p>在运行Java的时候有时候想测试运行时占用内存情况，这时候就需要使用测试工具查看了。在eclipse里面有 Eclipse Memory Analyzer tool (MAT) 插件可以测试，而在IDEA中也有这么一个插件，就是JProfiler。</p><p>JProfiler 是由 ej-technologies 公司开发的一款 Java 应用性能诊断工具。功能强大，但是收费。</p><p>官网下载地址：<a href="https://www.ej-technologies.com/jprofiler">https://www.ej-technologies.com/jprofiler</a></p><p><img src="https://raw.githubusercontent.com/GeorgeChan95/blogimg/master/img/2024/08/22/20240822-194145.png" alt="JProfiler 官网"></p><h3 id="1-2-特点"><a href="#1-2-特点" class="headerlink" title="1.2 特点"></a>1.2 特点</h3><ul><li><p>使用方便、界面操作友好（简单且强大）</p></li><li><p>对被分析的应用影响小（提供模板）</p></li><li><p>CPU，Thread，Memory分析功能尤其强大</p></li><li><p>支持对jdbc，noSql，jsp，servlet，socket等进行分析</p></li><li><p>支持多种模式（离线，在线）的分析</p></li><li><p>支持监控本地、远程的JVM</p></li><li><p>跨平台，拥有多种操作系统的安装版本</p></li></ul><h3 id="1-3-主要功能"><a href="#1-3-主要功能" class="headerlink" title="1.3 主要功能"></a>1.3 主要功能</h3><ul><li>1-方法调用：对方法调用的分析可以帮助您了解应用程序正在做什么，并找到提高其性能的方法</li><li>2-内存分配：通过分析堆上对象、引用链和垃圾收集能帮您修复内存泄露问题，优化内存使用</li><li>3-线程和锁：JProfiler 提供多种针对线程和锁的分析视图助您发现多线程问题</li><li>4-高级子系统：许多性能问题都发生在更高的语义级别上。例如，对于JDBC调用，您可能希望找出执行最慢的SQL语句。JProfiler支持对这些子系统进行集成分析</li></ul><h2 id="2-安装与配置"><a href="#2-安装与配置" class="headerlink" title="2. 安装与配置"></a>2. 安装与配置</h2><h3 id="2-1-下载与安装"><a href="#2-1-下载与安装" class="headerlink" title="2.1 下载与安装"></a>2.1 下载与安装</h3><p>下载地址：<a href="https://www.ej-technologies.com/jprofiler/download">https://www.ej-technologies.com/jprofiler/download</a></p><p><img src="https://raw.githubusercontent.com/GeorgeChan95/blogimg/master/img/2024/08/22/20240822-195531.png" alt="下载 JProfiler"></p><p>选择一个版版本，点击下载后，安装。（收费软件，下载安装后有试用期）</p><p>或者下载使用破解版本：<a href="https://downloadlynet.ir/2020/12/1885/03/jprofiler/00/#/1885-ej-techn-152438080522.html">https://downloadlynet.ir/2020/12/1885/03/jprofiler/00/?#/1885-ej-techn-152438080522.html</a></p><h3 id="2-2-JProfiler-中配置-IDEA"><a href="#2-2-JProfiler-中配置-IDEA" class="headerlink" title="2.2 JProfiler 中配置 IDEA"></a>2.2 JProfiler 中配置 IDEA</h3><p><img src="https://raw.githubusercontent.com/GeorgeChan95/blogimg/master/img/2024/08/22/20240822-201609.png" alt="IDEA集成"></p><p>点击选择 <code>IDEA Integrations</code></p><p><img src="https://raw.githubusercontent.com/GeorgeChan95/blogimg/master/img/2024/08/22/20240822-202323.png" alt="选择IDEA，点击 Integrate"></p><p>选择 <code>IntelliJ IDEA</code> ， 点击 <code>Integrate</code>,  再点击 OK</p><h3 id="2-3-IDEA集成JProfiler"><a href="#2-3-IDEA集成JProfiler" class="headerlink" title="2.3 IDEA集成JProfiler"></a>2.3 IDEA集成JProfiler</h3><p><img src="https://raw.githubusercontent.com/GeorgeChan95/blogimg/master/img/2024/08/22/20240822-202123.png" alt="安装 JProfiler 插件"></p><p>IDEA 安装 JProfiler 插件</p><p><img src="https://raw.githubusercontent.com/GeorgeChan95/blogimg/master/img/2024/08/22/20240822-202816.png" alt="image-20240822202816158"></p><p>Tool 中配置 JProfiler 的执行exe文件路径。</p><p>安装并配置完成后，IDEA工具栏会出现这两个图标，点击可以直接启动一个进程，或者追踪一个运行中的进程。</p><p><img src="https://raw.githubusercontent.com/GeorgeChan95/blogimg/master/img/2024/08/22/20240822-203121.png" alt="image-20240822203120430"></p><h2 id="3-具体使用"><a href="#3-具体使用" class="headerlink" title="3. 具体使用"></a>3. 具体使用</h2><h3 id="3-1-数据采集方式"><a href="#3-1-数据采集方式" class="headerlink" title="3.1 数据采集方式"></a>3.1 数据采集方式</h3><ul><li>Instrumentation：这是 JProfiler 全功能模式。在 class 加载之前，JProfier 把相关功能代码写入到需要分析的 class 的 bytecode 中，对正在运行的 jvm 有一定影响。<ul><li>优点：功能强大。在此设置中，调用堆栈信息是准确的。</li><li>缺点：若要分析的 class 较多，则对应用的性能影响较大，CPU 开销可能很高（取决于 Filter 的控制）。因此使用此模式一般配合 Filter 使用，只对特定的类或包进行分析</li></ul></li><li>Sampling：类似于样本统计，每隔一定时间（5ms）将每个线程栈中方法栈中的信息统计出来。<ul><li>优点：对 CPU 的开销非常低，对应用影响小（即使你不配置任何 Filter）</li><li>缺点：一些数据／特性不能提供（例如：方法的调用次数、执行时间）</li></ul></li></ul><p>注：JProfiler 本身没有指出数据的采集类型，这里的采集类型是针对方法调用的采集类型。因为 JProfiler 的绝大多数核心功能都依赖方法调用采集的数据，所以可以直接认为是 JProfiler 的数据采集类型。</p><h3 id="3-2-遥感监测-Telemetries"><a href="#3-2-遥感监测-Telemetries" class="headerlink" title="3.2 遥感监测 Telemetries"></a>3.2 遥感监测 Telemetries</h3><h4 id="3-2-1-概览"><a href="#3-2-1-概览" class="headerlink" title="3.2.1 概览"></a>3.2.1 概览</h4><p><img src="https://raw.githubusercontent.com/GeorgeChan95/blogimg/master/img/2024/08/23/20240823-082049.png" alt="概览"></p><h4 id="3-2-2-内存"><a href="#3-2-2-内存" class="headerlink" title="3.2.2 内存"></a>3.2.2 内存</h4><p><img src="https://raw.githubusercontent.com/GeorgeChan95/blogimg/master/img/2024/08/23/20240823-083632.png" alt="内存"></p><p>内存占用持续飙升，存在OOM风险</p><h4 id="3-2-3-记录的对象"><a href="#3-2-3-记录的对象" class="headerlink" title="3.2.3 记录的对象"></a>3.2.3 记录的对象</h4><p><img src="https://raw.githubusercontent.com/GeorgeChan95/blogimg/master/img/2024/08/23/20240823-083819.png" alt="记录的对象"></p><h4 id="3-2-4-记录的吞吐量"><a href="#3-2-4-记录的吞吐量" class="headerlink" title="3.2.4 记录的吞吐量"></a>3.2.4 记录的吞吐量</h4><p><img src="https://raw.githubusercontent.com/GeorgeChan95/blogimg/master/img/2024/08/23/20240823-083914.png" alt="记录的吞吐量"></p><h4 id="3-2-5-GC活动"><a href="#3-2-5-GC活动" class="headerlink" title="3.2.5 GC活动"></a>3.2.5 GC活动</h4><p><img src="https://raw.githubusercontent.com/GeorgeChan95/blogimg/master/img/2024/08/23/20240823-084559.png" alt="GC活动"></p><h4 id="3-2-6-类"><a href="#3-2-6-类" class="headerlink" title="3.2.6 类"></a>3.2.6 类</h4><p><img src="https://raw.githubusercontent.com/GeorgeChan95/blogimg/master/img/2024/08/23/20240823-084628.png" alt="类"></p><h4 id="3-2-7-线程"><a href="#3-2-7-线程" class="headerlink" title="3.2.7 线程"></a>3.2.7 线程</h4><p><img src="https://raw.githubusercontent.com/GeorgeChan95/blogimg/master/img/2024/08/23/20240823-084653.png" alt="线程"></p><h4 id="3-2-8-CPU负载"><a href="#3-2-8-CPU负载" class="headerlink" title="3.2.8 CPU负载"></a>3.2.8 CPU负载</h4><p><img src="https://raw.githubusercontent.com/GeorgeChan95/blogimg/master/img/2024/08/23/20240823-084722.png" alt="CPU负载"></p><h3 id="3-3-内存视图-Live-Memory"><a href="#3-3-内存视图-Live-Memory" class="headerlink" title="3.3 内存视图 Live Memory"></a>3.3 内存视图 Live Memory</h3><p><code>Live memory</code> 内存剖析：<code>class/class instance</code> 的相关信息。例如对象的个数，大小，对象创建的方法执行栈，对象创建的热点。</p><h4 id="3-3-1-所有对象-All-Objects"><a href="#3-3-1-所有对象-All-Objects" class="headerlink" title="3.3.1 所有对象 All Objects"></a>3.3.1 所有对象 All Objects</h4><p>显示所有加载的类的列表和在堆上分配的实例数。只有Java 1.5(JVMTI)才会显示此视图。</p><p><img src="https://raw.githubusercontent.com/GeorgeChan95/blogimg/master/img/2024/08/23/20240823-085930.png" alt="Live Memory"></p><p>通过内存标记，可以查看到 Picture 持续增加，程序存在内存泄漏。</p><h4 id="3-3-2-记录对象Recorded-Objects"><a href="#3-3-2-记录对象Recorded-Objects" class="headerlink" title="3.3.2 记录对象Recorded Objects"></a>3.3.2 记录对象Recorded Objects</h4><p>查看特定时间段对象的分配，并记录分配的调用堆栈。</p><p><img src="https://raw.githubusercontent.com/GeorgeChan95/blogimg/master/img/2024/08/23/20240823-091046.png" alt="Recorded Objects"></p><p>可以看到Picture类占用了过多的内存，需要重点查看</p><h4 id="3-3-3-分配访问树-Allocation-Call-Tree"><a href="#3-3-3-分配访问树-Allocation-Call-Tree" class="headerlink" title="3.3.3 分配访问树 Allocation Call Tree"></a>3.3.3 分配访问树 Allocation Call Tree</h4><p>显示一棵请求树或者方法、类、包或对已选择类有带注释的分配信息的J2EE组件。</p><p><img src="https://raw.githubusercontent.com/GeorgeChan95/blogimg/master/img/2024/08/23/20240823-091415.png" alt="分配访问树"></p><h4 id="3-3-4-分配热点-Allocation-Hot-Spots"><a href="#3-3-4-分配热点-Allocation-Hot-Spots" class="headerlink" title="3.3.4 分配热点 Allocation Hot Spots"></a>3.3.4 分配热点 Allocation Hot Spots</h4><p>显示一个列表，包括方法、类、包或分配已选类的J2EE组件。你可以标注当前值并且显示差异值。对于每个热点都可以显示它的跟踪记录树。</p><p><img src="https://raw.githubusercontent.com/GeorgeChan95/blogimg/master/img/2024/08/23/20240823-092146.png" alt="Allocation Hot Spots"></p><h4 id="3-3-5-类追踪器-Class-Tracker"><a href="#3-3-5-类追踪器-Class-Tracker" class="headerlink" title="3.3.5 类追踪器 Class Tracker"></a>3.3.5 类追踪器 Class Tracker</h4><p>类跟踪视图可以包含任意数量的图表，显示选定的类和包的实例与时间。</p><p><img src="https://raw.githubusercontent.com/GeorgeChan95/blogimg/master/img/2024/08/23/20240823-093043.png" alt="Class Tracker"></p><p>分析：内存中的对象的情况</p><ul><li>频繁创建的Java对象：死循环、循环次数过多</li><li>存在大的对象：读取文件时，byte[]应该边读边写。如果长时间不写出的话，导致byte[]过大</li><li>存在内存泄漏</li></ul><p>注意：</p><ul><li>All Objects后面的Size大小是浅堆大小</li><li>Record Objects 在判断内存泄露的时候使用，可以通过观察Telemetries中的Memory，如果里面出现垃圾回收之后的内存占用逐步提高，这就有可能出现内存泄露问题，所以可以使用Record Objects查看，但是该分析默认不开启，毕竟占用CPU性能太多</li></ul><h3 id="3-4-堆遍历-heap-walker"><a href="#3-4-堆遍历-heap-walker" class="headerlink" title="3.4 堆遍历 heap walker"></a>3.4 堆遍历 heap walker</h3><p>如果通过内存视图 Live Memory已经分析出哪个类的对象不能进行垃圾回收，并且有可能导致内存溢出，如果想进一步分析，我们可以在该对象上点击右键，选择Show Selection In Heap Walker，如下图：</p><p><img src="https://raw.githubusercontent.com/GeorgeChan95/blogimg/master/img/2024/08/23/20240823-122458.png" alt="Show Selection In Heap Walker"></p><p>进入堆遍历视图，如下图所示：</p><p><img src="https://raw.githubusercontent.com/GeorgeChan95/blogimg/master/img/2024/08/23/20240823-123008.png" alt="image-20240823123007846"></p><p>查看对象的引用关系，如下图：</p><p><img src="https://raw.githubusercontent.com/GeorgeChan95/blogimg/master/img/2024/08/23/20240823-123505.png" alt="对象引用关系"></p><ul><li><p>Outgoing references 对象引用了谁</p><p><img src="https://raw.githubusercontent.com/GeorgeChan95/blogimg/master/img/2024/08/23/20240823-123700.png" alt="Outgoing references"></p></li><li><p>Incoming references 谁引用了自己</p><p><img src="https://raw.githubusercontent.com/GeorgeChan95/blogimg/master/img/2024/08/23/20240823-123821.png" alt="Incoming references"></p></li><li><p>Show In Graph 通过图表形式查看对象引用关系</p><p><img src="https://raw.githubusercontent.com/GeorgeChan95/blogimg/master/img/2024/08/23/20240823-124144.png" alt="image-20240823124143505"></p></li></ul><p><img src="https://raw.githubusercontent.com/GeorgeChan95/blogimg/master/img/2024/08/23/20240823-124442.png" alt="引用关系图"></p><h3 id="3-5-cpu视图-cpu-views"><a href="#3-5-cpu视图-cpu-views" class="headerlink" title="3.5  cpu视图 cpu views"></a>3.5  cpu视图 cpu views</h3><p><code>JProfiler</code> 提供不同的方法来记录访问树以优化性能和细节。线程或者线程组以及线程状况可以被所有的视图选择。所有的视图都可以聚集到方法、类、包或J2EE组件等不同层上。</p><ul><li><p><strong>访问树 Call Tree</strong></p><p>显示一个积累的自顶向下的树，树中包含所有在JVM中已记录的访问队列。JDBC,JMS和JNDI服务请求都被注释在请求树中。请求树可以根据Servlet和JSP对URL的不同需要进行拆分。</p><p><img src="https://raw.githubusercontent.com/GeorgeChan95/blogimg/master/img/2024/08/23/20240823-195001.png" alt="访问树"></p></li></ul><p>上面的 100% 表示该方法会100%调用下面的方法, 276s 表示方法调用一共花费了276秒, 再往下就是方法的全名称.</p><p>左上角可以筛选展示: Package, Class, Method</p><ul><li><p><strong>热点 Hot Spots</strong></p><p>显示消耗时间最多的方法的列表。对每个热点都能够显示回溯树。该热点可以按照方法请求，JDBC,JMS和JNDI服务请求以及按照URL请求来进行计算。</p><p><img src="https://raw.githubusercontent.com/GeorgeChan95/blogimg/master/img/2024/08/23/20240823-195125.png" alt="热点"></p></li><li><p><strong>访问图 Call Graph</strong></p><p>显示一个从已选方法、类、包或]2EE组件开始的访问队列的图。</p><p><img src="https://raw.githubusercontent.com/GeorgeChan95/blogimg/master/img/2024/08/23/20240823-195416.png" alt="访问图"></p></li><li><p><strong>方法检测 Outlier Detection</strong></p><p>显示一段时间内记录的方法的调用时间细节。</p><p><img src="https://raw.githubusercontent.com/GeorgeChan95/blogimg/master/img/2024/08/23/20240823-200246.png" alt="image-20240823200244805"></p></li><li><p><strong>调用栈追踪 Call Tracer</strong></p><p><img src="https://raw.githubusercontent.com/GeorgeChan95/blogimg/master/img/2024/08/23/20240823-200527.png" alt="image-20240823200526033"></p></li></ul><h3 id="3-6-线程视图-threads"><a href="#3-6-线程视图-threads" class="headerlink" title="3.6  线程视图 threads"></a>3.6  线程视图 threads</h3><p>JProfiler通过对线程历史的监控判断其运行状态，并监控是否有线程阻塞产生，还能将一个线程所管理的方法以树状形式呈现。对线程剖析。</p><ul><li><p><strong>线程历史 Thread History</strong></p><p>显示一个与线程活动和线程状态在一起的活动时间表。</p><p><img src="https://raw.githubusercontent.com/GeorgeChan95/blogimg/master/img/2024/08/23/20240823-202059.png" alt="线程历史"></p></li><li><p><strong>线程监控 Thread Monitor</strong></p><p>显示一个列表，包括所有的活动线程以及它们目前的活动状况。</p><p><img src="https://raw.githubusercontent.com/GeorgeChan95/blogimg/master/img/2024/08/23/20240823-202149.png" alt="线程监控"></p></li><li><p><strong>线程转储 Thread Dumps</strong></p><p>显示所有线程的堆栈跟踪。</p><p><img src="https://raw.githubusercontent.com/GeorgeChan95/blogimg/master/img/2024/08/23/20240823-202330.png" alt="线程转储"></p></li></ul><p>线程分析主要关心三个方面：</p><ul><li>web容器的线程最大数。比如：Tomcat的线程容量应该略大于最大并发数。</li><li>线程阻塞</li><li>线程死锁</li></ul><h3 id="3-7-监视器-锁-Monitors-locks"><a href="#3-7-监视器-锁-Monitors-locks" class="headerlink" title="3.7 监视器&amp;锁 Monitors&amp;locks"></a>3.7 监视器&amp;锁 Monitors&amp;locks</h3><p>监控和锁 <code>Monitors &amp; Locks</code> 所有线程持有<strong>锁</strong>的情况以及锁的信息. 观察JVM的内部线程并查看状态：</p><ul><li><p><strong>死锁探测图表 Current Locking Graph</strong></p><p>显示JVM中的当前<strong>死锁</strong>图表</p><p><img src="https://raw.githubusercontent.com/GeorgeChan95/blogimg/master/img/2024/08/23/20240823-202629.png" alt="死锁探测图表"></p></li><li><p><strong>监测器 Current Monitors</strong></p><p>显示目前使用的监测器并且包括它们的<strong>关联线程</strong></p><p><img src="https://raw.githubusercontent.com/GeorgeChan95/blogimg/master/img/2024/08/23/20240823-203056.png" alt="Current Monitors"></p></li><li><p><strong>锁定历史图表 Locking History Graph</strong></p><p>显示记录在JVM中的<strong>锁定历史</strong></p></li><li><p><strong>历史检测记录Monitor History</strong></p><p>显示重大的<strong>等待事件</strong>和<strong>阻塞事件</strong>的历史记录</p></li><li><p><strong>监控器使用统计 Monitor Usage Statistics</strong></p><p>显示分组监测，线程和监测类的<strong>统计监测数据</strong></p></li></ul><h2 id="4-案例分析"><a href="#4-案例分析" class="headerlink" title="4. 案例分析"></a>4. 案例分析</h2><ul><li><p>代码</p><pre><code class="highlight java"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">MemoryLeak</span> &#123;    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;        <span class="keyword">while</span> (<span class="literal">true</span>) &#123;            <span class="type">ArrayList</span> <span class="variable">beanList</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ArrayList</span>();            <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; <span class="number">500</span>; i++) &#123;                <span class="type">Bean</span> <span class="variable">data</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Bean</span>();                data.list.add(<span class="keyword">new</span> <span class="title class_">byte</span>[<span class="number">1024</span> * <span class="number">10</span>]);<span class="comment">//10kb</span>                beanList.add(data);            &#125;            <span class="keyword">try</span> &#123;                TimeUnit.MILLISECONDS.sleep(<span class="number">500</span>);            &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;                e.printStackTrace();            &#125;        &#125;    &#125;&#125;<span class="keyword">class</span> <span class="title class_">Bean</span> &#123;    <span class="type">int</span> <span class="variable">size</span> <span class="operator">=</span> <span class="number">10</span>;    <span class="type">String</span> <span class="variable">info</span> <span class="operator">=</span> <span class="string">&quot;hello,atguigu&quot;</span>;<span class="comment">//     ArrayList list = new ArrayList();</span>    <span class="keyword">static</span> <span class="type">ArrayList</span> <span class="variable">list</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ArrayList</span>();&#125;</code></pre></li><li><p>使用JProfiler进行分析</p><ul><li><p>我们通过JProfiler来看一下，如下：</p><p><img src="https://raw.githubusercontent.com/GeorgeChan95/blogimg/master/img/2024/08/23/20240823-204502.png" alt="查看内存"></p><p>你可以看到内存一个劲的往上涨，但是就是没有下降的趋势，说明这肯定有问题，过不了多久就会出现OOM，我们来到Live memory中，先标记看一下到底是哪些对象在进行内存增长，等一小下看看会不会触发垃圾回收，如果不触发的话，我们自己来触发垃圾回收，之后观察哪些对象没有被回收掉，如下：</p></li><li><p>查看Live Memory, 标记内存, 手动进行GC</p><p><img src="https://raw.githubusercontent.com/GeorgeChan95/blogimg/master/img/2024/08/23/20240823-204649.png" alt="查看活动的内存"></p><p>我上面点击了Mark Current，发现有些对象在持续增长，然后点击了一下Run GC，发现 byte[] 并没有被回收</p></li><li><p>点击Show Selection In Heap Walker，如下：</p><p><img src="https://raw.githubusercontent.com/GeorgeChan95/blogimg/master/img/2024/08/23/20240823-204856.png" alt="右键,点击 Heap Walker"></p></li><li><p>然后看一下该对象被谁引用，如下：</p><p><img src="https://raw.githubusercontent.com/GeorgeChan95/blogimg/master/img/2024/08/23/20240823-205031.png" alt="Incoming reference"></p><p>结果如下：</p><p><img src="https://raw.githubusercontent.com/GeorgeChan95/blogimg/master/img/2024/08/23/20240823-205343.png" alt="image-20240823205342532"></p></li></ul></li><li><p>结论</p><p>可以看出byte[]来自于Bean类是的list中，并且这个list是ArrayList类型的静态集合，所以找到了：static ArrayList list &#x3D; new ArrayList();<br>发现list是静态的，这不妥，因为我们的目的是while结束之后Bean对象被回收，并且Bena对象中的所有字段都被回收，但是list是静态的，那就是类的，众所周知，类变量随类而生，随类而灭，因此每次我们往list中添加值，都是往同一个list中添加值，这会造成list不断增大，并且不能回收，所以最终会导致OOM</p></li></ul><h1 id="六、Arthas"><a href="#六、Arthas" class="headerlink" title="六、Arthas"></a>六、Arthas</h1><h2 id="1-基本概述-4"><a href="#1-基本概述-4" class="headerlink" title="1. 基本概述"></a>1. 基本概述</h2><h3 id="1-1-背景"><a href="#1-1-背景" class="headerlink" title="1.1 背景"></a>1.1 背景</h3><p>前面，我们介绍了jdk自带的 <code>jvisualvm</code> 等免费工具，以及商业化工具<code>Jprofiler</code>。</p><p>这两款工具在业界知名度也比较高，他们的优点是可以<strong>图形界面</strong>上看到各维度的性能数据，使用者根据这些数据进行综合分析，然后判断哪里出现了性能问题。</p><p>但是这两款工具也有个缺点，都必须在<strong>服务端</strong>项目进程中配置相关的监控参数。然后工具通过远程连接到项目进程，获取相关的数据。这样就会带来一些不便，比如线上环境的网络是<strong>隔离</strong>的，本地的监控工具根本连不上线上环境。并且类似于<code>Jprofiler</code>这样的商业工具，是需要付费的。</p><p>阿里巴巴开源的<strong>性能分析神器</strong>Arthas(阿尔萨斯）不需要远程连接，也不需要配置监控参数，并且提供了丰富的性能监控数据.</p><h3 id="1-2-概述"><a href="#1-2-概述" class="headerlink" title="1.2 概述"></a>1.2 概述</h3><p>Arthas支持JDK6+,支持 <code>Linux</code> &#x2F; <code>Mac</code> &#x2F; <code>Windows</code>,采用命令行交互模式，同时提供丰富的<code>Tab</code>自动补全功能，进一步方便进行问题的定位和诊断。</p><p>当你遇到以下类似问题而束手无策时，Arthas可以帮助你解决：</p><ul><li><p>这个类从哪个jar包加载的？为什么会报各种类相关的Exception?</p></li><li><p>我改的代码为什么没有执行到？难道是我没commit?分支搞错了？</p></li><li><p>遇到问题无法在线上 debug , 难道只能通过加日志再重新发布吗？</p></li><li><p>线上遇到某个用户的数据处理有问题，但线上同样无法 debug,线下无法重现！</p></li><li><p>是否有一个全局视角来查看系统的运行状况？</p></li><li><p>有什么办法可以监控到JVM的实时运行状态？</p></li><li><p>怎么快速定位应用的热点，生成火焰图？</p></li></ul><h3 id="1-3-基于哪些工具开发而来"><a href="#1-3-基于哪些工具开发而来" class="headerlink" title="1.3 基于哪些工具开发而来"></a>1.3 基于哪些工具开发而来</h3><ul><li>greys-anatomy:Arthas代码基于Greys二次开发而来，非常感谢Greys之前所有的工作，以及Greys原作者对Arthas提出的意见和建议！</li><li>termd:Arthas的命令行实现基于termd开发，是一款优秀的命令行程序开发框架，感谢termd提供了优秀的框架。</li><li>crash:Arthas的文本渲染功能基于crash中的文本渲染功能开发，可以从这里看到源码，感谢crash在这方面所做的优秀工作。</li><li>cli:Arthas的命令行界面基于vert.x提供的cli库进行开发，感谢vert.x在这方面做的优秀工作。</li><li>compiler Arthas里的内存编绎器代码来源</li><li>Apache Commons Net Arthas里的Telnet Client代码来源</li><li>JavaAgent:运行在main方法之前的拦截器，它内定的方法名叫premain,也就是说先执行premain方法然后再执行main方法</li><li>ASM:一个通用的Java字节码操作和分析框架。它可以用于修改现有的类或直接以二进制形式动态生成类。ASM提供了一些常见的字节码转换和分析算法，可以从它们构建定制的复杂转换和代码分析工具。ASM提供了与其他Java字节码框架类似的功能，但是主要关注性能。因为它被设计和实现得尽可能小和快，所以非常适合在动态系统中使用（当然也可以以静态方式使用，例如在编译器中）</li></ul><h3 id="1-4-官方使用文档"><a href="#1-4-官方使用文档" class="headerlink" title="1.4 官方使用文档"></a>1.4 官方使用文档</h3><p><a href="https://arthas.aliyun.com/">https://arthas.aliyun.com/</a></p><p><img src="https://raw.githubusercontent.com/GeorgeChan95/blogimg/master/img/2024/08/23/20240823-210407.png" alt="官网"></p><h2 id="2-安装与使用"><a href="#2-安装与使用" class="headerlink" title="2. 安装与使用"></a>2. 安装与使用</h2><h3 id="2-1-安装"><a href="#2-1-安装" class="headerlink" title="2.1 安装"></a>2.1 安装</h3><p><strong>安装方式一:</strong> 可以直接在Linux上通过命令下载</p><p>可以在官方 Github 上进行下载，如果速度较慢，可以尝试国内的码云 Gitee 下载。</p><ul><li><p>Github下载</p><pre><code class="highlight shell">wget https://alibaba.github.io/arthas/arthas-boot.jar</code></pre><p><img src="https://raw.githubusercontent.com/GeorgeChan95/blogimg/master/img/2024/08/24/20240824-082939.png" alt="从Github下载"></p></li><li><p>Gitee 下载</p><pre><code class="highlight shell">wget https://arthas.gitee.io/arthas-boot.jar</code></pre></li></ul><p><strong>安装方式二:</strong></p><p>也可以在浏览器直接访问 <a href="https://alibaba.github.io/arthas/arthas-boot.jar">https://alibaba.github.io/arthas/arthas-boot.jar</a> ，等待下载完后，上传到Linux服务器上。</p><p><strong>卸载</strong></p><p>在 Linux&#x2F;Unix&#x2F;Mac 平台，删除下面的文件：</p><pre><code class="highlight shell">rm -rf ~/.arthasrm -rf ~/logs/arthas</code></pre><p><img src="https://raw.githubusercontent.com/GeorgeChan95/blogimg/master/img/2024/08/24/20240824-083154.png" alt="image-20240824083153843"></p><p>Windows 平台直接删除 <code>&lt;User_Home&gt;</code> 下的 .arthas 和 logs&#x2F;arthas 目录</p><h3 id="2-2-工程目录"><a href="#2-2-工程目录" class="headerlink" title="2.2 工程目录"></a>2.2 工程目录</h3><ul><li><strong>arthas-agent</strong>: 基于 JavaAgent 技术的代理</li><li><strong>bin</strong>: 一些启动脚本</li><li><strong>arthas-boot</strong>: Java 版本的一键安装启动脚本</li><li><strong>arthas-client</strong>: telnet client 代码</li><li><strong>arthas-common</strong>: 一些共用的工具类和枚举类</li><li><strong>arthas-core</strong>: 核心库，各种 arthas 命令的交互和实现</li><li><strong>arthas-demo</strong>: 示例代码</li><li><strong>arthas-memorycompiler</strong>: 内存编绎器代码，Fork from <a href="https://github.com/skalogs/SkaETL/tree/master/compiler">https://github.com/skalogs/SkaETL/tree/master/compiler</a></li><li><strong>arthas-packaging</strong>: maven 打包相关的</li><li><strong>arthas-site</strong>: arthas 站点</li><li><strong>arthas-spy</strong>: 编织到目标类中的各个功面</li><li><strong>static</strong>: 静态资源</li><li><strong>arthas-testcase</strong>: 测试</li></ul><h3 id="2-3-启动"><a href="#2-3-启动" class="headerlink" title="2.3 启动"></a>2.3 启动</h3><p>Arthas 只是一个 Java 程序，所以可以直接用 <code>java -jar</code> 运行。</p><ul><li><p>执行成功后，arthas 提供了一种命令行方式的交互方式，arthas 会检测当前服务器上的 Java 进程并将进程列表展示出来，用户输入对应的编号 (1、2、3、4…) 进行选择，然后回车。</p><p>选择进程（输入[]内编号（不是PID)回车）</p></li></ul><p><img src="https://raw.githubusercontent.com/GeorgeChan95/blogimg/master/img/2024/08/24/20240824-083713.png" alt="启动方式一"></p><ul><li>方式2: 运行时选择 Java 进程 PID</li></ul><p><img src="https://raw.githubusercontent.com/GeorgeChan95/blogimg/master/img/2024/08/24/20240824-083826.png" alt="启动方式二"></p><h3 id="2-4-查看进程"><a href="#2-4-查看进程" class="headerlink" title="2.4 查看进程"></a>2.4 查看进程</h3><p>查看运行中的程序进程号，使用命令：<code>jps</code> 或者 <code>jps -l</code></p><h3 id="2-5-查看日志"><a href="#2-5-查看日志" class="headerlink" title="2.5 查看日志"></a>2.5 查看日志</h3><pre><code class="highlight shell">cat ~/logs/arthas/arthas.log</code></pre><h3 id="2-6-参看帮助"><a href="#2-6-参看帮助" class="headerlink" title="2.6 参看帮助"></a>2.6 参看帮助</h3><pre><code class="highlight shell">java -jar arthas-boot.jar -h</code></pre><h3 id="2-7-web-console"><a href="#2-7-web-console" class="headerlink" title="2.7 web console"></a>2.7 web console</h3><p>除了在命令行查看外，<code>Arthas</code>目前还支持 <code>Web Console</code> 。在成功启动连接进程之后就已经自动启动，可以直接访问 <code>http://127.0.0.1:8563/</code> 访问，页面上的操作模式和控制台完全一样。</p><h3 id="2-8-退出"><a href="#2-8-退出" class="headerlink" title="2.8 退出"></a>2.8 退出</h3><ul><li>使用 <code>quit/exit</code>：退出当前客户端</li><li>使用 <code>stop/shutdown</code>：关闭 arthas 服务端，并退出所有客户端。</li></ul><h2 id="3-相关诊断指令"><a href="#3-相关诊断指令" class="headerlink" title="3. 相关诊断指令"></a>3. 相关诊断指令</h2><p>官方文档: <a href="https://arthas.aliyun.com/doc/commands.html">https://arthas.aliyun.com/doc/commands.html</a></p><h3 id="3-1-基础指令"><a href="#3-1-基础指令" class="headerlink" title="3.1 基础指令"></a>3.1 基础指令</h3><ul><li><code>help</code>：查看命令帮助信息</li><li><code>cat</code>：打印文件内容，和 linux 里的 cat 命令类似</li><li><code>echo</code>：打印参数，和 linux 里的 echo 命令类似</li><li><code>grep</code>：匹配查找，和 linux 里的 grep 命令类似</li><li><code>tee</code>：复制标准输入到标准输出和指定的文件，和 linux 里的 tee 命令类似</li><li><code>pwd</code>：返回当前的工作目录，和 linux 命令类似</li><li><code>cls</code>：清空当前屏幕区域</li><li><code>session</code>：查看当前会话的信息</li><li><code>reset</code>：重置增强类，将被 Arthas 增强过的类全部还原，Arthas 服务端关闭时会重置所有增强过的类</li><li><code>version</code>：输出当前目标 Java 进程所加戟的 Arthas 版本号</li><li><code>history</code>：打印命令历史</li><li><code>quit</code>：退出当前 Arthas 客户端，其他 Arthas 客户端不受影响</li><li><code>stop</code>：关闭 Arthas 服务端，所有 Arthas 客户端全部退出</li><li><code>keymap</code>：Arthas 快捷键列表及自定义快捷键</li></ul><h3 id="3-2-jvm相关"><a href="#3-2-jvm相关" class="headerlink" title="3.2 jvm相关"></a>3.2 jvm相关</h3><p><a href="https://arthas.aliyun.com/doc/commands.html">https://arthas.aliyun.com/doc/commands.html</a></p><ul><li><code>dashboard</code>: 当前系统的实时数据面板</li><li><code>thread</code>: 查看当前 JVM 的线程堆栈信息</li><li><code>jvm</code>: 查看当前 JVM 的信息</li><li><code>sysenv</code>: 查看 JVM 的环境变量</li><li><code>sysprop</code>: 查看和修改 JVM 的系统属性</li><li><code>sysem</code>: 查看 JVM 的环境变量</li><li><code>vmoption</code>: 查看和修改 JVM 里诊断相关的 option</li><li><code>perfcounter</code>: 查看当前 JVM 的 Perf Counter 信息</li><li><code>logger</code>: 查看和修改 logger</li><li><code>getstatic</code>: 查看类的静态属性</li><li><code>ognl</code>: 执行 ognl 表达式</li><li><code>mbean</code>: 查看 Mbean 的信息</li><li><code>heapdump</code>: dump java heap，类似 jmap 命令的 heap dump 功能</li></ul><h3 id="3-3-class-classloader相关"><a href="#3-3-class-classloader相关" class="headerlink" title="3.3 class&#x2F;classloader相关"></a>3.3 class&#x2F;classloader相关</h3><ul><li><code>sc</code>: 查看 JVM 已加载的类信息</li><li><code>sm</code>: 查看已加载类的方法信息</li><li><code>jad</code>: 反编译指定已加载类的源码</li><li><code>mc</code>: 内存编译器，内存编译.java 文件为.class 文件</li><li><code>retransform</code>: 加载外部的.class 文件，retransform 到 JVM 里</li><li><code>redefine</code>: 加载外部的.class 文件，redefine 到 JVM 里</li><li><code>dump</code>: dump 已加载类的 byte code 到特定目录</li><li><code>classloader</code>: 查看 classloader 的继承树，urls，类加载信息，使用 classloader 去 getResource</li></ul><h3 id="3-4-monitor-watch-trace相关"><a href="#3-4-monitor-watch-trace相关" class="headerlink" title="3.4 monitor&#x2F;watch&#x2F;trace相关"></a>3.4 monitor&#x2F;watch&#x2F;trace相关</h3><p>请注意，这些命令，都通过字节码增强技术来实现的，会在指定类的方法中插入一些切面来实现数据统计和观测，因此在线上、预发使用时，请尽量明确需要观测的类、方法以及条件，诊断结束要执行 stop 或将增强过的类执行 reset 命令。</p><ul><li>monitor 对匹配 <code>class-pattern／method-pattern／condition-express</code> 的类、方法的调用进行监控。</li><li>watch: 让你能方便的观察到指定函数的调用情况。能观察到的范围为：返回值、抛出异常、入参，通过编写 OGNL 表达式进行对应变量的查看。</li><li>trace: <code>trace</code> 命令能主动搜索 <code>class-pattern</code>／<code>method-pattern</code> 对应的方法调用路径，渲染和统计整个调用链路上的所有性能开销和追踪调用链路。</li><li>stack: 很多时候我们都知道一个方法被执行，但这个方法被执行的路径非常多，或者你根本就不知道这个方法是从那里被执行了，此时你需要的是 <code>stack</code> 命令。</li><li>tt: 方法执行数据的时空隧道，记录下指定方法每次调用的入参和返回信息，并能对这些不同的时间下调用进行观测</li></ul><h3 id="3-5-其他"><a href="#3-5-其他" class="headerlink" title="3.5 其他"></a>3.5 其他</h3><ul><li><p>profiler&#x2F;火焰图: <a href="https://arthas.aliyun.com/doc/profiler.html">https://arthas.aliyun.com/doc/profiler.html</a></p><p><img src="https://raw.githubusercontent.com/GeorgeChan95/blogimg/master/img/2024/08/24/20240824-093316.jpg" alt="火焰图"></p></li><li><p>options: <a href="https://arthas.aliyun.com/doc/options.html">https://arthas.aliyun.com/doc/options.html</a></p></li></ul><h1 id="七、Java-Misssion-Control"><a href="#七、Java-Misssion-Control" class="headerlink" title="七、Java Misssion Control"></a>七、Java Misssion Control</h1><h2 id="1-历史"><a href="#1-历史" class="headerlink" title="1. 历史"></a>1. 历史</h2><p>在 Oracle 收购 Sun 之前，Oracle 的 JRockit 虚拟机提供了一款叫做 JRockit Mission Control 的虚拟机诊断工具。</p><p>在 Oracle 收购 sun 之后，Oracle 公司同时拥有了 Hotspot 和 JRockit 两款虚拟机。根据 Oracle 对于 Java 的战略，在今后的发展中，会将 JRokit 的优秀特性移植到 Hotspot 上。其中一个重要的改进就是在 Sun 的 JDK 中加入了 JRockit 的支持。</p><p>在 Oracle JDK 7u40 之后，Mission Control 这款工具己经绑定在 Oracle JDK 中发布。</p><p>自 Java11 开始，本节介绍的 JFR 己经开源。但在之前的 Java 版本，JFR 属于 Commercial Feature 通过 Java 虚拟机参数 <code>-XX:+UnlockCommercialFeatures</code> 开启。</p><ul><li>官方地址：<a href="https://openjdk.org/projects/jmc">https://openjdk.org/projects/jmc</a></li><li>Github项目地址：<a href="https://github.com/openjdk/jmc">https://github.com/openjdk/jmc</a></li></ul><h2 id="2-概述"><a href="#2-概述" class="headerlink" title="2. 概述"></a>2. 概述</h2><p>Java Mission Control（简称 JMC) ， Java 官方提供的性能强劲的工具，是一个用于对 Java 应用程序进行管理、监视、概要分析和故障排除的工具套件。</p><p>它包含一个 GUI 客户端以及众多用来收集 Java 虚拟机性能数据的插件如 JMX Console（能够访问用来存放虚拟机各个子系统运行数据的 MXBeans）以及虚拟机内置的高效 profiling 工具 Java Flight Recorder（JFR）。</p><p>JMC 的另一个优点就是：采用取样，而不是传统的代码植入技术，对应用性能的影响非常非常小，完全可以开着 JMC 来做压测（唯一影响可能是 full gc 多了）。</p><h2 id="3-启动"><a href="#3-启动" class="headerlink" title="3. 启动"></a>3. 启动</h2><p>Mission Control 位于 <code>%JAVA_HOME%/bin/jmc.exe</code></p><p><img src="https://raw.githubusercontent.com/GeorgeChan95/blogimg/master/img/2024/08/24/20240824-094004.png" alt="jmc.exe"></p><h2 id="4-功能：实时监控JVM运行时的状态"><a href="#4-功能：实时监控JVM运行时的状态" class="headerlink" title="4. 功能：实时监控JVM运行时的状态"></a>4. 功能：实时监控JVM运行时的状态</h2><p>如果是远程服务器，使用前要开 JMX。</p><p><strong>JMX 启动参数：</strong></p><ul><li>-Dcom.sun.management.jmxremote 远程开启开关</li><li>-Dcom.sun.management.jmxremote.port&#x3D;1808 jmx远程调用端口</li><li>-Dcom.sun.management.jmxremote.rmi.port&#x3D;1808 添加 rmi 端口<ul><li>JMX 和 RMI，是两种相关联的技术，JMX 使用 RMI 作为远程管理工具来管理和监控 Java 程序，RMI 为 JMX 提供了远程连接所需的远程调用和通信机制。</li></ul></li><li>-Dcom.sun.management.jmxremote.authenticate&#x3D;false 不开启验证</li><li>-Dcom.sun.management.jmxremote.ssl&#x3D;false 不为ssl连接</li><li>-Djava.rmi.server.hostname&#x3D;192.168.6.203 服务器所在ip或者域名</li><li>-Dcom.sun.management.jmxremote.pwd.file&#x3D;&#x2F;opt&#x2F;module&#x2F;jdk1.8.0_261&#x2F;jre&#x2F;lib&#x2F;management&#x2F;jmxremote.password 配置JMX远程连接用户名和密码</li></ul><p><strong>服务端启动示例</strong></p><pre><code class="highlight shell">java -Xmx512m -Xms512m -Xmn512m \-XX:+UnlockCommercialFeatures -XX:+FlightRecorder \-Dcom.sun.management.jmxremote \-Dcom.sun.management.jmxremote.port=1808 \-Dcom.sun.management.jmxremote.rmi.port=1808 \-Dcom.sun.management.jmxremote.authenticate=false \-Dcom.sun.management.jmxremote.ssl=false \-Djava.rmi.server.hostname=192.168.6.203 \-jar ioms-ums.jar \--spring.profiles.active=dev</code></pre><p><em>注意：启动时，要在关闭用户校验的情况下启动JMX：<code>-Dcom.sun.management.jmxremote.authenticate=false</code>，并且添加参数 <code>-XX:+UnlockCommercialFeatures -XX:+FlightRecorder</code> 开启飞行记录仪；</em></p><p><strong>另外说明一点：</strong></p><p>这里需要注意的一点是，JMC可以用于java7以上的所有版本，而飞行记录器，只能用于oracle jre，且是java7及以上的版本，因为要使用飞行记录器，需要开启jvm的商业特性，也就是在启动的时候加上参数：”-XX:+UnlockCommercialFeatures”,”-XX:+FlightRecorder”。如果是open jdk，尝试加这两个参数的时候，会直接导致虚拟机终止，无法正常启动。所以，飞行记录器只能局限在oracle jdk里面使用。</p><p><strong>JMC连接监控进程</strong></p><p>文件 -&gt;连接 -&gt;创建新连接， 填入上面 JMX 参数的 host 和 port, 具体参考：第一章第3节：服务端开启远程监控</p><p><img src="https://raw.githubusercontent.com/GeorgeChan95/blogimg/master/img/2024/08/24/20240824-094752.png" alt="远程连接JMC"></p><p><img src="https://raw.githubusercontent.com/GeorgeChan95/blogimg/master/img/2024/08/24/20240824-095059.png" alt="连接JMC成功"></p><h2 id="5-Java-Flight-Recorder"><a href="#5-Java-Flight-Recorder" class="headerlink" title="5. Java Flight Recorder"></a>5. Java Flight Recorder</h2><p>Java Flight Recorder 是 JMC 的其中一个组件。</p><p>Java Flight Recorder 能够以极低的性能开销收集 Java 虚拟机的性能数据。</p><p>JFR 的性能开销很小，在默认配置下平均低于 1%。与其他工具相比，JFR 能够直接访问虚拟机内的数据，并且不会影响虚拟机的优化。因此，它非常适用于生产环境下满负荷运行的 Java 程序。</p><p>Java Flight Recorder 和 JDK Mission Control 共同创建了一个完整的工具链。JDKMission Control 可对 Java Flight Recorder 连续收集低水平和详细的运行时信息进行高效详细的分析。</p><h3 id="5-1-事件类型"><a href="#5-1-事件类型" class="headerlink" title="5.1 事件类型"></a>5.1 事件类型</h3><p>当启用时 JFR将记录运行过程中发生的一系列事件。其中包括Java层面的事件如线程事件、锁事件，以及Java虚拟机内部的事件，如新建对象，垃圾回收和即时编译事件。</p><p>按照发生时机以及持续时间来划分，JFR的事件共有四种类型，它们分别为以下四种：</p><ul><li>瞬时事件（Instant Event) ，用户关心的是它们发生与否，例如异常、线程启动事件。</li><li>持续事件(Duration Event) ，用户关心的是它们的持续时间，例如垃圾回收事件。</li><li>计时事件(Timed Event) ，是时长超出指定阈值的持续事件。</li><li>取样事件（Sample Event)，是周期性取样的事件。</li></ul><p>取样事件的其中一个常见例子便是方法抽样（Method Sampling），即每隔一段时问统计各个线程的栈轨迹。如果在这些抽样取得的栈轨迹中存在一个反复出现的方法，那么我们可以推测该方法是热点方法</p><h3 id="5-2-启动方式"><a href="#5-2-启动方式" class="headerlink" title="5.2 启动方式"></a>5.2 启动方式</h3><p><strong>方式1：使用 <code>-XX:StartFlightRecording=参数</code></strong></p><p>第一种是在运行目标 Java 程序时添加 <code>-XX:startFlightRecording=参数</code>。</p><p>比如: 下面命令中，JFR 将会在 Java 虚拟机启动 5s 后 (对应 <code>delay=5s</code>) 收集数据，持续 20s(对应 <code>duration=28s</code>)。当收集完毕后，JFR 会将收集得到的数据保存至指定的文件中(对应 <code>filename=myrecording.jfr</code>)</p><pre><code class="highlight shell">java -Xmx512m -Xms512m -Xmn512m \-XX:+UnlockCommercialFeatures -XX:+FlightRecorder \-XX:StartFlightRecording=delay=5s,duration=20s,filename=myrecording.jfr,settings=profile \-Dcom.sun.management.jmxremote \-Dcom.sun.management.jmxremote.port=1808 \-Dcom.sun.management.jmxremote.rmi.port=1808 \-Dcom.sun.management.jmxremote.authenticate=false \-Dcom.sun.management.jmxremote.ssl=false \-Djava.rmi.server.hostname=192.168.6.203 \-jar ioms-ums.jar \--spring.profiles.active=dev</code></pre><p>由于 JFR 将持续收集数据，如果不加以限制，那么 JFR 可能会填满硬盘的所有空间。因此，我们有必要对这种模式下所收集的数据进行限制。</p><p>比如:</p><pre><code class="highlight shell">java -Xmx512m -Xms512m -Xmn512m \-XX:+UnlockCommercialFeatures -XX:+FlightRecorder \-XX:StartFlightRecording=delay=5s,,duration=20s,maxage=10m,maxsize=100m,name=SomeLabel,filename=myrecording.jfr,settings=profile \-Dcom.sun.management.jmxremote \-Dcom.sun.management.jmxremote.port=1808 \-Dcom.sun.management.jmxremote.rmi.port=1808 \-Dcom.sun.management.jmxremote.authenticate=false \-Dcom.sun.management.jmxremote.ssl=false \-Djava.rmi.server.hostname=192.168.6.203 \-jar ioms-ums.jar \--spring.profiles.active=dev</code></pre><p><strong>方式2：使用 jcmd 的JFR.*子命令</strong></p><p>通过 jcmd 来让 JFR 开始收集数据、停止收集数据，或者保存所收集的数据，对应的子命令分别为JFR.start, JFR.stop，以及JFR.dump。</p><ul><li><p>启动java程序</p><pre><code class="highlight shell">java -Xmx512m -Xms512m -Xmn512m \-XX:+UnlockCommercialFeatures -XX:+FlightRecorder \-jar ioms-ums.jar \--spring.profiles.active=dev</code></pre></li><li><p>查看程序进程</p><pre><code class="highlight shell">root@ubuntu:/opt/module/ioms/ioms-ums# jps -l29318 ioms-gateway.jar29272 ioms-eureka.jar27116 ioms-ums.jar27228 sun.tools.jps.Jps29422 ioms-auth.ja</code></pre></li><li><p>通过jcmd来让 JFR 开始收集数据</p><pre><code class="highlight shell"><span class="meta prompt_">$ </span><span class="language-bash">jcmd &lt;PID&gt; JFR.start settings=profile maxage=10m maxsize=150m name=SomeLabel</span></code></pre><p>示例：</p><pre><code class="highlight shell">jcmd 27116 JFR.start settings=profile maxage=10m maxsize=100m name=test-jfr</code></pre><p><img src="https://raw.githubusercontent.com/GeorgeChan95/blogimg/master/img/2024/08/24/20240824-111447.png" alt="JFR 开始收集数据"></p></li><li><p>保存所收集的数据</p><pre><code class="highlight shell">jcmd &lt;PID&gt; JFR.dump name=SomeLabel filename=myrecording.jfr</code></pre><p>示例：</p><pre><code class="highlight shell">jcmd 27116 JFR.dump name=test-jfr filename=myrecording.jfr</code></pre><p><img src="https://raw.githubusercontent.com/GeorgeChan95/blogimg/master/img/2024/08/24/20240824-111612.png" alt="保存所收集的数据"></p></li><li><p>关闭目标进程中的 JFR</p><pre><code class="highlight shell"><span class="meta prompt_">$ </span><span class="language-bash">jcmd &lt;PID&gt; JFR.stop name=SomeLabel</span></code></pre><p>示例:</p><pre><code class="highlight shell">jcmd 27116 JFR.stop name=test-jfr</code></pre><p><img src="https://raw.githubusercontent.com/GeorgeChan95/blogimg/master/img/2024/08/24/20240824-111828.png" alt="关闭目标进程中的 JFR"></p></li></ul><p><strong>配置飞行记录仪监测</strong></p><ol><li>启动飞行记录仪</li></ol><p><img src="https://raw.githubusercontent.com/GeorgeChan95/blogimg/master/img/2024/08/24/20240824-112403.png" alt="启动飞行记录仪"></p><p><img src="https://raw.githubusercontent.com/GeorgeChan95/blogimg/master/img/2024/08/24/20240824-113110.png" alt="启动飞行记录仪"></p><p>2.正式启动</p><p><img src="https://raw.githubusercontent.com/GeorgeChan95/blogimg/master/img/2024/08/24/20240824-113329.png" alt="正式启动"></p><p>启动 Object Count 和 Object Count after GC </p><p><img src="https://raw.githubusercontent.com/GeorgeChan95/blogimg/master/img/2024/08/24/20240824-113508.png" alt="正式启动"></p><p><img src="https://raw.githubusercontent.com/GeorgeChan95/blogimg/master/img/2024/08/24/20240824-115346.png" alt="正式启动"></p><h3 id="5-3-Java-Flight-Recorder-取样分析"><a href="#5-3-Java-Flight-Recorder-取样分析" class="headerlink" title="5.3 Java Flight Recorder 取样分析"></a>5.3 Java Flight Recorder 取样分析</h3><p>要采用取样，必须先添加参数:</p><ul><li><code>-XX:+UnlockCommercialFeatures</code></li><li><code>-XX:+FlightRecorder</code></li></ul><p>JDK9及更高版本</p><ul><li><code>-XX:+UnlockCommercialFeatures</code></li><li><code>-XX:+StartFlightRecording</code></li></ul><p>如：<code>-XX:+UnlockCommercialFeatures -XX:+FlightRecorder -XX:StartFlightRecording=duration=200s</code></p><p>否则:</p><p><img src="https://raw.githubusercontent.com/GeorgeChan95/blogimg/master/img/2024/08/24/20240824-114008.png" alt="img"></p><p><img src="https://raw.githubusercontent.com/GeorgeChan95/blogimg/master/img/2024/08/24/20240824-114015.png" alt="img"></p><p>取样时间默认 1 分钟，可自行按需调整，事件设置选为profiling，然后可以设置取样 profile哪些信息，比如:</p><ul><li>加上对象数量的统计: Java Virtual Machine →→ Gc →→ Detailed →→ ObjectCount&#x2F;Object Count after GC</li><li>方法调用采样的间隔从 10ms 改为 1ms(但不能低于 1ms，否则会影响性能了): JavaVirtual Machine →→ Profiling →→ Method Profiling Sample&#x2F;Method SamplingInformation</li><li>Socket 与 File 采样，10ms 太久，但即使改为 1ms 也未必能抓住什么，可以干脆取消掉:Java Application →→ File Read&#x2F;FileWrite&#x2F;Socket Read&#x2F;Socket Write</li></ul><p><img src="https://raw.githubusercontent.com/GeorgeChan95/blogimg/master/img/2024/08/24/20240824-115458.png" alt="img"></p><p>然后就开始 Profile，到时间后 Profile 结束，会自动把记录下载回来，在 JMC 中展示。</p><p><img src="https://raw.githubusercontent.com/GeorgeChan95/blogimg/master/img/2024/08/24/20240824-120314.png" alt="JMC分析文件"></p><h1 id="八、其他工具"><a href="#八、其他工具" class="headerlink" title="八、其他工具"></a>八、其他工具</h1><h2 id="1-Flame-Graphs（火焰图）"><a href="#1-Flame-Graphs（火焰图）" class="headerlink" title="1. Flame Graphs（火焰图）"></a>1. Flame Graphs（火焰图）</h2><p>在追求极致性能的场景下，了解你的程序运行过程中cpu在干什么很重要，火焰图就是一种非常直观的展示CPU在程序整个生命周期过程中时间分配的工具。火焰图对于现代的程序员不应该陌生，这个工具可以非常直观的显示出调用找中的CPU消耗瓶颈。</p><p>网上的关于Java火焰图的讲解大部分来自于Brenden Gregg的博客 <a href="http://new.brendangregg.com/flamegraphs.html">http://new.brendangregg.com/flamegraphs.html</a></p><p><strong>CPU Flame Graphs</strong></p><p><img src="https://raw.githubusercontent.com/GeorgeChan95/blogimg/master/img/2024/08/24/20240824-120453.svg" alt="CPU Flame Graphs"></p><p>Memory Flame Graph</p><p><img src="https://raw.githubusercontent.com/GeorgeChan95/blogimg/master/img/2024/08/24/20240824-120514.svg" alt="Memory Flame Graph"></p><p>火焰图，简单通过x轴横条宽度来度量时间指标，y轴代表线程栈的层次。</p><h2 id="2-Tprofiler"><a href="#2-Tprofiler" class="headerlink" title="2. Tprofiler"></a>2. Tprofiler</h2><ul><li><p><strong>案例：</strong></p><p>使用 JDK 自身提供的工具进行 JVM 调优可以将下 TPS 由 2.5 提升到 20（提升了 7 倍），并准确 定位系统瓶颈。</p><p>系统瓶颈有：应用里释态对象不是太多、有大量的业务线程在频繁创建一些生命周期很长的临时对象，代码里有问题。</p><p>那么，如何在海量业务代码里边准确定位这些性能代码？这里使用阿里开源工具 Tprofiler 来定位 这些性能代码，成功解决掉了 GC 过于频繁的性能瓶预，并最终在上次优化的基础上将 TPS 再提升了 4 倍，即提升到 100。</p></li><li><p>Tprofiler 配置部署、远程操作、 日志阅谈都不太复杂，操作还是很简单的。但是其却是能够 起到一针见血、立竿见影的效果，帮我们解决了 GC 过于频繁的性能瓶预。</p></li><li><p>Tprofiler 最重要的特性就是能够统汁出你指定时间段内 JVM 的 top method 这些 top method 极有可能就是造成你 JVM 性能瓶颈的元凶。这是其他大多数 JVM 调优工具所不具备的，包括 JRockit Mission Control。JRokit 首席开发者 Marcus Hirt 在其私人博客《 Lom Overhead Method Profiling cith Java Mission Control》下的评论中曾明确指出 JRMC 井不支持 TOP 方法的统计。</p></li></ul><p>Github地址：<a href="http://github.com/alibaba/Tprofiler">http://github.com/alibaba/Tprofiler</a></p><h2 id="3-Btrace"><a href="#3-Btrace" class="headerlink" title="3. Btrace"></a>3. Btrace</h2><p>常见的动态追踪工具有BTrace、HouseHD（该项目己经停止开发）、Greys-Anatomy（国人开发 个人开发者）、Byteman（JBoss出品），注意Java运行时追踪工具井不限干这几种，但是这几个是相对比较常用的。</p><p>BTrace是SUN Kenai 云计算开发平台下的一个开源项目，旨在为java提供安全可靠的动态跟踪分析工具。先看一卜日Trace的官方定义：</p><blockquote><p>BTrace is a safe, dynamic tracing tool for the Java platform. BTrace can be used to dynamically trace a running Java program(similar to DTrace for OpenSolaris applications and 0s). BTrace dynamically instruments the classes of the target application to inject tracing code (“bytecode tracing” ).</p></blockquote><p>大概意思是一个 Java 平台的安全的动态追踪工具，可以用来动态地追踪一个运行的 Java 程序。BTrace动态调整目标应用程序的类以注入跟踪代码（“字节码跟踪“）。</p><h2 id="3-YourKit"><a href="#3-YourKit" class="headerlink" title="3. YourKit"></a>3. YourKit</h2><h2 id="4-JProbe"><a href="#4-JProbe" class="headerlink" title="4. JProbe"></a>4. JProbe</h2><h2 id="5-Spring-Insight"><a href="#5-Spring-Insight" class="headerlink" title="5. Spring Insight"></a>5. Spring Insight</h2>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;一、工具概述&quot;&gt;&lt;a href=&quot;#一、工具概述&quot; class=&quot;headerlink&quot; title=&quot;一、工具概述&quot;&gt;&lt;/a&gt;一、工具概述&lt;/h1&gt;&lt;p&gt;使用命令行工具或组合能帮您获取目标Java应用性能相关的基础信息，但它们存在下列局限：&lt;/p&gt;
&lt;ul&gt;
&lt;</summary>
      
    
    
    
    <category term="JVM" scheme="https://georgechan95.github.io/categories/JVM/"/>
    
    
    <category term="java" scheme="https://georgechan95.github.io/tags/java/"/>
    
    <category term="jvm" scheme="https://georgechan95.github.io/tags/jvm/"/>
    
  </entry>
  
</feed>
