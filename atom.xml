<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>George&#39;s Blog</title>
  
  <subtitle>个人邮箱：george_95@126.com</subtitle>
  <link href="https://georgechan95.github.io/atom.xml" rel="self"/>
  
  <link href="https://georgechan95.github.io/"/>
  <updated>2024-09-27T11:59:39.172Z</updated>
  <id>https://georgechan95.github.io/</id>
  
  <author>
    <name>George</name>
    
  </author>
  
  <generator uri="https://hexo.io/">Hexo</generator>
  
  <entry>
    <title>07-JUC进阶-CAS</title>
    <link href="https://georgechan95.github.io/blog/5e3757c1.html"/>
    <id>https://georgechan95.github.io/blog/5e3757c1.html</id>
    <published>2024-09-26T11:37:00.000Z</published>
    <updated>2024-09-27T11:59:39.172Z</updated>
    
    <content type="html"><![CDATA[<h1 id="一、没有CAS之前"><a href="#一、没有CAS之前" class="headerlink" title="一、没有CAS之前"></a>一、没有CAS之前</h1><ul><li><p>多线程环境不使用原子类保证线程安全（基本数据类型）</p><pre><code class="highlight java"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">T1</span> &#123;    <span class="keyword">volatile</span> <span class="type">int</span> <span class="variable">number</span> <span class="operator">=</span> <span class="number">0</span>;    <span class="comment">//读取</span>    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">getNumber</span><span class="params">()</span> &#123;        <span class="keyword">return</span> number;    &#125;    <span class="comment">//写入加锁保证原子性</span>    <span class="keyword">public</span> <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title function_">setNumber</span><span class="params">()</span> &#123;        number++;    &#125;&#125;</code></pre></li><li><p>多线程环境使用原子类保证线程安全（基本数据类型）</p><pre><code class="highlight java"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">T2</span> &#123;    <span class="type">AtomicInteger</span> <span class="variable">atomicInteger</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">AtomicInteger</span>();    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">getAtomicInteger</span><span class="params">()</span> &#123;        <span class="keyword">return</span> atomicInteger.get();    &#125;    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setAtomicInteger</span><span class="params">()</span> &#123;        atomicInteger.getAndIncrement();    &#125;&#125;</code></pre></li></ul><h1 id="二、什么是CAS"><a href="#二、什么是CAS" class="headerlink" title="二、什么是CAS"></a>二、什么是CAS</h1><h2 id="1-概念"><a href="#1-概念" class="headerlink" title="1. 概念"></a>1. 概念</h2><p>CAS 即： compare and swap的缩写，中文翻译成比较并交换,实现并发算法时常用到的一种技术。它包含三个操作数——内存位置、预期原值及更新值。</p><p>执行CAS操作的时候，将内存位置的值与预期原值比较：</p><ul><li>如果相匹配，那么处理器会自动将该位置值更新为新值，</li><li>如果不匹配，处理器不做任何操作，多个线程同时执行CAS操作只有一个会成功。</li></ul><h2 id="2-原理"><a href="#2-原理" class="headerlink" title="2. 原理"></a>2. 原理</h2><h3 id="2-1-概述"><a href="#2-1-概述" class="headerlink" title="2.1 概述"></a>2.1 概述</h3><p>CAS有3个操作数，位置内存值V，旧的预期值A，要修改的更新值B。</p><p>当且仅当旧的预期值A和内存值V相同时，将内存值V修改为B，否则什么都不做或重来</p><p><img src="https://raw.githubusercontent.com/GeorgeChan95/blogimg/master/img/2024/09/26/20240926-200317.png" alt="CAS原理"></p><h3 id="2-2-硬件级别保证"><a href="#2-2-硬件级别保证" class="headerlink" title="2.2 硬件级别保证"></a>2.2 硬件级别保证</h3><p>CAS是JDK提供的非阻塞原子性操作，它通过硬件保证了比较-更新的原子性。</p><p>它是非阻塞的且自身原子性，也就是说它效率更高且通过硬件保证，更可靠。</p><p>CAS是一条CPU的原子指令（cmpxchg指令），不会造成所谓的数据不一致问题，Unsafe提供的CAS方法（如 compareAndSwapXXX ）底层实现即为CPU指令<code>cmpxchg</code>。</p><p>执行 <code>cmpxchg</code> 指令的时候，会判断当前系统是否为多核系统，如果是就给总线加锁，只有一个线程会对总线加锁成功，加锁成功之后会执行cas操作，也就是说CAS的原子性实际上是CPU实现的， 其实在这一点上还是有排他锁的，只是比起用 <code>synchronized</code>， 这里的排他时间要短的多， 所以在多线程情况下性能会比较好</p><h2 id="3-CAS代码示例"><a href="#3-CAS代码示例" class="headerlink" title="3. CAS代码示例"></a>3. CAS代码示例</h2><pre><code class="highlight java"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">CASDemo</span> &#123;    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;        <span class="type">AtomicInteger</span> <span class="variable">atomicInteger</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">AtomicInteger</span>(<span class="number">5</span>);        System.out.println(atomicInteger.get());                System.out.println(atomicInteger.compareAndSet(<span class="number">5</span>, <span class="number">308</span>) + <span class="string">&quot;\t&quot;</span> + atomicInteger.get());        System.out.println(atomicInteger.compareAndSet(<span class="number">5</span>, <span class="number">3333</span>) + <span class="string">&quot;\t&quot;</span> + atomicInteger.get());    &#125;&#125;</code></pre><p>执行结果：</p><pre><code class="highlight shell">5true308false308</code></pre><h2 id="4-源码解析"><a href="#4-源码解析" class="headerlink" title="4. 源码解析"></a>4. 源码解析</h2><ul><li><p>compareAndSet(int expect, int update)</p><pre><code class="highlight java"><span class="comment">/**</span><span class="comment"> * Atomically sets the value to the given updated value</span><span class="comment"> * if the current value &#123;<span class="doctag">@code</span> ==&#125; the expected value.</span><span class="comment"> *</span><span class="comment"> * <span class="doctag">@param</span> expect the expected value</span><span class="comment"> * <span class="doctag">@param</span> update the new value</span><span class="comment"> * <span class="doctag">@return</span> &#123;<span class="doctag">@code</span> true&#125; if successful. False return indicates that</span><span class="comment"> * the actual value was not equal to the expected value.</span><span class="comment"> */</span><span class="keyword">public</span> <span class="keyword">final</span> <span class="type">boolean</span> <span class="title function_">compareAndSet</span><span class="params">(<span class="type">int</span> expect, <span class="type">int</span> update)</span> &#123;    <span class="keyword">return</span> unsafe.compareAndSwapInt(<span class="built_in">this</span>, valueOffset, expect, update);&#125;</code></pre><ul><li><p>unsafe.compareAndSwapInt(this, valueOffset, expect, update)</p><pre><code class="highlight java"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">native</span> <span class="type">boolean</span> <span class="title function_">compareAndSwapObject</span><span class="params">(Object var1, <span class="type">long</span> var2, Object var4, Object var5)</span>;<span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">native</span> <span class="type">boolean</span> <span class="title function_">compareAndSwapInt</span><span class="params">(Object var1, <span class="type">long</span> var2, <span class="type">int</span> var4, <span class="type">int</span> var5)</span>;<span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">native</span> <span class="type">boolean</span> <span class="title function_">compareAndSwapLong</span><span class="params">(Object var1, <span class="type">long</span> var2, <span class="type">long</span> var4, <span class="type">long</span> var6)</span>;</code></pre></li></ul><p>上面三个方法都是类似的，主要对4个参数做一下说明。</p><ul><li>var1：表示要操作的对象</li><li>var2：表示要操作对象中属性地址的偏移量</li><li>var4：表示需要修改数据的期望的值</li><li>var5&#x2F;var6：表示需要修改为的新值</li></ul></li></ul><p>那么什么是 <code>unsafe</code> 呢？</p><h1 id="三、关于-UnSafe-的理解"><a href="#三、关于-UnSafe-的理解" class="headerlink" title="三、关于 UnSafe 的理解"></a>三、关于 UnSafe 的理解</h1><h2 id="1-UnSafe"><a href="#1-UnSafe" class="headerlink" title="1. UnSafe"></a>1. UnSafe</h2><p><strong>UnSafe</strong></p><p><code>Unsafe</code> 是CAS的核心类，由于Java方法无法直接访问底层系统，需要通过本地（native）方法来访问，<code>Unsafe</code> 相当于一个后门，基于该类可以直接操作特定内存的数据。<code>Unsafe</code> 类存在于 <code>sun.misc</code> 包中，其内部方法操作可以像C的指针一样直接操作内存，因为Java中CAS操作的执行依赖于<code>Unsafe</code>类的方法。</p><p><strong>注意Unsafe类中的所有方法都是native修饰的，也就是说Unsafe类中的方法都直接调用操作系统底层资源执行相应任务</strong> </p><p><img src="https://raw.githubusercontent.com/GeorgeChan95/blogimg/master/img/2024/09/26/20240926-202221.png" alt="AtomicInteger"></p><p><strong>变量valueOffset</strong></p><p>变量 valueOffset，表示该变量值在内存中的偏移地址，因为 <code>Unsafe</code> 就是根据内存偏移地址获取数据的。</p><pre><code class="highlight java"><span class="comment">/**</span><span class="comment"> * Atomically increments by one the current value.</span><span class="comment"> *</span><span class="comment"> * <span class="doctag">@return</span> the previous value</span><span class="comment"> */</span><span class="keyword">public</span> <span class="keyword">final</span> <span class="type">int</span> <span class="title function_">getAndIncrement</span><span class="params">()</span> &#123;    <span class="keyword">return</span> unsafe.getAndAddInt(<span class="built_in">this</span>, valueOffset, <span class="number">1</span>);&#125;</code></pre><p><strong>用volatile修饰</strong>，保证了多线程之间的内存可见性。</p><p><img src="C:/Users/kd/AppData/Roaming/Typora/typora-user-images/image-20240926202653288.png" alt="变量value"></p><h2 id="2-CPU并发原语"><a href="#2-CPU并发原语" class="headerlink" title="2. CPU并发原语"></a>2. CPU并发原语</h2><p>我们知道i++线程不安全的，那 <code>atomicInteger.getAndIncrement()</code> 是如何保证线程安全的呢？</p><p>CAS的全称为Compare-And-Swap，它是一条CPU并发原语。它的功能是判断内存某个位置的值是否为预期值，如果是则更改为新的值，这个过程是原子的。<br>AtomicInteger 类主要利用 CAS (compare and swap) + volatile 和 native 方法来保证原子操作，从而避免 synchronized 的高开销，执行效率大为提升。</p><p><img src="https://raw.githubusercontent.com/GeorgeChan95/blogimg/master/img/2024/09/26/20240926-203001.png" alt="Compare-And-Swap"></p><p>CAS并发原语体现在JAVA语言中就是 <code>sun.misc.Unsafe</code> 类中的各个方法。调用 UnSafe 类中的CAS方法，JVM会帮我们实现出CAS汇编指令。这是一种完全依赖于硬件的功能，通过它实现了原子操作。再次强调，由于CAS是一种系统原语，原语属于操作系统用语范畴，是由若干条指令组成的，用于完成某个功能的一个过程，并且原语的执行必须是连续的，在执行过程中不允许被中断，也就是说CAS是一条CPU的原子指令，不会造成所谓的数据不一致问题。</p><h2 id="3-底层汇编"><a href="#3-底层汇编" class="headerlink" title="3. 底层汇编"></a>3. 底层汇编</h2><ul><li><p>native修饰的方法代表是底层方法</p><p>Unsafe类中的compareAndSwapInt，是一个本地方法，该方法的实现位于unsafe.cpp中</p><pre><code class="highlight cpp"><span class="built_in">UNSAFE_ENTRY</span>(jboolean, <span class="built_in">Unsafe_CompareAndSwapInt</span>(JNIEnv *env, jobject unsafe, jobject obj, jlong offset, jint e, jint x))  <span class="built_in">UnsafeWrapper</span>(<span class="string">&quot;Unsafe_CompareAndSwapInt&quot;</span>);  oop p = JNIHandles::<span class="built_in">resolve</span>(obj);<span class="comment">// 先想办法拿到变量value在内存中的地址，根据偏移量valueOffset，计算 value 的地址</span>  jint* addr = (jint *) <span class="built_in">index_oop_from_field_offset_long</span>(p, offset);<span class="comment">// 调用 Atomic 中的函数 cmpxchg来进行比较交换，其中参数x是即将更新的值，参数e是原内存的值</span>  <span class="keyword">return</span> (jint)(Atomic::<span class="built_in">cmpxchg</span>(x, addr, e)) == e;UNSAFE_END</code></pre><p>(Atomic::cmpxchg(x, addr, e)) &#x3D;&#x3D; e;</p></li><li><p>cmpxchg</p><p>&#x2F;&#x2F; 调用 Atomic 中的函数 cmpxchg来进行比较交换，其中参数x是即将更新的值，参数e是原内存的值<br>  return (jint)(Atomic::cmpxchg(x, addr, e)) &#x3D;&#x3D; e;</p><pre><code class="highlight cpp"><span class="function"><span class="type">unsigned</span> <span class="title">Atomic::cmpxchg</span><span class="params">(<span class="type">unsigned</span> <span class="type">int</span> exchange_value,<span class="keyword">volatile</span> <span class="type">unsigned</span> <span class="type">int</span>* dest, <span class="type">unsigned</span> <span class="type">int</span> compare_value)</span> </span>&#123;    <span class="built_in">assert</span>(<span class="built_in">sizeof</span>(<span class="type">unsigned</span> <span class="type">int</span>) == <span class="built_in">sizeof</span>(jint), <span class="string">&quot;more work to do&quot;</span>);  <span class="comment">/*</span><span class="comment">   * 根据操作系统类型调用不同平台下的重载函数，这个在预编译期间编译器会决定调用哪个平台下的重载函数*/</span>    <span class="keyword">return</span> (<span class="type">unsigned</span> <span class="type">int</span>)Atomic::<span class="built_in">cmpxchg</span>((jint)exchange_value, (<span class="keyword">volatile</span> jint*)dest, (jint)compare_value);&#125;</code></pre></li><li><p>在不同的操作系统下会调用不同的cmpxchg重载函数，本次用的是win10系统</p><pre><code class="highlight cpp"><span class="function"><span class="keyword">inline</span> jint <span class="title">Atomic::cmpxchg</span> <span class="params">(jint exchange_value, <span class="keyword">volatile</span> jint* dest, jint compare_value)</span> </span>&#123;  <span class="comment">//判断是否是多核CPU</span>  <span class="type">int</span> mp = os::<span class="built_in">is_MP</span>();  __asm &#123;    <span class="comment">//三个move指令表示的是将后面的值移动到前面的寄存器上</span>    mov edx, dest    mov ecx, exchange_value    mov eax, compare_value    <span class="comment">//CPU原语级别，CPU触发</span>    <span class="built_in">LOCK_IF_MP</span>(mp)    <span class="comment">//比较并交换指令</span>    <span class="comment">//cmpxchg: 即“比较并交换”指令</span>    <span class="comment">//dword: 全称是 double word 表示两个字，一共四个字节</span>    <span class="comment">//ptr: 全称是 pointer，与前面的 dword 连起来使用，表明访问的内存单元是一个双字单元 </span>    <span class="comment">//将 eax 寄存器中的值（compare_value）与 [edx] 双字内存单元中的值进行对比，</span>    <span class="comment">//如果相同，则将 ecx 寄存器中的值（exchange_value）存入 [edx] 内存单元中</span>    cmpxchg dword ptr [edx], ecx  &#125;&#125;</code></pre><p>到这里我们应该理解了CAS真正实现的机制了，它最终是由操作系统的汇编指令完成的。</p></li></ul><p><strong>总结：</strong></p><p>你只需要记住：CAS是靠硬件实现的从而在硬件层面提升效率，最底层还是交给硬件来保证原子性和可见性。实现方式是基于硬件平台的汇编指令，在intel的CPU中(X86机器上)，使用的是汇编指令<code>cmpxchg</code>指令。 </p><p>核心思想就是：比较要更新变量的值V和预期值E（compare），相等才会将V的值设为新值N（swap）如果不相等自旋再来。</p><h1 id="四、原子引用"><a href="#四、原子引用" class="headerlink" title="四、原子引用"></a>四、原子引用</h1><p>除了 AtomicInteger 原子整型，可否有其它原子类型？比如 AtomicBook 、AtomicOrder。</p><p>JDK 除了提供了原子整型之外，还提供了原子引用类：<code>AtomicReference</code></p><p><img src="https://raw.githubusercontent.com/GeorgeChan95/blogimg/master/img/2024/09/27/20240927-192203.png" alt="原子引用"></p><pre><code class="highlight java"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">AtomicReferenceTest</span> &#123;    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;        <span class="type">User1</span> <span class="variable">user1</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">User1</span>(<span class="string">&quot;张三&quot;</span>, <span class="number">20</span>);        <span class="type">User1</span> <span class="variable">user2</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">User1</span>(<span class="string">&quot;george&quot;</span>, <span class="number">22</span>);        AtomicReference&lt;User1&gt; atomicUser1 = <span class="keyword">new</span> <span class="title class_">AtomicReference</span>&lt;&gt;();        atomicUser1.set(user1);        System.out.println(<span class="string">&quot;当前人员：&quot;</span> + atomicUser1.get());        <span class="comment">// 第一次比较替换，张三 换成 george， 结果成功</span>        System.out.println(atomicUser1.compareAndSet(user1, user2) + <span class="string">&quot;\t&quot;</span> + atomicUser1.get());        <span class="comment">// 第二次比较替换，张三 换成 george， 结果失败</span>        System.out.println(atomicUser1.compareAndSet(user1, user2) + <span class="string">&quot;\t&quot;</span> + atomicUser1.get());    &#125;&#125;<span class="meta">@Data</span><span class="meta">@ToString</span><span class="meta">@NoArgsConstructor</span><span class="meta">@AllArgsConstructor</span><span class="keyword">class</span> <span class="title class_">User1</span> &#123;    <span class="keyword">private</span> String name;    <span class="keyword">private</span> Integer age;&#125;</code></pre><p>运行结果：</p><pre><code class="highlight shell">当前人员：User1(name=张三, age=20)trueUser1(name=george, age=22)falseUser1(name=george, age=22)</code></pre><h1 id="五、自旋锁"><a href="#五、自旋锁" class="headerlink" title="五、自旋锁"></a>五、自旋锁</h1><h2 id="1-自旋锁概念"><a href="#1-自旋锁概念" class="headerlink" title="1. 自旋锁概念"></a>1. 自旋锁概念</h2><p><strong>自旋锁（spinlock）</strong>是指尝试获取锁的线程不会立即阻塞，而是采用循环的方式去尝试获取锁，当线程发现锁被占用时，会不断循环判断锁的状态，直到获取。这样的好处是减少线程上下文切换的消耗，缺点是循环会消耗CPU</p><p>OpenJDK源码里面查看下 </p><p><img src="https://raw.githubusercontent.com/GeorgeChan95/blogimg/master/img/2024/09/27/20240927-192926.png" alt="Unsafe.java"></p><h2 id="2-实现一个自旋锁"><a href="#2-实现一个自旋锁" class="headerlink" title="2. 实现一个自旋锁"></a>2. 实现一个自旋锁</h2><pre><code class="highlight java"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">MySpinLock</span> &#123;    AtomicReference&lt;Thread&gt; atomicReference = <span class="keyword">new</span> <span class="title class_">AtomicReference</span>&lt;&gt;();    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">lock</span><span class="params">()</span> &#123;        <span class="comment">// 当没有替换成当前线程，则表示获取锁失败，线程自旋</span>        <span class="keyword">while</span> (!atomicReference.compareAndSet(<span class="literal">null</span>, Thread.currentThread())) &#123;        &#125;        System.out.println(Thread.currentThread().getName() + <span class="string">&quot;获取锁成功&quot;</span>);    &#125;    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">unlock</span><span class="params">()</span> &#123;        <span class="keyword">while</span> (atomicReference.compareAndSet(Thread.currentThread(), <span class="literal">null</span>)) &#123;            System.out.println(Thread.currentThread().getName() + <span class="string">&quot;解锁成功&quot;</span>);        &#125;    &#125;    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> InterruptedException &#123;        <span class="type">MySpinLock</span> <span class="variable">lock</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">MySpinLock</span>();        <span class="keyword">new</span> <span class="title class_">Thread</span>(() -&gt; &#123;            <span class="comment">// 获取锁</span>            lock.lock();            <span class="keyword">try</span> &#123;                <span class="comment">// 阻塞3秒</span>                TimeUnit.SECONDS.sleep(<span class="number">3</span>);            &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;                <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">RuntimeException</span>(e);            &#125;            <span class="comment">// 解锁</span>            lock.unlock();        &#125;, <span class="string">&quot;t1&quot;</span>).start();        <span class="comment">// 程序暂停1秒， 保证t1先拿到锁</span>        TimeUnit.SECONDS.sleep(<span class="number">1</span>);        <span class="keyword">new</span> <span class="title class_">Thread</span>(() -&gt; &#123;            lock.lock();            lock.unlock();        &#125;, <span class="string">&quot;t2&quot;</span>).start();    &#125;&#125;</code></pre><p>运行结果：</p><pre><code class="highlight shell">t1获取锁成功t1解锁成功t2获取锁成功t2解锁成功</code></pre><p>结果：t1先拿到了锁，将 atomicReference 设置成自己，t2 再去获取锁的时候就会获取失败，然后在 while 中自旋， 等待 t1 释放锁后，t2才能获取到锁继续执行。</p><h1 id="六、CAS缺点"><a href="#六、CAS缺点" class="headerlink" title="六、CAS缺点"></a>六、CAS缺点</h1><h2 id="1-时间开销大"><a href="#1-时间开销大" class="headerlink" title="1. 时间开销大"></a>1. 时间开销大</h2><p>循环时间长开销很大。</p><p>我们可以看到 <code>getAndAddInt</code> 方法执行时，有个 <code>do while</code></p><p><img src="https://raw.githubusercontent.com/GeorgeChan95/blogimg/master/img/2024/09/27/20240927-194243.png" alt="do while"></p><p>如果CAS失败，会一直进行尝试。如果CAS长时间一直不成功，可能会给CPU带来很大的开销。</p><h2 id="2-ABA问题"><a href="#2-ABA问题" class="headerlink" title="2. ABA问题"></a>2. ABA问题</h2><p>CAS会导致“ABA问题”。</p><p>CAS算法实现一个重要前提需要取出内存中某时刻的数据并在当下时刻比较并替换，那么在这个时间差类会导致数据的变化。</p><p>比如说一个<strong>线程t1</strong>从内存位置V中取出A，这时候另一个<strong>线程t2</strong>也从内存中取出A，并且<strong>线程t2</strong>进行了一些操作将值变成了B，<br>然后<strong>线程t2</strong>又将V位置的数据变成A，这时候<strong>线程t1</strong>进行CAS操作发现内存中仍然是A，然后<strong>线程t1</strong>操作成功。</p><pre><code class="highlight java"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">abaProblem</span><span class="params">()</span> &#123;    <span class="keyword">new</span> <span class="title class_">Thread</span>(() -&gt; &#123;        atomicInteger.compareAndSet(<span class="number">100</span>, <span class="number">101</span>);        atomicInteger.compareAndSet(<span class="number">101</span>, <span class="number">100</span>);    &#125;, <span class="string">&quot;t1&quot;</span>).start();    <span class="comment">//暂停毫秒</span>    <span class="keyword">try</span> &#123;        TimeUnit.MILLISECONDS.sleep(<span class="number">10</span>);    &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;        e.printStackTrace();    &#125;    <span class="keyword">new</span> <span class="title class_">Thread</span>(() -&gt; &#123;        <span class="type">boolean</span> <span class="variable">b</span> <span class="operator">=</span> atomicInteger.compareAndSet(<span class="number">100</span>, <span class="number">20210308</span>);        System.out.println(Thread.currentThread().getName() + <span class="string">&quot;\t&quot;</span> + <span class="string">&quot;修改成功否：&quot;</span> + b + <span class="string">&quot;\t&quot;</span> + atomicInteger.get());    &#125;, <span class="string">&quot;t2&quot;</span>).start();&#125;</code></pre><p>尽管<strong>线程t1</strong>的CAS操作成功，但是不代表这个过程就是没有问题的。</p><p><strong>解决方式：</strong>使用 <code>AtomicStampedReference</code>， 带有版本号的原子操作类。</p><pre><code class="highlight java"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ABATest</span> &#123;    <span class="comment">// 初始值：100   初始版本号：1</span>    <span class="keyword">static</span> AtomicStampedReference&lt;Integer&gt; stampedReference = <span class="keyword">new</span> <span class="title class_">AtomicStampedReference</span>&lt;&gt;(<span class="number">100</span>, <span class="number">1</span>);    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;        <span class="keyword">new</span> <span class="title class_">Thread</span>(() -&gt; &#123;            <span class="type">int</span> <span class="variable">stamp</span> <span class="operator">=</span> stampedReference.getStamp();            System.out.println(Thread.currentThread().getName() + <span class="string">&quot; 默认获取到的值：&quot;</span> + stampedReference.getReference() + <span class="string">&quot;\t默认版本号：&quot;</span> + stamp);            <span class="keyword">try</span> &#123;                TimeUnit.SECONDS.sleep(<span class="number">1</span>);            &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;                <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">RuntimeException</span>(e);            &#125;            <span class="comment">// 修改值，将版本号加1</span>            <span class="type">boolean</span> <span class="variable">flag1</span> <span class="operator">=</span> stampedReference.compareAndSet(<span class="number">100</span>, <span class="number">101</span>, stampedReference.getStamp(), stampedReference.getStamp() + <span class="number">1</span>);            System.out.println(Thread.currentThread().getName() + <span class="string">&quot;第一次修改：&quot;</span> + flag1);            <span class="comment">// 修改值，将版本号加1</span>            <span class="type">boolean</span> <span class="variable">flag2</span> <span class="operator">=</span> stampedReference.compareAndSet(<span class="number">101</span>, <span class="number">100</span>, stampedReference.getStamp(), stampedReference.getStamp() + <span class="number">1</span>);            System.out.println(Thread.currentThread().getName() + <span class="string">&quot;第二次修改：&quot;</span> + flag2);            System.out.println(<span class="string">&quot;修改后的值：&quot;</span> + stampedReference.getReference() + <span class="string">&quot;\t版本号：&quot;</span> + stampedReference.getStamp());        &#125;, <span class="string">&quot;t1&quot;</span>).start();        <span class="keyword">new</span> <span class="title class_">Thread</span>(() -&gt; &#123;            <span class="type">int</span> <span class="variable">stamp</span> <span class="operator">=</span> stampedReference.getStamp();            System.out.println(Thread.currentThread().getName() + <span class="string">&quot; 默认获取到的值：&quot;</span> + stampedReference.getReference() + <span class="string">&quot;\t默认版本号：&quot;</span> + stamp);            <span class="keyword">try</span> &#123;                TimeUnit.SECONDS.sleep(<span class="number">3</span>);            &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;                <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">RuntimeException</span>(e);            &#125;            <span class="comment">// 修改值，将版本号加1</span>            <span class="type">boolean</span> <span class="variable">flag</span> <span class="operator">=</span> stampedReference.compareAndSet(<span class="number">100</span>, <span class="number">2024</span>, stamp, stampedReference.getStamp() + <span class="number">1</span>);            System.out.println(Thread.currentThread().getName() + <span class="string">&quot;修改：&quot;</span> + flag);            System.out.println(<span class="string">&quot;修改后的值：&quot;</span> + stampedReference.getReference() + <span class="string">&quot;\t版本号：&quot;</span> + stampedReference.getStamp());        &#125;, <span class="string">&quot;t2&quot;</span>).start();    &#125;&#125;</code></pre><p>运行结果</p><pre><code class="highlight shell">t1 默认获取到的值：100默认版本号：1t2 默认获取到的值：100默认版本号：1t1第一次修改：truet1第二次修改：true修改后的值：100版本号：3t2修改：false修改后的值：100版本号：3</code></pre>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;一、没有CAS之前&quot;&gt;&lt;a href=&quot;#一、没有CAS之前&quot; class=&quot;headerlink&quot; title=&quot;一、没有CAS之前&quot;&gt;&lt;/a&gt;一、没有CAS之前&lt;/h1&gt;&lt;ul&gt;
&lt;li&gt;&lt;p&gt;多线程环境不使用原子类保证线程安全（基本数据类型）&lt;/p&gt;
&lt;pr</summary>
      
    
    
    
    <category term="JUC" scheme="https://georgechan95.github.io/categories/JUC/"/>
    
    
    <category term="juc" scheme="https://georgechan95.github.io/tags/juc/"/>
    
    <category term="java" scheme="https://georgechan95.github.io/tags/java/"/>
    
  </entry>
  
  <entry>
    <title>06-JUC进阶-Volatile与Java内存模型</title>
    <link href="https://georgechan95.github.io/blog/546d628d.html"/>
    <id>https://georgechan95.github.io/blog/546d628d.html</id>
    <published>2024-09-25T11:01:01.000Z</published>
    <updated>2024-09-26T11:36:37.257Z</updated>
    
    <content type="html"><![CDATA[<h1 id="一、被Volatile修改的变量有2大特点"><a href="#一、被Volatile修改的变量有2大特点" class="headerlink" title="一、被Volatile修改的变量有2大特点"></a>一、被Volatile修改的变量有2大特点</h1><h2 id="1-特点"><a href="#1-特点" class="headerlink" title="1. 特点"></a>1. 特点</h2><ul><li><p>可见性</p><p>写完后立即刷新回主内存并及时发出通知，其它线程可以去主内存拿到最新的数据，前面的修改对后面所有线程可见</p></li><li><p>有序性</p><p>重排序是指编译器和处理器为了优化程序性能而对指令序列进行重新排序的一种手段，有时候会改变程序语句的先后顺序，若不存在数据依赖关系，可以重排序；存在数据依赖关系，禁止重排序；但重排后的指令绝对不能改变原有的串行语义！这点在并发设计中必须要重点考虑！</p></li></ul><p><strong>注意：volatile 修饰的字段，没有原子性</strong></p><h2 id="2-volatile的内存语义"><a href="#2-volatile的内存语义" class="headerlink" title="2. volatile的内存语义"></a>2. volatile的内存语义</h2><ul><li>当写一个volatile变量时，JMM会把该线程对应的本地内存中的共享变量值立即刷新回主内存中</li><li>当读一个volatile变量时，JMM会把该线程对应的本地内存设置为无效，重新回到主内存中读取最新共享变量的值</li><li>所以volatile的写内存语义是直接刷新到主内存中，读的内存语义是直接从主内存中读取</li></ul><p><strong>volatile凭什么可以保证可见性和有序性？</strong></p><p>  内存屏障Memory Barrier</p><h1 id="二、内存屏障"><a href="#二、内存屏障" class="headerlink" title="二、内存屏障"></a>二、内存屏障</h1><h2 id="1-什么是内存屏障"><a href="#1-什么是内存屏障" class="headerlink" title="1. 什么是内存屏障"></a>1. 什么是内存屏障</h2><p>内存屏障（也称内存栅栏，内存栅障，屏障指令等，是一类同步屏障指令，是CPU或编译器在对内存随机访问的操作中的一个同步点，使得此点之前的所有读写操作都执行后才可以开始执行此点之后的操作），避免代码重排序。内存屏障其实就是一种JVM指令，Java内存模型的重排规则会要求Java编译器在生成JVM指令时插入特定的内存屏障指令，通过这些内存屏障指令，volatile实现了Java内存模型中的可见性和有序性，但volatile无法保证原子性。</p><p>内存屏障之前的所有写操作都要回写到主内存，<br>内存屏障之后的所有读操作都能获得内存屏障之前的所有写操作的最新结果(实现了可见性)。</p><p><img src="https://raw.githubusercontent.com/GeorgeChan95/blogimg/master/img/2024/09/25/20240925-191447.png" alt="内存屏障"></p><p>因此重排序时，不允许把内存屏障之后的指令重排序到内存屏障之前。</p><p>一句话：<strong>对一个 volatile 域的写, happens-before 于任意后续对这个 volatile 域的读，也叫写后读。</strong></p><h2 id="2-内存屏障分类"><a href="#2-内存屏障分类" class="headerlink" title="2. 内存屏障分类"></a>2. 内存屏障分类</h2><h3 id="2-1-分类解析"><a href="#2-1-分类解析" class="headerlink" title="2.1 分类解析"></a>2.1 分类解析</h3><p><strong>内存屏障粗分为两种</strong></p><ul><li>读屏障（Load Barrier）：在读指令之前插入读屏障，让工作内存或CPU高速缓存 当中的缓存数据失效，重新回到主内存中获取最新数据。</li><li>写屏障（Store Barrier）：在写指令之后插入写屏障，强制把缓冲区的数据刷回到主内存中。</li></ul><p><strong>内存屏障细分四种：</strong></p><table><thead><tr><th><strong>屏障类型</strong></th><th><strong>指令示例</strong></th><th><strong>说明</strong></th></tr></thead><tbody><tr><td>LoadLoad</td><td>Load1;LoadLoad;Load2</td><td>保证Load1的读取操作在Load2及后续读取操作之前执行</td></tr><tr><td>StoreStore</td><td>Store1;StoreStore;Store2</td><td>在store2及其后的写操作执行前，保证Store1的写操作已经刷新到主内存</td></tr><tr><td>LoadStore</td><td>Load1;LoadStore;Store2</td><td>在Store2及其后的写操作执行前，保证Load1的读操作已经结束</td></tr><tr><td>StoreLoad</td><td>Store1;StoreLoad;Load2</td><td>保证Store1的写操作已经刷新到主内存后，Load2及其后的读操作才能执行</td></tr></tbody></table><h3 id="2-2-源码分析"><a href="#2-2-源码分析" class="headerlink" title="2.2 源码分析"></a>2.2 源码分析</h3><p>IDEA工具里面找 <code>Unsafe.class</code> –&gt; <code>Unsafe.java</code> –&gt; <code>Unsafe.cpp</code> –&gt; <code>OrderAccess.hpp</code> –&gt; <code>orderAccess_linux_x86.inline.hpp</code></p><ul><li>Unsafe.class</li></ul><p><img src="https://raw.githubusercontent.com/GeorgeChan95/blogimg/master/img/2024/09/25/20240925-193844.png" alt="Unsafe.class"></p><ul><li>Unsafe.java</li></ul><p><img src="https://raw.githubusercontent.com/GeorgeChan95/blogimg/master/img/2024/09/25/20240925-193745.png" alt="Unsafe.java"></p><ul><li>Unsafe.cpp</li></ul><p><img src="https://raw.githubusercontent.com/GeorgeChan95/blogimg/master/img/2024/09/25/20240925-194019.png" alt="Unsafe.cpp"></p><ul><li>OrderAccess.hpp</li></ul><p><img src="https://raw.githubusercontent.com/GeorgeChan95/blogimg/master/img/2024/09/25/20240925-194034.png" alt="OrderAccess.hpp"></p><ul><li>orderAccess_linux_x86.inline.hpp</li></ul><p><img src="https://raw.githubusercontent.com/GeorgeChan95/blogimg/master/img/2024/09/25/20240925-194058.png" alt="orderAccess_linux_x86.inline.hpp"></p><h2 id="3-volatile-变量规则与插入策略"><a href="#3-volatile-变量规则与插入策略" class="headerlink" title="3. volatile 变量规则与插入策略"></a>3. volatile 变量规则与插入策略</h2><h3 id="3-1-如何保证有序性？"><a href="#3-1-如何保证有序性？" class="headerlink" title="3.1 如何保证有序性？"></a>3.1 如何保证有序性？</h3><p><strong>通过内存屏障禁重排</strong></p><ul><li>重排序有可能影响程序的执行和实现，因此，我们有时候希望JVM不要自动重排序。</li><li>对于编译器的重排序，JMM会根据重排序的规则，禁止特定类型的编译器重排序</li><li>对于处理器的重排序，Java编译器在生成指令序列的适当位置，插入内存屏障指令，来禁止特定类型的处理器排序。</li></ul><h3 id="3-2-happens-before-之-volatile-变量规则"><a href="#3-2-happens-before-之-volatile-变量规则" class="headerlink" title="3.2 happens-before 之 volatile 变量规则"></a>3.2 happens-before 之 volatile 变量规则</h3><p><img src="https://raw.githubusercontent.com/GeorgeChan95/blogimg/master/img/2024/09/25/20240925-192602.png" alt="volatile变量规则"></p><ul><li>当第一个操作为volatile读时，不论第二个操作是什么，都不能重排序。这个操作保证了volatile读之后的操作不会被重排到volatile读之前。</li><li>当第二个操作为volatile写时，不论第一个操作是什么，都不能重排序。这个操作保证了volatile写之前的操作不会被重排到volatile写之后。</li><li>当第一个操作为volatile写时，第二个操作为volatile读时，不能重排。</li></ul><h3 id="3-3-内存屏障插⼊策略"><a href="#3-3-内存屏障插⼊策略" class="headerlink" title="3.3 内存屏障插⼊策略"></a>3.3 内存屏障插⼊策略</h3><p>JMM 就将内存屏障插⼊策略分为 4 种</p><p><strong>读屏障</strong></p><ul><li><p>在每个 volatile 读操作的后⾯插⼊⼀个 LoadLoad 屏障</p><p>LoadLoad屏障用来禁止处理器把上面的volatile读与下面的普通读重排序。</p></li><li><p>在每个 volatile 读操作的后⾯插⼊⼀个 LoadStore 屏障</p><p>LoadStore屏障用来禁止处理器把上面的volatile读与下面的普通写重排序。</p><p><img src="https://raw.githubusercontent.com/GeorgeChan95/blogimg/master/img/2024/09/25/20240925-195529.png" alt="读屏障"></p></li></ul><p><strong>写屏障</strong></p><ul><li><p>在每个 volatile 写操作的前⾯插⼊⼀个 StoreStore 屏障</p><p>StoreStore屏障可以保证在volatile写之前，其前面的所有普通写操作都已经刷新到主内存中。</p></li><li><p>在每个 volatile 写操作的后⾯插⼊⼀个 StoreLoad 屏障</p><p>StoreLoad屏障的作用是避免volatile写与后面可能有的volatile读&#x2F;写操作重排序</p><p><img src="https://raw.githubusercontent.com/GeorgeChan95/blogimg/master/img/2024/09/25/20240925-195658.png" alt="写屏障"></p></li></ul><h1 id="三、volatile特性"><a href="#三、volatile特性" class="headerlink" title="三、volatile特性"></a>三、volatile特性</h1><h2 id="1-保证可见性"><a href="#1-保证可见性" class="headerlink" title="1. 保证可见性"></a>1. 保证可见性</h2><p>保证不同线程对某个变量完成操作后结果及时可见，即该共享变量一旦改变所有线程立即可见</p><h3 id="1-1-代码示例："><a href="#1-1-代码示例：" class="headerlink" title="1.1 代码示例："></a>1.1 代码示例：</h3><pre><code class="highlight java"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">VolatileSeeDemo</span> &#123;<span class="comment">//    static boolean flag = true;       //不加volatile，没有可见性</span>    <span class="keyword">static</span> <span class="keyword">volatile</span> <span class="type">boolean</span> <span class="variable">flag</span> <span class="operator">=</span> <span class="literal">true</span>;       <span class="comment">//加了volatile，保证可见性</span>    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;        <span class="keyword">new</span> <span class="title class_">Thread</span>(() -&gt; &#123;            System.out.println(Thread.currentThread().getName() + <span class="string">&quot;\t&quot;</span> + <span class="string">&quot;---come in&quot;</span>);            <span class="keyword">while</span> (flag) &#123;                <span class="keyword">new</span> <span class="title class_">Integer</span>(<span class="number">308</span>);            &#125;            System.out.println(<span class="string">&quot;t1 over&quot;</span>);        &#125;, <span class="string">&quot;t1&quot;</span>).start();        <span class="keyword">try</span> &#123;            TimeUnit.SECONDS.sleep(<span class="number">1</span>);        &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;            e.printStackTrace();        &#125;        <span class="keyword">new</span> <span class="title class_">Thread</span>(() -&gt; &#123;            flag = <span class="literal">false</span>;        &#125;, <span class="string">&quot;t2&quot;</span>).start();    &#125;&#125;</code></pre><ul><li>不加volatile，没有可见性，程序无法停止</li><li>加了volatile，保证可见性，程序可以停止</li></ul><h3 id="1-2-原理解析"><a href="#1-2-原理解析" class="headerlink" title="1.2 原理解析"></a>1.2 原理解析</h3><p><strong>线程t1中为何看不到被主线程main修改为false的flag的值？</strong></p><p>猜测：</p><ol><li>主线程修改了flag之后没有将其刷新到主内存，所以t1线程看不到。</li><li>主线程将flag刷新到了主内存，但是t1一直读取的是自己工作内存中flag的值，没有去主内存中更新获取flag最新的值。</li></ol><p>诉求：</p><ol><li>线程中修改了工作内存中的副本之后，立即将其刷新到主内存</li><li>工作内存中每次读取共享变量时，都去主内存中重新读取，然后拷贝到工作内存</li></ol><p>使用 <code>volatile</code> 修饰共享变量，就可以达到上面的效果，被 <code>volatile</code> 修改的变量有以下特点：</p><ul><li>线程中读取的时候，每次读取都会去主内存中读取共享变量最新的值，然后将其复制到工作内存</li><li>线程中修改了工作内存中变量的副本，修改之后会立即刷新到主内存</li></ul><h3 id="1-3-volatile变量的读写过程"><a href="#1-3-volatile变量的读写过程" class="headerlink" title="1.3 volatile变量的读写过程"></a>1.3 volatile变量的读写过程</h3><p>Java内存模型中定义的8种工作内存与主内存之间的原子操作</p><p>read(读取)→load(加载)→use(使用)→assign(赋值)→store(存储)→write(写入)→lock(锁定)→unlock(解锁)</p><p><img src="https://raw.githubusercontent.com/GeorgeChan95/blogimg/master/img/2024/09/25/20240925-202607.png" alt="image-20240925202607271"></p><ul><li><p>read: 作用于主内存，将变量的值从主内存传输到工作内存，主内存到工作内存</p></li><li><p>load: 作用于工作内存，将read从主内存传输的变量值放入工作内存变量副本中，即数据加载</p></li><li><p>use: 作用于工作内存，将工作内存变量副本的值传递给执行引擎，每当JVM遇到需要该变量的字节码指令时会执行该操作</p></li><li><p>assign: 作用于工作内存，将从执行引擎接收到的值赋值给工作内存变量，每当JVM遇到一个给变量赋值字节码指令时会执行该操作</p></li><li><p>store: 作用于工作内存，将赋值完毕的工作变量的值写回给主内存</p></li><li><p>write: 作用于主内存，将store传输过来的变量值赋值给主内存中的变量</p><p>由于上述只能保证单条指令的原子性，针对多条指令的组合性原子保证，没有大面积加锁，所以，JVM提供了另外两个原子指令：</p></li><li><p>lock: 作用于主内存，将一个变量标记为一个线程独占的状态，只是写时候加锁，就只是锁了写变量的过程。</p></li><li><p>unlock: 作用于主内存，把一个处于锁定状态的变量释放，然后才能被其他线程占用</p></li></ul><h2 id="2-没有原子性"><a href="#2-没有原子性" class="headerlink" title="2. 没有原子性"></a>2. 没有原子性</h2><p>volatile变量的符合操作不具有原子性</p><ul><li><p>对于voaltile变量具备可见性，<strong>JVM只是保证从主内存加载到线程工作内存的值是最新的</strong>，也仅仅是数据加载时是最新的。但是多线程环境下，“数据计算”和“数据赋值”操作可能多次出现，若数据在加载之后，若主内存volatile修饰变量发生修改之后，线程工作内存的操作将会<strong>作废</strong>去读主内存最新值，<strong>操作出现写丢失问题</strong>。<strong>即各线程私有内存和主内存公共内存中变量不同步</strong>，进而导致数据不一致。由此可见volatile解决的是变量读时的可见性问题，但<strong>无法保证原子性，对于多线程修改主内存共享变量的场景必须加锁同步</strong>。</p><p><img src="https://raw.githubusercontent.com/GeorgeChan95/blogimg/master/img/2024/09/26/20240926-103838.png" alt="image-20240926103741047"></p></li><li><p>至于怎么去理解这个写丢失的问题，就是再将数据读取到本地内存到写回主内存中有三个步骤：数据加载—-&gt;数据计算—-&gt;数据赋值，如果第二个线程在第一个线程读取旧值与写回新值期间读取共享变量的值，那么第二个线程将会与第一个线程一起看到同一个值，并执行自己的操作，<strong>一旦其中一个线程对volatile修饰的变量先行完成操作刷回主内存后，另一个线程会作废自己的操作，然后重新去读取最新的值再进行操作，这样的话，它自身的那一次操作就丢失了</strong>，这就造成了 线程安全失败，因此，这个问题<strong>需要使用synchronized修饰以保证线程安全性</strong>。</p></li></ul><p><strong>读取赋值一个volatile变量的情况</strong></p><p><img src="https://raw.githubusercontent.com/GeorgeChan95/blogimg/master/img/2024/09/26/20240926-104126.png" alt="读取赋值一个volatile变量"></p><p>read-load-use 和 assign-store-write 成为了两个不可分割的原子操作，但是在use和assign之间依然有极小的一段真空期，有可能变量会被其他线程读取，导致写丢失一次。无论在哪一个时间点主内存的变量和任一工作内存的变量的值都是相等的。这个特性就导致了volatile变量不适合参与到依赖当前值的运算，如i &#x3D; i + 1; i++;之类的那么依靠可见性的特点volatile可以用在哪些地方呢？ 通常volatile用做保存某个状态的boolean值or int值。</p><p><strong>结论：volatile变量不适合参与到依赖当前值的运算</strong>，如i++，i&#x3D;i+1之类的，<strong>通常用来保存某个状态的boolean值或者int值</strong>，也正是由于volatile变量只能保证可见性，在不符合以下规则的运算场景中，我们仍然要通过加锁来保证原子性：</p><ul><li><p>运算结果并不依赖变量的当前值，或者能够确保只有单一的线程修改变量的值</p></li><li><p>变量不需要与其他的状态变量共同参与不变约束</p></li></ul><p><strong>volatile不具备原子性的代码示例</strong></p><pre><code class="highlight java"><span class="keyword">class</span> <span class="title class_">MyNumber1</span> &#123;    <span class="keyword">public</span> <span class="keyword">volatile</span> <span class="type">int</span> <span class="variable">num</span> <span class="operator">=</span> <span class="number">0</span>;    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">addNum</span><span class="params">()</span> &#123;        num++;    &#125;&#125;<span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">VolatileDemo</span> &#123;    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> InterruptedException &#123;        <span class="type">MyNumber1</span> <span class="variable">myNumber1</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">MyNumber1</span>();        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; <span class="number">10</span>; i++) &#123;            <span class="keyword">new</span> <span class="title class_">Thread</span>(() -&gt; &#123;                <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> <span class="number">0</span>; j &lt; <span class="number">1000</span>; j++) &#123;                    myNumber1.addNum();                &#125;            &#125;, <span class="string">&quot;t&quot;</span> + i).start();        &#125;        TimeUnit.SECONDS.sleep(<span class="number">3</span>);        System.out.println(<span class="string">&quot;执行结束，num值为：&quot;</span> + myNumber1.num);    &#125;&#125;</code></pre><p>执行结果：</p><pre><code class="highlight shell">执行结束，num值为：9913</code></pre><p>多次执行，结果都接近10000，但是到不了10000，原因在于上面说的，volatile修饰的变量，在多线程并发修改情况下会出现写丢失。</p><p><strong>解决方式：</strong> 给 addNum() 添加 synchronized</p><pre><code class="highlight java"><span class="keyword">public</span> <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title function_">addNum</span><span class="params">()</span> &#123;    num++;&#125;</code></pre><h2 id="3-指令禁重排"><a href="#3-指令禁重排" class="headerlink" title="3. 指令禁重排"></a>3. 指令禁重排</h2><h3 id="3-1-重排序"><a href="#3-1-重排序" class="headerlink" title="3.1 重排序"></a>3.1 重排序</h3><p>重排序是指编译器和处理器为了优化程序性能而对指令序列进行重新排序的一种手段，有时候会改变程序语句的先后顺序</p><ul><li>不存在数据依赖关系，可以重排序；</li><li><strong>存在数据依赖关系，禁止重排序</strong></li></ul><p>但重排后的指令绝对不能改变原有的串行语义！这点在并发设计中必须要重点考虑！</p><h3 id="3-2-重排序的分类和执行流程"><a href="#3-2-重排序的分类和执行流程" class="headerlink" title="3.2 重排序的分类和执行流程"></a>3.2 重排序的分类和执行流程</h3><p><img src="https://raw.githubusercontent.com/GeorgeChan95/blogimg/master/img/2024/09/26/20240926-161621.png" alt="重排序的分类和执行流程"></p><ul><li>编译器优化的重排序：编译器在不改变单线程串行语义的前提下，可以重新调整指令的执行顺序</li><li>指令级并行的重排序：处理器使用指令级并行技术来讲多条指令重叠执行，若不存在数据依赖性，处理器可以改变语句对应机器指令的执行顺序</li><li>内存系统的重排序：由于处理器使用缓存和读&#x2F;写缓冲区，这使得加载和存储操作看上去可能是乱序执行</li></ul><h3 id="3-3-数据依赖性"><a href="#3-3-数据依赖性" class="headerlink" title="3.3 数据依赖性"></a>3.3 数据依赖性</h3><p>若两个操作访问同一变量，且这两个操作中有一个为写操作，此时两操作间就存在数据依赖性。</p><p><strong>案例说明</strong></p><ul><li><p>不存在数据依赖关系，可以重排序</p><table><thead><tr><th>重排前</th><th>重排后</th></tr></thead><tbody><tr><td>int a &#x3D; 1;  &#x2F;&#x2F;1<br/>int b &#x3D; 20; &#x2F;&#x2F;2<br/>int c &#x3D; a + b; &#x2F;&#x2F;3</td><td>int b &#x3D; 20;  &#x2F;&#x2F;1<br/>int a &#x3D; 1; &#x2F;&#x2F;2<br/>int c &#x3D; a + b; &#x2F;&#x2F;3</td></tr><tr><td>结论：编译器调整了语句的顺序，但是不影响程序的最终结果。</td><td><strong>可以重排序</strong></td></tr></tbody></table></li><li><p><strong>存在数据依赖关系，禁止重排序</strong></p><p>重排序发生，会导致程序运行结果不同。编译器和处理器在重排序时，会遵守数据依赖性，不会改变存在依赖关系的两个操作的执行,但不同处理器和不同线程之间的数据性不会被编译器和处理器考虑，其只会作用于单处理器和单线程环境，下面三种情况，只要重排序两个操作的执行顺序，程序的执行结果就会被改变。</p><p><img src="https://raw.githubusercontent.com/GeorgeChan95/blogimg/master/img/2024/09/26/20240926-162829.png" alt="数据依赖"></p></li></ul><h1 id="四、如何正确使用volatile"><a href="#四、如何正确使用volatile" class="headerlink" title="四、如何正确使用volatile"></a>四、如何正确使用volatile</h1><h2 id="1-单一赋值"><a href="#1-单一赋值" class="headerlink" title="1. 单一赋值"></a>1. 单一赋值</h2><p>单一赋值可以，但是含复合运算赋值不可以(i++之类)</p><pre><code class="highlight java"><span class="keyword">volatile</span> <span class="type">int</span> <span class="variable">a</span> <span class="operator">=</span> <span class="number">10</span><span class="keyword">volatile</span> <span class="type">boolean</span> <span class="variable">flag</span> <span class="operator">=</span> <span class="literal">false</span></code></pre><h2 id="2-状态标志"><a href="#2-状态标志" class="headerlink" title="2. 状态标志"></a>2. 状态标志</h2><p>判断业务是否结束</p><pre><code class="highlight java"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">VolatileSeeDemo</span> &#123;<span class="comment">//    static boolean flag = true;       //不加volatile，没有可见性</span>    <span class="keyword">static</span> <span class="keyword">volatile</span> <span class="type">boolean</span> <span class="variable">flag</span> <span class="operator">=</span> <span class="literal">true</span>;       <span class="comment">//加了volatile，保证可见性</span>    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;        <span class="keyword">new</span> <span class="title class_">Thread</span>(() -&gt; &#123;            System.out.println(Thread.currentThread().getName() + <span class="string">&quot;\t&quot;</span> + <span class="string">&quot;---come in&quot;</span>);            <span class="keyword">while</span> (flag) &#123;                <span class="keyword">new</span> <span class="title class_">Integer</span>(<span class="number">308</span>);            &#125;            System.out.println(<span class="string">&quot;t1 over&quot;</span>);        &#125;, <span class="string">&quot;t1&quot;</span>).start();        <span class="keyword">try</span> &#123;            TimeUnit.SECONDS.sleep(<span class="number">1</span>);        &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;            e.printStackTrace();        &#125;        <span class="keyword">new</span> <span class="title class_">Thread</span>(() -&gt; &#123;            flag = <span class="literal">false</span>;        &#125;, <span class="string">&quot;t2&quot;</span>).start();    &#125;&#125;</code></pre><h2 id="3-开销较低的读，写锁策略"><a href="#3-开销较低的读，写锁策略" class="headerlink" title="3. 开销较低的读，写锁策略"></a>3. 开销较低的读，写锁策略</h2><pre><code class="highlight java"><span class="keyword">class</span> <span class="title class_">MyNumber1</span> &#123;    <span class="keyword">public</span> <span class="keyword">volatile</span> <span class="type">int</span> <span class="variable">num</span> <span class="operator">=</span> <span class="number">0</span>;    <span class="keyword">public</span> <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title function_">addNum</span><span class="params">()</span> &#123;        num++;    &#125;&#125;<span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">VolatileDemo</span> &#123;    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> InterruptedException &#123;        <span class="type">MyNumber1</span> <span class="variable">myNumber1</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">MyNumber1</span>();        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; <span class="number">10</span>; i++) &#123;            <span class="keyword">new</span> <span class="title class_">Thread</span>(() -&gt; &#123;                <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> <span class="number">0</span>; j &lt; <span class="number">1000</span>; j++) &#123;                    myNumber1.addNum();                &#125;            &#125;, <span class="string">&quot;t&quot;</span> + i).start();        &#125;        TimeUnit.SECONDS.sleep(<span class="number">3</span>);        System.out.println(<span class="string">&quot;执行结束，num值为：&quot;</span> + myNumber1.num);    &#125;&#125;</code></pre><h2 id="4-DCL双端锁的发布"><a href="#4-DCL双端锁的发布" class="headerlink" title="4. DCL双端锁的发布"></a>4. DCL双端锁的发布</h2><h3 id="4-1-问题代码示例"><a href="#4-1-问题代码示例" class="headerlink" title="4.1 问题代码示例"></a>4.1 问题代码示例</h3><pre><code class="highlight java"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">SafeDoubleCheckSingleton</span> &#123;    <span class="comment">// 加 volatile 保证了对象的可见性</span>    <span class="comment">//    private volatile static SafeDoubleCheckSingleton singleton = null;</span>    <span class="comment">// 不加 volatile 在多线程环境下可能导致获取到的对象是null</span>    <span class="keyword">private</span> <span class="keyword">static</span> <span class="type">SafeDoubleCheckSingleton</span> <span class="variable">singleton</span> <span class="operator">=</span> <span class="literal">null</span>;    <span class="comment">//私有化构造方法</span>    <span class="keyword">private</span> <span class="title function_">SafeDoubleCheckSingleton</span><span class="params">()</span> &#123;    &#125;    <span class="comment">//双重锁设计</span>    <span class="keyword">public</span> <span class="keyword">static</span> SafeDoubleCheckSingleton <span class="title function_">getInstance</span><span class="params">()</span> &#123;        <span class="keyword">if</span> (singleton == <span class="literal">null</span>) &#123;            <span class="comment">//1.多线程并发创建对象时，会通过加锁保证只有一个线程能创建对象</span>            <span class="keyword">synchronized</span> (SafeDoubleCheckSingleton.class) &#123;                <span class="keyword">if</span> (singleton == <span class="literal">null</span>) &#123;                    <span class="comment">//隐患：多线程环境下，由于重排序，该对象可能还未完成初始化就被其他线程读取</span>                    singleton = <span class="keyword">new</span> <span class="title class_">SafeDoubleCheckSingleton</span>();                &#125;            &#125;        &#125;        <span class="comment">//2.对象创建完毕，执行getInstance()将不需要获取锁，直接返回创建对象</span>        <span class="keyword">return</span> singleton;    &#125;    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;        <span class="type">SafeDoubleCheckSingleton</span> <span class="variable">instance</span> <span class="operator">=</span> SafeDoubleCheckSingleton.getInstance();    &#125;&#125;</code></pre><h3 id="4-2-问题如下"><a href="#4-2-问题如下" class="headerlink" title="4.2 问题如下"></a>4.2 问题如下</h3><ul><li><p>单线程环境下：(或者说正常情况下)，在”问题代码处”，会执行如下操作，保证能获取到已完成初始化的实例</p><p><img src="https://raw.githubusercontent.com/GeorgeChan95/blogimg/master/img/2024/09/26/20240926-172219.png" alt="单线程环境下指令执行逻辑"></p><p>由于代码从编译到执行的过程中，可能会出现指令重排，2、3 两处的指令执行顺序可能会颠倒，这就有可能导致返回的对象，还未执行初始化。</p></li><li><p>多线程环境下：在”问题代码处”，会执行如下操作，由于重排序导致2,3乱序，后果就是其他线程得到的是null而不是完成初始化的对象</p><p>正确的执行顺序</p><p><img src="https://raw.githubusercontent.com/GeorgeChan95/blogimg/master/img/2024/09/26/20240926-172545.png" alt="指令顺序-正确"></p><p>异常的执行顺序</p><p><img src="https://raw.githubusercontent.com/GeorgeChan95/blogimg/master/img/2024/09/26/20240926-172531.png" alt="指令顺序-异常"></p></li></ul><h3 id="4-3-问题解决"><a href="#4-3-问题解决" class="headerlink" title="4.3 问题解决"></a>4.3 问题解决</h3><h4 id="4-3-1-方式一：加volatile修饰"><a href="#4-3-1-方式一：加volatile修饰" class="headerlink" title="4.3.1 方式一：加volatile修饰"></a>4.3.1 方式一：加volatile修饰</h4><p><strong>原理:利用volatile，禁止 “初始化对象”(2) 和 “设置singleton指向内存空间”(3) 的重排序</strong></p><pre><code class="highlight java"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">SafeDoubleCheckSingleton</span> &#123;    <span class="comment">// 加 volatile 保证了对象的可见性，实现线程安全的延迟初始化。</span>    <span class="keyword">private</span> <span class="keyword">volatile</span> <span class="keyword">static</span> <span class="type">SafeDoubleCheckSingleton</span> <span class="variable">singleton</span> <span class="operator">=</span> <span class="literal">null</span>;    <span class="comment">//私有化构造方法</span>    <span class="keyword">private</span> <span class="title function_">SafeDoubleCheckSingleton</span><span class="params">()</span> &#123;    &#125;    <span class="comment">//双重锁设计</span>    <span class="keyword">public</span> <span class="keyword">static</span> SafeDoubleCheckSingleton <span class="title function_">getInstance</span><span class="params">()</span> &#123;        <span class="keyword">if</span> (singleton == <span class="literal">null</span>) &#123;            <span class="comment">//1.多线程并发创建对象时，会通过加锁保证只有一个线程能创建对象</span>            <span class="keyword">synchronized</span> (SafeDoubleCheckSingleton.class) &#123;                <span class="keyword">if</span> (singleton == <span class="literal">null</span>) &#123;                    <span class="comment">//隐患：多线程环境下，由于重排序，该对象可能还未完成初始化就被其他线程读取</span>                    singleton = <span class="keyword">new</span> <span class="title class_">SafeDoubleCheckSingleton</span>();                &#125;            &#125;        &#125;        <span class="comment">//2.对象创建完毕，执行getInstance()将不需要获取锁，直接返回创建对象</span>        <span class="keyword">return</span> singleton;    &#125;    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;        <span class="type">SafeDoubleCheckSingleton</span> <span class="variable">instance</span> <span class="operator">=</span> SafeDoubleCheckSingleton.getInstance();    &#125;&#125;</code></pre><h4 id="4-3-2-方式二：采用静态内部类的方式实现"><a href="#4-3-2-方式二：采用静态内部类的方式实现" class="headerlink" title="4.3.2 方式二：采用静态内部类的方式实现"></a>4.3.2 方式二：采用静态内部类的方式实现</h4><pre><code class="highlight java"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">SingletonDemo</span> &#123;    <span class="keyword">private</span> <span class="title function_">SingletonDemo</span><span class="params">()</span> &#123;    &#125;    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">class</span> <span class="title class_">SingletonDemoHandler</span> &#123;        <span class="keyword">private</span> <span class="keyword">static</span> <span class="type">SingletonDemo</span> <span class="variable">instance</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">SingletonDemo</span>();    &#125;    <span class="keyword">public</span> <span class="keyword">static</span> SingletonDemo <span class="title function_">getInstance</span><span class="params">()</span> &#123;        <span class="keyword">return</span> SingletonDemoHandler.instance;    &#125;&#125;</code></pre><h1 id="五、总结"><a href="#五、总结" class="headerlink" title="五、总结"></a>五、总结</h1><p>凭什么我们java写了一个volatile关键字系统底层加入内存屏障？两者关系怎么勾搭上的?</p><ul><li><p>字节码层面</p><p>它其实给 volatile 修饰的字段添加了一个 <code>ACC_VOLATILE</code> 标识</p><p>查看命令：<code>javap -v -p SafeDoubleCheckSingleton.class</code></p><p><img src="https://raw.githubusercontent.com/GeorgeChan95/blogimg/master/img/2024/09/26/20240926-180150.png" alt="image-20240926180150159"></p></li></ul><p>JVM 在把字节码 生成 为 机器码 的时候，发现操作是 volatile 的变量的话，就会根据 JMM 要求，在相应的位置去插入 内存屏障指令</p><p><strong>对比 java.util.concurrent.locks.Lock 来理解</strong></p><p>cpu执行机器码指令的时候，是使用lock前缀指令 来实现 volatile 的功能的。</p><p>Lock 指令，相当于内存屏障，功能也类似内存屏障的功能:</p><ul><li>首先对总线&#x2F;缓存加锁，然后去执行后面的指令，最后，释放锁，同时把高速缓存的数据刷新回到主内存</li><li>在 lock 锁住总线&#x2F;缓存的时候，其它 cpu 的读写请求就会被阻塞，直到锁释放。Lock过后的写操作,会让其它cpu的高速缓存中相应的数据失效这样后续这些 cpu 在读取数据的时候，就会从主内存去加载最新的数据</li></ul><p>加了 Lock 指令过后的具体表现，就跟 JMM 添加内存屏障后一样。</p><p><strong>一句话总结</strong></p><ul><li>volatile写之前的的操作，都禁止重排到volatile之后</li><li>volatile读之后的操作，都禁止重排到volatile之前</li><li>volatile写之后volatile读，禁止重排序</li></ul>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;一、被Volatile修改的变量有2大特点&quot;&gt;&lt;a href=&quot;#一、被Volatile修改的变量有2大特点&quot; class=&quot;headerlink&quot; title=&quot;一、被Volatile修改的变量有2大特点&quot;&gt;&lt;/a&gt;一、被Volatile修改的变量有2大特点&lt;/</summary>
      
    
    
    
    <category term="JUC" scheme="https://georgechan95.github.io/categories/JUC/"/>
    
    
    <category term="juc" scheme="https://georgechan95.github.io/tags/juc/"/>
    
    <category term="java" scheme="https://georgechan95.github.io/tags/java/"/>
    
  </entry>
  
  <entry>
    <title>05-JUC进阶-Java内存模型-JMM</title>
    <link href="https://georgechan95.github.io/blog/1f2e0014.html"/>
    <id>https://georgechan95.github.io/blog/1f2e0014.html</id>
    <published>2024-09-23T15:01:07.000Z</published>
    <updated>2024-09-25T05:09:23.536Z</updated>
    
    <content type="html"><![CDATA[<h1 id="一、计算机硬件存储体系"><a href="#一、计算机硬件存储体系" class="headerlink" title="一、计算机硬件存储体系"></a>一、计算机硬件存储体系</h1><p> 计算机存储结构，从本地磁盘 到 主内存 到 CPU缓存，也就是从硬盘 -&gt; 内存 -&gt; CPU。</p><p>一般对应的程序的操作就是从数据库查数据到内存然后到CPU进行计算</p><p><img src="https://raw.githubusercontent.com/GeorgeChan95/blogimg/master/img/2024/09/23/20240923-162409.png" alt="计算机硬件存储体系"></p><p>由于CPU和物理主内存的速度不一致（CPU速度远快于主内存），因此CPU和主内存之间需要多级缓存。</p><p>CPU的运行并不是直接操作内存而是先把内存里边的数据读到缓存，而内存的读和写操作的时候就会造成不一致的问题。</p><p><img src="https://raw.githubusercontent.com/GeorgeChan95/blogimg/master/img/2024/09/23/20240923-162728.png" alt="CPU-缓存-内存"></p><p>Java虚拟机规范中试图定义一种Java内存模型（java Memory Model，简称JMM) 来屏蔽掉各种硬件和操作系统的内存访问差异，以实现让Java程序在各种平台下都能达到一致的内存访问效果。</p><h1 id="二、Java内存模型-JMM"><a href="#二、Java内存模型-JMM" class="headerlink" title="二、Java内存模型-JMM"></a>二、Java内存模型-JMM</h1><h2 id="1-JMM概述"><a href="#1-JMM概述" class="headerlink" title="1. JMM概述"></a>1. JMM概述</h2><p>JMM(Java内存模型Java Memory Model，简称JMM)本身是一种抽象的概念并不真实存在<strong>它仅仅描述的是一组约定或规范</strong>，通过这组规范定义了程序中(尤其是多线程)各个变量的读写访问方式并决定一个线程对共享变量的写入何时以及如何变成对另一个线程可见，<strong>关键技术点都是围绕多线程的原子性、可见性和有序性展开的</strong>。</p><h2 id="2-JMM的作用"><a href="#2-JMM的作用" class="headerlink" title="2. JMM的作用"></a>2. JMM的作用</h2><ul><li>通过JMM来实现线程和主内存之间的抽象关系</li><li>屏蔽各个硬件平台和操作系统的内存访问差异以实现让Java程序在各种平台下都能达到一致的内存访问效果。</li></ul><h2 id="3-JMM规范下，三大特性"><a href="#3-JMM规范下，三大特性" class="headerlink" title="3. JMM规范下，三大特性"></a>3. JMM规范下，三大特性</h2><ul><li><p>可见性</p></li><li><p>原子性</p></li><li><p>有序性</p></li></ul><h3 id="3-1-可见性"><a href="#3-1-可见性" class="headerlink" title="3.1 可见性"></a>3.1 可见性</h3><p>是指当一个线程修改了某一个共享变量的值，其他线程是否能够立即知道该变更 ，JMM规定了所有的变量都存储在主内存中。</p><p><img src="https://raw.githubusercontent.com/GeorgeChan95/blogimg/master/img/2024/09/23/20240923-165016.png" alt="CPU-缓存-主存"></p><p><img src="https://raw.githubusercontent.com/GeorgeChan95/blogimg/master/img/2024/09/23/20240923-165023.png" alt="多线程修改同一个变量"></p><p><strong>Java中普通的共享变量不保证可见性</strong>，因为数据修改被写入内存的时机是不确定的，多线程并发下很可能出现**”脏读”<strong>，所以每个线程都有自己的</strong>工作内存<strong>，线程自己的工作内存中保存了该线程使用到的变量的</strong>主内存副本拷贝**，线程对变量的所有操作（读取，赋值等 ）都必需在线程自己的工作内存中进行，而不能够直接读写主内存中的变量。不同线程之间也无法直接访问对方工作内存中的变量，线程间变量值的传递均需要通过主内存来完成</p><p><img src="https://raw.githubusercontent.com/GeorgeChan95/blogimg/master/img/2024/09/23/20240923-164824.png" alt="线程-主存-工作内存的关系"></p><p> <strong>线程脏读：如果没有可见性保证</strong></p><ul><li>主内存中有变量 x，初始值为 0</li><li>线程 A 要将 x 加 1，先将 x&#x3D;0 拷贝到自己的私有内存中，然后更新 x 的值</li><li>线程 A 将更新后的 x 值回刷到主内存的时间是不固定的</li><li>刚好在线程 A 没有回刷 x 到主内存时，线程 B 同样从主内存中读取 x，此时为 0，和线程 A 一样的操作，最后期盼的 x&#x3D;2 就会变成 x&#x3D;1</li></ul><p><img src="https://raw.githubusercontent.com/GeorgeChan95/blogimg/master/img/2024/09/23/20240923-170757.png" alt="线程脏读"></p><h3 id="3-2-原子性"><a href="#3-2-原子性" class="headerlink" title="3.2 原子性"></a>3.2 原子性</h3><p>指一个操作是不可被打断的，即多线程环境下，操作不能被其他线程干扰</p><h3 id="3-3-有序性"><a href="#3-3-有序性" class="headerlink" title="3.3. 有序性"></a>3.3. 有序性</h3><p>对于一个线程的执行代码而言，我们总是习惯性地认为代码的执行总是从上到下，有序执行。但为了提升性能，编译器和处理器通常会对指令序列进行重新排序。Java规范规定JVM线程内部维持顺序化语义，即只要程序的最终结果与它顺序化执行的结果相等，那么指令的执行顺序可以与代码顺序不一致，此过程叫指令的重排序。</p><p>  <strong>优缺点：</strong></p><ul><li>JVM能根据处理器特性（CPU多级缓存系统、多核处理器等）适当的对机器指令进行重排序，使机器指令更符合CPU的执行特性，最大限度的发挥机器性能</li><li>​    但是指令重排可以保证串行语义一致，<strong>但没有义务保证多线程的语义也一致（即可能产生“脏读”）</strong>，简单而言就是两行以上不相干的代码在执行的时候有可能先执行的不是第一条，不见得是从上到下顺序执行，执行顺序会被优化。</li></ul><p>从源码到最终执行示例图</p><p><img src="https://raw.githubusercontent.com/GeorgeChan95/blogimg/master/img/2024/09/23/20240923-171944.png" alt="原码编译到执行"></p><ul><li><p>单线程环境里面确保程序最终执行结果和代码顺序执行的结果一致。处理器在进行重排序时必须要考虑指令之间的数据依赖性。</p></li><li><p>多线程环境中线程交替执行,由于编译器优化重排的存在，两个线程中使用的变量能否保证一致性是无法确定的,结果无法预测</p></li></ul><h1 id="三、JMM规范下，多线程对变量的读写过程"><a href="#三、JMM规范下，多线程对变量的读写过程" class="headerlink" title="三、JMM规范下，多线程对变量的读写过程"></a>三、JMM规范下，多线程对变量的读写过程</h1><p><strong>读取过程</strong></p><p>由于JVM运行程序的实体是线程，而每个线程创建时JVM都会为其创建一个工作内存(有些地方称为栈空间)，工作内存是每个线程的私有数据区域，而Java内存模型中规定所有变量都存储在<strong>主内存</strong>，主内存是共享内存区域，所有线程都可以访问，但<strong>线程对变量的操作(读取赋值等)必须在工作内存中进行，首先要将变量从主内存拷贝到的线程自己的工作内存空间，然后对变量进行操作，操作完成后再将变量写回主内存</strong>，不能直接操作主内存中的变量，各个线程中的工作内存中存储着主内存中的变量副本拷贝，因此不同的线程间无法访问对方的工作内存，线程间的通信(传值)必须通过主内存来完成，其简要访问过程如下图:</p><p><img src="https://raw.githubusercontent.com/GeorgeChan95/blogimg/master/img/2024/09/23/20240923-172630.png" alt="多线程操作主内存变量"></p><p><strong>JMM定义了线程和主内存之间的抽象关系：</strong></p><ul><li>线程之间的共享变量存储在主内存中（从硬件角度讲就是内存条）</li><li>每个线程都有一个自己的本地工作内存，本地工作内存中存储了该线程用来读写共享变量的副本（从硬件角度来说就是CPU的缓存）</li></ul><p><strong>总结</strong></p><ul><li>我们定义的所有共享变量都储存在<strong>物理主内存中</strong></li><li>每个线程都有自己独立的工作内存，里面保证该线程使用到的共享变量的副本（主内存中该变量的一份拷贝）</li><li>线程对共享变量所有的操作都必须先在线程自己的工作内存中进行后写回主内存，不能直接从主内存在读写（不能越级）</li><li>不同线程之间也无法直接访问其他线程的工作内存中的变量，线程间变量值的传递需要通过主内存来进行（同级不能互相访问）。</li></ul><h1 id="四、JMM规范下，多线程先行发生原则之happens-before"><a href="#四、JMM规范下，多线程先行发生原则之happens-before" class="headerlink" title="四、JMM规范下，多线程先行发生原则之happens-before"></a>四、JMM规范下，多线程先行发生原则之happens-before</h1><p>在JVM中，如果一个操作执行的结果需要对另一个操作可见或者代码重排序，那么这两个操作之间必须存在 happens-before（先行发生）原则，逻辑上的先后关系。</p><h2 id="1-x-、y案例说明"><a href="#1-x-、y案例说明" class="headerlink" title="1. x 、y案例说明"></a>1. x 、y案例说明</h2><ul><li>x&#x3D;5;线程A执行</li><li>y&#x3D;x;线程B执行</li><li>问：y一定等于5吗？</li></ul><p><strong>答案：不一定</strong></p><p>如果线程A的操作（x&#x3D; 5）happens-before(先行发生)线程B的操作（y &#x3D; x）,那么可以确定线程B执行后y &#x3D; 5 一定成立;</p><p>如果他们不存在happens-before原则，那么y &#x3D; 5 不一定成立。</p><p><strong>这就是happens-before原则的为例———–&gt;包含可见性和有序性的约束</strong></p><h2 id="2-先行并发原则说明"><a href="#2-先行并发原则说明" class="headerlink" title="2. 先行并发原则说明"></a>2. 先行并发原则说明</h2><p>如果Java内存模型中所有的有序性都仅靠 <code>volatile</code> 和 <code>synchronized</code> 来完成，那么有很多操作都将变得非常罗嗦，但是我们在编写Java并发代码的时候并没有察觉到这一点。</p><p>我们没有时时、处处、次次，添加volatile和synchronized来完成程序，这是因为Java语言中JMM原则下，有一个“先行发生”（happens-before）的原则限制和规矩，给你理好了规矩！</p><p>这个原则非常重要：它是判断数据是否存在竞争，线程是否安全的非常有用的手段。依赖这个原则，我们可以通过几条简单规则解决并发环境下两个操作之间是否可能存在冲突的所有问题，而不需要陷入Java内存模型晦涩难懂的底层编译原理之中。</p><h2 id="3-happens-before总原则"><a href="#3-happens-before总原则" class="headerlink" title="3. happens-before总原则"></a>3. happens-before总原则</h2><ul><li>如果一个操作happens-before另一个操作，那么第一个操作的执行结果将对第二个操作可见，而且第一个操作的执行顺序排在第二个操作之前</li><li>如果两个操作之间存在happens-before关系，并不意味着一定要按照happens-before原则制定的顺序来执行。如果重排之后的执行结果与按照happens-before关系来执行的结果一致，那么这种重排序并不非法。</li></ul><h2 id="4-happens-before之8条规则"><a href="#4-happens-before之8条规则" class="headerlink" title="4. happens-before之8条规则"></a>4. happens-before之8条规则</h2><p>从JDK 5开始，Java使用新的JSR-133内存模型，提供了 happens-before 原则来辅助保证程序执行的原子性、可见性以及有序性的问题，它是判断数据是否存在竞争、线程是否安全的依据，happens-before 原则内容如下：</p><ol><li><p>次序规则：一个线程内，按照代码的顺序，写在前面的操作先行发生于写在后面的操作，也就是说前一个操作的结果可以被后续的操作获取（保证语义串行性，按照代码顺序执行）。比如前一个操作把变量x赋值为1，那后面一个操作肯定能知道x已经变成了1</p></li><li><p>锁定规则：一个 <code>unLock</code> 操作先行发生于后面对同一个锁的<code>lock</code>操作（后面指时间上的先后）</p><p>​解释：A线程的 unlock 操作，先行发生于 B线程的 lock 操作。</p></li><li><p>volatile变量规则：对一个volatile变量的写操作先行发生于后面对这个变量的读操作，前面的写对后面的读是可见的，这里的后面同样指时间上的先后</p></li><li><p>传递规则：如果操作A先行发生于操作B，而操作B又先行发生于操作C，则可以得出操作A先行发生于操作C。</p></li><li><p>线程启动规则（Thread start Rule）：Thread对象的start()方法先行发生于此线程的每一个动作</p></li><li><p>线程中断规则（Thread Interruption Rule）：</p><ol><li>对线程interrupt()方法的调用先行发生于被中断线程的代码检测到中断事件的发生</li><li>可以通过Thread.interrupted()检测到是否发生中断</li><li>也就是说你要先调用interrupt()方法设置过中断标志位，我才能检测到中断发生</li></ol><p>解释：这里其实都是重排序问题，如果没有的此规则就变成了你写的前面设置终止状态，判断结果理应是true，但指令重排序有可能给你改成先判断结果就是false了</p></li><li><p>线程终止规则（Thread Termination Rule）：线程中的所有操作都优先发生于对此线程的终止检测，我们可以通过isAlive()等手段检测线程是否已经终止执行。</p></li><li><p>对象终结规则（Finalizer Rule）：一个对象的初始化完成（构造函数执行结束）先行发生于它的finalize(）方法的开始——-&gt;对象没有完成初始化之前，是不能调用finalized()方法的</p></li></ol><h2 id="5-happens-before-总结"><a href="#5-happens-before-总结" class="headerlink" title="5. happens-before 总结"></a>5. happens-before 总结</h2><ul><li>在Java语言里面，Happens-before 的语义本质上是一种可见性</li><li>A happens-before B ,意味着A发生过的事情对B而言是可见的，无论A事件和B事件是否发生在同一线程里</li><li>JVM的设计分为两部分：<ul><li>一部分是面向我们程序员提供的，也就是happens-before规则，它通俗易懂的向我们程序员阐述了一个强内存模型，我们只要理解happens-before规则，就可以编写并发安全的程序了</li><li>另一部分是针对JVM实现的，为了尽可能少的对编译器和处理器做约束从而提升性能，JMM在不影响程序执行结果的前提下对其不做要求，即允许优化重排序，我们只要关注前者就好了，也就是理解happens-before规则即可，其他繁杂的内容由JMM规范结合操作系统给我们搞定，我们只写好代码即可。</li></ul></li></ul><h2 id="6-案例说明"><a href="#6-案例说明" class="headerlink" title="6. 案例说明"></a>6. 案例说明</h2><pre><code class="highlight java"><span class="keyword">private</span> <span class="type">int</span> <span class="variable">value</span> <span class="operator">=</span><span class="number">0</span>;<span class="keyword">public</span> <span class="type">int</span> <span class="title function_">getValue</span><span class="params">()</span>&#123;    <span class="keyword">return</span> value;&#125;<span class="keyword">public</span> <span class="type">int</span> <span class="title function_">setValue</span><span class="params">()</span>&#123;    <span class="keyword">return</span> ++value;&#125;</code></pre><p>问题描述：假设存在线程A和B，线程A先（时间上的先后）调用了setValue()方法，然后线程B调用了同一个对象的getValue()方法，那么线程B收到的返回值是什么？</p><p><strong>答案：不一定</strong></p><p><strong>分析如下：</strong></p><p>分析happens-before规则（规则5，6，7，8可以忽略，和代码无关）</p><ul><li>由于两个方法由不同线程调用，不满足一个线程的条件，不满足程序次序规则</li><li>两个方法都没有用锁，不满足锁定规则</li><li>变量没有使用volatile修饰，所以不满足volatile变量规则</li><li>传递规则肯定不满足</li></ul><p>综上：无法通过happens-before原则推导出线程A happens-before 线程B，虽然可以确定时间上线程A优于线程B，但就是无法确定线程B获得的结果是什么，所以这段代码不是线程安全的</p><p>注意：如果两个操作的执行次序无法从happens-before原则推导出来，那么就不能保证他们的有序性，虚拟机可以随意对他们进行重排序</p><p><strong>解决方案：</strong></p><ul><li><p>方案一：</p><ul><li><p>把getter&#x2F;setter方法都定义为synchronized方法——-&gt;<strong>不好，重量锁，并发性下降</strong></p><pre><code class="highlight java"><span class="keyword">private</span> <span class="type">int</span> <span class="variable">value</span> <span class="operator">=</span><span class="number">0</span>;<span class="keyword">public</span> <span class="keyword">synchronized</span> <span class="type">int</span> <span class="title function_">getValue</span><span class="params">()</span>&#123;    <span class="keyword">return</span> value;&#125;<span class="keyword">public</span> <span class="keyword">synchronized</span> <span class="type">int</span> <span class="title function_">setValue</span><span class="params">()</span>&#123;    <span class="keyword">return</span> ++value;&#125;</code></pre></li><li><p>把 value 定义为 volatile 变量，由于setter方法对value的修改不依赖value的原值，满足volatile关键字使用场景</p><pre><code class="highlight java"><span class="comment">/**</span><span class="comment">* 利用volatile保证读取操作的可见性，</span><span class="comment">* 利用synchronized保证符合操作的原子性结合使用锁和volatile变量来减少同步的开销</span><span class="comment">*/</span><span class="keyword">private</span> <span class="keyword">volatile</span> <span class="type">int</span> <span class="variable">value</span> <span class="operator">=</span><span class="number">0</span>;<span class="keyword">public</span> <span class="type">int</span> <span class="title function_">getValue</span><span class="params">()</span>&#123;    <span class="keyword">return</span> value;&#125;<span class="keyword">public</span> <span class="keyword">synchronized</span> <span class="type">int</span> <span class="title function_">setValue</span><span class="params">()</span>&#123;    <span class="keyword">return</span> ++value;&#125;</code></pre></li></ul></li></ul>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;一、计算机硬件存储体系&quot;&gt;&lt;a href=&quot;#一、计算机硬件存储体系&quot; class=&quot;headerlink&quot; title=&quot;一、计算机硬件存储体系&quot;&gt;&lt;/a&gt;一、计算机硬件存储体系&lt;/h1&gt;&lt;p&gt; 计算机存储结构，从本地磁盘 到 主内存 到 CPU缓存，也就是从硬</summary>
      
    
    
    
    <category term="JUC" scheme="https://georgechan95.github.io/categories/JUC/"/>
    
    
    <category term="juc" scheme="https://georgechan95.github.io/tags/juc/"/>
    
    <category term="java" scheme="https://georgechan95.github.io/tags/java/"/>
    
  </entry>
  
  <entry>
    <title>04-JUC进阶-LockSupport与线程中断</title>
    <link href="https://georgechan95.github.io/blog/19653fb9.html"/>
    <id>https://georgechan95.github.io/blog/19653fb9.html</id>
    <published>2024-09-23T12:51:50.000Z</published>
    <updated>2024-09-23T08:11:09.507Z</updated>
    
    <content type="html"><![CDATA[<h1 id="一、线程中断机制"><a href="#一、线程中断机制" class="headerlink" title="一、线程中断机制"></a>一、线程中断机制</h1><h2 id="1-什么是中断机制-？"><a href="#1-什么是中断机制-？" class="headerlink" title="1. 什么是中断机制 ？"></a>1. 什么是中断机制 ？</h2><p>首先一个线程不应该由其他线程来强制中断或停止，而是应该由线程自己自行停止。所以，<code>Thread.stop</code> , <code>Thread.suspend</code> , <code>Thread.resume</code> 都已经被废弃了。</p><p>其次在Java中没有办法立即停止一条线程，然而停止线程却显得尤为重要，如取消一个耗时操作。因此，Java提供了一种用于停止线程的机制——中断。</p><p><strong>中断只是一种协作机制，Java没有给中断增加任何语法，中断的过程完全需要程序员自己实现。</strong></p><ul><li>若要中断一个线程，你需要手动调用该线程的interrupt方法，<strong>该方法也仅仅是将线程对象的中断标识设成true</strong>；</li><li>接着你需要自己写代码不断地检测当前线程的标识位，如果为true，表示别的线程要求这条线程中断，</li><li>此时究竟该做什么需要你自己写代码实现。</li><li>每个线程对象中都有一个标识，用于表示线程是否被中断；该标识位为true表示中断，为false表示未中断；</li><li>通过调用线程对象的 <code>interrupt</code> 方法将该线程的标识位设为 true ；可以在别的线程中调用，也可以在自己的线程中调用。</li></ul><h2 id="2-中断的相关API方法"><a href="#2-中断的相关API方法" class="headerlink" title="2. 中断的相关API方法"></a>2. 中断的相关API方法</h2><p><img src="https://raw.githubusercontent.com/GeorgeChan95/blogimg/master/img/2024/09/23/20240923-094444.png" alt="线程中断API"></p><table><thead><tr><th>API</th><th>描述</th></tr></thead><tbody><tr><td>public void interrupt()</td><td>实例方法，<br/>实例方法 <code>interrupt()</code> 仅仅是设置线程的中断状态为true，不会停止线程</td></tr><tr><td><strong>public static boolean interrupted()</strong></td><td><strong>静态方法</strong>，<code>Thread.interrupted();</code>  <br/>判断线程是否被中断，并清除当前中断状态<br/>这个方法做了两件事：<br/>1 返回当前线程的中断状态<br/>2 将当前线程的中断状态设为false<br/> <br/>这个方法有点不好理解，因为连续调用两次的结果可能不一样。</td></tr><tr><td>public boolean isInterrupted()</td><td>实例方法，<br/>判断当前线程是否被中断（通过检查中断标志位）</td></tr></tbody></table><h3 id="2-1-通过一个-volatile-变量实现"><a href="#2-1-通过一个-volatile-变量实现" class="headerlink" title="2.1 通过一个 volatile 变量实现"></a>2.1 通过一个 volatile 变量实现</h3><ul><li>volatile保证了可见性，t2修改了标志位后能马上被t1看到</li></ul><pre><code class="highlight java"><span class="comment">/**</span><span class="comment"> * volatile变量实现线程中断</span><span class="comment"> *</span><span class="comment"> * <span class="doctag">@throws</span> InterruptedException</span><span class="comment"> */</span><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">volatileStopThread</span><span class="params">()</span> <span class="keyword">throws</span> InterruptedException &#123;    <span class="keyword">new</span> <span class="title class_">Thread</span>(() -&gt; &#123;        <span class="keyword">while</span> (!isStop) &#123;            System.out.println(<span class="string">&quot;------- t1 run&quot;</span>);        &#125;        System.out.println(<span class="string">&quot;===== t1 is stop =====&quot;</span>);    &#125;, <span class="string">&quot;t1&quot;</span>).start();    <span class="comment">// 让线程t1运行50毫秒后，中断线程运行</span>    Thread.sleep(<span class="number">10</span>);    <span class="keyword">new</span> <span class="title class_">Thread</span>(() -&gt; &#123;        isStop = <span class="literal">true</span>;        System.out.println(<span class="string">&quot;------- t2 stop: &quot;</span> + isStop);    &#125;, <span class="string">&quot;t2&quot;</span>).start();&#125;</code></pre><h3 id="2-2-通过-AtomicBoolean（原子布尔型）"><a href="#2-2-通过-AtomicBoolean（原子布尔型）" class="headerlink" title="2.2 通过 AtomicBoolean（原子布尔型）"></a>2.2 通过 AtomicBoolean（原子布尔型）</h3><pre><code class="highlight java"><span class="comment">/**</span><span class="comment"> * 通过AtomicBoolean变量实现线程中断</span><span class="comment"> *</span><span class="comment"> * <span class="doctag">@throws</span> InterruptedException</span><span class="comment"> */</span><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">atomicBooleanStopThread</span><span class="params">()</span> <span class="keyword">throws</span> InterruptedException &#123;    <span class="keyword">new</span> <span class="title class_">Thread</span>(() -&gt; &#123;        <span class="keyword">while</span> (!flag.get()) &#123;            System.out.println(<span class="string">&quot;------- t1 run&quot;</span>);        &#125;        System.out.println(<span class="string">&quot;===== t1 is stop =====&quot;</span>);    &#125;, <span class="string">&quot;t1&quot;</span>).start();    <span class="comment">// 让线程t1运行50毫秒后，中断线程运行</span>    Thread.sleep(<span class="number">50</span>);    <span class="keyword">new</span> <span class="title class_">Thread</span>(() -&gt; &#123;        flag.set(<span class="literal">true</span>);        System.out.println(<span class="string">&quot;------- t2 stop: &quot;</span> + flag.get());    &#125;, <span class="string">&quot;t2&quot;</span>).start();&#125;</code></pre><h3 id="2-3-通过Thread类自带的中断api方法实现"><a href="#2-3-通过Thread类自带的中断api方法实现" class="headerlink" title="2.3 通过Thread类自带的中断api方法实现"></a>2.3 通过Thread类自带的中断api方法实现</h3><pre><code class="highlight java"><span class="comment">/**</span><span class="comment"> * 通过Thread类自带的中断api方法实现</span><span class="comment"> *</span><span class="comment"> * <span class="doctag">@throws</span> InterruptedException</span><span class="comment"> */</span><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">threadApiInterruptThread</span><span class="params">()</span> <span class="keyword">throws</span> InterruptedException &#123;    <span class="type">Thread</span> <span class="variable">t1</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Thread</span>(() -&gt; &#123;        <span class="keyword">while</span> (!Thread.currentThread().isInterrupted()) &#123;            System.out.println(<span class="string">&quot;------- t1 run&quot;</span>);        &#125;        System.out.println(<span class="string">&quot;===== t1 is stop =====&quot;</span>);    &#125;, <span class="string">&quot;t1&quot;</span>);    t1.start();    <span class="comment">// 让线程t1运行50毫秒后，中断线程运行</span>    Thread.sleep(<span class="number">50</span>);    <span class="keyword">new</span> <span class="title class_">Thread</span>(() -&gt; &#123;        <span class="comment">// t1线程中断标识设置为true，等待县城自我中断</span>        t1.interrupt();        System.out.println(<span class="string">&quot;------- t2 stop: &quot;</span> + <span class="literal">true</span>);    &#125;, <span class="string">&quot;t2&quot;</span>).start();&#125;</code></pre><h2 id="3-中断API源码分析"><a href="#3-中断API源码分析" class="headerlink" title="3. 中断API源码分析"></a>3. 中断API源码分析</h2><ul><li><strong>实例方法interrupt()，没有返回值</strong></li></ul><pre><code class="highlight java"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">interrupt</span><span class="params">()</span> &#123;    <span class="keyword">if</span> (<span class="built_in">this</span> != Thread.currentThread())        checkAccess();    <span class="keyword">synchronized</span> (blockerLock) &#123;        <span class="type">Interruptible</span> <span class="variable">b</span> <span class="operator">=</span> blocker;        <span class="keyword">if</span> (b != <span class="literal">null</span>) &#123;            interrupt0();           <span class="comment">// Just to set the interrupt flag</span>            b.interrupt(<span class="built_in">this</span>);            <span class="keyword">return</span>;        &#125;    &#125;    interrupt0();&#125;<span class="comment">//Thread.java</span><span class="comment">/* Some private helper methods */</span><span class="keyword">private</span> <span class="keyword">native</span> <span class="keyword">void</span> <span class="title function_">setPriority0</span><span class="params">(<span class="type">int</span> newPriority)</span>;<span class="keyword">private</span> <span class="keyword">native</span> <span class="keyword">void</span> <span class="title function_">stop0</span><span class="params">(Object o)</span>;<span class="keyword">private</span> <span class="keyword">native</span> <span class="keyword">void</span> <span class="title function_">suspend0</span><span class="params">()</span>;<span class="keyword">private</span> <span class="keyword">native</span> <span class="keyword">void</span> <span class="title function_">resume0</span><span class="params">()</span>;<span class="keyword">private</span> <span class="keyword">native</span> <span class="keyword">void</span> <span class="title function_">interrupt0</span><span class="params">()</span>;  <span class="comment">//---------------------------调用了c底层原生方法</span><span class="keyword">private</span> <span class="keyword">native</span> <span class="keyword">void</span> <span class="title function_">setNativeName</span><span class="params">(String name)</span>;</code></pre><ul><li><strong>实例方法 isInterrupted，返回布尔值</strong></li></ul><pre><code class="highlight java"><span class="comment">/**</span><span class="comment"> * Tests whether this thread has been interrupted.  The &lt;i&gt;interrupted</span><span class="comment"> * status&lt;/i&gt; of the thread is unaffected by this method.</span><span class="comment"> *</span><span class="comment"> * &lt;p&gt;A thread interruption ignored because a thread was not alive</span><span class="comment"> * at the time of the interrupt will be reflected by this method</span><span class="comment"> * returning false.</span><span class="comment"> *</span><span class="comment"> * <span class="doctag">@return</span>  &lt;code&gt;true&lt;/code&gt; if this thread has been interrupted;</span><span class="comment"> *          &lt;code&gt;false&lt;/code&gt; otherwise.</span><span class="comment"> * <span class="doctag">@see</span>     #interrupted()</span><span class="comment"> * <span class="doctag">@revised</span> 6.0</span><span class="comment"> */</span><span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">isInterrupted</span><span class="params">()</span> &#123;    <span class="keyword">return</span> isInterrupted(<span class="literal">false</span>);&#125;<span class="comment">//Thread.java</span><span class="keyword">private</span> <span class="keyword">native</span> <span class="type">boolean</span> <span class="title function_">isInterrupted</span><span class="params">(<span class="type">boolean</span> ClearInterrupted)</span>;<span class="comment">//也调用了c底层</span></code></pre><p><strong>中断API相关说明：</strong></p><p>具体来说，当对一个线程，调用 interrupt() 时：</p><ul><li>如果线程处于<strong>正常活动状态</strong>，那么会将该线程的中断标志设置为 true，仅此而已。被设置中断标志的线程将继续正常运行，不受影响。所以， interrupt() 并不能真正的中断线程，需要被调用的线程自己进行配合才行（即：代码自行实现中断逻辑）。</li><li>如果线程处于被阻塞状态（例如处于sleep, wait, join 等状态），在别的线程中调用当前线程对象的interrupt方法，那么线程将立即退出被阻塞状态（中断状态将被清除），并抛出一个InterruptedException异常。（ 关于这一点，<code>interrupt()</code> 方法的注释有明确的说明，）</li><li>中断<strong>不活动的线程</strong>不会产生任何影响，具体看下面案例</li></ul><h3 id="3-1-当前线程的中断标识为true，是不是线程就立刻停止？"><a href="#3-1-当前线程的中断标识为true，是不是线程就立刻停止？" class="headerlink" title="3.1 当前线程的中断标识为true，是不是线程就立刻停止？"></a>3.1 <strong>当前线程的中断标识为true，是不是线程就立刻停止？</strong></h3><p>答案：否， 仅仅设置了一个中断状态为true。</p><pre><code class="highlight java"><span class="comment">/**</span><span class="comment"> * 中断为true后，并不是立刻stop程序</span><span class="comment"> */</span><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">m4</span><span class="params">()</span> &#123;    <span class="comment">//中断为true后，并不是立刻stop程序</span>    <span class="type">Thread</span> <span class="variable">t1</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Thread</span>(() -&gt; &#123;        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">1</span>; i &lt;= <span class="number">800</span>; i++) &#123;            System.out.println(<span class="string">&quot;------i: &quot;</span> + i);        &#125;        System.out.println(<span class="string">&quot;t1.interrupt()调用之后02： &quot;</span> + Thread.currentThread().isInterrupted());    &#125;, <span class="string">&quot;t1&quot;</span>);    t1.start();    System.out.println(<span class="string">&quot;t1.interrupt()调用之前,t1线程的中断标识默认值： &quot;</span> + t1.isInterrupted());    <span class="keyword">try</span> &#123;        TimeUnit.MILLISECONDS.sleep(<span class="number">3</span>);    &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;        e.printStackTrace();    &#125;    <span class="comment">//实例方法interrupt()仅仅是设置线程的中断状态位设置为true，不会停止线程</span>    t1.interrupt();    <span class="comment">//活动状态,t1线程还在执行中</span>    System.out.println(<span class="string">&quot;t1.interrupt()调用之后01： &quot;</span> + t1.isInterrupted());    <span class="keyword">try</span> &#123;        TimeUnit.MILLISECONDS.sleep(<span class="number">3000</span>);    &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;        e.printStackTrace();    &#125;    <span class="comment">//非活动状态,t1线程不在执行中，已经结束执行了, 此时调用 isInterrupted() 方法不起作用，中断状态标识位返回：false</span>    System.out.println(<span class="string">&quot;t1.interrupt()调用之后03： &quot;</span> + t1.isInterrupted());&#125;</code></pre><p>运行结果：</p><pre><code class="highlight shell">t1.interrupt()调用之前,t1线程的中断标识默认值： false------i: 1------i: 2------i: 3......------i: 645t1.interrupt()调用之后01： true // ------此处中断标志位设置为了true,但是t1仍然在运行------i: 646......------i: 798------i: 799------i: 800t1.interrupt()调用之后02： truet1.interrupt()调用之后03： false //中断不活动的线程不会产生任何影响，线程结束后应该是自动变为了false</code></pre><h3 id="3-2-中断异常代码案例："><a href="#3-2-中断异常代码案例：" class="headerlink" title="3.2 中断异常代码案例："></a>3.2 <strong>中断异常代码案例：</strong></h3><p>当线程处于 <code>wait</code> 、<code>join</code> 、<code>sleep</code> 时，此时调用 <code>interrupt()</code> 方法，会触发 <strong>中断异常</strong>， 且会导致程序无限循环. 因为 InterruptedException，将会把中断状态清除。</p><pre><code class="highlight java"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">m5</span><span class="params">()</span> &#123;    <span class="type">Thread</span> <span class="variable">t1</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Thread</span>(() -&gt; &#123;        <span class="keyword">while</span> (<span class="literal">true</span>) &#123;            <span class="keyword">if</span> (Thread.currentThread().isInterrupted()) &#123;                System.out.println(<span class="string">&quot;-----isInterrupted() = true，程序结束。&quot;</span>);                <span class="keyword">break</span>;            &#125;            <span class="keyword">try</span> &#123;                Thread.sleep(<span class="number">500</span>);            &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;<span class="comment">//                    Thread.currentThread().interrupt(); //线程的中断标志位为false,无法停下，需要再次掉interrupt()设置true</span>                e.printStackTrace();            &#125;            System.out.println(<span class="string">&quot;------hello Interrupt&quot;</span>);        &#125;    &#125;, <span class="string">&quot;t1&quot;</span>);    t1.start();    <span class="keyword">try</span> &#123;        TimeUnit.SECONDS.sleep(<span class="number">3</span>);    &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;        e.printStackTrace();    &#125;    <span class="keyword">new</span> <span class="title class_">Thread</span>(() -&gt; &#123;        t1.interrupt();<span class="comment">//修改t1线程的中断标志位为true</span>    &#125;, <span class="string">&quot;t2&quot;</span>).start();&#125;</code></pre><p><strong>运行结果：</strong></p><p>当调用 t1.interrupt(); 时，代码发生了异常，但 t1 依然在运行，没有结束掉</p><pre><code class="highlight shell">------hello Interrupt------hello Interruptjava.lang.InterruptedException: sleep interruptedat java.lang.Thread.sleep(Native Method)at com.atguigu.juc.interrupt.InterruptDemo.lambda$m5$0(InterruptDemo.java:34)at java.lang.Thread.run(Thread.java:748)------hello Interrupt------hello Interrupt------hello Interrupt......</code></pre><p><strong>解决方法：</strong></p><p>在 catch (InterruptedException e)  处添加 <code>Thread.currentThread().interrupt();</code> 发生异常后，再次调用代码执行中断，程序发生异常后依然可以正常结束；</p><pre><code class="highlight shell">------hello Interrupt------hello Interrupt------hello Interrupt------hello Interrupt------hello Interruptjava.lang.InterruptedException: sleep interruptedat java.lang.Thread.sleep(Native Method)at com.atguigu.juc.interrupt.InterruptDemo.lambda$m5$0(InterruptDemo.java:34)at java.lang.Thread.run(Thread.java:748)------hello Interrupt-----isInterrupted() = true，程序结束。</code></pre><h3 id="3-3-对静态方法-Thread-interrupted-的理解"><a href="#3-3-对静态方法-Thread-interrupted-的理解" class="headerlink" title="3.3 对静态方法 Thread.interrupted() 的理解"></a>3.3 对静态方法 Thread.interrupted() 的理解</h3><p><code>public static boolean interrupted()</code> </p><ul><li><p>静态方法，Thread.interrupted(); 判断线程是否被中断，并清除当前中断状态这个方法做了两件事：</p><ul><li>1 返回当前线程的中断状态</li><li>2 将当前线程的中断状态设为false</li></ul><p>注意：此方法连续调用两次的结果可能不一样</p></li></ul><pre><code class="highlight java"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;    System.out.println(Thread.currentThread().getName()+<span class="string">&quot;---&quot;</span>+Thread.interrupted()); <span class="comment">// main---false</span>    System.out.println(Thread.currentThread().getName()+<span class="string">&quot;---&quot;</span>+Thread.interrupted()); <span class="comment">// main---false</span>    System.out.println(<span class="string">&quot;111111&quot;</span>);    Thread.currentThread().interrupt();<span class="comment">///----false---&gt; true</span>    System.out.println(<span class="string">&quot;222222&quot;</span>);    System.out.println(Thread.currentThread().getName()+<span class="string">&quot;---&quot;</span>+Thread.interrupted()); <span class="comment">// main---true</span>    System.out.println(Thread.currentThread().getName()+<span class="string">&quot;---&quot;</span>+Thread.interrupted()); <span class="comment">// main---false</span>&#125;</code></pre><p>运行结果：</p><pre><code class="highlight shell">main---falsemain---false111111222222main---truemain---false</code></pre><p><strong>对比 <code>interrupted()</code> 与 <code>isInterrupted()</code> 源码</strong></p><pre><code class="highlight java"><span class="keyword">public</span> <span class="keyword">static</span> <span class="type">boolean</span> <span class="title function_">interrupted</span><span class="params">()</span> &#123;    <span class="keyword">return</span> currentThread().isInterrupted(<span class="literal">true</span>);&#125;<span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">isInterrupted</span><span class="params">()</span> &#123;    <span class="keyword">return</span> isInterrupted(<span class="literal">false</span>);&#125;<span class="comment">/**</span><span class="comment"> * Tests if some Thread has been interrupted.  The interrupted state</span><span class="comment"> * is reset or not based on the value of ClearInterrupted that is</span><span class="comment"> * passed.</span><span class="comment"> */</span><span class="keyword">private</span> <span class="keyword">native</span> <span class="type">boolean</span> <span class="title function_">isInterrupted</span><span class="params">(<span class="type">boolean</span> ClearInterrupted)</span>;</code></pre><p>他们在底层都调用了native方法 isInterrupted() , 只不过传入参数ClearInterrupted一个传参传了<code>true</code>，一个传了<code>false</code>。</p><ul><li>静态方法<code>interrupted() </code>中<code>true</code>表示清空当前中断状态。</li><li>实例方法<code>isInterrupted</code> 则不会。</li></ul><h2 id="4-总结"><a href="#4-总结" class="headerlink" title="4. 总结"></a>4. 总结</h2><p>线程中断相关的方法：</p><ul><li><p><code>interrupt()</code> 方法是一个实例方法</p><p>它通知目标线程中断，也就是设置目标线程的中断标志位为true，中断标志位表示当前线程已经被中断了。</p></li><li><p><code>isInterrupted()</code> 方法也是一个实例方法</p><p>它判断当前线程是否被中断（通过检查中断标志位）并获取中断标志</p></li><li><p>Thread类的静态方法 <code>interrupted()</code></p><p>返回当前线程的中断状态(boolean类型)且将当前线程的中断状态设为false，此方法调用之后会清除当前线程的中断标志位的状态（将中断标志置为false了），返回当前值并清零置false</p></li></ul><h1 id="二、LockSupport是什么"><a href="#二、LockSupport是什么" class="headerlink" title="二、LockSupport是什么"></a>二、LockSupport是什么</h1><p><code>LockSupport</code> 是用来创建锁和其他同步类的基本线程阻塞原语，其中 <code>park()</code> 和 <code>unpack()</code> 而作用分别是阻塞线程和解除阻塞线程.</p><p><img src="https://raw.githubusercontent.com/GeorgeChan95/blogimg/master/img/2024/09/23/20240923-133129.png" alt="LockSupport"></p><h1 id="三、线程等待唤醒机制"><a href="#三、线程等待唤醒机制" class="headerlink" title="三、线程等待唤醒机制"></a>三、线程等待唤醒机制</h1><h2 id="1-3种让线程等待和唤醒的方法"><a href="#1-3种让线程等待和唤醒的方法" class="headerlink" title="1. 3种让线程等待和唤醒的方法"></a>1. 3种让线程等待和唤醒的方法</h2><ul><li>使用Object中的<code>wait()</code>方法让线程等待，使用Object中的<code>notify()</code>方法唤醒线程</li><li>使用JUC包中<code>Condition</code>的<code>await()</code>方法让线程等待，使用<code>signal()</code>方法唤醒线程</li><li><code>LockSupport</code>类可以阻塞当前线程以及唤醒指定被阻塞的线程</li></ul><h2 id="2-Object类中的-wait-和-notify-方法实现线程等待和唤醒"><a href="#2-Object类中的-wait-和-notify-方法实现线程等待和唤醒" class="headerlink" title="2. Object类中的 wait 和 notify 方法实现线程等待和唤醒"></a>2. Object类中的 wait 和 notify 方法实现线程等待和唤醒</h2><p><strong>正确使用 wait &#x2F; notify</strong> </p><ul><li>wait 和 notify 都必须在 synchronized 覆盖的代码块中</li><li>必须先执行 wait， 再执行 notify</li></ul><pre><code class="highlight java"><span class="comment">/**</span><span class="comment"> * 正确使用 wait / notify 实现线程的等待和唤醒</span><span class="comment"> *</span><span class="comment"> * <span class="doctag">@throws</span> InterruptedException</span><span class="comment"> */</span><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">normal</span><span class="params">()</span> <span class="keyword">throws</span> InterruptedException &#123;    <span class="keyword">new</span> <span class="title class_">Thread</span>(() -&gt; &#123;        <span class="keyword">synchronized</span> (object) &#123;            <span class="keyword">try</span> &#123;                System.out.println(Thread.currentThread().getName() + <span class="string">&quot; ---- t1释放锁&quot;</span>);                <span class="comment">// wait方法会释放锁，给其他线程获取锁的机会</span>                object.wait();                System.out.println(Thread.currentThread().getName() + <span class="string">&quot; ---- t1重新获取锁&quot;</span>);            &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;                <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">RuntimeException</span>(e);            &#125;        &#125;    &#125;, <span class="string">&quot;t1&quot;</span>).start();    TimeUnit.SECONDS.sleep(<span class="number">1</span>);    <span class="keyword">new</span> <span class="title class_">Thread</span>(() -&gt; &#123;        <span class="keyword">synchronized</span> (object) &#123;            System.out.println(Thread.currentThread().getName() + <span class="string">&quot;---- notify&quot;</span>);            object.notify(); <span class="comment">// notify执行，让 t1 线程重新获取锁</span>        &#125;    &#125;, <span class="string">&quot;t2&quot;</span>).start();&#125;</code></pre><p>运行结果：</p><pre><code class="highlight shell">t1 ---- t1释放锁t2---- notifyt1 ---- t1重新获取锁</code></pre><p><strong>错误使用—： 去掉 synchronized</strong></p><pre><code class="highlight java"><span class="comment">/**</span><span class="comment"> * 错误方式—： 去掉 synchronized</span><span class="comment"> *</span><span class="comment"> * <span class="doctag">@throws</span> InterruptedException</span><span class="comment"> */</span><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">error1</span><span class="params">()</span> <span class="keyword">throws</span> InterruptedException &#123;    <span class="keyword">new</span> <span class="title class_">Thread</span>(() -&gt; &#123;        <span class="keyword">try</span> &#123;            System.out.println(Thread.currentThread().getName() + <span class="string">&quot; ---- t1释放锁&quot;</span>);            <span class="comment">// wait方法会释放锁，给其他线程获取锁的机会</span>            object.wait();            System.out.println(Thread.currentThread().getName() + <span class="string">&quot; ---- t1重新获取锁&quot;</span>);        &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;            <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">RuntimeException</span>(e);        &#125;    &#125;, <span class="string">&quot;t1&quot;</span>).start();    TimeUnit.SECONDS.sleep(<span class="number">1</span>);    <span class="keyword">new</span> <span class="title class_">Thread</span>(() -&gt; &#123;        System.out.println(Thread.currentThread().getName() + <span class="string">&quot;---- notify&quot;</span>);        object.notify(); <span class="comment">// notify执行，让 t1 线程重新获取锁</span>    &#125;, <span class="string">&quot;t2&quot;</span>).start();&#125;</code></pre><p>运行结果：</p><pre><code class="highlight shell">t1 ---- t1释放锁Exception in thread &quot;t1&quot; java.lang.IllegalMonitorStateExceptionat java.lang.Object.wait(Native Method)at java.lang.Object.wait(Object.java:502)at com.atguigu.juc.interrupt.SynchronizedDemo.lambda$error1$2(SynchronizedDemo.java:59)at java.lang.Thread.run(Thread.java:748)t2---- notifyException in thread &quot;t2&quot; java.lang.IllegalMonitorStateExceptionat java.lang.Object.notify(Native Method)at com.atguigu.juc.interrupt.SynchronizedDemo.lambda$error1$3(SynchronizedDemo.java:70)at java.lang.Thread.run(Thread.java:748)</code></pre><p><strong>错误使用二：把notify和wait的执行顺序对换</strong></p><pre><code class="highlight java"><span class="comment">/**</span><span class="comment"> * 错误使用二：把notify和wait的执行顺序对换</span><span class="comment"> *</span><span class="comment"> * <span class="doctag">@throws</span> InterruptedException</span><span class="comment"> */</span><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">error2</span><span class="params">()</span> <span class="keyword">throws</span> InterruptedException &#123;    <span class="keyword">new</span> <span class="title class_">Thread</span>(() -&gt; &#123;        <span class="keyword">try</span> &#123;            TimeUnit.SECONDS.sleep(<span class="number">2</span>); <span class="comment">// t1 线程先停2秒，等待t2线程执行结束</span>        &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;            <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">RuntimeException</span>(e);        &#125;        <span class="keyword">synchronized</span> (object) &#123;            <span class="keyword">try</span> &#123;                System.out.println(Thread.currentThread().getName() + <span class="string">&quot; ---- t1释放锁&quot;</span>);                <span class="comment">// wait方法会释放锁，给其他线程获取锁的机会</span>                object.wait();                System.out.println(Thread.currentThread().getName() + <span class="string">&quot; ---- t1重新获取锁&quot;</span>);            &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;                <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">RuntimeException</span>(e);            &#125;        &#125;    &#125;, <span class="string">&quot;t1&quot;</span>).start();    TimeUnit.SECONDS.sleep(<span class="number">1</span>);    <span class="keyword">new</span> <span class="title class_">Thread</span>(() -&gt; &#123;        <span class="keyword">synchronized</span> (object) &#123;            System.out.println(Thread.currentThread().getName() + <span class="string">&quot;---- notify&quot;</span>);            object.notify(); <span class="comment">// notify执行，让 t1 线程重新获取锁</span>        &#125;    &#125;, <span class="string">&quot;t2&quot;</span>).start();&#125;</code></pre><p>运行结果：</p><pre><code class="highlight shell">t2---- notifyt1 ---- t1释放锁</code></pre><p>现象：t1 线程没有结束掉。</p><p><strong>总结：</strong></p><ul><li>wait和notify方法必须要在<strong>同步</strong>块或者方法里面，且必须<strong>成对</strong>出现使用</li><li>先wait后notify才可以,<strong>顺序不能错</strong></li></ul><h2 id="3-Condition接口中的-await-后-signal-方法实现线程的等待和唤醒"><a href="#3-Condition接口中的-await-后-signal-方法实现线程的等待和唤醒" class="headerlink" title="3. Condition接口中的 await 后 signal 方法实现线程的等待和唤醒"></a>3. Condition接口中的 await 后 signal 方法实现线程的等待和唤醒</h2><p><strong>正确使用 await &#x2F; signal</strong> </p><ul><li>await 和 signal 都必须在 lock() &#x2F; unlock() 覆盖的代码块中</li><li>必须先执行 await ， 再执行 signal</li></ul><pre><code class="highlight java"><span class="comment">/**</span><span class="comment"> * 正确使用 Lock 的 await / signal 实现对线程的等待和唤醒</span><span class="comment"> * <span class="doctag">@throws</span> InterruptedException</span><span class="comment"> */</span><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">normal</span><span class="params">()</span> <span class="keyword">throws</span> InterruptedException &#123;    <span class="type">Lock</span> <span class="variable">lock</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ReentrantLock</span>();    <span class="type">Condition</span> <span class="variable">condition</span> <span class="operator">=</span> lock.newCondition();    <span class="keyword">new</span> <span class="title class_">Thread</span>(() -&gt; &#123;        <span class="keyword">try</span> &#123;            lock.lock();            System.out.println(Thread.currentThread().getName() + <span class="string">&quot;---- t1 释放锁&quot;</span>);            condition.await();            System.out.println(Thread.currentThread().getName() + <span class="string">&quot;---- t1 重新获取锁&quot;</span>);        &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;            <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">RuntimeException</span>(e);        &#125; <span class="keyword">finally</span> &#123;            lock.unlock();        &#125;    &#125;, <span class="string">&quot;t1&quot;</span>).start();    TimeUnit.SECONDS.sleep(<span class="number">1</span>);    <span class="keyword">new</span> <span class="title class_">Thread</span>(() -&gt; &#123;        <span class="keyword">try</span> &#123;            lock.lock();            System.out.println(Thread.currentThread().getName() + <span class="string">&quot;---- t2唤醒t1线程&quot;</span>);            condition.signal();        &#125; <span class="keyword">finally</span> &#123;            lock.unlock();        &#125;    &#125;, <span class="string">&quot;t2&quot;</span>).start();&#125;</code></pre><p>运行结果：</p><pre><code class="highlight shell">t1---- t1 释放锁t2---- t2唤醒t1线程t1---- t1 重新获取锁</code></pre><p><strong>错误使用一：await 和 signal 不在 lock() &#x2F; unlock() 覆盖的代码块中</strong></p><p>报错： java.lang.IllegalMonitorStateException</p><p><strong>错误使用二：必须先执行 signal ， 再执行 await</strong></p><p>线程没有正确的停止</p><h2 id="4-Object和Condition使用的限制条件"><a href="#4-Object和Condition使用的限制条件" class="headerlink" title="4. Object和Condition使用的限制条件"></a>4. Object和Condition使用的限制条件</h2><ul><li>线程先要获得并持有锁，必须在锁块(synchronized或lock)中</li><li>必须要先等待后唤醒，线程才能够被唤醒</li></ul><h2 id="5-LockSupport类中的park等待和unpark唤醒"><a href="#5-LockSupport类中的park等待和unpark唤醒" class="headerlink" title="5. LockSupport类中的park等待和unpark唤醒"></a>5. LockSupport类中的park等待和unpark唤醒</h2><h3 id="5-1-概念解析"><a href="#5-1-概念解析" class="headerlink" title="5.1 概念解析"></a>5.1 概念解析</h3><p>LockSupport 通过 <code>park()</code> 和 <code>unpark(thread)</code> 方法来实现阻塞和唤醒线程的操作</p><p><strong>官网解释</strong></p><p><img src="https://raw.githubusercontent.com/GeorgeChan95/blogimg/master/img/2024/09/23/20240923-145605.png" alt="LockSupport"></p><p>LockSupport是用来创建锁和其他同步类的基本线程阻塞原语。</p><ul><li>LockSupport类使用了一种名为Permit（许可）的概念来做到阻塞和唤醒线程的功能， 每个线程都有一个许可(permit)，</li><li>permit只有两个值1和零，默认是零。</li><li>可以把许可看成是一种(0,1)信号量（Semaphore），但与 Semaphore 不同的是，许可的累加上限是1。</li></ul><h3 id="5-2-主要方法"><a href="#5-2-主要方法" class="headerlink" title="5.2 主要方法"></a>5.2 主要方法</h3><h4 id="5-2-1-API"><a href="#5-2-1-API" class="headerlink" title="5.2.1 API"></a>5.2.1 API</h4><p><img src="https://raw.githubusercontent.com/GeorgeChan95/blogimg/master/img/2024/09/23/20240923-150101.png" alt="LockSupport API"></p><h4 id="5-2-2-阻塞"><a href="#5-2-2-阻塞" class="headerlink" title="5.2.2 阻塞"></a>5.2.2 阻塞</h4><ul><li><code>park() / park(Object blocker)</code></li><li>阻塞当前线程 &#x2F; 阻塞传入的具体线程</li></ul><p>调用<code>LockSupport.park()</code>时，发现它调用了<code>unsafe类</code>，并且默认传了一个0</p><pre><code class="highlight java"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">park</span><span class="params">()</span> &#123;    UNSAFE.park(<span class="literal">false</span>, <span class="number">0L</span>);&#125;</code></pre><ul><li>permit默认是零，所以一开始调用<code>park()</code>方法，当前线程就会阻塞，直到别的线程将当前线程的permit设置为1时，park方法会被唤醒，然后会将permit再次设置为零并返回。</li></ul><h4 id="5-2-3-唤醒"><a href="#5-2-3-唤醒" class="headerlink" title="5.2.3 唤醒"></a>5.2.3 唤醒</h4><p><code>unpark(Thread thread)</code> , 唤醒处于阻塞状态的指定线程</p><pre><code class="highlight java"><span class="comment">/**</span><span class="comment"> * Makes available the permit for the given thread, if it</span><span class="comment"> * was not already available.  If the thread was blocked on</span><span class="comment"> * &#123;<span class="doctag">@code</span> park&#125; then it will unblock.  Otherwise, its next call</span><span class="comment"> * to &#123;<span class="doctag">@code</span> park&#125; is guaranteed not to block. This operation</span><span class="comment"> * is not guaranteed to have any effect at all if the given</span><span class="comment"> * thread has not been started.</span><span class="comment"> *</span><span class="comment"> * <span class="doctag">@param</span> thread the thread to unpark, or &#123;<span class="doctag">@code</span> null&#125;, in which case</span><span class="comment"> *        this operation has no effect</span><span class="comment"> */</span><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">unpark</span><span class="params">(Thread thread)</span> &#123;    <span class="keyword">if</span> (thread != <span class="literal">null</span>)        UNSAFE.unpark(thread);&#125;</code></pre><p>调用<code>LockSupport.unpark();</code>时，也调用了<code>unsafe类</code></p><ul><li>调用unpark(thread)方法后，就会将 thread线程的许可 permit 设置成<strong>1</strong>(注意多次调用 unpark 方法，不会累加，permit 值还是1)会自动唤醒 thread 线程，即之前阻塞中的 LockSupport.park() 方法会立即返回。</li></ul><h3 id="5-3-LockSupport-代码示例"><a href="#5-3-LockSupport-代码示例" class="headerlink" title="5.3 LockSupport 代码示例"></a>5.3 LockSupport 代码示例</h3><p><strong>正常+无锁块要求</strong></p><pre><code class="highlight java"><span class="comment">/**</span><span class="comment"> * 正常使用，无锁块要求</span><span class="comment"> * 先阻塞后释放，可以实现线程的阻塞和唤醒</span><span class="comment"> *</span><span class="comment"> * <span class="doctag">@throws</span> InterruptedException</span><span class="comment"> */</span><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">m1</span><span class="params">()</span> <span class="keyword">throws</span> InterruptedException &#123;    <span class="type">Thread</span> <span class="variable">t1</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Thread</span>(() -&gt; &#123;        System.out.println(Thread.currentThread().getName() + <span class="string">&quot;---- come in&quot;</span>);        System.out.println(Thread.currentThread().getName() + <span class="string">&quot;---- park阻塞&quot;</span>);        LockSupport.park();        System.out.println(Thread.currentThread().getName() + <span class="string">&quot;---- 继续执行&quot;</span>);    &#125;, <span class="string">&quot;t1&quot;</span>);    t1.start();    TimeUnit.SECONDS.sleep(<span class="number">1</span>);    <span class="keyword">new</span> <span class="title class_">Thread</span>(() -&gt; &#123;        System.out.println(Thread.currentThread().getName() + <span class="string">&quot;---- come in&quot;</span>);        LockSupport.unpark(t1);    &#125;, <span class="string">&quot;t2&quot;</span>).start();&#125;</code></pre><p>运行结果：</p><pre><code class="highlight shell">t1---- come int1---- park阻塞t2---- come int1---- 继续执行</code></pre><p><strong>先唤醒后等待，LockSupport 同样支持</strong></p><pre><code class="highlight java"><span class="comment">/**</span><span class="comment"> * 先释放后阻塞，也可以实现线程的阻塞和唤醒</span><span class="comment"> *</span><span class="comment"> * <span class="doctag">@throws</span> InterruptedException</span><span class="comment"> */</span><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">m2</span><span class="params">()</span> <span class="keyword">throws</span> InterruptedException &#123;    <span class="type">Thread</span> <span class="variable">t1</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Thread</span>(() -&gt; &#123;        <span class="keyword">try</span> &#123;            TimeUnit.SECONDS.sleep(<span class="number">2</span>);        &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;            <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">RuntimeException</span>(e);        &#125;        System.out.println(Thread.currentThread().getName() + <span class="string">&quot;---- come in&quot;</span>);        System.out.println(Thread.currentThread().getName() + <span class="string">&quot;---- park阻塞&quot;</span>);        LockSupport.park();        System.out.println(Thread.currentThread().getName() + <span class="string">&quot;---- 继续执行&quot;</span>);    &#125;, <span class="string">&quot;t1&quot;</span>);    t1.start();    TimeUnit.SECONDS.sleep(<span class="number">1</span>);    <span class="keyword">new</span> <span class="title class_">Thread</span>(() -&gt; &#123;        System.out.println(Thread.currentThread().getName() + <span class="string">&quot;---- come in&quot;</span>);        System.out.println(Thread.currentThread().getName() + <span class="string">&quot;---- 给t1线程发通行证&quot;</span>);        LockSupport.unpark(t1);    &#125;, <span class="string">&quot;t2&quot;</span>).start();&#125;</code></pre><p>运行结果：</p><pre><code class="highlight shell">t2---- come int2---- 给t1线程发通行证t1---- come int1---- park阻塞t1---- 继续执行</code></pre><p>t1 sleep方法2秒后醒来，执行park无效，没有阻塞效果，这是因为 t2 先执行了<code>unpark(t1)</code>导致上面的park方法无效.</p><p>注意：park() &#x2F; unpark() 必须成对出现</p><p><strong>错误使用：连续执行 unpark(), 相当于只执行了一次 unpark()</strong> </p><pre><code class="highlight java"><span class="comment">/**</span><span class="comment"> * 连续执行 unpark(), 相当于只执行了一次 unpark()</span><span class="comment"> */</span><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">error1</span><span class="params">()</span> &#123;    <span class="type">Thread</span> <span class="variable">t1</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Thread</span>(() -&gt; &#123;        System.out.println(Thread.currentThread().getName() + <span class="string">&quot;\t&quot;</span> + <span class="string">&quot;---come in&quot;</span>);        System.out.println(Thread.currentThread().getName() + <span class="string">&quot;\t&quot;</span> + <span class="string">&quot;--- park1&quot;</span>);        LockSupport.park();        System.out.println(Thread.currentThread().getName() + <span class="string">&quot;\t&quot;</span> + <span class="string">&quot;--- park2&quot;</span>);        LockSupport.park();        System.out.println(Thread.currentThread().getName() + <span class="string">&quot;\t&quot;</span> + <span class="string">&quot;---被唤醒&quot;</span>);    &#125;, <span class="string">&quot;t1&quot;</span>);    t1.start();    <span class="keyword">new</span> <span class="title class_">Thread</span>(() -&gt; &#123;        LockSupport.unpark(t1);        LockSupport.unpark(t1);        System.out.println(Thread.currentThread().getName() + <span class="string">&quot;\t&quot;</span> + <span class="string">&quot;--- unpark1&quot;</span>);        System.out.println(Thread.currentThread().getName() + <span class="string">&quot;\t&quot;</span> + <span class="string">&quot;--- unpark2&quot;</span>);        <span class="keyword">try</span> &#123;            TimeUnit.SECONDS.sleep(<span class="number">3</span>);        &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;            e.printStackTrace();        &#125;    &#125;, <span class="string">&quot;t2&quot;</span>).start();&#125;</code></pre><p>运行结果：</p><pre><code class="highlight shell">t1---come int1--- park1t2--- unpark1t2--- unpark2t1--- park2</code></pre><p>t1 没有停止，继续阻塞，这是因为 t2 连续执行了两次 <code>unpark(t1)</code> ，但其实只发布了一个通行证，导致 t1 的第一次 park() 被唤醒了，但是第二次 park() 就没有通行证用来唤醒它，因此 t1 阻塞。</p><p><strong>总结：</strong></p><ul><li>Lock Support是用来创建锁和其他同步类的基本线程阻塞原语。</li><li>Lock Support是一个线程阻塞工具类， 所有的方法都是静态方法， 可以让线程在任意位置阻塞， 阻塞之后也有对应的唤醒方法。归根结底，Lock Support调用的Unsafe中的native代码。</li><li>Lock Support提供<code>park()</code> 和<code>unpark() </code>方法实现<strong>阻塞线程</strong>和<strong>解除线程阻塞</strong>的过程</li><li>Lock Support和每个使用它的线程都有一个许可(permit) 关联。</li><li>每个线程都有一个相关的 permit， permit 最多只有一个， 重复调用 <code>unpark()</code> 也不会积累凭证。</li></ul>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;一、线程中断机制&quot;&gt;&lt;a href=&quot;#一、线程中断机制&quot; class=&quot;headerlink&quot; title=&quot;一、线程中断机制&quot;&gt;&lt;/a&gt;一、线程中断机制&lt;/h1&gt;&lt;h2 id=&quot;1-什么是中断机制-？&quot;&gt;&lt;a href=&quot;#1-什么是中断机制-？&quot; class</summary>
      
    
    
    
    <category term="JUC" scheme="https://georgechan95.github.io/categories/JUC/"/>
    
    
    <category term="juc" scheme="https://georgechan95.github.io/tags/juc/"/>
    
    <category term="java" scheme="https://georgechan95.github.io/tags/java/"/>
    
  </entry>
  
  <entry>
    <title>03-JUC进阶-Java中的锁的解析</title>
    <link href="https://georgechan95.github.io/blog/219e52ea.html"/>
    <id>https://georgechan95.github.io/blog/219e52ea.html</id>
    <published>2024-09-21T06:15:20.000Z</published>
    <updated>2024-09-21T08:52:48.128Z</updated>
    
    <content type="html"><![CDATA[<h1 id="一、乐观锁和悲观锁"><a href="#一、乐观锁和悲观锁" class="headerlink" title="一、乐观锁和悲观锁"></a>一、乐观锁和悲观锁</h1><h2 id="1-悲观锁"><a href="#1-悲观锁" class="headerlink" title="1. 悲观锁"></a>1. 悲观锁</h2><p>悲观锁认为自己在使用数据的时候一定有别的线程来修改数据，因此在获取数据的时候会先加锁，确保数据不会被别的线程修改。</p><p><strong>悲观锁的实现方式</strong></p><ul><li><code>synchronized</code> 关键字</li><li><code>Lock</code> 的实现类都是悲观锁</li></ul><p><strong>适合写操作多的场景</strong>，先加锁可以保证写操作时数据正确。显示的锁定之后再操作同步资源。</p><pre><code class="highlight java"><span class="comment">//=============悲观锁的调用方式</span><span class="keyword">public</span> <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title function_">m1</span><span class="params">()</span>&#123;    <span class="comment">//加锁后的业务逻辑......</span>&#125;<span class="comment">// 保证多个线程使用的是同一个lock对象的前提下</span><span class="type">ReentrantLock</span> <span class="variable">lock</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ReentrantLock</span>();<span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">m2</span><span class="params">()</span> &#123;    lock.lock();    <span class="keyword">try</span> &#123;        <span class="comment">// 操作同步资源</span>    &#125;<span class="keyword">finally</span> &#123;        lock.unlock();    &#125;&#125;</code></pre><h2 id="2-乐观锁"><a href="#2-乐观锁" class="headerlink" title="2. 乐观锁"></a>2. 乐观锁</h2><p>乐观锁认为自己在使用数据时不会有别的线程修改数据，所以不会添加锁，只是在更新数据的时候去判断之前有没有别的线程更新了这个数据。如果这个数据没有被更新，当前线程将自己修改的数据成功写入。如果数据已经被其他线程更新，则根据不同的实现方式执行不同的操作</p><p><strong>乐观锁的实现方式</strong></p><ul><li>版本号机制Version。（只要有人提交了就会修改版本号，可以解决ABA问题）<ul><li><strong>ABA问题</strong>：再CAS中想读取一个值A，想把值A变为C，不能保证读取时的A就是赋值时的A，中间可能有个线程将A变为B再变为A。<ul><li>解决方法：Juc包提供了一个 <code>AtomicStampedReference</code>，原子更新带有版本号的引用类型，通过控制版本值的变化来解决ABA问题。</li></ul></li><li>最常采用的是CAS算法，Java原子类中的递增操作就通过CAS自旋实现的。</li></ul></li></ul><p><strong>适合读操作多的场景</strong>，不加锁的性能特点能够使其操作的性能大幅提升。</p><pre><code class="highlight java"><span class="comment">//=============乐观锁的调用方式</span><span class="comment">// 保证多个线程使用的是同一个AtomicInteger</span><span class="keyword">private</span> <span class="type">AtomicInteger</span> <span class="variable">atomicInteger</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">AtomicInteger</span>();atomicInteger.incrementAndGet();</code></pre><h1 id="二、synchronized-锁的8种情况"><a href="#二、synchronized-锁的8种情况" class="headerlink" title="二、synchronized 锁的8种情况"></a>二、synchronized 锁的8种情况</h1><p>下面通过一段代码，演示 synchronized 锁的 8 种情况</p><ol><li><p>标准访问，先打印短信还是邮件</p><pre><code class="highlight java"><span class="keyword">class</span> <span class="title class_">Phone</span> &#123;    <span class="keyword">public</span> <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title function_">sendSMS</span><span class="params">()</span> <span class="keyword">throws</span> Exception &#123;        System.out.println(<span class="string">&quot;------sendSMS&quot;</span>);    &#125;    <span class="keyword">public</span> <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title function_">sendEmail</span><span class="params">()</span> <span class="keyword">throws</span> Exception &#123;        System.out.println(<span class="string">&quot;------sendEmail&quot;</span>);    &#125;&#125;<span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Lock_8</span> &#123;    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception &#123;        <span class="type">Phone</span> <span class="variable">phone</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Phone</span>();        <span class="keyword">new</span> <span class="title class_">Thread</span>(() -&gt; &#123;            <span class="keyword">try</span> &#123;                phone.sendSMS();            &#125; <span class="keyword">catch</span> (Exception e) &#123;                e.printStackTrace();            &#125;        &#125;, <span class="string">&quot;AA&quot;</span>).start();        Thread.sleep(<span class="number">100</span>);        <span class="keyword">new</span> <span class="title class_">Thread</span>(() -&gt; &#123;            <span class="keyword">try</span> &#123;                phone.sendEmail();            &#125; <span class="keyword">catch</span> (Exception e) &#123;                e.printStackTrace();            &#125;        &#125;, <span class="string">&quot;BB&quot;</span>).start();    &#125;&#125;</code></pre><p>打印结果：</p><pre><code class="highlight shell">------sendSMS------sendEmail</code></pre><p>分析：两个方法都加了 synchronized 关键字，因为是同一个对象调用，所有是同一把锁，按照顺序执行。</p></li><li><p>停4秒在短信方法内，先打印短信还是邮件</p><pre><code class="highlight java"><span class="keyword">class</span> <span class="title class_">Phone</span> &#123;    <span class="keyword">public</span> <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title function_">sendSMS</span><span class="params">()</span> <span class="keyword">throws</span> Exception &#123;        <span class="comment">//停留4秒</span>        TimeUnit.SECONDS.sleep(<span class="number">4</span>);        System.out.println(<span class="string">&quot;------sendSMS&quot;</span>);    &#125;    <span class="keyword">public</span> <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title function_">sendEmail</span><span class="params">()</span> <span class="keyword">throws</span> Exception &#123;        System.out.println(<span class="string">&quot;------sendEmail&quot;</span>);    &#125;&#125;<span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Lock_8</span> &#123;    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception &#123;        <span class="type">Phone</span> <span class="variable">phone</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Phone</span>();        <span class="keyword">new</span> <span class="title class_">Thread</span>(() -&gt; &#123;            <span class="keyword">try</span> &#123;                phone.sendSMS();            &#125; <span class="keyword">catch</span> (Exception e) &#123;                e.printStackTrace();            &#125;        &#125;, <span class="string">&quot;AA&quot;</span>).start();        Thread.sleep(<span class="number">100</span>);        <span class="keyword">new</span> <span class="title class_">Thread</span>(() -&gt; &#123;            <span class="keyword">try</span> &#123;                phone.sendEmail();            &#125; <span class="keyword">catch</span> (Exception e) &#123;                e.printStackTrace();            &#125;        &#125;, <span class="string">&quot;BB&quot;</span>).start();    &#125;&#125;</code></pre><p>打印结果：</p><pre><code class="highlight shell">------sendSMS------sendEmail</code></pre><p>分析：两个方法都加了 synchronized 关键字，因为还是同一个对象调用，所有还是同一把锁，先拿到锁的方法执行结束后，另一个方法才能执行。</p></li><li><p>新增普通的hello方法，是先打短信还是hello</p><pre><code class="highlight java"><span class="keyword">class</span> <span class="title class_">Phone</span> &#123;    <span class="keyword">public</span> <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title function_">sendSMS</span><span class="params">()</span> <span class="keyword">throws</span> Exception &#123;        <span class="comment">//停留4秒</span>        TimeUnit.SECONDS.sleep(<span class="number">4</span>);        System.out.println(<span class="string">&quot;------sendSMS&quot;</span>);    &#125;    <span class="keyword">public</span> <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title function_">sendEmail</span><span class="params">()</span> <span class="keyword">throws</span> Exception &#123;        System.out.println(<span class="string">&quot;------sendEmail&quot;</span>);    &#125;    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">getHello</span><span class="params">()</span> &#123;        System.out.println(<span class="string">&quot;------getHello&quot;</span>);    &#125;&#125;<span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Lock_8</span> &#123;    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception &#123;        <span class="type">Phone</span> <span class="variable">phone</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Phone</span>();        <span class="keyword">new</span> <span class="title class_">Thread</span>(() -&gt; &#123;            <span class="keyword">try</span> &#123;                phone.sendSMS();            &#125; <span class="keyword">catch</span> (Exception e) &#123;                e.printStackTrace();            &#125;        &#125;, <span class="string">&quot;AA&quot;</span>).start();        Thread.sleep(<span class="number">100</span>);        <span class="keyword">new</span> <span class="title class_">Thread</span>(() -&gt; &#123;            <span class="keyword">try</span> &#123;                phone.getHello();            &#125; <span class="keyword">catch</span> (Exception e) &#123;                e.printStackTrace();            &#125;        &#125;, <span class="string">&quot;BB&quot;</span>).start();    &#125;&#125;</code></pre><p>打印结果：</p><pre><code class="highlight shell">------getHello------sendSMS</code></pre><p>分析：hello方法没有加锁，调用即执行，sendSMS有sleep阻塞。</p></li><li><p>现在有两部手机，先打印短信还是邮件</p><pre><code class="highlight java"><span class="keyword">class</span> <span class="title class_">Phone</span> &#123;    <span class="keyword">public</span> <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title function_">sendSMS</span><span class="params">()</span> <span class="keyword">throws</span> Exception &#123;        <span class="comment">//停留4秒</span>        TimeUnit.SECONDS.sleep(<span class="number">4</span>);        System.out.println(<span class="string">&quot;------sendSMS&quot;</span>);    &#125;    <span class="keyword">public</span> <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title function_">sendEmail</span><span class="params">()</span> <span class="keyword">throws</span> Exception &#123;        System.out.println(<span class="string">&quot;------sendEmail&quot;</span>);    &#125;&#125;<span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Lock_8</span> &#123;    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception &#123;        <span class="type">Phone</span> <span class="variable">phone</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Phone</span>();        <span class="type">Phone</span> <span class="variable">phone2</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Phone</span>();        <span class="keyword">new</span> <span class="title class_">Thread</span>(() -&gt; &#123;            <span class="keyword">try</span> &#123;                phone.sendSMS();            &#125; <span class="keyword">catch</span> (Exception e) &#123;                e.printStackTrace();            &#125;        &#125;, <span class="string">&quot;AA&quot;</span>).start();        Thread.sleep(<span class="number">100</span>);        <span class="keyword">new</span> <span class="title class_">Thread</span>(() -&gt; &#123;            <span class="keyword">try</span> &#123;                phone2.sendEmail();            &#125; <span class="keyword">catch</span> (Exception e) &#123;                e.printStackTrace();            &#125;        &#125;, <span class="string">&quot;BB&quot;</span>).start();    &#125;&#125;</code></pre><p>打印结果：</p><pre><code class="highlight shell">------sendEmail------sendSMS</code></pre><p>分析：synchronized 在方法上，是方法级的锁，由于是两个 phone 对象调用不同的方法，所以 sendSMS() 和 sendEmail() 持有的是不同的锁，互不影响。</p></li><li><p>两个静态同步方法，1部手机，先打印短信还是邮件</p><pre><code class="highlight java"><span class="keyword">class</span> <span class="title class_">Phone</span> &#123;    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title function_">sendSMS</span><span class="params">()</span> <span class="keyword">throws</span> Exception &#123;        <span class="comment">//停留4秒</span>        TimeUnit.SECONDS.sleep(<span class="number">4</span>);        System.out.println(<span class="string">&quot;------sendSMS&quot;</span>);    &#125;    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title function_">sendEmail</span><span class="params">()</span> <span class="keyword">throws</span> Exception &#123;        System.out.println(<span class="string">&quot;------sendEmail&quot;</span>);    &#125;&#125;<span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Lock_8</span> &#123;    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception &#123;        <span class="type">Phone</span> <span class="variable">phone</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Phone</span>();                <span class="keyword">new</span> <span class="title class_">Thread</span>(() -&gt; &#123;            <span class="keyword">try</span> &#123;                phone.sendSMS();            &#125; <span class="keyword">catch</span> (Exception e) &#123;                e.printStackTrace();            &#125;        &#125;, <span class="string">&quot;AA&quot;</span>).start();        Thread.sleep(<span class="number">100</span>);        <span class="keyword">new</span> <span class="title class_">Thread</span>(() -&gt; &#123;            <span class="keyword">try</span> &#123;                phone.sendEmail();            &#125; <span class="keyword">catch</span> (Exception e) &#123;                e.printStackTrace();            &#125;        &#125;, <span class="string">&quot;BB&quot;</span>).start();    &#125;&#125;</code></pre><p>打印结果：</p><pre><code class="highlight shell">------sendSMS------sendEmail</code></pre><p>分析：synchronized 在静态方法上，是类级别的锁，所以两个方法持有的是同一把锁，要按顺序执行</p></li><li><p>两个静态同步方法，2部手机，先打印短信还是邮件</p><pre><code class="highlight java"><span class="keyword">class</span> <span class="title class_">Phone</span> &#123;    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title function_">sendSMS</span><span class="params">()</span> <span class="keyword">throws</span> Exception &#123;        <span class="comment">//停留4秒</span>        TimeUnit.SECONDS.sleep(<span class="number">4</span>);        System.out.println(<span class="string">&quot;------sendSMS&quot;</span>);    &#125;    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title function_">sendEmail</span><span class="params">()</span> <span class="keyword">throws</span> Exception &#123;        System.out.println(<span class="string">&quot;------sendEmail&quot;</span>);    &#125;&#125;<span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Lock_8</span> &#123;    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception &#123;        <span class="type">Phone</span> <span class="variable">phone</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Phone</span>();        <span class="type">Phone</span> <span class="variable">phone2</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Phone</span>();        <span class="keyword">new</span> <span class="title class_">Thread</span>(() -&gt; &#123;            <span class="keyword">try</span> &#123;                phone.sendSMS();            &#125; <span class="keyword">catch</span> (Exception e) &#123;                e.printStackTrace();            &#125;        &#125;, <span class="string">&quot;AA&quot;</span>).start();        Thread.sleep(<span class="number">100</span>);        <span class="keyword">new</span> <span class="title class_">Thread</span>(() -&gt; &#123;            <span class="keyword">try</span> &#123;                phone2.sendEmail();            &#125; <span class="keyword">catch</span> (Exception e) &#123;                e.printStackTrace();            &#125;        &#125;, <span class="string">&quot;BB&quot;</span>).start();    &#125;&#125;</code></pre><p>打印结果：</p><pre><code class="highlight shell">------sendSMS------sendEmail</code></pre><p>分析：synchronized 在静态方法上，是类级别的锁，所以两个方法持有的是同一把锁，要按顺序执行</p></li><li><p>1个静态同步方法,1个普通同步方法，1部手机，先打印短信还是邮件</p><pre><code class="highlight java"><span class="keyword">class</span> <span class="title class_">Phone</span> &#123;    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title function_">sendSMS</span><span class="params">()</span> <span class="keyword">throws</span> Exception &#123;        <span class="comment">//停留4秒</span>        TimeUnit.SECONDS.sleep(<span class="number">4</span>);        System.out.println(<span class="string">&quot;------sendSMS&quot;</span>);    &#125;    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">getHello</span><span class="params">()</span> &#123;        System.out.println(<span class="string">&quot;------getHello&quot;</span>);    &#125;&#125;<span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Lock_8</span> &#123;    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception &#123;        <span class="type">Phone</span> <span class="variable">phone</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Phone</span>();        <span class="keyword">new</span> <span class="title class_">Thread</span>(() -&gt; &#123;            <span class="keyword">try</span> &#123;                phone.sendSMS();            &#125; <span class="keyword">catch</span> (Exception e) &#123;                e.printStackTrace();            &#125;        &#125;, <span class="string">&quot;AA&quot;</span>).start();        Thread.sleep(<span class="number">100</span>);        <span class="keyword">new</span> <span class="title class_">Thread</span>(() -&gt; &#123;            <span class="keyword">try</span> &#123;                phone.getHello();            &#125; <span class="keyword">catch</span> (Exception e) &#123;                e.printStackTrace();            &#125;        &#125;, <span class="string">&quot;BB&quot;</span>).start();    &#125;&#125;</code></pre><p>打印结果：</p><pre><code class="highlight shell">------getHello------sendSMS</code></pre><p>分析：类加锁对普通方法无限制，普通方法调用即执行。</p></li><li><p>1个静态同步方法,1个普通同步方法，2部手机，先打印短信还是邮件</p><pre><code class="highlight java"><span class="keyword">class</span> <span class="title class_">Phone</span> &#123;    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title function_">sendSMS</span><span class="params">()</span> <span class="keyword">throws</span> Exception &#123;        <span class="comment">//停留4秒</span>        TimeUnit.SECONDS.sleep(<span class="number">4</span>);        System.out.println(<span class="string">&quot;------sendSMS&quot;</span>);    &#125;    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">sendEmail</span><span class="params">()</span> <span class="keyword">throws</span> Exception &#123;        System.out.println(<span class="string">&quot;------sendEmail&quot;</span>);    &#125;&#125;<span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Lock_8</span> &#123;    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception &#123;        <span class="type">Phone</span> <span class="variable">phone</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Phone</span>();        <span class="type">Phone</span> <span class="variable">phone2</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Phone</span>();        <span class="keyword">new</span> <span class="title class_">Thread</span>(() -&gt; &#123;            <span class="keyword">try</span> &#123;                phone.sendSMS();            &#125; <span class="keyword">catch</span> (Exception e) &#123;                e.printStackTrace();            &#125;        &#125;, <span class="string">&quot;AA&quot;</span>).start();        Thread.sleep(<span class="number">100</span>);        <span class="keyword">new</span> <span class="title class_">Thread</span>(() -&gt; &#123;            <span class="keyword">try</span> &#123;                phone2.sendEmail();            &#125; <span class="keyword">catch</span> (Exception e) &#123;                e.printStackTrace();            &#125;        &#125;, <span class="string">&quot;BB&quot;</span>).start();    &#125;&#125;</code></pre><p>打印结果：</p><pre><code class="highlight shell">------sendEmail------sendSMS</code></pre><p>分析：类加锁对普通方法无限制，普通方法调用即执行。</p></li></ol><p><strong>总结：</strong></p><ul><li>synchronized 锁的是方法，则是对象锁，同个对象锁的机制要等待，不同对象锁的机制调用同一个不用等待</li><li>加了static则为class锁而不是对象锁</li><li>对于同步方法块，锁是 synchronized 括号里配置对象</li></ul><h1 id="三、字节码角度分析-synchronized-实现"><a href="#三、字节码角度分析-synchronized-实现" class="headerlink" title="三、字节码角度分析 synchronized 实现"></a>三、字节码角度分析 synchronized 实现</h1><h2 id="1-synchronized-同步代码块"><a href="#1-synchronized-同步代码块" class="headerlink" title="1. synchronized 同步代码块"></a>1. synchronized 同步代码块</h2><h3 id="1-1-文件反编译技巧"><a href="#1-1-文件反编译技巧" class="headerlink" title="1.1 文件反编译技巧"></a>1.1 文件反编译技巧</h3><ul><li><p>文件反编译 <code>javap -c ***.class</code> 文件反编译，-c表示对代码进行反汇编</p></li><li><p>假如需要更多信息 <code>javap -v ***.class</code> ，-v 即 -verbose 输出附加信息（包括行号、本地变量表、反汇编等详细信息）</p></li></ul><h3 id="1-2-synchronized-同步代码块"><a href="#1-2-synchronized-同步代码块" class="headerlink" title="1.2 synchronized 同步代码块"></a>1.2 synchronized 同步代码块</h3><pre><code class="highlight java"><span class="comment">/**</span><span class="comment"> * 锁同步代码块</span><span class="comment"> */</span><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">LockSyncDemo</span> &#123;    <span class="type">Object</span> <span class="variable">object</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Object</span>();    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">m1</span><span class="params">()</span>&#123;        <span class="keyword">synchronized</span> (object)&#123;            System.out.println(<span class="string">&quot;-----hello synchronized code block&quot;</span>);        &#125;    &#125;    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;    &#125;&#125;</code></pre><h3 id="1-3-class-文件反编译"><a href="#1-3-class-文件反编译" class="headerlink" title="1.3 class 文件反编译"></a>1.3 class 文件反编译</h3><p>执行命令 <code>javap -c LockSyncDemo.class</code></p><pre><code class="highlight shell">public class com.georg.controller.LockSyncDemo &#123;  java.lang.Object object;  public com.zhang.admin.controller.LockSyncDemo();    Code:       0: aload_0       1: invokespecial #1                  // Method java/lang/Object.&quot;&lt;init&gt;&quot;:()V       4: aload_0       5: new           #2                  // class java/lang/Object       8: dup       9: invokespecial #1                  // Method java/lang/Object.&quot;&lt;init&gt;&quot;:()V      12: putfield      #3                  // Field object:Ljava/lang/Object;      15: return  public void m1();    Code:       0: aload_0       1: getfield      #3                  // Field object:Ljava/lang/Object;       4: dup       5: astore_1       6: monitorenter        //**注****------进入锁       7: getstatic     #4                  // Field java/lang/System.out:Ljava/io/PrintStream;      10: ldc           #5                  // String -----hello synchronized code block      12: invokevirtual #6                  // Method java/io/PrintStream.println:(Ljava/lang/String;)V      15: aload_1      16: monitorexit        // **注**------退出锁      17: goto          25      20: astore_2      21: aload_1      22: monitorexit        //**注**-----这里又有一个exit, 目的当出现异常时，保证能够释放锁      23: aload_2      24: athrow      25: return    Exception table:       from    to  target type           7    17    20   any          20    23    20   any  public static void main(java.lang.String[]);    Code:       0: return&#125;</code></pre><p><strong>总结</strong></p><ul><li>synchronized 同步代码块，实现使用的是<code>moniterenter</code> 和 <code>moniterexit</code> 指令（ <code>moniterexit</code> 可能有两个）</li><li>那一定是一个enter两个exit吗？（不一样，如果主动throw一个RuntimeException，发现一个enter，一个exit，还有两个athrow）</li></ul><h2 id="2-synchronized-普通同步方法"><a href="#2-synchronized-普通同步方法" class="headerlink" title="2. synchronized 普通同步方法"></a>2. synchronized 普通同步方法</h2><pre><code class="highlight java"><span class="comment">/**</span><span class="comment"> * 锁普通的同步方法</span><span class="comment"> */</span><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">LockSyncDemo</span> &#123;    <span class="keyword">public</span> <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title function_">m2</span><span class="params">()</span>&#123;        System.out.println(<span class="string">&quot;------hello synchronized m2&quot;</span>);    &#125;    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;    &#125;&#125;</code></pre><ul><li>类似于上述操作，最后调用 <code>javap -v LockSyncDemo.class</code></li></ul><pre><code class="highlight java">.....<span class="keyword">public</span> <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title function_">m2</span><span class="params">()</span>;    descriptor: ()V    flags: ACC_PUBLIC, ACC_SYNCHRONIZED <span class="comment">//请注意该标志</span>    Code:      stack=<span class="number">2</span>, locals=<span class="number">1</span>, args_size=<span class="number">1</span>         <span class="number">0</span>: getstatic     #<span class="number">2</span>                  <span class="comment">// Field java/lang/System.out:Ljava/io/PrintStream;</span>         <span class="number">3</span>: ldc           #<span class="number">3</span>                  <span class="comment">// String ------hello synchronized m2</span>         <span class="number">5</span>: invokevirtual #<span class="number">4</span>                  <span class="comment">// Method java/io/PrintStream.println:(Ljava/lang/String;)V</span>         <span class="number">8</span>: <span class="keyword">return</span>      LineNumberTable:        line <span class="number">11</span>: <span class="number">0</span>        line <span class="number">12</span>: <span class="number">8</span>      LocalVariableTable:        Start  Length  Slot  Name   Signature            <span class="number">0</span>       <span class="number">9</span>     <span class="number">0</span>  <span class="built_in">this</span>   Lcom/zhang/admin/controller/LockSyncDemo;......</code></pre><p><strong>总结</strong></p><p>调用指令将会检查方法的 <strong>ACC_SYNCHRONIZED</strong> 访问标志是否被设置。如果设置了，执行线程会先持有monitor, 然后再执行方法，最后在方法完成（无论是正常完成还是非正常完成）时释放monitor</p><h2 id="3-synchronized-静态同步方法"><a href="#3-synchronized-静态同步方法" class="headerlink" title="3. synchronized 静态同步方法"></a>3. synchronized 静态同步方法</h2><pre><code class="highlight java"><span class="comment">/**</span><span class="comment"> * 锁静态同步方法</span><span class="comment"> */</span><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">LockSyncDemo</span> &#123;    <span class="keyword">public</span> <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title function_">m2</span><span class="params">()</span>&#123;        System.out.println(<span class="string">&quot;------hello synchronized m2&quot;</span>);    &#125;    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title function_">m3</span><span class="params">()</span>&#123;        System.out.println(<span class="string">&quot;------hello synchronized m3---static&quot;</span>);    &#125;    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;    &#125;&#125;</code></pre><ul><li>调用 <code>javap -v LockSyncDemo.class</code></li></ul><pre><code class="highlight shell"> ...... public static synchronized void m3();    descriptor: ()V    flags: ACC_PUBLIC, ACC_STATIC, ACC_SYNCHRONIZED //访问标志 区分该方法是否是静态同步方法    Code:      stack=2, locals=0, args_size=0         0: getstatic     #2                  // Field java/lang/System.out:Ljava/io/PrintStream;         3: ldc           #5                  // String ------hello synchronized m3---static         5: invokevirtual #4                  // Method java/io/PrintStream.println:(Ljava/lang/String;)V         8: return      LineNumberTable:        line 15: 0        line 16: 8......</code></pre><p><strong>总结</strong></p><p><strong>ACC_STATIC</strong> 访问标志区分该方法是否是静态同步方法。</p><h1 id="四、反编译解析-synchronized-锁的是什么"><a href="#四、反编译解析-synchronized-锁的是什么" class="headerlink" title="四、反编译解析 synchronized 锁的是什么"></a>四、反编译解析 synchronized 锁的是什么</h1><h2 id="1-管程概念"><a href="#1-管程概念" class="headerlink" title="1. 管程概念"></a>1. 管程概念</h2><ul><li>管程：Monitor（监视器），也就是我们平时说的锁。监视器锁</li><li>信号量及其操作原语“封装”在一个对象内部）管程实现了在一个时间点，最多只有一个线程在执行管程的某个子程序。 管程提供了一种机制，管程可以看做一个软件模块，它是将共享的变量和对于这些共享变量的操作封装起来，形成一个具有一定接口的功能模块，进程可以调用管程来实现线程级别的并发控制。</li><li>执行线程就要求先成功持有管程，然后才能执行方法，最后当方法完成（无论是正常完成还是非正常完成）时释放管理。在方法执行期间，执行线程持有了管程，其他任何线程都无法再获取到同一个管程。</li></ul><h2 id="2-解释为什么任何一个对象都可以成为一个锁"><a href="#2-解释为什么任何一个对象都可以成为一个锁" class="headerlink" title="2. 解释为什么任何一个对象都可以成为一个锁"></a>2. 解释为什么任何一个对象都可以成为一个锁</h2><p>Java Object 类是所有类的父类，也就是说 Java 的所有类都继承了 Object，子类可以使用 Object 的所有方法。</p><ul><li><code>ObjectMonitor.java</code> → <code>ObjectMonitor.cpp</code> → <code>objectMonitor.hpp</code></li></ul><p><code>ObjectMonitor.cpp</code> 中引入了头文件（include）<code>objectMonitor.hpp</code></p><p><img src="https://raw.githubusercontent.com/GeorgeChan95/blogimg/master/img/2024/09/21/20240921-153217.png" alt="objectMonitor.hpp"></p><ul><li><p><strong>objectMonitor.hpp</strong></p><table><thead><tr><th>属性</th><th>作用</th></tr></thead><tbody><tr><td>_owner</td><td>指向持有ObjectMonitor对象的线程</td></tr><tr><td>_WaitSet</td><td>存放处于wait状态的线程队列</td></tr><tr><td>_EntryList</td><td>存放处于等待锁block状态的线程队列</td></tr><tr><td>_recursions</td><td>锁的重入次数</td></tr><tr><td>_count</td><td>用来记录该线程获取锁的次数</td></tr></tbody></table><p><strong>因此：每个对象天生都带着一个对象监视器</strong></p></li></ul><h1 id="五、关于锁升级"><a href="#五、关于锁升级" class="headerlink" title="五、关于锁升级"></a>五、关于锁升级</h1><p>这里只是简单提及，做个了解，后面会再做深入讲解</p><p>synchronized必须作用于某个对象中，所以Java在对象的头文件存储了锁的相关信息。锁升级功能主要依赖于 MarkWord 中的锁标志位和释放偏向锁标志位。</p><p><img src="https://raw.githubusercontent.com/GeorgeChan95/blogimg/master/img/2024/09/21/20240921-153834.png" alt="锁升级"></p><h1 id="六、公平锁和非公平锁"><a href="#六、公平锁和非公平锁" class="headerlink" title="六、公平锁和非公平锁"></a>六、公平锁和非公平锁</h1><h2 id="1-案例演示"><a href="#1-案例演示" class="headerlink" title="1. 案例演示"></a>1. 案例演示</h2><h3 id="1-1-非公平锁"><a href="#1-1-非公平锁" class="headerlink" title="1.1 非公平锁"></a>1.1 非公平锁</h3><p>使用 ReentrantLock 实现抢票的案例</p><pre><code class="highlight java"><span class="keyword">class</span> <span class="title class_">Ticket</span> &#123;    <span class="keyword">private</span> <span class="type">int</span> <span class="variable">number</span> <span class="operator">=</span> <span class="number">30</span>;    <span class="keyword">private</span> <span class="type">Lock</span> <span class="variable">lock</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ReentrantLock</span>(); <span class="comment">//默认用的是非公平锁，分配的平均一点，=--》公平一点</span>    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">sale</span><span class="params">()</span> &#123;        lock.lock();        <span class="keyword">try</span> &#123;            <span class="keyword">if</span> (number &gt; <span class="number">0</span>) &#123;                System.out.println(Thread.currentThread().getName() + <span class="string">&quot;\t 卖出第: &quot;</span> + (number--) + <span class="string">&quot;\t 还剩下: &quot;</span> + number);            &#125;        &#125; <span class="keyword">finally</span> &#123;            lock.unlock();        &#125;    &#125;&#125;<span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">SaleTicketDemo</span> &#123;    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;        <span class="type">Ticket</span> <span class="variable">ticket</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Ticket</span>();        <span class="keyword">new</span> <span class="title class_">Thread</span>(() -&gt; &#123;<span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">1</span>; i &lt;= <span class="number">55</span>; i++) ticket.sale();&#125;, <span class="string">&quot;a&quot;</span>).start();        <span class="keyword">new</span> <span class="title class_">Thread</span>(() -&gt; &#123;<span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">1</span>; i &lt;= <span class="number">55</span>; i++) ticket.sale();&#125;, <span class="string">&quot;b&quot;</span>).start();        <span class="keyword">new</span> <span class="title class_">Thread</span>(() -&gt; &#123;<span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">1</span>; i &lt;= <span class="number">55</span>; i++) ticket.sale();&#125;, <span class="string">&quot;c&quot;</span>).start();    &#125;&#125;</code></pre><p>运行结果，不同的线程抢到票的几率差距很大，线程执行不公平。</p><pre><code class="highlight shell">a 卖出第: 30 还剩下: 29a 卖出第: 29 还剩下: 28a 卖出第: 28 还剩下: 27a 卖出第: 27 还剩下: 26c 卖出第: 26 还剩下: 25c 卖出第: 25 还剩下: 24c 卖出第: 24 还剩下: 23c 卖出第: 23 还剩下: 22c 卖出第: 22 还剩下: 21c 卖出第: 21 还剩下: 20c 卖出第: 20 还剩下: 19c 卖出第: 19 还剩下: 18c 卖出第: 18 还剩下: 17c 卖出第: 17 还剩下: 16c 卖出第: 16 还剩下: 15c 卖出第: 15 还剩下: 14c 卖出第: 14 还剩下: 13c 卖出第: 13 还剩下: 12c 卖出第: 12 还剩下: 11c 卖出第: 11 还剩下: 10c 卖出第: 10 还剩下: 9c 卖出第: 9 还剩下: 8c 卖出第: 8 还剩下: 7c 卖出第: 7 还剩下: 6c 卖出第: 6 还剩下: 5c 卖出第: 5 还剩下: 4c 卖出第: 4 还剩下: 3c 卖出第: 3 还剩下: 2c 卖出第: 2 还剩下: 1c 卖出第: 1 还剩下: 0</code></pre><h3 id="1-2-公平锁"><a href="#1-2-公平锁" class="headerlink" title="1.2 公平锁"></a>1.2 公平锁</h3><p>使用 ReentrantLock 实现公平抢票的案例</p><pre><code class="highlight java"><span class="keyword">class</span> <span class="title class_">Ticket</span> &#123;    <span class="keyword">private</span> <span class="type">int</span> <span class="variable">number</span> <span class="operator">=</span> <span class="number">30</span>;    <span class="keyword">private</span> <span class="type">Lock</span> <span class="variable">lock</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ReentrantLock</span>(<span class="literal">true</span>); <span class="comment">//默认用的是非公平锁，传 true 则为公平锁</span>    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">sale</span><span class="params">()</span> &#123;        lock.lock();        <span class="keyword">try</span> &#123;            <span class="keyword">if</span> (number &gt; <span class="number">0</span>) &#123;                System.out.println(Thread.currentThread().getName() + <span class="string">&quot;\t 卖出第: &quot;</span> + (number--) + <span class="string">&quot;\t 还剩下: &quot;</span> + number);            &#125;        &#125; <span class="keyword">finally</span> &#123;            lock.unlock();        &#125;    &#125;&#125;<span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">SaleTicketDemo</span> &#123;    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;        <span class="type">Ticket</span> <span class="variable">ticket</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Ticket</span>();        <span class="keyword">new</span> <span class="title class_">Thread</span>(() -&gt; &#123;<span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">1</span>; i &lt;= <span class="number">55</span>; i++) ticket.sale();&#125;, <span class="string">&quot;a&quot;</span>).start();        <span class="keyword">new</span> <span class="title class_">Thread</span>(() -&gt; &#123;<span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">1</span>; i &lt;= <span class="number">55</span>; i++) ticket.sale();&#125;, <span class="string">&quot;b&quot;</span>).start();        <span class="keyword">new</span> <span class="title class_">Thread</span>(() -&gt; &#123;<span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">1</span>; i &lt;= <span class="number">55</span>; i++) ticket.sale();&#125;, <span class="string">&quot;c&quot;</span>).start();    &#125;&#125;</code></pre><p>执行结果，每个线程都得到了较为公平的执行机会。</p><pre><code class="highlight shell">a 卖出第: 30 还剩下: 29a 卖出第: 29 还剩下: 28a 卖出第: 28 还剩下: 27a 卖出第: 27 还剩下: 26b 卖出第: 26 还剩下: 25c 卖出第: 25 还剩下: 24a 卖出第: 24 还剩下: 23b 卖出第: 23 还剩下: 22c 卖出第: 22 还剩下: 21a 卖出第: 21 还剩下: 20b 卖出第: 20 还剩下: 19c 卖出第: 19 还剩下: 18a 卖出第: 18 还剩下: 17b 卖出第: 17 还剩下: 16c 卖出第: 16 还剩下: 15a 卖出第: 15 还剩下: 14b 卖出第: 14 还剩下: 13c 卖出第: 13 还剩下: 12a 卖出第: 12 还剩下: 11b 卖出第: 11 还剩下: 10c 卖出第: 10 还剩下: 9a 卖出第: 9 还剩下: 8b 卖出第: 8 还剩下: 7c 卖出第: 7 还剩下: 6a 卖出第: 6 还剩下: 5b 卖出第: 5 还剩下: 4c 卖出第: 4 还剩下: 3a 卖出第: 3 还剩下: 2b 卖出第: 2 还剩下: 1c 卖出第: 1 还剩下: 0</code></pre><h2 id="2-公平锁-非公平锁-概念解析"><a href="#2-公平锁-非公平锁-概念解析" class="headerlink" title="2. 公平锁&#x2F;非公平锁 概念解析"></a>2. 公平锁&#x2F;非公平锁 概念解析</h2><ul><li>公平锁：是指多个线程按照申请锁的顺序来获取锁，这里类似于排队买票，先来的人先买，后来的人再队尾排着，这是公平的—– Lock lock &#x3D; new ReentrantLock(true)—表示公平锁，先来先得。</li><li>非公平锁：是指多个线程获取锁的顺序并不是按照申请的顺序，有可能后申请的线程比先申请的线程优先获取锁，在高并发环境下，有可能造成优先级反转或者饥饿的状态（某个线程一直得不到锁）—- Lock lock &#x3D; new  ReentrantLock(false)—表示非公平锁，后来的也可能先获得锁，默认为非公平锁。</li></ul><h2 id="3-关于-公平锁-非公平锁-的相关问题"><a href="#3-关于-公平锁-非公平锁-的相关问题" class="headerlink" title="3. 关于 公平锁&#x2F;非公平锁 的相关问题"></a>3. 关于 公平锁&#x2F;非公平锁 的相关问题</h2><h3 id="3-1-为什么会有公平锁-非公平锁的设计为什么默认非公平？"><a href="#3-1-为什么会有公平锁-非公平锁的设计为什么默认非公平？" class="headerlink" title="3.1 为什么会有公平锁&#x2F;非公平锁的设计为什么默认非公平？"></a>3.1 为什么会有公平锁&#x2F;非公平锁的设计为什么默认非公平？</h3><ul><li>恢复挂起的线程到真正锁的获取还是有时间差的，从开发人员来看这个时间微乎其微，但是从CPU的角度来看，这个时间差存在的还是很明显的。所以非公平锁能更充分的利用CPU 的时间片，尽量减少 CPU 空闲状态时间。</li><li>使用多线程很重要的考量点是线程切换的开销，当采用非公平锁时，当1个线程请求锁获取同步状态，然后释放同步状态，因为不需要考虑是否还有前驱节点，所以刚释放锁的线程在此刻再次获取同步状态的概率就变得非常大，所以就减少了线程的开销。</li></ul><h3 id="3-2-使⽤公平锁会有什么问题"><a href="#3-2-使⽤公平锁会有什么问题" class="headerlink" title="3.2 使⽤公平锁会有什么问题"></a>3.2 使⽤公平锁会有什么问题</h3><p>公平锁保证了排队的公平性，非公平锁霸气的忽视这个规则，所以就有可能导致排队的长时间在排队，也没有机会获取到锁，这就是传说中的 “锁饥饿”</p><h3 id="3-3-什么时候用公平？什么时候用非公平？"><a href="#3-3-什么时候用公平？什么时候用非公平？" class="headerlink" title="3.3 什么时候用公平？什么时候用非公平？"></a>3.3 什么时候用公平？什么时候用非公平？</h3><ul><li>如果为了更高的吞吐量，很显然非公平锁是比较合适的，因为节省很多线程切换时间，吞吐量自然就上去了；</li><li>否则那就用公平锁，大家公平使用。</li></ul><h1 id="七、可重入锁"><a href="#七、可重入锁" class="headerlink" title="七、可重入锁"></a>七、可重入锁</h1><h2 id="1-概念解析"><a href="#1-概念解析" class="headerlink" title="1. 概念解析"></a>1. 概念解析</h2><p><strong>可重入锁又名递归锁</strong></p><ul><li><p>是指在同一个线程在外层方法获取锁的时候，再进入该线程的内层方法会自动获取锁(前提，锁对象得是同一个对象)，不会因为之前已经获取过还没释放而阻塞。</p></li><li><p>如果是1个有 <code>synchronized</code> 修饰的递归调用方法，程序第2次进入被自己阻塞了这样递归方法也就不能继续执行下去了。所以Java中 <code>ReentrantLock</code> 和<code>synchronized</code> 都是可重入锁，可重入锁的一个优点是可一定程度避免死锁。</p></li></ul><h2 id="2-可重入锁种类"><a href="#2-可重入锁种类" class="headerlink" title="2. 可重入锁种类"></a>2. 可重入锁种类</h2><h3 id="2-1-隐式锁"><a href="#2-1-隐式锁" class="headerlink" title="2.1 隐式锁"></a>2.1 隐式锁</h3><p>隐式锁（即synchronized关键字使用的锁）默认是可重入锁</p><ul><li><p>作用于同步代码块</p><pre><code class="highlight java"><span class="keyword">static</span> <span class="type">Object</span> <span class="variable">objectLock</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Object</span>();<span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">syncBlock</span><span class="params">()</span>&#123;    <span class="keyword">new</span> <span class="title class_">Thread</span>(() -&gt; &#123;        <span class="keyword">synchronized</span> (objectLock) &#123;<span class="comment">// lock</span>            System.out.println(<span class="string">&quot;-----外层&quot;</span>);            <span class="keyword">synchronized</span> (objectLock)            &#123;                System.out.println(<span class="string">&quot;-----中层&quot;</span>);                <span class="keyword">synchronized</span> (objectLock)                &#123;                    System.out.println(<span class="string">&quot;-----内层&quot;</span>);                &#125;            &#125;        &#125;<span class="comment">//unlock</span>    &#125;,<span class="string">&quot;t1&quot;</span>).start();&#125;</code></pre><p>打印结果：</p><pre><code class="highlight plaintext">-----外层-----中层-----内层</code></pre></li><li><p>作用于同步方法中</p><pre><code class="highlight java"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ReEntryLockDemo</span>&#123;    <span class="keyword">public</span> <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title function_">m1</span><span class="params">()</span>    &#123;        <span class="comment">//指的是可重复可递归调用的锁，在外层使用之后，在内层仍然可以使用，并且不发生死锁，这样的锁就叫做可重入锁</span>        System.out.println(Thread.currentThread().getName()+<span class="string">&quot;\t&quot;</span>+<span class="string">&quot;-----come in m1&quot;</span>);        m2();        System.out.println(Thread.currentThread().getName()+<span class="string">&quot;\t-----end m1&quot;</span>);    &#125;    <span class="keyword">public</span> <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title function_">m2</span><span class="params">()</span>    &#123;        System.out.println(<span class="string">&quot;-----m2&quot;</span>);        m3();    &#125;    <span class="keyword">public</span> <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title function_">m3</span><span class="params">()</span>    &#123;        System.out.println(<span class="string">&quot;-----m3&quot;</span>);    &#125;    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span>    &#123;        <span class="type">ReEntryLockDemo</span> <span class="variable">reEntryLockDemo</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ReEntryLockDemo</span>();        reEntryLockDemo.m1();    &#125;&#125;<span class="comment">/**</span><span class="comment"> * main  -----come in m1</span><span class="comment"> * -----m2</span><span class="comment"> * -----m3</span><span class="comment"> * main  -----end m1</span><span class="comment"> */</span></code></pre><p>打印结果：</p><pre><code class="highlight java">main  -----come in m1-----m2-----m3main  -----end m1</code></pre></li><li></li></ul><h3 id="2-2-显式锁"><a href="#2-2-显式锁" class="headerlink" title="2.2 显式锁"></a>2.2 显式锁</h3><p>显式锁（即Lock）也有 ReentrantLock 这样的可重入锁。</p><ul><li>ReentrantLock 实现的显示可重入锁</li></ul><pre><code class="highlight java"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;    <span class="type">Lock</span> <span class="variable">lock</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ReentrantLock</span>();    <span class="keyword">new</span> <span class="title class_">Thread</span>(() -&gt; &#123;        lock.lock();        <span class="keyword">try</span> &#123;            System.out.println(Thread.currentThread().getName() + <span class="string">&quot;\t&quot;</span> + <span class="string">&quot;-----外层&quot;</span>);            lock.lock();            <span class="keyword">try</span> &#123;                System.out.println(Thread.currentThread().getName() + <span class="string">&quot;\t&quot;</span> + <span class="string">&quot;-----内层&quot;</span>);            &#125; <span class="keyword">finally</span> &#123;                lock.unlock();            &#125;        &#125; <span class="keyword">finally</span> &#123;            lock.unlock();        &#125;    &#125;, <span class="string">&quot;t1&quot;</span>).start();    <span class="keyword">new</span> <span class="title class_">Thread</span>(() -&gt; &#123;        lock.lock();        <span class="keyword">try</span> &#123;            System.out.println(<span class="string">&quot;------22222&quot;</span>);        &#125; <span class="keyword">finally</span> &#123;            lock.unlock();        &#125;    &#125;, <span class="string">&quot;t2&quot;</span>).start();&#125;</code></pre><p>打印结果：</p><pre><code class="highlight shell">t1-----外层t1-----内层------22222</code></pre><h2 id="3-Synchronized的可重入锁实现机理"><a href="#3-Synchronized的可重入锁实现机理" class="headerlink" title="3. Synchronized的可重入锁实现机理"></a>3. Synchronized的可重入锁实现机理</h2><p>再看 <code>ObjectMoitor.hpp</code></p><pre><code class="highlight cpp"><span class="number">140</span>行  <span class="built_in">ObjectMonitor</span>() &#123;    _header       = <span class="literal">NULL</span>;    _count        = <span class="number">0</span>; <span class="comment">//用来记录该线程获取锁的次数</span>    _waiters      = <span class="number">0</span>,    _recursions   = <span class="number">0</span>; <span class="comment">//锁的重入次数</span>    _object       = <span class="literal">NULL</span>;    _owner        = <span class="literal">NULL</span>; <span class="comment">//------最重要的----指向持有ObjectMonitor对象的线程，记录哪个线程持有了我</span>    _WaitSet      = <span class="literal">NULL</span>; <span class="comment">//存放处于wait状态的线程队列</span>    _WaitSetLock  = <span class="number">0</span> ;    _Responsible  = <span class="literal">NULL</span> ;    _succ         = <span class="literal">NULL</span> ;    _cxq          = <span class="literal">NULL</span> ;    FreeNext      = <span class="literal">NULL</span> ;    _EntryList    = <span class="literal">NULL</span> ; <span class="comment">//存放处于等待锁block状态的线程队列</span>    _SpinFreq     = <span class="number">0</span> ;    _SpinClock    = <span class="number">0</span> ;    OwnerIsThread = <span class="number">0</span> ;    _previous_owner_tid = <span class="number">0</span>;  &#125;</code></pre><ul><li><code>ObjectMoitor.hpp</code><strong>底层</strong>：每个锁对象拥有一个锁计数器和一个指向持有该锁的线程的指针。<code>_count</code> <code>_owner</code></li><li><strong>首次加锁</strong>：当执行<code>monitorenter</code>时，如果目标锁对象的计数器为零，那么说明它没有被其他线程所持有，Java虚拟机会将该锁对象的持有线程设置为当前线程，并且将其计数器<code>加1</code>。</li><li><strong>重入</strong>：在目标锁对象的计数器不为零的情况下，如果锁对象的持有线程是当前线程，那么 Java 虚拟机可以将其计数器<code>加1</code>，否则需要等待，直至持有线程释放该锁。</li><li><strong>释放锁</strong>：当执行monitorexit时，Java虚拟机则需将锁对象的计数器减1。计数器为零代表锁已被释放。</li></ul><h2 id="4-死锁及排查"><a href="#4-死锁及排查" class="headerlink" title="4. 死锁及排查"></a>4. 死锁及排查</h2><h3 id="4-1-死锁是什么"><a href="#4-1-死锁是什么" class="headerlink" title="4.1 死锁是什么"></a>4.1 死锁是什么</h3><p>死锁是指两个或两个以上的线程在执行过程中,因争夺资源而造成的一种互相等待的现象,若无外力干涉那它们都将无法推进下去，如果系统资源充足，进程的资源请求都能够得到满足，死锁出现的可能性就很低，否则就会因争夺有限的资源而陷入死锁。</p><p><img src="https://raw.githubusercontent.com/GeorgeChan95/blogimg/master/img/2024/09/21/20240921-163418.png" alt="死锁"></p><h3 id="4-2-死锁产生的原因"><a href="#4-2-死锁产生的原因" class="headerlink" title="4.2 死锁产生的原因"></a>4.2 死锁产生的原因</h3><ul><li>系统资源不足</li><li>进程运行推进的顺序不合适</li><li>资源分配不当</li></ul><h3 id="4-3-死锁代码案例"><a href="#4-3-死锁代码案例" class="headerlink" title="4.3 死锁代码案例"></a>4.3 死锁代码案例</h3><pre><code class="highlight java"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">DeadLockDemo</span> &#123;    <span class="keyword">static</span> <span class="type">Object</span> <span class="variable">lockA</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Object</span>();    <span class="keyword">static</span> <span class="type">Object</span> <span class="variable">lockB</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Object</span>();    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;        <span class="type">Thread</span> <span class="variable">a</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Thread</span>(() -&gt; &#123;            <span class="keyword">synchronized</span> (lockA) &#123;                System.out.println(Thread.currentThread().getName() + <span class="string">&quot;\t&quot;</span> + <span class="string">&quot; 自己持有A锁，期待获得B锁&quot;</span>);                <span class="keyword">try</span> &#123;                    TimeUnit.SECONDS.sleep(<span class="number">1</span>);                &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;                    e.printStackTrace();                &#125;                <span class="keyword">synchronized</span> (lockB) &#123;                    System.out.println(Thread.currentThread().getName() + <span class="string">&quot;\t 获得B锁成功&quot;</span>);                &#125;            &#125;        &#125;, <span class="string">&quot;a&quot;</span>);        a.start();        <span class="keyword">new</span> <span class="title class_">Thread</span>(() -&gt; &#123;            <span class="keyword">synchronized</span> (lockB) &#123;                System.out.println(Thread.currentThread().getName() + <span class="string">&quot;\t&quot;</span> + <span class="string">&quot; 自己持有B锁，期待获得A锁&quot;</span>);                <span class="keyword">try</span> &#123;                    TimeUnit.SECONDS.sleep(<span class="number">1</span>);                &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;                    e.printStackTrace();                &#125;                <span class="keyword">synchronized</span> (lockA) &#123;                    System.out.println(Thread.currentThread().getName() + <span class="string">&quot;\t 获得A锁成功&quot;</span>);                &#125;            &#125;        &#125;, <span class="string">&quot;b&quot;</span>).start();    &#125;&#125;</code></pre><p>运行结果：</p><pre><code class="highlight shell">a 自己持有A锁，期待获得B锁b 自己持有B锁，期待获得A锁</code></pre><p>程序运行到此没有停止，一直等待着……</p><h3 id="4-4-如何排查死锁"><a href="#4-4-如何排查死锁" class="headerlink" title="4.4 如何排查死锁"></a>4.4 如何排查死锁</h3><h4 id="4-4-1-命令行"><a href="#4-4-1-命令行" class="headerlink" title="4.4.1 命令行"></a>4.4.1 命令行</h4><ul><li><code>jps -l</code> 查看当前进程运行状况</li><li><code>jstack 进程编号</code> 查看该进程信息</li></ul><pre><code class="highlight shell">PS F:\&gt; jps -l29104 33360 com.atguigu.juc.locks.DeadLockDemo11172 org.jetbrains.jps.cmdline.Launcher27412 org.jetbrains.idea.maven.server.RemoteMavenServer3630148 org.jetbrains.idea.maven.server.RemoteMavenServer3645796 sun.tools.jps.Jps<span class="meta prompt_"></span><span class="meta prompt_">#</span><span class="language-bash"><span class="comment">####################################################################################</span></span>PS F:\&gt; jstack 333602024-09-21 16:39:01Full thread dump Java HotSpot(TM) 64-Bit Server VM (25.241-b07 mixed mode):&quot;Finalizer&quot; #3 daemon prio=8 os_prio=1 tid=0x0000000026eea000 nid=0x8df0 in Object.wait() [0x000000002a8ff000]   java.lang.Thread.State: WAITING (on object monitor)        at java.lang.Object.wait(Native Method)        - waiting on &lt;0x0000000716508ee0&gt; (a java.lang.ref.ReferenceQueue$Lock)        at java.lang.ref.ReferenceQueue.remove(ReferenceQueue.java:144)        - locked &lt;0x0000000716508ee0&gt; (a java.lang.ref.ReferenceQueue$Lock)        at java.lang.ref.ReferenceQueue.remove(ReferenceQueue.java:165)        at java.lang.ref.Finalizer$FinalizerThread.run(Finalizer.java:216)&quot;Reference Handler&quot; #2 daemon prio=10 os_prio=2 tid=0x0000000028ba8000 nid=0x3cb4 in Object.wait() [0x000000002a7ff000]   java.lang.Thread.State: WAITING (on object monitor)        at java.lang.Object.wait(Native Method)        - waiting on &lt;0x0000000716506c00&gt; (a java.lang.ref.Reference$Lock)        at java.lang.Object.wait(Object.java:502)        at java.lang.ref.Reference.tryHandlePending(Reference.java:191)        - locked &lt;0x0000000716506c00&gt; (a java.lang.ref.Reference$Lock)        at java.lang.ref.Reference$ReferenceHandler.run(Reference.java:153)&quot;VM Periodic Task Thread&quot; os_prio=2 tid=0x000000002b8e4000 nid=0x1378 waiting on conditionJNI global references: 317Found one Java-level deadlock:=============================&quot;b&quot;:  waiting to lock monitor 0x0000000028bab9f8 (object 0x00000007166f0fe8, a java.lang.Object),  which is held by &quot;a&quot;&quot;a&quot;:  waiting to lock monitor 0x0000000028bae338 (object 0x00000007166f0ff8, a java.lang.Object),  which is held by &quot;b&quot;Java stack information for the threads listed above:===================================================&quot;b&quot;:        at com.atguigu.juc.locks.DeadLockDemo.lambda$main$1(DeadLockDemo.java:44)        - waiting to lock &lt;0x00000007166f0fe8&gt; (a java.lang.Object)        - locked &lt;0x00000007166f0ff8&gt; (a java.lang.Object)        at com.atguigu.juc.locks.DeadLockDemo$$Lambda$2/1199823423.run(Unknown Source)        at java.lang.Thread.run(Thread.java:748)&quot;a&quot;:        at com.atguigu.juc.locks.DeadLockDemo.lambda$main$0(DeadLockDemo.java:27)        - waiting to lock &lt;0x00000007166f0ff8&gt; (a java.lang.Object)        - locked &lt;0x00000007166f0fe8&gt; (a java.lang.Object)        at com.atguigu.juc.locks.DeadLockDemo$$Lambda$1/1342443276.run(Unknown Source)        at java.lang.Thread.run(Thread.java:748)Found 1 deadlock.</code></pre><h4 id="4-4-2-图形化工具"><a href="#4-4-2-图形化工具" class="headerlink" title="4.4.2 图形化工具"></a>4.4.2 图形化工具</h4><p>这里使用JDK 自带的 <code>jconsole</code> 演示，此工具在jdk的安装的 <code>bin目录</code> 下，双击 jconsole.exe 打开即可。</p><p><img src="https://raw.githubusercontent.com/GeorgeChan95/blogimg/master/img/2024/09/21/20240921-164427.png" alt="image-20240921164426956"></p><h1 id="八、总结"><a href="#八、总结" class="headerlink" title="八、总结"></a>八、总结</h1><p>指针指向monitor对象（也称为管程或监视器锁）的起始地址。每个对象都存在着一个monitor与之关联，当一个monitor被某个线程持有后，它便处于锁定状态。在Java虚拟机(HotSpot)中，monitor是由ObjectMonitor实现的，其主要数据结构如下（位于HotSpot虚拟机源码ObjectMonitor.hpp,C++实现的）<br><img src="https://raw.githubusercontent.com/GeorgeChan95/blogimg/master/img/2024/09/21/20240921-165034.png" alt="锁"></p>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;一、乐观锁和悲观锁&quot;&gt;&lt;a href=&quot;#一、乐观锁和悲观锁&quot; class=&quot;headerlink&quot; title=&quot;一、乐观锁和悲观锁&quot;&gt;&lt;/a&gt;一、乐观锁和悲观锁&lt;/h1&gt;&lt;h2 id=&quot;1-悲观锁&quot;&gt;&lt;a href=&quot;#1-悲观锁&quot; class=&quot;header</summary>
      
    
    
    
    <category term="JUC" scheme="https://georgechan95.github.io/categories/JUC/"/>
    
    
    <category term="juc" scheme="https://georgechan95.github.io/tags/juc/"/>
    
    <category term="java" scheme="https://georgechan95.github.io/tags/java/"/>
    
  </entry>
  
  <entry>
    <title>02-JUC进阶-CompletableFuture</title>
    <link href="https://georgechan95.github.io/blog/7e2d78eb.html"/>
    <id>https://georgechan95.github.io/blog/7e2d78eb.html</id>
    <published>2024-09-18T14:50:00.000Z</published>
    <updated>2024-09-20T12:20:12.477Z</updated>
    
    <content type="html"><![CDATA[<h1 id="一、Future接口概述"><a href="#一、Future接口概述" class="headerlink" title="一、Future接口概述"></a>一、Future接口概述</h1><p>Future接口（FutureTask实现类）定义了操作异步任务执行一些方法，如获取异步任务的执行结果、取消异步任务的执行、判断任务是否被取消、判断任务执行是否完毕等。</p><p>举例：比如主线程让一个子线程去执行任务，子线程可能比较耗时，启动子线程开始执行任务后，主线程就去做其他事情了，忙完其他事情或者先执行完，过了一会再才去获取子任务的执行结果或变更的任务状态。</p><h1 id="二、Future接口实现类FutureTask"><a href="#二、Future接口实现类FutureTask" class="headerlink" title="二、Future接口实现类FutureTask"></a>二、Future接口实现类FutureTask</h1><h2 id="1-Future接口能干什么"><a href="#1-Future接口能干什么" class="headerlink" title="1. Future接口能干什么"></a>1. Future接口能干什么</h2><p>Future是 Java5 新加的一个接口，它提供一种异步并行计算的功能，如果主线程需要执行一个很耗时的计算任务，我们会就可以通过Future把这个任务放进异步线程中执行，主线程继续处理其他任务或者先行结束，再通过Future获取计算结果。</p><p>Future接口定义了操作异步任务执行一些方法，如获取异步任务的执行结果、取消任务的执行、判断任务是否被取消、判断任务执行是否完毕等。</p><h2 id="2-Future接口相关架构"><a href="#2-Future接口相关架构" class="headerlink" title="2. Future接口相关架构"></a>2. Future接口相关架构</h2><p><img src="https://raw.githubusercontent.com/GeorgeChan95/blogimg/master/img/2024/09/18/20240918-171237.png" alt="Future接口架构"></p><ul><li><p>目的：异步多线程任务执行且返回有结果，三个特点：多线程、有返回、异步任务（班长为老师去买水作为新启动的异步多线程任务且买到水有结果返回）</p></li><li><p>代码实现：Runnable接口+Callable接口+Future接口和FutureTask实现类。</p><pre><code class="highlight java"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">FutureTaskDemo3</span> &#123;    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> ExecutionException, InterruptedException &#123;        FutureTask&lt;String&gt; futureTask = <span class="keyword">new</span> <span class="title class_">FutureTask</span>&lt;&gt;(<span class="keyword">new</span> <span class="title class_">MyThread</span>());        <span class="type">Thread</span> <span class="variable">thread</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Thread</span>(futureTask, <span class="string">&quot;t1&quot;</span>);        <span class="comment">// 启动一个新的线程</span>        thread.start();        System.out.println(futureTask.get());    &#125;&#125;<span class="keyword">class</span> <span class="title class_">MyThread</span> <span class="keyword">implements</span> <span class="title class_">Callable</span>&lt;String&gt; &#123;    <span class="meta">@Override</span>    <span class="keyword">public</span> String <span class="title function_">call</span><span class="params">()</span> <span class="keyword">throws</span> Exception &#123;        System.out.println(Thread.currentThread().getName() + <span class="string">&quot; come in ......&quot;</span>);        <span class="keyword">return</span> <span class="string">&quot;Hello Callable&quot;</span>;    &#125;&#125;</code></pre></li></ul><h2 id="3-Future编码实战和优缺点分析"><a href="#3-Future编码实战和优缺点分析" class="headerlink" title="3. Future编码实战和优缺点分析"></a>3. Future编码实战和优缺点分析</h2><p><strong>优点</strong></p><p>Future+线程池异步多线程任务配合，能显著提高程序的运行效率。</p><p><strong>缺点</strong></p><ul><li>get() 阻塞—一旦调用get()方法求结果，一旦调用不见不散，非要等到结果才会离开，不管你是否计算完成，如果没有计算完成容易程序堵塞。</li></ul>  <pre><code class="highlight java"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">FutureTaskDemo1</span> &#123;    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> ExecutionException, InterruptedException, TimeoutException &#123;        FutureTask&lt;String&gt; futureTask = <span class="keyword">new</span> <span class="title class_">FutureTask</span>&lt;&gt;(() -&gt; &#123;            System.out.println(<span class="string">&quot;-----come in FutureTask&quot;</span>);            <span class="keyword">try</span> &#123;                TimeUnit.SECONDS.sleep(<span class="number">3</span>);            &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;                e.printStackTrace();            &#125;            <span class="keyword">return</span> <span class="string">&quot;&quot;</span> + ThreadLocalRandom.current().nextInt(<span class="number">100</span>);        &#125;);        <span class="type">Thread</span> <span class="variable">t1</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Thread</span>(futureTask, <span class="string">&quot;t1&quot;</span>);        t1.start();        <span class="comment">//3秒钟后才出来结果，还没有计算你提前来拿(只要一调用get方法，对于结果就是不见不散，会导致阻塞)</span>        <span class="comment">//System.out.println(Thread.currentThread().getName()+&quot;\t&quot;+futureTask.get());</span>        <span class="comment">//3秒钟后才出来结果，我只想等待1秒钟，过时不候</span>        System.out.println(Thread.currentThread().getName() + <span class="string">&quot;\t&quot;</span> + futureTask.get(<span class="number">1L</span>, TimeUnit.SECONDS));        System.out.println(Thread.currentThread().getName() + <span class="string">&quot;\t&quot;</span> + <span class="string">&quot; run... here&quot;</span>);    &#125;&#125;</code></pre><ul><li>isDone() 轮询—轮询的方式会耗费无谓的cpu资源，而且也不见得能及时得到计算结果，如果想要异步获取结果，通常会以轮询的方式去获取结果，尽量不要阻塞。</li></ul>  <pre><code class="highlight java"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">FutureTaskDemo2</span> &#123;    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> ExecutionException, InterruptedException &#123;        FutureTask&lt;String&gt; futureTask = <span class="keyword">new</span> <span class="title class_">FutureTask</span>&lt;&gt;(() -&gt; &#123;            System.out.println(<span class="string">&quot;-----come in FutureTask&quot;</span>);            <span class="keyword">try</span> &#123;                TimeUnit.SECONDS.sleep(<span class="number">3</span>);            &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;                e.printStackTrace();            &#125;            <span class="keyword">return</span> <span class="string">&quot;&quot;</span> + ThreadLocalRandom.current().nextInt(<span class="number">100</span>);        &#125;);        <span class="keyword">new</span> <span class="title class_">Thread</span>(futureTask, <span class="string">&quot;t1&quot;</span>).start();        System.out.println(Thread.currentThread().getName() + <span class="string">&quot;\t&quot;</span> + <span class="string">&quot;线程完成任务&quot;</span>);        <span class="comment">/**</span><span class="comment">         * 用于阻塞式获取结果,如果想要异步获取结果,通常都会以轮询的方式去获取结果</span><span class="comment">         */</span>        <span class="keyword">while</span> (<span class="literal">true</span>) &#123;            <span class="keyword">if</span> (futureTask.isDone()) &#123;                System.out.println(futureTask.get());                <span class="keyword">break</span>;            &#125;        &#125;    &#125;&#125;</code></pre><p><strong>结论：</strong>Future对于结果的获取不是很友好，只能通过阻塞或轮询的方式得到任务的结果。</p><h2 id="4-完成复杂的任务"><a href="#4-完成复杂的任务" class="headerlink" title="4. 完成复杂的任务"></a>4. 完成复杂的任务</h2><ul><li><p>回调通知（Future支持）</p><ul><li>应对Future的完成时间，完成了可以告诉我，也就是我们的回调通知</li><li>通过轮询的方式去判断任务是否完成这样非常占cpu并且代码也不优雅</li></ul></li><li><p>创建异步任务：Future+线程池组合</p><pre><code class="highlight java"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">FutureTaskDemo4</span> &#123;    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> ExecutionException, InterruptedException &#123;        <span class="comment">// 创建线程池</span>        <span class="type">ExecutorService</span> <span class="variable">executorService</span> <span class="operator">=</span> Executors.newFixedThreadPool(<span class="number">5</span>);                FutureTask&lt;String&gt; futureTask = <span class="keyword">new</span> <span class="title class_">FutureTask</span>&lt;&gt;(() -&gt; &#123;            System.out.println(Thread.currentThread().getName() + <span class="string">&quot;-----come in FutureTask&quot;</span>);            <span class="keyword">try</span> &#123;                TimeUnit.SECONDS.sleep(<span class="number">3</span>);            &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;                e.printStackTrace();            &#125;            <span class="keyword">return</span> <span class="string">&quot;&quot;</span> + ThreadLocalRandom.current().nextInt(<span class="number">100</span>);        &#125;);        <span class="comment">// 异步提交任务</span>        executorService.submit(futureTask);        System.out.println(Thread.currentThread().getName() + <span class="string">&quot;\t&quot;</span> + <span class="string">&quot;线程完成任务&quot;</span>);        <span class="comment">/**</span><span class="comment">         * 用于阻塞式获取结果,如果想要异步获取结果,通常都会以轮询的方式去获取结果</span><span class="comment">         */</span>        <span class="keyword">while</span> (<span class="literal">true</span>) &#123;            <span class="keyword">if</span> (futureTask.isDone()) &#123;                System.out.println(futureTask.get());                <span class="keyword">break</span>;            &#125;        &#125;        <span class="comment">// 关闭线程池</span>        executorService.shutdown();    &#125;&#125;</code></pre></li><li><p>多个任务前后依赖可以组合处理（Future不支持）</p><ul><li>想将多个异步任务的结果组合起来，后一个异步任务的计算结果需要前一个异步任务的值</li><li>想将两个或多个异步计算合并成为一个异步计算，这几个异步计算互相独立，同时后面这个又依赖前一个处理的结果</li></ul></li><li><p>对计算速度选最快的（Future不支持）</p><ul><li>当Future集合中某个任务最快结束时，返回结果，返回第一名处理结果</li></ul></li></ul><p><strong>结论</strong></p><ul><li>对于简单的业务场景使用 Future 完全 ok</li><li>对于复杂业务场景，使用 Future 之前提供的 API 处理起来不够优雅，这时候需要使用 CompletableFuture 以声明式的方式优雅的处理这些需求。</li><li>Future能干的，CompletableFuture 都能干</li></ul><h1 id="三、CompletableFuture对Future的改进"><a href="#三、CompletableFuture对Future的改进" class="headerlink" title="三、CompletableFuture对Future的改进"></a>三、CompletableFuture对Future的改进</h1><h2 id="1-CompletableFuture为什么会出现"><a href="#1-CompletableFuture为什么会出现" class="headerlink" title="1. CompletableFuture为什么会出现"></a>1. CompletableFuture为什么会出现</h2><ul><li>get() 方法在 Future 计算完成之前会一直处在阻塞状态下，阻塞的方式和异步编程的设计理念相违背。</li><li>isDone() 方法容易耗费 cpu 资源（cpu空转），</li><li>对于真正的异步处理我们希望是可以通过传入回调函数，在Future结束时自动调用该回调函数，这样，我们就不用等待结果</li></ul><p>jdk8 设计出 CompletableFuture，CompletableFuture 提供了一种观察者模式类似的机制，可以让任务执行完成后通知监听的一方。</p><h2 id="2-CompletableFuture-和-CompletionStage-介绍"><a href="#2-CompletableFuture-和-CompletionStage-介绍" class="headerlink" title="2. CompletableFuture 和 CompletionStage 介绍"></a>2. CompletableFuture 和 CompletionStage 介绍</h2><p><strong>类架构说明</strong>：</p><p><img src="https://raw.githubusercontent.com/GeorgeChan95/blogimg/master/img/2024/09/19/20240919-093123.png" alt="CompletableFuture"></p><p><img src="https://raw.githubusercontent.com/GeorgeChan95/blogimg/master/img/2024/09/19/20240919-093420.png" alt="CompletableFuture"></p><ul><li><strong>接口CompletionStage</strong><ul><li>代表异步计算过程中的某一个阶段，一个阶段完成以后可能会触发另外一个阶段。<ul><li>有些类似Linux系统的管道分隔符传参数</li></ul></li><li>一个阶段的执行可能是被单个阶段的完成触发，也可能是由多个阶段一起触发</li><li>一个阶段的计算执行可以是一个 function, Consumer 或者 Runnable。<ul><li>比如: <code>stage.thenApply(x -&gt; square(x).thenAccept(x -&gt; System.out.print(x)).thenRun(0)-&gt; system.out.println())</code></li></ul></li></ul></li><li><strong>类CompletableFuture</strong><ul><li>在Java8中，CompletableFuture 提供了非常强大的 Future 的扩展功能，可以帮助我们简化异步编程的复杂性，并且提供了函数式编程的能力，可以通过回调的方式处理计算结果，也提供了转换和组合 CompletableFuture 的方法,</li><li>它可能代表一个明确完成的 Future，也有可能代表一个完成阶段 (CompletionStage)，它支持在计算完成以后触发一些函数或执行某些动作。</li><li>它实现了 Future 和 CompletionStage 接口</li></ul></li></ul><h2 id="3-四个核心静态方法，创建异步任务"><a href="#3-四个核心静态方法，创建异步任务" class="headerlink" title="3. 四个核心静态方法，创建异步任务"></a>3. 四个核心静态方法，创建异步任务</h2><p>四个静态构造方法</p><p><img src="https://raw.githubusercontent.com/GeorgeChan95/blogimg/master/img/2024/09/19/20240919-094354.png" alt="CompletableFuture静态方法"></p><p><strong>对于上述Executor参数说明：若没有指定，则使用默认的 <code>ForkJoinPoolCommonPool()</code> 作为它的线程池执行异步代码，如果指定线程池，则使用我们自定义的或者特别指定的线程池执行异步代码</strong></p><h3 id="3-1-四个静态方法演示"><a href="#3-1-四个静态方法演示" class="headerlink" title="3.1 四个静态方法演示"></a>3.1 四个静态方法演示</h3><pre><code class="highlight java"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">CompletableFutureBuildDemo</span> &#123;    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> ExecutionException, InterruptedException &#123;        <span class="comment">// 自定义线程池</span>        <span class="type">ThreadPoolExecutor</span> <span class="variable">threadPoolExecutor</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ThreadPoolExecutor</span>(                <span class="number">1</span>,                <span class="number">20</span>,                <span class="number">1L</span>,                TimeUnit.SECONDS,                <span class="keyword">new</span> <span class="title class_">LinkedBlockingQueue</span>&lt;&gt;(<span class="number">50</span>),                Executors.defaultThreadFactory(),                <span class="keyword">new</span> <span class="title class_">ThreadPoolExecutor</span>.AbortPolicy());        <span class="comment">// 无返回值，默认线程池</span>        CompletableFuture&lt;Void&gt; future1 = CompletableFuture.runAsync(() -&gt; &#123;            <span class="keyword">try</span> &#123;                TimeUnit.SECONDS.sleep(<span class="number">1</span>);            &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;                <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">RuntimeException</span>(e);            &#125;            System.out.println(Thread.currentThread().getName() + <span class="string">&quot;无返回值，默认线程池：ForkJoinPool&quot;</span>);        &#125;);        System.out.println(<span class="string">&quot;future1 ==&gt; &quot;</span> + future1.get());        <span class="comment">/*</span><span class="comment">        * 打印：</span><span class="comment">        ForkJoinPool.commonPool-worker-1无返回值，默认线程池：ForkJoinPool</span><span class="comment">        future1 ==&gt; null</span><span class="comment">        * */</span>        System.out.println(<span class="string">&quot;----------------------------------------------------------&quot;</span>);        <span class="comment">// 无返回值，自定义线程池</span>        CompletableFuture&lt;Void&gt; future2 = CompletableFuture.runAsync(() -&gt; &#123;            <span class="keyword">try</span> &#123;                TimeUnit.SECONDS.sleep(<span class="number">1</span>);            &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;                <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">RuntimeException</span>(e);            &#125;            System.out.println(Thread.currentThread().getName() + <span class="string">&quot;无返回值，自定义线程池&quot;</span>);        &#125;, threadPoolExecutor);        System.out.println(<span class="string">&quot;future2 ==&gt; &quot;</span> + future2.get());        <span class="comment">/*</span><span class="comment">        * 打印：</span><span class="comment">        pool-1-thread-1无返回值，自定义线程池</span><span class="comment">        future2 ==&gt; null</span><span class="comment">        * */</span>        System.out.println(<span class="string">&quot;----------------------------------------------------------&quot;</span>);        CompletableFuture&lt;String&gt; future3 = CompletableFuture.supplyAsync(() -&gt; &#123;            <span class="keyword">try</span> &#123;                TimeUnit.SECONDS.sleep(<span class="number">1</span>);            &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;                <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">RuntimeException</span>(e);            &#125;            System.out.println(Thread.currentThread().getName() + <span class="string">&quot;有返回值，默认线程池：ForkJoinPool&quot;</span>);            <span class="keyword">return</span> <span class="string">&quot;有返回值，默认线程池：ForkJoinPool&quot;</span>;        &#125;);        System.out.println(<span class="string">&quot;future3 ==&gt; &quot;</span> + future3.get());        <span class="comment">/*</span><span class="comment">        * 打印：</span><span class="comment">        ForkJoinPool.commonPool-worker-1有返回值，默认线程池：ForkJoinPool</span><span class="comment">        future3 ==&gt; 有返回值，默认线程池：ForkJoinPool</span><span class="comment">        * */</span>        System.out.println(<span class="string">&quot;----------------------------------------------------------&quot;</span>);        CompletableFuture&lt;String&gt; future4 = CompletableFuture.supplyAsync(() -&gt; &#123;            <span class="keyword">try</span> &#123;                TimeUnit.SECONDS.sleep(<span class="number">1</span>);            &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;                <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">RuntimeException</span>(e);            &#125;            System.out.println(Thread.currentThread().getName() + <span class="string">&quot;有返回值，自定义线程池&quot;</span>);            <span class="keyword">return</span> <span class="string">&quot;有返回值，自定义线程池&quot;</span>;        &#125;, threadPoolExecutor);        System.out.println(<span class="string">&quot;future4 ==&gt; &quot;</span> + future4.get());        <span class="comment">/*</span><span class="comment">        * 打印：</span><span class="comment">        pool-1-thread-1有返回值，自定义线程池</span><span class="comment">        future4 ==&gt; 有返回值，自定义线程池</span><span class="comment">        * */</span>        <span class="comment">// 关闭线程池</span>        threadPoolExecutor.shutdown();    &#125;&#125;</code></pre><h3 id="3-2-回调方法演示"><a href="#3-2-回调方法演示" class="headerlink" title="3.2 回调方法演示"></a>3.2 回调方法演示</h3><p>CompletableFuture 减少阻塞和轮询，可以传入回调对象，当异步任务完成或者发生异常时，自动调用回调对象的回调方法。</p><pre><code class="highlight java"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">CompletableFutureUseDemo</span> &#123;    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> InterruptedException &#123;        <span class="comment">// 自定义线程池</span>        <span class="type">ThreadPoolExecutor</span> <span class="variable">threadPoolExecutor</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ThreadPoolExecutor</span>(<span class="number">1</span>,                <span class="number">20</span>,                <span class="number">1</span>,                TimeUnit.SECONDS,                <span class="keyword">new</span> <span class="title class_">LinkedBlockingQueue</span>&lt;&gt;(<span class="number">5</span>),                Executors.defaultThreadFactory(),                <span class="keyword">new</span> <span class="title class_">ThreadPoolExecutor</span>.AbortPolicy());        CompletableFuture&lt;Integer&gt; completableFuture = CompletableFuture.supplyAsync(() -&gt; &#123;            System.out.println(Thread.currentThread().getName() + <span class="string">&quot; 线程运行中...&quot;</span>);            <span class="type">int</span> <span class="variable">result</span> <span class="operator">=</span> ThreadLocalRandom.current().nextInt(<span class="number">10</span>);            <span class="keyword">try</span> &#123;                TimeUnit.SECONDS.sleep(<span class="number">1</span>);            &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;                <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">RuntimeException</span>(e);            &#125;            <span class="keyword">if</span> (result &gt; <span class="number">5</span>) &#123;                <span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">10</span> / <span class="number">0</span>;            &#125;            <span class="keyword">return</span> result;        &#125;, threadPoolExecutor).whenComplete((v, e) -&gt; &#123; <span class="comment">// 当计算完成时调用</span>            <span class="keyword">if</span> (e == <span class="literal">null</span>) &#123;                System.out.println(Thread.currentThread().getName() + <span class="string">&quot; 线程计算完成，结果为：&quot;</span> + v);            &#125;        &#125;).exceptionally(e -&gt; &#123;            e.printStackTrace();            <span class="type">String</span> <span class="variable">msg</span> <span class="operator">=</span> String.format(<span class="string">&quot;%s 线程计算出现异常，原因：%s, 错误信息：%s&quot;</span>, Thread.currentThread().getName(), e.getCause(), e.getMessage());            System.out.println(msg);            <span class="keyword">return</span> -<span class="number">1</span>;        &#125;);        System.out.println(Thread.currentThread().getName() + <span class="string">&quot; 线程先去完成其他任务&quot;</span>);        <span class="comment">// 线程不要立刻结束，否则CompletableFuture默认使用的线程池会立刻关闭：暂停3秒钟线程</span>        TimeUnit.SECONDS.sleep(<span class="number">2</span>);        <span class="comment">// 关闭自定义线程池</span>        threadPoolExecutor.shutdown();    &#125;&#125;<span class="comment">/*</span><span class="comment">无异常时打印如下：</span><span class="comment">pool-1-thread-1 线程运行中...</span><span class="comment">main 线程先去完成其他任务</span><span class="comment">pool-1-thread-1 线程计算完成，结果为：2</span><span class="comment">* */</span><span class="comment">/*</span><span class="comment">有异常时打印如下：</span><span class="comment">pool-1-thread-1 线程运行中...</span><span class="comment">main 线程先去完成其他任务</span><span class="comment">java.util.concurrent.CompletionException: java.lang.ArithmeticException: / by zero</span><span class="comment">at java.base/java.util.concurrent.CompletableFuture.encodeThrowable(CompletableFuture.java:315)</span><span class="comment">at java.base/java.util.concurrent.CompletableFuture.completeThrowable(CompletableFuture.java:320)</span><span class="comment">at java.base/java.util.concurrent.CompletableFuture$AsyncSupply.run(CompletableFuture.java:1770)</span><span class="comment">at java.base/java.util.concurrent.ThreadPoolExecutor.runWorker(ThreadPoolExecutor.java:1136)</span><span class="comment">at java.base/java.util.concurrent.ThreadPoolExecutor$Worker.run(ThreadPoolExecutor.java:635)</span><span class="comment">at java.base/java.lang.Thread.run(Thread.java:842)</span><span class="comment">Caused by: java.lang.ArithmeticException: / by zero</span><span class="comment">at com.atguigu.juc.cf.CompletableFutureUseDemo.lambda$main$0(CompletableFutureUseDemo.java:32)</span><span class="comment">at java.base/java.util.concurrent.CompletableFuture$AsyncSupply.run(CompletableFuture.java:1768)</span><span class="comment">... 3 more</span><span class="comment">pool-1-thread-1 线程计算出现异常，原因：java.lang.ArithmeticException: / by zero, 错误信息：java.lang.ArithmeticException: / by zero</span><span class="comment">* */</span></code></pre><p>CompletableFuture优点：</p><ul><li>异步任务<strong>结束</strong>时，会自动回调某个对象的方法</li><li>主线程设置好回调后，不用关心异步任务的执行，异步任务之间可以顺序执行</li><li>异步任务<strong>出错</strong>时，会自动回调某个对象的方法</li></ul><h1 id="四、函数式编程"><a href="#四、函数式编程" class="headerlink" title="四、函数式编程"></a>四、函数式编程</h1><p>Lambda表达式+Stream流式调用+Chain链式调用+Java8函数式编程</p><h2 id="1-函数式接口"><a href="#1-函数式接口" class="headerlink" title="1. 函数式接口"></a>1. 函数式接口</h2><ul><li><p>Runnable：无参数、无返回值</p><p><img src="https://raw.githubusercontent.com/GeorgeChan95/blogimg/master/img/2024/09/19/20240919-110244.png" alt="Runnable"></p></li><li><p>Function：接受一个参数，并且有返回值</p><p><img src="https://raw.githubusercontent.com/GeorgeChan95/blogimg/master/img/2024/09/19/20240919-110317.png" alt="Function"></p></li><li><p>Consumer：接受一个参数，没有返回值</p><p><img src="https://raw.githubusercontent.com/GeorgeChan95/blogimg/master/img/2024/09/19/20240919-110409.png" alt="Consumer"></p></li><li><p>BiConsumer：接受两个参数，没有返回值</p><p><img src="https://raw.githubusercontent.com/GeorgeChan95/blogimg/master/img/2024/09/19/20240919-110436.png" alt="BiConsumer"></p></li><li><p>Supplier：没有参数，有返回值</p><p><img src="https://raw.githubusercontent.com/GeorgeChan95/blogimg/master/img/2024/09/19/20240919-110455.png" alt="Supplier"></p></li></ul><p><strong>总结：</strong></p><table><thead><tr><th>函数式接口名称</th><th>方法名称</th><th>参数</th><th>返回值</th></tr></thead><tbody><tr><td>Runnable</td><td>run</td><td>无参数</td><td>无返回值</td></tr><tr><td>Function</td><td>apply</td><td>1个参数</td><td>有返回值</td></tr><tr><td>Consume</td><td>accept</td><td>1个参数</td><td>无返回值</td></tr><tr><td>Supplier</td><td>get</td><td>没有参数</td><td>有返回值</td></tr><tr><td>Biconsumer</td><td>accept</td><td>2个参数</td><td>无返回值</td></tr></tbody></table><h2 id="2-链式编程"><a href="#2-链式编程" class="headerlink" title="2. 链式编程"></a>2. 链式编程</h2><pre><code class="highlight java"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Chain</span> &#123;    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;        <span class="comment">//-------------------老式写法------------</span><span class="comment">//        Student student = new Student();</span><span class="comment">//        student.setId(1);</span><span class="comment">//        student.setMajor(&quot;cs&quot;);</span><span class="comment">//        student.setName(&quot;小卡&quot;);</span>        <span class="keyword">new</span> <span class="title class_">Student</span>().setId(<span class="number">1</span>).setName(<span class="string">&quot;大卡&quot;</span>).setMajor(<span class="string">&quot;cs&quot;</span>);    &#125;    &#125;<span class="meta">@NoArgsConstructor</span><span class="meta">@AllArgsConstructor</span><span class="meta">@Data</span><span class="meta">@Accessors(chain = true)</span><span class="comment">//开启链式编程</span><span class="keyword">class</span> <span class="title class_">Student</span>&#123;    <span class="keyword">private</span> <span class="type">int</span> id;    <span class="keyword">private</span> String name;    <span class="keyword">private</span> String major;&#125;</code></pre><h1 id="五、join-和-get-对比"><a href="#五、join-和-get-对比" class="headerlink" title="五、join 和 get 对比"></a>五、join 和 get 对比</h1><p>join 与 get 功能几乎一样，区别在于编码时是否需要抛出异常</p><ul><li>get() 方法需要抛出异常</li><li>join() 方法不需要抛出异常</li></ul><pre><code class="highlight java"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Chain</span> &#123;    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> ExecutionException, InterruptedException &#123; <span class="comment">//抛出异常</span>        CompletableFuture&lt;String&gt; completableFuture = CompletableFuture.supplyAsync(() -&gt; &#123;            <span class="keyword">return</span> <span class="string">&quot;hello 12345&quot;</span>;        &#125;);        System.out.println(completableFuture.get());    &#125;&#125;<span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Chain</span> &#123;    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span>  &#123;<span class="comment">// 不用抛出异常</span>        CompletableFuture&lt;String&gt; completableFuture = CompletableFuture.supplyAsync(() -&gt; &#123;            <span class="keyword">return</span> <span class="string">&quot;hello 12345&quot;</span>;        &#125;);        System.out.println(completableFuture.join());    &#125;&#125;</code></pre><h1 id="六、CompletableFuture-案例讲解"><a href="#六、CompletableFuture-案例讲解" class="headerlink" title="六、CompletableFuture 案例讲解"></a>六、CompletableFuture 案例讲解</h1><h2 id="1-需求说明"><a href="#1-需求说明" class="headerlink" title="1. 需求说明"></a>1. 需求说明</h2><p>电商网站比价需求分析：</p><ol><li><p>需求说明：</p></li><li><ol><li>同一款产品，同时搜索出同款产品在各大电商平台的售价</li><li>同一款产品，同时搜索出本产品在同一个电商平台下，各个入驻卖家售价是多少</li></ol></li><li><p>输出返回：</p></li><li><ol><li>出来结果希望是同款产品的在不同地方的价格清单列表，返回一个List<String></li></ol></li></ol><p>例如：《Mysql》 in jd price is 88.05  《Mysql》 in taobao price is 90.43</p><ol><li><p>解决方案，对比同一个产品在各个平台上的价格，要求获得一个清单列表</p></li><li><ol><li>step by step，按部就班，查完淘宝查京东，查完京东查天猫….</li><li>all in，万箭齐发，一口气多线程异步任务同时查询</li></ol></li></ol><h2 id="2-不使用多线程实现需求"><a href="#2-不使用多线程实现需求" class="headerlink" title="2. 不使用多线程实现需求"></a>2. 不使用多线程实现需求</h2><p>从不同的网站逐个查询，直到所有网站查询完成，返回结果。</p><pre><code class="highlight java"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">NetMallCase</span> &#123;    <span class="keyword">static</span> List&lt;NetMall&gt; list = Arrays.asList(            <span class="keyword">new</span> <span class="title class_">NetMall</span>(<span class="string">&quot;jd&quot;</span>),            <span class="keyword">new</span> <span class="title class_">NetMall</span>(<span class="string">&quot;pdd&quot;</span>),            <span class="keyword">new</span> <span class="title class_">NetMall</span>(<span class="string">&quot;taobao&quot;</span>),            <span class="keyword">new</span> <span class="title class_">NetMall</span>(<span class="string">&quot;dangdangwang&quot;</span>),            <span class="keyword">new</span> <span class="title class_">NetMall</span>(<span class="string">&quot;tmall&quot;</span>)    );    <span class="comment">/**</span><span class="comment">     * 不使用多线程，获取图书在不同平台的价格</span><span class="comment">     * <span class="doctag">@param</span> list</span><span class="comment">     * <span class="doctag">@param</span> productName</span><span class="comment">     * <span class="doctag">@return</span></span><span class="comment">     */</span>    <span class="keyword">public</span> <span class="keyword">static</span> List&lt;String&gt; <span class="title function_">getPriceByStep</span><span class="params">(List&lt;NetMall&gt; list, String productName)</span> &#123;        List&lt;String&gt; result = list.stream().map(netMall -&gt; &#123;            <span class="type">String</span> <span class="variable">str</span> <span class="operator">=</span> String.format(productName + <span class="string">&quot; in %s price is %.2f&quot;</span>, netMall.getMallName(), netMall.calcPrice(productName));            <span class="keyword">return</span> str;        &#125;).collect(Collectors.toList());        <span class="keyword">return</span> result;    &#125;    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;        <span class="type">long</span> <span class="variable">startTime</span> <span class="operator">=</span> System.currentTimeMillis();        List&lt;String&gt; resuts = getPriceByStep(list, <span class="string">&quot;mysql&quot;</span>);        <span class="keyword">for</span> (String data : resuts) &#123;            System.out.println(data);        &#125;        <span class="type">long</span> <span class="variable">endTime</span> <span class="operator">=</span> System.currentTimeMillis();        System.out.println(<span class="string">&quot;不使用多线程，costTime: &quot;</span> + (endTime - startTime) + <span class="string">&quot; 毫秒&quot;</span>);    &#125;&#125;<span class="keyword">class</span> <span class="title class_">NetMallData</span> &#123;    <span class="meta">@Getter</span>    <span class="keyword">private</span> String mallName;    <span class="keyword">public</span> <span class="title function_">NetMallData</span><span class="params">(String mallName)</span> &#123;        <span class="built_in">this</span>.mallName = mallName;    &#125;    <span class="keyword">public</span> <span class="type">double</span> <span class="title function_">calcPrice</span><span class="params">(String productName)</span> &#123;        <span class="comment">//检索需要1秒钟</span>        <span class="keyword">try</span> &#123;            TimeUnit.SECONDS.sleep(<span class="number">1</span>);        &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;            e.printStackTrace();        &#125;        <span class="keyword">return</span> ThreadLocalRandom.current().nextDouble() * <span class="number">2</span> + productName.charAt(<span class="number">0</span>);    &#125;&#125;</code></pre><p>执行结果：</p><pre><code class="highlight shell">mysql in jd price is 109.95mysql in pdd price is 109.86mysql in taobao price is 109.79mysql in dangdangwang price is 110.08mysql in tmall price is 110.55不使用多线程，costTime: 5070 毫秒</code></pre><p>多个查询逐个完成，执行效率低，执行时间长。</p><h2 id="3-使用-CompletableFuture-实现需求"><a href="#3-使用-CompletableFuture-实现需求" class="headerlink" title="3. 使用 CompletableFuture 实现需求"></a>3. 使用 CompletableFuture 实现需求</h2><pre><code class="highlight java"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">NetMallCase</span> &#123;    <span class="keyword">static</span> List&lt;NetMall&gt; list = Arrays.asList(            <span class="keyword">new</span> <span class="title class_">NetMall</span>(<span class="string">&quot;jd&quot;</span>),            <span class="keyword">new</span> <span class="title class_">NetMall</span>(<span class="string">&quot;pdd&quot;</span>),            <span class="keyword">new</span> <span class="title class_">NetMall</span>(<span class="string">&quot;taobao&quot;</span>),            <span class="keyword">new</span> <span class="title class_">NetMall</span>(<span class="string">&quot;dangdangwang&quot;</span>),            <span class="keyword">new</span> <span class="title class_">NetMall</span>(<span class="string">&quot;tmall&quot;</span>)    );    <span class="comment">/**</span><span class="comment">     * 不使用多线程，获取图书在不同平台的价格</span><span class="comment">     *</span><span class="comment">     * <span class="doctag">@param</span> list</span><span class="comment">     * <span class="doctag">@param</span> productName</span><span class="comment">     * <span class="doctag">@return</span></span><span class="comment">     */</span>    <span class="keyword">public</span> <span class="keyword">static</span> List&lt;String&gt; <span class="title function_">getPriceByStep</span><span class="params">(List&lt;NetMall&gt; list, String productName)</span> &#123;        List&lt;String&gt; result = list.stream().map(netMall -&gt; &#123;            <span class="type">String</span> <span class="variable">str</span> <span class="operator">=</span> String.format(productName + <span class="string">&quot; in %s price is %.2f&quot;</span>, netMall.getMallName(), netMall.calcPrice(productName));            <span class="keyword">return</span> str;        &#125;).collect(Collectors.toList());        <span class="keyword">return</span> result;    &#125;    <span class="comment">/**</span><span class="comment">     * 使用多线程异步的从不同平台获取图书价格</span><span class="comment">     *</span><span class="comment">     * <span class="doctag">@param</span> list</span><span class="comment">     * <span class="doctag">@param</span> productName</span><span class="comment">     * <span class="doctag">@return</span></span><span class="comment">     */</span>    <span class="keyword">public</span> <span class="keyword">static</span> List&lt;String&gt; <span class="title function_">getPriceByAsync</span><span class="params">(List&lt;NetMall&gt; list, String productName)</span> &#123;        List&lt;String&gt; results = list.stream().map(netMall -&gt;                        CompletableFuture.supplyAsync(() -&gt; String.format(productName + <span class="string">&quot; in %s price is %.2f&quot;</span>, netMall.getMallName(), netMall.calcPrice(productName))))                .collect(Collectors.toList())                .stream()                .map(CompletableFuture::join)                .collect(Collectors.toList());        <span class="keyword">return</span> results;    &#125;    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;        <span class="comment">// 使用异步多线程获取</span>        <span class="type">long</span> <span class="variable">startTime2</span> <span class="operator">=</span> System.currentTimeMillis();        List&lt;String&gt; resuts2 = getPriceByAsync(list, <span class="string">&quot;mysql&quot;</span>);        <span class="keyword">for</span> (String data : resuts2) &#123;            System.out.println(data);        &#125;        <span class="type">long</span> <span class="variable">endTime2</span> <span class="operator">=</span> System.currentTimeMillis();        System.out.println(<span class="string">&quot;使用异步多线程，costTime: &quot;</span> + (endTime2 - startTime2) + <span class="string">&quot; 毫秒&quot;</span>);    &#125;&#125;<span class="keyword">class</span> <span class="title class_">NetMallData</span> &#123;    <span class="meta">@Getter</span>    <span class="keyword">private</span> String mallName;    <span class="keyword">public</span> <span class="title function_">NetMallData</span><span class="params">(String mallName)</span> &#123;        <span class="built_in">this</span>.mallName = mallName;    &#125;    <span class="keyword">public</span> <span class="type">double</span> <span class="title function_">calcPrice</span><span class="params">(String productName)</span> &#123;        <span class="comment">//检索需要1秒钟</span>        <span class="keyword">try</span> &#123;            TimeUnit.SECONDS.sleep(<span class="number">1</span>);        &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;            e.printStackTrace();        &#125;        <span class="keyword">return</span> ThreadLocalRandom.current().nextDouble() * <span class="number">2</span> + productName.charAt(<span class="number">0</span>);    &#125;&#125;</code></pre><p>执行结果：</p><pre><code class="highlight shell">mysql in jd price is 110.91mysql in pdd price is 109.59mysql in taobao price is 109.30mysql in dangdangwang price is 110.85mysql in tmall price is 110.67使用异步多线程，costTime: 1056 毫秒</code></pre><p>使用异步多线程，执行效率大大提升。</p><h1 id="七、CompletableFuture-常用API"><a href="#七、CompletableFuture-常用API" class="headerlink" title="七、CompletableFuture 常用API"></a>七、CompletableFuture 常用API</h1><h2 id="1-获得结果和触发计算"><a href="#1-获得结果和触发计算" class="headerlink" title="1.获得结果和触发计算"></a>1.获得结果和触发计算</h2><ul><li><p>获取结果</p><ul><li><code>public T get()</code>  阻塞等待，直到得到返回结果</li><li><code>public T get(long timeout,TimeUnit unit)</code>  阻塞等待指定的时长，超时则报错：TimeOutException</li><li><code>public T join()</code>  类似于get()，区别在于不需要抛出异常</li><li><code>public T getNow(T valueIfAbsent)</code>  立即获取结果不阻塞<ul><li>计算完，返回计算完成后的结果</li><li>没算完，返回设定的valueAbsent(直接返回了备胎值xxx)</li></ul></li></ul></li><li><p>主动触发计算</p><ul><li><code>public boolean complete(T value)</code>  是否立即打断get()方法返回括号值<ul><li>(执行要2s，等待只有1s，所以还没执行完就被打断了。返回true表示打断了获取这个过程，直接返回了备胎值 complete；如果没打断，返回false 和原来的abc)</li></ul></li></ul><pre><code class="highlight java"><span class="comment">/**</span><span class="comment"> * 获得结果和触发计算</span><span class="comment"> *</span><span class="comment"> * <span class="doctag">@throws</span> InterruptedException</span><span class="comment"> * <span class="doctag">@throws</span> ExecutionException</span><span class="comment"> */</span><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">m1</span><span class="params">()</span> <span class="keyword">throws</span> InterruptedException, ExecutionException &#123;    <span class="type">ThreadPoolExecutor</span> <span class="variable">threadPoolExecutor</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ThreadPoolExecutor</span>(<span class="number">1</span>, <span class="number">20</span>, <span class="number">1L</span>, TimeUnit.SECONDS, <span class="keyword">new</span> <span class="title class_">LinkedBlockingQueue</span>&lt;&gt;(<span class="number">50</span>), Executors.defaultThreadFactory(), <span class="keyword">new</span> <span class="title class_">ThreadPoolExecutor</span>.AbortPolicy());    CompletableFuture&lt;Integer&gt; future = CompletableFuture.supplyAsync(() -&gt; &#123;        <span class="comment">//暂停几秒钟线程</span>        <span class="comment">//暂停几秒钟线程</span>        <span class="keyword">try</span> &#123;            TimeUnit.SECONDS.sleep(<span class="number">2</span>);        &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;            e.printStackTrace();        &#125;        <span class="keyword">return</span> <span class="number">1</span>;    &#125;, threadPoolExecutor);    <span class="comment">//System.out.println(future.get()); // 1</span>    <span class="comment">//System.out.println(future.get(2L,TimeUnit.SECONDS)); // 1</span>    <span class="comment">//暂停几秒钟线程</span>    <span class="keyword">try</span> &#123;        TimeUnit.SECONDS.sleep(<span class="number">1</span>);    &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;        e.printStackTrace();    &#125;    <span class="comment">//System.out.println(future.getNow(9999));</span>    System.out.println(future.complete(-<span class="number">44</span>) + <span class="string">&quot;\t&quot;</span> + future.get());        <span class="comment">// 关闭线程池</span>    threadPoolExecutor.shutdown();&#125;</code></pre><p>打印结果：</p><pre><code class="highlight shell">true-44</code></pre></li></ul><h2 id="2-对计算结果进行处理"><a href="#2-对计算结果进行处理" class="headerlink" title="2. 对计算结果进行处理"></a>2. 对计算结果进行处理</h2><ul><li><p><code>thenApply </code> 计算结果存在在依赖关系，使得线程串行化。因为依赖关系，所以一旦有异常，直接叫停。</p><pre><code class="highlight java"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">thenApplyDemo</span><span class="params">()</span> <span class="keyword">throws</span> InterruptedException &#123;    <span class="type">ThreadPoolExecutor</span> <span class="variable">threadPoolExecutor</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ThreadPoolExecutor</span>(<span class="number">1</span>, <span class="number">20</span>, <span class="number">1L</span>, TimeUnit.SECONDS, <span class="keyword">new</span> <span class="title class_">LinkedBlockingQueue</span>&lt;&gt;(<span class="number">50</span>), Executors.defaultThreadFactory(), <span class="keyword">new</span> <span class="title class_">ThreadPoolExecutor</span>.AbortPolicy());    CompletableFuture&lt;Integer&gt; completableFuture = CompletableFuture.supplyAsync(() -&gt; &#123;        <span class="type">int</span> <span class="variable">result</span> <span class="operator">=</span> ThreadLocalRandom.current().nextInt(<span class="number">10</span>);        <span class="keyword">try</span> &#123;            TimeUnit.SECONDS.sleep(<span class="number">1</span>);        &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;            <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">RuntimeException</span>(e);        &#125;        <span class="keyword">if</span> (result &gt; <span class="number">5</span>) &#123;            <span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">10</span> / <span class="number">0</span>;        &#125;        <span class="keyword">return</span> <span class="number">1</span>;    &#125;, threadPoolExecutor).thenApply(data -&gt; data + <span class="number">2</span>).whenComplete((v, e) -&gt; &#123;        <span class="keyword">if</span> (e == <span class="literal">null</span>) &#123;            System.out.println(<span class="string">&quot;执行完成，结果：&quot;</span> + v);        &#125;    &#125;).exceptionally(e -&gt; &#123;        e.printStackTrace();        <span class="type">String</span> <span class="variable">msg</span> <span class="operator">=</span> String.format(<span class="string">&quot;执行出现异常，原因：%s, 异常信息：%s&quot;</span>, e.getCause(), e.getMessage());        System.out.println(msg);        <span class="keyword">return</span> -<span class="number">1</span>;    &#125;);        System.out.println(<span class="string">&quot;执行结束，结果：&quot;</span> + completableFuture.join());    <span class="comment">// 关闭自定义线程池</span>    threadPoolExecutor.shutdown();    <span class="comment">// 主线程停留3秒</span>    TimeUnit.SECONDS.sleep(<span class="number">3</span>);&#125;</code></pre><p>正常执行结束打印：</p><pre><code class="highlight shell">执行完成，结果：3执行结束，结果：3</code></pre><p>异常执行结束打印：</p><pre><code class="highlight shell">java.util.concurrent.CompletionException: java.lang.ArithmeticException: / by zeroat java.util.concurrent.CompletableFuture.encodeThrowable(CompletableFuture.java:273)at java.util.concurrent.CompletableFuture.completeThrowable(CompletableFuture.java:280)at java.util.concurrent.CompletableFuture$AsyncSupply.run(CompletableFuture.java:1606)at java.util.concurrent.ThreadPoolExecutor.runWorker(ThreadPoolExecutor.java:1149)at java.util.concurrent.ThreadPoolExecutor$Worker.run(ThreadPoolExecutor.java:624)at java.lang.Thread.run(Thread.java:748)Caused by: java.lang.ArithmeticException: / by zeroat com.atguigu.juc.cf.CompletableFutureDemo.lambda$thenApplyDemo$0(CompletableFutureDemo.java:27)at java.util.concurrent.CompletableFuture$AsyncSupply.run(CompletableFuture.java:1604)... 3 more执行出现异常，原因：java.lang.ArithmeticException: / by zero, 异常信息：java.lang.ArithmeticException: / by zero执行结束，结果：-1</code></pre></li><li><p><code>handle </code> 类似于 thenApply，但是有异常的话仍然可以往下走一步。</p><pre><code class="highlight java"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">handleDemo</span><span class="params">()</span> <span class="keyword">throws</span> InterruptedException &#123;    <span class="comment">// 自定义线程池</span>    <span class="type">ThreadPoolExecutor</span> <span class="variable">threadPool</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ThreadPoolExecutor</span>(            <span class="number">4</span>,            <span class="number">5</span>,            <span class="number">50</span>,            TimeUnit.SECONDS,            <span class="keyword">new</span> <span class="title class_">LinkedBlockingQueue</span>&lt;&gt;(<span class="number">10</span>),            Executors.defaultThreadFactory(),            <span class="keyword">new</span> <span class="title class_">ThreadPoolExecutor</span>.AbortPolicy());    CompletableFuture.supplyAsync(() -&gt; &#123;        <span class="type">int</span> <span class="variable">result</span> <span class="operator">=</span> ThreadLocalRandom.current().nextInt(<span class="number">10</span>);        <span class="keyword">try</span> &#123;            TimeUnit.SECONDS.sleep(<span class="number">1</span>);        &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;            <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">RuntimeException</span>(e);        &#125;        <span class="keyword">if</span> (result &gt; <span class="number">5</span>) &#123;            <span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">10</span> / <span class="number">0</span>;        &#125;        <span class="keyword">return</span> <span class="number">10</span>;    &#125;, threadPool).handle((v, e) -&gt; &#123;        <span class="keyword">if</span> (e == <span class="literal">null</span>) &#123;            System.out.println(<span class="string">&quot;handle1执行完成，结果：&quot;</span> + v);        &#125; <span class="keyword">else</span> &#123;            System.out.println(<span class="string">&quot;handle1执行异常&quot;</span>);        &#125;        <span class="keyword">return</span> v + <span class="number">1</span>;    &#125;).handle((v, e) -&gt; &#123;        <span class="keyword">if</span> (e == <span class="literal">null</span>) &#123;            System.out.println(<span class="string">&quot;handle2执行完成，结果：&quot;</span> + v);        &#125; <span class="keyword">else</span> &#123;            System.out.println(<span class="string">&quot;handle2执行异常&quot;</span>);        &#125;        <span class="keyword">return</span> <span class="string">&quot;abc&quot;</span>;    &#125;).handle((v, e) -&gt; &#123;        <span class="keyword">if</span> (e == <span class="literal">null</span>) &#123;            System.out.println(<span class="string">&quot;handle3执行完成，结果：&quot;</span> + v);        &#125; <span class="keyword">else</span> &#123;            System.out.println(<span class="string">&quot;handle3执行异常&quot;</span>);        &#125;        <span class="keyword">return</span> <span class="string">&quot;xyz&quot;</span>;    &#125;).whenCompleteAsync((v, e) -&gt; &#123;        <span class="keyword">if</span> (e == <span class="literal">null</span>) &#123;            System.out.println(Thread.currentThread().getName() + <span class="string">&quot; whenComplete执行完成，结果：&quot;</span> + v);        &#125;    &#125;, threadPool).exceptionally(e -&gt; &#123;        e.printStackTrace();        <span class="type">String</span> <span class="variable">msg</span> <span class="operator">=</span> String.format(<span class="string">&quot;执行出现异常，原因：%s, 异常信息：%s&quot;</span>, e.getCause(), e.getMessage());        System.out.println(msg);        <span class="keyword">return</span> <span class="string">&quot;error&quot;</span>;    &#125;);    TimeUnit.SECONDS.sleep(<span class="number">5</span>);    <span class="comment">// 关闭线程池</span>    threadPool.shutdown();&#125;</code></pre><p>正常执行结束打印：</p><pre><code class="highlight shell">handle1执行完成，结果：10handle2执行完成，结果：11whenComplete执行完成，结果：abc</code></pre><p>异常执行结束打印：</p><pre><code class="highlight shell">handle1执行异常handle2执行异常handle3执行完成，结果：abcpool-1-thread-2 whenComplete执行完成，结果：xyz</code></pre><p><strong>注意：</strong>当 <code>supplyAsync</code> 方法执行异常时， 程序依然往下走，经过了 <code>handle1</code>、<code>handle2</code>、<code>handle3</code> ，而没有经过 <code>exceptionally</code> ，当 <code>handle3</code> 出现异常时（在<code>whenCompleteAsync</code> 上方的方法），才会经过 <code>exceptionally</code> 方法</p></li></ul><p><strong>thenApply 在实际工作中最常用</strong></p><h2 id="3-对计算结果进行消费"><a href="#3-对计算结果进行消费" class="headerlink" title="3. 对计算结果进行消费"></a>3. 对计算结果进行消费</h2><p>接收任务的处理结果，并消费处理，<strong>无返回结果|消费型函数式接口</strong>，之前的是Function</p><ul><li><p>thenAccept</p><ul><li>thenAccept(Consumer action)</li><li>任务A执行完执行B，B需要A的结果，但是任务B无返回值</li></ul><pre><code class="highlight java">System.out.println(CompletableFuture.supplyAsync(() -&gt; <span class="string">&quot;resultA&quot;</span>).thenAccept(r -&gt; System.out.println(r)).join());</code></pre></li><li><p>thenRun</p><ul><li>thenRun(Runnable runnable)</li><li>任务A执行完执行B，并且B不需要A的结果</li></ul><pre><code class="highlight java">System.out.println(CompletableFuture.supplyAsync(() -&gt; <span class="string">&quot;resultA&quot;</span>).thenRun(() -&gt; &#123;&#125;).join());</code></pre></li><li><p>thenApply</p><ul><li>thenApply(Function fn)</li><li>任务A执行完执行B，B需要A的结果，同时任务B有返回值</li></ul><pre><code class="highlight java">System.out.println(CompletableFuture.supplyAsync(() -&gt; <span class="string">&quot;resultA&quot;</span>).thenApply(resultA -&gt; resultA + <span class="string">&quot; resultB&quot;</span>).join());</code></pre></li></ul><p>示例代码：</p><pre><code class="highlight java"><span class="comment">/**</span><span class="comment"> * 对计算结果进行消费</span><span class="comment"> */</span><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">m3</span><span class="params">()</span> &#123;    CompletableFuture.supplyAsync(() -&gt; &#123;        <span class="keyword">return</span> <span class="number">1</span>;    &#125;).thenApply(f -&gt; &#123;        <span class="keyword">return</span> f + <span class="number">2</span>;    &#125;).thenApply(f -&gt; &#123;        <span class="keyword">return</span> f + <span class="number">3</span>;    &#125;).thenAccept(r -&gt; System.out.println(r));    <span class="comment">// 任务A执行完执行B，并且B不需要A的结果, 且B无返回值</span>    System.out.println(CompletableFuture.supplyAsync(() -&gt; <span class="string">&quot;resultA&quot;</span>).thenRun(() -&gt; &#123;&#125;).join());    <span class="comment">// 任务A执行完执行B，B需要A的结果，但是任务B无返回值</span>    System.out.println(CompletableFuture.supplyAsync(() -&gt; <span class="string">&quot;resultA&quot;</span>).thenAccept(r -&gt; System.out.println(r)).join());    <span class="comment">// 任务A执行完执行B，B需要A的结果，同时任务B有返回值</span>    System.out.println(CompletableFuture.supplyAsync(() -&gt; <span class="string">&quot;resultA&quot;</span>).thenApply(resultA -&gt; resultA + <span class="string">&quot; resultB&quot;</span>).join());&#125;</code></pre><h2 id="4-CompleteFuture和线程池说明（非常重要）"><a href="#4-CompleteFuture和线程池说明（非常重要）" class="headerlink" title="4. CompleteFuture和线程池说明（非常重要）"></a>4. CompleteFuture和线程池说明（非常重要）</h2><p>上面的几个方法都有普通版本和后面加<strong>Async</strong>的版本, 例如：<code>thenRun</code>、<code>thenRunAsync</code>、<code>thenApply</code>、<code>thenApplyAsync</code>、<code>whenComplete</code>、<code>whenCompleteAsync</code> ……</p><p>以 <code>thenRun</code>和<code>thenRunAsync</code>为例，有什么区别？</p><ul><li><p><code>thenRun</code> 没有传入自定义线程池，使用默认线程池 ForkJoinPool</p></li><li><p><code>thenRunAsync</code>可传入一个自定义线程池</p><ul><li>如果你执行第一个任务的时候，传入了一个自定义线程池，调用<code>thenRun</code>方法执行第二个任务的时候，则第二个任务和第一个任务是用同一个线程池。</li><li>调用<code>thenRunAsync</code>执行第二个任务的时候，则第一个任务使用的是你自己传入的线程池，第二个任务使用的是 <strong>ForkJoin线程池</strong></li></ul></li><li><p>特殊情况，任务处理太快，系统优化切换原则，直接使用main线程处理</p></li><li><p>thenRun 代码示例</p><pre><code class="highlight plaintext">private static void m7() throws InterruptedException &#123;    ThreadPoolExecutor threadPoolExecutor = new ThreadPoolExecutor(1, 20, 1L, TimeUnit.SECONDS, new LinkedBlockingQueue&lt;&gt;(50), Executors.defaultThreadFactory(), new ThreadPoolExecutor.AbortPolicy());    CompletableFuture&lt;Void&gt; completableFuture = CompletableFuture.supplyAsync(()-&gt;&#123;        try &#123;TimeUnit.MILLISECONDS.sleep(20);&#125; catch (InterruptedException e) &#123;e.printStackTrace();&#125;        System.out.println(&quot;1号任务&quot;+&quot;\t&quot;+Thread.currentThread().getName());        return &quot;abcd&quot;;    &#125;,threadPoolExecutor).thenRun(()-&gt;&#123;        try &#123;TimeUnit.MILLISECONDS.sleep(20);&#125; catch (InterruptedException e) &#123;e.printStackTrace();&#125;        System.out.println(&quot;2号任务&quot;+&quot;\t&quot;+Thread.currentThread().getName());    &#125;).thenRun(()-&gt;&#123;        try &#123;TimeUnit.MILLISECONDS.sleep(20);&#125; catch (InterruptedException e) &#123;e.printStackTrace();&#125;        System.out.println(&quot;3号任务&quot;+&quot;\t&quot;+Thread.currentThread().getName());    &#125;).thenRun(()-&gt;&#123;        try &#123;TimeUnit.MILLISECONDS.sleep(20);&#125; catch (InterruptedException e) &#123;e.printStackTrace();&#125;        System.out.println(&quot;4号任务&quot;+&quot;\t&quot;+Thread.currentThread().getName());    &#125;);    Thread.sleep(2000);    threadPoolExecutor.shutdown();&#125;</code></pre><p>  运行结果：</p><pre><code class="highlight shell">1号任务pool-1-thread-12号任务pool-1-thread-13号任务pool-1-thread-14号任务pool-1-thread-1</code></pre></li><li><p>thenRunAsync 代码示例</p><pre><code class="highlight java"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">m7</span><span class="params">()</span> <span class="keyword">throws</span> InterruptedException &#123;    <span class="type">ThreadPoolExecutor</span> <span class="variable">threadPoolExecutor</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ThreadPoolExecutor</span>(<span class="number">1</span>, <span class="number">20</span>, <span class="number">1L</span>, TimeUnit.SECONDS, <span class="keyword">new</span> <span class="title class_">LinkedBlockingQueue</span>&lt;&gt;(<span class="number">50</span>), Executors.defaultThreadFactory(), <span class="keyword">new</span> <span class="title class_">ThreadPoolExecutor</span>.AbortPolicy());    CompletableFuture&lt;Void&gt; completableFuture = CompletableFuture.supplyAsync(()-&gt;&#123;        <span class="keyword">try</span> &#123;TimeUnit.MILLISECONDS.sleep(<span class="number">20</span>);&#125; <span class="keyword">catch</span> (InterruptedException e) &#123;e.printStackTrace();&#125;        System.out.println(<span class="string">&quot;1号任务&quot;</span>+<span class="string">&quot;\t&quot;</span>+Thread.currentThread().getName());        <span class="keyword">return</span> <span class="string">&quot;abcd&quot;</span>;    &#125;,threadPoolExecutor).thenRunAsync(()-&gt;&#123;        <span class="keyword">try</span> &#123;TimeUnit.MILLISECONDS.sleep(<span class="number">20</span>);&#125; <span class="keyword">catch</span> (InterruptedException e) &#123;e.printStackTrace();&#125;        System.out.println(<span class="string">&quot;2号任务&quot;</span>+<span class="string">&quot;\t&quot;</span>+Thread.currentThread().getName());    &#125;).thenRun(()-&gt;&#123;        <span class="keyword">try</span> &#123;TimeUnit.MILLISECONDS.sleep(<span class="number">20</span>);&#125; <span class="keyword">catch</span> (InterruptedException e) &#123;e.printStackTrace();&#125;        System.out.println(<span class="string">&quot;3号任务&quot;</span>+<span class="string">&quot;\t&quot;</span>+Thread.currentThread().getName());    &#125;).thenRun(()-&gt;&#123;        <span class="keyword">try</span> &#123;TimeUnit.MILLISECONDS.sleep(<span class="number">20</span>);&#125; <span class="keyword">catch</span> (InterruptedException e) &#123;e.printStackTrace();&#125;        System.out.println(<span class="string">&quot;4号任务&quot;</span>+<span class="string">&quot;\t&quot;</span>+Thread.currentThread().getName());    &#125;);    Thread.sleep(<span class="number">2000</span>);    threadPoolExecutor.shutdown();&#125;</code></pre><p>运行结果：</p><pre><code class="highlight shell">1号任务pool-1-thread-12号任务ForkJoinPool.commonPool-worker-253号任务ForkJoinPool.commonPool-worker-254号任务ForkJoinPool.commonPool-worker-25</code></pre></li><li><p>特殊情况, 直接使用main线程处理</p><pre><code class="highlight java"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">m7</span><span class="params">()</span> <span class="keyword">throws</span> InterruptedException &#123;    <span class="type">ThreadPoolExecutor</span> <span class="variable">threadPoolExecutor</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ThreadPoolExecutor</span>(<span class="number">1</span>, <span class="number">20</span>, <span class="number">1L</span>, TimeUnit.SECONDS, <span class="keyword">new</span> <span class="title class_">LinkedBlockingQueue</span>&lt;&gt;(<span class="number">50</span>), Executors.defaultThreadFactory(), <span class="keyword">new</span> <span class="title class_">ThreadPoolExecutor</span>.AbortPolicy());    CompletableFuture&lt;Void&gt; completableFuture = CompletableFuture.supplyAsync(()-&gt;&#123;<span class="comment">//        try &#123;TimeUnit.MILLISECONDS.sleep(20);&#125; catch (InterruptedException e) &#123;e.printStackTrace();&#125;</span>        System.out.println(<span class="string">&quot;1号任务&quot;</span>+<span class="string">&quot;\t&quot;</span>+Thread.currentThread().getName());        <span class="keyword">return</span> <span class="string">&quot;abcd&quot;</span>;    &#125;,threadPoolExecutor).thenRunAsync(()-&gt;&#123;<span class="comment">//        try &#123;TimeUnit.MILLISECONDS.sleep(20);&#125; catch (InterruptedException e) &#123;e.printStackTrace();&#125;</span>        System.out.println(<span class="string">&quot;2号任务&quot;</span>+<span class="string">&quot;\t&quot;</span>+Thread.currentThread().getName());    &#125;).thenRun(()-&gt;&#123;<span class="comment">//        try &#123;TimeUnit.MILLISECONDS.sleep(20);&#125; catch (InterruptedException e) &#123;e.printStackTrace();&#125;</span>        System.out.println(<span class="string">&quot;3号任务&quot;</span>+<span class="string">&quot;\t&quot;</span>+Thread.currentThread().getName());    &#125;).thenRun(()-&gt;&#123;<span class="comment">//        try &#123;TimeUnit.MILLISECONDS.sleep(20);&#125; catch (InterruptedException e) &#123;e.printStackTrace();&#125;</span>        System.out.println(<span class="string">&quot;4号任务&quot;</span>+<span class="string">&quot;\t&quot;</span>+Thread.currentThread().getName());    &#125;);    Thread.sleep(<span class="number">2000</span>);    threadPoolExecutor.shutdown();&#125;</code></pre><p> 运行结果：</p><pre><code class="highlight shell">1号任务pool-1-thread-12号任务ForkJoinPool.commonPool-worker-253号任务main4号任务main</code></pre></li></ul><h2 id="5-对计算速度进行选用"><a href="#5-对计算速度进行选用" class="headerlink" title="5. 对计算速度进行选用"></a>5. 对计算速度进行选用</h2><ul><li>applyToEither 优先选择运行速度快的任务的结果</li></ul><pre><code class="highlight java"><span class="comment">/**</span><span class="comment"> * 对计算速度进行选用</span><span class="comment"> */</span><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">m4</span><span class="params">()</span> &#123;    System.out.println(CompletableFuture.supplyAsync(() -&gt; &#123;        <span class="comment">//暂停几秒钟线程</span>        <span class="keyword">try</span> &#123;            TimeUnit.SECONDS.sleep(<span class="number">1</span>);        &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;            e.printStackTrace();        &#125;        <span class="keyword">return</span> <span class="number">1</span>;    &#125;).applyToEither(CompletableFuture.supplyAsync(() -&gt; &#123;        <span class="keyword">try</span> &#123;            TimeUnit.SECONDS.sleep(<span class="number">2</span>);        &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;            e.printStackTrace();        &#125;        <span class="keyword">return</span> <span class="number">2</span>;    &#125;), r -&gt; &#123;        <span class="keyword">return</span> r;    &#125;).join());    <span class="comment">//暂停几秒钟线程</span>    <span class="keyword">try</span> &#123;        TimeUnit.SECONDS.sleep(<span class="number">3</span>);    &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;        e.printStackTrace();    &#125;&#125;</code></pre><p>运行结果：</p><pre><code class="highlight shell">1</code></pre><h2 id="6-对计算结果进行合并"><a href="#6-对计算结果进行合并" class="headerlink" title="6. 对计算结果进行合并"></a>6. 对计算结果进行合并</h2><ul><li><p><code>thenCombine</code> 合并</p><ul><li>两个 <code>CompletionStage</code> 任务都完成后，最终能把两个任务的结果一起交给 <code>thenCombine</code> 来处理</li><li>先完成的先等着，等待其它分支任务</li></ul><pre><code class="highlight java"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">m5</span><span class="params">()</span> <span class="keyword">throws</span> ExecutionException, InterruptedException &#123;    CompletableFuture&lt;Integer&gt; thenCombineResult = CompletableFuture.supplyAsync(() -&gt; &#123;        System.out.println(Thread.currentThread().getName() + <span class="string">&quot;\t&quot;</span> + <span class="string">&quot;---come in 1&quot;</span>);        <span class="keyword">return</span> <span class="number">10</span>;    &#125;).thenCombine(CompletableFuture.supplyAsync(() -&gt; &#123;        System.out.println(Thread.currentThread().getName() + <span class="string">&quot;\t&quot;</span> + <span class="string">&quot;---come in 2&quot;</span>);        <span class="keyword">return</span> <span class="number">20</span>;    &#125;), (x, y) -&gt; &#123;        System.out.println(Thread.currentThread().getName() + <span class="string">&quot;\t&quot;</span> + <span class="string">&quot;---come in 3&quot;</span>);        <span class="keyword">return</span> x + y;    &#125;).thenCombine(CompletableFuture.supplyAsync(() -&gt; &#123;        System.out.println(Thread.currentThread().getName() + <span class="string">&quot;\t&quot;</span> + <span class="string">&quot;---come in 4&quot;</span>);        <span class="keyword">return</span> <span class="number">30</span>;    &#125;), (a, b) -&gt; &#123;        System.out.println(Thread.currentThread().getName() + <span class="string">&quot;\t&quot;</span> + <span class="string">&quot;---come in 5&quot;</span>);        <span class="keyword">return</span> a + b;    &#125;);    System.out.println(<span class="string">&quot;-----主线程结束，END&quot;</span>);    System.out.println(thenCombineResult.get());    <span class="comment">// 主线程不要立刻结束，否则CompletableFuture默认使用的线程池会立刻关闭:</span>    <span class="keyword">try</span> &#123;        TimeUnit.SECONDS.sleep(<span class="number">10</span>);    &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;        e.printStackTrace();    &#125;&#125;</code></pre><p>打印结果：</p><pre><code class="highlight shell">ForkJoinPool.commonPool-worker-25---come in 1ForkJoinPool.commonPool-worker-25---come in 2main---come in 3ForkJoinPool.commonPool-worker-18---come in 4main---come in 5-----主线程结束，END60</code></pre></li></ul>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;一、Future接口概述&quot;&gt;&lt;a href=&quot;#一、Future接口概述&quot; class=&quot;headerlink&quot; title=&quot;一、Future接口概述&quot;&gt;&lt;/a&gt;一、Future接口概述&lt;/h1&gt;&lt;p&gt;Future接口（FutureTask实现类）定义了操作异步</summary>
      
    
    
    
    <category term="JUC" scheme="https://georgechan95.github.io/categories/JUC/"/>
    
    
    <category term="juc" scheme="https://georgechan95.github.io/tags/juc/"/>
    
    <category term="java" scheme="https://georgechan95.github.io/tags/java/"/>
    
  </entry>
  
  <entry>
    <title>01-JUC进阶-线程基础</title>
    <link href="https://georgechan95.github.io/blog/3d102971.html"/>
    <id>https://georgechan95.github.io/blog/3d102971.html</id>
    <published>2024-09-18T14:32:00.000Z</published>
    <updated>2024-09-18T08:10:02.284Z</updated>
    
    <content type="html"><![CDATA[<h1 id="一、Java多线程相关概念"><a href="#一、Java多线程相关概念" class="headerlink" title="一、Java多线程相关概念"></a>一、Java多线程相关概念</h1><ul><li><p><strong>进程</strong></p><p>是程序的⼀次执⾏，是系统进⾏资源分配和调度的独⽴单位，每⼀个进程都有它⾃⼰的内存空间和系统资源</p></li><li><p><strong>线程</strong></p><ul><li>在同⼀个进程内⼜可以执⾏多个任务，⽽这每⼀个任务我们就可以看做是⼀个线程</li><li>⼀个进程会有1个或多个线程的</li></ul></li><li><p><strong>管程</strong></p><p>Monitor(监视器)，也就是我们平时所说的锁</p><p>Monitor其实是一种同步机制，他的义务是保证（同一时间）只有一个线程可以访问被保护的数据和代码。</p><p>JVM中同步是基于进入和退出监视器对象(Monitor,管程对象)来实现的，每个对象实例都会有一个Monitor对象，</p><pre><code class="highlight java"><span class="type">Object</span> <span class="variable">o</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Object</span>();<span class="keyword">new</span> <span class="title class_">Thread</span>(() -&gt; &#123;    <span class="keyword">synchronized</span> (o)    &#123;    &#125;&#125;,<span class="string">&quot;t1&quot;</span>).start();</code></pre><p>Monitor对象会和Java对象一同创建并销毁，它底层是由C++语言来实现的。</p></li></ul><p><img src="https://raw.githubusercontent.com/GeorgeChan95/blogimg/master/img/2024/09/18/20240918-153629.png" alt="同步指令"></p><h1 id="二、用户线程和守护线程"><a href="#二、用户线程和守护线程" class="headerlink" title="二、用户线程和守护线程"></a>二、用户线程和守护线程</h1><p>Java线程分为用户线程和守护线程，<strong>线程的daemon属性为true表示是守护线程，false表示是用户线程</strong></p><ul><li><p>守护线程</p><p>是一种特殊的线程，在后台默默地完成一些系统性的服务，比如垃圾回收线程</p></li><li><p>用户线程</p><p>是系统的工作线程，它会完成这个程序需要完成的业务操作</p></li></ul><p><strong>代码示例：</strong></p><pre><code class="highlight java"><span class="comment">/**</span><span class="comment"> * &lt;p&gt;</span><span class="comment"> * 演示守护线程和用户线程</span><span class="comment"> * &lt;/p&gt;</span><span class="comment"> */</span><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">DaemonDemo</span> &#123;    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;        <span class="type">Thread</span> <span class="variable">a</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Thread</span>(() -&gt; &#123;            System.out.println(Thread.currentThread().getName() + <span class="string">&quot; come in：\t&quot;</span>                    + (Thread.currentThread().isDaemon() ? <span class="string">&quot;守护线程&quot;</span> : <span class="string">&quot;用户线程&quot;</span>));            <span class="keyword">while</span> (<span class="literal">true</span>) &#123;            &#125;        &#125;, <span class="string">&quot;a&quot;</span>);        a.setDaemon(<span class="literal">true</span>); <span class="comment">// daemon设置为true，表示该线程为守护线程</span>        <span class="comment">// setDaemon 必须在 start() 方法之前</span>        a.start();        <span class="comment">//暂停几秒钟线程</span>        <span class="keyword">try</span> &#123;            TimeUnit.SECONDS.sleep(<span class="number">2</span>);        &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;            e.printStackTrace();        &#125;        System.out.println(Thread.currentThread().getName() + <span class="string">&quot;\t&quot;</span> + <span class="string">&quot; ----task is over&quot;</span>);    &#125;&#125;</code></pre><p>运行结果：</p><pre><code class="highlight shell">a come in：守护线程main ----task is over</code></pre><p>结论：当主线程(用户线程)结束后，守护线程也随之结束了。</p><p><strong>重点</strong></p><ul><li><p>当程序中所有用户线程执行完毕之后，不管守护线程是否结束，系统都会自动退出</p><p>如果用户线程全部结束了，意味着程序需要完成的业务操作已经结束了，系统可以退出了。所以当系统只剩下守护进程的时候，java虚拟机会自动退出</p></li><li><p>设置守护线程，需要在start()方法之前进行</p></li></ul>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;一、Java多线程相关概念&quot;&gt;&lt;a href=&quot;#一、Java多线程相关概念&quot; class=&quot;headerlink&quot; title=&quot;一、Java多线程相关概念&quot;&gt;&lt;/a&gt;一、Java多线程相关概念&lt;/h1&gt;&lt;ul&gt;
&lt;li&gt;&lt;p&gt;&lt;strong&gt;进程&lt;/stron</summary>
      
    
    
    
    <category term="JUC" scheme="https://georgechan95.github.io/categories/JUC/"/>
    
    
    <category term="juc" scheme="https://georgechan95.github.io/tags/juc/"/>
    
    <category term="java" scheme="https://georgechan95.github.io/tags/java/"/>
    
  </entry>
  
  <entry>
    <title>11-CompletableFuture</title>
    <link href="https://georgechan95.github.io/blog/37d56d14.html"/>
    <id>https://georgechan95.github.io/blog/37d56d14.html</id>
    <published>2024-09-16T08:12:00.000Z</published>
    <updated>2024-09-18T07:30:50.861Z</updated>
    
    <content type="html"><![CDATA[<h1 id="一、CompletableFuture-简介"><a href="#一、CompletableFuture-简介" class="headerlink" title="一、CompletableFuture 简介"></a>一、CompletableFuture 简介</h1><p>CompletableFuture 在 Java 里面被用于异步编程，异步通常意味着非阻塞，可以使得我们的任务单独运行在与主线程分离的其他线程中，并且通过回调可以在主线程中得到异步任务的执行状态，是否完成，和是否异常等信息。</p><p>CompletableFuture 实现了 Future, CompletionStage 接口，实现了 Future接口就可以兼容现在有线程池框架，而 CompletionStage 接口才是异步编程的接口抽象，里面定义多种异步方法，通过这两者集合，从而打造出了强大的 CompletableFuture 类。</p><h1 id="二、Future-与-CompletableFuture"><a href="#二、Future-与-CompletableFuture" class="headerlink" title="二、Future 与 CompletableFuture"></a>二、Future 与 CompletableFuture</h1><p>Futrue 在 Java 里面，通常用来表示一个异步任务的引用，比如我们将任务提交到线程池里面，然后我们会得到一个 Futrue，在 Future 里面有 isDone 方法来 判断任务是否处理结束，还有 get 方法可以一直阻塞直到任务结束然后获取结果，但整体来说这种方式，还是同步的，因为需要客户端不断阻塞等待或者不断轮询才能知道任务是否完成。</p><p><strong>Future 的主要缺点如下：</strong></p><ul><li><p>不支持手动完成</p><p>我提交了一个任务，但是执行太慢了，我通过其他路径已经获取到了任务结果，现在没法把这个任务结果通知到正在执行的线程，所以必须主动取消或者一直等待它执行完成</p></li><li><p>不支持进一步的非阻塞调用</p><p>通过 Future 的 get 方法会一直阻塞到任务完成，但是想在获取任务之后执行额外的任务，因为 Future 不支持回调函数，所以无法实现这个功能</p></li><li><p>不支持链式调用</p><p>对于 Future 的执行结果，我们想继续传到下一个 Future 处理使用，从而形成一个链式的 pipline 调用，这在 Future 中是没法实现的。</p></li><li><p>不支持多个 Future 合并</p><p>比如我们有 10 个 Future 并行执行，我们想在所有的 Future 运行完毕之后，执行某些函数，是没法通过 Future 实现的。</p></li><li><p>不支持异常处理</p><p>Future 的 API 没有任何的异常处理的 api，所以在异步运行时，如果出了问题是不好定位的。</p></li></ul><h1 id="三、CompletableFuture-入门"><a href="#三、CompletableFuture-入门" class="headerlink" title="三、CompletableFuture 入门"></a>三、CompletableFuture 入门</h1><h2 id="1-使用-CompletableFuture"><a href="#1-使用-CompletableFuture" class="headerlink" title="1. 使用 CompletableFuture"></a>1. 使用 CompletableFuture</h2><p>场景:主线程里面创建一个 CompletableFuture，然后主线程调用 get 方法会阻塞，最后我们在一个子线程中使其终止。</p><pre><code class="highlight java"><span class="comment">/**</span><span class="comment"> * 主线程里面创建一个 CompletableFuture，然后主线程调用 get 方法会阻塞，最后我们在一个子线程中使其终止</span><span class="comment"> *</span><span class="comment"> * <span class="doctag">@throws</span> InterruptedException</span><span class="comment"> * <span class="doctag">@throws</span> ExecutionException</span><span class="comment"> */</span><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">method1</span><span class="params">()</span> <span class="keyword">throws</span> InterruptedException, ExecutionException &#123;    CompletableFuture&lt;String&gt; future = <span class="keyword">new</span> <span class="title class_">CompletableFuture</span>&lt;&gt;();    <span class="keyword">new</span> <span class="title class_">Thread</span>(() -&gt; &#123;        <span class="keyword">try</span> &#123;            System.out.println(Thread.currentThread().getName() + <span class="string">&quot;子线程开始干活&quot;</span>);            <span class="comment">//子线程睡 5 秒</span>            Thread.sleep(<span class="number">5000</span>);            <span class="comment">//在子线程中完成主线程</span>            future.complete(<span class="string">&quot;success&quot;</span>);        &#125; <span class="keyword">catch</span> (Exception e) &#123;            e.printStackTrace();        &#125;    &#125;, <span class="string">&quot;A&quot;</span>).start();    <span class="comment">//主线程调用 get 方法阻塞</span>    System.out.println(<span class="string">&quot;主线程调用 get 方法获取结果为: &quot;</span> + future.get());    System.out.println(<span class="string">&quot;主线程完成,阻塞结束!!!!!!&quot;</span>);&#125;</code></pre><p>打印结果:</p><pre><code class="highlight shell">A子线程开始干活主线程调用 get 方法获取结果为: success主线程完成,阻塞结束!!!!!!</code></pre><h2 id="2-没有返回值的异步任务"><a href="#2-没有返回值的异步任务" class="headerlink" title="2. 没有返回值的异步任务"></a>2. 没有返回值的异步任务</h2><pre><code class="highlight java"><span class="comment">/**</span><span class="comment">    * 没有返回值的异步任务</span><span class="comment">    *</span><span class="comment">    * <span class="doctag">@throws</span> InterruptedException</span><span class="comment">    * <span class="doctag">@throws</span> ExecutionException</span><span class="comment">    */</span>   <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">method2</span><span class="params">()</span> <span class="keyword">throws</span> InterruptedException, ExecutionException &#123;       CompletableFuture&lt;Void&gt; future = <span class="keyword">new</span> <span class="title class_">CompletableFuture</span>&lt;&gt;();       <span class="keyword">new</span> <span class="title class_">Thread</span>(() -&gt; &#123;           <span class="keyword">try</span> &#123;               System.out.println(Thread.currentThread().getName() + <span class="string">&quot;开始作业&quot;</span>);               TimeUnit.SECONDS.sleep(<span class="number">5</span>);               System.out.println(Thread.currentThread().getName() + <span class="string">&quot; 完成作业&quot;</span>);           &#125; <span class="keyword">catch</span> (Exception e) &#123;               e.printStackTrace();           &#125;       &#125;, <span class="string">&quot;线程1&quot;</span>).start();       <span class="comment">//主线程调用 get 方法阻塞</span>       future.get();       System.out.println(<span class="string">&quot;主线程结束&quot;</span>);   &#125;</code></pre><p>运行结果:</p><pre><code class="highlight shell">线程1开始作业线程1 完成作业</code></pre><h2 id="3-有返回值的异步任务"><a href="#3-有返回值的异步任务" class="headerlink" title="3. 有返回值的异步任务"></a>3. 有返回值的异步任务</h2><pre><code class="highlight java"><span class="comment">/**</span><span class="comment"> * 有返回值的异步任务</span><span class="comment"> *</span><span class="comment"> * <span class="doctag">@throws</span> InterruptedException</span><span class="comment"> * <span class="doctag">@throws</span> ExecutionException</span><span class="comment"> */</span><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">method3</span><span class="params">()</span> <span class="keyword">throws</span> InterruptedException, ExecutionException &#123;    CompletableFuture&lt;String&gt; future = CompletableFuture.supplyAsync(<span class="keyword">new</span> <span class="title class_">Supplier</span>&lt;String&gt;() &#123;        <span class="meta">@Override</span>        <span class="keyword">public</span> String <span class="title function_">get</span><span class="params">()</span> &#123;            <span class="keyword">try</span> &#123;                System.out.println(Thread.currentThread().getName() + <span class="string">&quot;开始作业&quot;</span>);                TimeUnit.SECONDS.sleep(<span class="number">5</span>);                System.out.println(Thread.currentThread().getName() + <span class="string">&quot; 完成作业&quot;</span>);            &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;                e.printStackTrace();            &#125;            <span class="keyword">return</span> <span class="string">&quot;异步结果&quot;</span>;        &#125;    &#125;);    <span class="comment">//主线程调用 get 方法阻塞</span>    future.get();    System.out.println(<span class="string">&quot;主线程结束&quot;</span>);&#125;</code></pre><p><strong>运行结果:</strong></p><pre><code class="highlight shell">ForkJoinPool.commonPool-worker-19开始作业ForkJoinPool.commonPool-worker-19 完成作业主线程结束</code></pre><h2 id="4-线程依赖"><a href="#4-线程依赖" class="headerlink" title="4. 线程依赖"></a>4. 线程依赖</h2><p>当一个线程依赖另一个线程时，可以使用 thenApply 方法来把这两个线程串行化。</p><pre><code class="highlight java"><span class="keyword">private</span> <span class="keyword">static</span> <span class="type">int</span> <span class="variable">num</span> <span class="operator">=</span> <span class="number">0</span>;<span class="comment">/**</span><span class="comment"> * 线程依赖</span><span class="comment"> * 先对一个数加 10,然后取平方</span><span class="comment"> * <span class="doctag">@throws</span> InterruptedException</span><span class="comment"> * <span class="doctag">@throws</span> ExecutionException</span><span class="comment"> */</span><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">method4</span><span class="params">()</span> <span class="keyword">throws</span> InterruptedException, ExecutionException &#123;    CompletableFuture&lt;Integer&gt; future = CompletableFuture.supplyAsync(() -&gt; &#123;        System.out.println(Thread.currentThread().getName() + <span class="string">&quot;开始对值进行 +10 操作&quot;</span>);        num += <span class="number">10</span>;        System.out.println(Thread.currentThread().getName() + <span class="string">&quot; 完成作业&quot;</span>);        <span class="keyword">return</span> num;    &#125;).thenApply(<span class="keyword">new</span> <span class="title class_">Function</span>&lt;Integer, Integer&gt;() &#123;        <span class="meta">@Override</span>        <span class="keyword">public</span> Integer <span class="title function_">apply</span><span class="params">(Integer data)</span> &#123;            System.out.println(Thread.currentThread().getName() + <span class="string">&quot;开始对值进行 取平方 操作&quot;</span>);            System.out.println(<span class="string">&quot;integer: &quot;</span> + data);            <span class="keyword">return</span> data*data;        &#125;    &#125;);    <span class="comment">//主线程调用 get 方法阻塞</span>    System.out.println(<span class="string">&quot;主线程阻塞获取结果,结果为:&quot;</span> + future.get());    System.out.println(<span class="string">&quot;主线程结束&quot;</span>);&#125;</code></pre><p>运行结果:</p><pre><code class="highlight shell">ForkJoinPool.commonPool-worker-19开始对值进行 +10 操作ForkJoinPool.commonPool-worker-19 完成作业ForkJoinPool.commonPool-worker-19开始对值进行 取平方 操作integer: 10主线程阻塞获取结果,结果为:100主线程结束</code></pre><h2 id="5-消费处理结果"><a href="#5-消费处理结果" class="headerlink" title="5. 消费处理结果"></a>5. 消费处理结果</h2><p>thenAccept 消费处理结果, 接收任务的处理结果，并消费处理，无返回结果。</p><pre><code class="highlight java"><span class="comment">/**</span><span class="comment"> * thenAccept 消费处理结果, 接收任务的处理结果，并消费处理，无返回结果。</span><span class="comment"> * </span><span class="comment"> * <span class="doctag">@throws</span> InterruptedException</span><span class="comment"> * <span class="doctag">@throws</span> ExecutionException</span><span class="comment"> */</span><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">method5</span><span class="params">()</span> <span class="keyword">throws</span> InterruptedException, ExecutionException &#123;    CompletableFuture&lt;Void&gt; completableFuture = CompletableFuture.supplyAsync(() -&gt; &#123;        System.out.println(Thread.currentThread().getName() + <span class="string">&quot;开始对值进行 +10 操作&quot;</span>);        num += <span class="number">10</span>;        System.out.println(Thread.currentThread().getName() + <span class="string">&quot; 完成作业&quot;</span>);        <span class="keyword">return</span> num;    &#125;).thenApply(data -&gt; &#123;        System.out.println(Thread.currentThread().getName() + <span class="string">&quot;开始对值进行 取平方 操作&quot;</span>);        System.out.println(<span class="string">&quot;integer: &quot;</span> + data);        <span class="keyword">return</span> data * data;    &#125;).thenAccept(integer -&gt; &#123;        System.out.println(<span class="string">&quot;子线程全部处理完成,最后调用了 accept,结果为:&quot;</span> + integer);    &#125;);    <span class="comment">//主线程调用 get 方法阻塞</span>    System.out.println(<span class="string">&quot;主线程阻塞获取结果,结果为:&quot;</span> + completableFuture.get());    System.out.println(<span class="string">&quot;主线程结束&quot;</span>);&#125;</code></pre><p>运行结果:</p><pre><code class="highlight shell">ForkJoinPool.commonPool-worker-19开始对值进行 +10 操作ForkJoinPool.commonPool-worker-19 完成作业ForkJoinPool.commonPool-worker-19开始对值进行 取平方 操作integer: 10子线程全部处理完成,最后调用了 accept,结果为:100主线程阻塞获取结果,结果为:null主线程结束</code></pre><h2 id="6-异常处理"><a href="#6-异常处理" class="headerlink" title="6. 异常处理"></a>6. 异常处理</h2><p>exceptionally 异常处理,出现异常时触发</p><pre><code class="highlight java"><span class="comment">/**</span><span class="comment"> * exceptionally 异常处理,出现异常时触发</span><span class="comment"> * <span class="doctag">@throws</span> InterruptedException</span><span class="comment"> * <span class="doctag">@throws</span> ExecutionException</span><span class="comment"> */</span><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">method6</span><span class="params">()</span> <span class="keyword">throws</span> InterruptedException, ExecutionException &#123;    CompletableFuture&lt;Integer&gt; completableFuture = CompletableFuture.supplyAsync(() -&gt; &#123;        <span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">1</span> / <span class="number">0</span>;        System.out.println(Thread.currentThread().getName() + <span class="string">&quot;开始对值进行 +10 操作&quot;</span>);        num += <span class="number">10</span>;        System.out.println(Thread.currentThread().getName() + <span class="string">&quot; 完成作业&quot;</span>);        <span class="keyword">return</span> num;    &#125;).exceptionally(throwable -&gt; &#123;        System.out.println(throwable.getMessage());        <span class="keyword">return</span> -<span class="number">1</span>;    &#125;);    <span class="comment">//主线程调用 get 方法阻塞</span>    System.out.println(<span class="string">&quot;主线程阻塞获取结果,结果为:&quot;</span> + completableFuture.get());    System.out.println(<span class="string">&quot;主线程结束&quot;</span>);&#125;</code></pre><p>执行结果:</p><pre><code class="highlight shell">java.lang.ArithmeticException: / by zero主线程阻塞获取结果,结果为:-1主线程结束</code></pre><p><strong>handle 类似于 thenAccept&#x2F;thenRun 方法,是最后一步的处理调用,但是同时可以处理异常</strong></p><pre><code class="highlight java"><span class="comment">/**</span><span class="comment"> * handle 类似于 thenAccept/thenRun 方法,是最后一步的处理调用,但是同时可以处理异常</span><span class="comment"> */</span><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">method7</span><span class="params">()</span> &#123;    System.out.println(<span class="string">&quot;主线程开始&quot;</span>);    CompletableFuture&lt;Integer&gt; future = CompletableFuture.supplyAsync(() -&gt; &#123;        System.out.println(<span class="string">&quot;加 10 任务开始&quot;</span>);        num += <span class="number">10</span>;        <span class="keyword">return</span> num;    &#125;).handle((i, ex) -&gt; &#123;        System.out.println(<span class="string">&quot;进入 handle 方法&quot;</span>);        <span class="keyword">if</span> (ex != <span class="literal">null</span>) &#123;            System.out.print(<span class="string">&quot;发生了异常,内容为:&quot;</span>);            System.out.println(ex.getMessage());            <span class="keyword">return</span> -<span class="number">1</span>;        &#125; <span class="keyword">else</span> &#123;            System.out.println(<span class="string">&quot;正常完成,内容为: &quot;</span> + i);            <span class="keyword">return</span> i;        &#125;    &#125;);&#125;</code></pre><p>运行结果:</p><pre><code class="highlight shell">主线程开始加 10 任务开始进入 handle 方法正常完成,内容为: 10</code></pre><p>发生异常时:</p><pre><code class="highlight shell">主线程开始加 10 任务开始进入 handle 方法发生了异常,内容为:java.lang.ArithmeticException: / by zero</code></pre><h2 id="7-结果合并"><a href="#7-结果合并" class="headerlink" title="7. 结果合并"></a>7. 结果合并</h2><p><strong>thenCompose 合并两个有依赖关系的 CompletableFutures 的执行结果.</strong></p><pre><code class="highlight java"><span class="comment">/**</span><span class="comment"> * thenCompose 合并两个有依赖关系的 CompletableFutures 的执行结果</span><span class="comment"> * <span class="doctag">@throws</span> ExecutionException</span><span class="comment"> * <span class="doctag">@throws</span> InterruptedException</span><span class="comment"> */</span><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">method8</span><span class="params">()</span> <span class="keyword">throws</span> ExecutionException, InterruptedException &#123;    System.out.println(<span class="string">&quot;主线程开始......&quot;</span>);    <span class="comment">//第一步加 10</span>    CompletableFuture&lt;Integer&gt; future1 = CompletableFuture.supplyAsync(() -&gt; &#123;        System.out.println(Thread.currentThread().getName() + <span class="string">&quot;线程执行num加10&quot;</span>);        num += <span class="number">10</span>;        <span class="keyword">return</span> num;    &#125;);    <span class="comment">// 合并</span>    CompletableFuture&lt;Integer&gt; future2 = future1.thenCompose(data -&gt; CompletableFuture.supplyAsync(() -&gt; &#123;        System.out.println(Thread.currentThread().getName() + <span class="string">&quot;线程执行合并&quot;</span>);        <span class="keyword">return</span> data + <span class="number">1</span>;    &#125;));    System.out.println(<span class="string">&quot;主线程阻塞获取结果: &quot;</span> + future1.get());    System.out.println(<span class="string">&quot;主线程阻塞获取结果: &quot;</span> + future2.get());&#125;</code></pre><p>执行结果:</p><pre><code class="highlight shell">主线程开始......ForkJoinPool.commonPool-worker-19线程执行num加10ForkJoinPool.commonPool-worker-5线程执行合并主线程阻塞获取结果: 10主线程阻塞获取结果: 11</code></pre><p><strong>thenCombine 合并两个没有依赖关系的 CompletableFutures 任务</strong></p><pre><code class="highlight java"><span class="comment">/**</span><span class="comment"> * thenCombine 合并两个没有依赖关系的 CompletableFutures 任务</span><span class="comment"> * <span class="doctag">@throws</span> ExecutionException</span><span class="comment"> * <span class="doctag">@throws</span> InterruptedException</span><span class="comment"> */</span><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">method9</span><span class="params">()</span> <span class="keyword">throws</span> ExecutionException, InterruptedException &#123;    System.out.println(<span class="string">&quot;主线程开始......&quot;</span>);    <span class="comment">//第一个线程加 10</span>    CompletableFuture&lt;Integer&gt; future1 = CompletableFuture.supplyAsync(() -&gt; &#123;        System.out.println(Thread.currentThread().getName() + <span class="string">&quot;线程执行num加10&quot;</span>);        num += <span class="number">10</span>;        <span class="keyword">return</span> num;    &#125;);    <span class="comment">// 第二个线程 *10</span>    CompletableFuture&lt;Integer&gt; future2 = CompletableFuture.supplyAsync(() -&gt; &#123;        System.out.println(Thread.currentThread().getName() + <span class="string">&quot;线程执行num * 10&quot;</span>);        num *= <span class="number">10</span>;        <span class="keyword">return</span> num;    &#125;);    <span class="comment">// 合并两个CompletableFuture</span>    CompletableFuture&lt;Object&gt; combine = future1.thenCombine(future2, (a, b) -&gt; &#123;        List&lt;Integer&gt; list = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();        list.add(a);        list.add(b);        <span class="keyword">return</span> list;    &#125;);    System.out.println(<span class="string">&quot;主线程阻塞获取future1结果: &quot;</span> + future1.get());    System.out.println(<span class="string">&quot;主线程阻塞获取future2结果: &quot;</span> + future2.get());    System.out.println(<span class="string">&quot;主线程阻塞获取combine结果: &quot;</span> + combine.get());&#125;</code></pre><p>执行结果:</p><pre><code class="highlight shell">主线程开始......ForkJoinPool.commonPool-worker-19线程执行num加10ForkJoinPool.commonPool-worker-5线程执行num * 10主线程阻塞获取future1结果: 10主线程阻塞获取future2结果: 100主线程阻塞获取combine结果: [10, 100]</code></pre><p><strong>合并多个任务的结果 allOf 与 anyOf</strong></p><p><strong>allOf:</strong>  一系列独立的 future 任务，等其所有的任务执行完后做一些事情</p><pre><code class="highlight java"><span class="comment">/**</span><span class="comment"> * allOf: 一系列独立的 future 任务，等其所有的任务执行完后做一些事情</span><span class="comment"> */</span><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">method10</span><span class="params">()</span> &#123;    System.out.println(<span class="string">&quot;主线程开始&quot;</span>);    List&lt;CompletableFuture&gt; list = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();    CompletableFuture&lt;Integer&gt; job1 = CompletableFuture.supplyAsync(() -&gt; &#123;        System.out.println(<span class="string">&quot;加 10 任务开始&quot;</span>);        num += <span class="number">10</span>;        <span class="keyword">return</span> num;    &#125;);    list.add(job1);    CompletableFuture&lt;Integer&gt; job2 = CompletableFuture.supplyAsync(() -&gt; &#123;        System.out.println(<span class="string">&quot;乘以 10 任务开始&quot;</span>);        num = num * <span class="number">10</span>;        <span class="keyword">return</span> num;    &#125;);    list.add(job2);    CompletableFuture&lt;Integer&gt; job3 = CompletableFuture.supplyAsync(() -&gt; &#123;        System.out.println(<span class="string">&quot;减以 10 任务开始&quot;</span>);        num = num * <span class="number">10</span>;        <span class="keyword">return</span> num;    &#125;);    list.add(job3);    CompletableFuture&lt;Integer&gt; job4 = CompletableFuture.supplyAsync(() -&gt; &#123;        System.out.println(<span class="string">&quot;除以 10 任务开始&quot;</span>);        num = num * <span class="number">10</span>;        <span class="keyword">return</span> num;    &#125;);    list.add(job4);    <span class="comment">//多任务合并</span>    List&lt;Integer&gt; collect =            list.stream().map(CompletableFuture&lt;Integer&gt;::join).collect(Collectors.toList());    System.out.println(<span class="string">&quot;所有任务执行结束,结果为: &quot;</span> + collect);&#125;</code></pre><p>运行结果:</p><pre><code class="highlight shell">主线程开始乘以 10 任务开始加 10 任务开始减以 10 任务开始除以 10 任务开始所有任务执行结束,结果为: [10, 0, 100, 1000]</code></pre><p><strong>anyOf</strong>: 只要在多个 future 里面有一个返回，整个任务就可以结束，而不需要等到每一个future 结束</p><pre><code class="highlight java"><span class="comment">/**</span><span class="comment"> * anyOf: 只要在多个 future 里面有一个返回，整个任务就可以结束，而不需要等到每一个future 结束</span><span class="comment"> * <span class="doctag">@throws</span> ExecutionException</span><span class="comment"> * <span class="doctag">@throws</span> InterruptedException</span><span class="comment"> */</span><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">method11</span><span class="params">()</span> <span class="keyword">throws</span> ExecutionException, InterruptedException &#123;    System.out.println(<span class="string">&quot;主线程开始&quot;</span>);    CompletableFuture&lt;Integer&gt;[] futures = <span class="keyword">new</span> <span class="title class_">CompletableFuture</span>[<span class="number">4</span>];    CompletableFuture&lt;Integer&gt; job1 = CompletableFuture.supplyAsync(() -&gt; &#123;        System.out.println(<span class="string">&quot;加 10 任务开始&quot;</span>);        num += <span class="number">10</span>;        <span class="keyword">return</span> num;    &#125;);    futures[<span class="number">0</span>] = job1;    CompletableFuture&lt;Integer&gt; job2 = CompletableFuture.supplyAsync(() -&gt; &#123;        System.out.println(<span class="string">&quot;乘以 10 任务开始&quot;</span>);        num = num * <span class="number">10</span>;        <span class="keyword">return</span> num;    &#125;);    futures[<span class="number">1</span>] = job2;    CompletableFuture&lt;Integer&gt; job3 = CompletableFuture.supplyAsync(() -&gt; &#123;        System.out.println(<span class="string">&quot;减以 10 任务开始&quot;</span>);        num = num * <span class="number">10</span>;        <span class="keyword">return</span> num;    &#125;);    futures[<span class="number">2</span>] = job3;    CompletableFuture&lt;Integer&gt; job4 = CompletableFuture.supplyAsync(() -&gt; &#123;        System.out.println(<span class="string">&quot;除以 10 任务开始&quot;</span>);        num = num * <span class="number">10</span>;        <span class="keyword">return</span> num;    &#125;);    futures[<span class="number">3</span>] = job4;    CompletableFuture&lt;Object&gt; future = CompletableFuture.anyOf(futures);    System.out.println(future.get());    System.out.println(<span class="string">&quot;其中一个任务执行结束,结果为: &quot;</span> + future.get());&#125;</code></pre><p>执行结果:</p><pre><code class="highlight shell">主线程开始乘以 10 任务开始加 10 任务开始减以 10 任务开始10除以 10 任务开始其中一个任务执行结束,结果为: 10</code></pre>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;一、CompletableFuture-简介&quot;&gt;&lt;a href=&quot;#一、CompletableFuture-简介&quot; class=&quot;headerlink&quot; title=&quot;一、CompletableFuture 简介&quot;&gt;&lt;/a&gt;一、CompletableFuture </summary>
      
    
    
    
    <category term="JUC" scheme="https://georgechan95.github.io/categories/JUC/"/>
    
    
    <category term="juc" scheme="https://georgechan95.github.io/tags/juc/"/>
    
    <category term="java" scheme="https://georgechan95.github.io/tags/java/"/>
    
  </entry>
  
  <entry>
    <title>10-Fork/Join</title>
    <link href="https://georgechan95.github.io/blog/31919959.html"/>
    <id>https://georgechan95.github.io/blog/31919959.html</id>
    <published>2024-09-16T05:10:00.000Z</published>
    <updated>2024-09-18T07:30:50.861Z</updated>
    
    <content type="html"><![CDATA[<h1 id="一、Fork-Join-框架简介"><a href="#一、Fork-Join-框架简介" class="headerlink" title="一、Fork&#x2F;Join 框架简介"></a>一、Fork&#x2F;Join 框架简介</h1><p>Fork&#x2F;Join 它可以将一个大的任务拆分成多个子任务进行并行处理，最后将子任务结果合并成最后的计算结果，并进行输出。Fork&#x2F;Join 框架要完成两件事情：</p><p><strong>Fork：把一个复杂任务进行分拆，大事化小</strong></p><p><strong>Join：把分拆任务的结果进行合并</strong></p><p><img src="https://raw.githubusercontent.com/GeorgeChan95/blogimg/master/img/2024/09/16/20240916-150030.png" alt="任务拆分"></p><ul><li><strong>任务分割：</strong>首先 Fork&#x2F;Join 框架需要把大的任务分割成足够小的子任务，如果子任务比较大的话还要对子任务进行继续分割</li><li><strong>执行任务并合并结果：</strong>分割的子任务分别放到双端队列里，然后几个启动线程分别从双端队列里获取任务执行。子任务执行完的结果都放在另外一个队列里，启动一个线程从队列里取数据，然后合并这些数据。</li></ul><p>在 Java 的 Fork&#x2F;Join 框架中，使用两个类完成上述操作</p><ul><li><strong>ForkJoinTask:</strong> 我们要使用 Fork&#x2F;Join 框架，首先需要创建一个 ForkJoin 任务。该类提供了在任务中执行 fork 和 join 的机制。通常情况下我们不需要直接集成 ForkJoinTask 类，只需要继承它的子类，Fork&#x2F;Join 框架提供了两个子类：<ul><li>RecursiveAction：用于没有返回结果的任务</li><li>RecursiveTask: 用于有返回结果的任务</li></ul></li><li><strong>ForkJoinPool</strong>: ForkJoinTask 需要通过 ForkJoinPool 来执行</li><li><strong>RecursiveTask</strong>: 继承后可以实现递归(自己调自己)调用的任务</li></ul><p><strong>Fork&#x2F;Join 框架的实现原理</strong></p><p>ForkJoinPool 由 ForkJoinTask 数组和 ForkJoinWorkerThread 数组组成，ForkJoinTask 数组负责将存放以及将程序提交给 ForkJoinPool，而ForkJoinWorkerThread 负责执行这些任务。</p><h1 id="二、Fork-方法"><a href="#二、Fork-方法" class="headerlink" title="二、Fork 方法"></a>二、Fork 方法</h1><p><img src="https://raw.githubusercontent.com/GeorgeChan95/blogimg/master/img/2024/09/16/20240916-150946.png" alt="ForkJoinPool继承体系"></p><p><img src="https://raw.githubusercontent.com/GeorgeChan95/blogimg/master/img/2024/09/16/20240916-151158.png" alt="ForkJoinTask继承体系"></p><p><strong>Fork 方法的实现原理：</strong> 当我们调用 ForkJoinTask 的 fork 方法时，程序会把任务放在 ForkJoinWorkerThread 的 pushTask 的 workQueue 中，异步地执行这个任务，然后立即返回结果. </p><pre><code class="highlight java"><span class="comment">/**</span><span class="comment"> * Arranges to asynchronously execute this task in the pool the</span><span class="comment"> * current task is running in, if applicable, or using the &#123;<span class="doctag">@link</span></span><span class="comment"> * ForkJoinPool#commonPool()&#125; if not &#123;<span class="doctag">@link</span> #inForkJoinPool&#125;.  While</span><span class="comment"> * it is not necessarily enforced, it is a usage error to fork a</span><span class="comment"> * task more than once unless it has completed and been</span><span class="comment"> * reinitialized.  Subsequent modifications to the state of this</span><span class="comment"> * task or any data it operates on are not necessarily</span><span class="comment"> * consistently observable by any thread other than the one</span><span class="comment"> * executing it unless preceded by a call to &#123;<span class="doctag">@link</span> #join&#125; or</span><span class="comment"> * related methods, or a call to &#123;<span class="doctag">@link</span> #isDone&#125; returning &#123;<span class="doctag">@code</span></span><span class="comment"> * true&#125;.</span><span class="comment"> *</span><span class="comment"> * <span class="doctag">@return</span> &#123;<span class="doctag">@code</span> this&#125;, to simplify usage</span><span class="comment"> */</span><span class="keyword">public</span> <span class="keyword">final</span> ForkJoinTask&lt;V&gt; <span class="title function_">fork</span><span class="params">()</span> &#123;    Thread t;    <span class="keyword">if</span> ((t = Thread.currentThread()) <span class="keyword">instanceof</span> ForkJoinWorkerThread)        ((ForkJoinWorkerThread)t).workQueue.push(<span class="built_in">this</span>);    <span class="keyword">else</span>        ForkJoinPool.common.externalPush(<span class="built_in">this</span>);    <span class="keyword">return</span> <span class="built_in">this</span>;&#125;</code></pre><p>pushTask 方法把当前任务存放在 ForkJoinTask 数组队列里。然后再调用ForkJoinPool 的 signalWork()方法唤醒或创建一个工作线程来执行任务。代码如下：</p><pre><code class="highlight java"><span class="comment">/**</span><span class="comment"> * Pushes a task. Call only by owner in unshared queues.</span><span class="comment"> *</span><span class="comment"> * <span class="doctag">@param</span> task the task. Caller must ensure non-null.</span><span class="comment"> * <span class="doctag">@throws</span> RejectedExecutionException if array cannot be resized</span><span class="comment"> */</span><span class="keyword">final</span> <span class="keyword">void</span> <span class="title function_">push</span><span class="params">(ForkJoinTask&lt;?&gt; task)</span> &#123;    ForkJoinTask&lt;?&gt;[] a;    <span class="type">int</span> <span class="variable">s</span> <span class="operator">=</span> top, d, cap, m;    <span class="type">ForkJoinPool</span> <span class="variable">p</span> <span class="operator">=</span> pool;    <span class="keyword">if</span> ((a = array) != <span class="literal">null</span> &amp;&amp; (cap = a.length) &gt; <span class="number">0</span>) &#123;        QA.setRelease(a, (m = cap - <span class="number">1</span>) &amp; s, task);        top = s + <span class="number">1</span>;        <span class="keyword">if</span> (((d = s - (<span class="type">int</span>)BASE.getAcquire(<span class="built_in">this</span>)) &amp; ~<span class="number">1</span>) == <span class="number">0</span> &amp;&amp;                p != <span class="literal">null</span>) &#123;                 <span class="comment">// size 0 or 1</span>            VarHandle.fullFence();            p.signalWork();        &#125;        <span class="keyword">else</span> <span class="keyword">if</span> (d == m)            growArray(<span class="literal">false</span>);    &#125;&#125;</code></pre><h1 id="三、join-方法"><a href="#三、join-方法" class="headerlink" title="三、join 方法"></a>三、join 方法</h1><p>Join 方法的主要作用是阻塞当前线程并等待获取结果。让我们一起看看 ForkJoinTask 的 join 方法的实现，代码如下：</p><pre><code class="highlight java"><span class="comment">/**</span><span class="comment"> * Returns the result of the computation when it</span><span class="comment"> * &#123;<span class="doctag">@linkplain</span> #isDone is done&#125;.</span><span class="comment"> * This method differs from &#123;<span class="doctag">@link</span> #get()&#125; in that abnormal</span><span class="comment"> * completion results in &#123;<span class="doctag">@code</span> RuntimeException&#125; or &#123;<span class="doctag">@code</span> Error&#125;,</span><span class="comment"> * not &#123;<span class="doctag">@code</span> ExecutionException&#125;, and that interrupts of the</span><span class="comment"> * calling thread do &lt;em&gt;not&lt;/em&gt; cause the method to abruptly</span><span class="comment"> * return by throwing &#123;<span class="doctag">@code</span> InterruptedException&#125;.</span><span class="comment"> *</span><span class="comment"> * <span class="doctag">@return</span> the computed result</span><span class="comment"> */</span><span class="keyword">public</span> <span class="keyword">final</span> V <span class="title function_">join</span><span class="params">()</span> &#123;    <span class="type">int</span> s;    <span class="keyword">if</span> (((s = doJoin()) &amp; ABNORMAL) != <span class="number">0</span>)        reportException(s);    <span class="keyword">return</span> getRawResult();&#125;</code></pre><p>它首先调用 doJoin 方法，通过 doJoin()方法得到当前任务的状态来判断返回什么结果，任务状态有 4 种：</p><p><strong>已完成（NORMAL）</strong>、<strong>被取消（CANCELLED）</strong>、<strong>信号（SIGNAL）</strong>和 <strong>出现异常（EXCEPTIONAL）</strong></p><ul><li>如果任务状态是已完成，则直接返回任务结果。</li><li>如果任务状态是被取消，则直接抛出 CancellationException</li><li>如果任务状态是抛出异常，则直接抛出对应的异常</li></ul><p><strong>分析一下 doJoin 方法的实现</strong></p><pre><code class="highlight java"><span class="comment">/**</span><span class="comment"> * Implementation for join, get, quietlyJoin. Directly handles</span><span class="comment"> * only cases of already-completed, external wait, and</span><span class="comment"> * unfork+exec.  Others are relayed to ForkJoinPool.awaitJoin.</span><span class="comment"> *</span><span class="comment"> * <span class="doctag">@return</span> status upon completion</span><span class="comment"> */</span><span class="keyword">private</span> <span class="type">int</span> <span class="title function_">doJoin</span><span class="params">()</span> &#123;    <span class="type">int</span> s; Thread t; ForkJoinWorkerThread wt; ForkJoinPool.WorkQueue w;    <span class="keyword">return</span> (s = status) &lt; <span class="number">0</span> ? s :            ((t = Thread.currentThread()) <span class="keyword">instanceof</span> ForkJoinWorkerThread) ?                    (w = (wt = (ForkJoinWorkerThread)t).workQueue).                            tryUnpush(<span class="built_in">this</span>) &amp;&amp; (s = doExec()) &lt; <span class="number">0</span> ? s :                            wt.pool.awaitJoin(w, <span class="built_in">this</span>, <span class="number">0L</span>) :                    externalAwaitDone();&#125;<span class="comment">/**</span><span class="comment"> * Primary execution method for stolen tasks. Unless done, calls</span><span class="comment"> * exec and records status if completed, but doesn&#x27;t wait for</span><span class="comment"> * completion otherwise.</span><span class="comment"> *</span><span class="comment"> * <span class="doctag">@return</span> status on exit from this method</span><span class="comment"> */</span><span class="keyword">final</span> <span class="type">int</span> <span class="title function_">doExec</span><span class="params">()</span> &#123;    <span class="type">int</span> s; <span class="type">boolean</span> completed;    <span class="keyword">if</span> ((s = status) &gt;= <span class="number">0</span>) &#123;        <span class="keyword">try</span> &#123;            completed = exec();        &#125; <span class="keyword">catch</span> (Throwable rex) &#123;            completed = <span class="literal">false</span>;            s = setExceptionalCompletion(rex);        &#125;        <span class="keyword">if</span> (completed)            s = setDone();    &#125;    <span class="keyword">return</span> s;&#125;</code></pre><p>在 doJoin()方法流程如下:</p><ul><li>首先通过查看任务的状态，看任务是否已经执行完成，如果执行完成，则直接返回任务状态；</li><li>如果没有执行完，则从任务数组里取出任务并执行。</li><li>如果任务顺利执行完成，则设置任务状态为 NORMAL，如果出现异常，则记录异常，并将任务状态设置为 EXCEPTIONAL。</li></ul><h1 id="四、Fork-Join-框架的异常处理"><a href="#四、Fork-Join-框架的异常处理" class="headerlink" title="四、Fork&#x2F;Join 框架的异常处理"></a>四、Fork&#x2F;Join 框架的异常处理</h1><p>ForkJoinTask 在执行的时候可能会抛出异常，但是我们没办法在主线程里直接捕获异常，所以 ForkJoinTask 提供了 isCompletedAbnormally() 方法来检查任务是否已经抛出异常或已经被取消了，并且可以通过 ForkJoinTask 的 getException 方法获取异常。</p><p>getException 方法返回 Throwable 对象，如果任务被取消了则返回 CancellationException。如果任务没有完成或者没有抛出异常则返回 null。</p><h1 id="五、入门案例"><a href="#五、入门案例" class="headerlink" title="五、入门案例"></a>五、入门案例</h1><p><strong>场景: 生成一个计算任务，计算 1+2+3………+100 每 10 个数切分一个子任务</strong></p><pre><code class="highlight java"><span class="keyword">class</span> <span class="title class_">MyTask</span> <span class="keyword">extends</span> <span class="title class_">RecursiveTask</span>&lt;Integer&gt; &#123;    <span class="comment">//拆分差值不能超过10，计算10以内运算</span>    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">Integer</span> <span class="variable">VALUE</span> <span class="operator">=</span> <span class="number">10</span>;    <span class="keyword">private</span> <span class="type">int</span> begin ;<span class="comment">//拆分开始值</span>    <span class="keyword">private</span> <span class="type">int</span> end;<span class="comment">//拆分结束值</span>    <span class="keyword">private</span> <span class="type">int</span> result ; <span class="comment">//返回结果</span>    <span class="comment">//创建有参数构造</span>    <span class="keyword">public</span> <span class="title function_">MyTask</span><span class="params">(<span class="type">int</span> begin,<span class="type">int</span> end)</span> &#123;        <span class="built_in">this</span>.begin = begin;        <span class="built_in">this</span>.end = end;    &#125;    <span class="comment">//拆分和合并过程</span>    <span class="meta">@Override</span>    <span class="keyword">protected</span> Integer <span class="title function_">compute</span><span class="params">()</span> &#123;<span class="comment">//        System.out.println(Thread.currentThread().getName() + &quot;, begin: &quot; + begin + &quot;, end: &quot; + end);</span>        <span class="comment">//判断相加两个数值是否大于10</span>        <span class="keyword">if</span>((end-begin)&lt;=VALUE) &#123;            <span class="comment">//相加操作</span>            <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> begin; i &lt;=end; i++) &#123;                result = result+i;            &#125;        &#125; <span class="keyword">else</span> &#123;<span class="comment">// 递归调用,切分为 2 个小任务</span>            <span class="comment">//获取中间值</span>            <span class="type">int</span> <span class="variable">middle</span> <span class="operator">=</span> (begin+end)/<span class="number">2</span>;            <span class="comment">//拆分左边</span>            <span class="type">MyTask</span> <span class="variable">task01</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">MyTask</span>(begin,middle);            <span class="comment">//拆分右边</span>            <span class="type">MyTask</span> <span class="variable">task02</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">MyTask</span>(middle+<span class="number">1</span>,end);            <span class="comment">// 执行:异步</span>            task01.fork();            task02.fork();            <span class="comment">// 同步阻塞获取执行结果</span>            result = task01.join()+task02.join();        &#125;        <span class="keyword">return</span> result;    &#125;&#125;<span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ForkJoinDemo</span> &#123;    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> ExecutionException, InterruptedException &#123;        <span class="comment">//创建MyTask对象</span>        <span class="type">MyTask</span> <span class="variable">myTask</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">MyTask</span>(<span class="number">0</span>,<span class="number">100</span>);        <span class="comment">//创建分支合并池对象</span>        <span class="type">ForkJoinPool</span> <span class="variable">forkJoinPool</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ForkJoinPool</span>();        ForkJoinTask&lt;Integer&gt; forkJoinTask = forkJoinPool.submit(myTask);        <span class="comment">//获取最终合并之后结果</span>        <span class="type">Integer</span> <span class="variable">result</span> <span class="operator">=</span> forkJoinTask.get();        System.out.println(result);        <span class="comment">//关闭池对象</span>        forkJoinPool.shutdown();    &#125;&#125;</code></pre>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;一、Fork-Join-框架简介&quot;&gt;&lt;a href=&quot;#一、Fork-Join-框架简介&quot; class=&quot;headerlink&quot; title=&quot;一、Fork&amp;#x2F;Join 框架简介&quot;&gt;&lt;/a&gt;一、Fork&amp;#x2F;Join 框架简介&lt;/h1&gt;&lt;p&gt;Fork</summary>
      
    
    
    
    <category term="JUC" scheme="https://georgechan95.github.io/categories/JUC/"/>
    
    
    <category term="juc" scheme="https://georgechan95.github.io/tags/juc/"/>
    
    <category term="java" scheme="https://georgechan95.github.io/tags/java/"/>
    
  </entry>
  
  <entry>
    <title>09-ThreadPool-线程池</title>
    <link href="https://georgechan95.github.io/blog/a0197c15.html"/>
    <id>https://georgechan95.github.io/blog/a0197c15.html</id>
    <published>2024-09-13T12:10:08.000Z</published>
    <updated>2024-09-18T07:30:50.861Z</updated>
    
    <content type="html"><![CDATA[<h1 id="一、线程池简介"><a href="#一、线程池简介" class="headerlink" title="一、线程池简介"></a>一、线程池简介</h1><p>线程池（英语：thread pool）：一种线程使用模式。线程过多会带来调度开销，进而影响缓存局部性和整体性能。而线程池维护着多个线程，等待着监督管理者分配可并发执行的任务。这避免了在处理短时间任务时创建与销毁线程的代价。线程池不仅能够保证内核的充分利用，还能防止过分调度。</p><p>例子： 10 年前单核 CPU 电脑，假的多线程，像马戏团小丑玩多个球，CPU 需要来回切换。 现在是多核电脑，多个线程各自跑在独立的 CPU 上，不用切换效率高</p><p><strong>线程池的优势：</strong> 线程池做的工作只要是控制运行的线程数量，处理过程中将任务放入队列，然后在线程创建后启动这些任务，如果线程数量超过了最大数量，超出数量的线程排队等候，等其他线程执行完毕，再从队列中取出任务来执行。</p><p><strong>它的主要特点为：</strong></p><ul><li>降低资源消耗: 通过重复利用已创建的线程降低线程创建和销毁造成的销耗。</li><li>提高响应速度: 当任务到达时，任务可以不需要等待线程创建就能立即执行。</li><li>提高线程的可管理性: 线程是稀缺资源，如果无限制的创建，不仅会销耗系统资源，还会降低系统的稳定性，使用线程池可以进行统一的分配，调优和监控。</li><li><strong>Java</strong> <strong>中的线程池是通过</strong> <strong>Executor</strong> <strong>框架实现的，该框架中用到了</strong> <strong>Executor，Executors,  ExecutorService，ThreadPoolExecutor这几个类</strong></li></ul><p><img src="https://raw.githubusercontent.com/GeorgeChan95/blogimg/master/img/2024/09/16/20240916-103643.png" alt="Executors继承体系"></p><h1 id="二、线程池参数说明"><a href="#二、线程池参数说明" class="headerlink" title="二、线程池参数说明"></a>二、线程池参数说明</h1><p>介绍 5 种类型的线程池</p><h2 id="1-常用参数-重点"><a href="#1-常用参数-重点" class="headerlink" title="1. 常用参数(重点)"></a>1. 常用参数(重点)</h2><ul><li>corePoolSize 线程池的核心线程数</li><li>maximumPoolSize 能容纳的最大线程数</li><li>keepAliveTime 空闲线程存活时间</li><li>unit 存活的时间单位</li><li>workQueue 存放提交但未执行任务的队列</li><li>threadFactory 创建线程的工厂类</li><li>handler 等待队列满后的拒绝策略</li></ul><p>线程池中，有三个重要的参数，决定影响了拒绝策略：corePoolSize - 核心线程数，也即最小的线程数。workQueue - 阻塞队列 。 maximumPoolSize - 最大线程数</p><p>当提交任务数大于 corePoolSize 的时候，会优先将任务放到 workQueue 阻塞队列中。当阻塞队列饱和后，会扩充线程池中线程数，直到达到 maximumPoolSize 最大线程数配置。此时，再多余的任务，则会触发线程池的拒绝策略了。</p><p>总结起来，也就是一句话，当提交的任务数大于（<code>workQueue.size()</code> + <code>maximumPoolSize</code> ），就会触发线程池的拒绝策略。</p><h2 id="2-拒绝策略-重点"><a href="#2-拒绝策略-重点" class="headerlink" title="2. 拒绝策略(重点)"></a>2. 拒绝策略(重点)</h2><ul><li><strong>CallerRunsPolicy</strong>: 当触发拒绝策略，只要线程池没有关闭的话，则使用调用线程直接运行任务。一般并发比较小，性能要求不高，不允许失败。但是，由于调用者自己运行任务，如果任务提交速度过快，可能导致程序阻塞，性能效率上必然的损失较大</li><li><strong>AbortPolicy</strong>: 丢弃任务，并抛出拒绝执行 RejectedExecutionException 异常信息。线程池默认的拒绝策略。必须处理好抛出的异常，否则会打断当前的执行流程，影响后续的任务执行。</li><li><strong>DiscardPolicy</strong>: 直接丢弃，其他啥都没有</li><li><strong>DiscardOldestPolicy</strong>: 当触发拒绝策略，只要线程池没有关闭的话，丢弃阻塞队列 workQueue 中最老的一个任务，并将新任务加入</li></ul><h1 id="三、线程池的种类与创建"><a href="#三、线程池的种类与创建" class="headerlink" title="三、线程池的种类与创建"></a>三、线程池的种类与创建</h1><h2 id="1-newCachedThreadPool-常用"><a href="#1-newCachedThreadPool-常用" class="headerlink" title="1. newCachedThreadPool(常用)"></a>1. newCachedThreadPool(常用)</h2><p><strong>作用</strong>：创建一个可缓存线程池，如果线程池长度超过处理需要，可灵活回收空闲线程，若无可回收，则新建线程.</p><p><strong>特点</strong>: </p><ul><li>线程池中数量没有固定，可达到最大值（<code>Interger. MAX_VALUE</code>）</li><li>线程池中的线程可进行缓存重复利用和回收（回收默认时间为 1 分钟）</li><li>当线程池中，没有可用线程，会重新创建一个线程</li></ul><p><strong>创建方式：</strong></p><pre><code class="highlight java"><span class="comment">/**</span><span class="comment"> * 可缓存线程池</span><span class="comment"> *</span><span class="comment"> * <span class="doctag">@return</span></span><span class="comment"> */</span><span class="keyword">public</span> <span class="keyword">static</span> ExecutorService <span class="title function_">newCachedThreadPool</span><span class="params">()</span> &#123;    <span class="comment">/**</span><span class="comment">     * corePoolSize 线程池的核心线程数</span><span class="comment">     * maximumPoolSize 能容纳的最大线程数</span><span class="comment">     * keepAliveTime 空闲线程存活时间</span><span class="comment">     * unit 存活的时间单位</span><span class="comment">     * workQueue 存放提交但未执行任务的队列</span><span class="comment">     * threadFactory 创建线程的工厂类:可以省略</span><span class="comment">     * handler 等待队列满后的拒绝策略:可以省略</span><span class="comment">     */</span>    <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">ThreadPoolExecutor</span>(<span class="number">0</span>,            Integer.MAX_VALUE,            <span class="number">60L</span>,            TimeUnit.SECONDS,            <span class="keyword">new</span> <span class="title class_">SynchronousQueue</span>&lt;&gt;(),            Executors.defaultThreadFactory(),            <span class="keyword">new</span> <span class="title class_">ThreadPoolExecutor</span>.AbortPolicy());&#125;</code></pre><p><strong>场景:</strong> 适用于创建一个可无限扩大的线程池，服务器负载压力较轻，执行时间较短，任务多的场景</p><h2 id="2-newFixedThreadPool-常用"><a href="#2-newFixedThreadPool-常用" class="headerlink" title="2. newFixedThreadPool(常用)"></a>2. newFixedThreadPool(常用)</h2><p><strong>作用</strong>：创建一个可重用固定线程数的线程池，以共享的无界队列方式来运行这些线程。在任意点，在大多数线程会处于处理任务的活动状态。如果在所有线程处于活动状态时提交附加任务，则在有可用线程之前，附加任务将在队列中等待。如果在关闭前的执行期间由于失败而导致任何线程终止，那么一个新线程将代替它执行后续的任务（如果需要）。在某个线程被显式地关闭之前，池中的线程将一直存在。</p><p><strong>特征：</strong></p><ul><li>线程池中的线程处于一定的量，可以很好的控制线程的并发量</li><li>线程可以重复被使用，在显示关闭之前，都将一直存在</li><li>超出一定量的线程被提交时候需在队列中等待</li></ul><p><strong>创建方式</strong>：</p><pre><code class="highlight java"><span class="comment">/**</span><span class="comment"> * 固定长度线程池</span><span class="comment"> * <span class="doctag">@return</span></span><span class="comment"> */</span><span class="keyword">public</span> <span class="keyword">static</span> ExecutorService <span class="title function_">newFixedThreadPool</span><span class="params">()</span>&#123;    <span class="comment">/**</span><span class="comment">     * corePoolSize 线程池的核心线程数</span><span class="comment">     * maximumPoolSize 能容纳的最大线程数</span><span class="comment">     * keepAliveTime 空闲线程存活时间</span><span class="comment">     * unit 存活的时间单位</span><span class="comment">     * workQueue 存放提交但未执行任务的队列</span><span class="comment">     * threadFactory 创建线程的工厂类:可以省略</span><span class="comment">     * handler 等待队列满后的拒绝策略:可以省略</span><span class="comment">     */</span>    <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">ThreadPoolExecutor</span>(<span class="number">10</span>,            <span class="number">10</span>,            <span class="number">0L</span>,            TimeUnit.SECONDS,            <span class="keyword">new</span> <span class="title class_">LinkedBlockingQueue</span>&lt;&gt;(),            Executors.defaultThreadFactory(),            <span class="keyword">new</span> <span class="title class_">ThreadPoolExecutor</span>.AbortPolicy());&#125;</code></pre><p><strong>场景:</strong> 适用于可以预测线程数量的业务中，或者服务器负载较重，对线程数有严格限制的场景</p><h2 id="3-newSingleThreadExecutor-常用"><a href="#3-newSingleThreadExecutor-常用" class="headerlink" title="3. newSingleThreadExecutor(常用)"></a>3. newSingleThreadExecutor(常用)</h2><p><strong>作用</strong>：创建一个使用单个 worker 线程的 Executor，以无界队列方式来运行该线程。（注意，如果因为在关闭前的执行期间出现失败而终止了此单个线程，那么如果需要，一个新线程将代替它执行后续的任务）。可保证顺序地执行各个任务，并且在任意给定的时间不会有多个线程是活动的。与其他等效的 newFixedThreadPool 不同，可保证无需重新配置此方法所返回的执行程序即可使用其他的线程。</p><p><strong>特征：</strong> 线程池中最多执行 1 个线程，之后提交的线程活动将会排在队列中以此执行</p><p><strong>创建方式：</strong></p><pre><code class="highlight java"><span class="comment">/**</span><span class="comment"> * 单一线程池</span><span class="comment"> *</span><span class="comment"> * <span class="doctag">@return</span></span><span class="comment"> */</span><span class="keyword">public</span> <span class="keyword">static</span> ExecutorService <span class="title function_">newSingleThreadExecutor</span><span class="params">()</span> &#123;    <span class="comment">/**</span><span class="comment">    * corePoolSize 线程池的核心线程数</span><span class="comment">    * maximumPoolSize 能容纳的最大线程数</span><span class="comment">    * keepAliveTime 空闲线程存活时间</span><span class="comment">    * unit 存活的时间单位</span><span class="comment">    * workQueue 存放提交但未执行任务的队列</span><span class="comment">    * threadFactory 创建线程的工厂类:可以省略</span><span class="comment">    * handler 等待队列满后的拒绝策略:可以省略</span><span class="comment">    */</span>    <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">ThreadPoolExecutor</span>(<span class="number">1</span>,            <span class="number">1</span>,            <span class="number">0L</span>,            TimeUnit.SECONDS,            <span class="keyword">new</span> <span class="title class_">LinkedBlockingQueue</span>&lt;&gt;(),            Executors.defaultThreadFactory(),            <span class="keyword">new</span> <span class="title class_">ThreadPoolExecutor</span>.AbortPolicy());&#125;</code></pre><p><strong>场景:</strong> 适用于需要保证顺序执行各个任务，并且在任意时间点，不会同时有多个线程的场景</p><h2 id="4-newScheduleThreadPool-了解"><a href="#4-newScheduleThreadPool-了解" class="headerlink" title="4. newScheduleThreadPool(了解)"></a>4. newScheduleThreadPool(了解)</h2><p><strong>作用:</strong> 线程池支持定时以及周期性执行任务，创建一个 corePoolSize 为传入参数，最大线程数为整形的最大数的线程池</p><p><strong>特征:</strong></p><ul><li>线程池中具有指定数量的线程，即便是空线程也将保留 </li><li>可定时或者延迟执行线程活动</li></ul><p><strong>创建方式:</strong></p><pre><code class="highlight java"><span class="keyword">public</span> <span class="keyword">static</span> ScheduledExecutorService <span class="title function_">newScheduledThreadPool</span><span class="params">(<span class="type">int</span> corePoolSize,</span><span class="params">                                                              ThreadFactory threadFactory)</span> &#123;    <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">ScheduledThreadPoolExecutor</span>(corePoolSize,                                           threadFactory);&#125;</code></pre><p><strong>场景:</strong> 适用于需要多个后台线程执行周期任务的场景</p><h2 id="5-newWorkStealingPool"><a href="#5-newWorkStealingPool" class="headerlink" title="5. newWorkStealingPool"></a>5. newWorkStealingPool</h2><p>jdk1.8 提供的线程池，底层使用的是 ForkJoinPool 实现，创建一个拥有多个任务队列的线程池，可以减少连接数，创建当前可用 cpu 核数的线程来并行执行任务</p><p><strong>创建方式:</strong></p><pre><code class="highlight java"><span class="keyword">public</span> <span class="keyword">static</span> ExecutorService <span class="title function_">newWorkStealingPool</span><span class="params">(<span class="type">int</span> parallelism)</span> &#123;    <span class="comment">/**</span><span class="comment">     * parallelism：并行级别，通常默认为 JVM 可用的处理器个数</span><span class="comment">     * factory：用于创建 ForkJoinPool 中使用的线程。</span><span class="comment">     * handler：用于处理工作线程未处理的异常，默认为 null</span><span class="comment">     * asyncMode：用于控制 WorkQueue 的工作模式:队列---反队列</span><span class="comment">     */</span>    <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">ForkJoinPool</span>(parallelism,            ForkJoinPool.defaultForkJoinWorkerThreadFactory,            <span class="literal">null</span>,            <span class="literal">true</span>);&#125;</code></pre><p><strong>场景:</strong> 适用于大耗时，可并行执行的场景</p><h1 id="四、线程池入门案例"><a href="#四、线程池入门案例" class="headerlink" title="四、线程池入门案例"></a>四、线程池入门案例</h1><p><strong>场景: 火车站 3 个售票口, 10 个用户买票</strong></p><pre><code class="highlight java"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ThreadPoolDemo1</span> &#123;    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;        <span class="comment">//一池五线程</span>        <span class="type">ExecutorService</span> <span class="variable">threadPool1</span> <span class="operator">=</span> Executors.newFixedThreadPool(<span class="number">3</span>); <span class="comment">//5个窗口</span>        <span class="comment">//一池一线程</span>        <span class="type">ExecutorService</span> <span class="variable">threadPool2</span> <span class="operator">=</span> Executors.newSingleThreadExecutor(); <span class="comment">//一个窗口</span>        <span class="comment">//一池可扩容线程</span>        <span class="type">ExecutorService</span> <span class="variable">threadPool3</span> <span class="operator">=</span> Executors.newCachedThreadPool();        <span class="comment">// 创建当前可用的CPU核数的线程数的线程池</span>        <span class="type">ExecutorService</span> <span class="variable">threadPool4</span> <span class="operator">=</span> Executors.newWorkStealingPool();        <span class="comment">//10个顾客请求</span>        <span class="keyword">try</span> &#123;            <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">1</span>; i &lt;= <span class="number">10</span>; i++) &#123;                <span class="keyword">final</span> <span class="type">int</span> <span class="variable">num</span> <span class="operator">=</span> i;                <span class="comment">//执行</span>                threadPool1.execute(() -&gt; &#123;                    System.out.println(Thread.currentThread().getName() + <span class="string">&quot;开始办理业务&quot;</span> + num);                    <span class="keyword">try</span> &#123;                        TimeUnit.SECONDS.sleep(<span class="number">5</span>);                    &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;                        e.printStackTrace();                    &#125;                    System.out.println(Thread.currentThread().getName() + <span class="string">&quot;结束办理业务&quot;</span> + num);                &#125;);            &#125;        &#125; <span class="keyword">catch</span> (Exception e) &#123;            e.printStackTrace();        &#125; <span class="keyword">finally</span> &#123;            <span class="comment">//关闭线程池</span>            threadPool1.shutdown();        &#125;    &#125;&#125;</code></pre><p><strong>运行结果:</strong></p><pre><code class="highlight shell">pool-1-thread-1开始办理业务1pool-1-thread-2开始办理业务2pool-1-thread-3开始办理业务3pool-1-thread-2结束办理业务2pool-1-thread-1结束办理业务1pool-1-thread-1开始办理业务5pool-1-thread-3结束办理业务3pool-1-thread-2开始办理业务4pool-1-thread-3开始办理业务6pool-1-thread-1结束办理业务5pool-1-thread-3结束办理业务6pool-1-thread-3开始办理业务8pool-1-thread-2结束办理业务4pool-1-thread-2开始办理业务9pool-1-thread-1开始办理业务7pool-1-thread-2结束办理业务9pool-1-thread-2开始办理业务10pool-1-thread-1结束办理业务7pool-1-thread-3结束办理业务8pool-1-thread-2结束办理业务10</code></pre><h1 id="五、线程池底层工作原理-重要"><a href="#五、线程池底层工作原理-重要" class="headerlink" title="五、线程池底层工作原理(重要)"></a>五、线程池底层工作原理(重要)</h1><p><img src="https://raw.githubusercontent.com/GeorgeChan95/blogimg/master/img/2024/09/16/20240916-115726.png" alt="线程池底层工作原理"></p><ul><li>在创建了线程池后，线程池中的线程数为零</li><li>当调用 execute()方法添加一个请求任务时，线程池会做出如下判断<ul><li>如果正在运行的线程数量小于 corePoolSize，那么马上创建线程运行这个任务；</li><li>如果正在运行的线程数量大于或等于 corePoolSize，那么将这个任务放入队列；</li><li>如果这个时候队列满了且正在运行的线程数量还小于maximumPoolSize，那么还是要创建非核心线程立刻运行这个任务；</li><li>如果队列满了且正在运行的线程数量大于或等于 maximumPoolSize，那么线程池会启动饱和拒绝策略来执行。</li></ul></li><li>当一个线程完成任务时，它会从队列中取下一个任务来执行</li><li>当一个线程无事可做超过一定的时间（keepAliveTime）时，线程会判断<ul><li>如果当前运行的线程数大于 corePoolSize，那么这个线程就被停掉。</li><li>所以线程池的所有任务完成后，它最终会收缩到 corePoolSize 的大小。</li></ul></li></ul><p><img src="https://raw.githubusercontent.com/GeorgeChan95/blogimg/master/img/2024/09/16/20240916-120237.png" alt="JDK内置拒绝策略"></p><h1 id="六、注意事项-重要"><a href="#六、注意事项-重要" class="headerlink" title="六、注意事项(重要)"></a>六、注意事项(重要)</h1><ul><li><p>项目中创建多线程时，使用常见的三种线程池创建方式，单一、可变、定长都有一定问题，原因是 FixedThreadPool 和 SingleThreadExecutor 底层都是用 LinkedBlockingQueue 实现的，这个队列最大长度为 Integer.MAX_VALUE，容易导致 OOM。所以实际生产一般自己通过 ThreadPoolExecutor 的 7 个参数，自定义线程池</p></li><li><p>创建线程池推荐适用 ThreadPoolExecutor 及其 7 个参数手动创建</p><ul><li>corePoolSize 线程池的核心线程数</li><li>maximumPoolSize 能容纳的最大线程数</li><li>keepAliveTime 空闲线程存活时间</li><li>unit 存活的时间单位</li><li>workQueue 存放提交但未执行任务的队列</li><li>threadFactory 创建线程的工厂类</li><li>handler 等待队列满后的拒绝策略</li></ul></li><li><p>为什么不允许适用不允许 Executors.的方式手动创建线程池,如下图</p></li></ul><p><img src="https://raw.githubusercontent.com/GeorgeChan95/blogimg/master/img/2024/09/16/20240916-120936.png" alt="阿里巴巴开发手册关于线程池创建要求"></p><pre><code class="highlight java"><span class="comment">//自定义线程池创建</span><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ThreadPoolDemo2</span> &#123;    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;        <span class="type">ExecutorService</span> <span class="variable">threadPool</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ThreadPoolExecutor</span>(                <span class="number">2</span>,                <span class="number">5</span>,                <span class="number">2L</span>,                TimeUnit.SECONDS,                <span class="keyword">new</span> <span class="title class_">ArrayBlockingQueue</span>&lt;&gt;(<span class="number">3</span>),                Executors.defaultThreadFactory(),                <span class="keyword">new</span> <span class="title class_">ThreadPoolExecutor</span>.AbortPolicy()        );        <span class="comment">//10个顾客请求</span>        <span class="keyword">try</span> &#123;            <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">1</span>; i &lt;=<span class="number">10</span>; i++) &#123;                <span class="comment">//执行</span>                threadPool.execute(()-&gt;&#123;                    System.out.println(Thread.currentThread().getName()+<span class="string">&quot; 办理业务&quot;</span>);                &#125;);            &#125;        &#125;<span class="keyword">catch</span> (Exception e) &#123;            e.printStackTrace();        &#125;<span class="keyword">finally</span> &#123;            <span class="comment">//关闭</span>            threadPool.shutdown();        &#125;    &#125;&#125;</code></pre>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;一、线程池简介&quot;&gt;&lt;a href=&quot;#一、线程池简介&quot; class=&quot;headerlink&quot; title=&quot;一、线程池简介&quot;&gt;&lt;/a&gt;一、线程池简介&lt;/h1&gt;&lt;p&gt;线程池（英语：thread pool）：一种线程使用模式。线程过多会带来调度开销，进而影响缓存局部性</summary>
      
    
    
    
    <category term="JUC" scheme="https://georgechan95.github.io/categories/JUC/"/>
    
    
    <category term="juc" scheme="https://georgechan95.github.io/tags/juc/"/>
    
    <category term="java" scheme="https://georgechan95.github.io/tags/java/"/>
    
  </entry>
  
  <entry>
    <title>08-阻塞队列BlockingQueue</title>
    <link href="https://georgechan95.github.io/blog/a6760d1f.html"/>
    <id>https://georgechan95.github.io/blog/a6760d1f.html</id>
    <published>2024-09-07T09:30:00.000Z</published>
    <updated>2024-09-13T00:27:39.289Z</updated>
    
    <content type="html"><![CDATA[<h1 id="一、阻塞队列概述"><a href="#一、阻塞队列概述" class="headerlink" title="一、阻塞队列概述"></a>一、阻塞队列概述</h1><p>阻塞队列，顾名思义，首先它是一个队列, 通过一个共享的队列，可以使得数据由队列的一端输入，从另外一端输出；</p><img src="https://raw.githubusercontent.com/GeorgeChan95/blogimg/master/img/2024/09/07/20240907-173358" alt="阻塞队列" style="zoom:50%;" /><ul><li>当队列是空的，从队列中获取元素的操作将会被阻塞</li><li>当队列是满的，从队列中添加元素的操作将会被阻塞</li><li>试图从空的队列中获取元素的线程将会被阻塞，直到其他线程往空的队列插入新的元素</li><li>试图向已满的队列中添加新元素的线程将会被阻塞，直到其他线程从队列中移除一个或多个元素或者完全清空，使队列变得空闲起来并后续新增</li></ul><p>常用的队列主要有以下两种：</p><ul><li>先进先出（FIFO）：先插入的队列的元素也最先出队列，类似于排队的功能。从某种程度上来说这种队列也体现了一种公平性</li><li>后进先出（LIFO）：后插入队列的元素最先出队列，这种队列优先处理最近发生的事件(栈)</li></ul><p>在多线程领域：所谓阻塞，在某些情况下会挂起线程（即阻塞），一旦条件满足，被挂起的线程又会自动被唤起</p><p><strong>为什么需要 BlockingQueue?</strong></p><p>好处是我们不需要关心什么时候需要阻塞线程，什么时候需要唤醒线程，因为这一切 BlockingQueue 都给你一手包办了.</p><p>在 concurrent 包发布以前，在多线程环境下，我们每个程序员都必须去自己控制这些细节，尤其还要兼顾效率和线程安全，而这会给我们的程序带来不小的复杂度。多线程环境中，通过队列可以很容易实现数据共享，比如经典的“生产者”和“消费者”模型中，通过队列可以很便利地实现两者之间的数据共享。假设我们有若干生产者线程，另外又有若干个消费者线程。如果生产者线程需要把准备好的数据共享给消费者线程，利用队列的方式来传递数据，就可以很方便地解决他们之间的数据共享问题。但如果生产者和消费者在某个时间段内，万一发生数据处理速度不匹配的情况呢？理想情况下，如果生产者产出数据的速度大于消费者消费的速度，并且当生产出来的数据累积到一定程度的时候，那么生产者必须暂停等待一下（阻塞生产者线程），以便等待消费者线程把累积的数据处理完毕，反之亦然。</p><ul><li>当队列中没有数据的情况下，消费者端的所有线程都会被自动阻塞（挂起），直到有数据放入队列</li><li>当队列中填满数据的情况下，生产者端的所有线程都会被自动阻塞（挂起），直到队列中有空的位置，线程被自动唤醒</li></ul><h1 id="二、BlockingQueue-核心方法"><a href="#二、BlockingQueue-核心方法" class="headerlink" title="二、BlockingQueue 核心方法"></a>二、BlockingQueue 核心方法</h1><table><thead><tr><th align="center">方法类型</th><th align="center">抛出异常</th><th align="center">特殊值</th><th align="center">阻塞</th><th align="center">超时</th></tr></thead><tbody><tr><td align="center">插入</td><td align="center">add(e)</td><td align="center">offer()</td><td align="center">put(e)</td><td align="center">offer(e,time,unit)</td></tr><tr><td align="center">移除</td><td align="center">remove()</td><td align="center">poll()</td><td align="center">take()</td><td align="center">poll(time,unit)</td></tr><tr><td align="center">检查</td><td align="center">element()</td><td align="center">peek()</td><td align="center">-</td><td align="center">-</td></tr></tbody></table><table><thead><tr><th>抛出异常</th><th>当阻塞队列满时，再往队列里add插入元素会抛出IllegalStateException:Queue full <br />当阻塞队列空时，再往队列里remove移除元素会抛出NoSuchElementException</th></tr></thead><tbody><tr><td><strong>特殊值</strong></td><td>插入方法，成功true，失败false 移除方法，成功返回出队列的元素，列表里没有就返回null</td></tr><tr><td><strong>阻塞</strong></td><td>当阻塞队列满时，生产者线程继续往队列里put元素，队列会一直阻塞生产者线程知道put数据或响应中断退出 当阻塞队列空时，消费者线程视图从队列里take元素，队列会一直阻塞消费者线程直到队列可用</td></tr><tr><td><strong>超时</strong></td><td>当阻塞队列满时，队列会阻塞生产者线程一定时间，超过限时后生产者线程会退出</td></tr></tbody></table><h2 id="1-放入数据"><a href="#1-放入数据" class="headerlink" title="1. 放入数据"></a>1. 放入数据</h2><ul><li>offer(Object):表示如果可能的话,将 Object 加到 BlockingQueue 里,即如果 BlockingQueue 可以容纳,则返回 true,否则返回 false.<strong>（本方法不阻塞当前执行方法的线程）</strong></li><li>offer(E o, long timeout, TimeUnit unit)：可以设定等待的时间，如果在指定的时间内，还不能往队列中加入 BlockingQueue，则返回失败</li><li>put(Object):把 Object 加到 BlockingQueue 里,如果 BlockQueue 没有空间,则调用此方法的线程被阻断直到 BlockingQueue 里面有空间再继续.</li></ul><h2 id="2-获取数据"><a href="#2-获取数据" class="headerlink" title="2. 获取数据"></a>2. 获取数据</h2><ul><li>poll(time): 取走 BlockingQueue 里排在首位的对象,若不能立即取出,则可以等time 参数规定的时间,取不到时返回 null</li><li>poll(long timeout, TimeUnit unit)：从 BlockingQueue 取出一个队首的对象，如果在指定时间内，队列一旦有数据可取，则立即返回队列中的数据。否则知道时间超时还没有数据可取，返回失败。</li><li>take(): 取走 BlockingQueue 里排在首位的对象,若 BlockingQueue 为空,<strong>阻断进入等待状态直到 BlockingQueue 有新的数据被加入</strong>;</li><li>drainTo(): 一次性从 BlockingQueue 获取所有可用的数据对象（还可以指定获取数据的个数），通过该方法，可以提升获取数据效率；不需要多次分批加锁或释放锁。</li></ul><h1 id="三、入门案例"><a href="#三、入门案例" class="headerlink" title="三、入门案例"></a>三、入门案例</h1><pre><code class="highlight java"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">BlockingQueueTest</span> &#123;    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> InterruptedException &#123;        <span class="comment">/********************* 第一种: 抛出异常 ***********************/</span>        BlockingQueue&lt;Object&gt; bQueue1 = <span class="keyword">new</span> <span class="title class_">ArrayBlockingQueue</span>&lt;&gt;(<span class="number">3</span>);        System.out.println(bQueue1.add(<span class="string">&quot;a&quot;</span>)); <span class="comment">// true</span>        System.out.println(bQueue1.add(<span class="string">&quot;b&quot;</span>)); <span class="comment">// true</span>        System.out.println(bQueue1.add(<span class="string">&quot;c&quot;</span>)); <span class="comment">// true</span><span class="comment">//        System.out.println(bQueue1.add(&quot;d&quot;)); // Exception in thread &quot;main&quot; java.lang.IllegalStateException: Queue full</span>        <span class="comment">// 检查</span>        System.out.println(bQueue1.element()); <span class="comment">// a</span>        System.out.println(bQueue1.remove()); <span class="comment">// a</span>        System.out.println(bQueue1.remove()); <span class="comment">// b</span>        System.out.println(bQueue1.element()); <span class="comment">// c</span>                <span class="comment">/********************* 第二种: 特殊值 ***********************/</span>        BlockingQueue&lt;Object&gt; bQueue2 = <span class="keyword">new</span> <span class="title class_">ArrayBlockingQueue</span>&lt;&gt;(<span class="number">3</span>);        System.out.println(bQueue2.offer(<span class="string">&quot;e&quot;</span>)); <span class="comment">// true</span>        System.out.println(bQueue2.offer(<span class="string">&quot;f&quot;</span>)); <span class="comment">// true</span>        System.out.println(bQueue2.offer(<span class="string">&quot;g&quot;</span>)); <span class="comment">// true</span>        System.out.println(bQueue2.offer(<span class="string">&quot;h&quot;</span>)); <span class="comment">// false</span>        System.out.println(bQueue2.peek()); <span class="comment">// e</span>        System.out.println(bQueue2.poll()); <span class="comment">// e</span>        System.out.println(bQueue2.poll()); <span class="comment">// f</span>                <span class="comment">/********************* 第三种: 阻塞 ***********************/</span>        BlockingQueue&lt;Object&gt; bQueue3 = <span class="keyword">new</span> <span class="title class_">ArrayBlockingQueue</span>&lt;&gt;(<span class="number">3</span>);        bQueue3.put(<span class="string">&quot;j&quot;</span>);        bQueue3.put(<span class="string">&quot;k&quot;</span>);        bQueue3.put(<span class="string">&quot;l&quot;</span>);        System.out.println(bQueue3.take()); <span class="comment">// j</span>        bQueue3.put(<span class="string">&quot;m&quot;</span>);        System.out.println(<span class="string">&quot;m&quot;</span>); <span class="comment">// m</span>        bQueue3.put(<span class="string">&quot;n&quot;</span>); <span class="comment">// 阻塞</span>                <span class="comment">/********************* 第四种: 超时 ***********************/</span>        BlockingQueue&lt;Object&gt; bQueue4 = <span class="keyword">new</span> <span class="title class_">ArrayBlockingQueue</span>&lt;&gt;(<span class="number">3</span>);        System.out.println(bQueue4.offer(<span class="string">&quot;o&quot;</span>, <span class="number">3</span>, TimeUnit.SECONDS)); <span class="comment">// true</span>        System.out.println(bQueue4.offer(<span class="string">&quot;p&quot;</span>, <span class="number">3</span>, TimeUnit.SECONDS)); <span class="comment">// true</span>        System.out.println(bQueue4.offer(<span class="string">&quot;q&quot;</span>, <span class="number">3</span>, TimeUnit.SECONDS)); <span class="comment">// true</span>        System.out.println(bQueue4.offer(<span class="string">&quot;r&quot;</span>, <span class="number">3</span>, TimeUnit.SECONDS)); <span class="comment">// false</span>        System.out.println(bQueue4.poll(<span class="number">2</span>, TimeUnit.SECONDS)); <span class="comment">// o</span>        System.out.println(bQueue4.poll(<span class="number">2</span>, TimeUnit.SECONDS)); <span class="comment">// p</span>        System.out.println(bQueue4.poll(<span class="number">2</span>, TimeUnit.SECONDS)); <span class="comment">// q</span>        System.out.println(bQueue4.poll(<span class="number">2</span>, TimeUnit.SECONDS)); <span class="comment">// null</span>    &#125;&#125;</code></pre><h1 id="四、常见的-BlockingQueue"><a href="#四、常见的-BlockingQueue" class="headerlink" title="四、常见的 BlockingQueue"></a>四、常见的 BlockingQueue</h1><h2 id="1-ArrayBlockingQueue-常用"><a href="#1-ArrayBlockingQueue-常用" class="headerlink" title="1. ArrayBlockingQueue(常用)"></a>1. ArrayBlockingQueue(常用)</h2><p><strong>由数组结构组成的有界阻塞队列</strong></p><p>基于数组的阻塞队列实现，在 ArrayBlockingQueue 内部，维护了一个定长数组，以便缓存队列中的数据对象，这是一个常用的阻塞队列，除了一个定长数组外，ArrayBlockingQueue 内部还保存着两个整形变量，分别标识着队列的头部和尾部在数组中的位置。</p><p>ArrayBlockingQueue 在生产者放入数据和消费者获取数据，都是共用同一个锁对象，由此也意味着两者无法真正并行运行，这点尤其不同于LinkedBlockingQueue；按照实现原理来分析，ArrayBlockingQueue完全可以采用分离锁，从而实现生产者和消费者操作的完全并行运行。Doug Lea之所以没这样去做，也许是因为ArrayBlockingQueue的数据写入和获取操作已经足够轻巧，以至于引入独立的锁机制，除了给代码带来额外的复杂性外，其在性能上完全占不到任何便宜。ArrayBlockingQueue和LinkedBlockingQueue间还有一个明显的不同之处在于，前者在插入或删除元素时不会产生或销毁任何额外的对象实例，而后者则会生成一个额外的Node对象。这在长时间内需要高效并发地处理大批量数据的系统中，其对于GC的影响还是存在一定的区别。而在创建ArrayBlockingQueue时，我们还可以控制对象的内部锁是否采用公平锁，默认采用非公平锁。</p><h2 id="2-LinkedBlockingQueue-常用"><a href="#2-LinkedBlockingQueue-常用" class="headerlink" title="2. LinkedBlockingQueue(常用)"></a>2. LinkedBlockingQueue(常用)</h2><p><strong>由链表结构组成的有界（但大小默认值为integer.MAX_VALUE）阻塞队列。</strong></p><p>基于链表的阻塞队列，同ArrayListBlockingQueue类似，其内部也维持着一个数据缓冲队列（该队列由一个链表构成），当生产者往队列中放入一个数据时，队列会从生产者手中获取数据，并缓存在队列内部，而生产者立即返回；只有当队列缓冲区达到最大值缓存容量时（LinkedBlockingQueue可以通过构造函数指定该值），才会阻塞生产者队列，直到消费者从队列中消费掉一份数据，生产者线程会被唤醒，反之对于消费者这端的处理也基于同样的原理。而LinkedBlockingQueue之所以能够高效的处理并发数据，还因为其对于生产者端和消费者端分别采用了独立的锁来控制数据同步，这也意味着在高并发的情况下生产者和消费者可以并行地操作队列中的数据，以此来提高整个队列的并发性能。</p><p><strong>ArrayBlockingQueue</strong> 和 <strong>LinkedBlockingQueue</strong> 是两个最普通也是最常用的阻塞队列，一般情况下，在处理多线程间的生产者消费者问题，使用这两个类足以。</p><h2 id="3-DelayQueue"><a href="#3-DelayQueue" class="headerlink" title="3. DelayQueue"></a>3. DelayQueue</h2><p><strong>使用优先级队列实现的延迟无界阻塞队列。</strong></p><p>DelayQueue中的元素只有当其指定的延迟时间到了，才能够从队列中获取到该元素。DelayQueue是一个没有大小限制的队列，因此往队列中插入数据的操作（生产者）永远不会被阻塞，而只有获取数据的操作（消费者）才会被阻塞。</p><h2 id="4-PriorityBlockingQueue"><a href="#4-PriorityBlockingQueue" class="headerlink" title="4. PriorityBlockingQueue"></a>4. PriorityBlockingQueue</h2><p><strong>支持优先级排序的无界阻塞队列。</strong></p><p>基于优先级的阻塞队列（优先级的判断通过构造函数传入的Compator对象来决定），但需要注意的是PriorityBlockingQueue并<strong>不会阻塞数据生产者，而只会在没有可消费的数据时，阻塞数据的消费者</strong>。</p><h2 id="5-SynchronousQueue"><a href="#5-SynchronousQueue" class="headerlink" title="5. SynchronousQueue"></a>5. SynchronousQueue</h2><p><strong>不存储元素的阻塞队列，也即单个元素的队列。</strong></p><p>一种无缓冲的等待队列，类似于无中介的直接交易，有点像原始社会中的生产者和消费者，生产者拿着产品去集市销售给产品的最终消费者，而消费者必须亲自去集市找到所要商品的直接生产者，如果一方没有找到合适的目标，那么对不起，大家都在集市等待。相对于有缓冲的BlockingQueue来说，少了一个中间经销商的环节（缓冲区），如果有经销商，生产者直接把产品批发给经销商，而无需在意经销商最终会将这些产品卖给那些消费者，由于经销商可以库存一部分商品，因此相对于直接交易模式，总体来说采用中间经销商的模式会吞吐量高一些（可以批量买卖）；但另一方面，又因为经销商的引入，使得产品从生产者到消费者中间增加了额外的交易环节，单个产品的及时响应性能可能会降低。</p><p>声明一个SynchronousQueue有两种不同的方式，它们之间有着不太一样的行为。</p><p><strong>公平模式和非公平模式的区别</strong>:</p><ul><li>公平模式：SynchronousQueue会采用公平锁，并配合一个FIFO队列来阻塞多余的生产者和消费者，从而体现整体的公平策略；</li><li>非公平模式（SynchronousQueue默认）：SynchronousQueue采用非公平锁，同时配合一个LIFO队列来管理多余的生产者和消费者，而后一种模式，如果生产者和消费者的处理速度有差距，则很容易出现饥渴的情况，即可能有某些生产者或者是消费者的数据永远都得不到处理。</li></ul><h2 id="6-LinkedTransferQueue"><a href="#6-LinkedTransferQueue" class="headerlink" title="6. LinkedTransferQueue"></a>6. LinkedTransferQueue</h2><p><strong>由链表组成的无界阻塞队列。</strong></p><p>LinkedTransferQueue 是一个由链表结构组成的无界阻塞 TransferQueue 队列。相对于其他阻塞队列，LinkedTransferQueue 多了 tryTransfer 和 transfer 方法.</p><p>LinkedTransferQueue 采用一种预占模式。意思就是消费者线程取元素时，如果队列不为空，则直接取走数据，若队列为空，那就生成一个节点（节点元素为 null）入队，然后消费者线程被等待在这个节点上，后面生产者线程入队时发现有一个元素为 null 的节点，生产者线程就不入队了，直接就将元素填充到该节点，并唤醒该节点等待的线程，被唤醒的消费者线程取走元素，从调用的方法返回。</p><h2 id="7-LinkedBlockingDeque"><a href="#7-LinkedBlockingDeque" class="headerlink" title="7.  LinkedBlockingDeque"></a>7.  LinkedBlockingDeque</h2><p><strong>由链表组成的双向阻塞队列</strong></p><p>LinkedBlockingDeque 是一个由链表结构组成的双向阻塞队列，即可以从队列的两端插入和移除元素。对于一些指定的操作，在插入或者获取队列元素时如果队列状态不允许该操作可能会阻塞住该线程直到队列状态变更为允许操作，这里的阻塞一般有两种情况</p><ul><li><p>插入元素时: 如果当前队列已满将会进入阻塞状态，一直等到队列有空的位置时再将该元素插入，该操作可以通过设置超时参数，超时后返回 false 表示操作失败，也可以不设置超时参数一直阻塞，中断后抛出 InterruptedException 异常</p></li><li><p>读取元素时: 如果当前队列为空会阻塞住直到队列不为空然后返回元素，同样可以通过设置超时参数</p></li></ul>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;一、阻塞队列概述&quot;&gt;&lt;a href=&quot;#一、阻塞队列概述&quot; class=&quot;headerlink&quot; title=&quot;一、阻塞队列概述&quot;&gt;&lt;/a&gt;一、阻塞队列概述&lt;/h1&gt;&lt;p&gt;阻塞队列，顾名思义，首先它是一个队列, 通过一个共享的队列，可以使得数据由队列的一端输入，从</summary>
      
    
    
    
    <category term="JUC" scheme="https://georgechan95.github.io/categories/JUC/"/>
    
    
    <category term="juc" scheme="https://georgechan95.github.io/tags/juc/"/>
    
    <category term="java" scheme="https://georgechan95.github.io/tags/java/"/>
    
  </entry>
  
  <entry>
    <title>07-JUC辅助类CountDownLatch、CyclicBarrier、Semaphore</title>
    <link href="https://georgechan95.github.io/blog/838e7581.html"/>
    <id>https://georgechan95.github.io/blog/838e7581.html</id>
    <published>2024-09-07T05:00:00.000Z</published>
    <updated>2024-09-07T07:42:20.066Z</updated>
    
    <content type="html"><![CDATA[<p>JUC 中提供了三种常用的辅助类，通过这些辅助类可以很好的解决线程数量过多时 Lock 锁的频繁操作。这三种辅助类为：</p><ul><li>CountDownLatch: 减少计数</li><li>CyclicBarrier: 循环栅栏</li><li>Semaphore: 信号灯</li></ul><h1 id="一、减少计数-CountDownLatch"><a href="#一、减少计数-CountDownLatch" class="headerlink" title="一、减少计数 CountDownLatch"></a>一、减少计数 CountDownLatch</h1><h2 id="1-概述"><a href="#1-概述" class="headerlink" title="1. 概述"></a>1. 概述</h2><p>该类的构造方法为 <code>CountDownLatch(int count)</code> 构造一个用给定计数初始化的 <code>CountDownLatch</code> </p><p>在这里插入代码片</p><pre><code class="highlight java"><span class="comment">/**</span><span class="comment"> * Constructs a &#123;<span class="doctag">@code</span> CountDownLatch&#125; initialized with the given count.</span><span class="comment"> *</span><span class="comment"> * <span class="doctag">@param</span> count the number of times &#123;<span class="doctag">@link</span> #countDown&#125; must be invoked</span><span class="comment"> *        before threads can pass through &#123;<span class="doctag">@link</span> #await&#125;</span><span class="comment"> * <span class="doctag">@throws</span> IllegalArgumentException if &#123;<span class="doctag">@code</span> count&#125; is negative</span><span class="comment"> */</span><span class="keyword">public</span> <span class="title function_">CountDownLatch</span><span class="params">(<span class="type">int</span> count)</span> &#123;    <span class="keyword">if</span> (count &lt; <span class="number">0</span>) <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">IllegalArgumentException</span>(<span class="string">&quot;count &lt; 0&quot;</span>);    <span class="built_in">this</span>.sync = <span class="keyword">new</span> <span class="title class_">Sync</span>(count);&#125;</code></pre><p>CountDownLatch 类可以设置一个计数器，然后通过 countDown 方法来进行减 1 的操作，使用 await 方法等待计数器不大于 0，然后继续执行 await 方法之后的语句。具体步骤可以演化为<strong>定义一个类，减1操作，并等待到0，为0执行结果</strong>。</p><p><strong>两个常用的主要方法</strong></p><ul><li>await() 使当前线程在锁存器倒计数至零之前一直在等待，除非线程被中断</li></ul><pre><code class="highlight java"><span class="comment">/**</span><span class="comment"> * Causes the current thread to wait until the latch has counted down to</span><span class="comment"> * zero, unless the thread is &#123;<span class="doctag">@linkplain</span> Thread#interrupt interrupted&#125;.</span><span class="comment"> *</span><span class="comment"> * &lt;p&gt;If the current count is zero then this method returns immediately.</span><span class="comment"> *</span><span class="comment"> * &lt;p&gt;If the current count is greater than zero then the current</span><span class="comment"> * thread becomes disabled for thread scheduling purposes and lies</span><span class="comment"> * dormant until one of two things happen:</span><span class="comment"> * &lt;ul&gt;</span><span class="comment"> * &lt;li&gt;The count reaches zero due to invocations of the</span><span class="comment"> * &#123;<span class="doctag">@link</span> #countDown&#125; method; or</span><span class="comment"> * &lt;li&gt;Some other thread &#123;<span class="doctag">@linkplain</span> Thread#interrupt interrupts&#125;</span><span class="comment"> * the current thread.</span><span class="comment"> * &lt;/ul&gt;</span><span class="comment"> *</span><span class="comment"> * &lt;p&gt;If the current thread:</span><span class="comment"> * &lt;ul&gt;</span><span class="comment"> * &lt;li&gt;has its interrupted status set on entry to this method; or</span><span class="comment"> * &lt;li&gt;is &#123;<span class="doctag">@linkplain</span> Thread#interrupt interrupted&#125; while waiting,</span><span class="comment"> * &lt;/ul&gt;</span><span class="comment"> * then &#123;<span class="doctag">@link</span> InterruptedException&#125; is thrown and the current thread&#x27;s</span><span class="comment"> * interrupted status is cleared.</span><span class="comment"> *</span><span class="comment"> * <span class="doctag">@throws</span> InterruptedException if the current thread is interrupted</span><span class="comment"> *         while waiting</span><span class="comment"> */</span><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">await</span><span class="params">()</span> <span class="keyword">throws</span> InterruptedException &#123;    sync.acquireSharedInterruptibly(<span class="number">1</span>);&#125;</code></pre><ul><li>countDown()递减锁存器的计数，如果计数达到零，将释放所有等待的线程</li></ul><pre><code class="highlight java"><span class="comment">/**</span><span class="comment"> * Decrements the count of the latch, releasing all waiting threads if</span><span class="comment"> * the count reaches zero.</span><span class="comment"> *</span><span class="comment"> * &lt;p&gt;If the current count is greater than zero then it is decremented.</span><span class="comment"> * If the new count is zero then all waiting threads are re-enabled for</span><span class="comment"> * thread scheduling purposes.</span><span class="comment"> *</span><span class="comment"> * &lt;p&gt;If the current count equals zero then nothing happens.</span><span class="comment"> */</span><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">countDown</span><span class="params">()</span> &#123;    sync.releaseShared(<span class="number">1</span>);&#125;<span class="comment">/**</span><span class="comment"> * Releases in shared mode.  Implemented by unblocking one or more</span><span class="comment"> * threads if &#123;<span class="doctag">@link</span> #tryReleaseShared&#125; returns true.</span><span class="comment"> *</span><span class="comment"> * <span class="doctag">@param</span> arg the release argument.  This value is conveyed to</span><span class="comment"> *        &#123;<span class="doctag">@link</span> #tryReleaseShared&#125; but is otherwise uninterpreted</span><span class="comment"> *        and can represent anything you like.</span><span class="comment"> * <span class="doctag">@return</span> the value returned from &#123;<span class="doctag">@link</span> #tryReleaseShared&#125;</span><span class="comment"> */</span><span class="keyword">public</span> <span class="keyword">final</span> <span class="type">boolean</span> <span class="title function_">releaseShared</span><span class="params">(<span class="type">int</span> arg)</span> &#123;    <span class="keyword">if</span> (tryReleaseShared(arg)) &#123;        signalNext(head);        <span class="keyword">return</span> <span class="literal">true</span>;    &#125;    <span class="keyword">return</span> <span class="literal">false</span>;&#125;</code></pre><h2 id="2-案例演示"><a href="#2-案例演示" class="headerlink" title="2. 案例演示"></a>2. 案例演示</h2><p>6个同学陆续离开教室之后，班长才能锁门</p><p><strong>演示没有CountDownLatch的情况</strong></p><p>如果不加 CountDownLatch类，会出现线程混乱执行，同学还未离开教室班长就已经锁门了</p><pre><code class="highlight java"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">NoCountDownLatch</span> &#123;    <span class="comment">//6个同学陆续离开教室之后，班长锁门</span>    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> InterruptedException &#123;        <span class="comment">// 创建六个线程，模拟六个学生</span>        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">1</span>; i &lt;=<span class="number">6</span>; i++) &#123;            <span class="keyword">new</span> <span class="title class_">Thread</span>(()-&gt;&#123;                System.out.println(Thread.currentThread().getName()+<span class="string">&quot;离开教室&quot;</span>);            &#125;,String.valueOf(i)).start();        &#125;        System.out.println(Thread.currentThread().getName()+<span class="string">&quot;锁门&quot;</span>);    &#125;&#125;</code></pre><p>运行结果：</p><pre><code class="highlight shell">5离开教室main锁门2离开教室1离开教室6离开教室3离开教室4离开教室</code></pre><p><strong>添加CountDownLatch</strong></p><pre><code class="highlight java"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">CountDownLatchDemo</span> &#123;    <span class="comment">//6个同学陆续离开教室之后，班长锁门</span>    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> InterruptedException &#123;        <span class="type">CountDownLatch</span> <span class="variable">countDownLatch</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">CountDownLatch</span>(<span class="number">6</span>);        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">1</span>; i &lt;= <span class="number">6</span>; i++) &#123;            <span class="keyword">new</span> <span class="title class_">Thread</span>(() -&gt; &#123;                System.out.println(Thread.currentThread().getName() + <span class="string">&quot; 号同学离开了教室&quot;</span>);                <span class="comment">// 计数器减1</span>                countDownLatch.countDown();            &#125;, String.valueOf(i)).start();        &#125;        <span class="comment">// 阻塞，等待计数器为0后，继续往下执行</span>        countDownLatch.await();        System.out.println(Thread.currentThread().getName() + <span class="string">&quot;执行了关门操作&quot;</span>);    &#125;&#125;</code></pre><p>运行结果：</p><pre><code class="highlight shell">2 号同学离开了教室5 号同学离开了教室6 号同学离开了教室1 号同学离开了教室4 号同学离开了教室3 号同学离开了教室main执行了关门操作</code></pre><h1 id="二、循环栅栏-CyclicBarrier"><a href="#二、循环栅栏-CyclicBarrier" class="headerlink" title="二、循环栅栏 CyclicBarrier"></a>二、循环栅栏 CyclicBarrier</h1><h2 id="1-概述-1"><a href="#1-概述-1" class="headerlink" title="1. 概述"></a>1. 概述</h2><p>CyclicBarrier 字面意思是环栅栏，是 JUC 下的一个并发工具，跟 CountDownLatch 很相似，都可以使线程先等待然后再执行，但是它的功能比 CountDownLatch 更加复杂和强大， CountDownLatch 是一个或者多个线程等待另外一批线程执行完毕后，在接着执行，而 CyclicBarrier 是等待一批线程到达某个状态之后再同时开始执行，回环的意思是当所有的线程被释放后，CyclicBarrier 可以被重启，也就是可以重复使用。</p><p><img src="https://raw.githubusercontent.com/GeorgeChan95/blogimg/master/img/2024/09/07/20240907-141817.png" alt="CyclicBarrier"></p><p>常用的构造方法有：**CyclicBarrier(int parties，Runnable barrierAction)**，其底层代码如下</p><pre><code class="highlight java"><span class="keyword">public</span> <span class="title function_">CyclicBarrier</span><span class="params">(<span class="type">int</span> parties, Runnable barrierAction)</span> &#123;    <span class="keyword">if</span> (parties &lt;= <span class="number">0</span>) <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">IllegalArgumentException</span>();    <span class="built_in">this</span>.parties = parties;    <span class="built_in">this</span>.count = parties;    <span class="comment">// 最后需要执行的方法</span>    <span class="built_in">this</span>.barrierCommand = barrierAction;&#125;</code></pre><p>创建一个新的CyclicBarrier，它将在<strong>给定数量的参与者</strong>（线程）处于等待状态时启动，并在启动barrier时执行**给定的屏障操作，*<em>该操作由最后一个*<em>进入barrier的线程操作</em></em></p><p>常用的方法有：</p><p><strong>await()</strong> 在所有的参与者都已经在此barrier上调用await方法之前一直等待。</p><pre><code class="highlight java"><span class="keyword">public</span> <span class="type">int</span> <span class="title function_">await</span><span class="params">()</span> <span class="keyword">throws</span> InterruptedException, BrokenBarrierException &#123;    <span class="keyword">try</span> &#123;        <span class="keyword">return</span> dowait(<span class="literal">false</span>, <span class="number">0L</span>);    &#125; <span class="keyword">catch</span> (TimeoutException toe) &#123;        <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">Error</span>(toe); <span class="comment">// cannot happen</span>    &#125;&#125;<span class="keyword">private</span> <span class="type">int</span> <span class="title function_">dowait</span><span class="params">(<span class="type">boolean</span> timed, <span class="type">long</span> nanos)</span>    <span class="keyword">throws</span> InterruptedException, BrokenBarrierException,TimeoutException &#123;    <span class="keyword">final</span> <span class="type">ReentrantLock</span> <span class="variable">lock</span> <span class="operator">=</span> <span class="built_in">this</span>.lock;    <span class="comment">// 同步锁</span>    lock.lock();    <span class="keyword">try</span> &#123;        <span class="keyword">final</span> <span class="type">Generation</span> <span class="variable">g</span> <span class="operator">=</span> generation;        <span class="keyword">if</span> (g.broken)            <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">BrokenBarrierException</span>();        <span class="keyword">if</span> (Thread.interrupted()) &#123;            breakBarrier();            <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">InterruptedException</span>();        &#125;<span class="comment">// 每次执行 CyclicBarrier 一次障碍数会加一，距离目标障碍数-1</span>        <span class="type">int</span> <span class="variable">index</span> <span class="operator">=</span> --count;        <span class="comment">// 当达到目标障碍数执行if内代码</span>        <span class="keyword">if</span> (index == <span class="number">0</span>) &#123;  <span class="comment">// tripped</span>            <span class="type">boolean</span> <span class="variable">ranAction</span> <span class="operator">=</span> <span class="literal">false</span>;            <span class="keyword">try</span> &#123;                <span class="keyword">final</span> <span class="type">Runnable</span> <span class="variable">command</span> <span class="operator">=</span> barrierCommand;                <span class="keyword">if</span> (command != <span class="literal">null</span>)                    <span class="comment">// 执行Runnable代码</span>                    command.run();                ranAction = <span class="literal">true</span>;                nextGeneration();                <span class="comment">// 返回0</span>                <span class="keyword">return</span> <span class="number">0</span>;            &#125; <span class="keyword">finally</span> &#123;                <span class="keyword">if</span> (!ranAction)                    breakBarrier();            &#125;        &#125;        <span class="comment">// 循环，直到触发、中断、中断或超时  </span>        <span class="keyword">for</span> (;;) &#123;            <span class="keyword">try</span> &#123;                <span class="keyword">if</span> (!timed)                    trip.await();                <span class="keyword">else</span> <span class="keyword">if</span> (nanos &gt; <span class="number">0L</span>)                    nanos = trip.awaitNanos(nanos);            &#125; <span class="keyword">catch</span> (InterruptedException ie) &#123;                <span class="keyword">if</span> (g == generation &amp;&amp; ! g.broken) &#123;                    breakBarrier();                    <span class="keyword">throw</span> ie;                &#125; <span class="keyword">else</span> &#123;                    <span class="comment">// We&#x27;re about to finish waiting even if we had not</span>                    <span class="comment">// been interrupted, so this interrupt is deemed to</span>                    <span class="comment">// &quot;belong&quot; to subsequent execution.</span>                    Thread.currentThread().interrupt();                &#125;            &#125;            <span class="keyword">if</span> (g.broken)                <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">BrokenBarrierException</span>();            <span class="keyword">if</span> (g != generation)                <span class="keyword">return</span> index;            <span class="keyword">if</span> (timed &amp;&amp; nanos &lt;= <span class="number">0L</span>) &#123;                breakBarrier();                <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">TimeoutException</span>();            &#125;        &#125;    &#125; <span class="keyword">finally</span> &#123;        lock.unlock();    &#125;&#125;</code></pre><p>从底层代码可知， CyclicBarrier 的构造方法第一个参数是目标障碍数，每次执行 CyclicBarrier 一次障碍数会+1，如果达到了目标障碍数，才会执行 cyclicBarrier.await()之后的语句。可以将 CyclicBarrier 理解为+1 操作（指与目标障碍数的距离）</p><h2 id="2-案例演示-1"><a href="#2-案例演示-1" class="headerlink" title="2. 案例演示"></a>2. 案例演示</h2><p><strong>代码案例：集齐7颗龙珠就可以召唤神龙</strong></p><pre><code class="highlight java"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">CyclicBarrirtTest</span> &#123;    <span class="keyword">private</span> <span class="keyword">static</span> <span class="type">Integer</span> <span class="variable">NUMBER</span> <span class="operator">=</span> <span class="number">7</span>;    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;        <span class="comment">// 每次执行 CyclicBarrier 一次障碍数会加一，如果达到了目标障碍数，才会执行 cyclicBarrier.await()之后的语句。</span>        <span class="type">CyclicBarrier</span> <span class="variable">cyclicBarrier</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">CyclicBarrier</span>(NUMBER, () -&gt; System.out.println(<span class="string">&quot;集齐7颗龙珠，可以召唤神龙了&quot;</span>));        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">1</span>; i &lt;= <span class="number">7</span>; i++) &#123;            <span class="keyword">new</span> <span class="title class_">Thread</span>(() -&gt; &#123;                System.out.println(Thread.currentThread().getName() + <span class="string">&quot; 号龙珠已收集&quot;</span>);                <span class="keyword">try</span> &#123;                    <span class="comment">// 执行 await() 方法，障碍数 +1</span>                    cyclicBarrier.await();                &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;                    <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">RuntimeException</span>(e);                &#125; <span class="keyword">catch</span> (BrokenBarrierException e) &#123;                    <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">RuntimeException</span>(e);                &#125;            &#125;, String.valueOf(i)).start();        &#125;    &#125;&#125;</code></pre><p><strong>执行结果</strong></p><pre><code class="highlight shell">5 号龙珠已收集1 号龙珠已收集4 号龙珠已收集2 号龙珠已收集6 号龙珠已收集3 号龙珠已收集7 号龙珠已收集集齐7颗龙珠，可以召唤神龙了</code></pre><h1 id="三、信号灯-Semaphore"><a href="#三、信号灯-Semaphore" class="headerlink" title="三、信号灯 Semaphore"></a>三、信号灯 Semaphore</h1><h2 id="1-概述-2"><a href="#1-概述-2" class="headerlink" title="1. 概述"></a>1. 概述</h2><p>信号量(Semaphore)，又被称为信号灯，在多线程环境下用于协调各个线程, 以保证它们能够正确、合理的使用公共资源。信号量维护了一个许可集，我们在初始化Semaphore时需要为这个许可集传入一个数量值，该数量值代表同一时间能访问共享资源的线程数量。</p><p>线程可以通过acquire()方法获取到一个许可，然后对共享资源进行操作。注意如果许可集已分配完了，那么线程将进入等待状态，直到其他线程释放许可才有机会再获取许可，线程释放一个许可通过release()方法完成，”许可”将被归还给Semaphore。</p><p><strong>具体常用的构造方法有：</strong></p><p>Semaphore(int permits) 创建具有给定的许可数和非公平的公平设置的 Semapore</p><pre><code class="highlight java"><span class="keyword">public</span> <span class="title function_">Semaphore</span><span class="params">(<span class="type">int</span> <span class="keyword">permits</span>)</span> &#123;    <span class="comment">// 默认创建非公平锁</span>    sync = <span class="keyword">new</span> <span class="title class_">NonfairSync</span>(<span class="keyword">permits</span>);&#125;<span class="keyword">public</span> <span class="title function_">Semaphore</span><span class="params">(<span class="type">int</span> <span class="keyword">permits</span>, <span class="type">boolean</span> fair)</span> &#123;    <span class="comment">// fair为true时，为公平锁</span>    sync = fair ? <span class="keyword">new</span> <span class="title class_">FairSync</span>(<span class="keyword">permits</span>) : <span class="keyword">new</span> <span class="title class_">NonfairSync</span>(<span class="keyword">permits</span>);&#125;</code></pre><p><strong>具体常用的方法有：</strong></p><p>acquire()从此信号量获取一个许可，在获取到许可前一直将线程阻塞。</p><p>release()释放一个许可，将其返回给信号量</p><pre><code class="highlight java"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">acquire</span><span class="params">()</span> <span class="keyword">throws</span> InterruptedException &#123;    <span class="comment">// 阻塞当前线程</span>    sync.acquireSharedInterruptibly(<span class="number">1</span>);&#125;<span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">release</span><span class="params">()</span> &#123;    <span class="comment">// 释放一个许可</span>    sync.releaseShared(<span class="number">1</span>);&#125;</code></pre><p>设置许可数量 <code>Semaphore semaphore = new Semaphore(3);</code></p><p><strong>一般 acquire(）都会抛出异常，release 在 finally 中执行</strong></p><h2 id="2-案例演示-2"><a href="#2-案例演示-2" class="headerlink" title="2. 案例演示"></a>2. 案例演示</h2><p>6辆汽车，停3个车位</p><pre><code class="highlight java"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">SemaphoreTest</span> &#123;    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;        <span class="comment">//创建Semaphore，设置许可数量</span>        <span class="type">Semaphore</span> <span class="variable">semaphore</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Semaphore</span>(<span class="number">3</span>);        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">1</span>; i &lt;= <span class="number">6</span>; i++) &#123;            <span class="keyword">new</span> <span class="title class_">Thread</span>(() -&gt; &#123;                <span class="keyword">try</span> &#123;                    <span class="comment">// 获取许可，在获取到前，线程阻塞</span>                    semaphore.acquire();                    System.out.println(Thread.currentThread().getName() + <span class="string">&quot; 找到了车位&quot;</span>);                    <span class="comment">// 设置停车时间</span>                    TimeUnit.SECONDS.sleep(<span class="keyword">new</span> <span class="title class_">Random</span>().nextInt(<span class="number">5</span>));                    <span class="comment">// 离开车位</span>                    System.out.println(Thread.currentThread().getName()+<span class="string">&quot;------离开了车位&quot;</span>);                &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;                    <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">RuntimeException</span>(e);                &#125; <span class="keyword">finally</span> &#123;                    <span class="comment">// 释放许可</span>                    semaphore.release();                &#125;            &#125;, <span class="string">&quot;车辆&quot;</span> + i).start();        &#125;    &#125;&#125;</code></pre><p><strong>执行结果：</strong></p><pre><code class="highlight shell">车辆1 找到了车位车辆3 找到了车位车辆2 找到了车位车辆1------离开了车位车辆4 找到了车位车辆2------离开了车位车辆5 找到了车位车辆5------离开了车位车辆6 找到了车位车辆3------离开了车位车辆6------离开了车位车辆4------离开了车位</code></pre>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;JUC 中提供了三种常用的辅助类，通过这些辅助类可以很好的解决线程数量过多时 Lock 锁的频繁操作。这三种辅助类为：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;CountDownLatch: 减少计数&lt;/li&gt;
&lt;li&gt;CyclicBarrier: 循环栅栏&lt;/li&gt;
&lt;li&gt;Semap</summary>
      
    
    
    
    <category term="JUC" scheme="https://georgechan95.github.io/categories/JUC/"/>
    
    
    <category term="juc" scheme="https://georgechan95.github.io/tags/juc/"/>
    
    <category term="java" scheme="https://georgechan95.github.io/tags/java/"/>
    
  </entry>
  
  <entry>
    <title>06-Callable &amp; Future 接口</title>
    <link href="https://georgechan95.github.io/blog/f60e37c5.html"/>
    <id>https://georgechan95.github.io/blog/f60e37c5.html</id>
    <published>2024-09-06T14:10:00.000Z</published>
    <updated>2024-09-07T02:21:37.284Z</updated>
    
    <content type="html"><![CDATA[<h1 id="一、Callable接口"><a href="#一、Callable接口" class="headerlink" title="一、Callable接口"></a>一、Callable接口</h1><p><strong>创建线程的多种方式：</strong></p><ul><li>继承Thread类</li><li>实现Runnable接口</li><li>Callable接口</li><li>线程池</li></ul><h2 id="1-Callable接口创建线程"><a href="#1-Callable接口创建线程" class="headerlink" title="1. Callable接口创建线程"></a>1. Callable接口创建线程</h2><p>目前学习了有两种创建线程的方法，一种是通过创建 Thread 类，另一种是通过使用 Runnable 创建线程，但是 Runnable 缺少的一项功能是，当线程终止时（即 run()完成时），我们无法使线程返回结果。为了支持此功能，Java 中提供了 Callable 接口</p><p><strong>比较Runnable接口和Callable接口</strong></p><ul><li>Callable 中的 call() 计算结果，如果无法计算结果，会抛出异常</li><li>Runnable 中的 run() 使用实现接口 Runnable 的对象创建一个线程时，启动该线程将导致在独立执行的线程中调用该对象的run方法总的来说：run() 没有返回值，不会抛出异常。而 call() 有返回值，会抛出异常</li></ul><p>因为Thread的构造函数中没有Callable接口的参数设置,直接替换不可以，只能用下面这种线程创建方法（找一个类，即和 Runnable 接口有关系，又和 Callable 接口有关系）, 发现 Runnable 接口有实现类 FutureTask（中间对象）, FutureTask 的构造函数有Callable参数，通过 FutureTask 创建线程对象</p><p><strong>Callable使用示例：</strong></p><pre><code class="highlight java"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">CallableTest</span> &#123;    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> ExecutionException, InterruptedException &#123;        <span class="comment">// Runable 调用线程</span>        <span class="keyword">new</span> <span class="title class_">Thread</span>(() -&gt; &#123;            System.out.println(Thread.currentThread().getName() + <span class="string">&quot;执行了run方法&quot;</span>);        &#125;, <span class="string">&quot;Runable&quot;</span>).start();        <span class="comment">// 使用Callable调用线程</span>        FutureTask&lt;String&gt; futureTask = <span class="keyword">new</span> <span class="title class_">FutureTask</span>&lt;&gt;(() -&gt; &#123;            System.out.println(Thread.currentThread().getName() +  <span class="string">&quot;执行了call方法&quot;</span>);            <span class="keyword">return</span> <span class="string">&quot;Callable的call方法返回结果&quot;</span>;        &#125;);        <span class="keyword">new</span> <span class="title class_">Thread</span>(futureTask, <span class="string">&quot;Callable&quot;</span>).start();        <span class="type">String</span> <span class="variable">result</span> <span class="operator">=</span> futureTask.get();        System.out.println(result);    &#125;&#125;</code></pre><p><strong>执行结果：</strong></p><pre><code class="highlight shell">Runable执行了run方法Callable执行了call方法Callable的call方法返回结果</code></pre><p><strong>实现Callable接口的写法</strong></p><pre><code class="highlight java"><span class="comment">//比较两个接口</span><span class="comment">//实现Runnable接口</span><span class="keyword">class</span> <span class="title class_">MyThread1</span> <span class="keyword">implements</span> <span class="title class_">Runnable</span> &#123;    <span class="meta">@Override</span>    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span> &#123;        System.out.println(Thread.currentThread().getName() + <span class="string">&quot;执行了run方法&quot;</span>);    &#125;&#125;<span class="comment">//实现Callable接口</span><span class="keyword">class</span> <span class="title class_">MyThread2</span> <span class="keyword">implements</span> <span class="title class_">Callable</span> &#123;    <span class="meta">@Override</span>    <span class="keyword">public</span> Integer <span class="title function_">call</span><span class="params">()</span> <span class="keyword">throws</span> Exception &#123;        System.out.println(Thread.currentThread().getName()+<span class="string">&quot; come in callable&quot;</span>);        <span class="keyword">return</span> <span class="number">200</span>;    &#125;&#125;<span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Demo1</span> &#123;    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> ExecutionException, InterruptedException &#123;        <span class="comment">//Runnable接口创建线程</span>        <span class="keyword">new</span> <span class="title class_">Thread</span>(<span class="keyword">new</span> <span class="title class_">MyThread1</span>(),<span class="string">&quot;MyThread1&quot;</span>).start();        <span class="comment">//Callable接口,报错，没有这个类型的构造方法</span>       <span class="comment">// new Thread(new MyThread2(),&quot;BB&quot;).start();</span>        <span class="comment">//FutureTask</span>        FutureTask&lt;Integer&gt; futureTask1 = <span class="keyword">new</span> <span class="title class_">FutureTask</span>&lt;&gt;(<span class="keyword">new</span> <span class="title class_">MyThread2</span>());        <span class="comment">//lam表达式</span>        FutureTask&lt;Integer&gt; futureTask2 = <span class="keyword">new</span> <span class="title class_">FutureTask</span>&lt;&gt;(()-&gt;&#123;            System.out.println(Thread.currentThread().getName()+<span class="string">&quot; come in callable&quot;</span>);            <span class="keyword">return</span> <span class="number">1024</span>;        &#125;);        <span class="comment">//创建一个线程</span>        <span class="keyword">new</span> <span class="title class_">Thread</span>(futureTask2,<span class="string">&quot;futureTask2&quot;</span>).start();        <span class="keyword">new</span> <span class="title class_">Thread</span>(futureTask1,<span class="string">&quot;futureTask1&quot;</span>).start();        <span class="keyword">while</span>(!futureTask2.isDone()) &#123;            System.out.println(<span class="string">&quot;futureTask2 wait.....&quot;</span>);        &#125;        <span class="comment">//调用FutureTask的get方法</span>        System.out.println(<span class="string">&quot;futureTask2结果：&quot;</span> + futureTask2.get());        System.out.println(<span class="string">&quot;futureTask1结果：&quot;</span> + futureTask1.get());        System.out.println(Thread.currentThread().getName()+<span class="string">&quot; come over&quot;</span>);    &#125;&#125;</code></pre><p><strong>执行结果：</strong></p><pre><code class="highlight shell">futureTask2 wait.....futureTask2 wait.....MyThread1执行了run方法futureTask2 wait.....futureTask1 come in callablefutureTask2 come in callablefutureTask2 wait.....futureTask2 wait.....futureTask2结果：1024futureTask1结果：200main come over</code></pre><h2 id="2-Future-接口"><a href="#2-Future-接口" class="headerlink" title="2. Future 接口"></a>2. Future 接口</h2><p>当 call（）方法完成时，结果必须存储在主线程已知的对象中，以便主线程可以知道该线程返回的结果。为此，可以使用 Future 对象。</p><p>将 Future 视为保存结果的对象–它可能暂时不保存结果，但将来会保存（一旦Callable 返回）。Future 基本上是主线程可以跟踪进度以及其他线程的结果的一种方式。要实现此接口，必须重写 5 种方法，这里列出了重要的方法,如下:</p><ul><li><p><strong>public boolean cancel (boolean mayInterruptIfRunning)</strong> 用于停止任务。</p><p>如果尚未启动，它将停止任务。如果已启动，则仅在 mayInterruptIfRunning 为 true时才会中断任务。</p></li><li><p><strong>public boolean isCancelled()</strong></p><p>观察任务是否取消成功</p></li><li><p><strong>public V get() throws InterruptedException, ExecutionException</strong> 用于获取任务的结果。</p><p>如果任务完成，它将立即返回结果，否则将等待任务完成，然后返回结果。</p></li><li><p><strong>public V get(long timeout, TimeUnit unit) throws InterruptedException, ExecutionException, TimeoutException</strong></p><p>在指定时间内尝试获取执行结果，若超时则抛出超时异常</p></li><li><p><strong>public boolean isDone()</strong> 如果任务完成，则返回 true，否则返回 false</p></li></ul><p><strong>使用示例：</strong></p><pre><code class="highlight java"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">FutureTest</span> &#123;    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception &#123;        <span class="comment">// 创建一个线程池</span>        <span class="type">ExecutorService</span> <span class="variable">executor</span> <span class="operator">=</span> Executors.newFixedThreadPool(<span class="number">1</span>);        <span class="comment">// 初始化一个任务</span>        Callable&lt;String&gt; task = <span class="keyword">new</span> <span class="title class_">Task</span>();        <span class="comment">// 提交任务并获得Future的实例</span>        Future&lt;String&gt; future = executor.submit(task);        <span class="comment">// 从Future获取异步执行返回的结果(可能会阻塞等待结果)</span>        <span class="type">String</span> <span class="variable">result</span> <span class="operator">=</span>future.get();        System.out.println(<span class="string">&quot;任务执行结果：&quot;</span> +  result);        <span class="comment">// 任务执行完毕之后，关闭线程池（可选）</span>        executor.shutdown();    &#125;&#125;<span class="keyword">class</span> <span class="title class_">Task</span> <span class="keyword">implements</span> <span class="title class_">Callable</span>&lt;String&gt; &#123;    <span class="meta">@Override</span>    <span class="keyword">public</span> String <span class="title function_">call</span><span class="params">()</span> <span class="keyword">throws</span> Exception &#123;        <span class="comment">// 执行下载某文件任务，并返回文件名称</span>        System.out.println(<span class="string">&quot;thread name:&quot;</span> +  Thread.currentThread().getName() + <span class="string">&quot; 开始执行下载任务&quot;</span>);        <span class="keyword">return</span> <span class="string">&quot;xxx.png&quot;</span>;    &#125;&#125;</code></pre><p><strong>执行结果：</strong></p><pre><code class="highlight shell">thread name:pool-1-thread-1 开始执行下载任务任务执行结果：xxx.png</code></pre><p>多次调用 <code>future.get()</code> 方法，<code>call()</code> 方法中的打印语句不会重复执行，直接返回了结果，因为 Future 在第一次调用 get() 方法时缓存了结果。</p><h1 id="二、FutureTask"><a href="#二、FutureTask" class="headerlink" title="二、FutureTask"></a>二、FutureTask</h1><p>Java 库具有具体的 FutureTask 类型，该类型实现 Runnable 和 Future，并方便地将两种功能组合在一起。 可以通过为其构造函数提供 Callable 来创建FutureTask。然后，将 FutureTask 对象提供给 Thread 的构造函数以创建Thread 对象。因此，间接地使用 Callable 创建线程。</p><p><strong>核心原理:(重点)</strong></p><p>在主线程中需要执行比较耗时的操作时，但又不想阻塞主线程时，可以把这些作业交给 Future 对象在后台完成</p><ul><li>当主线程将来需要时，就可以通过 Future 对象获得后台作业的计算结果或者执行状态</li><li>一般 FutureTask 多用于耗时的计算，主线程可以在完成自己的任务后，再去获取结果。</li><li>仅在计算完成时才能检索结果；如果计算尚未完成，则阻塞 get 方法</li><li>一旦计算完成，就不能再重新开始或取消计算</li><li>get 方法而获取结果只有在计算完成时获取，否则会一直阻塞直到任务转入完成状态，然后会返回结果或者抛出异常</li><li>get 只计算一次,因此 get 方法放到最后</li></ul><p><strong>总结：</strong></p><ul><li>在主线程中需要执行比较耗时的操作时，但又不想阻塞主线程时，可以把这些作业交给 Future 对象在后台完成, 当主线程将来需要时，就可以通过 Future对象获得后台作业的计算结果或者执行状态</li><li>一般 FutureTask 多用于耗时的计算，主线程可以在完成自己的任务后，再去获取结果</li><li>仅在计算完成时才能检索结果；如果计算尚未完成，则阻塞 get 方法。一旦计算完成，就不能再重新开始或取消计算。get 方法而获取结果只有在计算完成时获取，否则会一直阻塞直到任务转入完成状态，然后会返回结果或者抛出异常。</li><li>只计算一次</li></ul>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;一、Callable接口&quot;&gt;&lt;a href=&quot;#一、Callable接口&quot; class=&quot;headerlink&quot; title=&quot;一、Callable接口&quot;&gt;&lt;/a&gt;一、Callable接口&lt;/h1&gt;&lt;p&gt;&lt;strong&gt;创建线程的多种方式：&lt;/strong&gt;&lt;/p</summary>
      
    
    
    
    <category term="JUC" scheme="https://georgechan95.github.io/categories/JUC/"/>
    
    
    <category term="juc" scheme="https://georgechan95.github.io/tags/juc/"/>
    
    <category term="java" scheme="https://georgechan95.github.io/tags/java/"/>
    
  </entry>
  
  <entry>
    <title>05-公平锁和非公平锁，死锁，可重入锁</title>
    <link href="https://georgechan95.github.io/blog/f184587f.html"/>
    <id>https://georgechan95.github.io/blog/f184587f.html</id>
    <published>2024-09-05T12:12:00.000Z</published>
    <updated>2024-09-06T01:55:57.616Z</updated>
    
    <content type="html"><![CDATA[<h1 id="一、synchronized-锁的8种情况"><a href="#一、synchronized-锁的8种情况" class="headerlink" title="一、synchronized 锁的8种情况"></a>一、synchronized 锁的8种情况</h1><p>下面通过一段代码，演示 synchronized 锁的 8 种情况</p><ol><li><p>标准访问，先打印短信还是邮件</p><pre><code class="highlight java"><span class="keyword">class</span> <span class="title class_">Phone</span> &#123;    <span class="keyword">public</span> <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title function_">sendSMS</span><span class="params">()</span> <span class="keyword">throws</span> Exception &#123;        System.out.println(<span class="string">&quot;------sendSMS&quot;</span>);    &#125;    <span class="keyword">public</span> <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title function_">sendEmail</span><span class="params">()</span> <span class="keyword">throws</span> Exception &#123;        System.out.println(<span class="string">&quot;------sendEmail&quot;</span>);    &#125;&#125;<span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Lock_8</span> &#123;    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception &#123;        <span class="type">Phone</span> <span class="variable">phone</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Phone</span>();        <span class="keyword">new</span> <span class="title class_">Thread</span>(() -&gt; &#123;            <span class="keyword">try</span> &#123;                phone.sendSMS();            &#125; <span class="keyword">catch</span> (Exception e) &#123;                e.printStackTrace();            &#125;        &#125;, <span class="string">&quot;AA&quot;</span>).start();        Thread.sleep(<span class="number">100</span>);        <span class="keyword">new</span> <span class="title class_">Thread</span>(() -&gt; &#123;            <span class="keyword">try</span> &#123;                phone.sendEmail();            &#125; <span class="keyword">catch</span> (Exception e) &#123;                e.printStackTrace();            &#125;        &#125;, <span class="string">&quot;BB&quot;</span>).start();    &#125;&#125;</code></pre><p>打印结果：</p><pre><code class="highlight shell">------sendSMS------sendEmail</code></pre><p>分析：两个方法都加了 synchronized 关键字，因为是同一个对象调用，所有是同一把锁，按照顺序执行。</p></li><li><p>停4秒在短信方法内，先打印短信还是邮件</p><pre><code class="highlight java"><span class="keyword">class</span> <span class="title class_">Phone</span> &#123;    <span class="keyword">public</span> <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title function_">sendSMS</span><span class="params">()</span> <span class="keyword">throws</span> Exception &#123;        <span class="comment">//停留4秒</span>        TimeUnit.SECONDS.sleep(<span class="number">4</span>);        System.out.println(<span class="string">&quot;------sendSMS&quot;</span>);    &#125;    <span class="keyword">public</span> <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title function_">sendEmail</span><span class="params">()</span> <span class="keyword">throws</span> Exception &#123;        System.out.println(<span class="string">&quot;------sendEmail&quot;</span>);    &#125;&#125;<span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Lock_8</span> &#123;    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception &#123;        <span class="type">Phone</span> <span class="variable">phone</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Phone</span>();        <span class="keyword">new</span> <span class="title class_">Thread</span>(() -&gt; &#123;            <span class="keyword">try</span> &#123;                phone.sendSMS();            &#125; <span class="keyword">catch</span> (Exception e) &#123;                e.printStackTrace();            &#125;        &#125;, <span class="string">&quot;AA&quot;</span>).start();        Thread.sleep(<span class="number">100</span>);        <span class="keyword">new</span> <span class="title class_">Thread</span>(() -&gt; &#123;            <span class="keyword">try</span> &#123;                phone.sendEmail();            &#125; <span class="keyword">catch</span> (Exception e) &#123;                e.printStackTrace();            &#125;        &#125;, <span class="string">&quot;BB&quot;</span>).start();    &#125;&#125;</code></pre><p>打印结果：</p><pre><code class="highlight shell">------sendSMS------sendEmail</code></pre><p>分析：两个方法都加了 synchronized 关键字，因为还是同一个对象调用，所有还是同一把锁，先拿到锁的方法执行结束后，另一个方法才能执行。</p></li><li><p>新增普通的hello方法，是先打短信还是hello</p><pre><code class="highlight java"><span class="keyword">class</span> <span class="title class_">Phone</span> &#123;    <span class="keyword">public</span> <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title function_">sendSMS</span><span class="params">()</span> <span class="keyword">throws</span> Exception &#123;        <span class="comment">//停留4秒</span>        TimeUnit.SECONDS.sleep(<span class="number">4</span>);        System.out.println(<span class="string">&quot;------sendSMS&quot;</span>);    &#125;    <span class="keyword">public</span> <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title function_">sendEmail</span><span class="params">()</span> <span class="keyword">throws</span> Exception &#123;        System.out.println(<span class="string">&quot;------sendEmail&quot;</span>);    &#125;    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">getHello</span><span class="params">()</span> &#123;        System.out.println(<span class="string">&quot;------getHello&quot;</span>);    &#125;&#125;<span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Lock_8</span> &#123;    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception &#123;        <span class="type">Phone</span> <span class="variable">phone</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Phone</span>();        <span class="keyword">new</span> <span class="title class_">Thread</span>(() -&gt; &#123;            <span class="keyword">try</span> &#123;                phone.sendSMS();            &#125; <span class="keyword">catch</span> (Exception e) &#123;                e.printStackTrace();            &#125;        &#125;, <span class="string">&quot;AA&quot;</span>).start();        Thread.sleep(<span class="number">100</span>);        <span class="keyword">new</span> <span class="title class_">Thread</span>(() -&gt; &#123;            <span class="keyword">try</span> &#123;                phone.getHello();            &#125; <span class="keyword">catch</span> (Exception e) &#123;                e.printStackTrace();            &#125;        &#125;, <span class="string">&quot;BB&quot;</span>).start();    &#125;&#125;</code></pre><p>打印结果：</p><pre><code class="highlight shell">------getHello------sendSMS</code></pre><p>分析：hello方法没有加锁，调用即执行，sendSMS有sleep阻塞。</p></li><li><p>现在有两部手机，先打印短信还是邮件</p><pre><code class="highlight java"><span class="keyword">class</span> <span class="title class_">Phone</span> &#123;    <span class="keyword">public</span> <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title function_">sendSMS</span><span class="params">()</span> <span class="keyword">throws</span> Exception &#123;        <span class="comment">//停留4秒</span>        TimeUnit.SECONDS.sleep(<span class="number">4</span>);        System.out.println(<span class="string">&quot;------sendSMS&quot;</span>);    &#125;    <span class="keyword">public</span> <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title function_">sendEmail</span><span class="params">()</span> <span class="keyword">throws</span> Exception &#123;        System.out.println(<span class="string">&quot;------sendEmail&quot;</span>);    &#125;&#125;<span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Lock_8</span> &#123;    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception &#123;        <span class="type">Phone</span> <span class="variable">phone</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Phone</span>();        <span class="type">Phone</span> <span class="variable">phone2</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Phone</span>();        <span class="keyword">new</span> <span class="title class_">Thread</span>(() -&gt; &#123;            <span class="keyword">try</span> &#123;                phone.sendSMS();            &#125; <span class="keyword">catch</span> (Exception e) &#123;                e.printStackTrace();            &#125;        &#125;, <span class="string">&quot;AA&quot;</span>).start();        Thread.sleep(<span class="number">100</span>);        <span class="keyword">new</span> <span class="title class_">Thread</span>(() -&gt; &#123;            <span class="keyword">try</span> &#123;                phone2.sendEmail();            &#125; <span class="keyword">catch</span> (Exception e) &#123;                e.printStackTrace();            &#125;        &#125;, <span class="string">&quot;BB&quot;</span>).start();    &#125;&#125;</code></pre><p>打印结果：</p><pre><code class="highlight shell">------sendEmail------sendSMS</code></pre><p>分析：synchronized 在方法上，是方法级的锁，由于是两个 phone 对象调用不同的方法，所以 sendSMS() 和 sendEmail() 持有的是不同的锁，互不影响。</p></li><li><p>两个静态同步方法，1部手机，先打印短信还是邮件</p><pre><code class="highlight java"><span class="keyword">class</span> <span class="title class_">Phone</span> &#123;    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title function_">sendSMS</span><span class="params">()</span> <span class="keyword">throws</span> Exception &#123;        <span class="comment">//停留4秒</span>        TimeUnit.SECONDS.sleep(<span class="number">4</span>);        System.out.println(<span class="string">&quot;------sendSMS&quot;</span>);    &#125;    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title function_">sendEmail</span><span class="params">()</span> <span class="keyword">throws</span> Exception &#123;        System.out.println(<span class="string">&quot;------sendEmail&quot;</span>);    &#125;&#125;<span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Lock_8</span> &#123;    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception &#123;        <span class="type">Phone</span> <span class="variable">phone</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Phone</span>();                <span class="keyword">new</span> <span class="title class_">Thread</span>(() -&gt; &#123;            <span class="keyword">try</span> &#123;                phone.sendSMS();            &#125; <span class="keyword">catch</span> (Exception e) &#123;                e.printStackTrace();            &#125;        &#125;, <span class="string">&quot;AA&quot;</span>).start();        Thread.sleep(<span class="number">100</span>);        <span class="keyword">new</span> <span class="title class_">Thread</span>(() -&gt; &#123;            <span class="keyword">try</span> &#123;                phone.sendEmail();            &#125; <span class="keyword">catch</span> (Exception e) &#123;                e.printStackTrace();            &#125;        &#125;, <span class="string">&quot;BB&quot;</span>).start();    &#125;&#125;</code></pre><p>打印结果：</p><pre><code class="highlight shell">------sendSMS------sendEmail</code></pre><p>分析：synchronized 在静态方法上，是类级别的锁，所以两个方法持有的是同一把锁，要按顺序执行</p></li><li><p>两个静态同步方法，2部手机，先打印短信还是邮件</p><pre><code class="highlight java"><span class="keyword">class</span> <span class="title class_">Phone</span> &#123;    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title function_">sendSMS</span><span class="params">()</span> <span class="keyword">throws</span> Exception &#123;        <span class="comment">//停留4秒</span>        TimeUnit.SECONDS.sleep(<span class="number">4</span>);        System.out.println(<span class="string">&quot;------sendSMS&quot;</span>);    &#125;    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title function_">sendEmail</span><span class="params">()</span> <span class="keyword">throws</span> Exception &#123;        System.out.println(<span class="string">&quot;------sendEmail&quot;</span>);    &#125;&#125;<span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Lock_8</span> &#123;    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception &#123;        <span class="type">Phone</span> <span class="variable">phone</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Phone</span>();        <span class="type">Phone</span> <span class="variable">phone2</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Phone</span>();        <span class="keyword">new</span> <span class="title class_">Thread</span>(() -&gt; &#123;            <span class="keyword">try</span> &#123;                phone.sendSMS();            &#125; <span class="keyword">catch</span> (Exception e) &#123;                e.printStackTrace();            &#125;        &#125;, <span class="string">&quot;AA&quot;</span>).start();        Thread.sleep(<span class="number">100</span>);        <span class="keyword">new</span> <span class="title class_">Thread</span>(() -&gt; &#123;            <span class="keyword">try</span> &#123;                phone2.sendEmail();            &#125; <span class="keyword">catch</span> (Exception e) &#123;                e.printStackTrace();            &#125;        &#125;, <span class="string">&quot;BB&quot;</span>).start();    &#125;&#125;</code></pre><p>打印结果：</p><pre><code class="highlight shell">------sendSMS------sendEmail</code></pre><p>分析：synchronized 在静态方法上，是类级别的锁，所以两个方法持有的是同一把锁，要按顺序执行</p></li><li><p>1个静态同步方法,1个普通同步方法，1部手机，先打印短信还是邮件</p><pre><code class="highlight java"><span class="keyword">class</span> <span class="title class_">Phone</span> &#123;    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title function_">sendSMS</span><span class="params">()</span> <span class="keyword">throws</span> Exception &#123;        <span class="comment">//停留4秒</span>        TimeUnit.SECONDS.sleep(<span class="number">4</span>);        System.out.println(<span class="string">&quot;------sendSMS&quot;</span>);    &#125;    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">getHello</span><span class="params">()</span> &#123;        System.out.println(<span class="string">&quot;------getHello&quot;</span>);    &#125;&#125;<span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Lock_8</span> &#123;    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception &#123;        <span class="type">Phone</span> <span class="variable">phone</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Phone</span>();        <span class="keyword">new</span> <span class="title class_">Thread</span>(() -&gt; &#123;            <span class="keyword">try</span> &#123;                phone.sendSMS();            &#125; <span class="keyword">catch</span> (Exception e) &#123;                e.printStackTrace();            &#125;        &#125;, <span class="string">&quot;AA&quot;</span>).start();        Thread.sleep(<span class="number">100</span>);        <span class="keyword">new</span> <span class="title class_">Thread</span>(() -&gt; &#123;            <span class="keyword">try</span> &#123;                phone.getHello();            &#125; <span class="keyword">catch</span> (Exception e) &#123;                e.printStackTrace();            &#125;        &#125;, <span class="string">&quot;BB&quot;</span>).start();    &#125;&#125;</code></pre><p>打印结果：</p><pre><code class="highlight shell">------getHello------sendSMS</code></pre><p>分析：类加锁对普通方法无限制，普通方法调用即执行。</p></li><li><p>1个静态同步方法,1个普通同步方法，2部手机，先打印短信还是邮件</p><pre><code class="highlight java"><span class="keyword">class</span> <span class="title class_">Phone</span> &#123;    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title function_">sendSMS</span><span class="params">()</span> <span class="keyword">throws</span> Exception &#123;        <span class="comment">//停留4秒</span>        TimeUnit.SECONDS.sleep(<span class="number">4</span>);        System.out.println(<span class="string">&quot;------sendSMS&quot;</span>);    &#125;    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">sendEmail</span><span class="params">()</span> <span class="keyword">throws</span> Exception &#123;        System.out.println(<span class="string">&quot;------sendEmail&quot;</span>);    &#125;&#125;<span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Lock_8</span> &#123;    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception &#123;        <span class="type">Phone</span> <span class="variable">phone</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Phone</span>();        <span class="type">Phone</span> <span class="variable">phone2</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Phone</span>();        <span class="keyword">new</span> <span class="title class_">Thread</span>(() -&gt; &#123;            <span class="keyword">try</span> &#123;                phone.sendSMS();            &#125; <span class="keyword">catch</span> (Exception e) &#123;                e.printStackTrace();            &#125;        &#125;, <span class="string">&quot;AA&quot;</span>).start();        Thread.sleep(<span class="number">100</span>);        <span class="keyword">new</span> <span class="title class_">Thread</span>(() -&gt; &#123;            <span class="keyword">try</span> &#123;                phone2.sendEmail();            &#125; <span class="keyword">catch</span> (Exception e) &#123;                e.printStackTrace();            &#125;        &#125;, <span class="string">&quot;BB&quot;</span>).start();    &#125;&#125;</code></pre><p>打印结果：</p><pre><code class="highlight shell">------sendEmail------sendSMS</code></pre><p>分析：类加锁对普通方法无限制，普通方法调用即执行。</p></li></ol><p><strong>总结：</strong></p><ul><li>synchronized 锁的是方法，则是对象锁，同个对象锁的机制要等待，不同对象锁的机制调用同一个不用等待</li><li>加了static则为class锁而不是对象锁</li><li>对于同步方法块，锁是 synchronized 括号里配置对象</li></ul><h1 id="二、公平锁和非公平锁"><a href="#二、公平锁和非公平锁" class="headerlink" title="二、公平锁和非公平锁"></a>二、公平锁和非公平锁</h1><ul><li><strong>公平锁</strong>：效率相对低 ，但是cpu 的利用高了</li><li><strong>非公平锁</strong>：效率高，但是线程容易饿死（所有的工作，有一个线程完成）</li></ul><p><strong>用法：</strong> 在创建可重入锁时，向构造器中传入true</p><pre><code class="highlight java"><span class="keyword">private</span> <span class="keyword">final</span> <span class="type">ReentrantLock</span> <span class="variable">lock</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ReentrantLock</span>(<span class="literal">true</span>);</code></pre><p>因为 ReentrantLock 的构造器源码如下：</p><pre><code class="highlight java"><span class="comment">/**</span><span class="comment"> * Creates an instance of &#123;<span class="doctag">@code</span> ReentrantLock&#125;.</span><span class="comment"> * This is equivalent to using &#123;<span class="doctag">@code</span> ReentrantLock(false)&#125;.</span><span class="comment"> */</span><span class="keyword">public</span> <span class="title function_">ReentrantLock</span><span class="params">()</span> &#123;    sync = <span class="keyword">new</span> <span class="title class_">NonfairSync</span>();&#125;<span class="comment">/**</span><span class="comment"> * Creates an instance of &#123;<span class="doctag">@code</span> ReentrantLock&#125; with the</span><span class="comment"> * given fairness policy.</span><span class="comment"> *</span><span class="comment"> * <span class="doctag">@param</span> fair &#123;<span class="doctag">@code</span> true&#125; if this lock should use a fair ordering policy</span><span class="comment"> */</span><span class="keyword">public</span> <span class="title function_">ReentrantLock</span><span class="params">(<span class="type">boolean</span> fair)</span> &#123;    sync = fair ? <span class="keyword">new</span> <span class="title class_">FairSync</span>() : <span class="keyword">new</span> <span class="title class_">NonfairSync</span>();&#125;</code></pre><h1 id="三、可重入锁"><a href="#三、可重入锁" class="headerlink" title="三、可重入锁"></a>三、可重入锁</h1><p><code>synchronized</code> 和 <code>lock</code> 都是可重入锁</p><ul><li>sychronized是隐式锁，不用手工上锁与解锁，而lock为显示锁，需要手工上锁与解锁</li><li>可重入锁也叫递归锁</li></ul><p>而且有了可重入锁之后，在拿到外层的第一把锁之后就可以一直进入到内层结构</p><p><strong>嵌套实现代码 他能进入下一个锁内而不会出现死锁</strong></p><p><strong>synchronized的示例代码</strong></p><pre><code class="highlight java"><span class="comment">/**</span><span class="comment"> * 演示可重入锁是什么意思，可重入，就是可以重复获取相同的锁而不会出现死锁</span><span class="comment"> * synchronized和ReentrantLock都是可重入的</span><span class="comment"> * */</span><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">WhatReentrantSynchronized</span> &#123;    <span class="comment">// 创建一个锁对象</span>    <span class="keyword">static</span> <span class="type">Object</span> <span class="variable">mylock</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Object</span>();    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;        <span class="keyword">new</span> <span class="title class_">Thread</span>(()-&gt;&#123;            <span class="comment">// 创建第一个锁</span>            <span class="keyword">synchronized</span> (mylock)&#123;                System.out.println(<span class="string">&quot;这是第一层锁&quot;</span>);                <span class="keyword">synchronized</span> (mylock)&#123;                    System.out.println(<span class="string">&quot;这是第二层锁&quot;</span>);                &#125;            &#125;        &#125;).start();    &#125;&#125;</code></pre><p>打印结果：</p><pre><code class="highlight shell">这是第一层锁这是第二层锁</code></pre><p><strong>ReentrantLock的示例代码</strong></p><pre><code class="highlight java"><span class="comment">/**</span><span class="comment"> * lock和unlock的数量必须一致，否则会出现死锁</span><span class="comment"> * */</span><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">WhatReentrantLock</span> &#123;    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;        <span class="type">ReentrantLock</span> <span class="variable">lock</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ReentrantLock</span>();        <span class="keyword">new</span> <span class="title class_">Thread</span>(() -&gt; &#123;            lock.lock();            <span class="keyword">try</span> &#123;                System.out.println(Thread.currentThread().getName() + <span class="string">&quot; 获取到第一把锁&quot;</span>);                lock.lock();                <span class="keyword">try</span> &#123;                    System.out.println(Thread.currentThread().getName() + <span class="string">&quot; 获取到第二把锁&quot;</span>);                &#125; <span class="keyword">finally</span> &#123;                    lock.unlock();                &#125;            &#125; <span class="keyword">finally</span> &#123;                lock.unlock();            &#125;        &#125;).start();    &#125;&#125;</code></pre><p><strong>打印结果</strong></p><pre><code class="highlight shell">Thread-0 获取到第一把锁Thread-0 获取到第二把锁</code></pre><h1 id="四、死锁"><a href="#四、死锁" class="headerlink" title="四、死锁"></a>四、死锁</h1><p><strong>两个或以上的进程因为争夺资源而造成互相等待资源的现象称为死锁</strong></p><p><img src="https://raw.githubusercontent.com/GeorgeChan95/blogimg/master/img/2024/09/06/20240906-093325.png" alt="死锁"></p><p><strong>产生死锁的原因：</strong></p><ol><li>系统资源不足</li><li>系统资源分配不当</li><li>进程运行顺序不当</li></ol><p><strong>我们有时候不知道是否是死锁 。那么怎么来验证呢？ （电脑配置的有环境变量，在命令窗口）</strong></p><ol><li>jps 类似于linux中的 <code>ps -ef</code>查看进程号</li><li>jstack 自带的堆栈跟踪工具</li></ol><p><strong>具体死锁的操作代码实列</strong></p><pre><code class="highlight java"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">DeadLock</span> &#123;    <span class="comment">//创建两个对象</span>    <span class="keyword">static</span> <span class="type">Object</span> <span class="variable">a</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Object</span>();    <span class="keyword">static</span> <span class="type">Object</span> <span class="variable">b</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Object</span>();    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;        <span class="keyword">new</span> <span class="title class_">Thread</span>(()-&gt;&#123;            <span class="keyword">synchronized</span> (a) &#123;                System.out.println(Thread.currentThread().getName()+<span class="string">&quot; 持有锁a，试图获取锁b&quot;</span>);                <span class="keyword">try</span> &#123;                    TimeUnit.SECONDS.sleep(<span class="number">1</span>);                &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;                    e.printStackTrace();                &#125;                <span class="keyword">synchronized</span> (b) &#123;                    System.out.println(Thread.currentThread().getName()+<span class="string">&quot; 获取锁b&quot;</span>);                &#125;            &#125;        &#125;,<span class="string">&quot;A&quot;</span>).start();        <span class="keyword">new</span> <span class="title class_">Thread</span>(()-&gt;&#123;            <span class="keyword">synchronized</span> (b) &#123;                System.out.println(Thread.currentThread().getName()+<span class="string">&quot; 持有锁b，试图获取锁a&quot;</span>);                <span class="keyword">try</span> &#123;                    TimeUnit.SECONDS.sleep(<span class="number">1</span>);                &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;                    e.printStackTrace();                &#125;                <span class="keyword">synchronized</span> (a) &#123;                    System.out.println(Thread.currentThread().getName()+<span class="string">&quot; 获取锁a&quot;</span>);                &#125;            &#125;        &#125;,<span class="string">&quot;B&quot;</span>).start();    &#125;&#125;</code></pre><p>运行程序，结果如下：</p><pre><code class="highlight shell">A 持有锁a，试图获取锁bB 持有锁b，试图获取锁a</code></pre><p>程序处于暂停状态</p><p><strong>使用 jstack 查看线程的情况</strong></p><pre><code class="highlight shell">PS E:\testWorkspace\juc-demo&gt; jps -l 69860 sun.tools.jps.Jps51436 com.atguigu.sync.DeadLock<span class="meta prompt_"># </span><span class="language-bash">当前执行的线程是 51436</span><span class="meta prompt_"></span><span class="meta prompt_"># </span><span class="language-bash">使用jstack 查看线程信息</span>PS E:\testWorkspace\juc-demo&gt; jstack 514362024-09-06 09:48:06Full thread dump Java HotSpot(TM) 64-Bit Server VM (17.0.11+7-LTS-207 mixed mode, sharing):Threads class SMR info:_java_thread_list=0x000001f8fc26e0c0, length=15, elements=&#123;0x000001f8b9f86ff0, 0x000001f8b9f87e70, 0x000001f8b9f9b8c0, 0x000001f8b9f9f2a0,0x000001f8b9f9fc60, 0x000001f8b9fa1630, 0x000001f8b9fa23d0, 0x000001f8b9fb37d0,0x000001f8b9fabf10, 0x000001f8b9f75300, 0x000001f8fc278d40, 0x000001f8fc279220,0x000001f8fc296e80, 0x000001f8fc29c1b0, 0x000001f88d7a7660&#125;&quot;Reference Handler&quot; #2 daemon prio=10 os_prio=2 cpu=0.00ms elapsed=196.10s tid=0x000001f8b9f86ff0 nid=0x10408 waiting on condition  [0x0000006af2dff000]   java.lang.Thread.State: RUNNABLE        at java.lang.ref.Reference.waitForReferencePendingList(java.base@17.0.11/Native Method)        at java.lang.ref.Reference.processPendingReferences(java.base@17.0.11/Reference.java:253)        at java.lang.ref.Reference$ReferenceHandler.run(java.base@17.0.11/Reference.java:215)&quot;Finalizer&quot; #3 daemon prio=8 os_prio=1 cpu=0.00ms elapsed=196.10s tid=0x000001f8b9f87e70 nid=0x9508 in Object.wait()  [0x0000006af2eff000]   java.lang.Thread.State: WAITING (on object monitor)        at java.lang.Object.wait(java.base@17.0.11/Native Method)        - waiting on &lt;0x000000062280d5d0&gt; (a java.lang.ref.ReferenceQueue$Lock)        at java.lang.ref.ReferenceQueue.remove(java.base@17.0.11/ReferenceQueue.java:155)        - locked &lt;0x000000062280d5d0&gt; (a java.lang.ref.ReferenceQueue$Lock)        at java.lang.ref.ReferenceQueue.remove(java.base@17.0.11/ReferenceQueue.java:176)        at java.lang.ref.Finalizer$FinalizerThread.run(java.base@17.0.11/Finalizer.java:172)&quot;Signal Dispatcher&quot; #4 daemon prio=9 os_prio=2 cpu=0.00ms elapsed=196.09s tid=0x000001f8b9f9b8c0 nid=0x11780 waiting on condition  [0x0000000000000000]   java.lang.Thread.State: RUNNABLE&quot;Attach Listener&quot; #5 daemon prio=5 os_prio=2 cpu=0.00ms elapsed=196.09s tid=0x000001f8b9f9f2a0 nid=0x11468 waiting on condition  [0x0000000000000000]   java.lang.Thread.State: RUNNABLE&quot;Service Thread&quot; #6 daemon prio=9 os_prio=0 cpu=0.00ms elapsed=196.09s tid=0x000001f8b9f9fc60 nid=0x10d90 runnable  [0x0000000000000000]   java.lang.Thread.State: RUNNABLE&quot;Monitor Deflation Thread&quot; #7 daemon prio=9 os_prio=0 cpu=0.00ms elapsed=196.09s tid=0x000001f8b9fa1630 nid=0x116e0 runnable  [0x0000000000000000]   java.lang.Thread.State: RUNNABLE&quot;C2 CompilerThread0&quot; #8 daemon prio=9 os_prio=2 cpu=0.00ms elapsed=196.09s tid=0x000001f8b9fa23d0 nid=0xb2f8 waiting on condition  [0x0000000000000000]   java.lang.Thread.State: RUNNABLE   No compile task&quot;C1 CompilerThread0&quot; #16 daemon prio=9 os_prio=2 cpu=0.00ms elapsed=196.09s tid=0x000001f8b9fb37d0 nid=0x11040 waiting on condition  [0x0000000000000000]   java.lang.Thread.State: RUNNABLE   No compile task&quot;Sweeper thread&quot; #20 daemon prio=9 os_prio=2 cpu=0.00ms elapsed=196.09s tid=0x000001f8b9fabf10 nid=0x11170 runnable  [0x0000000000000000]   java.lang.Thread.State: RUNNABLE&quot;Common-Cleaner&quot; #21 daemon prio=8 os_prio=1 cpu=0.00ms elapsed=196.09s tid=0x000001f8b9f75300 nid=0x10a7c in Object.wait()  [0x0000006af36fe000]   java.lang.Thread.State: TIMED_WAITING (on object monitor)        at java.lang.Object.wait(java.base@17.0.11/Native Method)        - waiting on &lt;0x00000006229199a8&gt; (a java.lang.ref.ReferenceQueue$Lock)        at java.lang.ref.ReferenceQueue.remove(java.base@17.0.11/ReferenceQueue.java:155)        - locked &lt;0x00000006229199a8&gt; (a java.lang.ref.ReferenceQueue$Lock)        at jdk.internal.ref.CleanerImpl.run(java.base@17.0.11/CleanerImpl.java:140)        at java.lang.Thread.run(java.base@17.0.11/Thread.java:842)        at jdk.internal.misc.InnocuousThread.run(java.base@17.0.11/InnocuousThread.java:162)&quot;Monitor Ctrl-Break&quot; #22 daemon prio=5 os_prio=0 cpu=0.00ms elapsed=196.07s tid=0x000001f8fc278d40 nid=0x11118 runnable  [0x0000006af3bfe000]   java.lang.Thread.State: RUNNABLE        at sun.nio.ch.SocketDispatcher.read0(java.base@17.0.11/Native Method)        at sun.nio.ch.SocketDispatcher.read(java.base@17.0.11/SocketDispatcher.java:46)        at sun.nio.ch.NioSocketImpl.tryRead(java.base@17.0.11/NioSocketImpl.java:266)        at sun.nio.ch.NioSocketImpl.implRead(java.base@17.0.11/NioSocketImpl.java:317)        at sun.nio.ch.NioSocketImpl.read(java.base@17.0.11/NioSocketImpl.java:355)        at sun.nio.ch.NioSocketImpl$1.read(java.base@17.0.11/NioSocketImpl.java:808)        at java.net.Socket$SocketInputStream.read(java.base@17.0.11/Socket.java:966)        at sun.nio.cs.StreamDecoder.readBytes(java.base@17.0.11/StreamDecoder.java:270)        at sun.nio.cs.StreamDecoder.implRead(java.base@17.0.11/StreamDecoder.java:313)        at sun.nio.cs.StreamDecoder.read(java.base@17.0.11/StreamDecoder.java:188)        - locked &lt;0x0000000622afa510&gt; (a java.io.InputStreamReader)        at java.io.InputStreamReader.read(java.base@17.0.11/InputStreamReader.java:177)        at java.io.BufferedReader.fill(java.base@17.0.11/BufferedReader.java:162)        at java.io.BufferedReader.readLine(java.base@17.0.11/BufferedReader.java:329)        - locked &lt;0x0000000622afa510&gt; (a java.io.InputStreamReader)        at java.io.BufferedReader.readLine(java.base@17.0.11/BufferedReader.java:396)        at com.intellij.rt.execution.application.AppMainV2$1.run(AppMainV2.java:53)&quot;Notification Thread&quot; #23 daemon prio=9 os_prio=0 cpu=0.00ms elapsed=196.07s tid=0x000001f8fc279220 nid=0xbde4 runnable  [0x0000000000000000]   java.lang.Thread.State: RUNNABLE&quot;A&quot; #24 prio=5 os_prio=0 cpu=0.00ms elapsed=196.07s tid=0x000001f8fc296e80 nid=0x10308 waiting for monitor entry  [0x0000006af3eff000]   java.lang.Thread.State: BLOCKED (on object monitor)        at com.atguigu.sync.DeadLock.lambda$main$0(DeadLock.java:24)        - waiting to lock &lt;0x0000000622b5ee98&gt; (a java.lang.Object)        - locked &lt;0x0000000622b5ee88&gt; (a java.lang.Object)        at com.atguigu.sync.DeadLock$$Lambda$14/0x000001f8bc001200.run(Unknown Source)        at java.lang.Thread.run(java.base@17.0.11/Thread.java:842)&quot;B&quot; #25 prio=5 os_prio=0 cpu=0.00ms elapsed=196.07s tid=0x000001f8fc29c1b0 nid=0xf378 waiting for monitor entry  [0x0000006af3ffe000]   java.lang.Thread.State: BLOCKED (on object monitor)        at com.atguigu.sync.DeadLock.lambda$main$1(DeadLock.java:38)        - waiting to lock &lt;0x0000000622b5ee88&gt; (a java.lang.Object)        - locked &lt;0x0000000622b5ee98&gt; (a java.lang.Object)        at com.atguigu.sync.DeadLock$$Lambda$15/0x000001f8bc001418.run(Unknown Source)        at java.lang.Thread.run(java.base@17.0.11/Thread.java:842)&quot;DestroyJavaVM&quot; #26 prio=5 os_prio=0 cpu=0.00ms elapsed=196.07s tid=0x000001f88d7a7660 nid=0x5df0 waiting on condition  [0x0000000000000000]   java.lang.Thread.State: RUNNABLE&quot;VM Thread&quot; os_prio=2 cpu=0.00ms elapsed=196.10s tid=0x000001f8b9f813d0 nid=0x1157c runnable&quot;GC Thread#0&quot; os_prio=2 cpu=0.00ms elapsed=196.12s tid=0x000001f88d854e60 nid=0xe388 runnable&quot;G1 Main Marker&quot; os_prio=2 cpu=0.00ms elapsed=196.11s tid=0x000001f88d865c40 nid=0x111a8 runnable&quot;G1 Conc#0&quot; os_prio=2 cpu=0.00ms elapsed=196.11s tid=0x000001f88d866650 nid=0x8228 runnable&quot;G1 Refine#0&quot; os_prio=2 cpu=0.00ms elapsed=196.11s tid=0x000001f8b9ebd4d0 nid=0x4888 runnable&quot;G1 Service&quot; os_prio=2 cpu=0.00ms elapsed=196.11s tid=0x000001f8b9ebdf00 nid=0x80b4 runnable&quot;VM Periodic Task Thread&quot; os_prio=2 cpu=0.00ms elapsed=196.07s tid=0x000001f8b9ddc390 nid=0x11520 waiting on conditionJNI global refs: 23, weak refs: 0Found one Java-level deadlock:=============================&quot;A&quot;:  waiting to lock monitor 0x000001f8fc29f130 (object 0x0000000622b5ee98, a java.lang.Object),  which is held by &quot;B&quot;&quot;B&quot;:  waiting to lock monitor 0x000001f8fc2a00f0 (object 0x0000000622b5ee88, a java.lang.Object),  which is held by &quot;A&quot;Java stack information for the threads listed above:===================================================&quot;A&quot;:        at com.atguigu.sync.DeadLock.lambda$main$0(DeadLock.java:24)        - waiting to lock &lt;0x0000000622b5ee98&gt; (a java.lang.Object)        - locked &lt;0x0000000622b5ee88&gt; (a java.lang.Object)        at com.atguigu.sync.DeadLock$$Lambda$14/0x000001f8bc001200.run(Unknown Source)        at java.lang.Thread.run(java.base@17.0.11/Thread.java:842)&quot;B&quot;:        at com.atguigu.sync.DeadLock.lambda$main$1(DeadLock.java:38)        - waiting to lock &lt;0x0000000622b5ee88&gt; (a java.lang.Object)        - locked &lt;0x0000000622b5ee98&gt; (a java.lang.Object)        at com.atguigu.sync.DeadLock$$Lambda$15/0x000001f8bc001418.run(Unknown Source)        at java.lang.Thread.run(java.base@17.0.11/Thread.java:842)Found 1 deadlock.</code></pre><p>从 jstack 打印的日志可以看出，发生了死锁</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;一、synchronized-锁的8种情况&quot;&gt;&lt;a href=&quot;#一、synchronized-锁的8种情况&quot; class=&quot;headerlink&quot; title=&quot;一、synchronized 锁的8种情况&quot;&gt;&lt;/a&gt;一、synchronized 锁的8种情况&lt;/</summary>
      
    
    
    
    <category term="JUC" scheme="https://georgechan95.github.io/categories/JUC/"/>
    
    
    <category term="juc" scheme="https://georgechan95.github.io/tags/juc/"/>
    
    <category term="java" scheme="https://georgechan95.github.io/tags/java/"/>
    
  </entry>
  
  <entry>
    <title>04-集合的线程安全</title>
    <link href="https://georgechan95.github.io/blog/9a09d992.html"/>
    <id>https://georgechan95.github.io/blog/9a09d992.html</id>
    <published>2024-09-04T13:09:05.000Z</published>
    <updated>2024-09-06T01:07:26.519Z</updated>
    
    <content type="html"><![CDATA[<h1 id="一、ArrayList线程安全的操作"><a href="#一、ArrayList线程安全的操作" class="headerlink" title="一、ArrayList线程安全的操作"></a>一、ArrayList线程安全的操作</h1><h2 id="1-集合不安全的演示"><a href="#1-集合不安全的演示" class="headerlink" title="1. 集合不安全的演示"></a>1. 集合不安全的演示</h2><pre><code class="highlight java"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">NotSafeDemo</span> &#123;    <span class="comment">/**</span><span class="comment">     * 多个线程同时对集合进行修改</span><span class="comment">     * <span class="doctag">@param</span> args</span><span class="comment">     */</span>    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;        <span class="type">List</span> <span class="variable">list</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ArrayList</span>();        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; <span class="number">100</span>; i++) &#123;            <span class="keyword">new</span> <span class="title class_">Thread</span>(() -&gt;&#123;                list.add(UUID.randomUUID().toString());                System.out.println(list);            &#125;, <span class="string">&quot;线程&quot;</span> + i).start();        &#125;    &#125;&#125;</code></pre><p><strong>运行结果：</strong></p><pre><code class="highlight shell">Exception in thread &quot;线程93&quot; java.util.ConcurrentModificationExceptionat java.base/java.util.ArrayList$Itr.checkForComodification(ArrayList.java:1013)at java.base/java.util.ArrayList$Itr.next(ArrayList.java:967)at java.base/java.util.AbstractCollection.toString(AbstractCollection.java:456)at java.base/java.lang.String.valueOf(String.java:4222)at java.base/java.io.PrintStream.println(PrintStream.java:1047)</code></pre><p><strong>ArrayList add() 方法原码</strong></p><pre><code class="highlight java"><span class="comment">/**</span><span class="comment"> * Appends the specified element to the end of this list.</span><span class="comment"> *</span><span class="comment"> * <span class="doctag">@param</span> e element to be appended to this list</span><span class="comment"> * <span class="doctag">@return</span> &#123;<span class="doctag">@code</span> true&#125; (as specified by &#123;<span class="doctag">@link</span> Collection#add&#125;)</span><span class="comment"> */</span><span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">add</span><span class="params">(E e)</span> &#123;    modCount++;    add(e, elementData, size);    <span class="keyword">return</span> <span class="literal">true</span>;&#125;</code></pre><p>add() 方法没有加锁，是不安全的操作。</p><p><strong>如何去解决 List 类型的线程安全问题?</strong></p><h2 id="2-Vector"><a href="#2-Vector" class="headerlink" title="2. Vector"></a>2. Vector</h2><p>Vector 是<strong>矢量队列</strong>，它是 JDK1.0 版本添加的类。继承于 AbstractList，实现了 List, RandomAccess, Cloneable 这些接口。 Vector 继承了 AbstractList，实现了 List；所以，<strong>它是一个队列，支持相关的添加、删除、修改、遍历等功能</strong>。 Vector 实现了 RandmoAccess 接口，即<strong>提供了随机访问功能</strong>。RandmoAccess 是 java 中用来被 List 实现，为 List 提供快速访问功能的。在Vector 中，我们即可以通过元素的序号快速获取元素对象；这就是快速随机访问。 Vector 实现了 Cloneable 接口，即实现 clone()函数。它能被克隆。</p><p><strong>和 ArrayList 不同，Vector 中的操作是线程安全的。</strong></p><p>使用 <strong>Vector</strong> 对 Demo 进行修改</p><pre><code class="highlight java"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">VectorDemo</span> &#123;    <span class="comment">/**</span><span class="comment">     * 多个线程同时对集合进行修改</span><span class="comment">     * <span class="doctag">@param</span> args</span><span class="comment">     */</span>    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;        <span class="type">List</span> <span class="variable">list</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Vector</span>();        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; <span class="number">100</span>; i++) &#123;            <span class="keyword">new</span> <span class="title class_">Thread</span>(() -&gt;&#123;                list.add(UUID.randomUUID().toString());                System.out.println(list);            &#125;, <span class="string">&quot;线程&quot;</span> + i).start();        &#125;    &#125;&#125;</code></pre><p><strong>运行结果：无异常</strong></p><p>查看Vector add() 方法</p><pre><code class="highlight java"><span class="comment">/**</span><span class="comment"> * Appends the specified element to the end of this Vector.</span><span class="comment"> *</span><span class="comment"> * <span class="doctag">@param</span> e element to be appended to this Vector</span><span class="comment"> * <span class="doctag">@return</span> &#123;<span class="doctag">@code</span> true&#125; (as specified by &#123;<span class="doctag">@link</span> Collection#add&#125;)</span><span class="comment"> * <span class="doctag">@since</span> 1.2</span><span class="comment"> */</span><span class="keyword">public</span> <span class="keyword">synchronized</span> <span class="type">boolean</span> <span class="title function_">add</span><span class="params">(E e)</span> &#123;    modCount++;    add(e, elementData, elementCount);    <span class="keyword">return</span> <span class="literal">true</span>;&#125;</code></pre><p><code>add()</code> 方法添加了 <code>synchronized</code> 这是线程安全的操作。</p><h2 id="3-Collections"><a href="#3-Collections" class="headerlink" title="3. Collections"></a>3. Collections</h2><p>Collections 提供了方法 synchronizedList 保证 list 是同步线程安全的。</p><pre><code class="highlight java"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">CollectionsDemo</span> &#123;    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;        List&lt;Object&gt; list = Collections.synchronizedList(<span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;());        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; <span class="number">100</span>; i++) &#123;            <span class="keyword">new</span> <span class="title class_">Thread</span>(() -&gt;&#123;                list.add(UUID.randomUUID().toString());                System.out.println(list);            &#125;, <span class="string">&quot;线程&quot;</span> + i).start();        &#125;    &#125;&#125;</code></pre><p><strong>运行结果：没有异常</strong></p><p><strong>查看原码：</strong></p><pre><code class="highlight java"><span class="comment">/**</span><span class="comment"> * Returns a synchronized (thread-safe) list backed by the specified</span><span class="comment"> * list.  In order to guarantee serial access, it is critical that</span><span class="comment"> * &lt;strong&gt;all&lt;/strong&gt; access to the backing list is accomplished</span><span class="comment"> * through the returned list.&lt;p&gt;</span><span class="comment"> *</span><span class="comment"> * It is imperative that the user manually synchronize on the returned</span><span class="comment"> * list when traversing it via &#123;<span class="doctag">@link</span> Iterator&#125;, &#123;<span class="doctag">@link</span> Spliterator&#125;</span><span class="comment"> * or &#123;<span class="doctag">@link</span> Stream&#125;:</span><span class="comment"> * &lt;pre&gt;</span><span class="comment"> *  List list = Collections.synchronizedList(new ArrayList());</span><span class="comment"> *      ...</span><span class="comment"> *  synchronized (list) &#123;</span><span class="comment"> *      Iterator i = list.iterator(); // Must be in synchronized block</span><span class="comment"> *      while (i.hasNext())</span><span class="comment"> *          foo(i.next());</span><span class="comment"> *  &#125;</span><span class="comment"> * &lt;/pre&gt;</span><span class="comment"> * Failure to follow this advice may result in non-deterministic behavior.</span><span class="comment"> *</span><span class="comment"> * &lt;p&gt;The returned list will be serializable if the specified list is</span><span class="comment"> * serializable.</span><span class="comment"> *</span><span class="comment"> * <span class="doctag">@param</span>  &lt;T&gt; the class of the objects in the list</span><span class="comment"> * <span class="doctag">@param</span>  list the list to be &quot;wrapped&quot; in a synchronized list.</span><span class="comment"> * <span class="doctag">@return</span> a synchronized view of the specified list.</span><span class="comment"> */</span><span class="keyword">public</span> <span class="keyword">static</span> &lt;T&gt; List&lt;T&gt; <span class="title function_">synchronizedList</span><span class="params">(List&lt;T&gt; list)</span> &#123;    <span class="keyword">return</span> (list <span class="keyword">instanceof</span> RandomAccess ?            <span class="keyword">new</span> <span class="title class_">SynchronizedRandomAccessList</span>&lt;&gt;(list) :            <span class="keyword">new</span> <span class="title class_">SynchronizedList</span>&lt;&gt;(list));&#125;</code></pre><h2 id="4-CopyOnWriteArrayList-重点"><a href="#4-CopyOnWriteArrayList-重点" class="headerlink" title="4. CopyOnWriteArrayList (重点)"></a>4. CopyOnWriteArrayList (重点)</h2><p>CopyOnWriteArrayList 是线程安全的 ArrayList，具有以下特性：</p><ul><li>它最适合于具有以下特征的应用程序：List 大小通常保持很小，只读操作远多于可变操作，需要在遍历期间防止线程间的冲突。</li><li>它是线程安全的。</li><li>因为通常需要复制整个基础数组，所以可变操作（add()、set() 和 remove() 等等）的开销很大</li><li>迭代器支持 hasNext(), next()等不可变操作，但不支持可变 remove()等操作。</li><li>使用迭代器进行遍历的速度很快，并且不会与其他线程发生冲突。在构造迭代器时，迭代器依赖于不变的数组快照。</li></ul><p>当我们往一个容器添加元素的时候，不直接往当前容器添加，而是先将当前容器进行 Copy，复制出一个新的容器，然后新的容器里添加元素，添加完元素之后，再将原容器的引用指向新的容器。</p><p><strong>这时候会抛出来一个新的问题，也就是数据不一致的问题。如果写线程还没来得及写完并切换引用，其他的线程就会读到了脏数据</strong></p><p><strong>代码示例</strong></p><pre><code class="highlight java"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">CopyOnWriteArrayListDemo</span> &#123;    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;        CopyOnWriteArrayList&lt;String&gt; list = <span class="keyword">new</span> <span class="title class_">CopyOnWriteArrayList</span>&lt;&gt;();        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; <span class="number">100</span>; i++) &#123;            <span class="keyword">new</span> <span class="title class_">Thread</span>(() -&gt;&#123;                list.add(UUID.randomUUID().toString());                System.out.println(list);            &#125;, <span class="string">&quot;线程&quot;</span> + i).start();        &#125;    &#125;&#125;</code></pre><p>运行结果：没有线程安全问题</p><p>下面从“动态数组”和“线程安全”两个方面进一步对CopyOnWriteArrayList 的原理进行说明。</p><ul><li><strong>“动态数组”机制</strong><ul><li>它内部有个“volatile 数组”(array)来保持数据。在“添加&#x2F;修改&#x2F;删除”数据时，都会新建一个数组，并将更新后的数据拷贝到新建的数组中，最后再将该数组赋值给“volatile 数组”, 这就是它叫做 CopyOnWriteArrayList 的原因</li><li><strong>由于它在“添加&#x2F;修改&#x2F;删除”数据时，都会新建数组，所以涉及到修改数据的操作，CopyOnWriteArrayList 效率很低；但是单单只是进行遍历查找的话，效率比较高。</strong></li></ul></li><li><strong>“线程安全”机制</strong><ul><li>通过 volatile 和互斥锁来实现的。</li><li>通过“volatile 数组”来保存数据的。一个线程读取 volatile 数组时，总能看到其它线程对该 volatile 变量最后的写入；就这样，通过 volatile 提供了“读取到的数据总是最新的”这个机制的保证。</li><li>通过互斥锁来保护数据。在“添加&#x2F;修改&#x2F;删除”数据时，会先“获取互斥锁”，再修改完毕之后，先将数据更新到 “volatile 数组” 中，然后再 “释放互斥锁”，就达到了保护数据的目的。</li></ul></li></ul><h1 id="二、HashSet-线程安全的操作"><a href="#二、HashSet-线程安全的操作" class="headerlink" title="二、HashSet 线程安全的操作"></a>二、HashSet 线程安全的操作</h1><p>解决方案 CopyOnWriteArraySet</p><pre><code class="highlight java"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">CopyOnWriteArraySetDemo</span> &#123;    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;        <span class="comment">// 线程不安全的操作</span><span class="comment">//        HashSet&lt;String&gt; set = new HashSet&lt;&gt;();</span>        <span class="comment">// 线程安全的操作</span>        CopyOnWriteArraySet&lt;String&gt; set = <span class="keyword">new</span> <span class="title class_">CopyOnWriteArraySet</span>&lt;&gt;();        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; <span class="number">1000</span>; i++) &#123;            <span class="keyword">new</span> <span class="title class_">Thread</span>(() -&gt;&#123;                set.add(UUID.randomUUID().toString());                System.out.println(set);            &#125;, <span class="string">&quot;线程&quot;</span> + i).start();        &#125;    &#125;&#125;</code></pre><h1 id="三、HashMap-线程安全的操作"><a href="#三、HashMap-线程安全的操作" class="headerlink" title="三、HashMap 线程安全的操作"></a>三、HashMap 线程安全的操作</h1><p>解决方案 ConcurrentHashMap</p><pre><code class="highlight java"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ConcurrentHashMapDemo</span> &#123;    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;        <span class="comment">// 线程不安全的操作</span><span class="comment">//        HashMap&lt;String, String&gt; map = new HashMap&lt;&gt;();</span>        <span class="comment">// 线程安全的操作</span>        ConcurrentHashMap&lt;String, String&gt; map = <span class="keyword">new</span> <span class="title class_">ConcurrentHashMap</span>&lt;&gt;();        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; <span class="number">1000</span>; i++) &#123;            <span class="keyword">new</span> <span class="title class_">Thread</span>(() -&gt;&#123;                map.put(UUID.randomUUID().toString(), <span class="string">&quot;1&quot;</span>);                System.out.println(map.values());            &#125;, <span class="string">&quot;线程&quot;</span> + i).start();        &#125;    &#125;&#125;</code></pre>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;一、ArrayList线程安全的操作&quot;&gt;&lt;a href=&quot;#一、ArrayList线程安全的操作&quot; class=&quot;headerlink&quot; title=&quot;一、ArrayList线程安全的操作&quot;&gt;&lt;/a&gt;一、ArrayList线程安全的操作&lt;/h1&gt;&lt;h2 id=&quot;1</summary>
      
    
    
    
    <category term="JUC" scheme="https://georgechan95.github.io/categories/JUC/"/>
    
    
    <category term="juc" scheme="https://georgechan95.github.io/tags/juc/"/>
    
    <category term="java" scheme="https://georgechan95.github.io/tags/java/"/>
    
  </entry>
  
  <entry>
    <title>03-线程间通信</title>
    <link href="https://georgechan95.github.io/blog/bd2134da.html"/>
    <id>https://georgechan95.github.io/blog/bd2134da.html</id>
    <published>2024-09-04T12:06:00.000Z</published>
    <updated>2024-09-04T00:31:04.024Z</updated>
    
    <content type="html"><![CDATA[<h1 id="一、线程间通信"><a href="#一、线程间通信" class="headerlink" title="一、线程间通信"></a>一、线程间通信</h1><p>线程间通信的模型有两种：共享内存和消息传递，以下方式都是基本这两种模型来实现的。我们来基本一道面试常见的题目来分析</p><p><strong>场景—两个线程，一个线程对当前数值加 1，另一个线程对当前数值减 1,要求用线程间通信</strong></p><h2 id="1-synchronized-方案"><a href="#1-synchronized-方案" class="headerlink" title="1. synchronized 方案"></a>1. synchronized 方案</h2><pre><code class="highlight java"><span class="keyword">class</span> <span class="title class_">TestVolatile</span> &#123;    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;        <span class="type">DemoClass</span> <span class="variable">demoClass</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">DemoClass</span>();        <span class="keyword">new</span> <span class="title class_">Thread</span>(() -&gt; &#123;            <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; <span class="number">10</span>; i++) &#123;                <span class="keyword">try</span> &#123;                    demoClass.increment();                &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;                    <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">RuntimeException</span>(e);                &#125;            &#125;        &#125;, <span class="string">&quot;线程A&quot;</span>).start();        <span class="keyword">new</span> <span class="title class_">Thread</span>(() -&gt; &#123;            <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; <span class="number">10</span>; i++) &#123;                <span class="keyword">try</span> &#123;                    demoClass.decrement();                &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;                    <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">RuntimeException</span>(e);                &#125;            &#125;        &#125;, <span class="string">&quot;线程B&quot;</span>).start();    &#125;&#125;<span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">DemoClass</span> &#123;    <span class="keyword">private</span> <span class="type">int</span> <span class="variable">number</span> <span class="operator">=</span> <span class="number">0</span>;    <span class="keyword">public</span> <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title function_">increment</span><span class="params">()</span> <span class="keyword">throws</span> InterruptedException &#123;        <span class="keyword">while</span> (number != <span class="number">0</span>) &#123;            <span class="built_in">this</span>.wait();        &#125;        number++;        System.out.println(Thread.currentThread().getName() + <span class="string">&quot;执行了加1操作，当前值为：&quot;</span> + number);        notifyAll();    &#125;    <span class="keyword">public</span> <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title function_">decrement</span><span class="params">()</span> <span class="keyword">throws</span> InterruptedException &#123;        <span class="keyword">while</span> (number != <span class="number">1</span>) &#123;            <span class="built_in">this</span>.wait();        &#125;        number--;        System.out.println(Thread.currentThread().getName() + <span class="string">&quot;执行了减1操作，当前值为：&quot;</span> + number);        notifyAll();    &#125;&#125;</code></pre><h2 id="2-Lock-方案"><a href="#2-Lock-方案" class="headerlink" title="2. Lock 方案"></a>2. Lock 方案</h2><pre><code class="highlight java"><span class="keyword">class</span> <span class="title class_">ShareNum</span> &#123;    <span class="keyword">private</span> <span class="type">int</span> <span class="variable">number</span> <span class="operator">=</span> <span class="number">0</span>;    <span class="keyword">private</span> <span class="type">ReentrantLock</span> <span class="variable">lock</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ReentrantLock</span>(<span class="literal">true</span>);    <span class="keyword">private</span> <span class="type">Condition</span> <span class="variable">condition</span> <span class="operator">=</span> lock.newCondition();    <span class="comment">// ++操作</span>    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">increase</span><span class="params">()</span> &#123;        <span class="comment">// 上锁</span>        lock.lock();        <span class="keyword">try</span> &#123;            <span class="keyword">while</span> (number != <span class="number">0</span>) &#123;                condition.await();            &#125;            <span class="comment">// 执行 ++ 操作</span>            number++;            System.out.println(Thread.currentThread().getName() + <span class="string">&quot;执行了 ++ 操作，当前number值为：&quot;</span> + number);            <span class="comment">// 唤醒其它线程</span>            condition.signalAll();        &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;            <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">RuntimeException</span>(e);        &#125; <span class="keyword">finally</span> &#123;            <span class="comment">// 解锁</span>            lock.unlock();        &#125;    &#125;    <span class="comment">// -- 操作</span>    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">decrease</span><span class="params">()</span> &#123;        <span class="comment">// 上锁</span>        lock.lock();        <span class="keyword">try</span> &#123;            <span class="keyword">while</span> (number != <span class="number">1</span>) &#123;                condition.await();            &#125;            <span class="comment">// 执行 -- 操作</span>            number--;            System.out.println(Thread.currentThread().getName() + <span class="string">&quot;执行了 -- 操作，当前number值为：&quot;</span> + number);            <span class="comment">// 唤醒其它线程</span>            condition.signalAll();        &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;            <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">RuntimeException</span>(e);        &#125; <span class="keyword">finally</span> &#123;            <span class="comment">// 解锁</span>            lock.unlock();        &#125;    &#125;&#125;<span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ConditionDemo</span> &#123;    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;        <span class="type">ShareNum</span> <span class="variable">shareNum</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ShareNum</span>();        <span class="keyword">new</span> <span class="title class_">Thread</span>(() -&gt; &#123;            <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; <span class="number">10</span>; i++) &#123;                shareNum.increase();            &#125;        &#125;, <span class="string">&quot;AA&quot;</span>).start();        <span class="keyword">new</span> <span class="title class_">Thread</span>(() -&gt; &#123;            <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; <span class="number">10</span>; i++) &#123;                shareNum.decrease();            &#125;        &#125;, <span class="string">&quot;BB&quot;</span>).start();        <span class="keyword">new</span> <span class="title class_">Thread</span>(() -&gt; &#123;            <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; <span class="number">10</span>; i++) &#123;                shareNum.increase();            &#125;        &#125;, <span class="string">&quot;CC&quot;</span>).start();        <span class="keyword">new</span> <span class="title class_">Thread</span>(() -&gt; &#123;            <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; <span class="number">10</span>; i++) &#123;                shareNum.decrease();            &#125;        &#125;, <span class="string">&quot;DD&quot;</span>).start();    &#125;&#125;</code></pre><h1 id="二、线程间定制化通信"><a href="#二、线程间定制化通信" class="headerlink" title="二、线程间定制化通信"></a>二、线程间定制化通信</h1><h2 id="1-案例介绍"><a href="#1-案例介绍" class="headerlink" title="1. 案例介绍"></a>1. 案例介绍</h2><p><strong>A 线程打印 5 次 A，B 线程打印 10 次 B，C 线程打印 15 次 C,按照此顺序循环 10 轮</strong></p><h2 id="2-实现过程"><a href="#2-实现过程" class="headerlink" title="2. 实现过程"></a>2. 实现过程</h2><pre><code class="highlight java"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">PrintTest</span> &#123;    <span class="comment">// 线程通信标识：0-线程A  1-线程B  2-线程C</span>    <span class="keyword">private</span> <span class="type">int</span> <span class="variable">number</span> <span class="operator">=</span> <span class="number">0</span>;    <span class="comment">// 创建锁</span>    <span class="keyword">private</span> <span class="type">Lock</span> <span class="variable">lock</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ReentrantLock</span>();    <span class="comment">// 线程A的通信钥匙</span>    <span class="keyword">private</span> <span class="type">Condition</span> <span class="variable">conditionA</span> <span class="operator">=</span>lock.newCondition();    <span class="comment">// 线程B的通信钥匙</span>    <span class="keyword">private</span> <span class="type">Condition</span> <span class="variable">conditionB</span> <span class="operator">=</span>lock.newCondition();    <span class="comment">// 线程C的通信钥匙</span>    <span class="keyword">private</span> <span class="type">Condition</span> <span class="variable">conditionC</span> <span class="operator">=</span>lock.newCondition();    <span class="comment">/**</span><span class="comment">     * 打印五次A</span><span class="comment">     */</span>    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">printA</span><span class="params">(<span class="type">int</span> round)</span> &#123;        <span class="keyword">try</span> &#123;            lock.lock();            <span class="keyword">while</span> (number != <span class="number">0</span>) &#123;                conditionA.await(); <span class="comment">// 等待并释放锁</span>            &#125;            <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; <span class="number">5</span>; i++) &#123;                System.out.println(<span class="string">&quot;第 &quot;</span> + round + <span class="string">&quot;轮：&quot;</span> + Thread.currentThread().getName() + <span class="string">&quot;执行中，开始打印：=== A ===&quot;</span>);            &#125;            <span class="comment">// 打印B</span>            number = <span class="number">1</span>;            conditionB.signal();        &#125; <span class="keyword">catch</span> (Exception e) &#123;        &#125; <span class="keyword">finally</span> &#123;            lock.unlock();        &#125;    &#125;    <span class="comment">/**</span><span class="comment">     * 打印10次B</span><span class="comment">     */</span>    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">printB</span><span class="params">(<span class="type">int</span> round)</span> &#123;        <span class="keyword">try</span> &#123;            lock.lock();            <span class="keyword">while</span> (number != <span class="number">1</span>) &#123;                conditionB.await(); <span class="comment">// 等待并释放锁</span>            &#125;            <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; <span class="number">10</span>; i++) &#123;                System.out.println(<span class="string">&quot;第 &quot;</span> + round + <span class="string">&quot;轮：&quot;</span> + Thread.currentThread().getName() + <span class="string">&quot;执行中，开始打印：=== B ===&quot;</span>);            &#125;            <span class="comment">// 打印B</span>            number = <span class="number">2</span>;            conditionC.signal();        &#125; <span class="keyword">catch</span> (Exception e) &#123;        &#125; <span class="keyword">finally</span> &#123;            lock.unlock();        &#125;    &#125;    <span class="comment">/**</span><span class="comment">     * 打印15次C</span><span class="comment">     */</span>    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">printC</span><span class="params">(<span class="type">int</span> round)</span> &#123;        <span class="keyword">try</span> &#123;            lock.lock();            <span class="keyword">while</span> (number != <span class="number">2</span>) &#123;                conditionC.await(); <span class="comment">// 等待并释放锁</span>            &#125;            <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; <span class="number">15</span>; i++) &#123;                System.out.println(<span class="string">&quot;第 &quot;</span> + round + <span class="string">&quot;轮：&quot;</span> + Thread.currentThread().getName() + <span class="string">&quot;执行中，开始打印：=== C ===&quot;</span>);            &#125;            <span class="comment">// 打印B</span>            number = <span class="number">0</span>;            conditionA.signal();        &#125; <span class="keyword">catch</span> (Exception e) &#123;        &#125; <span class="keyword">finally</span> &#123;            lock.unlock();        &#125;    &#125;&#125;<span class="keyword">class</span> <span class="title class_">MainClass</span> &#123;    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;        <span class="type">PrintTest</span> <span class="variable">printTest</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">PrintTest</span>();        <span class="keyword">new</span> <span class="title class_">Thread</span>(() -&gt; &#123;            <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; <span class="number">10</span>; i++) &#123;                printTest.printA(i);            &#125;        &#125;, <span class="string">&quot;线程A&quot;</span>).start();        <span class="keyword">new</span> <span class="title class_">Thread</span>(() -&gt; &#123;            <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; <span class="number">10</span>; i++) &#123;                printTest.printB(i);            &#125;        &#125;, <span class="string">&quot;线程B&quot;</span>).start();        <span class="keyword">new</span> <span class="title class_">Thread</span>(() -&gt; &#123;            <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; <span class="number">10</span>; i++) &#123;                printTest.printC(i);            &#125;        &#125;, <span class="string">&quot;线程C&quot;</span>).start();    &#125;&#125;</code></pre>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;一、线程间通信&quot;&gt;&lt;a href=&quot;#一、线程间通信&quot; class=&quot;headerlink&quot; title=&quot;一、线程间通信&quot;&gt;&lt;/a&gt;一、线程间通信&lt;/h1&gt;&lt;p&gt;线程间通信的模型有两种：共享内存和消息传递，以下方式都是基本这两种模型来实现的。我们来基本一道面试常</summary>
      
    
    
    
    <category term="JUC" scheme="https://georgechan95.github.io/categories/JUC/"/>
    
    
    <category term="juc" scheme="https://georgechan95.github.io/tags/juc/"/>
    
    <category term="java" scheme="https://georgechan95.github.io/tags/java/"/>
    
  </entry>
  
  <entry>
    <title>02-Lock接口</title>
    <link href="https://georgechan95.github.io/blog/850dac3c.html"/>
    <id>https://georgechan95.github.io/blog/850dac3c.html</id>
    <published>2024-08-30T11:27:00.000Z</published>
    <updated>2024-09-03T23:45:00.212Z</updated>
    
    <content type="html"><![CDATA[<h1 id="一、Synchronized"><a href="#一、Synchronized" class="headerlink" title="一、Synchronized"></a>一、Synchronized</h1><h2 id="1-Synchronized-关键字回顾"><a href="#1-Synchronized-关键字回顾" class="headerlink" title="1. Synchronized 关键字回顾"></a>1. Synchronized 关键字回顾</h2><p>synchronized 是 Java 中的关键字，是一种同步锁。它修饰的对象有以下几种：</p><ul><li><p>修饰一个代码块，被修饰的代码块称为同步语句块，其作用的范围是 大括号{} 括起来的代码，作用的对象是调用这个代码块的对象；</p></li><li><p>修饰一个方法，被修饰的方法称为同步方法，其作用的范围是整个方法，作用的对象是调用这个方法的对象；</p><p>虽然可以使用 synchronized 来定义方法，但 synchronized 并不属于方法定义的一部分，因此，<strong>synchronized 关键字不能被继承</strong>。如果在父类中的某个方法使用了 synchronized 关键字，而在子类中覆盖了这个方法，在子类中的这个方法默认情况下并不是同步的，而必须显式地在子类的这个方法中加上synchronized 关键字才可以。当然，还可以在子类方法中调用父类中相应的方法，这样虽然子类中的方法不是同步的，但子类调用了父类的同步方法，因此，子类的方法也就相当于同步了。</p></li><li><p>修改一个静态的方法，其作用的范围是整个静态方法，作用的对象是这个类的所有对象；</p></li><li><p>修改一个类，其作用的范围是 synchronized 后面括号括起来的部分，作用主的对象是这个类的所有对象。</p></li></ul><h2 id="2-Synchronized案例"><a href="#2-Synchronized案例" class="headerlink" title="2. Synchronized案例"></a>2. Synchronized案例</h2><p>使用 synchronized 完成售票案例</p><pre><code class="highlight java"><span class="comment">//第一步  创建资源类，定义属性和和操作方法</span><span class="keyword">class</span> <span class="title class_">Ticket</span> &#123;    <span class="comment">//票数</span>    <span class="keyword">private</span> <span class="type">int</span> <span class="variable">number</span> <span class="operator">=</span> <span class="number">30</span>;    <span class="comment">//操作方法：卖票</span>    <span class="keyword">public</span> <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title function_">sale</span><span class="params">()</span> &#123;        <span class="comment">//判断：是否有票</span>        <span class="keyword">if</span>(number &gt; <span class="number">0</span>) &#123;            System.out.println(Thread.currentThread().getName()+<span class="string">&quot; : 卖出：&quot;</span>+(number--)+<span class="string">&quot; 剩下：&quot;</span>+number);        &#125;    &#125;&#125;<span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">SaleTicket</span> &#123;    <span class="comment">//第二步 创建多个线程，调用资源类的操作方法</span>    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;        <span class="comment">//创建Ticket对象</span>        <span class="type">Ticket</span> <span class="variable">ticket</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Ticket</span>();        <span class="comment">//创建三个线程</span>        <span class="keyword">new</span> <span class="title class_">Thread</span>(<span class="keyword">new</span> <span class="title class_">Runnable</span>() &#123;            <span class="meta">@Override</span>            <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span> &#123;                <span class="comment">//调用卖票方法</span>                <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; <span class="number">40</span>; i++) &#123;                    ticket.sale();                &#125;            &#125;        &#125;,<span class="string">&quot;AA&quot;</span>).start();        <span class="keyword">new</span> <span class="title class_">Thread</span>(<span class="keyword">new</span> <span class="title class_">Runnable</span>() &#123;            <span class="meta">@Override</span>            <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span> &#123;                <span class="comment">//调用卖票方法</span>                <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; <span class="number">40</span>; i++) &#123;                    ticket.sale();                &#125;            &#125;        &#125;,<span class="string">&quot;BB&quot;</span>).start();        <span class="keyword">new</span> <span class="title class_">Thread</span>(<span class="keyword">new</span> <span class="title class_">Runnable</span>() &#123;            <span class="meta">@Override</span>            <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span> &#123;                <span class="comment">//调用卖票方法</span>                <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; <span class="number">40</span>; i++) &#123;                    ticket.sale();                &#125;            &#125;        &#125;,<span class="string">&quot;CC&quot;</span>).start();    &#125;&#125;</code></pre><ul><li>注意：Synchronized 不是公平锁，所以执行这个程序有可能会出现某个线程把票卖完，而其它线程没有执行机会的情况</li></ul><p>如果一个代码块被 synchronized 修饰了，当一个线程获取了对应的锁，并执行该代码块时，其他线程便只能一直等待，等待获取锁的线程释放锁，而这里获取锁的线程释放锁只会有两种情况：</p><ul><li>获取锁的线程执行完了该代码块，然后线程释放对锁的占有；</li><li>线程执行发生异常，此时 JVM 会让线程自动释放锁</li></ul><p>那么如果这个获取锁的线程由于要等待 IO 或者其他原因（比如调用 sleep方法）被阻塞了，但是又没有释放锁，其他线程便只能干巴巴地等待，试想一下，这多么影响程序执行效率。因此就需要有一种机制可以不让等待的线程一直无期限地等待下去（比如只等待一定的时间或者能够响应中断），通过 Lock 就可以办到。</p><h1 id="二、Lock接口"><a href="#二、Lock接口" class="headerlink" title="二、Lock接口"></a>二、Lock接口</h1><p>Lock 锁实现提供了比使用同步方法和语句可以获得的更广泛的锁操作。它们允许更灵活的结构，可能具有非常不同的属性，并且可能支持多个关联的条件对象。Lock 提供了比 synchronized 更多的功能。</p><p>Lock 与的 Synchronized 区别：</p><ul><li>Lock 不是 Java 语言内置的，synchronized 是 Java 语言的关键字，因此是内置特性。Lock 是一个类，通过这个类可以实现同步访问；</li><li>Lock 和 synchronized 有一点非常大的不同，采用 synchronized 不需要用户去手动释放锁，当 synchronized 方法或者 synchronized 代码块执行完之后，系统会自动让线程释放对锁的占用；而 Lock 则必须要用户去手动释放锁，如果没有主动释放锁，就有可能导致出现死锁现象。</li></ul><h2 id="1-Lock-接口"><a href="#1-Lock-接口" class="headerlink" title="1. Lock 接口"></a>1. Lock 接口</h2><p>接口代码路径：<code>java.util.concurrent.locks.Lock</code></p><pre><code class="highlight java"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">Lock</span> &#123;    <span class="comment">/**</span><span class="comment">     * Acquires the lock.</span><span class="comment">     */</span>    <span class="keyword">void</span> <span class="title function_">lock</span><span class="params">()</span>;    <span class="comment">/**</span><span class="comment">     * Acquires the lock unless the current thread is</span><span class="comment">     * &#123;<span class="doctag">@linkplain</span> Thread#interrupt interrupted&#125;.</span><span class="comment">     */</span>    <span class="keyword">void</span> <span class="title function_">lockInterruptibly</span><span class="params">()</span> <span class="keyword">throws</span> InterruptedException;    <span class="comment">/**</span><span class="comment">     * Acquires the lock only if it is free at the time of invocation.</span><span class="comment">     */</span>    <span class="type">boolean</span> <span class="title function_">tryLock</span><span class="params">()</span>;    <span class="comment">/**</span><span class="comment">     * Acquires the lock if it is free within the given waiting time and the</span><span class="comment">     * current thread has not been &#123;<span class="doctag">@linkplain</span> Thread#interrupt interrupted&#125;.</span><span class="comment">     */</span>    <span class="type">boolean</span> <span class="title function_">tryLock</span><span class="params">(<span class="type">long</span> time, TimeUnit unit)</span> <span class="keyword">throws</span> InterruptedException;    <span class="comment">/**</span><span class="comment">     * Releases the lock.</span><span class="comment">     */</span>    <span class="keyword">void</span> <span class="title function_">unlock</span><span class="params">()</span>;    <span class="comment">/**</span><span class="comment">     * Returns a new &#123;<span class="doctag">@link</span> Condition&#125; instance that is bound to this</span><span class="comment">     */</span>    Condition <span class="title function_">newCondition</span><span class="params">()</span>;&#125;</code></pre><p>下面来逐个讲述 Lock 接口中每个方法的使用</p><h3 id="1-1-lock-方法"><a href="#1-1-lock-方法" class="headerlink" title="1.1 lock() 方法"></a>1.1 <code>lock()</code> 方法</h3><p>lock()方法是平常使用得最多的一个方法，就是用来获取锁。如果锁已被其他线程获取，则进行等待。</p><p>采用 Lock，必须主动去释放锁，并且在发生异常时，不会自动释放锁。因此一般来说，使用 Lock 必须在 <code>try&#123;&#125;catch&#123;&#125;</code> 块中进行，并且将释放锁的操作放在<code>finally</code> 块中进行，以保证锁一定被被释放，防止死锁的发生。通常使用 Lock来进行同步的话，是以下面这种形式去使用的：</p><pre><code class="highlight java">lock.lock();<span class="keyword">try</span> &#123;<span class="comment">//处理任务</span>&#125; <span class="keyword">catch</span> (Exception e) &#123;&#125; <span class="keyword">finally</span> &#123;    lock.unlock(); <span class="comment">//释放锁</span>&#125;</code></pre><p><strong>测试案例：买票</strong></p><p>三个售票员，同时卖30张票，不能超卖。</p><p>使用 <code>ReentrantLock</code></p><pre><code class="highlight java"><span class="comment">// 定义资源类、属性、方法</span><span class="keyword">class</span> <span class="title class_">LTickets</span> &#123;    <span class="comment">//票数量</span>    <span class="keyword">private</span> <span class="type">int</span> <span class="variable">num</span> <span class="operator">=</span> <span class="number">30</span>;    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">getNum</span><span class="params">()</span> &#123;        <span class="keyword">return</span> num;    &#125;    <span class="comment">// 创建可重入锁</span>    <span class="keyword">private</span> <span class="type">ReentrantLock</span> <span class="variable">lock</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ReentrantLock</span>(<span class="literal">true</span>);    <span class="comment">//卖票方法</span>    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">sale</span><span class="params">()</span> &#123;        <span class="comment">//上锁</span>        lock.lock();        <span class="keyword">try</span> &#123;            <span class="comment">// 判断是否还有票</span>            <span class="keyword">if</span> (num &gt; <span class="number">0</span>) &#123;                System.out.println(Thread.currentThread().getName() + <span class="string">&quot; 卖出1张票,还剩：&quot;</span> + --num +<span class="string">&quot; 张票&quot;</span>);            &#125;        &#125; <span class="keyword">finally</span> &#123;            <span class="comment">// 解锁</span>            lock.unlock();        &#125;    &#125;&#125;<span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ReentrantLockDemo</span> &#123;    <span class="comment">//第二步 创建多个线程，调用资源类的操作方法</span>    <span class="comment">//创建三个线程</span>    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;        <span class="type">LTickets</span> <span class="variable">lTickets</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">LTickets</span>();        <span class="keyword">new</span> <span class="title class_">Thread</span>(() -&gt; &#123;            <span class="keyword">while</span> (lTickets.getNum() &gt; <span class="number">0</span>) &#123;                lTickets.sale();            &#125;        &#125;, <span class="string">&quot;售票员1&quot;</span>).start();        <span class="keyword">new</span> <span class="title class_">Thread</span>(() -&gt; &#123;            <span class="keyword">while</span> (lTickets.getNum() &gt; <span class="number">0</span>) &#123;                lTickets.sale();            &#125;        &#125;, <span class="string">&quot;售票员2&quot;</span>).start();        <span class="keyword">new</span> <span class="title class_">Thread</span>(() -&gt; &#123;            <span class="keyword">while</span> (lTickets.getNum() &gt; <span class="number">0</span>) &#123;                lTickets.sale();            &#125;        &#125;, <span class="string">&quot;售票员3&quot;</span>).start();    &#125;&#125;</code></pre><p><strong>运行结果</strong></p><pre><code class="highlight txt">售票员1 卖出1张票,还剩：29 张票售票员2 卖出1张票,还剩：28 张票售票员3 卖出1张票,还剩：27 张票......售票员3 卖出1张票,还剩：3 张票售票员1 卖出1张票,还剩：2 张票售票员2 卖出1张票,还剩：1 张票售票员3 卖出1张票,还剩：0 张票</code></pre><h3 id="1-2-newCondition-方法"><a href="#1-2-newCondition-方法" class="headerlink" title="1.2 newCondition() 方法"></a>1.2 <code>newCondition()</code> 方法</h3><p>关键字 <code>synchronized</code> 与 <code>wait()</code> &#x2F; <code>notify()</code> 这两个方法一起使用可以实现等待&#x2F;通知模式， Lock 锁的 <code>newContition()</code> 方法返回 Condition 对象，Condition 类也可以实现等待&#x2F;通知模式。</p><p>用 <code>notify()</code> 通知时，JVM 会随机唤醒某个等待的线程， 使用 Condition 类可以进行选择性通知， Condition 比较常用的两个方法：</p><ul><li><code>await()</code> 会使当前线程等待,同时会释放锁,当其他线程调用 <code>signal()</code> 时,线程会重新获得锁并继续执行。</li><li><code>signal()</code> 用于唤醒一个等待的线程。</li></ul><p>注意：在调用 Condition 的 <code>await()/signal()</code> 方法前，也需要线程持有相关的 Lock 锁，调用 <code>await()</code> 后线程会释放这个锁，在 <code>singal()</code> 调用后会从当前Condition 对象的等待队列中，唤醒 一个线程，唤醒的线程尝试获得锁， 一旦获得锁成功就继续执行。</p><h4 id="测试案例"><a href="#测试案例" class="headerlink" title="测试案例"></a>测试案例</h4><p>当前有一个变量 number，初始值是0，创建四个线程同时修改次变量，线程AA、线程CC对变量做++操作， 线程BB、线程DD对变量做–操作。每个线程都执行10次</p><pre><code class="highlight java"><span class="keyword">class</span> <span class="title class_">ShareNum</span> &#123;    <span class="keyword">private</span> <span class="type">int</span> <span class="variable">number</span> <span class="operator">=</span> <span class="number">0</span>;    <span class="keyword">private</span> <span class="type">ReentrantLock</span> <span class="variable">lock</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ReentrantLock</span>(<span class="literal">true</span>);    <span class="keyword">private</span> <span class="type">Condition</span> <span class="variable">condition</span> <span class="operator">=</span> lock.newCondition();    <span class="comment">// ++操作</span>    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">increase</span><span class="params">()</span> &#123;        <span class="comment">// 上锁</span>        lock.lock();        <span class="keyword">try</span> &#123;            <span class="keyword">while</span> (number != <span class="number">0</span>) &#123;                condition.await();            &#125;            <span class="comment">// 执行 ++ 操作</span>            number++;            System.out.println(Thread.currentThread().getName() + <span class="string">&quot;执行了 ++ 操作，当前number值为：&quot;</span> + number);            <span class="comment">// 唤醒其它线程</span>            condition.signalAll();        &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;            <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">RuntimeException</span>(e);        &#125; <span class="keyword">finally</span> &#123;            <span class="comment">// 解锁</span>            lock.unlock();        &#125;    &#125;    <span class="comment">// -- 操作</span>    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">decrease</span><span class="params">()</span> &#123;        <span class="comment">// 上锁</span>        lock.lock();        <span class="keyword">try</span> &#123;            <span class="keyword">while</span> (number != <span class="number">1</span>) &#123;                condition.await();            &#125;            <span class="comment">// 执行 -- 操作</span>            number--;            System.out.println(Thread.currentThread().getName() + <span class="string">&quot;执行了 -- 操作，当前number值为：&quot;</span> + number);            <span class="comment">// 唤醒其它线程</span>            condition.signalAll();        &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;            <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">RuntimeException</span>(e);        &#125; <span class="keyword">finally</span> &#123;            <span class="comment">// 解锁</span>            lock.unlock();        &#125;    &#125;&#125;<span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ConditionDemo</span> &#123;    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;        <span class="type">ShareNum</span> <span class="variable">shareNum</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ShareNum</span>();        <span class="keyword">new</span> <span class="title class_">Thread</span>(() -&gt; &#123;            <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; <span class="number">10</span>; i++) &#123;                shareNum.increase();            &#125;        &#125;, <span class="string">&quot;AA&quot;</span>).start();        <span class="keyword">new</span> <span class="title class_">Thread</span>(() -&gt; &#123;            <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; <span class="number">10</span>; i++) &#123;                shareNum.decrease();            &#125;        &#125;, <span class="string">&quot;BB&quot;</span>).start();        <span class="keyword">new</span> <span class="title class_">Thread</span>(() -&gt; &#123;            <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; <span class="number">10</span>; i++) &#123;                shareNum.increase();            &#125;        &#125;, <span class="string">&quot;CC&quot;</span>).start();        <span class="keyword">new</span> <span class="title class_">Thread</span>(() -&gt; &#123;            <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; <span class="number">10</span>; i++) &#123;                shareNum.decrease();            &#125;        &#125;, <span class="string">&quot;DD&quot;</span>).start();    &#125;&#125;</code></pre><h1 id="三、ReentrantLock"><a href="#三、ReentrantLock" class="headerlink" title="三、ReentrantLock"></a>三、ReentrantLock</h1><p>重入锁简单来说一个线程可以重复获取锁资源，虽然ReentrantLock不像synchronized关键字一样支持隐式的重入锁，但是在调用lock方法时，它会判断当前尝试获取锁的线程，是否等于已经拥有锁的线程，如果成立则不会被阻塞。</p><p>还有ReentrantLock在创建的时候，可以通构造方法指定创建公平锁还是非公平锁。</p><h2 id="1-代码示例"><a href="#1-代码示例" class="headerlink" title="1.  代码示例"></a>1.  代码示例</h2><pre><code class="highlight java"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ReentrantLockTest</span> &#123;    <span class="keyword">private</span> ArrayList&lt;Integer&gt; arrayList = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> InterruptedException &#123;        <span class="keyword">final</span> <span class="type">ReentrantLockTest</span> <span class="variable">test</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ReentrantLockTest</span>();        <span class="comment">// 锁放在这里，保证两个线程使用的是同一把锁</span>        <span class="type">Lock</span> <span class="variable">lock</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ReentrantLock</span>(); <span class="comment">//注意这个地方</span>        <span class="keyword">new</span> <span class="title class_">Thread</span>(() -&gt; &#123;            test.insert(Thread.currentThread(), lock);        &#125;).start();        <span class="keyword">new</span> <span class="title class_">Thread</span>(() -&gt; &#123;            test.insert(Thread.currentThread(), lock);        &#125;).start();        Thread.sleep(<span class="number">1000</span>);    &#125;    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">insert</span><span class="params">(Thread thread, Lock lock)</span> &#123;        lock.lock();        <span class="keyword">try</span> &#123;            System.out.println(thread.getName()+<span class="string">&quot;得到了锁&quot;</span>);            <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;<span class="number">5</span>;i++) &#123;                arrayList.add(i);            &#125;        &#125; <span class="keyword">catch</span> (Exception e) &#123;            <span class="comment">// <span class="doctag">TODO:</span> handle exception</span>        &#125;<span class="keyword">finally</span> &#123;            System.out.println(thread.getName()+<span class="string">&quot;释放了锁&quot;</span>);            lock.unlock();        &#125;    &#125;    <span class="comment">/**</span><span class="comment">     * 计算总数</span><span class="comment">     */</span>    <span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">count</span><span class="params">()</span> &#123;        <span class="type">int</span> <span class="variable">size</span> <span class="operator">=</span> arrayList.size();        System.out.println(<span class="string">&quot;总数为：&quot;</span> + size);    &#125;&#125;</code></pre><p><strong>运行结果</strong></p><pre><code class="highlight shell">Thread-0得到了锁Thread-0释放了锁Thread-1得到了锁Thread-1释放了锁</code></pre><h1 id="四、ReadWriteLock-读写锁"><a href="#四、ReadWriteLock-读写锁" class="headerlink" title="四、ReadWriteLock 读写锁"></a>四、ReadWriteLock 读写锁</h1><h2 id="1-乐观锁和悲观锁"><a href="#1-乐观锁和悲观锁" class="headerlink" title="1. 乐观锁和悲观锁"></a>1. 乐观锁和悲观锁</h2><p><strong>悲观锁( synchronized 键字和 Lock 的实现类都是悲观锁)</strong></p><ul><li><p>什么是悲观锁？认为自己在使用数据的时候一定有别的线程来修改数据，因此在获取数据的时候会先加锁，确保数据不会被别的线程修改，这样别人想拿数据就被挡住，直到悲观锁被释放，悲观锁中的共享资源每次只给一个线程使用，其它线程阻塞，用完后再把资源转让给其它线程</p></li><li><p>但是在效率方面，处理加锁的机制会产生额外的开销，还有增加产生<strong>死锁</strong>的机会。另外还会降低并行性，如果已经锁定了一个线程A，其他线程就必须等待该线程A处理完才可以处理</p></li><li><p>悲观锁适合写操作多的场景，先加锁可以保证写操作时数据正确(写操作包括增删改)、显式的锁定之后再操作同步资源</p><p><code>synchronized</code>关键字和<code>Lock</code>的实现类都是悲观锁，<strong>数据库中的行锁，表锁，读锁(共享锁)，写锁(排他锁)，均为悲观锁，表锁会发生死锁，读锁和写锁都会发生死锁现象。</strong></p></li><li><p>悲观锁不支持并发</p></li></ul><p><img src="https://raw.githubusercontent.com/GeorgeChan95/blogimg/master/img/2024/09/03/20240903-195057.png" alt="悲观锁"></p><p><strong>乐观锁</strong></p><ul><li>概念：乐观锁认为自己在使用数据时不会有别的线程修改数据，所以不会添加锁，只是在更新数据的时候去判断之前有没有别的线程更新了这个数据。如果这个数据没有被更新,当前线程将自己修改的数据成功写入。如果数据已经被其他线程更新，则根据不同的实现方式执行不同的操作</li><li>乐观锁在Java中通过使用无锁编程来实现，最常采用的是CAS算法，Java原子类中的递增操作就通过CAS自旋实现的，适合读操作多的场景，不加锁的特点能够使其读操作的性能大幅度提升</li></ul><p><img src="https://raw.githubusercontent.com/GeorgeChan95/blogimg/master/img/2024/09/03/20240903-195152.png" alt="乐观锁"></p><p><strong>乐观锁一般有两种实现方式</strong></p><ul><li>采用版本号机制</li><li>CAS算法实现</li></ul><pre><code class="highlight java"><span class="comment">//悲观锁的调用方式</span><span class="keyword">public</span> <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title function_">m1</span><span class="params">()</span> &#123;    <span class="comment">//加锁后的业务逻辑</span>&#125;<span class="comment">//保证多个线程使用的是同一个lock对象的前提下</span><span class="type">ReetrantLock</span> <span class="variable">lock</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ReentrantLock</span>();<span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">m2</span><span class="params">()</span>&#123;    lock.lock();    <span class="keyword">try</span> &#123;        <span class="comment">//操作同步资源</span>    &#125; <span class="keyword">finally</span> &#123;        lock.unlock();    &#125;&#125;<span class="comment">//乐观锁的调用方式</span><span class="comment">//保证多个线程使用的是同一个AtomicInteger</span><span class="keyword">private</span>  AtomicInteger atomicIntege=<span class="keyword">new</span> <span class="title class_">AtomicInteger</span>();atomicIntege.incrementAndGet();</code></pre><h2 id="2-读写锁ReadWriteLock"><a href="#2-读写锁ReadWriteLock" class="headerlink" title="2. 读写锁ReadWriteLock"></a>2. 读写锁ReadWriteLock</h2><h3 id="2-1-读写锁概述"><a href="#2-1-读写锁概述" class="headerlink" title="2.1 读写锁概述"></a>2.1 读写锁概述</h3><p>我们开发中应该能够遇到这样的一种情况，对共享资源有读和写的操作，且写操作没有读操作那么频繁。在没有写操作的时候，多个线程同时读一个资源没有任何问题，所以应该<strong>允许多个线程同时读取共享资源</strong>；但是当一个<strong>写者线程在写这些共享资源时，就不允许其他线程进行访问</strong>。</p><p>读写锁实际是一种特殊的自旋锁，它把对共享资源的访问者划分成读者和写者，读者只对共享资源进行读访问，写者则需要对共享资源进行写操作。我们将读操作相关的锁，称为读锁，因为可以共享读，我们也称为“<strong>共享锁</strong>”，将写操作相关的锁，称为<strong>写锁、排他锁、独占锁</strong>。<strong>每次可以多个线程的读者进行读访问，但是一次只能由一个写者线程进行写操作，即写操作是独占式的。</strong></p><p>读写锁适合于对数据结构的读次数比写次数多得多的情况。因为读模式锁定时可以共享, 以写模式锁住时意味着独占, 所以读写锁又叫<strong>共享-独占锁</strong>。</p><h3 id="2-2-ReadWriteLock读写锁"><a href="#2-2-ReadWriteLock读写锁" class="headerlink" title="2.2 ReadWriteLock读写锁"></a>2.2 ReadWriteLock读写锁</h3><p>针对上面这种场景，Java的并发包下提供了读写锁 <code>ReadWriteLock</code>（接口） | <code>ReentrantReadWriteLock</code>（实现类）。</p><p><code>ReadWriteLock</code> 维护了一对相关的锁，一个用于只读操作， 另一个用于写入操作。<strong>只要没有 writer</strong>，<strong>读取锁可以由多个 reader 线程同时保持</strong>。写入锁是<strong>独占</strong>的。</p><pre><code class="highlight java"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">ReadWriteLock</span> &#123;<span class="comment">// 读锁</span>    Lock <span class="title function_">readLock</span><span class="params">()</span>;<span class="comment">// 写锁</span>    Lock <span class="title function_">writeLock</span><span class="params">()</span>;&#125;</code></pre><p>ReadWriteLock 读取操作通常不会改变共享资源，<strong>但执行写入操作时，必须独占方式来获取锁</strong>。</p><ul><li>对于读取操作占多数的数据结构。 <strong>ReadWriteLock 能提供比独占锁更高的并发性</strong>。</li><li>而对于只读的数据结构，其中包含的不变性可以完全不需要考虑加锁操作。</li><li>读&#x2F;写锁使用后都需要分别关闭，跟<code>Lock</code>最后也需要手动关闭是一样一样的。</li><li>ReadWriteLock是比<code>lock</code>锁更加细粒度的控制</li></ul><h3 id="2-3-ReentrantReadWriteLock实现类"><a href="#2-3-ReentrantReadWriteLock实现类" class="headerlink" title="2.3 ReentrantReadWriteLock实现类"></a>2.3 ReentrantReadWriteLock实现类</h3><p><code>ReentrantReadWriteLock</code>实现了<code>ReadWriteLock</code>接口，下面是它的源码</p><pre><code class="highlight java"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ReentrantReadWriteLock</span> <span class="keyword">implements</span> <span class="title class_">ReadWriteLock</span>,java.io.Serializable &#123;    <span class="comment">/** 读锁 */</span>    <span class="keyword">private</span> <span class="keyword">final</span> ReentrantReadWriteLock.ReadLock readerLock;    <span class="comment">/** 写锁 */</span>    <span class="keyword">private</span> <span class="keyword">final</span> ReentrantReadWriteLock.WriteLock writerLock;    <span class="keyword">final</span> Sync sync;    <span class="comment">/** 使用默认（非公平）的排序属性创建一个新的</span><span class="comment">ReentrantReadWriteLock */</span>    <span class="keyword">public</span> <span class="title function_">ReentrantReadWriteLock</span><span class="params">()</span> &#123;        <span class="built_in">this</span>(<span class="literal">false</span>);    &#125;    <span class="comment">/** 使用给定的公平策略创建一个新的 ReentrantReadWriteLock */</span>    <span class="keyword">public</span> <span class="title function_">ReentrantReadWriteLock</span><span class="params">(<span class="type">boolean</span> fair)</span> &#123;        sync = fair ? <span class="keyword">new</span> <span class="title class_">FairSync</span>() : <span class="keyword">new</span> <span class="title class_">NonfairSync</span>();        readerLock = <span class="keyword">new</span> <span class="title class_">ReadLock</span>(<span class="built_in">this</span>);        writerLock = <span class="keyword">new</span> <span class="title class_">WriteLock</span>(<span class="built_in">this</span>);    &#125;    <span class="comment">/** 返回用于写入操作的锁 */</span>    <span class="keyword">public</span> ReentrantReadWriteLock.WriteLock <span class="title function_">writeLock</span><span class="params">()</span> &#123; <span class="keyword">return</span>        writerLock; &#125;    <span class="comment">/** 返回用于读取操作的锁 */</span>    <span class="keyword">public</span> ReentrantReadWriteLock.ReadLock <span class="title function_">readLock</span><span class="params">()</span> &#123; <span class="keyword">return</span>        readerLock; &#125;    <span class="keyword">abstract</span> <span class="keyword">static</span> <span class="keyword">class</span> <span class="title class_">Sync</span> <span class="keyword">extends</span> <span class="title class_">AbstractQueuedSynchronizer</span> &#123;&#125;    <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">class</span> <span class="title class_">NonfairSync</span> <span class="keyword">extends</span> <span class="title class_">Sync</span> &#123;&#125;    <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">class</span> <span class="title class_">FairSync</span> <span class="keyword">extends</span> <span class="title class_">Sync</span> &#123;&#125;    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">class</span> <span class="title class_">ReadLock</span> <span class="keyword">implements</span> <span class="title class_">Lock</span>, java.io.Serializable &#123;&#125;    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">class</span> <span class="title class_">WriteLock</span> <span class="keyword">implements</span> <span class="title class_">Lock</span>, java.io.Serializable &#123;&#125;&#125;</code></pre><h3 id="2-4-读写锁注意点"><a href="#2-4-读写锁注意点" class="headerlink" title="2.4 读写锁注意点"></a>2.4 读写锁注意点</h3><p>当读写锁是<strong>写加锁状态</strong>时, 在这个锁被解锁之前, 所有试图对这个锁加锁的线程都会被阻塞</p><p>当读写锁在<strong>读加锁状态</strong>时，所有试图以读模式对它进行加锁的线程都可以得到访问权，但是如果线程希望以写模式对此锁进行加锁, 它必须直到所有的线程释放锁.</p><p><strong>线程想要进入读锁的前提条件：</strong></p><ul><li>不存在其他线程的写锁</li><li>没有写请求, 或者有写请求，但调用线程和持有锁的线程是同一个(可重入锁)</li></ul><p><strong>线程进入写锁的前提条件：</strong></p><ul><li>没有读者线程正在访问</li><li>没有其他写者线程正在访问</li></ul><p><strong>通常, 当读写锁处于读模式锁住状态时，如果有另外线程试图以写模式加锁，读写锁通常会阻塞随后的读模式锁请求，这样可以避免读模式锁长期占用，而等待的写模式锁请求长期阻塞</strong></p><h3 id="2-5-读写锁的特点"><a href="#2-5-读写锁的特点" class="headerlink" title="2.5 读写锁的特点"></a>2.5 读写锁的特点</h3><ul><li><strong>公平选择性：</strong><ul><li>非公平模式（默认）<ul><li>当以非公平初始化时，读锁和写锁的获取的顺序是不确定的。非公平锁主张竞争获取，可能会延缓一个或多个读或写线程，但是会比公平锁有更高的吞吐量。</li></ul></li><li>公平模式<ul><li>当以公平模式初始化时，线程将会以队列的顺序获取锁。当当前线程释放锁后，等待时间最长的写锁线程就会被分配写锁；或者有一组读线程组等待时间比写线程长，那么这组读线程组将会被分配读锁。</li><li>当有写线程持有写锁或者有等待的写线程时，一个尝试获取公平的读锁（非重入）的线程就会阻塞。这个线程直到等待时间最长的写锁获得锁后并释放掉锁后才能获取到读锁。</li></ul></li></ul></li><li><strong>可重入</strong><ul><li>读锁和写锁都支持线程重进入。但是写锁可以获得读锁，读锁不能获得写锁。因为读锁是共享的，写锁是独占式的。</li></ul></li><li><strong>锁降级</strong><ul><li>遵循获取写锁、获取读锁再释放写锁的次序，写锁能够降级成为读锁。</li></ul></li><li><strong>支持中断锁的获取</strong><ul><li>在读锁和写锁的获取过程中支持中断</li></ul></li><li><strong>监控</strong><ul><li>提供一些辅助方法，例如hasQueuedThreads方法查询是否有线程正在等待获取读锁或写锁、isWriteLocked方法查询写锁是否被任何线程持有等等</li></ul></li></ul><h3 id="2-6-案例演示"><a href="#2-6-案例演示" class="headerlink" title="2.6 案例演示"></a>2.6 案例演示</h3><p>场景：我们通过一个缓存的小案例来，在没有使用锁的情况下，实现存储和读取的功能，并通过在多个线程的并发下。：使用 ReentrantReadWriteLock 对一个 hashmap 集合进行读和写的并发操作</p><p><strong>volatile关键字</strong>：表示数据会不断发生变化，多个线程可见性，禁止指令重排序</p><blockquote><p>没有锁的情况</p></blockquote><pre><code class="highlight java"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ReentrantReadWriteLockDemo</span> &#123;    <span class="comment">//创建 map 集合</span>    <span class="keyword">private</span> <span class="keyword">volatile</span> Map&lt;String, Object&gt; map = <span class="keyword">new</span> <span class="title class_">HashMap</span>&lt;&gt;();    <span class="comment">//放数据</span>    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">put</span><span class="params">(String key, Object value)</span> &#123;        System.out.println(Thread.currentThread().getName() + <span class="string">&quot;正在写数据&quot;</span> + key);        <span class="comment">//放数据</span>        map.put(key, value);        System.out.println(Thread.currentThread().getName() + <span class="string">&quot;写完了&quot;</span> + key);    &#125;    <span class="comment">//取数据</span>    <span class="keyword">public</span> Object <span class="title function_">get</span><span class="params">(String key)</span> &#123;        <span class="type">Object</span> <span class="variable">result</span> <span class="operator">=</span> <span class="literal">null</span>;        System.out.println(Thread.currentThread().getName() + <span class="string">&quot;正在取数据&quot;</span> + key);        <span class="comment">//        TimeUnit.MICROSECONDS.sleep(300);</span>        result = map.get(key);        System.out.println(Thread.currentThread().getName() + <span class="string">&quot;取完数据了&quot;</span> + key);        <span class="keyword">return</span> result;    &#125;    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;        <span class="type">ReentrantReadWriteLockDemo</span> <span class="variable">demo</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ReentrantReadWriteLockDemo</span>();        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">1</span>; i &lt;= <span class="number">5</span>; i++) &#123;            <span class="keyword">final</span> <span class="type">int</span> <span class="variable">number</span> <span class="operator">=</span> i;            <span class="keyword">new</span> <span class="title class_">Thread</span>(() -&gt; &#123;<span class="comment">//5个线程放数据</span>                demo.put(String.valueOf(number), number);            &#125;, String.valueOf(i)).start();        &#125;        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">1</span>; i &lt;= <span class="number">5</span>; i++) &#123;            <span class="keyword">final</span> <span class="type">int</span> <span class="variable">number</span> <span class="operator">=</span> i;            <span class="keyword">new</span> <span class="title class_">Thread</span>(() -&gt; &#123;<span class="comment">//5个线程取数据</span>                demo.get(String.valueOf(number));            &#125;, String.valueOf(i)).start();        &#125;    &#125;&#125;</code></pre><p><strong>执行结果：</strong></p><pre><code class="highlight shell">1正在取数据12正在取数据24正在写数据43正在写数据33正在取数据32取完数据了24正在取数据41取完数据了14取完数据了42正在写数据23取完数据了34写完了41正在写数据13写完了32写完了25正在取数据51写完了15取完数据了55正在写数据55写完了5</code></pre><p>可以看出在一个写线程写数据的时候，有其他线程进入，这显然是不行的。</p><blockquote><p><strong>使用ReadWriteLock读&#x2F;写锁解决缓存并发问题</strong></p></blockquote><pre><code class="highlight java"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ReentrantReadWriteLockDemo</span> &#123;    <span class="comment">//创建 map 集合</span>    <span class="keyword">private</span> <span class="keyword">volatile</span> Map&lt;String, Object&gt; map = <span class="keyword">new</span> <span class="title class_">HashMap</span>&lt;&gt;();    <span class="comment">//创建读写锁对象</span>    <span class="keyword">private</span> <span class="type">ReadWriteLock</span> <span class="variable">rwLock</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ReentrantReadWriteLock</span>();    <span class="comment">//放数据</span>    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">put</span><span class="params">(String key, Object value)</span> &#123;        <span class="comment">//添加写锁</span>        rwLock.writeLock().lock();        <span class="keyword">try</span> &#123;            System.out.println(Thread.currentThread().getName() + <span class="string">&quot;正在写数据&quot;</span> + key);            <span class="comment">//暂停一会</span>            TimeUnit.MICROSECONDS.sleep(<span class="number">300</span>);            <span class="comment">//放数据</span>            map.put(key, value);            System.out.println(Thread.currentThread().getName() + <span class="string">&quot;写完了&quot;</span> + key);        &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;            e.printStackTrace();        &#125; <span class="keyword">finally</span> &#123;            <span class="comment">//释放写锁</span>            rwLock.writeLock().unlock();        &#125;    &#125;    <span class="comment">//取数据</span>    <span class="keyword">public</span> Object <span class="title function_">get</span><span class="params">(String key)</span> &#123;        <span class="comment">//添加读锁</span>        rwLock.readLock().lock();        <span class="type">Object</span> <span class="variable">result</span> <span class="operator">=</span> <span class="literal">null</span>;        <span class="keyword">try</span> &#123;            System.out.println(Thread.currentThread().getName() + <span class="string">&quot;正在取数据&quot;</span> + key);            <span class="comment">//暂停一会</span>            TimeUnit.MICROSECONDS.sleep(<span class="number">300</span>);            result = map.get(key);            System.out.println(Thread.currentThread().getName() + <span class="string">&quot;取完数据了&quot;</span> + key);        &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;            e.printStackTrace();        &#125; <span class="keyword">finally</span> &#123;            <span class="comment">//释放读锁</span>            rwLock.readLock().unlock();        &#125;        <span class="keyword">return</span> result;    &#125;    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;        <span class="type">ReentrantReadWriteLockDemo</span> <span class="variable">demo</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ReentrantReadWriteLockDemo</span>();        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">1</span>; i &lt;= <span class="number">5</span>; i++) &#123;            <span class="keyword">final</span> <span class="type">int</span> <span class="variable">number</span> <span class="operator">=</span> i;            <span class="keyword">new</span> <span class="title class_">Thread</span>(() -&gt; &#123;<span class="comment">//5个线程放数据</span>                demo.put(String.valueOf(number), number);            &#125;, String.valueOf(i)).start();        &#125;        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">1</span>; i &lt;= <span class="number">5</span>; i++) &#123;            <span class="keyword">final</span> <span class="type">int</span> <span class="variable">number</span> <span class="operator">=</span> i;            <span class="keyword">new</span> <span class="title class_">Thread</span>(() -&gt; &#123;<span class="comment">//5个线程取数据</span>                demo.get(String.valueOf(number));            &#125;, String.valueOf(i)).start();        &#125;    &#125;&#125;</code></pre><p><strong>执行结果：</strong></p><pre><code class="highlight shell">1正在写数据11写完了12正在写数据22写完了23正在写数据33写完了34正在写数据44写完了45正在写数据55写完了51正在取数据12正在取数据24正在取数据43正在取数据35正在取数据52取完数据了21取完数据了15取完数据了53取完数据了34取完数据了4</code></pre><p>从结果可以看出，写操作是唯一独占的，多个线程不能同时写，必须等一个线程写完了另外一个线程才能进去，而读的时候是共享的，多个线程可以一起读数据。</p><h3 id="2-7-总结-重点"><a href="#2-7-总结-重点" class="headerlink" title="2.7 总结(重点)"></a>2.7 总结(重点)</h3><p>与传统锁不同的是读写锁的规则是可以共享读，但只能一个写，即不能同时存在读写线程，总结起来为：读读不互斥，读写互斥，写写互斥。而一般的传统独占锁是：读读互斥，读写互斥，写写互斥，而场景中往往读远远大于写，读写锁就是为了这种优化而创建出来的一种机制。注意是读远远大于写，一般情况下独占锁的效率低来源于高并发下对临界区的激烈竞争导致线程上下文切换。因此当并发不是很高的情况下，读写锁由于需要额外维护读锁的状态，可能还不如独占锁的效率高。因此需要根据实际情况选择使用。</p><ul><li><strong>ReentrantReadWriteLock和Synchonized、ReentrantLock比较起来有哪些区别呢？或者有哪些优势呢？</strong></li><li>Synchonized、ReentrantLock是属于传统独占锁，读、写操作每次都只能是一个人访问，效率比较低。</li><li>而ReentrantReadWriteLock读操作可以共享，提升性能，允许多人一起读操作，而写操作还是每次一个人访问。</li><li>当然ReentrantReadWriteLock优势是有，但是也存在一些缺陷，容易造成<strong>锁饥饿</strong>，因为如果是读线程先拿到锁的话，并且后续有很多读线程，但只有一个写线程，很有可能这个写线程拿不到锁，它可能要等到所有读线程读完才能进入，就可能会造成一种一直读，没有写的现象。</li></ul><h2 id="3-锁降级"><a href="#3-锁降级" class="headerlink" title="3. 锁降级"></a>3. 锁降级</h2><h3 id="3-1-概述"><a href="#3-1-概述" class="headerlink" title="3.1 概述"></a>3.1 概述</h3><p><strong>概念：</strong></p><p>锁降级的意思就是<strong>写锁降级为读锁</strong>。而读锁是不可以升级为写锁的。如果当前线程拥有写锁，然后将其释放，最后再获取读锁，这种分段完成的过程不能称之为锁降级。锁降级是指把持住（当前拥有的）写锁，再获取到读锁，随后释放（先前拥有的）写锁的过程，最后释放读锁的过程。</p><p><strong>编程模型：</strong></p><p>获取写锁—&gt;获取读锁—&gt;释放写锁—&gt;释放读锁</p><p><strong>代码演示</strong></p><pre><code class="highlight java"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ReadWriteLockDemo2</span> &#123;    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;        <span class="type">ReentrantReadWriteLock</span> <span class="variable">reentrantReadWriteLock</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ReentrantReadWriteLock</span>();        <span class="comment">// 获取读锁</span>        ReentrantReadWriteLock.<span class="type">WriteLock</span> <span class="variable">writeLock</span> <span class="operator">=</span> reentrantReadWriteLock.writeLock();        <span class="comment">// 获取写锁</span>        ReentrantReadWriteLock.<span class="type">ReadLock</span> <span class="variable">readLock</span> <span class="operator">=</span> reentrantReadWriteLock.readLock();                <span class="comment">//1、获取到写锁</span>        writeLock.lock();        System.out.println(<span class="string">&quot;获取到了写锁&quot;</span>);                <span class="comment">//2、获取到读锁</span>        readLock.lock();        System.out.println(<span class="string">&quot;继续获取到读锁&quot;</span>);        <span class="comment">//3、释放写锁</span>        writeLock.unlock();   <span class="comment">//4、 释放读锁</span>        readLock.unlock();    &#125;&#125;</code></pre><p>结果：</p><pre><code class="highlight shell">获取到了写锁继续获取到读锁</code></pre><p>也许大家觉得看不出什么，但是如果将获取读锁那一行代码调到获取写锁上方去，可能结果就完全不一样拉。</p><pre><code class="highlight java"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ReadWriteLockDemo2</span> &#123;    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;        <span class="type">ReentrantReadWriteLock</span> <span class="variable">reentrantReadWriteLock</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ReentrantReadWriteLock</span>();        <span class="comment">// 获取读锁</span>        ReentrantReadWriteLock.<span class="type">WriteLock</span> <span class="variable">writeLock</span> <span class="operator">=</span> reentrantReadWriteLock.writeLock();        <span class="comment">// 获取写锁</span>        ReentrantReadWriteLock.<span class="type">ReadLock</span> <span class="variable">readLock</span> <span class="operator">=</span> reentrantReadWriteLock.readLock();        <span class="comment">//1、 获取到读锁</span>        readLock.lock();        System.out.println(<span class="string">&quot;获取到了读锁&quot;</span>);        writeLock.lock();        System.out.println(<span class="string">&quot;继续获取到写锁&quot;</span>);        writeLock.unlock();        readLock.unlock();    &#125;&#125;</code></pre><p>结果：执行到读锁就停止了，即读锁不能升级为写锁。</p><pre><code class="highlight shell">获取到了读锁</code></pre><p><strong>原因：</strong></p><p>因为在线程持有读锁的情况下，该线程不能取得写锁（因为获取写锁的前提条件是，当前没有读者线程，也没有其他写者线程，如果发现当前的读锁被占用，就马上获取失败，不管读锁是不是被当前线程持有)。</p><p>但是在线程持有写锁的情况下，该线程可以继续获取读锁（获取读锁时如果发现写锁被占用，只有写锁没有被当前线程占用的情况才会获取失败）。</p><p>当线程获取读锁的时候，可能有其他线程同时也在持有读锁，因此不能把获取读锁的线程“升级”为写锁；而对于获得写锁的线程，它一定独占了读写锁，因此可以继续让它获取读锁，当它同时获取了写锁和读锁后，还可以先释放写锁继续持有读锁，这样一个写锁就“降级”为了读锁。</p><h3 id="3-2-使用场景"><a href="#3-2-使用场景" class="headerlink" title="3.2 使用场景"></a>3.2 使用场景</h3><p>对于数据比较敏感, 需要在对数据修改以后, 获取到修改后的值, 并进行接下来的其它操作.</p><p>我们来看个比较实在的案例：</p><pre><code class="highlight java"><span class="keyword">import</span> java.util.HashMap;<span class="keyword">import</span> java.util.Map;<span class="keyword">import</span> java.util.concurrent.locks.Lock;<span class="keyword">import</span> java.util.concurrent.locks.ReadWriteLock;<span class="keyword">import</span> java.util.concurrent.locks.ReentrantReadWriteLock;<span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">CacheDemo</span> &#123;    <span class="comment">/**</span><span class="comment">     * 缓存器,这里假设需要存储1000左右个缓存对象，按照默认的负载因子0.75，则容量=750，大概估计每一个节点链表长度为5个</span><span class="comment">     * 那么数组长度大概为：150,又有雨设置map大小一般为2的指数，则最近的数字为：128</span><span class="comment">     */</span>    <span class="keyword">private</span> Map&lt;String, Object&gt; map = <span class="keyword">new</span> <span class="title class_">HashMap</span>&lt;&gt;(<span class="number">128</span>);    <span class="keyword">private</span> <span class="type">ReadWriteLock</span> <span class="variable">rwl</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ReentrantReadWriteLock</span>();    <span class="keyword">private</span> Lock writeLock=rwl.writeLock();    <span class="keyword">private</span> Lock readLock=rwl.readLock();    <span class="keyword">public</span> Object <span class="title function_">get</span><span class="params">(String id)</span> &#123;        <span class="type">Object</span> <span class="variable">value</span> <span class="operator">=</span> <span class="literal">null</span>;        readLock.lock();<span class="comment">//首先开启读锁，从缓存中去取</span>        <span class="keyword">try</span> &#123;            <span class="comment">//如果缓存中没有  释放读锁，上写锁</span>            <span class="keyword">if</span> (map.get(id) == <span class="literal">null</span>) &#123;                 readLock.unlock();                writeLock.lock();                <span class="keyword">try</span> &#123;                    <span class="comment">//防止多写线程重复查询赋值</span>                    <span class="keyword">if</span> (value == <span class="literal">null</span>) &#123;                        <span class="comment">//此时可以去数据库中查找，这里简单的模拟一下</span>                        value = <span class="string">&quot;redis-value&quot;</span>;                      &#125;                    <span class="comment">//加读锁降级写锁,不明白的可以查看上面锁降级的原理与保持读取数据原子性的讲解</span>                    readLock.lock();                 &#125; <span class="keyword">finally</span> &#123;                    <span class="comment">//释放写锁</span>                    writeLock.unlock();                 &#125;            &#125;        &#125; <span class="keyword">finally</span> &#123;            <span class="comment">//最后释放读锁</span>            readLock.unlock();         &#125;        <span class="keyword">return</span> value;    &#125;&#125;</code></pre><p>如果不使用锁降级功能，如先释放写锁，然后获得读锁，在这个获取读锁的过程中，可能会有其他线程竞争到写锁 或者是更新数据 则获得的数据是其他线程更新的数据，可能会造成数据的污染，即产生脏读的问题。</p><h3 id="3-4-锁降级的必要性"><a href="#3-4-锁降级的必要性" class="headerlink" title="3.4 锁降级的必要性"></a>3.4 锁降级的必要性</h3><p>锁降级中读锁的获取是否必要呢？</p><p>答案是必要的。主要是为了保证数据的可见性，如果当前线程不获取读锁而是直接释放写锁， 假设此刻另一个线程（记作线程T）获取了写锁并修改了数据，那么当前线程无法感知线程T的数据更新。如果当前线程获取读锁，即遵循锁降级的步骤，则线程T将会被阻塞，直到当前线程使用数据并释放读锁之后，线程T才能获取写锁进行数据更新。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;一、Synchronized&quot;&gt;&lt;a href=&quot;#一、Synchronized&quot; class=&quot;headerlink&quot; title=&quot;一、Synchronized&quot;&gt;&lt;/a&gt;一、Synchronized&lt;/h1&gt;&lt;h2 id=&quot;1-Synchronized-关键</summary>
      
    
    
    
    <category term="JUC" scheme="https://georgechan95.github.io/categories/JUC/"/>
    
    
    <category term="juc" scheme="https://georgechan95.github.io/tags/juc/"/>
    
    <category term="java" scheme="https://georgechan95.github.io/tags/java/"/>
    
  </entry>
  
  <entry>
    <title>01-多线程的基本概念</title>
    <link href="https://georgechan95.github.io/blog/4e6bd685.html"/>
    <id>https://georgechan95.github.io/blog/4e6bd685.html</id>
    <published>2024-08-30T11:03:01.000Z</published>
    <updated>2024-08-31T03:39:29.138Z</updated>
    
    <content type="html"><![CDATA[<h1 id="一、进程和线程"><a href="#一、进程和线程" class="headerlink" title="一、进程和线程"></a>一、进程和线程</h1><ul><li>进程（Process）是计算机中的程序关于某数据集合上的一次运行活动，是系统进行资源分配和调度的基本单位，是操作系统结构的基础。在早期面向进程设计的计算机结构中，进程是程序的基本执行实体；在当代面向线程设计的计算机结构中，进程是线程的容器。程序是指令、数据及其组织形式的描述，进程是程序的实体。</li><li>线程（thread）是操作系统能够进行运算调度的最小单位。它被包含在进程之中，是进程中的实际运作单位。一条线程指的是进程中一个单一顺序的控制流，一个进程中可以并发多个线程，每条线程并行执行不同的任务。</li></ul><p>总结来说：</p><ul><li>进程：指在系统中正在运行的一个应用程序；程序一旦运行就是进程；进程是资源分配的最小单位</li><li>线程：系统分配处理器时间资源的基本单元，或者说进程之内独立执行的一个单元执行流。线程时程序执行的最小单位</li></ul><h1 id="二、线程的状态"><a href="#二、线程的状态" class="headerlink" title="二、线程的状态"></a>二、线程的状态</h1><p>进入 java.lang.Thread 类，找到内部类 State ，代码如下</p><pre><code class="highlight java"><span class="keyword">public</span> <span class="keyword">enum</span> <span class="title class_">State</span> &#123;        <span class="comment">/**</span><span class="comment">         * Thread state for a thread which has not yet started.</span><span class="comment">         */</span>        NEW,(新建)        <span class="comment">/**</span><span class="comment">         * Thread state for a runnable thread.  A thread in the runnable</span><span class="comment">         * state is executing in the Java virtual machine but it may</span><span class="comment">         * be waiting for other resources from the operating system</span><span class="comment">         * such as processor.</span><span class="comment">         */</span>        RUNNABLE,（准备就绪）        <span class="comment">/**</span><span class="comment">         * Thread state for a thread blocked waiting for a monitor lock.</span><span class="comment">         * A thread in the blocked state is waiting for a monitor lock</span><span class="comment">         * to enter a synchronized block/method or</span><span class="comment">         * reenter a synchronized block/method after calling</span><span class="comment">         * &#123;<span class="doctag">@link</span> Object#wait() Object.wait&#125;.</span><span class="comment">         */</span>        BLOCKED,（阻塞）        <span class="comment">/**</span><span class="comment">         * Thread state for a waiting thread.</span><span class="comment">         * A thread is in the waiting state due to calling one of the</span><span class="comment">         * following methods:</span><span class="comment">         * &lt;ul&gt;</span><span class="comment">         *   &lt;li&gt;&#123;<span class="doctag">@link</span> Object#wait() Object.wait&#125; with no timeout&lt;/li&gt;</span><span class="comment">         *   &lt;li&gt;&#123;<span class="doctag">@link</span> #join() Thread.join&#125; with no timeout&lt;/li&gt;</span><span class="comment">         *   &lt;li&gt;&#123;<span class="doctag">@link</span> LockSupport#park() LockSupport.park&#125;&lt;/li&gt;</span><span class="comment">         * &lt;/ul&gt;</span><span class="comment">         *</span><span class="comment">         * &lt;p&gt;A thread in the waiting state is waiting for another thread to</span><span class="comment">         * perform a particular action.</span><span class="comment">         *</span><span class="comment">         * For example, a thread that has called &lt;tt&gt;Object.wait()&lt;/tt&gt;</span><span class="comment">         * on an object is waiting for another thread to call</span><span class="comment">         * &lt;tt&gt;Object.notify()&lt;/tt&gt; or &lt;tt&gt;Object.notifyAll()&lt;/tt&gt; on</span><span class="comment">         * that object. A thread that has called &lt;tt&gt;Thread.join()&lt;/tt&gt;</span><span class="comment">         * is waiting for a specified thread to terminate.</span><span class="comment">         */</span>        WAITING,（不限时间等待）        <span class="comment">/**</span><span class="comment">         * Thread state for a waiting thread with a specified waiting time.</span><span class="comment">         * A thread is in the timed waiting state due to calling one of</span><span class="comment">         * the following methods with a specified positive waiting time:</span><span class="comment">         * &lt;ul&gt;</span><span class="comment">         *   &lt;li&gt;&#123;<span class="doctag">@link</span> #sleep Thread.sleep&#125;&lt;/li&gt;</span><span class="comment">         *   &lt;li&gt;&#123;<span class="doctag">@link</span> Object#wait(long) Object.wait&#125; with timeout&lt;/li&gt;</span><span class="comment">         *   &lt;li&gt;&#123;<span class="doctag">@link</span> #join(long) Thread.join&#125; with timeout&lt;/li&gt;</span><span class="comment">         *   &lt;li&gt;&#123;<span class="doctag">@link</span> LockSupport#parkNanos LockSupport.parkNanos&#125;&lt;/li&gt;</span><span class="comment">         *   &lt;li&gt;&#123;<span class="doctag">@link</span> LockSupport#parkUntil LockSupport.parkUntil&#125;&lt;/li&gt;</span><span class="comment">         * &lt;/ul&gt;</span><span class="comment">         */</span>        TIMED_WAITING,（限时等待）        <span class="comment">/**</span><span class="comment">         * Thread state for a terminated thread.</span><span class="comment">         * The thread has completed execution.</span><span class="comment">         */</span>        TERMINATED;(终结)&#125;</code></pre><ul><li>NEW,(新建)</li><li>RUNNABLE,（准备就绪）</li><li>BLOCKED,（阻塞）</li><li>WAITING,（不限时等待）</li><li>TIMED_WAITING,（限时等待）</li><li>TERMINATED;(终结)</li></ul><h1 id="三、wait和sleep"><a href="#三、wait和sleep" class="headerlink" title="三、wait和sleep"></a>三、wait和sleep</h1><ul><li>sleep 是 Thread 的静态方法，wait 是 Object 的方法，任何对象实例都能调用。</li><li>sleep 不会释放锁，它也不需要占用锁；wait会释放锁，但调用它的前提是当前线程占有锁（即代码要在synchronized中）</li><li>它们都可以被 <code>interrupt</code> 方法中断</li></ul><p><img src="https://raw.githubusercontent.com/GeorgeChan95/blogimg/master/img/2024/08/30/20240830-191847.png" alt="线程状态"></p><h1 id="四、并发与并行"><a href="#四、并发与并行" class="headerlink" title="四、并发与并行"></a>四、并发与并行</h1><ul><li>并发：同一时间间隔内多个线程正在执行，实际上是宏观上并行，微观上串行</li><li>并行：同一时刻多个线程正在执行</li></ul><h1 id="五、管程（monitor）"><a href="#五、管程（monitor）" class="headerlink" title="五、管程（monitor）"></a>五、管程（monitor）</h1><p>管程(monitor)是保证了同一时刻只有一个进程在管程内活动,即管程内定义的操作在同一时刻只被一个进程调用(由编译器实现).但是这样并不能保证进程以设计的顺序执行。</p><p>JVM 中同步是基于进入和退出管程(monitor)对象实现的，每个对象都会有一个管程(monitor)对象，管程(monitor)会随着 java 对象一同创建和销毁。</p><p>执行线程首先要持有管程对象，然后才能执行方法，当方法完成之后会释放管程，方法在执行时候会持有管程，其他线程无法再获取同一个管程</p><h1 id="六、用户线程和守护线程"><a href="#六、用户线程和守护线程" class="headerlink" title="六、用户线程和守护线程"></a>六、用户线程和守护线程</h1><ul><li><strong>用户线程</strong>：自定义线程</li><li><strong>守护线程</strong>:运行在后台,是一种特殊的线程,比如垃圾回收</li><li>当主线程结束后,用户线程还在运行,JVM 存活</li><li>如果没有用户线程,都是守护线程,JVM 结束</li></ul>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;一、进程和线程&quot;&gt;&lt;a href=&quot;#一、进程和线程&quot; class=&quot;headerlink&quot; title=&quot;一、进程和线程&quot;&gt;&lt;/a&gt;一、进程和线程&lt;/h1&gt;&lt;ul&gt;
&lt;li&gt;进程（Process）是计算机中的程序关于某数据集合上的一次运行活动，是系统进行资源分配</summary>
      
    
    
    
    <category term="JUC" scheme="https://georgechan95.github.io/categories/JUC/"/>
    
    
    <category term="juc" scheme="https://georgechan95.github.io/tags/juc/"/>
    
    <category term="java" scheme="https://georgechan95.github.io/tags/java/"/>
    
  </entry>
  
  <entry>
    <title>第二十五章-分析GC日志</title>
    <link href="https://georgechan95.github.io/blog/1b0522f4.html"/>
    <id>https://georgechan95.github.io/blog/1b0522f4.html</id>
    <published>2024-08-28T13:36:08.000Z</published>
    <updated>2024-08-28T08:47:45.286Z</updated>
    
    <content type="html"><![CDATA[<h1 id="一、GC日志参数"><a href="#一、GC日志参数" class="headerlink" title="一、GC日志参数"></a>一、GC日志参数</h1><ul><li><p><code>-verbose:gc</code></p><p>输出gc日志信息，默认输出到标准输出</p></li><li><p><code>-XX:+PrintGC</code></p><p>输出GC日志。类似：-verbose:gc</p></li><li><p><code>-XX:+PrintGCDetails</code></p><p>在发生垃圾回收时打印内存回收详细的日志，并在进程退出时输出当前内存各区域分配情况</p></li><li><p><code>-XX:+PrintGCTimeStamps</code></p><p>输出GC发生时的时间截</p></li><li><p><code>-XX:+PrintGCDateStamps</code></p><p>输出GC发生时的时间戳（以日期的形式，如 2013-05-04T21:53:59.234+0800)</p></li><li><p><code>-XX:+PrintHeapAtGC</code></p><p>每一次GC前和GC后，都打印堆信息</p></li><li><p><code>-Xloggc:&lt;file&gt;</code></p><p>表示把GC日志写入到一个文件中去，而不是打印到标准输出中</p></li></ul><h1 id="二、GC日志格式"><a href="#二、GC日志格式" class="headerlink" title="二、GC日志格式"></a>二、GC日志格式</h1><h2 id="1-GC分类"><a href="#1-GC分类" class="headerlink" title="1. GC分类"></a>1. GC分类</h2><p>针对 HotSpot VM 的实现，它里面的GC按照回收区域又分为两大种类型：一种是部分收集（Partial GC), 一种是整堆收集（Full GC)</p><h3 id="1-1-部分收集"><a href="#1-1-部分收集" class="headerlink" title="1.1 部分收集"></a>1.1 部分收集</h3><p>不是完整收集整个Java堆的垃圾收集。</p><p>其中又分为：</p><ul><li>新生代收集（Minor GC&#x2F;Young GC):只是新生代（Eden\S0,S1)的垃圾收集</li><li>老年代收集（Major GC&#x2F;old GC):只是老年代的垃圾收集。<ul><li>目前，只有CMSGC会有单独收集老年代的行为。</li><li>注意，很多时候Major GC会和Full GC混淆使用，需要具体分辨是老年代回收还是整堆回收。</li></ul></li><li>混合收集（Mixed GC):收集整个新生代以及部分老年代的垃圾收集。<ul><li>目前，只有G1GC会有这种行为</li></ul></li></ul><h3 id="1-2-整堆收集（Full-GC"><a href="#1-2-整堆收集（Full-GC" class="headerlink" title="1.2 整堆收集（Full GC)"></a>1.2 整堆收集（Full GC)</h3><p>收集整个java堆和方法区的垃圾收集。</p><p><strong>哪些情况会触发Full GC?</strong></p><ul><li>老年代空间不足</li><li>方法区空间不足</li><li>显式调用System.gc()</li><li>Minor GC进入老年代的数据的平均大小大于老年代的可用内存</li><li>大对象直接进入老年代，而老年代的可用空间不足</li></ul><h2 id="2-GC日志分类"><a href="#2-GC日志分类" class="headerlink" title="2. GC日志分类"></a>2. GC日志分类</h2><h3 id="2-1-MinorGC"><a href="#2-1-MinorGC" class="headerlink" title="2.1 MinorGC"></a>2.1 MinorGC</h3><p>MinorGC(或young GC或YGC)日志：</p><p>[GC (Allocation Failure) [PSYoungGen: 131584K-&gt;7195K(153088K)] 131584K-&gt;7203K(502784K), 0.0334432 secs] [Times: user&#x3D;0.02 sys&#x3D;0.00, real&#x3D;0.04 secs]</p><p><img src="https://raw.githubusercontent.com/GeorgeChan95/blogimg/master/img/2024/08/28/20240828-140528.png" alt="minorGC日志解析"></p><h3 id="2-2-FullGC"><a href="#2-2-FullGC" class="headerlink" title="2.2 FullGC"></a>2.2 FullGC</h3><p>[Full GC (Metadata GC Threshold) [PSYoungGen: 2848K-&gt;0K(158720K)] [ParOldGen: 32816K-&gt;19441K(349696K)] 35664K-&gt;19441K(508416K), [Metaspace: 34044K-&gt;34044K(1079296K)], 0.1156700 secs] [Times: user&#x3D;0.09 sys&#x3D;0.00, real&#x3D;0.12 secs]</p><p><img src="https://raw.githubusercontent.com/GeorgeChan95/blogimg/master/img/2024/08/28/20240828-140956.png" alt="fullGC日志解析"></p><h2 id="3-GC日志结构剖析"><a href="#3-GC日志结构剖析" class="headerlink" title="3. GC日志结构剖析"></a>3. GC日志结构剖析</h2><h3 id="3-1-垃圾收集器"><a href="#3-1-垃圾收集器" class="headerlink" title="3.1  垃圾收集器"></a>3.1  垃圾收集器</h3><ul><li>使用 <code>Serial</code> 收集器在新生代的名字是 <code>Default New Generation</code> , 因此显示的是”[DefNew”</li><li>使用 <code>ParNew</code> 收集器在新生代的名字会变成”[ParNew” , 意思是”Parallel New Generation”</li><li>使用 <code>Parallel Scavenge</code> 收集器在新生代的名字是”[PSYoungGen”,这里的JDK1.7使用的就是<code>PSYoungGen</code></li><li>使用 <code>Parallel Old Generation</code> 收集器在老年代的名字是”[ParOldGen”</li><li>使用G1收集器的话，会显示为”garbage-first heap”</li></ul><p><strong>Allocation Failure</strong></p><p>表明本次引起GC的原因是因为在年轻代中没有足够的空间能够存储新的数据了。</p><h3 id="3-2-GC前后情况"><a href="#3-2-GC前后情况" class="headerlink" title="3.2 GC前后情况"></a>3.2 GC前后情况</h3><p>通过图示，我们可以发现GC日志格式的规律一般都是：GC前内存占用 一&gt; GC后内存占用（该区域内存总大小）</p><p>[PSYoungGen: 5986K -&gt; 696K(8704K)] 5986K -&gt; 704K(9216K)</p><p>中括号内：GC回收前年轻代堆大小，回收后大小，(<strong>年轻代堆总大小</strong>）</p><p>括号外：GC回收前年轻代和老年代大小，回收后大小，(<strong>年轻代和老年代总大小</strong>）</p><h3 id="3-3-GC时间"><a href="#3-3-GC时间" class="headerlink" title="3.3 GC时间"></a>3.3 GC时间</h3><p>GC日志中有三个时间：user , sys 和 real</p><ul><li><strong>user</strong> - 进程执行用户态代码（核心之外）所使用的时间。这是执行此进程所使用的实际CPU时间，其他进程和此进程阻塞的时间并不包括在内。在垃圾收集的情况下，表示GC线程执行所使用的CPU总时间。</li><li><strong>sys</strong> - 进程在内核态消耗的CPU时间，即在内核执行系统调用或等待系统事件所使用的CPU时间</li><li><strong>real</strong> - 程序从开始到结束所用的时钟时间。这个时间包括其他进程使用的时间片和进程阻塞的时间（比如等待I&#x2F;0完成）。对于并行gc,这个数字应该接近（用户时间+系统时间）除以垃圾收集器使用的线程数。</li></ul><p>由于多核的原因，一般的GC事件中，real time是小于 <code>sys + user time</code> 的，因为一般是多个线程并发的去做 GC,所以real time是要小于 sys+user time 的。<br> 如果 <code>real &gt; sys+user</code> 的话，则你的应用可能存在下列问题：IO负载非常重 或者是CPU不够用。</p><h2 id="4-Minor-GC-日志解析"><a href="#4-Minor-GC-日志解析" class="headerlink" title="4. Minor GC 日志解析"></a>4. Minor GC 日志解析</h2><p>2024-08-28T15:09:58.253+0800: 2.004: [GC (Allocation Failure) [PSYoungGen: 138937K-&gt;7465K(153088K)] 138945K-&gt;7473K(502784K), 0.0261046 secs] [Times: user&#x3D;0.01 sys&#x3D;0.00, real&#x3D;0.03 secs]</p><ul><li><p>2024-08-28T15:09:58.253+0800</p><p><strong>日志打印时间日期格式</strong></p></li><li><p>2.004</p><p><strong>gc发生时，Java虚拟机启动以来经过的秒数</strong></p></li><li><p>[GC (Allocation Failure) </p><p><strong>发生了一次垃圾回收，这是一次MinorGC</strong></p><p>它不区分新生代还是老年代GC，括号里的内容是gc发生的原因，这里的Allocation Failure的原因是新生代中没有足够区域能够存放需要分配的数据而失败</p></li><li><p>[PSYoungGen: 138937K-&gt;7465K(153088K)] </p><ul><li>PSYoungGen：表示GC发生的区域，区域名称与使用的GC收集器是密切相关的<ul><li>Serial收集器：Default New Generation 显示Defnew</li><li>ParNew收集器：ParNew</li><li>Parallel Scanvenge收集器：PSYoung</li><li>老年代和新生代同理，也是和收集器名称相关</li></ul></li><li>138937K-&gt;7465K(153088K)：GC前该内存区域已使用容量-&gt;GC后该区域容量(该区域总容量)<ul><li>如果是新生代，总容量则会显示整个新生代内存的9&#x2F;10，即eden+from&#x2F;to区</li><li>如果是老年代，总容量则是全身内存大小，无变化</li></ul></li></ul></li><li><p>138945K-&gt;7473K(502784K)</p><p>虽然本次是Minor GC，只会进行新生代的垃圾收集，但是也肯定会打印堆中总容量相关信息</p><p>在显示完区域容量GC的情况之后，会接着显示整个堆内存区域的GC情况：GC前堆内存已使用容量-&gt;GC后堆内存容量（堆内存总容量），并且堆内存总容量 &#x3D; 9&#x2F;10 新生代 + 老年代，然后堆内存总容量肯定小于初始化的内存大小</p></li><li><p>0.0261046 secs</p><p>整个GC所花费的时间，单位是秒</p></li><li><p>[Times: user&#x3D;0.01 sys&#x3D;0.00, real&#x3D;0.03 secs]</p><ul><li>user：指CPU工作在用户态所花费的时间</li><li>sys：指CPU工作在内核态所花费的时间</li><li>real：指在此次事件中所花费的总时间</li></ul></li></ul><h2 id="5-Full-GC-日志解析"><a href="#5-Full-GC-日志解析" class="headerlink" title="5. Full GC 日志解析"></a>5. Full GC 日志解析</h2><p>2024-08-28T15:10:01.578+0800: 5.329: [Full GC (Metadata GC Threshold) [PSYoungGen: 3264K-&gt;0K(163840K)] [ParOldGen: 6227K-&gt;7621K(349696K)] 9491K-&gt;7621K(513536K), [Metaspace: 20472K-&gt;20472K(1067008K)], 0.0627380 secs] [Times: user&#x3D;0.04 sys&#x3D;0.00, real&#x3D;0.06 secs]</p><h3 id="5-1-日志分解与解释"><a href="#5-1-日志分解与解释" class="headerlink" title="5.1 日志分解与解释"></a>5.1 日志分解与解释</h3><pre><code class="highlight plaintext">2024-08-28T15:10:01.578+0800: 5.329: [Full GC (Metadata GC Threshold) [PSYoungGen: 3264K-&gt;0K(163840K)] [ParOldGen: 6227K-&gt;7621K(349696K)] 9491K-&gt;7621K(513536K), [Metaspace: 20472K-&gt;20472K(1067008K)], 0.0627380 secs] [Times: user=0.04 sys=0.00, real=0.06 secs]</code></pre><ol><li><strong>时间戳</strong>: <code>2024-08-28T15:10:01.578+0800</code><ul><li>这表示日志条目的日期和时间。<code>+0800</code> 表示时区偏移量（例如，北京时间为 UTC+8）。</li></ul></li><li><strong>GC 事件触发时间</strong>: <code>5.329</code><ul><li>表示从 JVM 启动到 GC 事件发生的时间，单位是秒。这表明在 JVM 启动后的 5.329 秒，发生了一个 Full GC。</li></ul></li><li><strong>GC 类型</strong>: <code>[Full GC (Metadata GC Threshold)]</code><ul><li><code>Full GC</code> 表示一次 Full Garbage Collection，即对整个堆（包括年轻代和老年代）进行的垃圾回收。</li><li><code>Metadata GC Threshold</code> 是此次 GC 的触发原因。它表明是因为元数据（如类的元信息）达到了特定的阈值，导致了 Full GC。<ul><li>Full GC (Ergonomics) : JVM , 自适应调整导致的GC</li><li>Full GC(System) : 调用了System.gc()方法</li></ul></li></ul></li><li><strong>年轻代回收</strong>: <code>[PSYoungGen: 3264K-&gt;0K(163840K)]</code><ul><li><strong>PSYoungGen</strong>: 使用 Parallel Scavenge（并行清除）垃圾回收器的年轻代（Young Generation）。</li><li><code>3264K-&gt;0K</code>: 表示在回收前年轻代占用 3264 KB 内存，回收后占用 0 KB。</li><li><code>(163840K)</code>: 年轻代的总容量是 163840 KB（160 MB）。</li></ul></li><li><strong>老年代回收</strong>: <code>[ParOldGen: 6227K-&gt;7621K(349696K)]</code><ul><li><strong>ParOldGen</strong>: 使用并行老年代垃圾回收器（Parallel Old Generation）。</li><li><code>6227K-&gt;7621K</code>: 表示在回收前老年代占用 6227 KB 内存，回收后增加到 7621 KB。这通常表示有一些对象从年轻代晋升到老年代。</li><li><code>(349696K)</code>: 老年代的总容量是 349696 KB（341.5 MB）。</li></ul></li><li><strong>堆总内存使用情况</strong>: <code>9491K-&gt;7621K(513536K)</code><ul><li><code>9491K-&gt;7621K</code>: 表示在 GC 前整个堆（年轻代 + 老年代）使用的总内存为 9491 KB，GC 后减少到 7621 KB。</li><li><code>(513536K)</code>: 堆的总容量是 513536 KB（501.25 MB）。</li></ul></li><li><strong>元空间（Metaspace）</strong>: <code>[Metaspace: 20472K-&gt;20472K(1067008K)]</code><ul><li><code>20472K-&gt;20472K</code>: 表示元空间（用于存储类的元数据）的使用量在 GC 前后保持不变，为 20472 KB。</li><li><code>(1067008K)</code>: 元空间的总容量是 1067008 KB（1042 MB）。</li></ul></li><li><strong>GC 事件耗时</strong>: <code>0.0627380 secs</code><ul><li>表示 GC 事件的总持续时间为 0.0627380 秒（约 62 毫秒）。</li></ul></li><li><strong>GC 时间分解</strong>: <code>[Times: user=0.04 sys=0.00, real=0.06 secs]</code><ul><li><code>user=0.04</code>: 用户态 CPU 时间（多个 CPU 线程的总和）是 0.04 秒。</li><li><code>sys=0.00</code>: 内核态 CPU 时间是 0.00 秒。</li><li><code>real=0.06</code>: 真实时间，即 GC 事件的墙钟时间是 0.06 秒。这个值通常比 <code>user</code> 和 <code>sys</code> 时间之和略大，反映了多线程并行执行的情况。</li></ul></li></ol><h1 id="三、GC日志分析工具"><a href="#三、GC日志分析工具" class="headerlink" title="三、GC日志分析工具"></a>三、GC日志分析工具</h1><p>上节介绍了GC日志的打印及含义，但是GC日志看起来比较麻烦，本节将会介绍一下GC日志可视化分析工具GCeasy和GCviewer等。通过GC日志可视化分析工具，我们可以很方便的看到JVM各个分代的内存使用情况、垃圾回收次数、垃圾回收的原因、垃圾回收占用的时间、吞吐量等，这些指标在我们进行JVM调优的时候是很有用的。</p><p>如果想把GC日志存到文件的话，是下面这个参数：</p><pre><code class="highlight shell">-Xloggc:/path/to/gc.log<span class="meta prompt_"># </span><span class="language-bash">示例</span>java -Xms512m -Xmx512m -XX:+PrintGCDetails -XX:+PrintGCDateStamps -Xloggc:/opt/module/ioms/ioms-ums/gc-%t.log -jar ioms-ums.jar --spring.profiles.active=dev</code></pre><p>然后就可以用一些工具去分析这些gc日志。</p><p><strong>示例代码1</strong></p><pre><code class="highlight java"><span class="comment">/**</span><span class="comment"> * 测试生成详细的日志文件</span><span class="comment"> *</span><span class="comment"> * -Xms60m -Xmx60m -XX:SurvivorRatio=8 -XX:+PrintGCDetails -XX:+PrintGCDateStamps -XX:+PrintHeapAtGC -Xloggc:d:/gc-log-%t.log</span><span class="comment"> *</span><span class="comment"> */</span><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">GCLogTest</span> &#123;    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;        ArrayList&lt;<span class="type">byte</span>[]&gt; list = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; <span class="number">5000</span>; i++) &#123;            <span class="type">byte</span>[] arr = <span class="keyword">new</span> <span class="title class_">byte</span>[<span class="number">1024</span> * <span class="number">50</span>];<span class="comment">//50KB</span>            list.add(arr);            <span class="keyword">try</span> &#123;                Thread.sleep(<span class="number">30</span>);            &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;                e.printStackTrace();            &#125;        &#125;    &#125;&#125;</code></pre><p><strong>示例代码2</strong></p><pre><code class="highlight java"><span class="comment">/**</span><span class="comment"> * java.lang.OutOfMemoryError: Metaspace异常演示：</span><span class="comment"> *</span><span class="comment"> * -Xms60m -Xmx60m -XX:MetaspaceSize=10m -XX:MaxMetaspaceSize=10m -XX:SurvivorRatio=8 -XX:+PrintGCDetails -XX:+PrintGCTimeStamps -XX:+PrintGCDateStamps -XX:+PrintHeapAtGC -Xloggc:d:/meta-log-%t.log</span><span class="comment"> *</span><span class="comment"> */</span><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">MetaspaceOOM</span> <span class="keyword">extends</span> <span class="title class_">ClassLoader</span> &#123;    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;        <span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> <span class="number">0</span>;        <span class="keyword">try</span> &#123;            <span class="type">MetaspaceOOM</span> <span class="variable">test</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">MetaspaceOOM</span>();            <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; <span class="number">10000</span>; i++) &#123;                <span class="comment">//创建ClassWriter对象，用于生成类的二进制字节码</span>                <span class="type">ClassWriter</span> <span class="variable">classWriter</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ClassWriter</span>(<span class="number">0</span>);                <span class="comment">//指明版本号，修饰符，类名，包名，父类，接口</span>                classWriter.visit(Opcodes.V1_8, Opcodes.ACC_PUBLIC, <span class="string">&quot;Class&quot;</span> + i, <span class="literal">null</span>, <span class="string">&quot;java/lang/Object&quot;</span>, <span class="literal">null</span>);                <span class="comment">//返回byte[]</span>                <span class="type">byte</span>[] code = classWriter.toByteArray();                <span class="comment">//类的加载</span>                test.defineClass(<span class="string">&quot;Class&quot;</span> + i, code, <span class="number">0</span>, code.length);<span class="comment">//Class对象</span>                j++;            &#125;        &#125; <span class="keyword">finally</span> &#123;            System.out.println(j);        &#125;    &#125;&#125;</code></pre><h2 id="1-GCeasy"><a href="#1-GCeasy" class="headerlink" title="1. GCeasy"></a>1. GCeasy</h2><p><strong>基本概述</strong></p><p>GCeasy——一款超好用的在线分析GC日志的网站官网地址：<a href="https://gceasy.io/gc-dashboard.jsp">https://gceasy.io/gc-dashboard.jsp</a></p><p>GCeasy是一款在线的GC日志分析器，可以通过GC日志分析进行内存泄漏检测、GC暂停原因分析、JVM配置建议优化等功能，而且是可以免费使用的（有一些服务是收费的）。</p><p><img src="https://raw.githubusercontent.com/GeorgeChan95/blogimg/master/img/2024/08/28/20240828-160343.png" alt="GCeasy官网"></p><p><strong>分析结果</strong></p><p><img src="https://raw.githubusercontent.com/GeorgeChan95/blogimg/master/img/2024/08/28/20240828-160459.png" alt="内存分析"></p><p><img src="https://raw.githubusercontent.com/GeorgeChan95/blogimg/master/img/2024/08/28/20240828-160520.png" alt="gc时间分析"></p><p><img src="https://raw.githubusercontent.com/GeorgeChan95/blogimg/master/img/2024/08/28/20240828-160833.png" alt="堆的使用"></p><p><img src="https://raw.githubusercontent.com/GeorgeChan95/blogimg/master/img/2024/08/28/20240828-160741.png" alt="GC统计"></p><p>等等……</p><h2 id="2-GCViewer"><a href="#2-GCViewer" class="headerlink" title="2. GCViewer"></a>2. GCViewer</h2><h3 id="2-1-基本概述"><a href="#2-1-基本概述" class="headerlink" title="2.1 基本概述"></a>2.1 基本概述</h3><p><code>GCViewer</code> 是一个免费的、开源的分析小工具，用于可视化查看由SUN&#x2F;Oracle,IBM,HP和BEA Java虚拟机产生的垃圾收集器的日志。</p><p>GCViewer用于可视化Java VM选项 <code>-verbose:gc</code> 和.NET生成的数据 <code>-Xloggc:&lt;file&gt;</code> 。它还计算与垃圾回收相关的性能指标（吞吐量，累积的暂停，最长的暂停等）。当通过更改世代大小或设置初始堆大小来调整特定应用程序的垃圾回收时，此功能非常有用。</p><h3 id="2-2-安装"><a href="#2-2-安装" class="headerlink" title="2.2 安装"></a>2.2 安装</h3><p><strong>下载GCViewer工具</strong></p><ul><li>源码下载: <a href="https://github.com/chewiebug/GCViewer">https://github.com/chewiebug/GCViewer</a></li><li>运行版本下载: <a href="https://github.com/chewiebug/GCViewer/wiki/Changelog">https://github.com/chewiebug/GCViewer/wiki/Changelog</a></li></ul><h3 id="2-3-启动GCViewer-gui"><a href="#2-3-启动GCViewer-gui" class="headerlink" title="2.3 启动GCViewer(gui)"></a>2.3 启动GCViewer(gui)</h3><p>需双击 <code>gcviewer-1.3x.jar</code></p><p>或</p><p>需要运行java1.8 vm</p><pre><code class="highlight shell">java -jar gcviewer-1.3x.jar</code></pre><p><img src="https://raw.githubusercontent.com/GeorgeChan95/blogimg/master/img/2024/08/28/20240828-162437.png" alt="GCViewer"></p><p>很难用！！！</p><h2 id="3-其他工具"><a href="#3-其他工具" class="headerlink" title="3. 其他工具"></a>3. 其他工具</h2><h3 id="3-1-GChisto"><a href="#3-1-GChisto" class="headerlink" title="3.1 GChisto"></a>3.1 GChisto</h3><p><code>GChisto</code> 是一款专业分析gc日志的工具，可以通过gc日志来分析 : MinorGC、Full GC的次数、频率、持续时间等，通过列表、报表、图表等不同形式来反应gc的情况。</p><p>虽然界面略显粗糙，但是功能还是不错的。</p><p>官网上没有下载的地方，需要自己从SVN上拉下来编译，不过这个工具似乎没怎么维护了，存在不少bug</p><h3 id="3-2-HPjmeter"><a href="#3-2-HPjmeter" class="headerlink" title="3.2 HPjmeter"></a>3.2 HPjmeter</h3><p>工具很强大，但只能打开由以下参数生成的 <code>GC log</code> , <code>-verbose:gc</code> <code>-Xloggc:gc.log</code> 。添加其他参数生成的 gc.log无法打开</p><p>HPjmeter集成了以前的 <code>HPjtune</code> 功能，可以分析在HP机器上产生的垃圾回收日志文件</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;一、GC日志参数&quot;&gt;&lt;a href=&quot;#一、GC日志参数&quot; class=&quot;headerlink&quot; title=&quot;一、GC日志参数&quot;&gt;&lt;/a&gt;一、GC日志参数&lt;/h1&gt;&lt;ul&gt;
&lt;li&gt;&lt;p&gt;&lt;code&gt;-verbose:gc&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;输出gc日</summary>
      
    
    
    
    <category term="JVM" scheme="https://georgechan95.github.io/categories/JVM/"/>
    
    
    <category term="java" scheme="https://georgechan95.github.io/tags/java/"/>
    
    <category term="jvm" scheme="https://georgechan95.github.io/tags/jvm/"/>
    
  </entry>
  
  <entry>
    <title>第二十四章-JVM运行时参数</title>
    <link href="https://georgechan95.github.io/blog/944806143.html"/>
    <id>https://georgechan95.github.io/blog/944806143.html</id>
    <published>2024-08-27T10:30:10.000Z</published>
    <updated>2024-08-28T04:17:33.350Z</updated>
    
    <content type="html"><![CDATA[<h1 id="一、JVM参数选项"><a href="#一、JVM参数选项" class="headerlink" title="一、JVM参数选项"></a>一、JVM参数选项</h1><p>官网地址：<a href="https://docs.oracle.com/javase/8/docs/technotes/tools/unix/java.html">https://docs.oracle.com/javase/8/docs/technotes/tools/unix/java.html</a></p><h2 id="1-类型一：标准参数选项"><a href="#1-类型一：标准参数选项" class="headerlink" title="1. 类型一：标准参数选项"></a>1. 类型一：标准参数选项</h2><h3 id="1-1-特点"><a href="#1-1-特点" class="headerlink" title="1.1 特点"></a>1.1 特点</h3><ul><li>比较稳定，后续版本基本不会变化</li><li>以 <code>-</code> 开头</li></ul><h3 id="1-2-各种选项"><a href="#1-2-各种选项" class="headerlink" title="1.2 各种选项"></a>1.2 各种选项</h3><p>运行 <code>java</code> 或者 <code>java-help</code> 可以看到所有的标准选项</p><pre><code class="highlight shell">C:\Users\kd&gt;java -help用法: java [-options] class [args...]           (执行类)   或  java [-options] -jar jarfile [args...]           (执行 jar 文件)其中选项包括:    -d32          使用 32 位数据模型 (如果可用)    -d64          使用 64 位数据模型 (如果可用)    -server       选择 &quot;server&quot; VM                  默认 VM 是 server.    -cp &lt;目录和 zip/jar 文件的类搜索路径&gt;    -classpath &lt;目录和 zip/jar 文件的类搜索路径&gt;                  用 ; 分隔的目录, JAR 档案                  和 ZIP 档案列表, 用于搜索类文件。    -D&lt;名称&gt;=&lt;值&gt;                  设置系统属性    -verbose:[class|gc|jni]                  启用详细输出    -version      输出产品版本并退出    -version:&lt;值&gt;                  警告: 此功能已过时, 将在                  未来发行版中删除。                  需要指定的版本才能运行    -showversion  输出产品版本并继续    -jre-restrict-search | -no-jre-restrict-search                  警告: 此功能已过时, 将在                  未来发行版中删除。                  在版本搜索中包括/排除用户专用 JRE    -? -help      输出此帮助消息    -X            输出非标准选项的帮助    -ea[:&lt;packagename&gt;...|:&lt;classname&gt;]    -enableassertions[:&lt;packagename&gt;...|:&lt;classname&gt;]                  按指定的粒度启用断言    -da[:&lt;packagename&gt;...|:&lt;classname&gt;]    -disableassertions[:&lt;packagename&gt;...|:&lt;classname&gt;]                  禁用具有指定粒度的断言    -esa | -enablesystemassertions                  启用系统断言    -dsa | -disablesystemassertions                  禁用系统断言    -agentlib:&lt;libname&gt;[=&lt;选项&gt;]                  加载本机代理库 &lt;libname&gt;, 例如 -agentlib:hprof                  另请参阅 -agentlib:jdwp=help 和 -agentlib:hprof=help    -agentpath:&lt;pathname&gt;[=&lt;选项&gt;]                  按完整路径名加载本机代理库    -javaagent:&lt;jarpath&gt;[=&lt;选项&gt;]                  加载 Java 编程语言代理, 请参阅 java.lang.instrument    -splash:&lt;imagepath&gt;                  使用指定的图像显示启动屏幕有关详细信息, 请参阅 http://www.oracle.com/technetwork/java/javase/documentation/index.html。</code></pre><h3 id="1-3-补充内容-server-与-client"><a href="#1-3-补充内容-server-与-client" class="headerlink" title="1.3 补充内容 -server 与 -client"></a>1.3 补充内容 -server 与 -client</h3><p><code>Hotspot JVM</code> 有两种模式，分别是 <code>server</code> 和 <code>client</code> , 分别通过 <code>-server</code> 和 <code>-client</code> 模式设置</p><ul><li><p>在32位Windows系统上，默认使用Client类型的JVM。要想使用 <code>Server</code> 模式，则机器配置至少有2个以上的CPU和2G以上的物理内存。<code>client</code> 模式适用于对内存要求较小的桌面应用程序，默认使用Serial串行垃圾收集器</p></li><li><p>64位机器上只支持server模式的JVM,适用于需要大内存的应用程序，默认使用并行垃圾收集器关于server和client的官网介绍为：<a href="https://docs.oracle.com/javase/8/docs/technotes/guides/vm/index.html">https://docs.oracle.com/javase/8/docs/technotes/guides/vm/index.html</a></p><p><img src="https://raw.githubusercontent.com/GeorgeChan95/blogimg/master/img/2024/08/27/20240827-184239.png" alt="server模式"></p></li></ul><h2 id="2-类型二：-X参数选项"><a href="#2-类型二：-X参数选项" class="headerlink" title="2. 类型二：-X参数选项"></a>2. 类型二：-X参数选项</h2><h3 id="2-1-特点"><a href="#2-1-特点" class="headerlink" title="2.1 特点"></a>2.1 特点</h3><ul><li>非标准化参数</li><li>功能还是比较稳定的，但官方说后续高版本可能变更</li><li>以 <code>-X</code> 开头</li></ul><h3 id="2-2-各种选项"><a href="#2-2-各种选项" class="headerlink" title="2.2 各种选项"></a>2.2 各种选项</h3><p>直接在DOS窗口中运行 <code>java -X</code> 命令可以看到所有的X选项</p><pre><code class="highlight shell">C:\Users\kd&gt;java -X    -Xmixed           混合模式执行 (默认)    -Xint             仅解释模式执行    -Xbootclasspath:&lt;用 ; 分隔的目录和 zip/jar 文件&gt;                      设置搜索路径以引导类和资源    -Xbootclasspath/a:&lt;用 ; 分隔的目录和 zip/jar 文件&gt;                      附加在引导类路径末尾    -Xbootclasspath/p:&lt;用 ; 分隔的目录和 zip/jar 文件&gt;                      置于引导类路径之前    -Xdiag            显示附加诊断消息    -Xnoclassgc       禁用类垃圾收集    -Xincgc           启用增量垃圾收集    -Xloggc:&lt;file&gt;    将 GC 状态记录在文件中 (带时间戳)    -Xbatch           禁用后台编译    -Xms&lt;size&gt;        设置初始 Java 堆大小    -Xmx&lt;size&gt;        设置最大 Java 堆大小    -Xss&lt;size&gt;        设置 Java 线程堆栈大小    -Xprof            输出 cpu 配置文件数据    -Xfuture          启用最严格的检查, 预期将来的默认值    -Xrs              减少 Java/VM 对操作系统信号的使用 (请参阅文档)    -Xcheck:jni       对 JNI 函数执行其他检查    -Xshare:off       不尝试使用共享类数据    -Xshare:auto      在可能的情况下使用共享类数据 (默认)    -Xshare:on        要求使用共享类数据, 否则将失败。    -XshowSettings    显示所有设置并继续    -XshowSettings:all                      显示所有设置并继续    -XshowSettings:vm 显示所有与 vm 相关的设置并继续    -XshowSettings:properties                      显示所有属性设置并继续    -XshowSettings:locale                      显示所有与区域设置相关的设置并继续-X 选项是非标准选项, 如有更改, 恕不另行通知。</code></pre><h3 id="2-3-JVM的JIT编译模式相关的选项"><a href="#2-3-JVM的JIT编译模式相关的选项" class="headerlink" title="2.3 JVM的JIT编译模式相关的选项"></a>2.3 JVM的JIT编译模式相关的选项</h3><ul><li><p><code>-Xint</code> : 只使用解释器：所有字节码都被解释执行，这个模式的速度是很慢的</p></li><li><p><code>-Xcomp</code> : 只使用编译器：所有字节码第一次使用就被编译成本地代码，然后在执行</p></li><li><p>-Xmixed : 混合模式：这是默认模式，刚开始的时候使用解释器慢慢解释执行，后来让JIT即时编译器根据程序运行的情况，有选择地将某些热点代码提前编译并缓存在本地，在执行的时候效率就非常高了</p><p><img src="https://raw.githubusercontent.com/GeorgeChan95/blogimg/master/img/2024/08/27/20240827-185220.png" alt="默认使用混合模式"></p></li></ul><h3 id="2-4-参数特别说明"><a href="#2-4-参数特别说明" class="headerlink" title="2.4 参数特别说明"></a>2.4 参数特别说明</h3><ul><li><code>-Xms&lt;size&gt;</code> ：设置初始Java堆大小，等价于 <code>-XX:InitialHeapSize</code></li><li><code>-Xmx&lt;size&gt;</code> ：设置最大Java堆大小，等价于 <code>-XX:MaxHeapSize</code></li><li><code>-Xss&lt;size&gt;</code> ：设置Java线程堆栈大小，等价于 <code>-XX:ThreadStackSize</code></li></ul><p>单位：k&#x2F;K、m&#x2F;M、g&#x2F;G<br>设置：-Xmx、-Xms 最好设置成一样的值，避免扩容带来的损耗</p><h2 id="3-类型三：-XX参数选项"><a href="#3-类型三：-XX参数选项" class="headerlink" title="3. 类型三：-XX参数选项"></a>3. 类型三：-XX参数选项</h2><h3 id="3-1-特点"><a href="#3-1-特点" class="headerlink" title="3.1 特点"></a>3.1 特点</h3><ul><li>非标准化参数</li><li>使用的最多的参数类型</li><li>这类选项属于实验性，不稳定</li><li>以 <code>-XX</code> 开头</li></ul><h3 id="3-2-作用"><a href="#3-2-作用" class="headerlink" title="3.2 作用"></a>3.2 作用</h3><p>用于开发和调试JVM</p><h3 id="3-3-分类"><a href="#3-3-分类" class="headerlink" title="3.3 分类"></a>3.3 分类</h3><h4 id="3-3-1-Boolean类型格式"><a href="#3-3-1-Boolean类型格式" class="headerlink" title="3.3.1 Boolean类型格式"></a>3.3.1 Boolean类型格式</h4><ul><li><p><code>-XX:+&lt;option&gt;</code>  表示启用option属性</p></li><li><p><code>-XX:-&lt;option&gt;</code>  表示禁用option属性</p></li></ul><p><strong>举例</strong></p><ul><li><p><code>-XX:+UseParallelGC</code> 选择垃圾收集器为并行收集器</p></li><li><p><code>-XX:+UseG1GC</code> 表示启用G1收集器</p></li><li><p><code>-XX:+UseAdaptiveSizePolicy</code> 自动选择年轻代区大小和相应的Survivor区比例</p></li></ul><p><strong>说明</strong></p><p>说明：因为有的指令默认是开启的，所以可以使用 <code>-</code> 关闭</p><h4 id="3-3-2-非Boolean类型格式（key-value类型）"><a href="#3-3-2-非Boolean类型格式（key-value类型）" class="headerlink" title="3.3.2 非Boolean类型格式（key-value类型）"></a>3.3.2 非Boolean类型格式（key-value类型）</h4><ul><li><p>数值型格式 <code>-XX:&lt;option&gt;=&lt;number&gt;</code></p><p><code>number</code> 表示数值，<code>number</code> 可以带上单位</p><p>比如：<br><code>m</code> 、<code>M</code> 表示 兆<br><code>k</code> 、<code>K</code> 表示 <code>Kb</code><br><code>g</code> 、<code>G</code> 表示 <code>g</code> ( 例如 : <code>32k</code> 跟 <code>32768</code> 是一样的效果 ）</p><p><strong>举例</strong></p><ul><li><p>设置新生代初始大小为1024兆</p><pre><code class="highlight shell">-XX:NewSize=1024m</code></pre></li><li><p>设置GC停顿时间：500毫秒</p><pre><code class="highlight shell">-XX:MaxGCPauseMillis=500</code></pre></li><li><p>设置吞吐量</p><pre><code class="highlight shell">-XX:GCTimeRatio=19</code></pre></li><li><p>新生代与老年代的比例</p><pre><code class="highlight shell">-XX:NewRatio=2</code></pre></li></ul></li><li><p>非数值型格式 <code>-XX:&lt;name&gt;=&lt;string&gt;</code></p><p><strong>举例</strong></p><ul><li><p>指定heap转存文件的存储路径</p><pre><code class="highlight shell">-XX:HeapDumpPath=/usr/local/heapdump.hprof</code></pre></li></ul></li></ul><h3 id="3-4-特别参数说明"><a href="#3-4-特别参数说明" class="headerlink" title="3.4 特别参数说明"></a>3.4 特别参数说明</h3><p><code>-XX:+PrintFlagsFinal</code> : 输出所有参数的名称和默认值</p><p>默认不包括 <code>Diagnostic</code>(诊断) 和 <code>Experimental</code>(实验) 的参数</p><p>可以配合 <code>-XX:+UnlockDiagnosticVMOptions</code> 和 <code>-XX:UnlockExperimentalVMOptions</code> 使用</p><h1 id="二、添加JVM参数选项"><a href="#二、添加JVM参数选项" class="headerlink" title="二、添加JVM参数选项"></a>二、添加JVM参数选项</h1><h2 id="1-Eclipse"><a href="#1-Eclipse" class="headerlink" title="1. Eclipse"></a>1. Eclipse</h2><ol><li><p>在空白处单击右键，选择Run As，在选择Run Configurations……</p><p><img src="https://raw.githubusercontent.com/GeorgeChan95/blogimg/master/img/2024/08/27/20240827-192230.png" alt="eclipse添加JVM选项1"></p></li><li><p>设置虚拟机参数</p><p><img src="https://raw.githubusercontent.com/GeorgeChan95/blogimg/master/img/2024/08/27/20240827-192311.png" alt="eclipse添加JVM选项2"></p></li></ol><h2 id="2-IDEA"><a href="#2-IDEA" class="headerlink" title="2. IDEA"></a>2. IDEA</h2><ol><li><p>Edit Configurations…</p><p><img src="https://raw.githubusercontent.com/GeorgeChan95/blogimg/master/img/2024/08/27/20240827-192358.png" alt="IDEA添加JVM选项1"></p></li><li><p>设置虚拟机参数</p><p><img src="https://raw.githubusercontent.com/GeorgeChan95/blogimg/master/img/2024/08/27/20240827-192428.png" alt="IDEA添加JVM选项2"></p></li></ol><h2 id="3-运行jar包"><a href="#3-运行jar包" class="headerlink" title="3. 运行jar包"></a>3. 运行jar包</h2><p>java -Xms500m -Xmx500m -XX:+PrintGCDetails -XX:+PrintGCTimeStamps -jar demo.jar</p><p>这是在java -jar demo.jar中的java -jar之间添加了虚拟机配置信息</p><h2 id="4-通过Tomcat运行war包"><a href="#4-通过Tomcat运行war包" class="headerlink" title="4. 通过Tomcat运行war包"></a>4. 通过Tomcat运行war包</h2><ul><li>Linux系统下可以在 tomcat&#x2F;bin&#x2F;catalina.sh 中添加类似如下配置：JAVA_OPTS&#x3D;”-Xms512M -Xmx1024M”</li><li>Windows系统下载 catalina.bat 中添加类似如下配置：set “JAVA_OPTS&#x3D;-Xms512M -Xmx1024M”</li></ul><h2 id="5-程序运行过程中"><a href="#5-程序运行过程中" class="headerlink" title="5. 程序运行过程中"></a>5. 程序运行过程中</h2><p><code>jinfo</code> 不仅可以查看运行时某一个 Java 虚拟机参数的实际取值，甚至可以在运行时修改部分参数，并使之立即生效。</p><p>但是，并非所有参数都支持动态修改。参数只有被标记为 manageable 的 flag 可以被实时修改。其实，这个修改能力是极其有限的。</p><p><strong>查看被标记为 manageable 的参数</strong></p><p><code>java -XX:+PrintFlagsFinal -version | grep &quot;manageable&quot;</code> 可以查看标记为 <code>manageable</code> 的参数</p><pre><code class="highlight shell">root@ubuntu:~# java -XX:+PrintFlagsFinal -version | grep &quot;manageable&quot;     intx CMSAbortablePrecleanWaitMillis            = 100                                 &#123;manageable&#125;     intx CMSTriggerInterval                        = -1                                  &#123;manageable&#125;     intx CMSWaitDuration                           = 2000                                &#123;manageable&#125;     bool HeapDumpAfterFullGC                       = false                               &#123;manageable&#125;     bool HeapDumpBeforeFullGC                      = false                               &#123;manageable&#125;     bool HeapDumpOnOutOfMemoryError                = false                               &#123;manageable&#125;    ccstr HeapDumpPath                              =                                     &#123;manageable&#125;    uintx MaxHeapFreeRatio                          = 100                                 &#123;manageable&#125;    uintx MinHeapFreeRatio                          = 0                                   &#123;manageable&#125;     bool PrintClassHistogram                       = false                               &#123;manageable&#125;     bool PrintClassHistogramAfterFullGC            = false                               &#123;manageable&#125;     bool PrintClassHistogramBeforeFullGC           = false                               &#123;manageable&#125;     bool PrintConcurrentLocks                      = false                               &#123;manageable&#125;     bool PrintGC                                   = false                               &#123;manageable&#125;     bool PrintGCDateStamps                         = false                               &#123;manageable&#125;     bool PrintGCDetails                            = false                               &#123;manageable&#125;     bool PrintGCID                                 = false                               &#123;manageable&#125;     bool PrintGCTimeStamps                         = false                               &#123;manageable&#125;java version &quot;1.8.0_261&quot;Java(TM) SE Runtime Environment (build 1.8.0_261-b12)Java HotSpot(TM) 64-Bit Server VM (build 25.261-b12, mixed mode)</code></pre><ul><li><p>设置非Boolean类型参数</p><p><code>jinfo -flag &lt;name&gt;=&lt;value&gt; &lt;pid&gt;</code></p></li><li><p>设置Boolean类型参数</p><p><code>jinfo -flag [+|-] &lt;name&gt; &lt;pid&gt;</code></p><p>示例： jinfo -flag +PrintGCDetails 29536</p></li></ul><h1 id="三、常用的JVM参数选项"><a href="#三、常用的JVM参数选项" class="headerlink" title="三、常用的JVM参数选项"></a>三、常用的JVM参数选项</h1><h2 id="1-打印设置的XX选项及值"><a href="#1-打印设置的XX选项及值" class="headerlink" title="1. 打印设置的XX选项及值"></a>1. 打印设置的XX选项及值</h2><ul><li><p>-XX:+PrintCommandLineFlags 可以让程序运行前打印出用户手动设置或者JVM自动设置的XX选项</p></li><li><p>-XX:+PrintFlagsInitial 表示打印出所有XX选项的默认值</p></li><li><p>-XX:+PrintFlagsFinal 表示打印出XX选项在运行程序时生效的值</p><p>如果值的前面加上了 <code>:=</code> ，说明该值不是初始值，该值可能被 jvm 自动改变了，也可能被我们设置的参数改变了，如下所示：</p><p><img src="https://raw.githubusercontent.com/GeorgeChan95/blogimg/master/img/2024/08/27/20240827-200720.png" alt="PrintFlagsFinal"></p></li><li><p>-XX:+PrintVMOptions 打印JVM的参数</p></li></ul><h2 id="2-堆、栈、方法区等内存大小设置"><a href="#2-堆、栈、方法区等内存大小设置" class="headerlink" title="2. 堆、栈、方法区等内存大小设置"></a>2. 堆、栈、方法区等内存大小设置</h2><h3 id="2-1-栈"><a href="#2-1-栈" class="headerlink" title="2.1 栈"></a>2.1 栈</h3><ul><li>-Xss128k 或 -XX:ThreadStackSize&#x3D;128k ：设置每个线程的栈大小为128k</li></ul><h3 id="2-2-堆内存"><a href="#2-2-堆内存" class="headerlink" title="2.2 堆内存"></a>2.2 堆内存</h3><ul><li>-Xms3550m 或 -XX:InitialHeapSize&#x3D;3550m ：设置JVM初始堆内存为3550M</li><li>-Xmx3550m 或 -XX:MaxHeapSize&#x3D;3550m ：设置JVM最大堆内存为3550M</li><li>-Xmn2g ：设置年轻代大小为2G, 官方推荐配置为整个堆大小的3&#x2F;8</li><li>-XX:NewSize&#x3D;1024m：设置年轻代初始值为1024M</li><li>-XX:MaxNewSize&#x3D;1024m ：设置年轻代最大值为1024M</li><li>-XX:SurvivorRatio&#x3D;8 ：设置年轻代中Eden区与一个Survivor区的比值，默认为8</li><li>-XX:+UseAdaptiveSizePolicy ：自动选择各区大小比例</li><li>-XX:NewRatio&#x3D;4 ：设置<strong>老年代</strong>与<strong>年轻代</strong>（包括1个Eden和2个Survivor区）的比值</li><li>-XX:PretenureSizeThreadshold&#x3D;1024 ：设置让大于此阀值的对象直接分配在老年代，单位为字节<br>只对Serial、ParNew收集器有效</li><li>-XX:MaxTenuringThreshold&#x3D;15 ：新生代每次 <code>MinorGC</code> 后，还存活的对象年龄 + 1 , 当对象的年龄大于设置的这个值时就进入老年代,默认值为15</li><li>-XX:+PrintTenuringDistribution ：每次 <code>MinorGC</code> 后打印出当前使用的 <code>Survivor</code> 中对象的年龄分布</li><li>-XX:TargetSurvivorRatio ：<code>MinorGC</code> 结束后 <code>Survivor</code> 区域中占用空间的期望比例</li></ul><h3 id="2-3-方法区"><a href="#2-3-方法区" class="headerlink" title="2.3 方法区"></a>2.3 方法区</h3><h4 id="2-3-1-永久代"><a href="#2-3-1-永久代" class="headerlink" title="2.3.1 永久代"></a>2.3.1 永久代</h4><ul><li>-XX:PermSize&#x3D;256m  ：设置<strong>永久代初始值</strong>为256M</li><li>-XX:MaxPermSize&#x3D;256m ：设置永久代最大值为256M</li></ul><h4 id="2-3-2-元空间"><a href="#2-3-2-元空间" class="headerlink" title="2.3.2 元空间"></a>2.3.2 元空间</h4><ul><li>-XX:MetaspaceSize ：初始空间大小</li><li>-XX:MaxMetaspaceSize ：最大空间，默认没有限制</li><li>-XX:+UseCompressedOops ：压缩对象指针</li><li>-XX:+UseCompressedClassPointers ：压缩类指针</li><li>-XX:CompressedClassSpaceSize ：设置Klass Metaspace的大小，默认1G</li></ul><h3 id="2-4-直接内存"><a href="#2-4-直接内存" class="headerlink" title="2.4 直接内存"></a>2.4 直接内存</h3><ul><li>-XX:MaxDirectMemorySize ：指定 DirectMemory 容量，若未指定，则默认与Java堆最大值一样</li></ul><h2 id="3-OutOfMemory相关的选项"><a href="#3-OutOfMemory相关的选项" class="headerlink" title="3. OutOfMemory相关的选项"></a>3. OutOfMemory相关的选项</h2><ul><li><p>-XX:+HeapDumpOnOutOfMemoryError ：内存出现OOM的时候，把Heap转存（Dump)到文件以便后续分析</p></li><li><p>-XX:+HeapDumpBeforeFullGC ：在出现FullGC之前，生成Heap转储文件</p></li><li><p><code>-XX:HeapDumpPath=&lt;path&gt;</code> ：指定heap转存文件的存储路径</p></li><li><p>-XX:OnOutOfMemoryError ：指定一个程序或者脚本的路径，当发生OOM的时候，去执行这个脚本</p><p><strong>举例：</strong></p><p>以部署在linux系统 <code>/opt/Server</code> 目录下的 <code>ioms-ums.jar</code> 为例</p><ul><li><p>在 <code>run.sh</code> 启动脚本中添加jvm参数：</p><pre><code class="highlight shell">-XX:OnOutOfMemoryError=/opt/Server/restart.sh</code></pre></li><li><p>restart.sh 脚本</p><ul><li><p>linux环境：</p><pre><code class="highlight shell"><span class="meta prompt_">#</span><span class="language-bash">!/bin/bash</span>pid=$(ps -ef|grep ioms-ums.jar|awk &#x27;&#123;if($8==&quot;java&quot;) &#123;print $2&#125;&#125;&#x27;)kill -9 $pidcd /opt/Server/;sh run.sh</code></pre></li><li><p>Windows环境：</p><pre><code class="highlight shell">echo offwmic process where Name=&#x27;java.exe&#x27; deletecd D:\Serverstart run.bat</code></pre></li></ul></li></ul></li></ul><h2 id="4-垃圾收集器相关选项"><a href="#4-垃圾收集器相关选项" class="headerlink" title="4. 垃圾收集器相关选项"></a>4. 垃圾收集器相关选项</h2><p>7款经典收集器与垃圾分代之间的关系 :</p><p><img src="https://raw.githubusercontent.com/GeorgeChan95/blogimg/master/img/2024/08/27/20240827-203512.png" alt="垃圾收集器分代关系"></p><p>垃圾收集器的组合关系 :</p><p><img src="https://raw.githubusercontent.com/GeorgeChan95/blogimg/master/img/2024/08/27/20240827-203533.png" alt="垃圾收集器的组合关系"></p><h3 id="4-1-查看默认垃圾收集器"><a href="#4-1-查看默认垃圾收集器" class="headerlink" title="4.1 查看默认垃圾收集器"></a>4.1 查看默认垃圾收集器</h3><ul><li><p><code>-XX:+PrintCommandLineFlags</code> 查看命令行相关参数（包含使用的垃圾收集器）</p></li><li><p><code>jinfo -flag 相关垃圾回收器参数 进程ID</code>，作用：使用命令行指令</p><ul><li><p>注意：只能修改被标记为 manageable 的参数</p><p>java -XX:+PrintFlagsFinal -version | grep “manageable”</p></li></ul><p>示例：jinfo -flag +PrintGCDetails 29536</p></li></ul><h3 id="4-2-Serial回收器"><a href="#4-2-Serial回收器" class="headerlink" title="4.2 Serial回收器"></a>4.2 Serial回收器</h3><p><code>Serial</code> 收集器作为HotSpot中client模式下的 <strong>默认新生代垃圾收集器</strong>。<code>Serial Old</code> 是运行在 <code>Client</code> 模式下默认的老年代的垃圾回收器。</p><ul><li><p><code>-XX:+UseSerialGC</code></p><p>指定年轻代和老年代都使用串行收集器</p><p>等价于新生代用 <code>Serial GC</code> , 且老年代用 <code>Serial Old GC</code> 。可以获得最高的单线程收集效率</p></li></ul><h3 id="4-3-ParNew回收器"><a href="#4-3-ParNew回收器" class="headerlink" title="4.3 ParNew回收器"></a>4.3 ParNew回收器</h3><ul><li><p><code>-XX:+UseParNewGC</code></p><p>手动指定使用 <code>ParNew</code> 收集器执行内存回收任务。</p><p>它表示年轻代使用并行收集器，不影响老年代。</p></li><li><p><code>-XX:ParallelGCThreads=N</code></p><p>限制线程数量，默认开启和CPU数据相同的线程数</p></li></ul><h3 id="4-4-Parallel回收器"><a href="#4-4-Parallel回收器" class="headerlink" title="4.4 Parallel回收器"></a>4.4 Parallel回收器</h3><ul><li><p><code>-XX:+UseParallelGC</code> </p><p>手动指定<strong>年轻代</strong>使用 <code>Parallel</code> <strong>并行收集器</strong>执行内存回收任务</p></li><li><p><code>-XX:+UseParallelOldGC</code></p><p>手动指定老年代都是使用并行回收收集器。</p></li></ul><p>分别适用于新生代和老年代。默认jdk8是开启的。</p><p>上面两个参数，默认开启一个，另一个也会被开启。（互相激活）</p><ul><li><p><code>-XX:ParallelGCThreads</code> </p><p>设置年轻代并行收集器的线程数。<br>一般地，最好与CPU数量相等，以避免过多的线程数影响垃圾收集性能。</p><p>在默认情况下，当CPU数量小于8个，ParallelGCThreads的值等于CPU数量。<br>当CPU数量大于8个，ParallelGCThreads 的值 &#x3D; 3 + [ 5 * CPU_Count] &#x2F; 8 ]</p></li><li><p><code>-XX:MaxGCPauseMillis</code></p><p>设置垃圾收集器<strong>最大停顿时间</strong>（即STW的时间）。单位是毫秒。</p><ul><li>为了尽可能地把停顿时间控制在 <code>MaxGCPauseMills</code> 以内，收集器在工作时会调整Java堆大小 或 其他一些参数。</li><li>对于用户来讲，停顿时间越短体验越好。但是在服务器端，我们注重高并发，整体的吞吐量。所以服务器端适合Parallel , 进行控制。</li><li>该参数使用需谨慎。</li></ul></li><li><p><code>-XX:GCTimeRatio</code></p><p>垃圾收集时间占总时间的比例（ &#x3D;1 &#x2F; ( N + 1 ) )。用于衡量<strong>吞吐量</strong>的大小。</p><ul><li>取值范围（ 0 , 100 )。默认值99 , 也就是垃圾回收时间不超过1%</li><li>与前一个 <code>-XX:MaxGCPauseMillis</code> 参数有一定矛盾性。暂停时间越长，Radio参数就容易超过设定的比例</li></ul></li><li><p><code>-XX:+UseAdaptiveSizePolicy</code></p><p>设置 <code>Parallel Scavenge</code> 收集器具有自适应调节策略</p><ul><li><p>在这种模式下，<strong>年轻代</strong>的大小、<code>Eden</code> 和 <code>Survivor</code> 的比例、晋升<strong>老年代</strong>的对象年龄等参数会被自动调整，已达到在<strong>堆大小</strong>、<strong>吞吐量</strong>和<strong>停顿时间</strong>之间的平衡点。</p></li><li><p>在手动调优比较困难的场合，可以直接使用这种自适应的方式，仅指定虚拟机的<strong>最大堆</strong>、目标的<strong>吞吐量</strong>（ <code>GCTimeRatio</code> )和<strong>停顿时间</strong>（ <code>MaxGCPauseMills</code> ) , 让虚拟机自己完成调优工作。</p></li></ul></li></ul><h3 id="4-5-CMS回收器"><a href="#4-5-CMS回收器" class="headerlink" title="4.5 CMS回收器"></a>4.5 CMS回收器</h3><ul><li><p><code>-XX:+UseConcMarkSweepGC</code></p><p>手动指定使用CMS 收集器执行内存回收任务</p><ul><li>开启该参数后会自动将 <code>-XX:+UseParNewGC</code> 打开。即：ParNew ( Young区用）+ CMS(Old区用）+ <code>Serial Old</code> 的组合。</li></ul></li><li><p><code>-XX:CMSlnitiatingoccupanyFraction</code></p><p>设置堆内存使用率的阀值，一旦达到该阀值，便开始进行回收。</p><ul><li>JDK5及以前版本的默认值为68 , 即当老年代的空间使用率达到68%时，会执行一次CMS回收。JDK6及以上版本默认值为92%</li><li>如果内存增长缓慢，则可以设置一个稍大的值，大的阙值可以有效降低CMS的触发频率，减少老年代回收的次数可以较为明显地改善应用程序性能。反之，如果应用程序内存使用率增长很快，则应该降低这个阙值，以避免频繁触发老年代串行收集器。因此通过该选项便可以有效降低Full GC 的执行次数。</li></ul></li><li><p><code>-XX:+UseCMSComlpactAtFullCollection</code></p><p>用于指定在执行完Full GC后对内存空间进行压缩整理，以此避免内存碎片的产生。</p><ul><li>不过由于内存压缩整理过程无法并发执行，所带来的问题就是停顿时间变得更长了。</li></ul></li><li><p><code>-XX:CMSFullGCsBeforeCompaction</code></p><p>设置在执行多少次 <code>Full GC</code> 后对内存空间进行压缩整理。</p></li><li><p>-XX:ParallelCMSThreads</p><p>设置CMS的线程数量</p><ul><li>CMS默认启动的线程数是（ParallelGCThreads + 3 ) &#x2F; 4 , <code>ParallelGCThreads</code> 是<strong>年轻代并行收集器</strong>的线程数。当CPU资源比较紧张时，受到CMS收集器线程的影响，应用程序的性能在垃圾回收阶段可能会非常糟糕。</li></ul></li></ul><p><strong>补充参数</strong></p><ul><li><p><code>-XX:ConcGCThreads</code></p><p>设置并发垃圾收集的线程数，默认该值是基于 <code>ParallelGCThreads</code> 计算出来的；</p></li><li><p><code>-XX:+UseCMSInitiatingOccupancyonly</code></p><p>是否动态可调，用这个参数可以使CMS一直按 <code>CMSInitiatingOccupancyFraction</code> 设定的值启动</p></li><li><p><code>-XX:+CMSScavengeBeforeRemark</code></p><p>强制hotspot虚拟机在 <code>cms remark</code> 阶段之前做一次 <code>minor gc</code> ,用于提高 <code>remark</code> 阶段的速度；</p></li><li><p><code>-XX:+CMSClassUnloadingEnable</code></p><p>如果有的话，启用回收Perm区（JDK8之前）</p></li><li><p><code>-XX:+CMSParallelInitialEnabled</code></p><p>用于开启 <code>CMS initial-mark</code> 阶段采用多线程的方式进行标记，用于提高标记速度，在Java8开始已经默认开启；</p></li><li><p><code>-XX:+CMSParallelRemarkEnabled</code></p><p>用户开启<code>CMS remark</code> 阶段采用多线程的方式进行重新标记 , 默认开启；</p></li><li><p><code>-XX:+ExplicitGCInvokesConcurrent</code> <code>-XX:+ExplicitGCInvokesConcurrentAndUnloadsClasses</code></p><p>这两个参数用户指定hotspot虚拟在执行 <code>System.gc()</code> 时使用CMS周期；</p></li><li><p><code>-XX:+CMSPrecleaningEnabled</code></p><p>指定CMS是否需要进行 <code>Pre cleaning</code> 这个阶段</p></li></ul><p><strong>特别说明</strong></p><p>JDK9新特性：<code>CMS</code> 被标记为 <code>Deprecate</code> 了（JEP291)</p><ul><li>如果对JDK9及以上版本的 <code>HotSpot</code> 虚拟机使用参数 <code>-XX:+UseConcMarkSweepGC</code> 来开启CMS收集器的话，用户会收到一个警告信息，提示CMS未来将会被废弃。</li></ul><p>JDK14新特性：删除CMS垃圾回收器（JEP363)</p><ul><li><p>移除了CMS垃圾收集器，如果在JDK14中使用 <code>-XX:+UseConcMarkSweepGC</code> 的话 , JVM不会报错，只是给出一个warning信息，但是不会exit。JVM会自动回退以默认GC方式启动JVM</p><p><img src="https://raw.githubusercontent.com/GeorgeChan95/blogimg/master/img/2024/08/28/20240828-081410.png" alt="JDK14 CMS"></p></li></ul><h3 id="4-6-G1回收器"><a href="#4-6-G1回收器" class="headerlink" title="4.6 G1回收器"></a>4.6 G1回收器</h3><p>如果使用G1垃圾收集器，不建议设置-Xmn和-XX:NewRatio，毕竟可能影响G1的自动调节</p><ul><li><p><code>-XX:+UseG1GC</code></p><p>手动指定使用G1收集器执行内存回收任务。</p></li><li><p><code>-XX:G1HeapRegionSize</code></p><p>设置每个Region的大小。值是2的幂，范围是1MB到32MB之间，目标是根据最小的Java堆大小划分出约2048个区域。默认是堆内存的1&#x2F;2000。</p></li><li><p><code>-XX:MaxGCPauseMillis</code></p><p>设置期望达到的最大GC停顿时间指标（JVM会尽力实现，但不保证达到）。默认值是200ms</p></li><li><p><code>-XX:ParallelGCThread</code>  设置STW时GC线程数的值。最多设置为8</p></li><li><p><code>-XX:ConcGCThreads</code></p><p>设置并发标记的线程数。将n设置为并行垃圾回收线程数（ParallelGCThreads)的1&#x2F;4左右。</p></li><li><p><code>-XX:InitiatingHeapOccupancyPercent</code></p><p>设置触发并发GC周期的Java堆占用率阈值。超过此值，就触发GC。默认值是45。</p></li><li><p><code>-XX:G1NewSizePercent</code> <code>-XX:G1MaxNewSizePercent</code></p><p>新生代占用整个堆内存的最小百分比（默认5%)、最大百分比（默认60%)</p></li><li><p><code>-XX:G1ReservePercent=10</code></p><p>保留内存区域，防止 <code>to space</code> (Survivor中的to区）溢出</p></li></ul><p><strong>Mixed GC调优参数</strong></p><p>注意：G1收集器主要涉及到Mixed GC,Mixed GC会回收young区和部分old区。</p><p>G1关于Mixed GC调优常用参数：</p><ul><li><p><code>-XX:InitiatingHeapOccupancyPercent</code></p><p>设置堆占用率的百分比（0到100)达到这个数值的时候触发global concurrent marking(全局并发标记）,默认为 45%。值为0表示间断进行全局并发标记。</p></li><li><p><code>-XX:G1MixedGCLiveThresholdPercent</code></p><p>设置old区的region被回收时候的对象占比，默认占用率为85%。只有old区的region中存活的对象占用达到了这个百分比 , 才会在Mixed GC中被回收。</p></li><li><p><code>-XX:G1HeapWastePercent</code></p><p>在global concurrent marking(全局并发标记）结束之后，可以知道所有的区有多少空间要被回收，在每次young GC之后和再次发生Mixed GC之前，会检查垃圾占比是否达到此参数，只有达到了，下次才会发生 Mixed GC。</p></li><li><p><code>-XX:G1MixedGCCountTarget</code></p><p>一次global concurrent marking(全局并发标记）之后，最多执行Mixed GC的次数，默认是8。</p></li><li><p><code>-XX:G1OldCSetRegionThresholdPercent</code></p><p>设置Mixed GC收集周期中要收集的Old region数的上限。默认值是Java堆的10%</p></li></ul><h3 id="4-7-怎么选择垃圾回收器"><a href="#4-7-怎么选择垃圾回收器" class="headerlink" title="4.7 怎么选择垃圾回收器"></a>4.7 怎么选择垃圾回收器</h3><ul><li>优先调整堆的大小让JVM自适应完成。</li><li>如果内存小于100M,使用串行收集器</li><li>如果是单核、单机程序，并且没有停顿时间的要求，串行收集器</li><li>如果是多CPU、需要高吞吐量、允许停顿时间超过1秒，选择并行或者JVM自己选择</li><li>如果是多CPU、追求低停顿时间，需快速响应（比如延迟不能超过1秒，如互联网应用),使用并发收集器。官方推荐G1,性能高。现在互联网的项目，基本都是使用G1。</li></ul><p>特别说明：</p><ol><li>没有最好的收集器，更没有万能的收集；</li><li>调优永远是针对特定场景、特定需求，不存在一劳永逸的收集器</li></ol><h2 id="5-GC日志相关选项"><a href="#5-GC日志相关选项" class="headerlink" title="5. GC日志相关选项"></a>5. GC日志相关选项</h2><p>强烈建议看下这篇博客：<a href="https://cloud.tencent.com/developer/article/1916565">https://cloud.tencent.com/developer/article/1916565</a></p><h3 id="5-1-常用参数"><a href="#5-1-常用参数" class="headerlink" title="5.1 常用参数"></a>5.1 常用参数</h3><ul><li><p><code>-verbose:gc</code></p><p>输出gc日志信息，默认输出到标准输出<br>可以独立使用</p></li><li><p><code>-XX:+PrintGC</code></p><p>等同于 <code>-verbose:gc</code> 表示打开简化的GC日志<br>可以独立使用</p></li><li><p><code>-XX:+PrintGCDetails</code></p><p>在发生垃圾回收时打印内存回收详细的日志，并在进程退出时输出当前内存各区域分配情况<br>可以独立使用</p></li><li><p><code>-XX:+PrintGCTimeStamps</code></p><p>输出GC发生时的时间截<br>不可以独立使用，需要配合-XX:+PrintGCDetails使用</p></li><li><p><code>-XX:+PrintGCDateStamps</code></p><p>输出GC发生时的时间戳（以日期的形式，如 2013-05-04T21:53:59.234+0800)<br>不可以独立使用，需要配合-XX:+PrintGCDetails使用</p></li><li><p><code>-XX:+PrintHeapAtGC</code></p><p>每一次GC前和GC后，都打印堆信息<br>可以独立使用</p></li><li><p><code>-Xloggc:&lt;file&gt;</code></p><p>把GC日志写入到一个文件中去，而不是打印到标准输出中</p><pre><code class="highlight shell">java -Xms4096m -Xmx4096m -Xloggc:/tm/gc-%t.log -jar ioms-ums.jar<span class="meta prompt_"># </span><span class="language-bash">或</span>java  -Xms4096m -Xmx4096m -Xloggc:/tm/gc-%t.log -XX:+UseGCLogFileRotation -XX:NumberOfGCLogFiles=3 -XX:GCLogFileSize=512k -jar ioms-ums.jar</code></pre></li></ul><h3 id="5-2-其他参数"><a href="#5-2-其他参数" class="headerlink" title="5.2 其他参数"></a>5.2 其他参数</h3><ul><li><p><code>-XX:+TraceClassLoading</code></p><p>监控类的加载</p></li><li><p><code>-XX:+PrintGCApplicationStoppedTime</code></p><p>打印GC时线程的停顿时间</p></li><li><p><code>-XX:+PrintGCApplicationConcurrentTime</code></p><p>垃圾收集之前打印出应用未中断的执行时间</p></li><li><p><code>-XX:+PrintReferenceGC</code></p><p>记录回收了多少种不同引用类型的引用</p></li><li><p><code>-XX:+PrintTenuringDistribution</code></p><p>让JVM在每次MinorGC后打印出当前使用的Survivor中对象的年龄分布</p></li><li><p><code>-XX:+UseGCLogFileRotation</code></p><p>启用GC日志文件的自动转储</p></li><li><p><code>-XX:NumberOfGClogFiles=1</code></p><p>GC日志文件的循环数目</p></li><li><p><code>-XX:GCLogFileSize=1M</code></p><p>控制GC日志文件的大小</p></li></ul><pre><code class="highlight shell">java  -Xms4096m -Xmx4096m -Xloggc:/tm/gc-%t.log -XX:+UseGCLogFileRotation -XX:NumberOfGCLogFiles=3 -XX:GCLogFileSize=512k -jar ioms-ums.jar</code></pre><h2 id="6-其他参数"><a href="#6-其他参数" class="headerlink" title="6. 其他参数"></a>6. 其他参数</h2><ul><li><p><code>-XX:+DisableExplicitGC</code></p><p>禁止hotspot执行System.gc(),默认禁用</p></li><li><p><code>-XX:ReservedCodeCacheSize=&lt;n&gt;[g|m|k]</code>  <code>-XX:InitialCodeCacheSize=&lt;n&gt;[g|m|k]</code></p><p>指定代码缓存的大小</p></li><li><p><code>-XX:+UseCodeCacheFlushing</code></p><p>使用该参数让jvm放弃一些被编译的代码，避免代码缓存被占满时JVM切换到interpreted-only的情况</p></li><li><p><code>XX:+DoEscapeAnalysis</code>  开启逃逸分析（jdk1.8默认开启）</p></li><li><p><code>-XX:+UseBiasedLocking</code>  开启偏向锁</p></li><li><p><code>-XX:+UseLargePages</code>  开启使用大页面</p></li><li><p><code>-XX:+UseTLAB</code>  使用TLAB,默认打开</p></li><li><p><code>-XX:+PrintTLAB</code>  打印TLAB的使用情况</p></li><li><p><code>-XX:TLABSize</code>  设置TLAB大小</p></li></ul><h1 id="四、通过Java代码获取JVM参数"><a href="#四、通过Java代码获取JVM参数" class="headerlink" title="四、通过Java代码获取JVM参数"></a>四、通过Java代码获取JVM参数</h1><p>Java提供了 <code>java.lang.management</code> 包用于监视和管理Java虚拟机和Java运行时中的其他组件，它允许本地和远程监控和管理运行的Java虚拟机。<br> 其中 <code>ManagementFactory</code> 这个类还是挺常用的。另外还有Runtime类也可以获取一些内存、CPU核数等相关的数据。</p><p>通过这些api可以监控我们的应用服务器的堆内存使用情况，设置一些阀值进行报警等处理。</p><pre><code class="highlight java"><span class="keyword">package</span> com.cpucode.java.operating.parameters;<span class="keyword">import</span> java.lang.management.ManagementFactory;<span class="keyword">import</span> java.lang.management.MemoryMXBean;<span class="keyword">import</span> java.lang.management.MemoryUsage;<span class="comment">/**</span><span class="comment"> * 监控我们的应用服务器的堆内存使用情况，设置一些阈值进行报警等处理</span><span class="comment"> */</span><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">MemoryMonitor</span> &#123;    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;        <span class="type">MemoryMXBean</span> <span class="variable">memoryMXBean</span> <span class="operator">=</span> ManagementFactory.getMemoryMXBean();        <span class="type">MemoryUsage</span> <span class="variable">usage</span> <span class="operator">=</span> memoryMXBean.getHeapMemoryUsage();        System.out.println(<span class="string">&quot;INIT HEAP: &quot;</span> + usage.getInit() / <span class="number">1024</span> / <span class="number">1024</span> + <span class="string">&quot;m&quot;</span>);        System.out.println(<span class="string">&quot;MAX HEAP: &quot;</span> + usage.getMax() / <span class="number">1024</span> / <span class="number">1024</span> + <span class="string">&quot;m&quot;</span>);        System.out.println(<span class="string">&quot;USE HEAP: &quot;</span> + usage.getUsed() / <span class="number">1024</span> / <span class="number">1024</span> + <span class="string">&quot;m&quot;</span>);        System.out.println(<span class="string">&quot;\nFull Information:&quot;</span>);        System.out.println(<span class="string">&quot;Heap Memory Usage: &quot;</span> + memoryMXBean.getHeapMemoryUsage());        System.out.println(<span class="string">&quot;Non-Heap Memory Usage: &quot;</span> + memoryMXBean.getNonHeapMemoryUsage());        System.out.println(<span class="string">&quot;=======================通过java来获取相关系统状态============================ &quot;</span>);        <span class="comment">// 当前堆内存大小</span>        System.out.println(<span class="string">&quot;当前堆内存大小totalMemory &quot;</span> + (<span class="type">int</span>) Runtime.getRuntime().totalMemory() / <span class="number">1024</span> / <span class="number">1024</span> + <span class="string">&quot;m&quot;</span>);        <span class="comment">// 空闲堆内存大小</span>        System.out.println(<span class="string">&quot;空闲堆内存大小freeMemory &quot;</span> + (<span class="type">int</span>) Runtime.getRuntime().freeMemory() / <span class="number">1024</span> / <span class="number">1024</span> + <span class="string">&quot;m&quot;</span>);        <span class="comment">// 最大可用总堆内存大小</span>        System.out.println(<span class="string">&quot;最大可用总堆内存maxMemory &quot;</span> + Runtime.getRuntime().maxMemory() / <span class="number">1024</span> / <span class="number">1024</span> + <span class="string">&quot;m&quot;</span>);    &#125;&#125;</code></pre><p><strong>通过Runtime获取</strong></p><pre><code class="highlight java"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">HeapSpaceInitial</span> &#123;<span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span>&#123;<span class="comment">//返回Java虚拟机中的堆内存总量</span><span class="type">long</span> <span class="variable">initialMemory</span> <span class="operator">=</span> Runtime.getRuntime().totalMemory() / <span class="number">1024</span> / <span class="number">1024</span>;<span class="comment">//返回Java虚拟机试图使用的最大堆内存量</span><span class="type">long</span> <span class="variable">maxMemory</span> <span class="operator">=</span> Runtime.getRuntime().maxMemory() / <span class="number">1024</span> / <span class="number">1024</span>;System.out.println(<span class="string">&quot;-Xms:&quot;</span> + initialMemory + <span class="string">&quot;M&quot;</span>);System.out.println(<span class="string">&quot;-Xmx:&quot;</span> + maxMemory + <span class="string">&quot;M&quot;</span>);System.out.println(<span class="string">&quot;系统内存大小为：&quot;</span> + maxMemory * <span class="number">4.0</span> / <span class="number">1024</span> + <span class="string">&quot;G&quot;</span>);System.out.println(<span class="string">&quot;系统内存大小为：&quot;</span> + initialMemory * <span class="number">64.0</span> / <span class="number">1024</span> + <span class="string">&quot;G&quot;</span>);&#125;&#125;</code></pre>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;一、JVM参数选项&quot;&gt;&lt;a href=&quot;#一、JVM参数选项&quot; class=&quot;headerlink&quot; title=&quot;一、JVM参数选项&quot;&gt;&lt;/a&gt;一、JVM参数选项&lt;/h1&gt;&lt;p&gt;官网地址：&lt;a href=&quot;https://docs.oracle.com/java</summary>
      
    
    
    
    <category term="JVM" scheme="https://georgechan95.github.io/categories/JVM/"/>
    
    
    <category term="java" scheme="https://georgechan95.github.io/tags/java/"/>
    
    <category term="jvm" scheme="https://georgechan95.github.io/tags/jvm/"/>
    
  </entry>
  
</feed>
